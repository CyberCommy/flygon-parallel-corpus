- en: Networking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Sending emails—sending emails from your application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fetching emails—checking and reading newly-received emails in a folder
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: FTP—uploading, listing, and downloading files from FTP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sockets—writing a chat system based on TCP/IP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AsyncIO—an asynchronous HTTP server for static files based on coroutines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remote procedure calls—implementing RPC through XMLRPC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Modern-day applications frequently need to interact with users or other software
    through networks. The more our society moves toward a connected world, the more
    users will expect software to be able to interact with remote services or across
    networks.
  prefs: []
  type: TYPE_NORMAL
- en: Networking-based applications rely on decades of stable and widely-tested tools
    and paradigms, and the Python standard library provides support for the most common
    technologies, from transport to application protocols.
  prefs: []
  type: TYPE_NORMAL
- en: Apart from providing support for the communication channels themselves, such
    as sockets, the standard library also provides the models to implement event-based
    applications that are typical of networking use cases as in most cases, the application
    will have to react to an input coming from the network and handle it accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will see how to handle some of the most common application
    protocols, such as SMTP, IMAP, and FTP. But we will also see how to handle networking
    directly through sockets and how to implement our own protocol for RPC communication.
  prefs: []
  type: TYPE_NORMAL
- en: Sending emails
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Emails are the most widespread communication tool nowadays, if you're on the
    internet, it's pretty much granted you have an email address and they are now
    highly integrated in smartphones too, so are accessible on the go.
  prefs: []
  type: TYPE_NORMAL
- en: For all those reasons, emails are the preferred tools for sending notifications
    to users, reports of completion, and results of long-running processes.
  prefs: []
  type: TYPE_NORMAL
- en: Sending emails requires some machinery and both the SMTP and MIME protocols
    are quite articulated if you want to support them by yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, the Python standard library comes with built-in support for both and
    we can rely on the `smtplib` module to interact with the SMTP server to send our
    email and on `email` package to actually create the content of the email and tackle
    all the special formats and encoding required.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sending an email is a three-step process:'
  prefs: []
  type: TYPE_NORMAL
- en: Contact the SMTP server and authenticate to it
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Prepare the email itself
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Provide the email to the SMTP server
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'All three phases are covered in the Python standard library and we just need
    to wrap them up for convenience in an easier interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `EmailSender` class can be used to easily send emails through our email
    provider:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sending an email requires connecting to an SMTP server, this requires data,
    such as the host on which the server is running, the port where it's exposed,
    and a username and password to authenticate against it.
  prefs: []
  type: TYPE_NORMAL
- en: 'All these details will be needed every time we want to send an email, as each
    email will require a separate connection. So, those are all details that our class
    in charge of sending email will always need to have available and thus are requested
    when the instance is created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Once all the details required to connect to the SMTP server are known, the
    only exposed method of our class is the one to actually send the emails:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Which requires the details needed to compose the email: the sender address,
    the address receiving the email, a subject, and the content of the email itself.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our method has to parse the provided sender and recipient. The part with the
    name of the sender and recipient is separated from the part containing the address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: If `sender` was something like `"Alessandro Molina <amol@myserver.it>"`, `sender_name` would
    be `"Alessandro Molina"` and `sender_addr` would be `"amol@myserver.it"`.
  prefs: []
  type: TYPE_NORMAL
- en: This is required because the name part will frequently contain names that are
    not constrained to plain ASCII, the mail might be delivered to China, or Korea,
    or any other place where you would have to properly support Unicode to handle
    recipient names.
  prefs: []
  type: TYPE_NORMAL
- en: 'So we have to properly encode those characters in a way that mail clients will
    understand when receiving the email, and that is done by using the `Header` class
    with the provided character set encoding, which in our case was `"UTF-8"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the sender and recipient names are encoded in the format expected by email
    headers, we can join them back with the address part to build back a full recipient
    and sender in the `"Name <address>"` form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The same goes for `Subject`, which being a header field of the mail needs to
    be encoded too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The body of the message instead doesn't have to be encoded as a header and can
    be provided as its plain-bytes representation in any encoding as far as the encoding
    is specified.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, the message was built with a body encoded to `UTF-8` too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Then, once the message itself is ready and both the body and headers are properly
    encoded, the only part left is actually getting in touch with the SMTP server
    and sending the email.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is done by creating an `SMTP` object for the known address and port:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in case the SMTP server supports encryption through TLS, we start it.
    If it doesn''t, we just ignore the error and proceed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Once encryption is enabled, if available, we can finally authenticate against
    the SMTP server and send the mail itself to the involved recipient:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'To test that encoding is working as you would expect, you can try sending an
    email with characters that are out of the standard ASCII plane to see whether
    your client properly understands the email:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: If everything worked as expected, you should be able to authenticate against
    your SMTP provider, send the email and see it in your inbox with the proper content.
  prefs: []
  type: TYPE_NORMAL
- en: Fetching emails
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Frequently, applications need to react to some kind of event, they receive a
    message from a user or software and they need to act accordingly. The whole nature
    of networking-based applications lies in reacting to received messages, but a
    very specific and common case of this class of applications are applications that
    need to react to received emails.
  prefs: []
  type: TYPE_NORMAL
- en: The typical case is when a user needs to send some kind of document to your
    application (usually an ID card or signed contracts) and you want to react to
    that event, such as enabling the service once the user sent the signed contract.
  prefs: []
  type: TYPE_NORMAL
- en: This requires us to be able to access the received emails and scan through them
    to detect sender and content.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The steps for this recipe are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using `imaplib` and `email` modules, it''s possible to build a working IMAP
    client to fetch the most recent messages from a supported IMAP server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '`IMAPReader` can then be used to access a compatible mail server to read the
    most recent emails:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This returns the title and timestamp of the last two received emails:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: If we need the actual email content and attachments, we can retrieve them by
    using `peek=False` and then calling `IMAPReader.get_message_body` on the retrieved
    messages.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our class acts as a wrapper over the `imaplib` and `email` modules, providing
    an easier-to-use interface for the need of fetching mail from a folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are actually two different objects that can be created from `imaplib`
    to connect to an IMAP server, one that uses SSL and one that doesn''t. Depending
    on what''s required by your server, you might have to turn it on or off (for example,
    Gmail requires SSL) and that''s abstracted in `__init__`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `__init__` method also takes care of logging you against the IMAP server,
    so that the once the reader is created, it's immediately usable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our reader then provides methods to list folders, so in case you want to read
    messages from all folders or you want to allow users to pick a folder, it''s possible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The first thing our `folders` method does is grab the list of folders from
    the server. The `imaplib` methods already report exceptions themselves in case
    there is an error, but as a safety net, we also check that the response is `OK`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: IMAP is a text-based protocol and the server is supposed to always respond `OK
    <response>` if it was able to understand your request and serve a response. Otherwise,
    a bunch of alternative response codes, such as `NO` or `BAD`, can be returned.
    In case any of those is returned, we consider our request failed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we make sure we actually have the folders list, we need to parse it. The
    list is constituted by multiple lines of text. Each line contains details about
    exactly one folder, the details: flags and folder name. Those are separated by
    a separator, which is not standard. On some servers, it''s a dot, while on others,
    it''s a slash, so we need to be pretty flexible when parsing it. That''s why we
    parse it with a regular expression that allows flags and a name separated by any
    separator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we know how to parse those lines from the response, we can just build
    a list of dictionaries out of them that contain the name and the flags for those
    folders:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The flags themselves can then be parsed further using the `imaplib.ParseFlags`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we know the name of the folder we want to fetch messages for, we can retrieve
    the messages through the `messages` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'As IMAP is a stateful protocol, the first thing we need to do is select the
    folder for which we want to run subsequent commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We provide a `readonly` option so we can't inadvertently destroy our emails,
    and we verify the response code as usual.
  prefs: []
  type: TYPE_NORMAL
- en: Then the content of the response of the `select` method is actually the ID of
    the last message that was uploaded to that folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'As those IDs are incremental numbers, we can use it to generate the IDs of
    the last `limit` messages to fetch the most recent messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, based on the caller choice, we select what we want to download of those
    messages. If only the headers or the whole content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The mode will be provided to the `fetch` method to tell it what data we want
    to download:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The message itself is then composed as a list that contains a tuple of two
    elements. The first element contains the size and mode the message is returned
    in (as we provided the mode ourselves, we don''t really care), and the last element
    of the tuple contains the message itself, so we just grab it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have the message available, we feed it to `BytesParser` so that we
    can get back a `Message` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We loop over all the messages, parse them, and add to the list of messages
    that we will return. We stop as soon as we reach the desired amount of messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: From the `messages` method, we get back a list of `Message` objects, for which
    we can easily access all data, apart from the body of the message itself. Because
    the body might actually be composed by multiple items (think of a message with
    attachments – it has text, images, PDF files, or whatever was attached).
  prefs: []
  type: TYPE_NORMAL
- en: 'For this reason, the reader provides a `get_message_body` method that retrieves
    all the parts of the message body in case it''s a multipart message and returns
    them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Combining the `messages` and `get_message_body` methods, we are able to grab
    messages and their content from a mailbox, and then process them however we need.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Writing a feature-complete and fully functioning IMAP client is a standalone
    project that is outside the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: IMAP is a complex protocol that includes support for flags, searching, and many
    more features. Most of these commands are provided by `imaplib` and it's also
    possible to upload messages to the server or create tools to perform backups or
    copy messages from one mail account to another.
  prefs: []
  type: TYPE_NORMAL
- en: Also, when parsing complex emails, the `email` module will handle the various
    representation of data specified by the email-related RFCs, for example, our recipe
    returns dates as a string, but `email.utils.parsedate` can parse them to Python
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: FTP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: FTP is the most widely-used solution to save and retrieve files from a remote
    server. It has been around for decades and it's a fairly easy protocol to use
    that can deliver good performance as it provides minimal overhead over transferred
    content, while supporting powerful features, such as transfer recovery.
  prefs: []
  type: TYPE_NORMAL
- en: Often, software needs to receive files automatically uploaded by other software;
    FTP has been frequently used as a robust solution in these scenarios over the
    years. Whether your software is the one in need of uploading the content or the
    one that has to receive it, the Python standard library has support for FTP built-in
    so we can rely on `ftplib` to use the FTP protocol.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`ftplib` is a powerful foundation on which we can provider an easier API to
    interact with an FTP server, both to store and retrieve files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can test our class by uploading and fetching back a simple file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: If everything worked as expected, the output should be `Hello World!`
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `FTPClient` class provides an initializer that is in charge of setting up
    the correct connection to the server and a bunch of methods to actually do work
    against the connected server.
  prefs: []
  type: TYPE_NORMAL
- en: '`__init__` does quite a lot of work to try setting up the proper connection
    to the remote server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: First it tries a TLS connection, which guarantees encrypting, because otherwise
    FTP is a plain-text protocol that would send all out data in a clear text way.
  prefs: []
  type: TYPE_NORMAL
- en: If our remote server supports TLS, it is enabled on the control connection by
    calling `.auth()` and then on the data-transfer connection by calling `prot_p()`.
  prefs: []
  type: TYPE_NORMAL
- en: FTP is based on two kinds of connections, the control connection where we send
    and receive the commands for the server and their result, and a data connection
    where we send the uploaded and downloaded data.
  prefs: []
  type: TYPE_NORMAL
- en: If possible, both of them should be encrypted. If our server doesn't support
    them, we fall back to a plain FTP connection and proceed by just authenticating
    against it.
  prefs: []
  type: TYPE_NORMAL
- en: If your server doesn't require any authentication, providing `anonymous` as
    the username with an empty password is usually enough to get in.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we are connected, we are free to move around the server, and that can
    be done with the `cwd` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This method is just a proxy to the internal client one, as the internal one
    is already easy to use and fully functional.
  prefs: []
  type: TYPE_NORMAL
- en: 'But once we get into a directory, we need to fetch its content and here''s
    where the `dir()` method comes into play:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The `dir()` method calls the `mlsd` method of the internal client, which is
    in charge of returning the list of files in the current directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'This list is returned as a tuple of two elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The first entry of the tuple contains the filename, while the second contains
    its properties.
  prefs: []
  type: TYPE_NORMAL
- en: Our own method does just two additional steps, it skips the first returned entry—as
    that is always the current directory (the one we picked with `cwd())`—and then
    skips any special entry for the parent or current directory. We are not really
    interested in them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we are able to move around the structure of the directories, we can finally
    `upload` and `download` files into those directories:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Those two methods are pretty straightforward, they just open local files for
    reading when we upload and for writing when we download, and send the FTP command
    required to retrieve or store a file.
  prefs: []
  type: TYPE_NORMAL
- en: When uploading a new `remotefile`, a file will be created with the same content
    that `localfile` had. When downloading, `localfile` is opened to write inside
    it the content that `remotefile` has.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Not all FTP servers support the same commands. The protocol saw many extensions
    over the years, so some commands might be missing or have a different semantic.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the `mlsd` function might be missing, but you might have `LIST`
    or `nlst`, which can perform a similar job.
  prefs: []
  type: TYPE_NORMAL
- en: You can refer to RFC 959 to know how the FTP protocol should work, but frequently
    experimenting explicitly with the FTP server you should be connecting to is the
    best way to assess which commands and which signature it's going to accept.
  prefs: []
  type: TYPE_NORMAL
- en: Frequently, FTP servers implement a `HELP` command you can use it to fetch the
    list of supported functions.
  prefs: []
  type: TYPE_NORMAL
- en: Sockets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sockets are one of the lowest-level concepts that you can use to write networking
    applications. It means managing the whole connection ourselves, usually when relying
    on sockets directly, you would have to handle connection requests, accept them,
    and then start a thread or a loop to handle the subsequent commands or data that
    is sent through the newly created connection channel.
  prefs: []
  type: TYPE_NORMAL
- en: This is a flow that nearly all applications that rely on networking have to
    implement, everything you call a server usually has as a foundation in the aforementioned
    loop.
  prefs: []
  type: TYPE_NORMAL
- en: The Python standard library provides a great foundation to avoid having to manually
    rewrite that flow every time you have to work on a networking-based application.
    We can use the `socketserver` module and let it handle the connection loop for
    us, while we focus on just implementing the application layer protocol and handling
    messages.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You need to perform the following steps for this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Mixing the `TCPServer` and `ThreadingMixIn` classes, we can easily build a
    multithreaded server that will handle concurrent connections through TCP:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have a working server, to test it, we need a client to send messages
    to it. For convenience, we will keep the client simple and just make it connect,
    send a message, and wait back for a short reply:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have both the server and client, we can test that our server works
    as expected:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'If everything worked properly, you should see:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The server part is composed of three different classes.
  prefs: []
  type: TYPE_NORMAL
- en: '`EchoServer`, which orchestrates the server and provides the high-level API
    we can use. `EchoRequestHandler`, which manages the incoming messages and serves
    them. And `ThreadedTCPServer`, which is in charge of the whole networking part,
    opening sockets, listening on them, and spawning threads to handle connections.'
  prefs: []
  type: TYPE_NORMAL
- en: '`EchoServer` allows to start and stop our server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: It creates a new thread where the server will be running and starts it if it's
    not already running. The thread will just run the `ThreadedTCPServer.serve_forever`
    method that loops over and over, serving one request after the other.
  prefs: []
  type: TYPE_NORMAL
- en: When we are done with our server, we can call the `stop()` method, which will
    shut down the server and wait for its completion (it will quit as soon as it is
    finished all currently-running requests).
  prefs: []
  type: TYPE_NORMAL
- en: '`ThreadedTCPServer` is pretty much the standard one provided by the standard
    library, if not for the reason that we inherit from `ThreadingMixIn` too. `Mixin`
    is a set of additional features that you can inject in a class by inheriting from
    it, in this specific case, it provides threading features for the socket server.
    So instead of being able to serve a single request at a time, we can server multiple
    requests concurrently.'
  prefs: []
  type: TYPE_NORMAL
- en: We also set the `allow_reuse_address = True` attribute of the server, so that
    in case it crashes or in case of timeouts, the socket can be instantly reused
    instead of having to wait for the system to close them.
  prefs: []
  type: TYPE_NORMAL
- en: Finally `EchoRequestHandler` is the one providing the whole message-handling
    and parsing. Whenever `ThreadedTCPServer` receives a new connection, it will call
    the `handle` method on the handler, and it's up to the handler to do the right
    thing.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, we are just implementing a simple server that responds back whatever
    was sent to it, so the handler has to do two things:'
  prefs: []
  type: TYPE_NORMAL
- en: Parse the incoming message to understand its content
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Send back a message with the same content
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One of the major complexities when working with sockets is that they are not
    really message-based. They are a continuous stream of data (well, UDP is message-based,
    but for what concerns us, the interface doesn't change much). This means that
    it is impossible to know when a new message begins and when a message ends.
  prefs: []
  type: TYPE_NORMAL
- en: The `handle` method just tells us that there is a new connection, but on that
    connection, multiple messages might be sent one after the other and unless we
    have a way of knowing where a message ends, we would read them as a single big
    message.
  prefs: []
  type: TYPE_NORMAL
- en: To solve this need, we use a very simple yet effective approach, that is, prefixing
    all messages with their own size. Thus, when a new message is received we always
    know that we just need to read the size of the message and then, once the size
    is known, we will read the remaining bytes specified by the size.
  prefs: []
  type: TYPE_NORMAL
- en: 'To read those messages, we rely on a utility method, `recv_message`, that will
    be able to read a message made this way from any provided socket:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The first thing that the function does is read from the socket exactly `MESSAGE_HEADER_LEN`
    bytes. Those will be the bytes that contain the size of the message. All sizes
    must be the same size. For this reason, sizes such as `10` will have to be represented
    as `00010`. The prefixed zeros will then be ignored. Then, this size is converted
    using `int`, and we will get back the right number. The sizes must be all the
    same, otherwise we wouldn't know how many bytes we need to read to fetch the size.
  prefs: []
  type: TYPE_NORMAL
- en: 'We decided to constrain our message size to 65,000, this leads to a `MESSAGE_HEADER_LEN`
    of five as five digits are necessary to represent numbers up to 65,536:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The size doesn't really matter, and we just picked a fairly big value. The bigger
    the messages are that you allow, the more bytes you will need to represent their
    sizes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `recv_message` method is then used by `handle()` to read the sent message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the message is known, the `handle()` method also sends back a new message
    prepared the same way and to prepare the response, it relies on `prepare_message`,
    which is also used by the client to send the messages in the first place:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: What this function does is, given a message, it ensures it's not bigger than
    the maximum allowed size and then prefixes it with its size.
  prefs: []
  type: TYPE_NORMAL
- en: 'The size is computed by grabbing the length of the message as text and then
    encoding it as bytes using `ascii` encoding. As the size will only contain numbers,
    the `ascii` encoding is more than enough to represent them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'As the resulting string can have any size (from one to five bytes), we always
    pad it with zeros until it reaches the expected size:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The resulting bytes are then prepended to the message and the prepared message
    is returned.
  prefs: []
  type: TYPE_NORMAL
- en: With those two functions, the server is able to receive and send back messages
    of arbitrary size.
  prefs: []
  type: TYPE_NORMAL
- en: 'The client function works nearly the same way, as it has to send a message
    and then receive the answer back:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: It still uses `EchoRequestHandler.prepare_message` to prepare the message to
    send to the server, and `EchoRequestHandler.recv_message` to read the server response.
  prefs: []
  type: TYPE_NORMAL
- en: The only additional parts are related to connecting to the server. To do this,
    we actually create a socket of type `AF_INET`, `SOCK_STREAM`, which actually means
    we want to use TCP/IP.
  prefs: []
  type: TYPE_NORMAL
- en: Then we connect to the `ip` and `port` where the server is running, and once
    we're connected, we just send the message through the resulting socket `sock`
    and read the answer back on the same socket.
  prefs: []
  type: TYPE_NORMAL
- en: When we are done, we have to remember to close the socket or we will be leaking
    them until the OS decides to kill them because they were inactive for too long.
  prefs: []
  type: TYPE_NORMAL
- en: AsyncIO
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While asynchronous solutions have been around for years, they are getting more
    and more common these days. The primary reason is that having an application without
    thousands of concurrent users is not an uncommon scenario anymore; it's actually
    the norm for a small/medium-sized application and we can scale to millions with
    major services used worldwide.
  prefs: []
  type: TYPE_NORMAL
- en: Being able to serve such volumes doesn't scale well with approaches based on
    threads or processes. Especially when many of the connections that users are triggering
    might be sitting there doing nothing most of the time. Think of a service such
    as Facebook Messenger or WhatsApp. Whichever you use, you probably send a message
    once in a while and most of the time your connection to the server is sitting
    there doing nothing. Maybe you are a heavy chatter and you receive a message every
    second, but that still means that out of the millions of clocks per second your
    computer can do, most of them will be doing nothing. Most of the heavy lifting
    in this kind of application is done by the networking part, so there are a lot
    of resources that can be shared by undergoing multiple connections in a single
    process.
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous technologies allow exactly that, to write a networking application
    that instead of requiring multiple separate threads (that would be wasting memory
    and kernel efforts), we can have a single process and thread composed by multiple
    coroutines that do nothing until there is actually something to do.
  prefs: []
  type: TYPE_NORMAL
- en: As long as what the coroutines have to do is super-quick (such as grabbing a
    message and forwarding it to another contact of yours), most of the work will
    happen at the networking layer and thus can proceed in parallel.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The steps for this recipe are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to replicate our echo server, but instead of using threads, it''s
    going to use AsyncIO and coroutines to serve requests:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have the server implementation, we need a client to test it. As
    in practice the client does the same that we did for the previous recipe, we are
    just going to reuse the same client implementation. So the client won''t be AsyncIO-
    and coroutines-based, but will be a normal function using `socket`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Now we can put the pieces together. To run both client and server in the same
    process, we are going to run the `asyncio` loop in a separate thread. So, we can
    concurrently start clients against it. This is not in any way required to serve
    multiple clients, it's just a convenience to avoid having to start two different
    Python scripts to play server and client.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First of all, we create a thread for the server that will go on for `3` seconds.
    After `3` seconds, we will explicitly stop our server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, as soon as the server has started, we make the three clients and send
    three messages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Once finished, we wait for the server to quit, as after 3 seconds it should
    stop and quit:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'If everything worked as expected, you should see the server start, serve three
    clients, and then quit:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The client side of this recipe is mostly taken as is from the socket serve recipe.
    The difference lies in the server side, which is not threaded anymore; instead,
    it's based on coroutines.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given an `asyncio` event loop (the one we created with `asyncio.new_event_loop()`
    within the `serve_for_3_seconds` thread) the `EchoServer.serve` method creates
    a new coroutine-based server and tells the loop to serve requests forever until
    the server itself is not closed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '`loop.run_until_complete` will block until the specified coroutine doesn''t
    quit, and `self._server.wait_closed()` will quit only when the server itself is
    stopped.'
  prefs: []
  type: TYPE_NORMAL
- en: To ensure that the server is stopped after a short time, when we created the
    loop, we issued the `loop.call_later(3, server.stop)` call. This means that after
    3 seconds, the server will stop and thus the whole loop will quit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Meanwhile, until the server is actually stopped, it will serve requests. Each
    request will spawn a coroutine that runs the `handle` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: The handler will receive two streams as arguments. One for incoming data and
    the other for outgoing data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Much like we did in the case of the threaded socket server, we read the incoming
    message from the `reader` stream. To do so, we reimplement the `recv_message`
    as a coroutine, so that we can read the data concurrently with other requests
    being served:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: When both the size of the message and the message itself are available, we just
    return the message so that the `send_message` function can echo it back to the
    client.
  prefs: []
  type: TYPE_NORMAL
- en: 'The only particular change from `socketserver` in this context is that we write
    to the stream writer, but then we have to drain it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: This is done because after we wrote into the socket, we needed to send back
    control to the `asyncio` loop so that it had a chance actually to flush this data.
  prefs: []
  type: TYPE_NORMAL
- en: After three seconds, the `server.stop` method is called and that will stop the
    server, wake up the `wait_closed()` function, and thus make the `EchoServer.serve`
    method quit as it is completed.
  prefs: []
  type: TYPE_NORMAL
- en: Remote procedure calls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are hundreds of systems to perform RPC in Python, but because it has powerful
    networking tools and is a dynamic language, everything we need is already built
    into the standard library.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You need to perform the following steps for this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using `xmlrpc.server`, we can easily create an XMLRPC-based server that exposes
    multiple services:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Particularly, we are going to expose two services: one to get back current
    time, and the other to multiply a number by `2`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Once we have our services, we can consume them using `xmlrpc.client.ServerProxy`,
    which provides a simple call interface against the XMLRPC server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As usual, to start both client and server in the same process, we can use a
    thread for the server and let the server run within that thread while the client
    drives the main thread:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'If everything worked properly, you should see the current time being printed
    on the terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `XMLRPCServices` class takes all services that we want to expose as initialization
    arguments and exposes them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'This is done because we expose a local object (`ExposedServices`) that by default
    is empty, but we attach to its instance all the provided services as attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'So, we end up exposing a `self.services` object that has two attributes: `math`
    and `time`, which refer to the `MathServices` and `TimeServices` classes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Serving them is actually done by the `XMLRPCServices.serve` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: This creates a `SimpleXMLRPCServer` instance, which is the HTTP server in charge
    of responding to the XMLRPC requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'To that instance, we then attach the `self.services` object we created before
    and allow it to access subproperties so that the nested `math` and `time` attributes
    are exposed as services:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Before actually starting the server, we also enabled introspection functions.
    Those are all the functions that allow us to access the list of exposed services,
    and ask for their help and signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we actually start the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: This will block the `serve` method and loop forever serving requests until the
    `stop` method is called.
  prefs: []
  type: TYPE_NORMAL
- en: That's the reason why, in the example, we started the server in a separate thread;
    that is, so that it won't block the main thread that we could use for the client.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `stop` method is in charge of stopping the server, so that the `serve`
    method can exit. This method asks the server to terminate as soon as it finishes
    the current request and then closes the associated network connection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'So, just creating `XMLRPCServices` and serving it is enough to have our RPC
    server up and running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'On the client side, the code base is a lot easier; it''s just a matter of creating
    a `ServerProxy` against the URL where the server is exposed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, all the methods of the services exposed by the server will be accessible
    through dot notation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`XMLRPCServices` has big security implications, and so you should never use
    `SimpleXMLRPCServer` on an open network.'
  prefs: []
  type: TYPE_NORMAL
- en: The most obvious concern is that you are allowing remote-code execution to anyone
    as the XMLRPC server is unauthenticated. So, the server should only run on private
    networks where you can ensure that only trusted clients will be able to access
    the services.
  prefs: []
  type: TYPE_NORMAL
- en: But even if you provide proper authentication in front of the service (which
    is possible by using any HTTP proxy in front of it), you still want to ensure
    that you trust the data your clients are going to send because `XMLRPCServices`
    suffers from some security limitations.
  prefs: []
  type: TYPE_NORMAL
- en: The data being served is exchanged in clear text, so anyone able to sniff your
    network will be able to see it.
  prefs: []
  type: TYPE_NORMAL
- en: This can be worked around with some effort by subclassing the `SimpleXMLRPCServer`
    and replacing its `socket` instance with an SSL-wrapped one (the same should happen
    for the client to be able to connect).
  prefs: []
  type: TYPE_NORMAL
- en: But, even when a hardening of the communication channel is involved, you still
    need to trust the data that will be sent because the parser is naive and can be
    brought out of service by sending large amounts of recursive data. Imagine you
    have an entity that's expanded to dozens of entities that each expand to dozens
    of entities and so on for 10-20 levels. That will quickly require gigabytes and
    gigabytes of RAM to decode, but requires no more than a few kilobytes to build
    and send through the network.
  prefs: []
  type: TYPE_NORMAL
- en: Also, the fact that we are exposing subproperties means we are exposing far
    more than we expect.
  prefs: []
  type: TYPE_NORMAL
- en: 'You certainly expect to expose the `currentTime` method of the `time` service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Note that you are exposing every single property or method declared in `TimeServices`
    whose name does not start with an `_`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In older Python versions (such as 2.7), this actually meant exposing internal
    code too, as you could access all public variables by doing something such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'You could then retrieve their values through:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: This was a major security concern.
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, the `im_func` attribute of functions was renamed to `__func__` and,
    thus, is no longer accessible. However, the concern still remains for any attribute
    you declared yourself.
  prefs: []
  type: TYPE_NORMAL
