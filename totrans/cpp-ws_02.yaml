- en: 2\. Building Quality Object-Oriented Code
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.构建高质量的面向对象代码
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, you will learn how to simplify complex logic using Object-Oriented
    Programming (OOP). You will start by creating classes and objects, before exploring
    the four pillars of OOP. You will then learn about some of the best practices
    in coding, known as the SOLID principles, and see how you can use C# 10 features
    to write effective code guided by these principles. By the end of this chapter,
    you will be able to write clean code using object-oriented design with C#.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习如何使用面向对象编程（OOP）简化复杂的逻辑。您将首先创建类和对象，然后探索面向对象编程的四大支柱。然后，您将了解一些最佳编码实践，即SOLID原则，并了解如何使用C#
    10功能编写受这些原则指导的有效代码。通过本章结束时，您将能够使用C#进行面向对象设计编写清晰的代码。
- en: Introduction
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: How do people write software that is still maintainable even after many decades?
    What is the best way to model software around real-world concepts? The answer
    to both questions is Object Oriented Programming (OOP). OOP is a widely used paradigm
    in professional programming and is especially useful in enterprise settings.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 人们如何编写经过多年仍然易于维护的软件？围绕现实世界概念建模软件的最佳方法是什么？这两个问题的答案都是面向对象编程（OOP）。面向对象编程是专业编程中广泛使用的范式，尤其在企业环境中特别有用。
- en: OOP can be thought of as a bridge that connects real-world concepts and source
    code. A cat, for example, has certain defining properties, such as age, fur color,
    eye color, and name. The weather can be described using factors such as temperature
    and humidity. Both of these are real-world concepts that humans have identified
    and defined over time. In OOP, classes are what help in defining the logic of
    a program. When assigning concrete values to the properties of these classes,
    the result is an object. For example, using OOP, you can define a class for representing
    a room in a house, and then assign values to its properties (color and area) to
    create an object of that class.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程可以被认为是连接现实世界概念和源代码的桥梁。例如，猫具有一些定义属性，如年龄、毛色、眼睛颜色和名字。天气可以用温度和湿度等因素来描述。这些都是人类随着时间识别和定义的现实世界概念。在面向对象编程中，类是帮助定义程序逻辑的东西。当为这些类的属性分配具体值时，结果就是一个对象。例如，使用面向对象编程，您可以定义一个表示房子中的房间的类，然后为其属性（颜色和面积）分配值，以创建该类的对象。
- en: In *Chapter 1*, *Hello C#*, you learned how to use C# to write basic programs.
    In this chapter, you will see how you can design your code by implementing OOP
    concepts and using C# at its best.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第1章*“你好C#”中，你学会了如何使用C#编写基本程序。在本章中，您将看到如何通过实现面向对象编程概念和充分利用C#来设计您的代码。
- en: Classes and Objects
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类和对象
- en: A class is like a blueprint that describes a concept. An object, on the other
    hand, is the result you get after the application of this blueprint. For example,
    `weather` can be a class, and `25 degrees and` `cloudless` could refer to an object
    of this class. Similarly, you can have a class named `Dog`, while a four-year-old
    `Spaniel` can represent an object of the `Dog` class.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于描述概念的蓝图。另一方面，对象是应用此蓝图后获得的结果。例如，`weather`可以是一个类，`25度`和`无云`可以指代这个类的一个对象。同样，您可以有一个名为`Dog`的类，而四岁的`Spaniel`可以代表`Dog`类的一个对象。
- en: 'Declaring a class in C# is simple. It starts with the `class` keyword, followed
    by the class name and a pair of curly braces. To define a class named `Dog`, you
    can write the following code:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中声明一个类很简单。它以`class`关键字开头，后跟类名和一对花括号。要定义一个名为`Dog`的类，您可以编写以下代码：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Right now, this class is just an empty skeleton. However, it can still be used
    to create objects by using the `new` keyword, as follows:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这个类只是一个空的骨架。但是，仍然可以使用`new`关键字来创建对象，如下所示：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This creates an object named `dog`. Currently, the object is an empty shell,
    as it lacks properties. You will see in an upcoming section how to define properties
    for classes, but first, you will explore constructors.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个名为`dog`的对象。目前，该对象是一个空壳，因为它缺少属性。在接下来的部分中，您将看到如何为类定义属性，但首先，您将探索构造函数。
- en: Constructors
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构造函数
- en: In C#, constructors are functions used to create new objects. You can also use
    them to set the initial values of an object. Like any function, a constructor
    has a name, takes arguments, and can be overloaded. A class must have at least
    one constructor, but if needed, it can have multiple constructors with different
    arguments. Even if you do not explicitly define a single constructor, a class
    will still have a default constructor–one that does not take any arguments or
    perform any actions but simply assigns memory to the newly created object and
    its fields.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中，构造函数是用于创建新对象的函数。您还可以使用它们来设置对象的初始值。与任何函数一样，构造函数有一个名称，接受参数，并且可以重载。一个类必须至少有一个构造函数，但如果需要，它可以有多个具有不同参数的构造函数。即使您没有显式定义一个构造函数，类仍将具有默认构造函数-一个不接受任何参数或执行任何操作，而只是为新创建的对象及其字段分配内存的构造函数。
- en: 'Consider the following snippet, where a constructor for the `Dog` class is
    being declared:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码片段，其中声明了`Dog`类的构造函数：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/H2lUF](https://packt.link/H2lUF).
    You can find the usage of the code at [https://packt.link/4WoSX](https://packt.link/4WoSX).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://packt.link/H2lUF](https://packt.link/H2lUF)找到此示例中使用的代码。您可以在[https://packt.link/4WoSX](https://packt.link/4WoSX)找到代码的用法。
- en: 'If a method has the same name as the class and does not provide a `return`
    type, it is a constructor. Here, the snippet of the code is within a class named
    `Dog`. So, the constructor is within the specified line of code. Note that by
    defining this constructor explicitly, you hide the default constructor. If there
    is one or more such custom constructors, you will no longer be able to use a default
    constructor. Once the new constructor is called, you should see this message printed
    in the console: `"A Dog object has been created"`.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个方法与类同名且没有提供 `return` 类型，则它是一个构造函数。在这里，代码片段在一个名为 `Dog` 的类中。因此，构造函数在指定的代码行内。请注意，通过显式定义此构造函数，您隐藏了默认构造函数。如果有一个或多个这样的自定义构造函数，您将不再能够使用默认构造函数。一旦调用新的构造函数，您应该在控制台中看到打印出此消息："已创建一个
    Dog 对象"。
- en: Fields and Class Members
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字段和类成员
- en: 'You already know what a variable is: it has a type, a name, and a value, as
    you saw in *Chapter 1*, *Hello C#*. Variables can also exist in the class scope,
    and such a variable is called a field. Declaring a field is as simple as declaring
    a local variable. The only difference is the addition of a keyword at the start,
    which is the access modifier. For example, you can declare a field within the
    `Dog` class with the public access modifier, as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经知道什么是变量：它有一个类型、一个名称和一个值，就像您在*第1章* *Hello C#*中看到的那样。变量也可以存在于类范围内，这样的变量称为字段。声明字段与声明局部变量一样简单。唯一的区别是在开头添加一个关键字，即访问修饰符。例如，您可以在
    `Dog` 类中声明一个具有公共访问修饰符的字段，如下所示：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This line of code states that the `Name` field, which is a string with the value
    `"unnamed"`, can be accessed publicly. Besides `public`, the other two main access
    modifiers in C# are `private` and `protected`, which you will look at them in
    detail later.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码说明了 `Name` 字段，它是一个值为 `"unnamed"` 的字符串，可以公开访问。除了 `public`，C# 中的另外两个主要访问修饰符是
    `private` 和 `protected`，您将在后面详细了解它们。
- en: Note
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find more information regarding access modifiers at [https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/access-modifiers.](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/access-modifiers.)
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/access-modifiers](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/access-modifiers)找到有关访问修饰符的更多信息。
- en: Everything a class holds is called a class member. Class members can be accessed
    from outside of a class; however, such access needs to be granted explicitly using
    the `public` access modifier. By default, all members have a `private` access
    modifier.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 类所持有的一切都称为类成员。类成员可以从类的外部访问；但是，这种访问需要使用 `public` 访问修饰符明确授予。默认情况下，所有成员都具有 `private`
    访问修饰符。
- en: 'You can access class members by writing the object name followed by a dot (`.`)
    and the member name. For example, consider the following snippet in which two
    objects of the `Dog` class are being created:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过写对象名称后跟一个点(`.`)和成员名称来访问类成员。例如，考虑以下代码片段，其中创建了 `Dog` 类的两个对象：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here, you can declare two independent variables, `sparky` and `ricky`. However,
    you haven''t explicitly assigned these names to the objects; note that these are
    only the variable names. To assign the names to the objects, you can write the
    following code using dot notation:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以声明两个独立的变量，`sparky` 和 `ricky`。但是，您还没有明确地将这些名称分配给对象；请注意，这些只是变量名称。要将名称分配给对象，您可以使用点表示法编写以下代码：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You can now have hands-on experience of creating classes and objects through
    an exercise.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以通过练习来亲身体验创建类和对象。
- en: 'Exercise 2.01: Creating Classes and Objects'
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 2.01：创建类和对象
- en: Consider that there are two books, both by an author named `New Writer`. The
    first one, called `First Book`, was published by `Publisher 1`. There is no description
    available for this book. Similarly, the second one is named `Second Book` and
    was published by `Publisher 2`. It has a description that simply says, `"Interesting read"`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有两本书，都是由名为 `New Writer` 的作者写的。第一本书名为 `First Book`，由 `Publisher 1` 出版。这本书没有可用的描述。类似地，第二本书名为
    `Second Book`，由 `Publisher 2` 出版。它有一个简单地说："有趣的阅读"的描述。
- en: In this exercise, you will model these books in code. The following steps will
    help you complete this exercise.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您将在代码中对这些书进行建模。以下步骤将帮助您完成这个练习。
- en: 'Create a class called `Book`. Add fields for `Title`, `Author`, `Publisher`,
    `Description`, and the number of pages. You must print this information from outside
    the class, so make sure every field is `public`:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `Book` 的类。为 `Title`、`Author`、`Publisher`、`Description` 和页数添加字段。您必须从类的外部打印这些信息，因此请确保每个字段都是
    `public` 的：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Create a class named `Solution`, with the `Main` method. As you saw in *Chapter
    1*, *Hello C#*, this class with the `Main` method is the starting point of your application:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `Solution` 的类，其中包含 `Main` 方法。正如您在*第1章* *Hello C#*中看到的那样，这个带有 `Main` 方法的类是您应用程序的起点：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Inside the `Main` method, create an object for the first book and set the values
    for the fields, as follows:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Main` 方法内，为第一本书创建一个对象，并设置字段的值，如下所示：
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, a new object named `book1` is created. Values are assigned to different
    fields by writing dot (`.`) followed by the field name. The first book does not
    have a description, so you can omit the field `book1.Description`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，创建了一个名为 `book1` 的新对象。通过写点(`.`)后跟字段名称，为不同的字段分配值。第一本书没有描述，因此您可以省略字段 `book1.Description`。
- en: 'Repeat this step for the second book. For this book, you need to set a value
    for the `Description` field as well:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复此步骤以创建第二本书。对于这本书，您还需要为 `Description` 字段设置一个值：
- en: '[PRE9]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In practice, you will rarely see fields with public access modifiers. Data mutates
    easily, and you might not want to leave your program open to external changes
    after initialization.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，您很少会看到具有公共访问修饰符的字段。数据很容易变异，您可能不希望在初始化后让程序对外部更改开放。
- en: 'Inside the `Solution` class, create a method named `Print`, which takes a `Book`
    object as an argument and prints all fields and their values. Use string interpolation
    to concatenate book information and print it to the console using `Console.WriteLine()`,
    as follows:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Solution`类中，创建一个名为`Print`的方法，该方法以`Book`对象作为参数，并打印所有字段及其值。使用字符串插值将书籍信息连接起来，并使用`Console.WriteLine()`将其打印到控制台，如下所示：
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Inside the `Main` method, call the `Print` method for `book1` and `book2`:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法中，调用`book1`和`book2`的`Print`方法：
- en: '[PRE11]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Upon running this code, you will see the following output on the console:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码后，您将在控制台上看到以下输出：
- en: '[PRE12]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this exercise at [https://packt.link/MGT9b](https://packt.link/MGT9b).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此练习中使用的代码[https://packt.link/MGT9b](https://packt.link/MGT9b)。
- en: In this exercise, you saw how to use fields and class members are used in simple
    programs. Now proceed to know about reference types.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您看到了如何在简单程序中使用字段和类成员。现在继续了解引用类型。
- en: Reference Types
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引用类型
- en: 'Suppose you have an object and the object is not created, just declared, as
    follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您有一个对象，该对象尚未创建，只是声明如下：
- en: '[PRE13]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: What would happen if you tried accessing its `Name` value? Calling `speedy.Name`
    would throw a `NullReferenceException` exception because `speedy` is yet to be
    initialized. Objects are reference types, and their default value is null until
    initialized. You have already worked with value types, such as `int`, `float`,
    and `decimal`. Now you need to grasp that there are two major differences between
    value and reference types.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尝试访问其“Name”值会发生什么？调用`speedy.Name`将抛出`NullReferenceException`异常，因为`speedy`尚未初始化。对象是引用类型，它们的默认值是null，直到初始化。您已经使用过值类型，比如`int`、`float`和`decimal`。现在您需要了解值类型和引用类型之间的两个主要区别。
- en: Firstly, value types allocate memory on the stack, whereas reference types allocate
    memory on the heap. The stack is a temporary place in memory. As the name implies,
    in a stack, blocks of memory are stacked on top of each other. When you call a
    function, all local function variables will end up on a single block of the stack.
    If you call a nested function, the local variables of that function will be allocated
    on another block of the stack.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，值类型在堆栈上分配内存，而引用类型在堆上分配内存。堆栈是内存中的临时位置。顾名思义，在堆栈中，内存块被堆叠在彼此之上。当您调用一个函数时，所有局部函数变量都将最终位于堆栈的一个单一块上。如果您调用一个嵌套函数，该函数的局部变量将分配在堆栈的另一个块上。
- en: In the following figure, you can see which parts of code will allocate memory
    in the stack during execution, and which will do so in the heap. Method calls
    (1, 8, 10) and local variables (2, 4) will be stored in the stack. Objects (3,
    5) and their members (6) will be stored on the heap. Stacks use the Push method
    to allocate data, and Pop to deallocate it. When memory is allocated, it comes
    on top of the stack. When it is deallocated, it is removed from the top as well.
    You deallocate memory from the stack as soon as you leave the scope of a method
    (8, 10, 11). Heap is much more random, and Garbage Collector (GC) automatically
    (unlike some other languages, where you need to do it yourself), deallocates memory.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在下图中，您可以看到代码的哪些部分在执行过程中将在堆栈中分配内存，哪些部分将在堆中分配内存。方法调用（1、8、10）和局部变量（2、4）将存储在堆栈中。对象（3、5）及其成员（6）将存储在堆中。堆栈使用Push方法来分配数据，并使用Pop来释放它。当内存被分配时，它位于堆栈的顶部。当它被释放时，它也从顶部移除。一旦离开方法的范围（8、10、11），就会从堆栈中释放内存。堆要随机得多，垃圾收集器（GC）会自动（不像其他一些语言，需要自己做）释放内存。
- en: Note
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: GC is a massive topic in itself. If you want to find out more, please refer
    to the official Microsoft documentation at [https://docs.microsoft.com/en-us/dotnet/standard/garbage-collection/fundamentals](https://docs.microsoft.com/en-us/dotnet/standard/garbage-collection/fundamentals).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: GC本身就是一个庞大的主题。如果您想了解更多，请参阅微软官方文档[https://docs.microsoft.com/en-us/dotnet/standard/garbage-collection/fundamentals](https://docs.microsoft.com/en-us/dotnet/standard/garbage-collection/fundamentals)。
- en: '![Figure 2.1: Stack and heap comparison'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.1：堆栈和堆比较'
- en: '](img/B16835_02_01.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16835_02_01.jpg)'
- en: 'Figure 2.1: Stack and heap comparison'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1：堆栈和堆比较
- en: Note
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you make too many nested calls, you will run into a `StackoverflowException`
    exception because the stack ran out of memory. Freeing up memory on the stack
    is just a matter of exiting from a function.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您进行太多的嵌套调用，您将遇到`StackoverflowException`异常，因为堆栈内存不足。释放堆栈上的内存只是退出函数的问题。
- en: The second difference is that, when value types are passed to a method, their
    value is copied, while for reference types, only the reference is copied. This
    means that the reference type object's state is modifiable inside a method, unlike
    a value type, because a reference is simply the address of an object.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个区别是，当值类型传递给方法时，它们的值被复制，而对于引用类型，只有引用被复制。这意味着引用类型对象的状态在方法内是可修改的，不像值类型，因为引用只是对象的地址。
- en: 'Consider the following snippet. Here, a function named `SetTo5` sets the value
    of the number to `5`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码片段。这里，一个名为`SetTo5`的函数将数字的值设置为`5`：
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, consider the following code:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，考虑以下代码：
- en: '[PRE15]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This should result in the following output:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该导致以下输出：
- en: '[PRE16]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If you run this code, you find that the printed value of `a` is still `2` and
    not `5`. This is because `a` is a value type that passed the value `2`, and therefore
    its value is copied. Inside a function, you never work with the original; a copy
    is always made.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您运行此代码，您会发现`a`的打印值仍然是`2`而不是`5`。这是因为`a`是一个传递值`2`的值类型，因此它的值被复制。在函数内部，您永远不会使用原始值；总是会进行复制。
- en: 'What about reference types? Suppose you add a field named `Owner` inside the
    `Dog` class:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 那引用类型呢？假设您在`Dog`类中添加一个名为`Owner`的字段：
- en: '[PRE17]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Create a function, `ResetOwner`, that sets the value of the `Owner` field for
    an object to `None`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`ResetOwner`的函数，将对象的`Owner`字段的值设置为`None`：
- en: '[PRE18]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, suppose the following code is executed:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设执行以下代码：
- en: '[PRE19]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This should result in the following output:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该导致以下输出：
- en: '[PRE20]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/gj164](https://packt.link/gj164).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://packt.link/gj164](https://packt.link/gj164)找到本示例使用的代码。
- en: If you try running this snippet of code yourself, you will first see the name
    `speedy` on one line and then `None` printed on another. This would change the
    dog's name, and the changes would remain outside the function. This is because
    Dog is a class, and a class is a reference type. When passed to a function, a
    copy of a reference is made. However, a copy of a reference points to the whole
    object, and therefore the changes that are made remain outside as well.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试运行这段代码片段，你会先看到一行上的名字`speedy`，然后在另一行上打印出`None`。这将改变狗的名字，并且这些改变将保留在函数外部。这是因为Dog是一个类，类是一个引用类型。当传递给一个函数时，会创建一个引用的副本。然而，引用的副本指向整个对象，因此所做的更改也会保留在外部。
- en: 'It might be confusing to hear that you pass a copy of a reference. How can
    you be sure you are working with a copy? To learn this, consider the following function:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 听到你传递引用的副本可能会让人感到困惑。你怎么能确定你正在使用一个副本呢？为了了解这一点，考虑以下函数：
- en: '[PRE21]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here, creating a new object creates a new reference. If you change the value
    of a reference type, you are working with a completely different object. It may
    be one that looks the same but is stored in a completely different place in memory.
    Creating an object for a passed parameter will not affect anything outside the
    object. Though this may sound potentially useful, you should generally avoid doing
    this as it can make code difficult to comprehend.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，创建一个新对象会创建一个新的引用。如果你改变引用类型的值，你实际上是在使用一个完全不同的对象。它可能看起来一样，但存储在内存中的位置完全不同。为传递的参数创建一个对象不会影响对象外部的任何东西。虽然这可能听起来有用，但通常应该避免这样做，因为它会使代码难以理解。
- en: Properties
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性
- en: The `Dog` class has one flaw. Logically, you wouldn't want the name of a dog
    to be changed once it is assigned. However, as of now, there is nothing that prevents
    changing it. Think about the object from the perspective of what you can do with
    it. You can set the name of a dog (`sparky.Name = "Sparky"`) or you can get it
    by calling `sparky.Name`. However, what you want is a read-only name that can
    be set just once.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dog`类有一个缺陷。从逻辑上讲，你不希望一只狗的名字在分配后被改变。然而，目前还没有任何东西可以阻止它被改变。从你可以对对象做什么的角度来考虑这个对象。你可以设置一只狗的名字（`sparky.Name
    = "Sparky"`），或者通过调用`sparky.Name`来获取它。然而，你想要的是一个只读的名字，只能设置一次。'
- en: Most languages take care of this through setter and getter methods. If you add
    the `public` modifier to a field, this means that it can be both retrieved (read)
    and modified (written). It isn't possible to allow just one of these actions.
    However, with setters and getters, you can restrict both read and write access.
    In OOP, restricting what can be done with an object is key to ensuring data integrity.
    In C#, instead of setter and getter methods, you can use properties.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数语言通过setter和getter方法来处理这个问题。如果给一个字段添加`public`修饰符，这意味着它既可以被检索（读取）又可以被修改（写入）。不可能只允许其中一个操作。然而，通过setter和getter，你可以限制读和写访问。在面向对象编程中，限制对象的操作是确保数据完整性的关键。在C#中，你可以使用属性来代替setter和getter方法。
- en: 'In OOP languages (for example Java), to set or get the values of a name, you
    would write something like this:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象编程语言（例如Java）中，要设置或获取名字的值，你会写类似于这样的代码：
- en: '[PRE22]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In C#, it is as simple as the following:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中，它就是这么简单的：
- en: '[PRE23]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This is a property, which is nothing but a method that reads like a field.
    There are two types of properties: getters and setters. You can perform both read
    and write operations with them. From the preceding code, if you remove `get`,
    it will become write-only, and if you remove `set`, it will become read-only.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个属性，实际上就是一个读起来像字段的方法。属性有两种类型：获取器和设置器。你可以用它们执行读和写操作。从前面的代码中，如果你移除`get`，它将变成只写，如果你移除`set`，它将变成只读。
- en: 'Internally, the property includes a setter and a getter method with a backing
    field. A backing field is simply a private field that stores a value, and getter
    and setter methods work with that value. You can write custom getters and setters
    as well, as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，属性包括一个带有后备字段的setter和getter方法。后备字段只是一个存储值的私有字段，getter和setter方法与该值一起工作。你也可以编写自定义的getter和setter，如下所示：
- en: '[PRE24]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the preceding snippet, the `Owner` property shows what the default getter
    and setter methods would look like for the `Dog` class.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的片段中，`Owner`属性展示了`Dog`类的默认getter和setter方法的样子。
- en: 'Just like other members, individual parts of a property (either getter or setter)
    can have their own access modifier, like the following:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 就像其他成员一样，属性的各个部分（getter或setter）可以有自己的访问修饰符，如下所示：
- en: '[PRE25]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In this case, the getter is `public`, and the setter is `private`. All parts
    of the property (getter, setter, or both, as defined) take the access modifier
    from the property (`Name`, in this case) unless explicitly specified otherwise
    (as in the case of `private` set). If you do not need to set a name, you can get
    rid of the setter. If you need a default value, you can write the code for this
    as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，getter是`public`，setter是`private`。属性的所有部分（getter、setter或两者，如定义的那样）都从属性（在这种情况下是`Name`）中获取访问修饰符，除非另有明确规定（如`private`
    set的情况）。如果不需要设置名字，可以摆脱setter。如果需要默认值，可以编写以下代码：
- en: '[PRE26]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This piece of code means that the `Name` field is read-only. You can set the
    name only through a constructor. Note that this is not the same as a `private`
    set because the latter means you can still change the name within the `Dog` class
    itself. If no setter is provided (as is the case here), you can set the value
    in only one place, the constructor.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码意味着`Name`字段是只读的。你只能通过构造函数设置名字。请注意，这与`private` set不同，因为后者意味着你仍然可以在`Dog`类内部更改名字。如果没有提供setter（就像这里的情况一样），你只能在一个地方设置值，那就是构造函数。
- en: 'What happens internally when you create a read-only property? The following
    code is generated by the compiler:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建一个只读属性时，内部会发生什么？编译器生成以下代码：
- en: '[PRE27]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This shows that getter and setter properties are simply methods with a backing
    field. It is important to note that, if you have a property called `Name`, the
    `set_Name()` and `get_Name()` methods will be reserved because that's what the
    compiler generates internally.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明getter和setter属性只是带有后备字段的方法。重要的是要注意，如果您有一个名为`Name`的属性，那么`set_Name()`和`get_Name()`方法将被保留，因为这是编译器在内部生成的。
- en: You may have noticed a new keyword in the previous snippet, `readonly`. It signifies
    that the value of a field can only be initialized once—either during declaration
    or in a constructor.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个片段中，您可能已经注意到了一个新的关键字`readonly`。它表示字段的值只能在声明时或在构造函数中初始化一次。
- en: 'Returning a backing field with a property may seem redundant sometimes. For
    example, consider the next snippet:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，使用属性返回后备字段可能看起来有些多余。例如，考虑下一个片段：
- en: '[PRE28]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This code snippet is a custom property. When a getter or a setter is more than
    just a basic return, you can write the property in this way to add custom logic
    to it. This property, without affecting the original name of a dog, will prepend
    `Dog''s name is` before returning the name. You can make this more concise using
    expression-bodied property syntax, as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码片段是一个自定义属性。当getter或setter不仅仅是基本返回时，您可以以这种方式编写属性，以向其添加自定义逻辑。这个属性，在不影响狗的原始名称的情况下，将在返回名称之前添加`Dog's
    name is`。您可以使用表达式主体属性语法使其更加简洁，如下所示：
- en: '[PRE29]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This code does the same thing as the previous code; the `=>` operator indicates
    that it is a read-only property, and you return a value that is specified on the
    right side of the `=>` operator.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码与上一段代码做了同样的事情；`=>`运算符表示它是一个只读属性，并且您返回的值是`=>`运算符右侧指定的值。
- en: How do you set the initial value if there is no setter? The answer to that is
    a constructor. In OOP, a constructor serves one purpose—that is, setting the initial
    values of fields. Using a constructor is great for preventing the creation of
    objects in an invalid state.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有setter，您如何设置初始值？答案是构造函数。在面向对象编程中，构造函数有一个目的——那就是设置字段的初始值。使用构造函数非常适合防止以无效状态创建对象。
- en: 'To add some validation to the `Dog` class, you can write the following code:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 要向`Dog`类添加一些验证，您可以编写以下代码：
- en: '[PRE30]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The code you have just written will prevent an empty name from being passed
    when creating a `Dog` instance.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 您刚刚编写的代码将阻止在创建`Dog`实例时传递空名称。
- en: 'It is worth mentioning that within a class, you have access to the object itself
    that will be created. It might sound confusing, but it should make sense with
    this example:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一提的是，在类内部，您可以访问将要创建的对象本身。这可能听起来有点混乱，但通过这个例子应该会有所启发：
- en: '[PRE31]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `this` keyword is most often used to clear the distinction between class
    members and arguments. `this` refers to the object that has just been created,
    hence, `this.name` refers to the name of that object and `name` refers to the
    passed parameter.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`this`关键字通常用于清除类成员和参数之间的区别。`this`指的是刚刚创建的对象，因此，`this.name`指的是该对象的名称，而`name`指的是传递的参数。'
- en: 'Creating an object of the `Dog` class, and setting the initial value of a name,
    can now be simplified as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，创建`Dog`类的对象，并设置名称的初始值，可以简化如下：
- en: '[PRE32]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: You still have a private setter, meaning the property that you have is not entirely
    read-only. You can still change the value of a name within the class itself. However,
    fixing that is quite easy; you can simply remove the setter and it will become
    truly read-only.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 您仍然有一个私有的setter，这意味着您拥有的属性并非完全只读。您仍然可以在类本身内部更改名称的值。然而，修复这个问题非常容易；您只需删除setter，它就会变成真正的只读。
- en: Note
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [http://packt.link/hjHRV](http://packt.link/hjHRV).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[http://packt.link/hjHRV](http://packt.link/hjHRV)找到本示例使用的代码。
- en: Object Initialization
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象初始化
- en: 'Often, a class has read and write properties. Usually, instead of setting the
    property values via a constructor, they are assigned after the creation of an
    object. However, in C# there is a better way—object initialization. This is where
    you create a new object and set the mutable (read and write) field values right
    away. If you had to create a new object of the `Dog` class and set the value of
    `Owner` for this object to `Tobias`, you could add the following code:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，一个类有读写属性。通常情况下，不是通过构造函数设置属性值，而是在创建对象后分配。然而，在C#中有一种更好的方法——对象初始化。这是您创建一个新对象并立即设置可变（读写）字段值的地方。如果您必须创建一个`Dog`类的新对象，并为该对象的`Owner`设置为`Tobias`，您可以添加以下代码：
- en: '[PRE33]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This can be done using object initialization as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过对象初始化来完成这个操作，如下所示：
- en: '[PRE34]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Setting initial properties like this when they are not a part of a constructor
    is generally more concise. The same applies to arrays and other collection types.
    Suppose you had two objects of the `Dog` class, as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 当它们不是构造函数的一部分时，设置初始属性通常更加简洁。对数组和其他集合类型也是如此。假设您有两个`Dog`类的对象，如下所示：
- en: '[PRE35]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In such a case, one way of creating an array would be as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，创建数组的一种方式如下：
- en: '[PRE36]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'However, instead of this, you can just add the following code, which is more
    concise:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，您可以简单地添加以下代码，这更加简洁：
- en: '[PRE37]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In C# 10, you can simplify object initialization without providing the type,
    if it can be inferred from the declaration, as in the following code:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在C# 10中，您可以简化对象初始化，而无需提供类型，如果可以从声明中推断出类型，如下面的代码所示：
- en: '[PRE38]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Comparing Functions and Methods
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较函数和方法
- en: Up until now, you might have seen the terms—function and method—used quite often,
    almost interchangeably. Now proceed to gain further insight into functions and
    methods. A function is a block of code that you can call using its name and some
    input. A method is a function that exists within a class.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您可能经常看到术语——函数和方法——几乎可以互换使用。现在继续深入了解函数和方法。函数是一段可以使用其名称和一些输入调用的代码块。方法是存在于类中的函数。
- en: However, in C#, you cannot have functions outside of a class. Therefore, in
    C#, every function is a method. Many languages, especially non-OOP languages,
    have only some functions that can be called methods (for example, JavaScript).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在C#中，您不能在类外部有函数。因此，在C#中，每个函数都是一个方法。许多语言，特别是非面向对象的语言，只有一些可以称为方法的函数（例如JavaScript）。
- en: 'The behavior of a class is defined using methods. You have already defined
    some behavior for the `Dog` class, that is, getting its name. To finish implementing
    the behaviors for this class, you can implement some real-world parallels, such
    as sitting and barking. Both methods will be called from the outside:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 类的行为是使用方法定义的。您已经为`Dog`类定义了一些行为，即获取其名称。要完成此类的行为实现，您可以实现一些现实世界的类比，例如坐下和吠叫。这两种方法都将从外部调用：
- en: '[PRE39]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'You can call both methods like this:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以这样调用这两种方法：
- en: '[PRE40]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In most cases, it is preferable to avoid exposing data publicly, so you should
    only ever expose functions publicly. Here, you might be wondering, What about
    properties? Properties are just getter and setter functions; they work with data
    but aren't data themselves. You should avoid **exposing** data publicly directly,
    for the same reason you lock your doors, or carry your phone in a case. If data
    were public, everyone could access it without any restrictions.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，最好避免公开数据，因此您应该只公开函数。在这里，您可能会想知道，属性呢？属性只是获取器和设置器函数；它们处理数据，但并不是数据本身。您应该避免直接公开数据，原因与您锁门或将手机放在套子中的原因相同。如果数据是公开的，每个人都可以无限制地访问它。
- en: Also, data should not change when the program requires it to be constant. A
    method is a mechanism that ensures that an object is not used in invalid ways,
    and if it is, it's well handled.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当程序要求数据保持不变时，数据不应更改。方法是一种确保对象不以无效方式使用的机制，如果是，它会被很好地处理。
- en: What if you need to validate the fields consistently throughout the application?
    Again, properties, that is, getter and setter methods, can help with this. You
    can limit what you can do with data and add validation logic to it. Properties
    help you be in full control of how you can get and set data. Properties are handy,
    but it's important to use them with discretion. If you want to do something complex,
    something that needs extra computing, it is preferable to use a method.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要在整个应用程序中一致地验证字段，那么属性，即获取器和设置器方法，可以帮助实现这一点。您可以限制对数据的操作，并向其添加验证逻辑。属性帮助您完全控制如何获取和设置数据。属性很方便，但重要的是要谨慎使用它们。如果要做一些复杂的事情，需要额外的计算，最好使用方法。
- en: For example, imagine that you have a class for an inventory made up of items,
    each having some weight. Here, it might make sense to have a property to return
    the heaviest item. If you chose to do so through a property (call it `MaxWeight`),
    you might get unexpected results; getting the heaviest item would require iterating
    through a collection of all items and finding the maximum by weight. This process
    is not as fast as you would expect. In fact, in some cases, it might even throw
    an error. Properties should have simple logic, otherwise working with them might
    yield unexpected results. Therefore, when the need for compute-heavy properties
    arises, consider refactoring them to a method. In this case, you would refactor
    the `MaxWeight` property into the `GetMaxWeight` method.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设您有一个库存类，由物品组成，每个物品都有一些重量。在这里，可能有一个属性返回最重的物品。如果您选择通过属性（称为`MaxWeight`）这样做，您可能会得到意想不到的结果；获取最重的物品将需要遍历所有物品的集合，并按重量找到最大值。这个过程不像你期望的那样快。事实上，在某些情况下，它甚至可能会抛出错误。属性应该有简单的逻辑，否则与它们一起工作可能会产生意想不到的结果。因此，当需要计算密集型属性时，考虑将它们重构为方法。在这种情况下，您将`MaxWeight`属性重构为`GetMaxWeight`方法。
- en: Properties should be avoided for returning results of complex calculations,
    as calling a property could be expensive. Getting or setting the value of a field
    should be straightforward. If it becomes expensive, it should no longer be treated
    as property.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 应避免使用属性返回复杂计算的结果，因为调用属性可能很昂贵。获取或设置字段的值应该是直接的。如果变得昂贵，它就不应该再被视为属性。
- en: An Effective Class
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个有效的类
- en: The `Dog` class models a `dog` object; therefore, it can be called a model.
    Some developers prefer to have a strict separation between data and logic. Others
    try to put as much logic in a model as possible, so long as it is self-contained.
    There is no right or wrong way here. It all depends on the context you are working
    with.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dog`类模拟了一个`dog`对象；因此，它可以被称为模型。一些开发人员更喜欢在数据和逻辑之间有严格的分离。其他人则尽可能多地将逻辑放入模型中，只要它是自包含的。这里没有对与错的方法。这一切都取决于您所处理的上下文。'
- en: Note
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This discussion is outside the scope of this chapter, but if you would like
    to know more, you can refer to the discussion on Domain-Driven Design (DDD) at
    [https://martinfowler.com/bliki/DomainDrivenDesign.html](https://martinfowler.com/bliki/DomainDrivenDesign.html).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这个讨论超出了本章的范围，但如果您想了解更多，可以参考[https://martinfowler.com/bliki/DomainDrivenDesign.html](https://martinfowler.com/bliki/DomainDrivenDesign.html)上关于领域驱动设计（DDD）的讨论。
- en: 'It is hard to pinpoint what an effective class looks like. However, when deciding
    whether a method fits better in class A or class B, try asking yourself these
    questions:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 很难准确描述一个有效的类是什么样的。但是，在决定方法更适合于A类还是B类时，尝试问自己以下问题：
- en: Would someone, who is not a programmer, know that you are talking about the
    class? Is it a logical representation of a real-world concept?
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不是程序员的人会知道您在谈论类吗？它是对现实世界概念的逻辑表示吗？
- en: How many reasons does the class have to change? Is it just one or are there
    more reasons?
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类有多少个原因需要更改？只有一个还是有更多原因？
- en: Is private data tightly related to public behavior?
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 私有数据是否与公共行为紧密相关？
- en: How often does the class change?
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类有多经常更改？
- en: How easy is it to break the code?
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码容易出错吗？
- en: Does the class do something by itself?
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类自己是否做了什么？
- en: High cohesion is a term used to describe a class that has all its members strongly
    related, not only semantically, but logically as well. In contrast, a low cohesion
    class has loosely related methods and fields that probably could have a better
    place. Such a class is inefficient because it changes for multiple reasons and
    you cannot expect to look for anything inside it, as it simply has no strong logical
    meaning.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 高内聚性是一个用来描述一个类的术语，它的所有成员不仅在语义上，而且在逻辑上都是强相关的。相比之下，低内聚性的类具有松散相关的方法和字段，这些方法和字段可能有更好的位置。这样的类是低效的，因为它因多种原因而改变，你不能期望在其中查找任何东西，因为它根本没有强烈的逻辑意义。
- en: 'For example, a part of a `Computer` class could look like this:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`Computer`类的一部分可能如下所示：
- en: '[PRE41]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'However, `Computer` and `keys` are not related at the same level. There could
    be another class that better suits the `Key` class, that is `Keyboard`:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`Computer`和`keys`并不是在同一级别相关的。可能有另一个类更适合`Key`类，那就是`Keyboard`：
- en: '[PRE42]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Note
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/FFcDa](https://packt.link/FFcDa).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://packt.link/FFcDa](https://packt.link/FFcDa)找到此示例使用的代码。
- en: A keyboard is directly related to keys, just as it is directly related to a
    computer. Here, both `Keyboard` and the `Computer` class have high cohesion because
    the dependencies have a stable logical place. You can now learn more about it
    through an exercise.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 键盘与键直接相关，就像它与计算机直接相关一样。在这里，`Keyboard`和`Computer`类都具有高内聚性，因为依赖关系有一个稳定的逻辑位置。现在，你可以通过练习更多地了解它。
- en: 'Exercise 2.02: Comparing the Area Occupied by Different Shapes'
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习2.02：比较不同形状占用的面积
- en: You have two sections of a backyard, one with circular tiles and the other with
    rectangular tiles. You would like to deconstruct one section of the backyard,
    but you are not sure which one it should be. Obviously, you want as little mess
    as possible and have decided to pick the section that occupies the least area.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 你有两个后院的区域，一个有圆形瓷砖，另一个有矩形瓷砖。你想要拆除后院的一个区域，但你不确定应该拆除哪一个。显然，你希望尽可能少地弄脏，因此决定选择占用面积最小的区域。
- en: Given two arrays, one for different sized rectangular tiles and the other for
    different-sized circular tiles, you need to find which section to deconstruct.
    This exercise aims to output the name of the section occupying less area, that
    is, `rectangular` or  `circular`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 给定两个数组，一个是不同尺寸的矩形瓷砖，另一个是不同尺寸的圆形瓷砖，你需要找出哪个区域要拆除。这个练习旨在输出占用面积较小的区域的名称，即`rectangular`或`circular`。
- en: 'Perform the following steps to do so:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤来完成这个过程：
- en: 'Create a `Rectangle` class as follows. It should have fields for `width`, `height`,
    and `area`:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`Rectangle`类如下。它应该有`width`、`height`和`area`字段：
- en: '[PRE43]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Here, `_width` and `_height` have been made immutable, using the `readonly`
    keyword. The type chosen is `double` because you will be performing `math` operations.
    The only property that is exposed publicly is `Area`. It will return a simple
    calculation: the product of width and height. The `Rectangle` is immutable, so
    all it needs is to be passed once through a constructor and it remains constant thereafter.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，使用`readonly`关键字使`_width`和`_height`成为不可变的。所选的类型是`double`，因为你将执行`math`操作。唯一公开的属性是`Area`。它将返回一个简单的计算：宽度和高度的乘积。`Rectangle`是不可变的，因此它只需要通过构造函数传递一次，之后保持不变。
- en: 'Similarly, create a `Circle` class as follows:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，创建一个`Circle`类如下：
- en: '[PRE44]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The `Circle` class is similar to `Rectangle` class, except that instead of width
    and height, it has `radius`, and the `Area` calculation uses a different formula.
    The constant `PI` has been used, which can be accessed from the `Math` namespace.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`Circle`类与`Rectangle`类类似，只是它有`radius`而不是宽度和高度，并且`Area`的计算使用了不同的公式。使用了常量`PI`，可以从`Math`命名空间中访问。'
- en: 'Create a `Solution` class with a skeleton method named `Solve`:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Solve`的骨架方法的`Solution`类：
- en: '[PRE45]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Here, the `Solution` class demonstrates how the code works. For now, there are
    three constants based on the requirements (which section is bigger? rectangular
    or circular, or are they equal?). Also, the flow will be to calculate the total
    area of rectangles, then of circles and finally return the bigger.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`Solution`类演示了代码的工作原理。目前，有三个基于要求的常量（哪个区域更大？矩形还是圆形，或者它们相等？）。此外，流程将是先计算矩形的总面积，然后是圆形的总面积，最后返回更大的那个。
- en: Before you can implement the solution, you must first create side methods for
    calculating the total area of the rectangular section, calculating the total area
    of the circular section, and comparing the two. You will do this over the next
    few steps.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现解决方案之前，你必须首先创建用于计算矩形部分的总面积、计算圆形部分的总面积和比较两者的辅助方法。你将在接下来的几个步骤中完成这些工作。
- en: 'Inside `Solution` class, add a method to calculate the total area of the rectangular
    section:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Solution`类中，添加一个方法来计算矩形部分的总面积：
- en: '[PRE46]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This method goes through all the rectangles, gets the area of each, and adds
    it to the total sum.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法遍历所有矩形，获取每个矩形的面积，并将其添加到总和中。
- en: 'Similarly, add a method to calculate the total area of the circular section:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，添加一个方法来计算圆形部分的总面积：
- en: '[PRE47]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Next, add a method to get the bigger area, as follows:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加一个获取更大面积的方法，如下所示：
- en: '[PRE48]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This snippet contains the most interesting part. In most languages, numbers
    with a decimal point are not accurate. In fact, in most cases, if a and b are
    floats or doubles, it is likely that they will never be equal. Therefore, when
    comparing such numbers, you must consider precision.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码包含了最有趣的部分。在大多数语言中，带有小数点的数字是不准确的。实际上，在大多数情况下，如果a和b是浮点数或双精度浮点数，它们可能永远不会相等。因此，在比较这样的数字时，你必须考虑精度。
- en: In this code, you have defined the margin, to have an acceptable range of accuracy
    of your comparison for when the numbers are considered equal (for example, 0.001
    and 0.0011 will be equal in this case since the margin is 0.01). After this, you
    can do a regular comparison and return the value for whichever section has the
    biggest area.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, create the `Main` method, as follows:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Here, four sets of shapes are created for comparison. `compare1` has two empty
    sections, meaning they should be equal. `compare2` has a rectangle and no circles,
    so the rectangle is bigger. `compare3` has a circle and no rectangle, so the circles
    are bigger. Finally, `compare4` has both rectangles and circles, but the total
    area of the circles is bigger. You used string interpolation inside `Console.WriteLine`
    to print the results.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code. You should see the following being printed to the console:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Note
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code used for this exercise at [https://packt.link/tfDCw](https://packt.link/tfDCw).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: What if you did not have objects? What would the section be made of in that
    case? For a circle, it might be viable to just pass radii, but for rectangles,
    you would need to pass another collinear array with widths and heights.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: Object-oriented code is great for grouping similar data and logic under one
    shell, that is, a class, and passing those class objects around. In this way,
    you can simplify complex logic through simple interaction with a class.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: You will now know about the four pillars of OOP.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: The Four Pillars of OOP
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Efficient code should be easy to grasp and maintain, and OOP strives to achieve
    such simplicity. The entire concept of object-oriented design is based on four
    main tenets, also known as the four pillars of OOP.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: Encapsulation
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first pillar of OOP is encapsulation. It defines the relationship between
    data and behavior, placed in the same shell, that is, a class. It refers to the
    need to expose only what is necessary and hide everything else. When you think
    about encapsulation, think about the importance of security for your code: what
    if you leak a password, return confidential data, or make an API key public? Being
    reckless often leads to damage that can be hard to fix.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: Security is not just limited to protection from malicious intent, but also extends
    to preventing manual errors. Humans tend to make mistakes. In fact, the more options
    there are to choose from, the more mistakes they are likely to make. Encapsulation
    helps in that regard because you can simply limit the number of options available
    to the person who will use the code.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: 'You should prevent all access by default, and only grant explicit access when
    necessary. For example, consider a simplified `LoginService` class:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'This class has two `private` fields: `_usernames` and `_passwords`. The key
    point to note here is that neither passwords nor usernames are accessible to the
    public, but you can still achieve the required functionality by exposing just
    enough logic publicly, through the `Login` method.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: You can find this code used for this example at [https://packt.link/6SO7a](https://packt.link/6SO7a).
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A police officer can arrest someone, a mailman delivers mail, and a teacher
    teaches one or more subjects. Each of them performs widely different duties, but
    what do they all have in common? In the context of the real world, they are all
    human. They all have a name, age, height, and weight. If you were to model each,
    you would need to make three classes. Each of those classes would look the same,
    other than one unique method for each. How could you express in code that they
    are all human?
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: The key to solving this problem is inheritance. It allows you to take all the
    properties from a parent class and transfer them to its child class. Inheritance
    also defines an is-a relationship. A police officer, a mailman, and a teacher
    are all humans, and so you can use inheritance. You will now write this down in
    code.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `Human` class that has fields for `name`, `age`, `weight`, and `height`:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'A mailman is a human. Therefore, the `Mailman` class should have all that a
    `Human` class has, but on top of that, it should have the added functionality
    of being able to deliver mail. Write the code for this as follows:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Now, look closely at the `Mailman` class. Writing `class Mailman : Human` means
    that `Mailman` inherits from `Human`. This means that `Mailman` takes all the
    properties and methods from `Human`. You can also see a new keyword, `base`. This
    keyword is used to tell which parent constructor is going to be used when creating
    `Mailman`; in this case, `Human`.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, create a class named `Mail` to represent the mail, containing a field
    for a message being delivered to an address:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Creating a `Mailman` object is no different than creating an object of a class
    that does not use inheritance.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: 'Create `mailman` and `mail` variables and tell the `mailman` to deliver the
    mail as follows:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Note
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code used for this example at [https://packt.link/w1bbf](https://packt.link/w1bbf).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding snippet, you created `mailman` and `mail` variables. Then,
    you told the `mailman` to deliver the `mail`.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: 'Generally, a base constructor must be provided when defining a child constructor.
    The only exception to this rule is when the parent has a parameter-less constructor.
    If a base constructor takes no arguments, then a child constructor using a base
    constructor would be redundant and therefore can be ignored. For example, consider
    the following snippet:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '`A` has no custom constructors, so implementing `B` would not require a custom
    constructor either.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: In C#, only a single class can be inherited; however, you can have a multi-level
    deep inheritance. For example, you could have a child class for `Mailman` named
    `RegionalMailman`, which would be responsible for a single region. In this way,
    you could go deeper and have another child class for `RegionalMailman`, called
    `RegionalBillingMailman`, then `EuropeanRegionalBillingMailman`, and so on.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: When using inheritance, it is important to know that even if everything is inherited,
    not everything is visible. Just like before, `public` members only will be accessible
    from a parent class. However, in C#, there is a special modifier, named `protected`,
    that works like the `private` modifier. It allows child classes to access `protected`
    members (just like `public` members) but prevents them from being accessed from
    the outside of the class (just like `private`).
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: Decades ago, inheritance used to be the answer to many problems and the key
    to code reuse. However, over time, it became apparent that using inheritance comes
    at a price, which is coupling. When you apply inheritance, you couple a child
    class with a parent. Deep inheritance stacks class scope all the way from parent
    to child. The deeper the inheritance, the deeper the scope. Deep inheritance (two
    or more levels deep) should be avoided for the same reason you avoid global variables—it
    is hard to know what comes from where and hard to control the state changes. This,
    in turn, makes the code difficult to maintain.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: 'Nobody wants to write duplicate code, but what is the alternative? The answer
    to that is composition. Just as a computer is composed of different parts, code
    should be composed of different parts as well. For example, imagine you are developing
    a 2D game and it has a `Tile` object. Some tiles contain a trap, and some tiles
    move. Using inheritance, you could write the code like this:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: This approach works fine until you face more complex requirements. What if there
    are tiles that could both be a trap and move? Should you inherit from a moving
    tile and rewrite the `TrapTile` functionality there? Could you inherit both? As
    you have seen, you cannot inherit more than one class at a time, therefore, if
    you were to implement this using inheritance, you would be forced to both complicate
    the situation, and rewrite some code. Instead, you could think about what different
    tiles contain. `TrapTile` has a trap. `MovingTile` has a motor.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: Both represent tiles, but the extra functionality they each have should come
    from different components, and not child classes. If you wanted to make this a
    composition-based approach, you would need to refactor quite a bit.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this, keep the `Tile` class as-is:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Now, add two components—Motor and Trap classes. Such components serve as logic
    providers. For now, they do nothing:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Note
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code used for this example at [https://packt.link/espfn](https://packt.link/espfn).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, you define a `MovingTile` class that has a single component, `_motor`.
    In composition, components rarely change dynamically. You should not expose class
    internals, so apply `private readonly` modifiers. The component itself can have
    a child class or change, and so should not be created from the constructor. Instead,
    it should be passed as an argument (see the highlighted code):'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Note that the `Move` method now calls `_motor.Move()`. That is the essence of
    composition; the class that holds composition often does nothing by itself. It
    just delegates the calls of logic to its components. In fact, even though this
    is just an example class, a real class for a game would look quite similar to
    this.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: 'You will do the same for `TrapTile`, except that instead of `Motor`, it will
    contain a `Trap` component:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Finally, it''s time to create the `MovingTrapTile` class. It has two components
    that provide logic to the `Move` and `Damage` methods. Again, the two methods
    are passed as arguments to a constructor:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Note
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code used for this example at [https://packt.link/SX4qG](https://packt.link/SX4qG).
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: It might seem that this class repeats some code from the other class, but the
    duplication is negligible, and the benefits are well worth it. After all, the
    biggest chunk of logic comes from the components themselves, and a repeated field
    or a call is not significant.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that you inherited `Tile`, despite not extracting it as
    a component for other classes. This is because `Tile` is the essence of all the
    classes that inherit it. No matter what type a tile is, it is still a tile. Inheritance
    is the second pillar of OOP. It is powerful and useful. However, it can be hard
    to get inheritance right, because in order to be maintainable, it truly needs
    to be very clear and logical. When choosing whether you should use inheritance,
    consider these factors:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: Not deep (ideally single level).
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logical (is-a relation, as you saw in your tiles example).
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stable and extremely unlikely for the relationship between classes to change
    in the future; not going to be modified often.
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Purely additive (child class should not use parent class members, except for
    a constructor).
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If any one of these rules is broken, it is recommended to use composition instead
    of inheritance.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: Polymorphism
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The third pillar of OOP is polymorphism. To grasp this pillar, it is useful
    to look at the meaning of the word. `Thomas`. `Thomas` is both a human and a mailman.
    `Mailman` is the specialized form and `Human` is the generalized form for Thomas.
    However, you can interact with `Thomas` through either of the two forms.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: If you do not know the jobs for every human, you can use an `abstract` class.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: 'An `abstract` class is a synonym for an incomplete class. This means that it
    cannot be initialized. It also means that some of its methods may not have an
    implementation if you mark them with the `abstract` keyword. You can implement
    this for the `Human` class as follows:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: You have created an abstract (incomplete) `Human` class here. The only difference
    from earlier is that you have applied the `abstract` keyword to the class and
    added a new `abstract` method, `public abstract void Work()`. You have also changed
    the constructor to protected so that it is accessible only from a child class.
    This is because it no longer makes sense to have it `public` if you cannot create
    an `abstract` class; you cannot call a `public` constructor. Logically, this means
    that the `Human` class, by itself, has no meaning, and it only gets meaning after
    you have implemented the `Work` method elsewhere (that is, in a child class).
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you will update the `Mailman` class. It does not change much; it just
    gets an additional method, that is, `Work()`. To provide an implementation for
    abstract methods, you must use the `override` keyword. In general, this keyword
    is used to change the implementation of an existing method inside a child class.
    You will explore this in detail later:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'If you were to create a new object for this class and call the `Work` method,
    it would print `"A mailman is delivering mails."` to the console. To get a full
    picture of polymorphism, you will now create one more class, `Teacher`:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: This class is almost identical to `Mailman`; however, a different implementation
    for the `Work` method is provided. Thus, you have two classes that do the same
    thing in two different ways. The act of calling a method of the same name, but
    getting different behavior, is called polymorphism.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: 'You already know about method overloading (not to be confused with overriding),
    which is when you have methods with the same names but different inputs. That
    is called static polymorphism and it happens during compile time. The following
    is an example of this:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The `Person` class has two methods with the same name, Say. One takes no arguments
    and the other takes a string as an argument. Depending on the arguments passed,
    different implementations of the method will be called. If nothing is passed,
    `"Hello"` will be printed. Otherwise, the words you pass will be printed.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: In the context of OOP, polymorphism is referred to as dynamic polymorphism,
    which happens during runtime. For the rest of this chapter, polymorphism should
    be interpreted as dynamic polymorphism.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: What is the Benefit of Polymorphism?
  id: totrans-277
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A teacher is a human, and the way a teacher works is by teaching. This is not
    the same as a mailman, but a teacher also has a name, age, weight, and height,
    like a mailman. Polymorphism allows you to interact with both in the same way,
    regardless of their specialized forms. The best way to illustrate this is to store
    both in an array of `humans` values and make them work:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'This code results in the following being printed in the console:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Note
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code used for this example at [https://packt.link/ovqru](https://packt.link/ovqru).
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: This code was polymorphism in action. You treated both `Mailman` and `Teacher`
    as `Human` and implemented the `Work` method for both. The result was different
    behaviors in each case. The important point to note here is that you did not have
    to care about the exact implementations of `Human` to implement `Work`.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: 'How would you implement this without polymorphism? You would need to write
    `if` statements based on the exact type of an object to find the behavior it should
    use:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: As you see, this is a lot more complicated and harder to grasp. Keep this example
    in mind when you get into a situation with many `if` statements. Polymorphism
    can remove the burden of all that branching code by simply moving the code for
    each branch into a child class and simplifying the interactions.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: 'What if you wanted to print some information about a person? Consider the following code:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Running this code would result in the object type names being printed to the
    console:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: In C#, everything derives from the `System.Object` class, so every single type
    in C# has a method called `ToString()`. Each type has its own implementation of
    this method, which is another example of polymorphism, widely used in C#.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '`ToString()` is different from `Work()` in that it provides a default implementation.
    You can achieve that using the `virtual` keyword, which will be covered in detail
    later in the chapter. From the point of view of a child class, working with the
    `virtual` or `abstract` keyword is the same. If you want to change or provide
    behavior, you will override the method.'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following snippet, a `Human` object is given a custom implementation
    of the `ToString()` method:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Trying to print information about the humans in the same foreach loop would
    result in the following output:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Note
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code used for this example at [https://packt.link/EGDkC](https://packt.link/EGDkC).
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: Polymorphism is one of the best ways to use different underlying behaviors when
    dealing with missing type information.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: Abstraction
  id: totrans-302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The last pillar of OOP is abstraction. Some say that there are only three pillars
    of OOP because abstraction does not really introduce much that is new. Abstraction
    encourages you to hide implementation details and simplify interactions between
    objects. Whenever you need the functionality of only a generalized form, you should
    not depend on its implementation.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: Abstraction could be illustrated with an example of how people interact with
    their computers. What occurs in the internal circuitry when you turn on the computer?
    Most people would have no clue, and that is fine. You do not need to know about
    the internal workings if you only need to use some functionality. All you have
    to know is what you can do, and not how it works. You know you can turn a computer
    on and off by pressing a button, and all the complex details are hidden away.
    Abstraction adds little new to the other three pillars because it reflects each
    of them. **Abstraction is similar to encapsulation**, as it hides unnecessary
    details to simplify interaction. It is also similar to polymorphism because it
    can interact with objects without knowing their exact types. Finally, inheritance
    is just one of the ways to create abstractions.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: 'You do not need to provide unnecessary details coming through implementation
    types when creating functions. The following example illustrates this problem.
    You need to make a progress bar. It should keep track of the current progress
    and should increment the progress up to a certain point. You could create a basic
    class with setters and getters, as follows:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The following code demonstrates how to initialize a progress bar that starts
    at `0` progress and goes up to `100`. The rest of the code illustrates what happens
    when you want to set the new progress to 120\. Progress cannot be more than `Max`,
    hence, if it is more than `bar.Max`, it should just remain at `bar.Max`. Otherwise,
    you can update the new progress with the value you set. Finally, you need to check
    whether the progress is complete (at `Max` value). To do so, you will compare
    the delta with the allowed margin of error tolerance (`0.0001`). A progress bar
    is complete if it is close to tolerance. So, updating progress could look like
    the following:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: This code does what is asked for, but it needs a lot of detail for a function.
    Imagine if you had to use this in other code; you would need to perform the same
    checks once again. In other words, it was easy to implement but complex to consume.
    You have so little within the class itself. A strong indicator of that is that
    you keep on calling the object, instead of doing something inside the class itself.
    Publicly, it's possible to break the object state by forgetting to check the `Max`
    value of progress and setting it to some high or negative value. The code that
    you wrote has low cohesion because to change `ProgressBar`, you would do it not
    within the class but somewhere outside of it. You need to create a better abstraction.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following snippet:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: With this code, you have hidden the nitty-gritty details. When it comes to updating
    progress and defining what the tolerance is, that is up to the `ProgressBar` class
    to decide. In the refactored code, you have a property, `Current`, with a backing
    field, `_current`, to store the progress. The property setter checks whether progress
    is more than the maximum and, if it is, it will not allow the value of `_current`
    to be set to a higher value, `=`. It also cannot be negative, as in those cases,
    the value will be adjusted to `0`. Lastly, if it is not negative and not more
    than the maximum, then you can set `_current` to whatever value you pass.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: 'Clearly, this code makes it much simpler to interact with the `ProgressBar`
    class:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: You cannot break anything; you do not have any extra choices and all you can
    do is defined through minimalistic methods. When you are asked to implement a
    feature, it is not recommended to do more than what is asked. Try to be minimalistic
    and simplistic because that is key to an effective code.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: Remember that well-abstracted code is full of empathy toward the reader. Just
    because today, it is easy to implement a class or a function, you should not forget
    about tomorrow. The requirements change, the implementation changes, but the structure
    should remain stable, otherwise, your code can break easily.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code used for this example can be found at [https://packt.link/U126i](https://packt.link/U126i).
    The code given in GitHub is split into two contrasting examples—`ProgressBarGood`
    and `ProgressBarBad`. Both codes are simple `ProgressBar` but were named distinctly
    to avoid ambiguity.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces
  id: totrans-319
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Earlier, it was mentioned that inheritance is not the proper way of designing
    code. However, you want to have an efficient abstraction as well as support for
    polymorphism, and little to no coupling. What if you wanted to have robot or ant
    workers? They do not have a name. Information such as height and weight are irrelevant.
    And inheriting from the `Human` class would make little sense. Using an interface
    solves this conundrum.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: In C#, by convention, interfaces are named starting with the letter `I`, followed
    by their actual name. An interface is a contract that states what a class can
    do. It does not have any implementation. It only defines behavior for every class
    that implements it. You will now refactor the human example using an interface.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: 'What can an object of the `Human` class do? It can work. Who or what can do
    work? A worker. Now, consider the following snippet:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Note
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: Interface `Work` method will have is the same as the interface access modifier,
    in this case, `public`.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: 'An ant is not a human, but it can work. With an interface, abstracting an ant
    as a worker is straightforward:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Similarly, a robot is not a human, but it can work as well:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'If you refer to the `Human` class, you can change its definition to `public
    abstract class Human : IWorker`. This can be read as: `Human` class implements
    the `IWorker` interface.'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next snippet, `Mailman` inherits the `Human` class, which implements
    the `IWorker` interface:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: If a child class inherits a parent class, which implements some interfaces,
    the child class will also be able to implement the same interfaces by default.
    However, `Human` was an abstract class and you had to provide implementation to
    the `abstract void Work` method.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: 'If anyone asked what a human, an ant, and a robot have in common, you could
    say that they can all work. You can simulate this situation as follows:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'This prints the following to the console:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Note
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code used for the example at [https://packt.link/FE2ag](https://packt.link/FE2ag).
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: 'C# does not support multiple inheritance. However, it is possible to implement
    multiple interfaces. Implementing multiple interfaces does not count as multiple
    inheritance. For example, to implement a `Drone` class, you could add an `IFlyer` interface:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '`Drone` is a flying object that can do some work; therefore it can be expressed
    as follows:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Listing multiple interfaces with separating commas means the class implements
    each of them. You can combine any number of interfaces, but try not to overdo
    this. Sometimes, a combination of two interfaces makes up a logical abstraction.
    If every drone can fly and does some work, then you can write that in code, as
    follows:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'And the `Drone` class becomes simplified to `public class Drone : IDrone`.'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also possible to mix interfaces with a base class (but no more than one
    base class). If you want to represent an ant that flies, you can write the following
    code:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: An interface is undoubtedly the best abstraction because depending on it does
    not force you to depend on any implementation details. All that is required is
    the logical concepts that have been defined. Implementation is prone to change,
    but the logic behind relations between classes is not.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: 'If an interface defines what a class can do, is it also possible to define
    a contract for common data? Absolutely. An interface holds behavior, hence it
    can hold properties as well because they define setter and getter behavior. For
    example, you should be able to track the drone, and for this, it should be identifiable,
    that is, it needs to have an ID. This can be coded as follows:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'In modern software development, there are several complex low-level details
    that programmers use on a daily basis. However, they often do so without knowing.
    If you want to create a maintainable code base with lots of logic and easy-to-grasp
    code, you should follow these principles of abstraction:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: Keep it simple and small.
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do not depend on details.
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hide complexity.
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Expose only what is necessary.
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With this exercise, you will grasp how OOP functions.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 2.03: Covering Floor in the Backyard'
  id: totrans-358
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A builder is building a mosaic with which he needs to cover an area of x square
    meters. You have some leftover tiles that are either rectangular or circular.
    In this exercise, you need to find out whether, if you shatter the tiles to perfectly
    fill the area they take up, can the tiles fill the mosaic completely.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: 'You will write a program that prints `true`, if the mosaic can be covered with
    tiles, or `false`, if it cannot. Perform the following steps to do so:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an interface named `IShape`, with an `Area` property:'
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: This is a get-only property. Note that a property is a method, so it is okay
    to have it in an interface.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a class called `Rectangle`, with width and height and a method for calculating
    area, called `Area`. Implement an `IShape` interface for this, as shown in the
    following code:'
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: The only thing required is to calculate the area. Hence, only the `Area` property
    is `public`. Your interface needs to implement a getter `Area` property, achieved
    by multiplying `width` and `height`.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `Circle` class with a `radius` and `Area` calculation, which also
    implements the `IShape` interface:'
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Create a skeleton `Solution` class with a method named `IsEnough`, as follows:'
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Both the class and the method are just placeholders for the implementation to
    come. The class is `static` because it will be used as a demo and it does not
    need to have a state. The `IsEnough` method takes the needed `mosaicArea`, an
    array of tiles objects, and returns whether the total area occupied by the tiles
    is enough to cover the mosaic.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `IsEnough` method, use a `for` loop to calculate the `totalArea`.
    Then, return whether the total area covers the mosaic area:'
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Inside the `Solution` class, create a demo. Add several sets of different shapes,
    as follows:'
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Here, you use four examples. When the area to cover is `0`, then no matter what
    shapes you pass, it will be enough. When the area to cover is `1`, a rectangle
    of area `1x1` will be just enough. When it's `100`, a circle of radius `5` is
    not enough. Finally, for the fourth example, the area occupied by three shapes
    is added up, that is, a rectangle of area `1x1`, a circle of radius `1`, and the
    second rectangle of area `1.4x1`. The total area is `5`, which is less than the
    combined area of these three shapes.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the demo. You should see the following output on your screen:'
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Note
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code used for this exercise at [https://packt.link/EODE6](https://packt.link/EODE6).
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: This exercise is very similar to *Exercise 2.02*. However, even though the assignment
    is more complex, there is less code than in the previous assignment. By using
    the OOP pillars, you were able to create a simple solution for a complex problem.
    You were able to create functions that depend on abstraction, rather than making
    overloads for different types. Thus, OOP is a powerful tool, and this only scratches
    the surface.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: Everyone can write code that works but writing code that lives for decades and
    is easy to grasp is hard. So, it is imperative to know about the set of best practices
    in OOP.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: SOLID Principles in OOP
  id: totrans-384
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SOLID principles are a set of best practices for OOP. SOLID is an acronym for
    five principles, namely, single responsibility, open-closed, Liskov substitution,
    interface segregation, and dependency inversion. You will not explore each of
    these in detail.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: Single Responsibility Principle
  id: totrans-386
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Functions, classes, projects, and entire systems change over time. Every change
    is potentially a breaking one, so you should limit the risk of too many things
    changing at a time. In other words, a part of a code block should have only a
    single reason to change.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: For a function, this means that it should do just one thing and have no side
    effects. In practice, this means that a function should either change, or get
    something, but never do both. This also means that functions responsible for high-level
    things should not be mixed with functions that perform low-level things. Low-level
    is all about implementing interactions with hardware, and working with primitives.
    High-level is focused on compositions of software building blocks or services.
    When talking about high- and low-level functions, it is usually referred to as
    a chain of dependencies. If function A calls function B, A is considered higher-level
    than B. A function should not implement multiple things; it should instead call
    other functions that implement doing one thing. The general guideline for this
    is that if you think you can split your code into different functions, then in
    most cases, you should do that.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: 'For classes, it means that you should keep them small and isolated from one
    another. An example of an efficient class is the `File` class, which can read
    and write. If it implemented both reading and writing, it would change for two
    reasons (reading and writing):'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Therefore, to conform to this principle, you can split the reading code into
    a class called `Reader` and writing code into a class called `Writer`, as follows:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Now, instead of implementing reading and writing by itself, the `File` class
    will simply be composed of a reader and writer:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Note
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code used for this example at [https://packt.link/PBppV](https://packt.link/PBppV).
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: It might be confusing because what the class does essentially remains the same.
    However, now, it just consumes a component and is not responsible for implementing
    it. A high-level class (`File`) simply adds context to how lower-level classes
    (`Reader`, `Writer`) will be consumed.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: For a module (library), it means that you should strive to not introduce dependencies,
    which would be more than what the consumer would want. For example, if you are
    using a library for logging, it should not come with some third-party logging
    provider-specific implementation.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: For a subsystem, it means that different systems should be as isolated as possible.
    If two (lower level) systems need to communicate, they could call one another
    directly. A consideration (not mandatory) would be to have a third system (higher-level)
    for coordination. Systems should also be separated through a boundary (such as
    a contract specifying communication parameters), which hides all the details.
    If a subsystem is a big library collection, it should have an interface to expose
    what it can do. If a subsystem is a web service, it should be a collection of
    endpoints. In any case, a contract of a subsystem should provide only the methods
    that the client may want.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, the principle is overdone and classes are split so much that making
    a change requires changing multiple places. It does keep true to the principle,
    as a class will have a single reason to change, but in such a case, multiple classes
    will change for the same reason. For example, suppose you have two classes: `Merchandise`
    and `TaxCalculator`. The `Merchandise` class has fields for `Name`, `Price`, and
    `Vat`:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Next, you will create the `TaxCalculator` class. `vat` is measured as a percentage,
    so the actual price to pay will be `vat` added to the original price:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'What would change if the functionality of calculating the price moved to the
    `Merchandise` class? You would still be able to perform the required operation.
    There are two key points here:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: The operation by itself is simple.
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also, everything that the tax calculator needs come from the `Merchandise` class.
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If a class can implement the logic by itself, as long as it is self-contained
    (does not involve extra components), it usually should. Therefore, a proper version
    of the code would be as follows:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: This code moves the `NetPrice` calculation to the `Merchandise` class and the
    `TaxCalculator` class has been removed.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: 'Singe Responsibility Principle (SRP) can be summarized in a couple of words:
    **split it**. You can find the code used for this example at [https://packt.link/lWxNO](https://packt.link/lWxNO).'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: Open-Closed Principle
  id: totrans-412
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned previously, every change in code is potentially a breaking one.
    As a way around this, instead of changing existing code, it is often preferable
    to write new code. Every software entity should have an extension point, through
    which the changes should be introduced. However, after this change is done, a
    software entity should not be interfered with. The Open-Closed Principle (OCP)
    is hard to implement and takes a lot of practice, but the benefits (a minimum
    number of breaking changes) are well worth it.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: If a multiple-step algorithm does not change, but its individual steps can change,
    you should split it into several functions. A change for an individual step will
    no longer affect the entire algorithm, but rather just that step. Such minimization
    of reasons for a single class or a function to change is what OCP is all about.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: You can find more information on OCP at [https://social.technet.microsoft.com/wiki/contents/articles/18062.open-closed-principle-ocp.aspx](https://social.technet.microsoft.com/wiki/contents/articles/18062.open-closed-principle-ocp.aspx).
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: Another example where you may want to implement this principle is a function
    working with combinations of specific values in code. This is called hardcoding
    and is generally deemed an inefficient practice. To make it work with new values,
    you might be tempted to create a new function, but by simply removing a hardcoded
    part and exposing it through function parameters, you can make it extensible.
    However, when you have variables that are known to be fixed and not changing,
    it is fine to hardcode them, but they should be flagged as constant.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: 'Previously, you created a file class with two dependencies—`Reader` and `Writer`.
    Those dependencies are hardcoded, and leave you with no extension points. Fixing
    that will involve two things. First, add the virtual modifier for both the `Reader`
    and `Writer` class methods:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Then, change the constructor of the `File` class so that it accepts instances
    of `Reader` and `Writer`, instead of hardcoding the dependencies:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: This code enables you to override the existing reader and writer behavior and
    replace it with whatever behavior you want, that is, the `File` class extension
    point.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: OCP can be summarized in a few words as **don't change it, extend it**.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: Liskov Substitution
  id: totrans-424
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Liskov Substitution Principle (LSP) is one of the most straightforward
    principles out there. It simply means that a child class should support all the
    public behavior of a parent class. If you have two classes, `Car` and `CarWreck`,
    where one inherits the other, then you have violated the principle:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: Note
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code used for this example at [https://packt.link/6nD76](https://packt.link/6nD76).
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: Both `Car` and `CarWreck` have a `Body` object. `Car` can move, but what about
    `CarWreck`? It can only stay in one place. The `Move` method is virtual because
    `CarWreck` intends to override it to mark it as not supported. If a child can
    no longer support what a parent can do, then it should no longer inherit that
    parent. In this case, a car wreck is not a car, it's simply a wreck.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: 'How do you conform to this principle? All you have to do is to remove the inheritance
    relationship and replicate the necessary behavior and structure. In this case,
    `CarWreck` still has a `Body` object, but the `Move` method is unnecessary:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Code changes happen quite often, and you can sometimes inadvertently use the
    wrong method to achieve your goals. Sometimes, you couple code in such a way that
    what you thought was flexible code turns out to be a complex mess. Do not use
    inheritance as a way of doing code reuse. Keep things small and compose them (again)
    instead of trying to override the existing behavior. Before things can be reusable,
    they should be usable. Design for simplicity and you will get flexibility for free.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: 'LSP can be summarized in a few words: **don''t fake it**.'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: You can find more information on LSP at [https://www.microsoftpressstore.com/articles/article.aspx?p=2255313](https://www.microsoftpressstore.com/articles/article.aspx?p=2255313).
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: Interface Segregation
  id: totrans-436
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The interface segregation principle is a special case of the OCP but is only
    applicable to contracts that will be exposed publicly. Remember, every change
    you make is potentially a breaking change, and this especially matters in making
    changes to a contract. Breaking changes are inefficient because they will often
    require effort to adapt to the change from multiple people.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, say you have an interface, `IMovableDamageable`:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'A single interface should represent a single concept. However, in this case,
    it does two things: move and manage `Hp` (hit points). By itself, an interface
    with two methods is not problematic. However, in scenarios of the implementation
    needing only a part of an interface, you are forced to create a workaround.'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, score text is indestructible, but you would like it to be animated
    and to move it across a scene:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: Note
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: The point here isn't to print the location; just to give an example of where
    it is used. It's up to location's implementation whether it will be printed or
    not as such.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: 'Taking another example, you might have a house that does not move but can be destroyed:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'In both scenarios, you worked around the issue by throwing `NotSupportedException`.
    However, another programmer should not be given an option to call code that never
    works in the first place. In order to fix the problem of representing too many
    concepts, you should split the `IMoveableDamageable` interface into `IMoveable`
    and `IDamageable`:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'And the implementations can now get rid of the unnecessary parts:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: The `Console.WriteLine`, in the preceding code, would display the namespace
    name with the class name.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: Interface segregation can be summarized as **don't enforce it**. You can find
    the code used for this example at [https://packt.link/32mwP](https://packt.link/32mwP).
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: Dependency Inversion
  id: totrans-454
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Large software systems can consist of millions of classes. Each class is a small
    dependency, and if unmanaged, the complexity might stack into something impossible
    to maintain. If one low-level component breaks, it causes a ripple effect, breaking
    the whole chain of dependencies. The dependency inversion principle states that
    you should avoid hard dependence on underlying classes.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: Dependency injection is the industry-standard way of implementing dependency
    inversion. Do not mix the two; one is a principle and the other refers to the
    implementation of this principle.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can also implement dependency inversion without dependency injection.
    For example, when declaring a field, instead of writing something like `private
    readonly List<int> _numbers = new List<int>();`, it is preferable to write `private
    readonly IList<int> = _numbers`, which shifts dependency to abstraction (`IList`)
    and not implementation (`List`).
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: 'What is dependency injection? It is the act of passing an implementation and
    setting it to an abstraction slot. There are three ways to implement this:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: Constructor injection is achieved by exposing an abstraction through the constructor
    argument and passing an implementation when creating an object and then assigning
    it to a field. Use it when you want to consistently use the same dependency in
    the same object (but not necessarily the same class).
  id: totrans-459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Method injection is done by exposing an abstraction through a method argument,
    and then passing an implementation when calling that method. Use it when, for
    a single method, a dependency might vary, and you do not plan to store the dependency
    throughout that object's lifetime.
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Property injection is implemented by exposing an abstraction through a public
    property, and then assigning (or not) that property to some exact implementation.
    Property injection is a rare way of injecting dependencies because it suggests
    that dependency might even be null or temporary and there are many ways in which
    it could break.
  id: totrans-461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Given two types, `interface IBartender { }` and `class Bar : Bartender { }`,
    you can illustrate the three ways of dependency injection for a class called `Bar`.'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: 'First, prepare the `Bar` class for constructor injection:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'The constructor injection is done as follows:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: This kind of dependency injection is a dominating kind of inheritance, as it
    enforces stability through immutability. For example, some bars have just one
    bartender.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: 'Method injection would look like this:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'The injection itself is as follows:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: Often, this kind of dependency injection is called interface injection because
    the method often goes under an interface. The interface itself is a great idea,
    but that does not change the idea behind this kind of dependency injection. Use
    method injection when you immediately consume a dependency that you set, or when
    you have a complex way of setting new dependencies dynamically. For example, it
    makes sense to use different bartenders for serving drinks.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, property injection can be done like this:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'Bartender is now injected like this:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: For example, a bar might have bartenders changing shifts, but one bartender
    at a time.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code used for this example at [https://packt.link/JcmAT](https://packt.link/JcmAT).
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: 'Property injection in other languages might have a different name: setter injection.
    In practice, components do not change that often, so this kind of dependency injection
    is the rarest.'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
- en: 'For the `File` class, this should mean that instead of exposing classes (implementation),
    you should expose abstractions (interfaces). This means that your `Reader` and
    `Writer` classes should implement some contract:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'Your file class should expose reader and writer abstractions, instead of implementations,
    as follows:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: This allows for a choice of the kind of `IReader` and `IWriter` you would like
    to inject. A different reader may read a different file format, or a different
    writer may output in a different way. You have a choice.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
- en: Dependency injection is a powerful tool that is used often, especially in an
    enterprise setting. It allows you to simplify complex systems by putting an interface
    in between and having 1:1 dependencies of implementation-abstraction-implementation.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
- en: Writing effective code that does not break can be paradoxical. It is the same
    as buying a tool from a shop; you can't know for sure how long it will last, or
    how well it will work. Code, just like those tools, might work now but break in
    the near future, and you will only know that it does not work if and when it breaks.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
- en: Observing and waiting, seeing how the code evolves, is the only way to know
    for sure if you have written an effective code. In small, personal projects, you
    might not even notice any changes, unless you expose the project to the public
    or involve other people. To most people, SOLID principles often sound like old,
    outdated principles, like over-engineering. But they are actually a set of best
    practices that have withstood the test of time, formulated by top professionals
    seasoned in enterprise settings. It is impossible to write perfect, SOLID code
    right away. In fact, in some cases, it is not even necessary (if a project is
    small and meant to be short-lived, for example). As someone who wants to produce
    quality software and work as a professional, you should practice it as early on
    as possible.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
- en: How C# Helps with Object-Oriented Design
  id: totrans-489
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, the principles you have learned are not language-specific. It is time
    to learn how to use C# for OOP. C# is a great language because it is full of some
    very useful features. It is not only one of the most productive languages to work
    with, but it also allows you to write beautiful, hard-to-break code. With a rich
    selection of keywords and languages features, you can model your classes completely
    the way you want, making the intentions crystal clear. This section will delve
    deep into C# features that help with object-oriented design.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
- en: Static
  id: totrans-491
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Up till now in this book, you have interacted mostly with `static` code. This
    refers to code that does not need new classes and objects, and that can be called
    right away. In C#, the static modifier can be applied in five different scenarios—methods,
    fields, classes, constructors, and the `using` statement.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
- en: 'Static methods and fields are the simplest application of the `static` keyword:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: Note
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code used for this example at [https://packt.link/748m3](https://packt.link/748m3).
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, you created a class called `DogsGenerator`. A `static class` cannot be
    initialized manually (using the `new` keyword). Internally, it is initialized,
    but only once. Calling the `GenerateDog` method returns a new `Dog` object with
    a counter next to its name, such as `Dog1`, `Dog2`, and `Dog3`. Writing a counter
    like this allows you to increment it from everywhere as it is `public static`
    and has a setter. This can be done by directly accessing the member from a class:
    `DogsGenerator.Counter++` will increment the counter by `1`.'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
- en: Once again, note that this does not require a call through an object because
    a `static class` instance is the same for the entire application. However, `DogsGenerator`
    is not the best example of a `static class`. That's because you have just created
    a global state. Many people would say that `static` is inefficient and should
    be avoided because it might create unpredictable results due to being modified
    and accessed uncontrollably.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
- en: A public mutable state means that changes can happen from anywhere in the application.
    Other than being hard to grasp, such code is also prone to breaking in the context
    of applications with multiple threads (that is, it is not thread-safe).
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
- en: 'You will learn about threading in detail in *Chapter 5*, *Concurrency: Multithreading
    Parallel and Async Code*.'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
- en: You can reduce the impact of a global state by making it publicly immutable.
    The benefit of doing so is that now you are in control. Instead of allowing a
    counter increment to happen from any place inside a program, you will change it
    within `DogsGenerator` only. For the `counter` property, achieving it is as simple
    as making the setter property `private`.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
- en: There is one valuable use case for the `static` keyword though, which is with
    helper functions. Such functions take an input and return the output without modifying
    any state internally. Moreover, a class that contains such functions is `static`
    and has no state. Another good application of the `static` keyword is creating
    immutable constants. They are defined with a different keyword (`const`). The
    `PI` and `E`, static helper methods such as `Sqrt` and `Abs`, and so on.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
- en: The `DogsGenerator` class has no members that would be applicable to an object.
    If all class members are `static`, then the class should be `static` as well.
    Therefore, you should change the class to `public static class DateGenerator`.
    Be aware, however, that depending on `static` is the same as depending on a concrete
    implementation. Although they are easy to use and straightforward, static dependencies
    are hard to escape and should only be used for simple code, or code that you are
    sure will not change and is critical in its implementation details. For that reason,
    the `Math` class is a `static class` as well; it has all the foundations for arithmetic
    calculations.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
- en: 'The last application of `static` is `using static`. Applying the `static` keyword
    before a `using` statement causes all methods and fields to be directly accessible
    without the need to call a `class`. For example, consider the following code:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: This is a static import feature in C#. By using `static Math`, all static members
    can be accessed directly.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
- en: Sealed
  id: totrans-508
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Previously, you mentioned that inheritance should be handled with great care
    because the complexity can quickly grow out of hand. You can carefully consider
    complexity when you read and write code, but can you prevent complexity by design?
    C# has a keyword for stopping inheritance called `sealed`. If it logically makes
    no sense to inherit a class, then you should mark it with the `sealed` keyword.
    Security-related classes should also be sealed because it is critical to keep
    them simple and non-overridable. Also, if performance is critical, then methods
    in inherited classes are slower, compared to being directly in a sealed class.
    This is due to how method lookup works.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
- en: Partial
  id: totrans-510
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In .NET, it is quite popular to make desktop applications using `WinForms`.
    The way `WinForms` works is that you can design how your application looks, with
    the help of a designer. Internally, it generates UI code and all you have to do
    is double-click a component, which will generate event handler code. That is where
    the partial class comes in. All the boring, autogenerated code will be in one
    class and the code that you write will be in another. The key point to note is
    that both classes will have the same name but be in different files.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
- en: You can have as many partial classes as you want. However, the recommended number
    of partial classes is no more than two. The compiler will treat them as one big
    class, but to the user, they will seem like two separate ones. Generating code
    generates new class files, which will overwrite the code you write. Use `partial`
    when you are dealing with autogenerated code. The biggest mistake that beginners
    make is using `partial` to manage big complex classes. If your class is complex,
    it's best to split it into smaller classes, not just different files.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
- en: There is one more use case for `partial`. Imagine you have a part of code in
    a class that is only needed in another assembly but is unnecessary in the assembly
    it is originally defined in. You can have the same class in different assemblies
    and mark it as `partial`. That way, a part of a class that is not needed will
    only be used where it is needed and be hidden where it should not be seen.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
- en: Virtual
  id: totrans-514
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Abstract methods can be overridden; however, they cannot be implemented. What
    if you wanted to have a method with a default behavior that could be overridden
    in the future? You can do this using the `virtual` keyword, as shown in the following example:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'Here, the `Human` class has the `SayHi` method. This method is prefixed with
    the virtual keyword, which means that it can change behavior in a child class,
    for example:'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: Note
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code used for this example at [https://packt.link/ZpHhI](https://packt.link/ZpHhI).
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
- en: The `Frenchman` class inherits the `Human` class and overrides the `SayHi` method.
    Calling `SayHi` from a `Frenchman` object will print `Bonjour`.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
- en: One of the things about C# is that its behavior is hard to override. Upon declaring
    a method, you need to be explicit by telling the compiler that the method can
    be overridden. Only `virtual` methods can be overridden. Interface methods are
    virtual (because they get behavior later), however, you cannot override interface
    methods from child classes. You can only implement an interface in a parent class.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
- en: An abstract method is the last type of virtual method and is the most similar
    to `virtual` in that it can be overridden as many times as you need (in child
    and grandchild classes).
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
- en: To avoid having fragile, changing, overridable behavior, the best kind of virtual
    methods are the ones that come from an interface. The `abstract` and `virtual`
    keywords enable changing class behavior in child classes and overriding it, which
    can become a big issue if uncontrolled. Overriding behavior often causes both
    inconsistent and unexpected results, so you should be careful before using the
    `virtual` keyword.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
- en: Internal
  id: totrans-525
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`public`, `private`, and `protected` are the three access modifiers that have
    been mentioned. Many beginners think that the default class modifier is `private`.
    However, `private` means that it cannot be called from outside a class, and in
    the context of a namespace, this does not make much sense. The default access
    modifier for a class is `internal`. This means that the class will only be visible
    inside the namespace it is defined in. The `internal` modifier is great for reusing
    classes across the same assembly, while at the same time hiding them from the
    outside.'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
- en: Conditional Operators
  id: totrans-527
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A null reference exception is probably the most common error in programming.
    For example, refer to the following code:'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: This code will throw `NullReferenceException` because you are interacting with
    a variable that has a null value. What is the length of a null array? There is
    no proper answer to this question, so an exception will be thrown here.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
- en: The best way to protect against such an error is to avoid working with null
    values altogether. However, sometimes it is unavoidable. In those cases, there
    is another technique called defensive programming. Before using a value that might
    be `null`, make sure it is not `null`.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
- en: 'Now recall the example of the `Dog` class. If you create a new object, the
    value of `Owner` could be null. If you were to determine whether the owner''s
    name starts with the letter `A`, you would need to check first whether the value
    of `Owner` is `null`, as follows:'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  id: totrans-533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'However, in C#, using null-conditional, this code becomes as simple as the
    following:'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  id: totrans-535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: Null-conditional (`?`) is an example of conditional operators in C#. It is an
    operator that implicitly runs an `if` statement (a specific `if` statement is
    based on the operator) and either returns something or continues work. The `Owner?.StartsWith('A')`
    part returns `true` if the condition is satisfied and `false` if it is either
    not satisfied or the object is `null`.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
- en: There are more conditional operators in C# that you will learn about.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
- en: Ternary Operators
  id: totrans-538
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is hardly any language that does not have `if` statements. One of the
    most common kinds of `if` statement is `if-else`. For example, if the value of
    `Owner` is `null` for an instance of the `Dog` class, you can describe the instance
    simply as `{Name}`. Otherwise, you can better describe it as `{Name}, dog of {Owner}`,
    as shown in the following snippet:'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'C#, like many other languages, simplifies this by using a ternary operator:'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  id: totrans-542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: On the left side, you have a condition (true or false), followed by a question
    mark (`?`), which returns the value on the right if the condition is true, followed
    by a colon (`:`), which returns the value to the left if the condition is false.
    `$` is a string interpolation literal, which allows you to write `$"{dog1.Name},
    dog of {dog1.Owner}"` over `dog1.Name + "dog of" + dog1.Owner`. You should use
    it when concatenating text.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine there are two dogs now. You want the first dog to join the second one
    (that is, be owned by the owner of the second dog), but this can only happen if
    the second one has an owner to begin with. Normally, you would use the following
    code:'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  id: totrans-545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'But in C#, you can use the following code:'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'Here, you have applied the null-coalescing operator (`??`), which returns the
    value to the right if it is `null` and the value on the left if it is not `null`.
    However, you can simplify this further:'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  id: totrans-549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: This means that if the value that you are trying to assign (on the left) is
    `null`, then the output will be the value on the right.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
- en: 'The last use case for the null-coalescing operator is input validation. Suppose
    there are two classes, `ComponentA` and `ComponentB`, and `ComponentB` must contain
    an initialized instance of `ComponentA`. You could write the following code:'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'However, instead of the preceding code, you can simply write the following:'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: This can be read as If there is no `componentA`, then an exception must be thrown.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code used for this example at [https://packt.link/yHYbh](https://packt.link/yHYbh).
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
- en: In most cases, null operators should replace the standard `if null-else` statements.
    However, be careful with the way you use the ternary operator and limit it to
    simple `if-else` statements because the code can become unreadable very quickly.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
- en: Overloading Operators
  id: totrans-559
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is fascinating how much can be abstracted away in C#. Comparing primitive
    numbers, multiplying, or dividing them is easy, but when it comes to objects,
    it is not that simple. What is one person plus another person? What is a bag of
    apples multiplied by another bag of apples? It is hard to say, but it can make
    total sense in the context of some domains.
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider a slightly better example. Suppose you are comparing bank accounts.
    Finding out who has more money in a bank account is a common use case. Normally,
    to compare two accounts, you would have to access their members, but C# allows
    you to overload comparison operators so that you can compare objects. For example,
    imagine you had a `BankAccount` class like so:'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  id: totrans-562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'Here, the balance amount is `private`. You do not care about the exact value
    of `balance`; all you want is to compare one with another. You could implement
    a `CompareTo` method, but instead, you will implement a comparison operator. In
    the `BankAccount` class, you will add the following code:'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  id: totrans-564
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: The preceding code is called an operator overload. With a custom operator overload
    like this, you can return true when a balance is bigger and false otherwise. In
    C#, operators are `public static`, followed by a return type. After that, you
    have the `operator` keyword followed by the actual operator that is being overloaded.
    The input depends on the operator being overloaded. In this case, you passed two
    bank accounts.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
- en: 'If you tried to compile the code as it is, you would get an error that something
    is missing. It makes sense that the comparison operators have a twin method that
    does the opposite. Now, add the less operator overload as follows:'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  id: totrans-567
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'The code compiles now. Finally, it would make sense to have an equality comparison.
    Remember, you will need to add a pair, equal and not equal:'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  id: totrans-569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'Next, you will create bank accounts to compare. Note that all numbers have
    an `m` appended, as this suffix makes those numbers `decimal`. By default, numbers
    with a fraction are `double`, so you need to add `m` at the end to make them `decimal`:'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  id: totrans-571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'Comparing two bank accounts becomes as simple as this now:'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  id: totrans-573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'Running the code results in the following being printed to the console:'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  id: totrans-575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: Note
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code used for this example at [https://packt.link/5DioJ](https://packt.link/5DioJ).
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
- en: Many (but not all) operators can be overloaded, but just because you can do
    so does not mean you should. Overloading operators can make sense in some cases,
    but in other cases, it might be counterintuitive. Again, remember to not abuse
    C# features and use them when it makes **logical** sense, and when it makes code
    easier to read, learn, and maintain.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
- en: Nullable Primitive Types
  id: totrans-579
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Have you ever wondered what to do when a primitive value is unknown? For example,
    say a collection of products are announced. Their names, descriptions, and some
    other parameters are known, but the price is revealed only before the launch.
    What type should you use for storing the price values?
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
- en: 'Nullable primitive types are primitive types that might have some value or
    no value. In C#, to declare such a type, you have to add `?` after a primitive,
    as shown in the following code:'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  id: totrans-582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: Here, you declared a field that may or may not have a value. Specifically, this
    means that a can be unknown. Do not confuse this with a default value because,
    by default, the value of `int` types is `0`.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
- en: 'You can assign a value to a nullable field quite simply, as follows:'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  id: totrans-585
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'And to retrieve its value afterward, you can write the code as follows:'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  id: totrans-587
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: Generics
  id: totrans-588
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes, you will come across situations where you do the exact same thing
    with different types, where the only difference is because of the type. For example,
    if you had to create a method that prints an `int` value, you could write the
    following code:'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  id: totrans-590
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'Similarly, if you need to print a string, you could add yet another overload:'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  id: totrans-592
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'You did the same thing three times. Surely, there must be a way to reduce code
    duplication. Remember, in C#, all types derive from an `object` type, which has
    the `ToString()` method, so you can execute the following command:'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  id: totrans-594
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: Even though the last implementation contains the least code, it is actually
    the least efficient. An object is a reference type, whereas a primitive is a value
    type. When you take a primitive and assign it to an object, you also create a
    new reference to it. This is called boxing. It does not come for free, because
    you move objects from `stack to heap`. Programmers should be conscious of this
    fact and avoid it wherever possible.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
- en: 'Earlier in the chapter, you encountered polymorphism—a way of doing different
    things using the same type. You can do the same things with different types as
    well and generics are what enable you to do that. In the case of the `Print` example,
    a generic method is what you need:'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  id: totrans-597
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: Using diamond brackets (`<>`), you can specify a type, `T`, with which this
    function works. `<T>` means that it can work with any type.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, suppose you want to print all elements of an array. Simply passing a collection
    to a `WriteLine` statement would result in printing a reference, instead of all
    the elements. Normally, you would create a method that prints all the elements
    passed. With the power of generics, you can have one method that prints an array
    of any type:'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  id: totrans-600
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: Please note that the generic version is not as efficient as taking an `object`
    type, simply because you would still be using a `WriteLine` overload that takes
    an object as a parameter. When passing a generic, you cannot tell whether it needs
    to call an overload with an `int`, `float`, or `String`, or whether there is an
    exact overload in the first place. If there was no overload that takes an object
    for `WriteLine`, you would not be able to call the `Print` method. For that reason,
    the most performant code is actually the one with three overloads. It is not terribly
    important though because that is just one, very specific scenario where boxing
    happens anyway. There are so many other cases, however, where you can make it
    not only concise but performant as well.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, the answer to choosing a generic or polymorphic function hides in
    tiny details. If you had to implement a method for comparing two elements and
    return `true` if the first one is bigger, you could do that in C# using an `IComparable` interface:'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  id: totrans-603
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'A generic version of this would look like this:'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  id: totrans-605
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: 'The new bit here is `where T : IComparable`. It is a generic constraint. By
    default, you can pass any type to a generic class or method. Constraints still
    allow different types to be passed, but they significantly reduce the possible
    options. A generic constraint allows only the types that conform to the constraint
    to be passed as a generic type. In this case, you will allow only the types that
    implement the `IComparable` interface. Constraints might seem like a limitation
    on types; however, they expose the behavior of the constrained types that you
    can use inside a generic method. Having constraints enables you to use the features
    of those types, so it is very useful. In this case, you do limit yourself to what
    types can be used, but at the same time, whatever you pass to the generic method
    will be comparable.'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
- en: 'What if instead of returning whether the first element is bigger, you needed
    to return the first element itself? You could write a non-generic method as follows:'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  id: totrans-608
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'And the generic version would look as follows:'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  id: totrans-610
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'Also, it is worth comparing how you will get a meaningful output using each
    version. With a non-generic method, this is what the code would look like:'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  id: totrans-612
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'With a generic version, the code would be like this:'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  id: totrans-614
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: Note
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code used for this example at [https://packt.link/sIdOp](https://packt.link/sIdOp).
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the winner is obvious. In the non-generic version, you have to
    do a cast. Casting in code is frowned upon because if you do get errors, you will
    get them during runtime and things might change and the cast will fail. Casting
    is also one extra action, whereas the generic version is far more fluent because
    it does not have a cast. Use generics when you want to work with types as-is and
    not through their abstractions. And returning an exact (non-polymorphic) type
    from a function is one of the best use cases for it.
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
- en: C# generics will be covered in detail in *Chapter 4*, *Data Structures and LINQ*.
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
- en: Enum
  id: totrans-619
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `enum` type represents a set of known values. Since it is a type, you can
    pass it instead of passing a primitive value to methods. `enum` holds all the
    possible values, hence it isn''t possible to have a value that it would not contain.
    The following snippet shows a simple example of this:'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  id: totrans-621
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: Note
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code used for this example at [https://packt.link/gP9Li](https://packt.link/gP9Li).
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
- en: You can now get a possible gender value as if it were in a `static class` by
    writing `Gender.Other`. Enums can easily be converted to an integer using casting—`(int)Gender.Male`
    will return `0`, `(int)Gender.Female` will return `1`, and so on. This is because
    `enum`, by default, starts numbering at `0`.
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
- en: Enums do not have any behavior and they are known as constant containers. You
    should use them when you want to work with constants and prevent invalid values
    from being passed by design.
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
- en: Extension Methods
  id: totrans-626
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Almost always, you will be working with a part of code that does not belong
    to you. Sometimes, this might cause inconvenience because you have no access to
    change it. Is it possible to somehow extend the existing types with the functionality
    you want? Is it possible to do so without inheriting or creating new component
    classes?
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
- en: You can achieve this easily through extension methods. They allow you to add
    methods on complete types and call them as if those methods were natively there.
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
- en: 'What if you wanted to print a `string` to a console using a `Print` method,
    but call it from a `string` itself? `String` has no such method, but you can add
    it using an extension method:'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  id: totrans-630
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 'And this allows you to write the following code:'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  id: totrans-632
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: 'This will print `Hey` to the console as follows:'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  id: totrans-634
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: Note
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code used for this example at [https://packt.link/JC5cj](https://packt.link/JC5cj).
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
- en: Extension methods are `static` and must be placed within a `static class`. If
    you look at the semantics of the method, you will notice the use of the `this`
    keyword. The `this` keyword should be the first argument in an extension method.
    After that, the function continues as normal and you can use the argument with
    the `this` keyword as if it was just another argument.
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
- en: Use extension methods to add (extend, but not the same extensions as what happens
    with inheritance) new behavior to existing types, even if the type would not support
    having methods otherwise. With extension methods, you can even add methods to
    `enum` types, which is not possible otherwise.
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
- en: Struct
  id: totrans-639
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A class is a reference type, but not all objects are reference types (saved
    on the heap). Some objects can be created on the stack, and such objects are made
    using structs.
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
- en: 'A struct is defined like a class, but it is used for slightly different things.
    Now, create a `struct` named `Point`:'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  id: totrans-642
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: 'The only real difference here is the `struct` keyword, which indicates that
    this object will be saved on the stack. Also, you might have noticed that there
    is no use of properties. There are many people who would, instead of `Point`,
    type `x` and `y`. It is not a big deal, but instead of one variable, you would
    be working with two. This way of working with primitives is called primitive obsession.
    You should follow the principles of OOP and work with abstractions, well-encapsulated
    data, as well as behavior to keep things close so that they have high cohesion.
    When choosing where to place variables, ask yourself this question: can `x` change
    independently of `y`? Do you ever modify a point? Is a point a complete value
    on its own? The answer to all of this is **yes** and therefore putting it in a
    data structure makes sense. But why choose a struct over a class?'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
- en: Structs are fast because they do not have any allocations on the heap. They
    are also fast because they are passed by value (therefore, access is direct, not
    through a reference). Passing them by value copies the values, so even if you
    could modify a struct, changes would not remain outside of a method. When something
    is just a simple, small composite value, you should use a struct. Finally, with
    structs, you get value equality.
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
- en: Another effective example of a `struct` is `DateTime`. `DateTime` is just a
    unit of time, containing some information. It also does not change individually
    and supports methods such as `AddDays`, `TryParse`, and `Now`. Even though it
    has several different pieces of data, they can be treated as one unit, as they
    are date- and time-related.
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
- en: 'Most `structs` should be immutable because they are passed by a copy of a value,
    so changing something inside a method will not keep those changes. You can add
    a `readonly` keyword to a `struct`, making all its fields `readonly`:'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  id: totrans-647
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: 'A `readonly` `struct` can have either a `readonly` field or getter properties.
    This is useful for the future maintainers of your code base as it prevents them
    from doing things that you did not design for (no mutability). Structs are just
    tiny grouped bits of data, but they can have behavior as well. It makes sense
    to have a method to calculate the distance between two points:'
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  id: totrans-649
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: The preceding code has a little bit of math in it—that is, distance between
    two points is the square root of points x's and y's squared differences added
    together.
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
- en: 'It also makes sense to calculate the distance between this and other points.
    You do not need to change anything because you can just reuse the existing code,
    passing correct arguments:'
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  id: totrans-652
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: 'If you wanted to measure the distance between two points, you could create
    them like this:'
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  id: totrans-654
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: 'And use a member function to calculate distance:'
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  id: totrans-656
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: 'Or a static function:'
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  id: totrans-658
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: 'The result for each version will be as follows:'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  id: totrans-660
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: Note
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code used for this example at [https://packt.link/PtQzz](https://packt.link/PtQzz).
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
- en: When you think about a struct, think about it as just a group of primitives.
    The key point to remember is that all the data members (properties or fields)
    in a struct must be assigned during object initialization. It needs to be done
    for the same reason local variables cannot be used without having a value set
    initially. Structs do not support inheritance; however, they do support implementing
    an interface.
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
- en: Structs are actually a great way to have simple business logic. Structs should
    be kept simple and should not contain other object references within them; they
    should be primitive-only. However, a class can hold as many struct objects as
    it needs. Using structs is a great way of escaping the obsessive use of primitives
    and using simple logic naturally, within a tiny group of data where it belongs—that
    is, a `struct`.
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
- en: Record
  id: totrans-665
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A record is a reference type (unlike a `struct`, more like a class). However,
    out of the box, it has methods for comparison by value (both using the `equals`
    method and the operator). Also, a record has a different default implementation
    of `ToString()`, which no longer prints a type, but instead all the properties.
    This is exactly what is needed in many cases, so it helps a lot. Finally, there
    is a lot of syntactic sugar around records, which you are about to witness.
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
- en: 'You already know how to create custom types in C#. The only difference between
    different custom types is the keyword used. For record types, such a keyword is
    `record`. For example, you will now create a movie record. It has a `Title`, `Director`,
    `Producer`, `Description`, and a `ReleaseDate`:'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  id: totrans-668
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: So far, you should find this very familiar, because the only difference is the
    keyword. Regardless of such a minor detail, you already reap major benefits.
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
- en: The intention of having `MovieRecordV1` class in chapter, as against `MovieClass`
    in GitHub code, was to have a type, similar to a class and then refactor highlighting
    how record helps.
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
- en: 'Create two identical movies:'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  id: totrans-673
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: 'So far, everything is the same. Try to print a movie to the console:'
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  id: totrans-675
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: 'The output would be as follows:'
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  id: totrans-677
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: Note
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code used for this example at [https://packt.link/xylkW](https://packt.link/xylkW).
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
- en: If you tried doing the same to a class or a `struct` object, you would only
    get a type printed. However, for a record, a default behavior is to print all
    of its properties and their values.
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
- en: 'That is not the only benefit of a record. Again, a record has value-equality
    semantics. Comparing two movie records will compare them by their property values:'
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  id: totrans-682
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: This will print `true true`.
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
- en: 'With the same amount of code, you have managed to get the most functionality
    by simply changing a data structure to a record. Out of the box, a record provides
    `Equals()`, `GetHashCode() overrides`, `== and != overrides`, and even a `ToString`
    override, which prints the record itself (all the members and their values). The
    benefits of records do not end there because, using them, you have a way to reduce
    a lot of boilerplate code. Take full advantage of records and rewrite your movie
    record:'
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  id: totrans-685
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: 'This is a positional record, meaning all that you pass as parameters will end
    up in the right read-only data members as if it was a dedicated constructor. If
    you ran the demo again, you would notice that it no longer compiles. The major
    difference with this declaration is that, now, changing a description is no longer
    possible. Making a mutable property is not difficult, you just need to be explicit
    about it:'
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  id: totrans-687
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: 'You started this paragraph with a discussion on immutability, but why is the
    primary focus on records? The benefits of records are actually immutability-focused.
    Using a `with` expression, you can create a copy of a record object with zero
    or more properties modified. So, suppose you add this to your demo:'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  id: totrans-689
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: 'The code would result in this:'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  id: totrans-691
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: As you see, this code copies an object with just one property changed. Before
    records, you would need a lot of code to ensure all the members are copied, and
    only then would you set a value. Keep in mind that this creates a shallow copy.
    A shallow copy is an object with all the references copied. A deep copy is an
    object with all the reference-type objects recreated. Unfortunately, there is
    no way of overriding such behavior. Records cannot inherit classes, but they can
    inherit other records. They can also implement interfaces.
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
- en: Other than being a reference type, records are more like structs in that they
    have value equality and syntactic sugar around immutability. They should not be
    used as a replacement for structs because structs are still preferable for small
    and simple objects, which have simple logic. Use records when you want immutable
    objects for data, which could hold other complex objects (if nested objects could
    have a state that changes, shallow copying might cause unexpected behavior).
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
- en: Init-Only Setters
  id: totrans-694
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With the introduction of records, the previous edition, C# 9, also introduced
    `init`-only setter properties. Writing `init` instead of `set` can enable object
    initialization for properties:'
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  id: totrans-696
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: 'This enables you to create a house with unknown properties:'
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  id: totrans-698
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: 'Or assign them:'
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  id: totrans-700
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: Using `init`-only setters is especially useful when you want read-only data,
    which can be known or not, but not in a consistent matter.
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code used for this example at [https://packt.link/89J99](https://packt.link/89J99).
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
- en: ValueTuple and Deconstruction
  id: totrans-704
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You already know that a function can only return one thing. In some cases,
    you can use the `out` keyword to return a second thing. For example, converting
    a string to a number is often done like this:'
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  id: totrans-706
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: '`TryParse` returns both the parsed number and whether the text was a number.'
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
- en: 'However, C# has a better way of returning multiple values. You can achieve
    this using a data structure called `ValueTuple`. It is a generic `struct` that
    contains from one to six public mutable fields of any (specified) type. It is
    just a container for holding unrelated values. For example, if you had a `dog`,
    a `human`, and a `Bool`, you could store all three in a `ValueTuple` struct:'
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  id: totrans-709
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: 'You can then access each—that is, `dog` through `values1.Item1`, `human` through
    `values1.Item2`, and i`sDogKnown` through `values.Item3`. Another way of creating
    a `ValueTuple` struct is to use brackets. This does exactly the same thing as
    before, but using the brackets syntax:'
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  id: totrans-711
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: 'The following syntax proves extremely useful because, with it, you can declare
    a function that virtually returns multiple things:'
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE182]'
  id: totrans-713
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: Note
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code used for this example at [https://packt.link/OTFpm](https://packt.link/OTFpm).
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also do the opposite, using another C# feature called deconstruction.
    It takes object data members and allows you to split them apart, into separate
    variables. The problem with a tuple type is that it does not have a strong name.
    As mentioned before, every field will be called `ItemX`, where `X` is the order
    in which the item was returned. Working with all that, `GetDogHumanAndBool` would
    require the results to be assigned to three different variables:'
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  id: totrans-717
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: 'You can simplify this and instead make use of deconstruction—assigning object
    properties to different variables right away:'
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  id: totrans-719
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: Using deconstruction, you are able to make this a lot more readable and concise.
    Use `ValueTuple` when you have multiple unrelated variables and you want to return
    them all from a function. You do not have to always work around using the `out`
    keyword, nor do you have to add overhead by creating a new class. You can solve
    this problem by simply returning and then deconstructing a `ValueTuple` struct.
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
- en: You can now have hands-on experience of using SOLID principles for writing codes
    incrementally through the following exercise.
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 2.04: Creating a Composable Temperature Unit Converter'
  id: totrans-722
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Temperature can be measured in different units: Celsius, Kelvin, and Fahrenheit.
    In the future, more units might be added. However, units do not have to be added
    dynamically by the user; the application either supports it or not. You need to
    make an application that converts temperature from any unit to another unit.'
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that converting to and from that unit will be a completely
    different thing. Therefore, you will need two methods for every converter. As
    a standard unit, you will use Celsius. Therefore, every converter should have
    a conversion method from and to Celsius, which makes it the simplest unit of a
    program. When you need to convert non-Celsius to Celsius, you will need to involve
    two converters—one to adapt the input to the standard unit (C), and then another
    one to convert from C to whatever unit you want. The exercise will aid you in
    developing an application using the SOLID principles and C# features you have
    learned in this chapter, such as `record` and `enum`.
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps to do so:'
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `TemperatureUnit` that uses an `enum` type to define constants—that
    is, a set of known values. You do not need to add it dynamically:'
  id: totrans-726
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE185]'
  id: totrans-727
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: In this example, you will use three temperature units that are `C`, `K`, and
    `F`.
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
- en: 'Temperature should be thought of as a simple object made of two properties:
    `Unit` and `Degrees`. You could either use a `record` or a `struct` because it
    is a very simple object with data. The best choice would be picking a `struct`
    here (due to the size of the object), but for the sake of practicing, you will
    use a `record`:'
  id: totrans-729
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE186]'
  id: totrans-730
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: 'Next, add a contract defining what you want from an individual specific temperature
    converter:'
  id: totrans-731
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE187]'
  id: totrans-732
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: You defined an interface with three methods—the `Unit` property to identify
    which temperature the converter is for, and `ToC` and `FromC` to convert from
    and to standard units.
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you have a converter, add the composable converter, which has an array
    of converters:'
  id: totrans-734
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE188]'
  id: totrans-735
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: 'It makes no sense to have duplicate temperature unit converters. So, add an
    error that will be thrown when a duplicate converter is detected. Also, not having
    any converters makes no sense. Therefore, there should be some code for validating
    against `null` or empty converters:'
  id: totrans-736
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE189]'
  id: totrans-737
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: When creating custom exceptions, you should provide as much information as possible
    about the context of an error. In this case, pass the `unit` for which the converter
    was not found.
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a method that requires non-empty converters:'
  id: totrans-739
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE190]'
  id: totrans-740
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: Passing an array of empty converters throws an `InvalidTemperatureConverterException`
    exception.
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a method that requires non-duplicate converters:'
  id: totrans-742
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE191]'
  id: totrans-743
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: This method goes through every converter and checks that, at other indexes,
    the same converter is not repeated (by duplicating `TemperatureUnit`). If it finds
    a duplicate unit, it will throw an exception. If it does not, it will just terminate successfully.
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
- en: 'Now combine it all in a constructor:'
  id: totrans-745
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE192]'
  id: totrans-746
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: When creating the converter, validate against converters that are not empty
    and not duplicates and only then set them.
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, create a `private` helper method to help you find the requisite converter,
    `FindConverter`, inside the composable converter:'
  id: totrans-748
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE193]'
  id: totrans-749
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: This method returns the converter of the requisite unit and, if no converter
    is found, throws an exception.
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
- en: 'To simplify how you search and convert from any unit to Celsius, add a `ToCelsius`
    method for that:'
  id: totrans-751
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE194]'
  id: totrans-752
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: Here, you find the requisite converter and convert the `Temperature` to Celsius.
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
- en: 'Do the same for converting from Celsius to any other unit:'
  id: totrans-754
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE195]'
  id: totrans-755
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: 'Wrap it all up by implementing this algorithm, standardize the temperature
    (convert to Celsius), and then convert to any other temperature:'
  id: totrans-756
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE196]'
  id: totrans-757
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: 'Add a few converters. Start with the Kelvin converter, `KelvinConverter`:'
  id: totrans-758
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE197]'
  id: totrans-759
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: The implementation of this and all the other converters is straightforward.
    All you had to do was implement the formula to convert to the correct unit from
    or to Celsius. Kelvin has a useful constant, absolute zero, so instead of having
    a magic number, `–273.15`, you used a named constant. Also, it is worth remembering
    that a temperature is not a primitive. It is both a degree value and a unit. So,
    when converting, you need to pass both. `ToC` will always take `TemperatureUnit.C`
    as a unit and `FromC` will take whatever unit the converter is identified as,
    in this case, `TemperatureUnit.K`.
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add a Fahrenheit converter, `FahrenheitConverter`:'
  id: totrans-761
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE198]'
  id: totrans-762
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: Fahrenheit is identical structure-wise; the only differences are the formulas
    and unit value.
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a `CelsiusConverter`, which will accept a value for the temperature and
    return the same value, as follows:'
  id: totrans-764
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE199]'
  id: totrans-765
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: '`CelsiusConverter` is the simplest one. It does not do anything; it just returns
    the same temperature. The converters convert to standard temperature—Celsius to
    Celsius is always Celsius. Why do you need such a class at all? Without it, you
    would need to change the flow a bit, adding `if` statements to ignore the temperature
    if it was in Celsius. But with this implementation, you can incorporate it in
    the same flow and use it in the same way with the help of the same abstraction,
    `ITemperatureConverter`.'
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, create a demo:'
  id: totrans-767
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE200]'
  id: totrans-768
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: '[PRE201]'
  id: totrans-769
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: In this example, you have created all the converters and passed them to the
    converters container called `composableConverter`. Then you have created a temperature
    in Celsius and used it to perform conversions from and to all the other temperatures.
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code and you will get the following results:'
  id: totrans-771
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE202]'
  id: totrans-772
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: Note
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code used for this exercise at [https://packt.link/dDRU6](https://packt.link/dDRU6).
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
- en: A software developer, ideally, should design code in such a way that making
    a change now or in the future will take the same amount of time. Using SOLID principles,
    you can write code incrementally and minimize the risk of breaking changes, because
    you never change existing code; you just add new code. As systems grow, complexity
    increases, and it might be difficult to learn how things work. Through well-defined
    contracts, SOLID enables you to have easy-to-read, and maintainable code because
    each piece is straightforward by itself, and they are isolated from one another.
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
- en: You will now test your knowledge of creating classes and overriding operators
    through an activity.
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 2.01: Merging Two Circles'
  id: totrans-777
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this activity, you will create classes and override operators to solve the
    following mathematics problem: A portion of pizza dough can be used to create
    two circular pizza bites each with a radius of three centimeters. What would be
    the radius of a single pizza bite made from the same amount of dough? You can
    assume that all the pizza bites are the same thickness. The following steps will
    help you complete this activity:'
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
- en: Create a `Circle` struct with a radius. It should be a `struct` because it is
    a simple data object, which has a tiny bit of logic, calculating area.
  id: totrans-779
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a property to get the area of a circle (try to use an expression-bodied
    member). Remember, the formula of a circle's area is `pi*r*r`. To use the `PI`
    constant, you will need to import the `Math` package.
  id: totrans-780
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add two circles' areas together. The most natural way would be to use an overload
    for a plus (`+`) operator. Implement a `+` operator overload that takes two circles
    and returns a new one. The area of the new circle is the sum of the areas of the
    two old circles. However, do not create a new circle by passing the area. You
    need a Radius. You can calculate this by dividing the new area by `PI` and then
    taking the square root of the result.
  id: totrans-781
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now create a `Solution` class that takes two circles and returns a result—the
    radius of the new circle.
  id: totrans-782
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Within the `main` method, create two circles with a radius of `3` cm and define
    a new circle, which is equal to the areas of the two other circles added together.
    Print the results.
  id: totrans-783
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the `main` method and the result should be as follows:'
  id: totrans-784
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE203]'
  id: totrans-785
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: As you can see from this final output, the new circle will have a radius of
    `4.24` (rounded to the second decimal place).
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
- en: The solution to this activity can be found at [https://packt.link/qclbF](https://packt.link/qclbF).
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
- en: This activity was designed to test your knowledge of creating classes and overriding
    operators. Operators are not normally employed to solve this sort of problem,
    but in this case, it worked well.
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-790
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about OOP and how it helps take complex problems
    and abstract them into simple concepts. C# has several useful features and, roughly
    every one or two years, a new language version is released. The features mentioned
    in this chapter are just some of the ways in which C# aids in productivity. You
    have seen how, by design, it allows for better, clearer code, less prone to error.
    C# is one of the best languages when it comes to productivity. With C#, you can
    make effective code, and quickly, because a lot of the boilerplate code is done
    for you.
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you learned the SOLID principles and used them in an application. SOLID
    is not something you can just read and learn immediately; it takes practice, discussions
    with your peers, and a lot of trial and error before you get it right and start
    applying it consistently. However, the benefits are worth it. In modern software
    development, producing fast, optimal code is no longer a number one priority.
    Nowadays, the focus is a balance of productivity (how fast you develop) and performance
    (how fast your program is). C# is one of the most efficient languages out there,
    both in terms of performance and productivity.
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn what functional programming is and how to
    work with lambdas and functional constructs such as delegates.
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
