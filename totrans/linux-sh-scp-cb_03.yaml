- en: Chapter 3. File In, File Out
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Generating files of any size
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Intersection and set difference (A-B) on text files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding and deleting duplicate files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making directories for a long path
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: File permissions, ownership and sticky bit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making files immutable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating blank files in bulk
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding symbolic links and its target
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enumerating file type statistics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loopback files and mounting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating ISO files, Hybrid ISO
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding difference between files, patching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: head and tail - printing the last or first 10 lines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Listing only directories - alternative methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fast command line directory navigation using pushd and popd
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Counting the number of lines, words, and characters in a file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Printing directory tree
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: UNIX treats every object in the operating system as a file. We can find the
    files associated with every action performed and can make use of them for different
    system- or process-related manipulations. For example, the command terminal that
    we use is associated with a device file. We can write to the terminal by writing
    to the corresponding device file for that specific terminal. Files take different
    forms such as directories, regular files, block devices, character special devices,
    symbolic links, sockets, named pipes, and so on. Filename, size, file type, modification
    time, access time, change time, inode, links associated, and the filesystem the
    file is on are all attributes and properties that files can have. This chapter
    deals with recipes that handle any of the operations or properties related to
    files.
  prefs: []
  type: TYPE_NORMAL
- en: Generating files of any size
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For various reasons, you may need to generate a file filled with random data.
    It may be for creating a test file to perform tests, such as an application efficiency
    test that uses a large file as input, or to test the splitting of files into many,
    or to create loopback filesystems (loopback files are files that can contain a
    filesystem itself and these files can be mounted similar to a physical device
    using the `mount` command). It is hard to create such files by writing specific
    programs. So we use general utilities.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The easiest way to create a large sized file with a given size is to use the
    `dd` command. The `dd` command clones the given input and writes an exact copy
    to the output. Input can be `stdin`, a device file, a regular file, or so on.
    Output can be `stdout`, a device file, a regular file, and so on. An example of
    the `dd` command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The above command will create a file called `junk.data` that is exactly 1MB
    in size. Let''s go through the parameters: `if` stands for `– input` file, `of`
    stands for `– output` file, `bs` stands for BYTES for a block, and `count` stands
    for the number of blocks of `bs` specified to be copied.'
  prefs: []
  type: TYPE_NORMAL
- en: Here we are only creating a file 1MB in size by specifying `bs` as 1MB with
    a count of 1\. If `bs` was set to `2M` and a count to 2, the total file size would
    be 4MB.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use various units for **Block** **Size** (**BS**) as follows. Append
    any of the following characters to the number to specify the size in bytes:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Unit size | Code |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Byte (1B) | `c` |'
  prefs: []
  type: TYPE_TB
- en: '| Word (2B) | `w` |'
  prefs: []
  type: TYPE_TB
- en: '| Block (512B) | `b` |'
  prefs: []
  type: TYPE_TB
- en: '| Kilo Byte (1024B) | `k` |'
  prefs: []
  type: TYPE_TB
- en: '| Mega Byte (1024 KB) | `M` |'
  prefs: []
  type: TYPE_TB
- en: '| Giga Byte (1024 MB) | `G` |'
  prefs: []
  type: TYPE_TB
- en: We can generate a file of any size using this. Instead of MB we can use any
    other unit notations such as the ones mentioned in the previous table.
  prefs: []
  type: TYPE_NORMAL
- en: '`/dev/zero` is a character special device, which infinitely returns the zero
    byte (`\0`).'
  prefs: []
  type: TYPE_NORMAL
- en: If the input parameter (`if`) is not specified, it will read the input from
    `stdin` by default. Similarly, if the output parameter (`of`) is not specified,
    it will use `stdout` as the default output sink.
  prefs: []
  type: TYPE_NORMAL
- en: The `dd` command can also be used to measure the speed of memory operations
    by transferring a large quantity of data and checking the command output (for
    example, `1048576 bytes (1.0 MB) copied, 0.00767266 s, 137 MB/s` as seen the previous
    example).
  prefs: []
  type: TYPE_NORMAL
- en: Intersection and set difference (A-B) on text files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Intersection and set difference operations are commonly used in mathematical
    classes on set theory. However, similar operations on text are also very helpful
    in some scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `comm` command is a utility to perform comparison between the two files.
    It has many nice options to arrange the output in such a way that we can perform
    intersection, difference, and set difference operations.
  prefs: []
  type: TYPE_NORMAL
- en: '**Intersection**: The intersection operation will print the lines that the
    specified files have in common with one another.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Difference**: The difference operation will print the lines that the specified
    files contain and that are not the same in all of those files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Set difference**: The set difference operation will print the lines in file
    "A" that do not match those in all of the set of files specified ("B" plus "C"
    for example).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Note that `comm` takes sorted files as input. Take a look at the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The first column of the output contains lines that are in `A.txt` excluding
    common lines in two files. The second column contains lines that are in `B.txt`
    excluding common lines. The third column contains the common lines from `A.txt`
    and `B.txt`. Each of the columns are delimited by using the tab (`\t`) character.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some options are available to format the output as per our requirement. For
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-1` removes first column from output'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-2` removes the second column'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-3` removes the third column'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In order to print the intersection of two files, we need to remove the first
    and second columns and print the third column only as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Print lines that are uncommon in two files as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the `-3` argument in the `comm` command removes the third column from
    the output. But, it writes column-1 and column-2 to the output. The column-1 contains
    the lines in `A.txt` excluding the lines in `B.txt`. Similarly, column-2 has the
    lines from `B.txt` excluding the lines in `A.txt`. As the output is a two-column
    output, it is not that useful. Columns have their fields blank for each of the
    unique lines. Hence both columns will not have the content on the same line. Either
    one of the two columns will have the content. In order to make it in a usable
    output text format, we need to remove the blank fields and make two columns into
    a single column output as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to produce such an output, we need to remove the `\t` character at
    the beginning of the lines. We can remove the `\t` character from the start of
    each line and unify the columns into one as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `sed` command is piped to the `comm` output. The `sed` removes the `\t`
    character at the beginning of the lines. The `s` in the `sed` script stands for
    substitute. `/^\t/` matches the `\t` at the beginning of the lines (`^` is the
    start of the line marker). `//` (no character) is the replacement string for every
    `\t` at the beginning of the line. Hence every `\t` at the start of the line gets
    removed.
  prefs: []
  type: TYPE_NORMAL
- en: A set difference operation on two files can be performed as explained in the
    following paragraphs.
  prefs: []
  type: TYPE_NORMAL
- en: The set difference operation enables you to compare two files and print all
    the lines that are in the file `A.txt` or `B.txt` excluding the common lines in
    `A.txt` and `B.txt`. When `A.txt` and `B.txt` are given as arguments to the `comm`
    command, the output will contain column-1 with the set difference for `A.txt`
    with respect to `B.txt` and column-2 will contain the set difference for `B.txt`
    with respect to `A.txt`.
  prefs: []
  type: TYPE_NORMAL
- en: 'By removing the unnecessary columns, we can produce the set difference for
    `A.txt` and `B.txt` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Set difference for A.txt**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '`-2 -3` removes the second and third columns.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Set difference for B.txt**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '`-2 -3` removes the second and third columns.'
  prefs: []
  type: TYPE_NORMAL
- en: Finding and deleting duplicate files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Duplicate files are copies of the same files. In some circumstances, we may
    need to remove duplicate files and keep a single copy of them. Identification
    of duplicate files by looking at the file content is an interesting task. It can
    be done using a combination of shell utilities. This recipe deals with finding
    out duplicate files and performing operations based on the result.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Duplicate files are files with different names but same data. We can identify
    the duplicate files by comparing the file content. Checksums are calculated by
    looking at the file contents. Since files with exactly the same content will produce
    duplicate checksum values, we can use this to remove duplicate lines.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Generate some test files as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The code for the script to remove the duplicate files is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Run it as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The commands above will find the copies of same file in a directory and remove
    all except one copy of the file. Let's go through the code and see how it works.
    `ls -lS` will list the details of the files sorted by file size in the current
    directory. `awk` will read the output of `ls -lS` and perform comparisons on columns
    and rows of the input text to find out the duplicate files.
  prefs: []
  type: TYPE_NORMAL
- en: 'The logic behind the previous code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We list the files sorted by file size so that the similarly sized files will
    be grouped together. The files having the same file size are identified as a first
    step to finding files that are the same. Next, we calculate the checksum of the
    files. If the checksums match, then the files are duplicates and one set of the
    duplicates are removed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `BEGIN{}` block of `awk` is executed first before lines are read from the
    file. Reading of lines takes place in the `{}` block and after the end of reading
    and processing all lines, the`END{}` block statements are executed. The output
    of `ls -lS` is:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The output of the first line tells us the total number of files, which in this
    case is not useful. We use `getline` to read the first line and then dump it.
    We need to compare each of the lines and the next line for sizes. For that we
    read the first line explicitly using `getline` and store name and size (which
    are the eighth and fifth columns). Hence a line is read ahead using `getline`.
    Now, when `awk` enters the `{}` block (in which the rest of the lines are read)
    that block is executed for every read offline. It compares size obtained from
    the current line and the previously stored size kept in the `size` variable. If
    they are equal, it means two files are duplicates by size. Hence they are to be
    further checked by `md5sum`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have played some tricky ways to reach the solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'The external command output can be read inside `awk` as:'
  prefs: []
  type: TYPE_NORMAL
- en: '`"cmd"| getline`'
  prefs: []
  type: TYPE_NORMAL
- en: Then we receive the output in line `$0` and each column output can be received
    in `$1,$2,..$n`, and so on. Here we read the md5sum of files in the `csum1` and
    `csum2` variables. Variables `name1` and `name2` are used to store consecutive
    file names. If the checksums of two files are the same, they are confirmed to
    be duplicates and are printed.
  prefs: []
  type: TYPE_NORMAL
- en: We need to find a file each from the group of duplicates so that we can remove
    all other duplicates except one. We calculate the `md5sum` of the duplicates and
    print one file from each group of duplicates by finding unique lines by comparing
    `md5sum` only from each line using `-w 32` (the first 32 characters in the `md5sum`
    output; usually, `md5sum` output consists of a 32 character hash followed by the
    filename). Therefore, one sample from each group of duplicates is written in `duplicate_sample`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we need to remove all the files listed in `duplicate_files`, excluding
    the files listed in `duplicate_sample`. The `comm` command prints files in `duplicate_files`
    but not in `duplicate_sample`.
  prefs: []
  type: TYPE_NORMAL
- en: For that, we use a set difference operation (refer to the intersection, difference,
    and set difference recipes).
  prefs: []
  type: TYPE_NORMAL
- en: '`comm` always accepts files that are sorted. Therefore, `sort -u` is used as
    a filter before redirecting to `duplicate_files` and `duplicate_sample`.'
  prefs: []
  type: TYPE_NORMAL
- en: Here the `tee` command is used to perform a trick so that it can pass filenames
    to the `rm` command as well as `print`. `tee` writes lines that appear as `stdin`
    to a file and sends them to `stdout`. We can also print text to the terminal by
    redirecting to `stderr`. `/dev/stderr` is the device corresponding to `stderr`
    (standard error). By redirecting to a `stderr` device file, text that appears
    through `stdin` will be printed in the terminal as standard error.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Basic awk primer* of [Chapter 4](ch04.html "Chapter 4. Texting and Driving")
    explains the awk command.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Checksum and verification* of [Chapter 2](ch02.html "Chapter 2. Have a Good
    Command") explains the md5sum command.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making directories for a long path
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are circumstances when we are required to make a tree of empty directories.
    If some intermediate directories exist in the given path, it will also have to
    incorporate checks to see whether the directory exists or not. It will make the
    code larger and inefficient. Let's see the use case and the recipe to solve the
    issue.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`mkdir` is the command for creating directories. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If the directory already exists, it will return a "File exists" error message,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: You are given a directory path (`/home/slynux/test/hello/child`). The directory
    `/home/slynux` already exist. We need to create rest of the directories `(/home/slynux/test`,
    `/home/slynux/test/hello`, and `/home/slynux/test/hello`) in the path.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is used to figure out whether each directory in a path exists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: -e is a parameter used in the condition construct `[ ]`, to determine whether
    a file exists. In UNIX-like systems, directory is also a type of file. `[ -e FILE_PATH
    ]` returns true if the file exists.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following sequence of code needs to be executed to create directories in
    a tree in several levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'If an error, such as "Directory exists", is encountered, it is ignored and
    the error message is dumped to the `/dev/null` device using the `2>` redirection.
    But this is lengthy and non-standard. The standard one-liner to perform this action
    is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This single command takes the place of the five different commands listed above.
    It ignores if any level of directory exists and creates the missing directories.
  prefs: []
  type: TYPE_NORMAL
- en: File permissions, ownership, and sticky bit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: File permissions and ownership are one of the distinguishing features of UNIX/Linux
    file systems such as extended (ext FS). In many circumstances while working on
    UNIX/Linux platforms, we come across issues related to permissions and ownership.
    This recipe is a walk through different use cases of permissions and ownership.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Linux systems, each file is associated with many types of permissions. Out
    of these permissions, three set of permissions (user, group, and others) are commonly
    manipulated.
  prefs: []
  type: TYPE_NORMAL
- en: The **user** is the owner of the file. The group is the collection of users
    (as defined by the system) that are permitted some access to the file. Others
    are any entity other than the user or group owner of the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Permissions of a file can be listed by using the `ls -l` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The first column of output specifies the following. The first letter corresponds
    to:'
  prefs: []
  type: TYPE_NORMAL
- en: '"-"—if it is a regular file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '"d"—if it is a directory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '"c"—for a character device'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '"b"—for a block device'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '"l"—if it is a symbolic link'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '"s"—for a socket'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '"p"—for a pipe'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The rest of the portions can be divided into three groups of three letters each
    (`------`). The first `---` three characters correspond the permissions of the
    user (owner), the second set of three characters correspond to the permissions
    of the group, and the third set of three characters correspond to the permissions
    of others. Each character in the nine character sequence (nine permissions) specifies
    whether a permission is set or unset. If the permission is set, a character appears
    in the corresponding position, else a '-' character appears in that position,
    which means that the corresponding permission is unset (unavailable).
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at what each of these three character set means for the user,
    group, and others.
  prefs: []
  type: TYPE_NORMAL
- en: '**User:**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Permission string: `rwx------`'
  prefs: []
  type: TYPE_NORMAL
- en: The first letter in the three letters specifies whether the user has read permission
    for the file. If the read permission is set for the user, the character `r` will
    appear as the first character. Similarly, the second character specifies write
    (modify) permission (`w`) and the third character specifies whether the user has
    execute (`x`) permission (the permission to run the file). The execute permission
    is usually set for executable files. User has one more special permission called
    setuid (`S`), which appears in the position of execute (`x`). The setuid permission
    enables an executable file to be executed effectively as its owner, even when
    the executable is run by another user.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example for a file with setuid permission set is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The read, write, and execute permissions are also applied to the directories.
    However, the interpretation of read, write, and execute permissions are slightly
    different in the context of directories as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Read permission (`r`) for the directories enables to read the list of files
    and sub-directories in the directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write permission (`w`) for a directory enables to create or remove files and
    directories from a directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Execute permission (`x`) specifies whether the access to the files and directories
    in a directory is possible or not
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Group**:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Permission string: `---rwx---`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The second set of three characters specifies the group permissions. The interpretation
    of permissions `rwx` is the same as the permissions for user. Instead of setuid,
    the group has a setgid (`S`) bit. It enables to run an executable file with an
    effective group as the owner group. But the group, which initiates the command,
    may be different. An example of group permission is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '**Others:**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Permission string: `------rwx`'
  prefs: []
  type: TYPE_NORMAL
- en: Other permissions appear as the last three character set in the permission string.
    Others have the same read, write, and execute permissions as the user and group.
    But it does not have permission `S` (like setuid and setgid).
  prefs: []
  type: TYPE_NORMAL
- en: Directories have a special permission called sticky bit. When a sticky bit is
    set for a directory, the user who created the directory can only delete the files
    in the directory even if group and others have write permissions. The sticky bit
    appears in the position of execute character (`x`) in the others permission set.
    It is represented as character `t` or `T`. `t` appears in the position of `x`
    if the execute permission is unset and the sticky bit is set. If the sticky bit
    and the execute permission is set, character `T` appears in the position of `x`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`------`rwt , `------`rwT'
  prefs: []
  type: TYPE_NORMAL
- en: A typical example of a directory with sticky bit turned on by default is `/tmp`.
    The sticky bit is a type of write-protection.
  prefs: []
  type: TYPE_NORMAL
- en: In each of the `ls -l` output line, the string `slynux slynux` corresponds to
    the owned user and owned group. Here the first 'slynux' is the user and the second
    'slynux' is the group owner.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to set permissions for files, we use the `chmod` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assume that we need to set permission: `rwx rw- r--`'
  prefs: []
  type: TYPE_NORMAL
- en: 'This could be set using chmod as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`u =` specifies user permissions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`g =` specifies group permissions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`o =` specifies others permissions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In order to add additional permissions on the current file, use + to add permission
    to user, group or others and use – to remove the permissions. Add the executable
    permission to a file, which is already having the permission `rwx rw- r--` as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This command adds the `x` permission for others.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the executable permission to all permission categories that is, for user,
    group, and others as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Here `a` means all.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to remove any permission, use -. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Permissions can also be set using octal numbers. Permissions are denoted by
    three-digit octal numbers in which each of the digit corresponds to user, group,
    and other in the order.
  prefs: []
  type: TYPE_NORMAL
- en: 'Read, write, and execute permissions have unique octal numbers as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`r--` = 4'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-w-` = 2'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--x` = 1'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can get the required combination of permissions by adding the octal values
    for the required permission sets. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`rw-` = 4 + 2 = 6'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`r-x` = 4 + 1 = 5'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The permission `rwx rw- r--` in numeric method is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`rwx` = 4 + 2 + 1 = 7'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rw-` = 4 + 2 = 6'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`r--` = 4'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Therefore, `rwx rw- r--` is equal to 764, and the command for setting the permissions
    using octal values is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's go through some additional tasks that can be performed for files and directories.
  prefs: []
  type: TYPE_NORMAL
- en: Changing ownership
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In order to change ownership of files, use the `chown` command as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Here, `slynux` is the user as well as the group.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the sticky bit
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The sticky bit is an interesting type of permission applied to directories.
    By setting the sticky bit, it restricts only the user owning it to delete the
    files even though group and others have sufficient permissions.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to set the sticky bit, `+t` is applied on a directory with `chmod`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Applying permissions recursively to files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Sometimes it may be required to recursively change the permissions of all the
    files and directories inside the current directory. This can be done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The `-R` option specifies to apply change permission recursively.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have used "." to specify the path as the current working directory. It is
    equivalent to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Applying ownership recursively
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can apply the ownership recursively by using the `-R` flag with the `chown`
    command as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Running an executable as a different user (setuid)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some executables need to be executed as a different user (other than the current
    user that initiates the execution of the file), effectively, whenever they are
    executed, by using the file path, such as `./executable_name`. A special permission
    attribute for files called `setuid` permission enables to effectively execute
    as the file owner when any other user runs the program.
  prefs: []
  type: TYPE_NORMAL
- en: 'First change the ownership to the user to which it needs to be executed every
    time and login as the owner user. Then, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Now it executes effectively as the root user every time.
  prefs: []
  type: TYPE_NORMAL
- en: '`setuid` is restricted such that `setuid` won''t work for scripts, but only
    for Linux ELF binaries. This is a fix for ensuring security.'
  prefs: []
  type: TYPE_NORMAL
- en: Making files immutable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Files on extended type file systems, which are common in Linux (for example,
    ext2, ext3, ext4, and so on) can be made immutable. Certain type of file attributes
    help to set the immutable attribute to the file. When a file is made immutable,
    any user or super user cannot remove the file until the immutable attribute is
    removed from the file. We can easily find out the file system type of any mounted
    partition by looking at the `/etc/mtab` file. The first column of the file specifies
    the partition device path (for example, `/dev/sda5`) and the third column specifies
    the file system type (for example, ext3). Let's see how to make files immutable.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`chattr` can be used for to make files immutable. However, it is not the only
    extended attribute that can be changed by chattr.'
  prefs: []
  type: TYPE_NORMAL
- en: Making a file immutable is one of the methods for securing files from modification.
    The best known example is in the case of the `/etc/shadow` file. The shadow file
    consists of encrypted passwords of every user in the current system. By injecting
    encrypted passwords, we can login into the system. Users can, usually, change
    their password by using the `passwd` command. When you execute the `passwd` command,
    it actually modifies the `/etc/shadow` file. We can make the shadow file immutable
    so that no user is able to change the password. Let's see how to do it.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A file can be made immutable as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Or:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The file is therefore made immutable. Now try the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to make it writable, remove the immutable attribute as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Generating blank files in bulk
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes we many need to generate test cases. We may use programs that operate
    on 1000s of files. But how are test files generated?
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`touch` is a command that can create blank files or modify the timestamp of
    files if they already exist. Let''s take a look at how to use them.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A blank file with the name `filename` will be created using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Generate bulk files with a different name pattern as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: In the above code `{1..100}` will be expanded as a string "1, 2, 3, 4, 5, 6,
    7...100". Instead of `{1..100}.txt`, we can use various shorthand patterns such
    as `test{1..200}.c`, `test{a..z}.txt`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'If a file already exists, then the `touch` command changes all timestamps associated
    with the file to the current time. However, if we want to specify that only certain
    stamps are to be modified, we use the following options:'
  prefs: []
  type: TYPE_NORMAL
- en: '`touch -a` modifies only the access time'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`touch -m` modifies only the modification time'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Instead of using the current time for the timestamp, we can specify the time
    and date with which to stamp the file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The date string that is used with `–d` need not always be in the same format.
    It will accept any standard date formats. We can omit time from the string and
    provide handy date formats like "Jan 20 2010".
  prefs: []
  type: TYPE_NORMAL
- en: Finding a symbolic link and its target
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Symbolic links are common with UNIX-like systems. We may come across various
    manipulations based on symbolic links. This recipe may not be having any practical
    purpose, but it gives practice of handling symbolic links that may be helpful
    in writing shell scripts for other purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Symbolic links are just pointers to other files. They are similar in function
    to aliases in Mac OS X or shortcuts in Windows. When symbolic links are removed,
    they will not cause any harm to the original file.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can create a symbolic link as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates a symbolic link (called "web") in the logged in user''s home directory.
    The link points to `/var/www/`. This is seen in the output of the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '`web -> /var/www` specifies that `web` points to `/var/www`.'
  prefs: []
  type: TYPE_NORMAL
- en: For every symbolic link, the permission notation block (`lrwxrwxrwx`) starts
    with letter "l", which represents a symlink.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in order to print symbolic links in the current directory, use the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '`grep` will filter the lines from the `ls -l` output such that it displays
    only lines starting with l. `^` is the start marker for the string. `awk` is used
    to print the eighth column. Hence it prints the eighth column, which is the filename.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way to print symbolic links is to use `find` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: In the above command, in the `find` argument `type` we have specified "l", which
    will instruct the `find` command to search only for symbolic link files. The `–print`
    option is used to print the list of symbolic links to the standard output (`stdout`).
    The path from which the file search should begin is given as '.', which means
    it is the current directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to print the target of a symbolic link use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The `ls –l` command lists many details with each of the line corresponding to
    the details of a file. `ls –l web` lists the details for the file called `web`,
    which is a symbolic link. The tenth column in the output of `ls –l` contains the
    link to which the file points to (if the file is a symbolic link). Hence in order
    to find the target associated with a symbolic link, we can use `awk` to print
    the tenth column from the file details listing (the output from `ls –l`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Or, alternately, we can use the standard way of reading the target path for
    a given symbolic link using the command `readlink`. It is the most preferred method
    and can be used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Enumerating file type statistics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many file types. It will be an interesting exercise to write a script
    that can enumerate through all the files inside a directory, its descendants,
    and print a report that provides details on types of files (files with different
    file types) and the count of each file type present. This recipe is an exercise
    on how to write scripts that can enumerate through a bulk of files and collecting
    details.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The file command can be used to find out the type of the file by looking at
    the contents of the file. In UNIX/Linux systems, file types are not determined
    based on the extension of the file (like the Microsoft Windows platform does).
    This recipe aims at collecting file type statistics of a number of files. For
    storing the count of files of the same type, we can use an associative array and
    the `file` command can be used to fetch the file type details from each of the
    files.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to print the file type of a file use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Print the file type only by excluding the filename as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The script for files statistics is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The usage is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'A sample output is shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here an associative array named `statarray` is declared so that it can take
    file type as file indices and store the count of each file type in the array.
    `let` is used to increment the count each time when a file type is encountered.
    The `find` command is used to get the list of file paths recursively. A `while`
    loop is used to iterate line by line through the `find` command''s output. The
    input line `ftype=`file -b "$line"`` in the previous script is used to find out
    the file type using the `file` command. The `–b` option specifies file command
    to print only file type (without filename in the output). The file type output
    consists of more details, such as image encoding used and resolution (in the case
    of an image file). But we are not interested in more details, we need only the
    basic information. Details are comma separated as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: We need to extract only the "ELF 32-bit LSB executable" from the above details.
    Hence we use `cut –d, -f1`, which specifies to use "`,`" as the delimiter and
    print only the first field.
  prefs: []
  type: TYPE_NORMAL
- en: '`done< <(find $path –type f –print);` is an important bit of code. The logic
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`while` read line;'
  prefs: []
  type: TYPE_NORMAL
- en: '`do` something'
  prefs: []
  type: TYPE_NORMAL
- en: '`done<` filename'
  prefs: []
  type: TYPE_NORMAL
- en: Instead of the filename we used the output of `find`.
  prefs: []
  type: TYPE_NORMAL
- en: '`<(find $path -type f -print)` is equivalent to a filename. But it substitutes
    filename with subprocess output. Note that there is an additional `<`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`${!statarray[@]}` is used to return the list of array indexes.'
  prefs: []
  type: TYPE_NORMAL
- en: Loopback files and mounting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Loopback filesystems are very interesting components of Linux like systems.
    We usually create filesystems on devices (for example, disk drive partitions).
    These storage devices are available as device files like `/dev/device_name`. In
    order to use the storage device filesystem, we need to mount it at some directory
    called a mount point. Loopback filesystems are those that we create in files rather
    than a physical device. We can mount those files as devices at a mount point.
    Let's see how to do it.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Loopback filesystems reside on a file. We mount these files by attaching it
    to a device file. An example of a loopback filesystem is the initial ramdisk file,
    which you would see at `boot/initrd.img`. It stores an initial filesystem for
    the kernel in a file.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see how to create an ext4 filesystem on a file of size 1GB.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following command will create a file that is 1 GB in size.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: You can see that the size of the created file exceeds 1GB. This is because the
    hard disk is a block device and hence storage is allocated by integral multiples
    of blocks size.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now format the 1GB file using the `mkfs` command as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'This command formats it to ext4\. Check the file type using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can mount the loopback file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The `-o loop` additional option is used to mount any loopback file systems.
  prefs: []
  type: TYPE_NORMAL
- en: This is the shortcut method. We do not attach it to any devices. But internally
    it attaches to a device called `/dev/loop1` or `loop2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can do it manually as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The first method cannot be used in all circumstances. Suppose we want to create
    a hard disk file, and then want to partition it and mount a sub partition, we
    cannot use `mount -o loop`. We have to use the second method. Partition a zeros
    dumped file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Create partitions in `loopback.img` in order to mount the first partition as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Now `/dev/loop2` represents first partition.
  prefs: []
  type: TYPE_NORMAL
- en: '`-o` is the offset flag. `32256` bytes are for a DOS partition scheme. The
    first partition starts after an offset of 32256 bytes from the start of the hard
    disk.'
  prefs: []
  type: TYPE_NORMAL
- en: We can set up the second partition by specifying the required offset. After
    mounting we can perform all regular operations as we can on physical devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to `umount`, use the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, alternately, we can use device file path as an argument to the `umount`
    command as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Note that `umount` command should be executed as a root user since it is a privileged
    command.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's explore more about additional mount options.
  prefs: []
  type: TYPE_NORMAL
- en: Mounting ISO files as loopback
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An ISO file is an archive of any optical media. We can mount ISO files in the
    same way that we mount physical discs by using loopback mounting.
  prefs: []
  type: TYPE_NORMAL
- en: 'A mount point is just a directory, which is used as access path to contents
    of a device through a filesystem. We can even use a non-empty directory as the
    mount path. Then the mount path will contain data from the devices rather than
    original contents until the device is unmounted. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Now perform operations using files from `/mnt/iso`. ISO is a read-only filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: Flush changes immediately with sync
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'While making changes on a mounted device, they are not immediately written
    to the physical devices. They are only written when the buffer is full. But we
    can force writing of changes immediately by using the `sync` command as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`# sync`'
  prefs: []
  type: TYPE_NORMAL
- en: You should execute the `sync` command as root.
  prefs: []
  type: TYPE_NORMAL
- en: Creating ISO files, Hybrid ISO
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An ISO image is an archive format that stores the exact storage images of optical
    disks like CD ROMs, DVD ROMs, and so on. It is a common use case that we burn
    ISO images to optical disks. But what if you want to create an image of an optical
    disk? For that we need to create an ISO image from an optical disk. Many people
    rely on third-party utilities to create an ISO image from an optical disk. However,
    using the command line, it's just a single line job.
  prefs: []
  type: TYPE_NORMAL
- en: Also, many people don't distinguish between bootable and non-bootable optical
    disks. Bootable disks are capable of booting from themselves and also running
    an operating system or another product. Non-bootable ISOs cannot do that. The
    practice that people usually follow is to copy files from a bootable CD-ROM and
    paste it to another location for keeping the copy. After that, they use the copied
    directory to burn a CD ROM. But then, it will lose its bootable nature. To preserve
    the bootable nature, it should be copied as a disk image or an ISO file.
  prefs: []
  type: TYPE_NORMAL
- en: Nowadays, most people use devices such as flash drives or hard disks as a replacement
    for optical disks. When we write a bootable ISO to a flash drive it will no longer
    be bootable unless we use a special hybrid ISO image designed specifically for
    the purpose.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will give you an insight on ISO images and manipulations.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we described many times in this book, UNIX handles everything as files. Every
    device is a file. Hence what if we want to copy an exact image of a device? We
    need to read all data from it and write to another file, right?
  prefs: []
  type: TYPE_NORMAL
- en: As we know, the `cat` command can be used to read any data and redirection can
    be used to write to a file.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to create an ISO image from `/dev/cdrom` use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: This will work, it will read all the bytes from the device and write an ISO
    image.
  prefs: []
  type: TYPE_NORMAL
- en: Using the `cat` command for creating an ISO image is a tricky way to do it.
    But the most preferred way to create an ISO image is to use the `dd` utility.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '`mkisofs` is a command used to create ISO system. The output file of `mkisofs`
    can be written to CD ROM or DVD ROM using utilities like `cdrecord`. We can use
    `mkisofs` to create an ISO file using a directory containing all the required
    files that should appear as contents of an ISO file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: The `–o` option in the `mkisofs` command specifies the ISO file path. The `source_dir`
    is the path of the directory that should be used as source content for the ISO
    and the `–V` option specifies the label that should be used for the ISO file.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's learn more commands and techniques related to ISO files.
  prefs: []
  type: TYPE_NORMAL
- en: Hybrid ISO that boots off flash drive or hard disk
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Usually, bootable ISO files cannot be transferred or written to a USB storage
    device and boot the OS from the USB key. But special type of ISO files called
    hybrid ISOs can be flashed and they are capable of booting from such devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can convert standard ISO files into hybrid ISOs with the `isohybrid` command.
    The `isohybrid` command is a new utility and most Linux distros don''t include
    this by default. You can download the syslinux package from: [http://syslinux.zytor.com](http://syslinux.zytor.com).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Have a look at the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Using this command, we will have a hybrid ISO with the file name `image.iso`
    and it can be written to USB storage devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the ISO to a USB storage by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Use the appropriate device instead of `sdb1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Or, you can use `cat` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Burning an ISO from command line
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `cdrecord` command is used to burn an ISO file into a CD ROM or DVD ROM.
    It can be used to burn the image to the CD ROM as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Some extra options are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can specify the burning speed with the `–speed` option as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: The speed is 8x, which is specified as 8.
  prefs: []
  type: TYPE_NORMAL
- en: 'A CD ROM can be burned in multisessions such that we can burn data multiple
    times on a disk. Multisession burning can be performed using the `–multi` option
    as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Playing with CD Rom tray
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Try the following commands and have fun:'
  prefs: []
  type: TYPE_NORMAL
- en: '**$ eject**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This command is used to eject the tray.
  prefs: []
  type: TYPE_NORMAL
- en: '**$ eject -t**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This command is used to close the tray.
  prefs: []
  type: TYPE_NORMAL
- en: Try to write a loop that opens the tray and closes the tray for "N" number of
    times.
  prefs: []
  type: TYPE_NORMAL
- en: Finding difference between files, patching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When multiple versions of a file are available, it is very useful when we can
    find the differences between files being highlighted rather than comparing two
    files manually by looking through them. If the files are of 1000s of lines, they
    are practically very difficult and time consuming to compare. This recipe illustrates
    how to generate differences between files highlighted with line numbers. When
    working on large files by multiple developers, when one of them has made changes
    and these changes need to be shown to the other, sending the entire source code
    to other developers is costly in consumption of space and time to manually check
    the changes. Sending a different file is helpful. It consists of only lines that
    are changed, added, or removed and line numbers are attached with it. This difference
    file is called a patch file. We can add the changes specified in the patch file
    to the original source code by using the patch command. We can also revert the
    changes by patching again. Let's see how to do this.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `diff` command utility is used to generate difference files.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to generate difference information, create the following files:'
  prefs: []
  type: TYPE_NORMAL
- en: 'File 1: `version1.txt`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'File 2: `version2.txt`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Non-unified `diff` output (without the `–u` flag) will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'The unified `diff` output will be as follows::'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: The `-u` option is used to produce unified output. Everyone prefers unified
    output, as the unified output is more readable and because it is easier to interpret
    the difference that is being made between two files.
  prefs: []
  type: TYPE_NORMAL
- en: In unified `diff`, the lines starting with `+` are the newly added lines and
    the lines starting with `–` are the removed lines.
  prefs: []
  type: TYPE_NORMAL
- en: 'A patch file can be generated by redirecting the `diff` output to a file, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Now using the patch command we can apply changes to any of the two files. When
    applied to `version1.txt`, we get `version2.txt` file. When applied to `version2.txt`,
    we receive `version1.txt`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Apply the patch by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: We now have `version1.txt` with the same contents as that of `version2.txt`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to revert the changes back, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Revert the changes without prompting the user with `y/n` by using the `–R` option
    along with the patch command.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's go through additional features available with `diff`.
  prefs: []
  type: TYPE_NORMAL
- en: Generating diff against directories
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `diff` command can also act recursively against directories. It will generate
    a difference output for all the descendant files in the directories.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'The interpretation of each of the above options is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-N` is for treating absent files as empty'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-a` is to consider all files as text files'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-u` is to produce unified output'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-r` is to recursively traverse through the files in the directories'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: head and tail – printing the last or first 10 lines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When looking into a large file, which consists of thousands of lines, we will
    not use a command like `cat` to print the entire file contents. Instead we look
    for a sample (for example, the first 10 lines of the file or the last 10 lines
    of the file). We may also need to print the first n lines or last n lines. Also
    we may need to print all the lines except the last "n" lines or all lines except
    first "n" lines.
  prefs: []
  type: TYPE_NORMAL
- en: Another use case is to print lines from n-th to m-th lines.
  prefs: []
  type: TYPE_NORMAL
- en: The commands `head` and `tail` can help us do this.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `head` command always reads the header portion of the input file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Print first 10 lines as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Read the data from stdin as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Specify the number of first lines to be printed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: This command prints four lines.
  prefs: []
  type: TYPE_NORMAL
- en: 'Print all lines excluding the last `N` lines as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Note that it is negative N.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to print all the lines except the last 5 lines use the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'The following command will, however, print from 1 to 5:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Printing by excluding the last lines is a very important usage of `head`. But
    people always look at some other complex methods to do the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'Print the last 10 lines of a file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to read from `stdin`, you can use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Print the last 5 lines as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to print all lines excluding first N lines, use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, to print all lines except the first 5 lines, N + 1 = 6, therefore
    the command will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: This will print from 6 to 100.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the important usages of `tail` is to read a constantly growing file.
    Since new lines are constantly appended to the end of the file, `tail` can be
    used to display all new lines as they are written to the file. When we run `tail`
    simply, it will read the last 10 lines and exit. However, by that time, new lines
    would have been appended to the file by some process. In order to constantly monitor
    the growth of file, `tail` has a special option `-f` or `--follow`, which enables
    `tail` to follow the appended lines and keep being updated with the data growth:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'An example of such growing files are logfiles. The command to monitor the growth
    of the files would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: or
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: We frequently run `dmesg` to look at kernel ring buffer messages either to debug
    the USB devices or to look at the `sdX` (`X` is the minor number for the `sd`
    device). The `tail -f` can also add a sleep interval `-s`, so that we can set
    the interval during which the file updates are monitored.
  prefs: []
  type: TYPE_NORMAL
- en: '`tail` has the interesting property that allows it to terminate after a given
    process ID dies.'
  prefs: []
  type: TYPE_NORMAL
- en: Suppose we are reading a growing file, and a process `Foo` is appending data
    to the file, `tail -f` should be executed until process `Foo` dies.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: When the process `Foo` terminates, `tail` also terminates.
  prefs: []
  type: TYPE_NORMAL
- en: Let's work on an example.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file `file.txt` and open the file in gedit (You can use any text
    editor).
  prefs: []
  type: TYPE_NORMAL
- en: Add new lines to the file and make frequent file saves in gedit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: When you make frequent changes to the file, it will be written to the terminal
    by the tail command. When you close the `gedit`, the `tail` command will get terminated.
  prefs: []
  type: TYPE_NORMAL
- en: Listing only directories – alternative methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Though listing only directories seems to be a simple task, many would not be
    able to do it. I have seen this often, even when asked to people who are good
    at shell scripting. This recipe is worth knowing since it introduces multiple
    ways of listing only directories with various tricky techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are multiple ways of listing directories only. When you ask people about
    these techniques, the first answer that they would probably give is `dir`. But,
    it is wrong. The `dir` command is just another command like `ls` with fewer options
    than `ls`. Let's see how to list directories.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are four ways in which directories in the current path can be displayed.
    They are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**$ ls -d */**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Only the above combination with `-d` will print directories.
  prefs: []
  type: TYPE_NORMAL
- en: '**$ ls -F | grep "/$"**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the `-F` parameter is used, all entries are appended with some type of
    file character such as `@`, `*`, `|`, and so on. For directories, entries are
    appended with the `/` character. We use `grep` to filter only entries ending with
    the `/$` end of line indicator.
  prefs: []
  type: TYPE_NORMAL
- en: '**$ ls -l | grep "^d"**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first character of `ls -d` output lines of each file entries is the type
    of file character. For directory, the type of file character is `"d"`. Hence we
    use `grep` to filter lines starting with `"d"`. `^` is the start of line indicator.
  prefs: []
  type: TYPE_NORMAL
- en: '**$ find . -type d -maxdepth 1 -print**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `find` command can take the parameter `type` as directory and `maxdepth`
    is set to `1` since it should not search the directories of descendants.
  prefs: []
  type: TYPE_NORMAL
- en: Fast command-line navigation using pushd and popd
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When dealing with multiple locations on a terminal or shell prompt, our common
    practice is to copy and paste the paths. Copy-paste is only effective when mouse
    is used. When there is only command-line access without a GUI, it is hard to deal
    with navigation through multiple paths. For example, if we are dealing with locations
    `/var/www`, `/home/slynux`, and `/usr/src`, when we need to navigate these locations
    one by one, it is really difficult to type the path every time when we need to
    switch between the paths. Hence the command-line interface (CLI) based navigation
    techniques such as pushd and popd are used. Let's see how to practice them.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`pushd` and `popd` are used to switch between multiple directories without
    the copy-paste of directory paths. `pushd` and `popd` operate on a stack. We know
    that stack is a **Last** **In** **First** **Out** (**LIFO**) data structure. It
    will store the directory paths in a stack and switch between them using push and
    pop operations.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We omit the use of the `cd` command while using `pushd` and `popd`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to push and change directory to a path use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: Now the stack contains `/var/www ~` and the current directory is changed to
    `/var/www`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now again push the next directory path as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: Now the stack contains `/usr/src /var/www ~` and the current directory is `/usr/src`.
  prefs: []
  type: TYPE_NORMAL
- en: You can similarly push as many directory paths as needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'View the stack contents by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'When you want to switch to any path in the list, number each path from `0`
    to `n,` then use the path number for which we need to switch, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: It will rotate the stack and switch to the directory `/usr/share`.
  prefs: []
  type: TYPE_NORMAL
- en: '`pushd` will always add paths to the stack, to remove paths from the stack
    use `popd`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove a last pushed path and change directory to the next directory by using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: Suppose the stack is `/usr/src /var/www ~ /usr/share /etc` such that the current
    directory is `/usr/src`, `popd` will change the stack to `/var/www ~ /usr/share
    /etc` and change the directory to `/var/www`.
  prefs: []
  type: TYPE_NORMAL
- en: In order to remove a specific path from the list, use `popd +no`.
  prefs: []
  type: TYPE_NORMAL
- en: The `no` is counted as `0` to `n` from left to right.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's go through essential directory navigation practices.
  prefs: []
  type: TYPE_NORMAL
- en: Most frequently used directory switching
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`pushd` and `popd` can be used when there are more than three directory paths
    are used. But when you use only two locations, there is an alternative and easier
    way. That is `cd -`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If the current path is `/var/www`, perform the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'Now to switch back to `/var/www`, you don''t have to type it out again, but
    just execute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can switch to `/usr/src` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: Counting number of lines, words, and characters in a file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Counting the number of lines, words, and characters from a text or file are
    very useful for text manipulations. In several cases, count of words or characters
    are used in indirect ways to perform some hacks to produce required output patterns
    and results. This book includes some of such tricky examples in other chapters.
    **Counting** **LOC** (**Lines of Code**) is an important application for developers.
    We may need to count special types of files excluding unnecessary files. A combination
    of `wc` with other commands help to perform that.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`wc` is the utility used for counting. It stands for **Word Count (wc)**. Let''s
    see how to use `wc` to count lines, words, and characters.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Count number of lines as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to use `stdin` as input, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'Count the number of words as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to count number of characters, use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, we can count the characters in a text as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: '`-n` is used to avoid an extra newline character.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When `wc` is executed without any options as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: it will print number of lines, words, and characters delimited by tabs.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's go through additional options available with `wc` command.
  prefs: []
  type: TYPE_NORMAL
- en: Print length of longest length line
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`wc` can be also used to print the length of longest line using the `–L` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: Printing directory tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Graphically representing directories and filesystem as tree hierarchy is quite
    useful when preparing tutorials and documents. Also they are sometimes useful
    in writing certain monitoring scripts that helps to look at the filesystem using
    easy-to-read tree representations. Let's see how to do it.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `tree` command is the hero that helps to print graphical trees of files
    and directories. Usually, `tree` does not come with Linux distributions. You need
    to install it using the package manager.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following is a sample UNIX file system tree to show an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: '`The tree` command comes with many interesting options, let us look at few
    of them.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Highlight only files matched by pattern as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'Highlight only files excluding the match pattern by using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to print size along with files and directories use the `-h` option
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's see an interesting option that is available with the `tree` command.
  prefs: []
  type: TYPE_NORMAL
- en: HTML output for tree
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is possible to generate HTML output from the `tree` command. For example,
    use the following command to create an HTML file with tree output.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: Replace `http://localhost` with the URL where you would like to host the file.
    Replace PATH with a real path for the base directory. For the current directory
    use '.' as the PATH.
  prefs: []
  type: TYPE_NORMAL
- en: 'The web page generated from the directory listing will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![HTML output for tree](img/3760_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
