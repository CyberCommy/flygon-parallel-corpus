- en: Multithreading and Concurrent Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned how we can optimize Spring messaging. We
    also learned various configuration tips and tricks that help us to improve the
    performance of our application. We also looked at the monitoring and configuration
    of JMS and RabbitMQ for optimal performance.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will cover the core concept of Java threads and then will
    move to advanced thread support provided by the `java.util.concurrent` package.
    For this package, we will see various classes and interfaces that help us write
    multithreaded and concurrent programming. We will also learn how we can use Java
    `ThreadPool` to improve performance. We will walk through useful functionalities
    provided by the Spring Framework, such as task executing, scheduling, and running
    as asynchronous. Finally, we will look into Spring transaction management with
    threads and various best programming practices for threads.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Java classical threads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `java.util.concurrent` package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the thread pools for asynchronous processing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring task execution and scheduling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Async
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring and threads—transactions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java threads best programming practices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java classical threads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Java applications execute via threads, which are an independent path of execution
    within a program. Any Java program has at least one thread, known as the main
    thread, which is created by **Java Virtual Machine** (**JVM**). Java is a multithreaded
    application that allows multiple thread execution at any particular time and these
    threads can run concurrently, either asynchronously or synchronously. When multiple
    threads are executing, each thread's path can differ from the other thread's paths.
  prefs: []
  type: TYPE_NORMAL
- en: The JVM provides each thread with its own stack to prevent threads from interfering
    with each other. Separate stacks help threads keep track of their next instructions
    to execute, which can differ from thread to thread. The stack also gives a thread
    its own copy of method parameters, local variables, and the return value.
  prefs: []
  type: TYPE_NORMAL
- en: Threads live within a process and share their resources, such as memory and
    open files, with the other threads of the process. The ability to share resources
    between different threads makes them more susceptible to errors where performance
    is a significant requirement. Every thread in Java is created and controlled by
    the `java.lang.Thread` class and the `java.lang.Runnable` interface.
  prefs: []
  type: TYPE_NORMAL
- en: Creating threads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Threads are objects in the Java language. They can be created using the following
    mechanisms:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a class that implements the `Runnable` interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a class that extends the `Thread` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are two ways to create a `Runnable` object. The first way is to create
    a class that implements the `Runnable` interface as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Before Java 8, we only had this way to create a `Runnable` object. But since
    Java 8, we can create a `Runnable` object using a Lambda expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'After creating the `Runnable` object, we need to pass it to a `Thread` constructor
    that receives a `Runnable` object as an argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Some constructors don''t take the `Runnable` object as an argument, such as `Thread()`.
    In that case, we need to take another approach in order to create a thread:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Thread life cycle and states
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Understanding the thread life cycle and states is very important when working
    with threads and multithreaded environments. In the previous examples, we saw
    how we can create the Java thread object using the `Thread` class and the `Runnable`
    interface. But to start the thread, we have to first create the thread object
    and call its `start()` method to execute the `run()` method as a thread.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are different states of the thread life cycle in Java:'
  prefs: []
  type: TYPE_NORMAL
- en: '**New**: The thread is in the new state when it is created with a `new` operator.
    At this stage, the thread is not alive.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Runnable**: The thread is in the runnable state when we call the `start()`
    method of the thread object. At this stage, the thread scheduler still does not
    pick it for running.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Running**: The thread state is changed from runnable to running when the
    thread scheduler has selected it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Blocked/waiting**: The thread state is blocked/waiting when it is currently
    not eligible to run.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Terminated/dead**: The thread state is terminated/dead when it executes its
    run method. At this stage, it''s considered to be not alive.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More advanced thread tasks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have seen the thread life cycle and its states, but threads also support
    some advanced tasks, such as sleeping, joining, and interrupting. Let''s discuss
    them:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Sleeping**: The `sleep()` thread method can be used to pause the execution
    of the current thread for the specified amount of time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Joining**: The `join()` thread method can be used to pause the execution
    of the current thread until the thread it joins completes its task.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Interrupting**: The `interrupt()` thread method can be used to break out
    the sleeping or waiting state of the thread. It throws `InterruptedException`
    if the thread is in the sleeping or waiting state, otherwise, it doesn''t interrupt
    the thread but sets the interrupted flag to true.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Synchronizing threads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In multithreaded applications, there might be situations where multiple threads
    try to access a shared resource and produce erroneous and unexpected results.
    We need to ensure that the resource will be used by only one thread at a time,
    and that can be achieved by synchronization. The `synchronized` keyword is used
    to achieve synchronization; when we define any synchronized block in Java, only
    one thread can access that block and other threads are blocked until the thread
    inside the block exits that block.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `synchronized` keyword can be used with the following different types of
    blocks:'
  prefs: []
  type: TYPE_NORMAL
- en: Instance methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Static methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code blocks inside instance methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code blocks inside static methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In Java, a synchronized block degrades performance. We must use the `synchronized`
    keyword when required, otherwise, we should use the synchronized block of the
    critical section only where it is required.
  prefs: []
  type: TYPE_NORMAL
- en: Issues with multithreading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Multithreading is a very powerful mechanism that helps us to better utilize
    the system's resources, but we need to take special care while reading and writing
    data shared by multiple threads. There are two basic problems with multithreading
    programming—visibility and access problems. A visibility problem occurs when the
    effects of one thread can be seen by another. An access problem can occur when
    the same shared resources are accessed by multiple threads at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: Due to visibility and access problems, a program does not react any more and
    it leads to deadlocks or generates incorrect data.
  prefs: []
  type: TYPE_NORMAL
- en: The java.util.concurrent package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we focused on Java's low-level support for threads.
    In this section, we will move on to look at Java's high-level thread support provided
    by the `java.util.concurrent` package. This package has various classes and interfaces
    that provide very useful functionalities to help us implement multithreaded and
    concurrent programming. In this section, we will mainly focus on some of the most
    useful utilities of this package.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the high-level overview of the `java.util.concurrent`
    API:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bc28c2a8-acac-4718-a085-9dab2fe53a72.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's discuss the interfaces in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Executors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Executor` provides an abstraction layer over all the internal thread management
    tasks and manages the entire concurrent execution flow of the threads. An `Executor`
    is an object that executes tasks provided.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Java concurrency API provides the following three basic interfaces for
    executors:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Executor`: This is a simple interface that is used to launch a new task. It
    does not strictly require the execution to be asynchronous.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ExecutorService`: This is a subinterface of the `Executor` interface. It allows
    us to pass a task to be executed by a thread asynchronously. It provides methods
    to manage the termination of previously sublimed tasks through `shutdown()`, `shutdownNow()`,
    and `awaitTermination(long timeout, TimeUnit unit)`. It also provides methods
    that return the `Future` object for tracking the progress of one or more asynchronous
    tasks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ScheduledExecutorService`: This is a subinterface of `ExecutorService`. It
    provides various key methods, such as `schedule()`, `scheduleAtFixedRate()` and
    `scheduleWithFixedDelay()`. All schedule methods can accept relative delays and
    periods as arguments, and this helps us to schedule tasks to execute after a given
    delay or period.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is a simple example showing how to create `Executor` in order
    to execute a `Runnable` task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous example, a `Runnable` object is created by an anonymous class
    and executes a task by means of a single-threaded `Executor` interface. When we
    compile and run the preceding class, we will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: ThreadFactory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `ThreadFactory` interface is used to create a new thread on demand and also
    helps us to eliminate lots of boilerplate code for creating threads.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows how we can use the `ThreadFactory` interface to
    create new threads:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'When we compile and run the preceding class, we will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Synchronizers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Java provides a `synchronized` keyword to write synchronized code, but it is
    difficult to correctly write synchronized code through the `synchronized` keyword
    alone. The `java.util.concurrent` package provides various utility classes, such
    as `CountDownLatch`, `CyclicBarrier`, `Exchanger`, `Semaphore`, and `Phaser`,
    which are known as synchronizers. Synchronizers are concurrency utilities that
    provide thread synchronization without using the `wait()` and `notify()` methods.
    Let''s have a look at the following classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CountDownLatch`: This allows one thread to wait for one or more threads to
    complete before it can start processing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CyclicBarrier`: This is very similar to `CountdownLatch`, but it allows multiple
    threads to wait for each other before they can start processing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Semaphore`: This maintains a set of permits for restricting the number of
    threads that can access a shared resource. Threads require a permit from `Semaphore`
    before accessing a shared resource. It provides two main methods, `acquire()`
    and `release()`, for getting and releasing permits, respectively.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Exchanger`: This provides a synchronization point where threads can exchange
    objects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Phaser`: This provides a thread synchronization mechanism similar to `CyclicBarrier`
    and `CountDownLatch`, but it supports more flexible usage. It allows a group of
    threads to wait on a barrier and then proceed after the last thread arrives, and
    it also supports multiple phases of execution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Concurrent collection classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The concurrent collection classes provide more scalability and performance
    than other collection classes, such as `HashMap` or `Hashtable`. The following
    are useful concurrent classes provided in the `java.util.concurrent` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ConcurrentHashMap`: This is similar to `HashMap` and `Hashtable`, but it has
    been designed to work in concurrent programming without the need for explicit
    synchronization. `Hashtable` and `ConcurrentHashMap` are both thread-safe collections,
    but `ConcurrentHashMap` is more advanced than `Hashtable`. It does not lock the
    entire collection for synchronization, so it is very useful when there are a lot
    of updates and fewer concurrent reads.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BlockingQueue`: The producer-consumer pattern is the most common design pattern
    in asynchronous programming, and the `BlockingQueue` data structure can be very
    useful in these asynchronous scenarios.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DelayQueue`: This is an infinite size blocking queue of elements where an
    element can only be taken when its delay has expired. If multiple elements delay
    expiry, then the element with the longest delay expiration will be taken first.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lock
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Lock` interface provides more advanced locking mechanisms than the synchronized block.
    The main difference between the synchronized block and `Lock` is that the synchronized
    block is fully contained in a method while the `Lock` interface has separate methods, `lock()` and `unlock()`, that
    can be called in a different method.
  prefs: []
  type: TYPE_NORMAL
- en: Callable and Future
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Callable` interface is similar to the `Runnable` object, but it can return
    any type of object, which helps us to get a result or status from a `Callable`
    task.
  prefs: []
  type: TYPE_NORMAL
- en: The `Callable` task returns the `Future` object, which is used for getting the
    result of an asynchronous operation. Its uses include providing a couple of methods
    to check whether the asynchronous execution is completed or not and retrieving
    the result of the computation.
  prefs: []
  type: TYPE_NORMAL
- en: Atomic variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Atomic variables are non-blocking algorithms introduced in the `java.util.concurrent.atomic`
    package. The main benefits of using atomic variables is that we don't need to
    worry about synchronization. Atomic variables are a necessity in multithreaded
    environments to avoid data inconsistency. It supports lock-free, thread-safe operations
    on single variables.
  prefs: []
  type: TYPE_NORMAL
- en: Using thread pools for asynchronous processing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Thread pool is a core concept in multithreaded programming that serves a collection
    of idle threads that can be used to execute a task. A thread pool can reuse previously
    created threads to execute the current task so that the thread is already available
    when the request arrives, which can reduce the time of thread creation and improve
    the performance of the application. Normally, thread pool can be used in a web
    server to handle client requests and also to maintain open connections to the
    database.
  prefs: []
  type: TYPE_NORMAL
- en: We can configure the maximum number of concurrent threads in the pool, which
    is useful for preventing overload. If all threads are busy executing a task, then
    a new task is placed in a queue and waits for a thread to become available.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Java concurrency API supports the following types of thread pools:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Fixed-thread pool**: A thread pool with a fixed number of threads. A task
    will only execute if a thread is available, otherwise, it is waiting in a queue.
    The `Executors.newFixedThreadPool()` method is used to create a fixed-thread pool.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cached-thread pool**: A thread pool where we can create new threads as required,
    but also reuse previously created threads. A thread will be terminated and removed
    from the pool if it is ideal for 60 seconds. The `Executors.newCachedThreadPool()`
    method is used to create a cached-thread pool.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Single-thread pool**: A thread pool with one thread. It executes tasks one
    by one. The `Executors.newSingleThreadExecutor()` method is used to create a single-thread
    pool.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fork/join pool**: A thread pool that is used to perform heavy tasks faster,
    by splitting the task into smaller pieces recursively. To create a fork/join pool,
    we need to create an instance of the `ForkJoinPool` class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is a simple example of the fixed-thread pool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The following demonstrates how the task is implemented:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In the previous example, we created a pool with a maximum of three concurrent
    threads and submitted `6` tasks to the `executor` object. When we compile and
    run the preceding class, we know that only three threads execute the tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Spring task execution and scheduling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using threads in any web application is not easy when we are dealing with a
    long-running task. Sometimes, we need to run a task asynchronously or after a
    specific delay, and that can be accomplished by Spring's task execution and scheduling.
    The Spring Framework introduced abstractions for asynchronous execution and scheduling
    of tasks with the `TaskExecutor` and `TaskScheduler` interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: TaskExecutor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spring provides the `TaskExecutor` interface as an abstraction for dealing
    with `Executor`. The implementation classes of `TaskExecutor` are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SimpleAsyncTaskExecutor`: This starts a new thread and executes it asynchronously.
    It does not reuse the thread.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SyncTaskExecutor`: This executes each task synchronously in the calling thread.
    It does not reuse the thread.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ConcurrentTaskExecutor`: This exposes bean properties for configuring `java.util.concurrent.Executor`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SimpleThreadPoolTaskExecutor`: This is a subclass of `SimpleThreadPool` of
    `Quartz`, which listens to Spring''s life cycle callbacks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ThreadPoolTaskExecutor`: This exposes bean properties for configuring `java.util.concurrent.ThreadPoolExecutor`
    and wraps it in `TaskExecutor`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TimerTaskExecutor`: This implements a single `TimerTask` class as its backing
    implementation. It executes methods as synchronous in a separate thread.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WorkManagerTaskExecutor`: This uses the `CommonJ` `WorkManager` interface
    as its backing implementation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's see a simple example of executing a task with `SimpleAsyncTaskExecutor`
    in the Spring application. It creates a new thread for each task submission and
    runs as asynchronous.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the configuration file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the bean class where we have assigned `5` tasks to `TaskExecutor`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the code for executing the task from the `main` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'When we compile and run the preceding class, we will get the following output.
    Here, we can see five threads are created and they execute the task asynchronously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: TaskScheduler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, we need to perform a task at fixed intervals, and this can be achieved
    with the Spring scheduler framework. In this section, we will see how we can schedule
    a task in Spring with the use of a few annotations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see a simple example of scheduling a task in the Spring application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In Spring, we can enable task scheduling with the help of the `@EnableScheduling`
    annotation. Once task scheduling is enabled, Spring will automatically register
    an internal bean post processor, which will find the `@Scheduled` annotated methods
    on a Spring-managed bean.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous example, we annotated the `scheduledTask()` method with the
    `@Scheduled` annotation with the `fixedDelay` attribute to be invoked every `2`
    seconds. We can also use other attributes, such as `fixedRate` and `cron`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'When we compile and run the previous class, we will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Spring Async
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will see the asynchronous execution support in Spring. In
    certain cases, we need to execute some tasks asynchronously, because the result
    of that task does not require the user, so we can process that task in a separate
    thread. The main benefit of asynchronous programming is that we can increase the
    performance and responsiveness of our application.
  prefs: []
  type: TYPE_NORMAL
- en: Spring provides annotation support for asynchronous method execution via `@EnableAsync`
    and `@Async`. Let's discuss them in detail.
  prefs: []
  type: TYPE_NORMAL
- en: The @EnableAsync annotation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can enable asynchronous processing by simply adding `@EnableAsync` to a
    configuration class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code, we have not provided `TaskExecutor` as a bean, so Spring
    will use a default `SimpleAsyncTaskExecutor` implicitly.
  prefs: []
  type: TYPE_NORMAL
- en: The @Async annotation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once asynchronous processing is enabled, then the methods that are annotated
    with the `@Async` annotation will execute asynchronously.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a simple example of the `@Async` annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also annotate the `@Async` annotation to a method with the return type,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code, we used the `AsyncResult` class, which implements `Future`.
    This can be used to get the results of the execution of the asynchronous method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the code to call the asynchronous method from the `main` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'When we compile and run the preceding class, we will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '@Async with CompletableFuture'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous section, we saw how we can use `java.util.Future` to get the
    result of asynchronous method execution. It provides an `isDone()` method to check
    whether the computation is done or not, and a `get()` method to retrieve the result
    of the computation when it is done. But there are certain limitations to using
    the `Future` API:'
  prefs: []
  type: TYPE_NORMAL
- en: Suppose we have written code to fetch the latest product price from an e-commerce
    system through a remote API. This task is time-consuming, so we need to run it
    asynchronously and use `Future` to get the result of that task. Now, the problem
    will occur when the remote API service is down. At that time, we need to complete
    `Future` manually by the last cached price of the product and that is not possible
    with `Future`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Future` only provides a `get()` method that notifies us when a result is available.
    We cannot attach a callback function to `Future` and have it get called automatically
    when the `Future` result is available.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sometimes we have requirements, such as the result of the long-running task
    is needed to send another long-running task. We can't create such asynchronous
    workflow with `Future`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We cannot run multiple `Future` in parallel.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Future` API does not have any exception handling.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Because of these limitations, Java 8 introduced a better abstraction than `java.util.Future`,
    called `CompletableFuture`. We can create `CompletableFuture` simply using the
    following no-arg constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the list of methods provided by `CompletableFuture`, which help us
    to resolve the limitations of `Future`:'
  prefs: []
  type: TYPE_NORMAL
- en: The `complete()` method is used to complete the task manually.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `runAsync()` method is used to run background tasks asynchronously that
    do not return anything. It takes a `Runnable` object and returns `CompletableFuture<Void>`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `supplyAsync()` method is used to run background tasks asynchronously and
    return a value. It takes `Supplier<T>` and returns `CompletableFuture<T>`, where
    `T` is the type of the value given by the supplier.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `thenApply()`, `thenAccept()`, and `thenRun()` methods are used to attach
    a callback to `CompletableFuture`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `thenCompose()` method is used to combine two dependent `CompletableFuture` together.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `thenCombine()` method is used to combine two independent `CompletableFuture` together.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `allOf()` and `anyOf()` methods are used to combine multiple `CompletableFuture` together.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `exceptionally()` method is used to get the generated error from `Future`.
    We can log the error and set a default value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `handle()` method is used to handle the exception.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring and threads – transactions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Spring Framework offers an extensive API for database transaction management.
    Spring takes care of all basic transaction management control and provides a consistent
    programming model for different transaction APIs, such as JDBC, Hibernate, **Java
    Transaction API** (**JTA**), **Java Persistence API** (**JPA**), and **Java Data
    Objects** (**JDO**). There are two types of transactions provided by Spring: one
    is declarative and the other is programmatic transaction management. Declarative
    is very high-level, while programmatic is more advanced but flexible.'
  prefs: []
  type: TYPE_NORMAL
- en: Spring transaction management works very well with a single thread. But it cannot
    manage a transaction across multiple threads. If we try to use the transaction
    with multiple threads, our program gives a runtime error or an unexpected result.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand why a Spring transaction fails with multiple threads, first,
    we need to understand how transactions work with Spring. Spring stores all transaction
    information in the `ThreadLocal` variables inside the `org.springframework.transaction.support.TransactionSynchronizationManager`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The thread's local variable holds the information of a specific transaction
    for a single thread only and that cannot be accessed by another thread. So, an
    ongoing transaction's information is not passed to the newly created thread. The
    result will be an error indicating that the transaction is missing.
  prefs: []
  type: TYPE_NORMAL
- en: Now we are able to understand the problem of a Spring transaction with multiple
    threads. Spring cannot maintain the transaction state to old threads from newly
    created threads. To solve the transaction problem with multiple threads, we need
    to manually pass the thread's local variable values to the newly created thread.
  prefs: []
  type: TYPE_NORMAL
- en: Java threads best programming practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The purpose of using multithreading and concurrent programming is to improve
    performance, but we need to always remember that speed comes after correctness.
    The Java programming language provides lots of synchronization and concurrency
    support from the language to API level, but it depends on an individual''s expertise
    in writing bug-free Java concurrency code. The following are Java concurrency
    and multithreading best practices, which help us write better concurrency code
    in Java:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Use immutable classes**: We should always prefer the immutable class in multithreading
    programming because immutable classes make sure that values are not changed in
    the middle of an operation without using synchronized blocks. For example, in
    an immutable class, such as `java.lang.String`, any modification on `String`,
    such as adding something or converting into uppercase, always creates another
    string object, keeping the original object unbroken.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use local variables**: Always try to use local variables instead of an instance
    or class-level variables because local variables are never shared between threads.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use thread pool**: Thread pool can reuse previously created threads and eliminate
    the time of thread creation, which improves the performance of the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use the synchronization utility**: Here, we can use the synchronization utility
    instead of the `wait` and `notify` methods. The `java.util.concurrent` package
    provides better synchronization utilities, such as `CycicBariier`, `CountDownLatch`,
    `Sempahore`, and `BlockingQueue`. It is very easy to wait for five threads using
    `CountDownLatch` to complete its task instead of implementing the same utility
    using the `wait` and `notify` methods. It is also easier to implement the producer-consumer
    design with the help of `BlockingQueue` rather than the `wait` and `notify` methods.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use concurrent collections instead of synchronized collection**: Concurrent
    collections are implemented with the new locking mechanism provided by the `Lock`
    interface and designed in such a way that we can take advantage of the native
    concurrency construct provided by the underlying hardware and JVM. Concurrent
    collections give more scalability and performance than their synchronized counterparts. `ConcurrentHashMap`
    provides better performance than synchronized `HashMap` or `Hashtable` classes
    if there are many updates and fewer reads concurrently.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Minimize locking scope**: We should always try to reduce the locking scope
    as much as possible because locking block will not be executed concurrently and
    it impacts the application''s performance. We should always first try to use atomic
    and volatile variables to achieve our synchronization requirement if our requirement
    is not satisfied with them, and then we need to use the functionality provided
    by the `Lock` interface. We can also reduce the locking scope to use a synchronized
    block instead of the synchronized method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use Java Executor framework**: It provides an abstraction layer on the Java
    threading framework and provides better control in terms of creating and executing
    threads in a multithreaded environment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored Java thread and learned how we can implement multithreading
    and concurrent programming with the help of the `java.util.concurrent` package.
    We also learned how we can improve performance using a thread pools in our application.
    We saw the task executing and scheduling functionalities provided by Spring and
    also learned about `@Async` support by Spring, which can increase the performance
    and responsiveness of our application. We reviewed how Spring transaction management
    creates an issue while working with multiple threads, and also looked at the best programming
    practices for multithreading and concurrent programming.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about profiling an application to figure
    out the performance of an application. It is very useful for identifying performance
    issues. We will also learn about logging, which is an important tool for identifying
    issues in the application.
  prefs: []
  type: TYPE_NORMAL
