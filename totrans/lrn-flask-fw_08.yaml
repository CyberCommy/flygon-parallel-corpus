- en: Chapter 8. Testing Flask Apps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we shall learn how to write unit tests covering all parts of
    the blogging app. We will utilize Flask's test client to simulate live requests,
    and we will see how the Mock library can simplify the testing of complex interactions,
    such as calling third-party services such as databases.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we shall learn the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Python's unit test module and general guidelines for test writing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test-friendly configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to simulate requests and sessions using the Flask test client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use the Mock library to test complex interactions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logging exceptions and error e-mails
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unit Testing is a process that allows us to have confidence in the code, confidence
    in bug fixes, and confidence in future features. The idea of unit testing is simple;
    you write code that complements your functional code.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, let's say we design a program that needs to calculate some math
    correctly; how do you know it's successful? Why not pull out a calculator, and
    you know what a computer is? A big calculator. Also, computers are really quite
    good at mundane repetitive tasks, so why not write a unit test that works out
    the answer for you? Repeat this pattern for all areas of your code, bundle those
    tests up into one wrapper, and you have complete confidence in the code that you
    have produced.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are some who say that tests are a sign of code "smell", that your code
    is so complex that it needs tests to prove that it works. This means that the
    code should be simpler. However, it really depends on your situation and it is
    up to you to make that judgment call. Unit tests are a good place to start before
    we start getting into making the code simpler.
  prefs: []
  type: TYPE_NORMAL
- en: What is clever about unit testing is that the tests complement the functional
    code. The methods prove that the tests work and the tests prove that the methods
    work. It reduces the likelihood of the code having major functional bugs, reducing
    the headache of having to rework the code in future, and allows you to concentrate
    on the minutiae of the new features that you want to work on.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The idea behind unit tests is to verify that small sections of code—or rather,
    simple bits of functionality—are tested. This will then build to the greater whole
    of your application. It is very easy to end up writing enormous tests that test
    the functionality of your code and not the code itself. If your test is looking
    pretty big, it's usually an indication that your main code should be broken down
    into smaller methods.
  prefs: []
  type: TYPE_NORMAL
- en: Python's unit test module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Fortunately, as is almost always the case with Python, there is a built-in
    unit test module. Much like Flask, it''s very easy to get a simple unit test module
    in place. In your main blog app, create a new directory called `tests` and, within
    that directory, create a new file called `test.py`. Now, using your favorite text
    editor, enter in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The preceding snippet demonstrates the basic framework for all the unit test
    modules that we will write. Simply making use of the built-in Python module `unittest`,
    it then creates a class that wraps a particular set of tests. The tests in this
    example, are the methods that start with the word `test`. The unit test module
    recognizes these as the methods that should be run each time `unittest.main` is
    called. Also, the `TestCase` class, which the `ExampleTest` class is inheriting
    from here, has some special methods that unit test will always attempt to use.
    One of them is `setUp`, a method that is run before each of the test methods that
    are run. This can be particularly useful when you want to run each test in isolation,
    but want, for example, to have a connection to a database in place.
  prefs: []
  type: TYPE_NORMAL
- en: The other special method is `tearDown`. This is run whenever a test method is
    run. Again, this is extremely useful for running each test in isolation when we
    want to maintain a database.
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, this code example will not do anything if run. To get it to a usable
    state, and by following the principles of **test-driven development** (**TDD**),
    we first need to write a test that verifies that the code we are going to write
    works correctly and then write the code that fulfills that test.
  prefs: []
  type: TYPE_NORMAL
- en: A simple math test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this example, we are going to write a test that verifies that a method
    will accept two numbers as arguments, subtract one from the second argument, then
    multiply them together. Take a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Argument 1 | Argument 2 | Answer |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `1` | `1` | `1 * (1-1) = 0` |'
  prefs: []
  type: TYPE_TB
- en: '| `1` | `2` | `1 * (2-1) = 1` |'
  prefs: []
  type: TYPE_TB
- en: '| `2` | `3` | `2 * (3-1) = 4` |'
  prefs: []
  type: TYPE_TB
- en: 'In your `test.py` file, you can create a method within the `ExampleTest` class
    that represents the preceding table as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code creates a new method that asserts, with Python's `unittest`
    module, the answers to the questions. The `assertEqual` function takes the returned
    response from the `my_multiplication` method on the first argument and compares
    that to the second argument. If it passes, it does nothing, waiting for the next
    assertion to be tested. But if it does not match, it will throw an error and your
    test method will stop executing to tell you there was an error.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding code example, there is also an `assertNotEqual` method. This
    works much the same as `assertEqual` but, rather, checks whether the values do
    not match each other. It is also a good idea to check when your method is likely
    to fail. If you've only checked the situations in which your method will work,
    you have only done half the work, and will likely run into problems with edge
    cases. A wide variety of assertion methods come with Python's `unittest` module,
    and that would be useful to explore.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can write the method that will give these results. For simplicity, we
    will write the method in the same file. Within the file, create the following
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Save the file and run it using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '![A simple math test](img/1709_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Oops! It failed. Why? Well, reviewing the `my_multiplication` method reveals
    that we missed some brackets. Let''s go back and correct that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'And now lets run it again:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A simple math test](img/1709_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Success! We now have a method that is correct; in future, we will know if it
    has been changed, and how it will need to be changed at a later point. Now to
    use this new skill with Flask.
  prefs: []
  type: TYPE_NORMAL
- en: Flask and unit testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You may be thinking: "Unit tests look great for small sections of code, but
    how do you test it for an entire Flask app?" Well one of the ways, as mentioned
    previously, is to make sure that all your methods are as discrete as possible—that
    is, to make sure your methods do the least possible work to complete their function,
    and to avoid repetition between methods. If your methods are not discrete, now
    is a good time to get them tidied up.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another thing that will help is that Flask comes readymade for unit testing.
    There is a good chance that any existing application can have at least some unit
    tests applied to it. Especially, any areas of API such as in unable to verify
    will be extremely easy to test by making use of the methods that represent the
    HTTP requests already within Flask. Following is a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This code should hopefully look very familiar. It simply re-writes the previous
    example to verify that the homepage is working. The `test_client` method that
    Flask exposes, allows simple access to the app via methods that represent the
    HTTP calls, as per the first line of the `test` method. The `test` method itself
    does not check the content of the page, but simply that the page loaded successfully.
    This may sound trivial, but it is useful to know that the homepage works. And
    the result? You can see it here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Flask and unit testing](img/1709_08_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One thing to be aware of is that we won't need to test Flask itself and must
    avoid testing it so that we don't create too much work for ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: Testing a page
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One thing to notice about running the previous tests are that they are very
    simplistic. No actual browser behaves that way. Browsers do things such as storing
    cookies for logging in: requesting static files such as JavaScript, images, and
    CSS files: and requesting data in particular formats. Somehow, we are going to
    need to simulate this functionality and test whether the results were correct.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is the part where unit testing starts becoming functional testing. While
    there is nothing intrinsically wrong with that, it is worth keeping in mind that
    smaller tests are better.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, Flask does all this for you simply by using the `app.get` methods
    from earlier, but there are some tricks you can use to make things easier. For
    example, adding functions to the `TestCase` class for logging in and out will
    make things much simpler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code is a framework for future test cases. Any time we have a
    test case that requires logging in and out, add this `Mixin` to the inheritance
    list and it automatically becomes available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The test case that we''ve just explained uses `FlaskLoginMixin`, a set of methods
    that aid in checking whether logging in and out is working correctly. This is
    achieved by checking that the response page sends the correct message and has
    the correct warning in the content of the page. Our test can further be extended
    to check whether a user has access to a page which they shouldn''t. Flask takes
    care of the sessions and cookies for you, so it''s as simple as the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: What the preceding code snippet shows is how to test whether certain pages are
    correctly protected. A very useful test. It also verifies that, when an admin
    logs out, they can no longer access the pages they had access to while being logged
    in. The method names are self, explanatory such that if those tests fail, it is
    obvious to tell what was being tested.
  prefs: []
  type: TYPE_NORMAL
- en: Testing an API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Testing APIs is even easier as it is a programmatic interference. Using the
    previous comment API set up in [Chapter 7](ch07.html "Chapter 7. AJAX and RESTful
    APIs"), *AJAX and RESTful APIs,* we can quite easily insert and retrieve some
    comments and verify that it worked correctly. To test this we will need to `import`
    the json library to work with our `JSON` based API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code example shows a comment dictionary object being created.
    This is used to verify that the values that went in were the same as the ones
    that came out. The methods therefore test posting the comment data to the `/api/comment`
    endpoint, verifying the data that sent back by the server has the right data in
    it. The `test_getting_comment` method checks again that a comment is posted to
    the server but is more concerned if the result that was requested by verifying
    the data that was sent in was the same as what came out.
  prefs: []
  type: TYPE_NORMAL
- en: Test-friendly configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the first obstacles faced by writing tests in a team or with a production
    environment is, How do we make sure that the tests are run without interfering
    with the production or even the development database. You certainly don't want
    to be attempting to fix bugs, or trialing new features and then finding that the
    data it relies upon has changed. Sometimes, a quick test just needs to be run
    on a local copy of the database without interference from anyone else, with the
    Flask app knowing how to use that.
  prefs: []
  type: TYPE_NORMAL
- en: One of the features built into Flask is the ability to load a configuration
    file depending on the environment variables.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The preceding method call informs your Flask app that the configuration should
    be loaded in the file specified in the environment variable `FLASK_APP_BLOG_CONFIG_FILE`.
    This has to be an absolute path to the file that you would like to load. Therefore,
    when you run your tests, a file specific to running your tests should be referred
    to here.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we already have a configuration file set up for our environment and we are
    looking to create a testing configuration file, a useful trick is to make use
    of the existing configuration and override just the important bits. The first
    thing to do is to create yourself a config directory with an __init__.py file.
    Our testing.py configuration file can then be added to that directory and can
    override some aspects of your config.py configuration file. For example, your
    new testing configuration file might look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code adds the TESTING attribute that can be used to determine
    if your app is currently being tested, and changes the DATABASE value to a database
    that is more suitable for testing, an in-memory SQLite database that doesn't have
    to be cleared down once your test finishes
  prefs: []
  type: TYPE_NORMAL
- en: 'These values can then be used like any other configuration in Flask and, when
    running the tests, the environment variable can be specified to point to that
    file. If we want to automate the updating of the environment variable for our
    tests, we can update Python''s built-in OS environment variable object in our
    `test.py` file in the `test` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Mocking objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mocking is an exceptionally useful part of any tester's tool kit. Mocking allows
    for custom objects to be over written with an object that can be used to verify
    if a method is doing the correct thing to its arguments. Sometimes, this may need
    a bit of re-imagining and a refactoring of your app so as to work in a testable
    way, but otherwise the concept is simple. We create a mocking object, run it through
    the method, and then run the tests on that object. It lends itself particularly
    well to databases and ORM models such as from `SQLAlchemy`.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are lots of Mocking frameworks available but, for this book, we shall
    be using `Mockito`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'It is one of the simplest to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code imports the functions from the `Mockito` library, creates
    a `mock` object that can be used for mocking, runs a method on it, and verifies
    that the method has been run. Obviously, if you want the method being tested to
    function properly without an error, you will need it to return a valid value when
    the method on the mocked object is being called.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we are creating a mocked up `duck` object, giving
    it the ability to `quack,` and then proving that it can `quack`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In dynamically typed languages such as Python, where an object you have may
    not be the one you are expecting, it is common practice to use duck-typing. As
    the phrase says "if it walks like a duck and quacks like a duck, it must be a
    duck". This is really useful when creating mocking objects, as it is easy to use
    a fake Mock object without your methods noticing the switch.
  prefs: []
  type: TYPE_NORMAL
- en: The difficulty arises when Flask uses its decorators to run methods before your
    method is run and you need to override it to, for example, replace the database
    initiator. The technique that can be used here is to have the decorators run a
    method that is globally available to the module, such as a method that creates
    a connection to the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Say your `app.py` looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code sets up a very simple app that creates a fake database as
    a Python dictionary object. Now to override with our own database as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code uses the Mockito library to create a fake database object.
    It also creates a method that overrides the method in the app module that creates
    the connection to the database—in this case, a simple dictionary object. You will
    notice that you can also specify arguments for methods when using Mockito. Now
    when the test is run, it inserts a value into the database for the page to return;
    this is then tested.
  prefs: []
  type: TYPE_NORMAL
- en: Logging and error reporting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Logging and error reporting are intrinsic to a production-ready web app. Logging
    keeps a record of all problems even if your app has crashed, while error reporting
    can directly notify us of specific problems even though the site keeps running.
  prefs: []
  type: TYPE_NORMAL
- en: It can be very gratifying to discover errors before anyone has reported them.
    It also makes it possible to roll out fixes before your users start complaining
    to you. However, to do this, you need to know what those errors were, when they
    occurred, and what caused them.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, as must be quite familiar right now, Python and Flask already have
    this in hand.
  prefs: []
  type: TYPE_NORMAL
- en: Logging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Flask comes with a built-in logger—an already defined instance of Python's built-in
    logger. You will hopefully be quite familiar with it by now. The logger messages
    are displayed, by default, each time a page is accessed.
  prefs: []
  type: TYPE_NORMAL
- en: '![Logging](img/1709_08_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding screenshot, obviously, shows the output to the terminal. We can
    see here that someone accessed the root page from `localhost` (`127.0.0.1`), on
    that particular date, with a `GET` request, as well as a few other directories.
    The server responded with one '`200` success' message, and two '`404` not found
    error' messages. While having this terminal output is useful when developing,
    it is not necessarily very useful if your app crashed while running in your production
    environment. We will need to see what happened from a file that was written to.
  prefs: []
  type: TYPE_NORMAL
- en: Logging to file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are various OS, dependent ways of writing logs like this to a file. However,
    as indicated previously, Python does have this built in, and Flask simply follows
    Python''s plan, which is quite simple. Add the following to the `app.py file`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: One thing to note here is that loggers make use of different handlers to complete
    their functionality. The handler we are using here is `RotatingFileHandler`. Not
    only does this handler write the files to disk (in this case to `blog.log)Courier`
    but also makes sure that our file doesn't get too big and fills up the disk with
    log messages, potentially taking the site down.
  prefs: []
  type: TYPE_NORMAL
- en: Custom log messages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One thing that can be really useful when trying to debug a difficult-to-trace
    issue is that we can add more logging to our blogging app. This can be done with
    the built-in logging object within Flask as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example demonstrates how to create a custom logging message. However,
    a message such as this will actually slow down our application quite considerably
    as it will write that message to the file or to the console, each time the homepage
    is accessed. Fortunately, Flask also understands the concept of logging levels,
    whereby we can specify which messages should be logged in different environments.
    For example, it would not be useful to record a message such as an info message
    in a production environment whereas a user failing to log in would be worthy of
    recording.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command simply logs a warning that a user failed to log in successfully
    using Python's string format method. As long as the error logging is low enough
    in Python, this message will be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: Levels
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The principle of logging levels is: the higher the importance of the log, the
    higher the level, and the less likely it is to be logged, depending on your logging
    level. For example, to be able to log warnings (and above, such as `ERROR`), we
    need to adjust the logging level to `WARNING`. We can do this in our configuration
    file. Edit the `config.py` file in the `config` folder to add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code snippet just uses the built-in Python logger to tell Flask
    how to handle logs. Of course, you can set different logging levels depending
    on your environment. For example, in your `testing.py` file in the `config` folder,
    we should use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: As for the purpose of testing, we don't need warnings. Similarly, we should
    do this for any production configuration file; for any development configuration
    files, use style.
  prefs: []
  type: TYPE_NORMAL
- en: Error reporting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It's all well and good having errors logged on the machine but it's even better
    if the errors come straight to your inbox where you can be immediately notified.
    Fortunately, as with all these things, Python has a built-in way of doing it that
    Flask can make use of. It is just another handler such as `RotatingFileHandler`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code creates `SMTPHandler` with a configuration that identifies
    where your mail server is and what the send address is, takes a list of e-mail
    addresses to send to from the configuration file, and gives the e-mail a subject
    so that we can identify where the error came from.
  prefs: []
  type: TYPE_NORMAL
- en: Read more
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Unit testing is a vast and complex area. Flask has some excellent documentation
    on other techniques for writing effective tests: [http://flask.pocoo.org/docs/0.10/testing/](http://flask.pocoo.org/docs/0.10/testing/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Python, of course, has its own documentation on unit testing: [https://docs.python.org/2/library/unittest.html](https://docs.python.org/2/library/unittest.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Flask uses the logging module from Python for its logging. This, in turn, follows
    the C library structure for its logging levels. More detail can be found at: [https://docs.python.org/2/library/logging.html](https://docs.python.org/2/library/logging.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learnt how to create some tests for our blogging app
    to verify that it is loading pages correctly, and that logging-in is taking place
    correctly. We have also set up logging to files and sent e-mails when errors occur.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how we can improve our blog with extensions
    that add extra features with minimal effort on our part.
  prefs: []
  type: TYPE_NORMAL
