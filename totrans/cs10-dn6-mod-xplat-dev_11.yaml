- en: '11'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Querying and Manipulating DataÂ Using LINQ
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is about **Language INtegrated Query** (**LINQ** ) expressions.
    LINQ is a set of language extensions that add the ability to work with sequences
    of items and then filter, sort, and project them into different outputs.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Writing LINQ expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with sets using LINQ
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using LINQ with EF Core
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sweetening LINQ syntax with syntactic sugar
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using multiple threads with parallel LINQ
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating your own LINQ extension methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with LINQ to XML
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing LINQ expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although we wrote a few LINQ expressions in *Chapter 10* , *Working with Data
    Using Entity Framework Core* , they weren't the focus, and so I didn't properly
    explain how LINQ works, so let's now take time to properly understand them.
  prefs: []
  type: TYPE_NORMAL
- en: What makes LINQ?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'LINQ has several parts; some are required, and some are optional:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Extension methods (required)** : These include examples such as `Where` ,
    `OrderBy` , and `Select` . These are what provide the functionality of LINQ.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**LINQ providers (required)** : These include LINQ to Objects for processing
    in-memory objects, LINQ to Entities for processing data stored in external databases
    and modeled with EF Core, and LINQ to XML for processing data stored as XML. These
    providers are what execute LINQ expressions in a way specific to different types
    of data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lambda expressions (optional)** : These can be used instead of named methods
    to simplify LINQ queries, for example, for the conditional logic of the `Where`
    method for filtering.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**LINQ query comprehension syntax (optional)** : These include C# keywords
    like `from` , `in` , `where` , `orderby` , `descending` , and `select` . These
    are aliases for some of the LINQ extension methods, and their use can simplify
    the queries you write, especially if you already have experience with other query
    languages, such as **Structured Query Language** (**SQL** ).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When programmers are first introduced to LINQ, they often believe that LINQ
    query comprehension syntax is LINQ, but ironically, that is one of the parts of
    LINQ that is optional!
  prefs: []
  type: TYPE_NORMAL
- en: Building LINQ expressions with the Enumerable class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The LINQ extension methods, such as `Where` and `Select` , are appended by the
    `Enumerable` static class to any type, known as a **sequence** , that implements
    `IEnumerable<T>` .
  prefs: []
  type: TYPE_NORMAL
- en: For example, an array of any type implements the `IEnumerable<T>` class, where
    `T` is the type of item in the array. This means that all arrays support LINQ
    to query and manipulate them.
  prefs: []
  type: TYPE_NORMAL
- en: All generic collections, such as `List<T>` , `Dictionary<TKey, TValue>` , `Stack<T>`
    , and `Queue<T>` , implement `IEnumerable<T>` , so they can be queried and manipulated
    with LINQ too.
  prefs: []
  type: TYPE_NORMAL
- en: '`Enumerable` defines more than 50 extension methods, as summarized in the following
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Method(s) | Description |'
  prefs: []
  type: TYPE_TB
- en: '| `First` , `FirstOrDefault` , `Last` , `LastOrDefault` | Get the first or
    last item in the sequence or throw an exception, or return the default value for
    the type, for example, `0` for an `int` and `null` for a reference type, if there
    is not a first or last item. |'
  prefs: []
  type: TYPE_TB
- en: '| `Where` | Return a sequence of items that match a specified filter. |'
  prefs: []
  type: TYPE_TB
- en: '| `Single` , `SingleOrDefault` | Return an item that matches a specific filter
    or throw an exception, or return the default value for the type if there is not
    exactly one match. |'
  prefs: []
  type: TYPE_TB
- en: '| `ElementAt` , `ElementAtOrDefault` | Return an item at a specified index
    position or throw an exception, or return the default value for the type if there
    is not an item at that position. New in .NET 6 are overloads that can be passed
    an `Index` instead of an `int` , which is more efficient when working with `Span<T>`
    sequences. |'
  prefs: []
  type: TYPE_TB
- en: '| `Select` , `SelectMany` | Project items into a different shape, that is,
    a different type, and flatten a nested hierarchy of items. |'
  prefs: []
  type: TYPE_TB
- en: '| `OrderBy` , `OrderByDescending` , `ThenBy` , `ThenByDescending` | Sort items
    by a specified field or property. |'
  prefs: []
  type: TYPE_TB
- en: '| `Reverse` | Reverse the order of the items. |'
  prefs: []
  type: TYPE_TB
- en: '| `GroupBy` , `GroupJoin` , `Join` | Group and/or join two sequences. |'
  prefs: []
  type: TYPE_TB
- en: '| `Skip` , `SkipWhile` | Skip a number of items; or skip while an expression
    is `true` . |'
  prefs: []
  type: TYPE_TB
- en: '| `Take` , `TakeWhile` | Take a number of items; or take while an expression
    is `true` . New in .NET 6 is a `Take` overload that can be passed a `Range` ,
    for example, `Take(range: 3..^5)` meaning take a subset starting 3 items in from
    the start and ending 5 items in from the end, or instead of `Skip(4)` you could
    use `Take(4..)` . |'
  prefs: []
  type: TYPE_TB
- en: '| `Aggregate` , `Average` , `Count` , `LongCount` , `Max` , `Min` , `Sum` |
    Calculate aggregate values. |'
  prefs: []
  type: TYPE_TB
- en: '| `TryGetNonEnumeratedCount` | `Count()` checks if a `Count` property is implemented
    on the sequence and returns its value, or it enumerates the entire sequence to
    count its items. New in .NET 6 is this method that only checks for `Count` and
    if it is missing it returns `false` and sets the `out` parameter to `0` to avoid
    a potentially poor-performing operation. |'
  prefs: []
  type: TYPE_TB
- en: '| `All` , `Any` , `Contains` | Return `true` if all or any of the items match
    the filter, or if the sequence contains a specified item. |'
  prefs: []
  type: TYPE_TB
- en: '| `Cast` | Cast items into a specified type. It is useful to convert non-generic
    objects to a generic type in scenarios where the compiler would otherwise complain.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `OfType` | Remove items that do not match a specified type. |'
  prefs: []
  type: TYPE_TB
- en: '| `Distinct` | Remove duplicate items. |'
  prefs: []
  type: TYPE_TB
- en: '| `Except` , `Intersect` , `Union` | Perform operations that return sets. Sets
    cannot have duplicate items. Although the inputs can be any sequence and so the
    inputs can have duplicates, the result is always a set. |'
  prefs: []
  type: TYPE_TB
- en: '| `Chunk` | Divide a sequence into sized batches. |'
  prefs: []
  type: TYPE_TB
- en: '| `Append` , `Concat` , `Prepend` | Perform sequence-combining operations.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Zip` | Perform a match operation on two sequences based on the position
    of items, for example, the item at position 1 in the first sequence matches the
    item at position 1 in the second sequence. New in .NET 6 is a match operation
    on three sequences. Previously you would have had to run the two sequences overload
    twice to achieve the same goal. |'
  prefs: []
  type: TYPE_TB
- en: '| `ToArray` , `ToList` , `ToDictionary` , `ToHashSet` , `ToLookup` | Convert
    the sequence into an array or collection. These are the only extension methods
    that execute the LINQ expression. |'
  prefs: []
  type: TYPE_TB
- en: '| `DistinctBy` , `ExceptBy` , `IntersectBy` , `UnionBy` , `MinBy` , `MaxBy`
    | New in .NET 6 are the `By` extension methods. They allow the comparison to be
    performed on a subset of the item rather than the entire item. For example, instead
    of removing duplicates by comparing an entire `Person` object, you could remove
    duplicates by comparing just their `LastName` and `DateOfBirth` . |'
  prefs: []
  type: TYPE_TB
- en: 'The `Enumerable` class also has some methods that are not extension methods,
    as shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Description |'
  prefs: []
  type: TYPE_TB
- en: '| `Empty<T>` | Returns an empty sequence of the specified type `T` . It is
    useful for passing an empty sequence to a method that requires an `IEnumerable<T>`
    . |'
  prefs: []
  type: TYPE_TB
- en: '| `Range` | Returns a sequence of integers from the `start` value with `count`
    items. For example, `Enumerable.Range(start: 5, count: 3)` would contain the integers
    5, 6, and 7. |'
  prefs: []
  type: TYPE_TB
- en: '| `Repeat` | Returns a sequence that contains the same `element` repeated `count`
    times. For example, `Enumerable.Repeat(element: "5", count: 3)` would contain
    the `string` values "5", "5", and "5". |'
  prefs: []
  type: TYPE_TB
- en: Understanding deferred execution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'LINQ uses **deferred execution** . It is important to understand that calling
    most of these extension methods does not execute the query and get the results.
    Most of these extension methods return a LINQ expression that represents a *question*
    , not an *answer* . Let''s explore:'
  prefs: []
  type: TYPE_NORMAL
- en: Use your preferred code editor to create a new solution/workspace named `Chapter11`
    .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a console app project, as defined in the following list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Project template: **Console Application** / `console`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Workspace/solution file and folder: `Chapter11`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Project file and folder: `LinqWithObjects`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `Program.cs` , delete the existing code and statically import `Console` .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add statements to define a sequence of `string` values for people who work
    in an office, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: // a string array is a sequence that implements IEnumerable<string>
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: '[] names = new'
  prefs: []
  type: TYPE_NORMAL
- en: '[] { "Michael"'
  prefs: []
  type: TYPE_NORMAL
- en: ', "Pam"'
  prefs: []
  type: TYPE_NORMAL
- en: ', "Jim"'
  prefs: []
  type: TYPE_NORMAL
- en: ', "Dwight"'
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: '"Angela"'
  prefs: []
  type: TYPE_NORMAL
- en: ', "Kevin"'
  prefs: []
  type: TYPE_NORMAL
- en: ', "Toby"'
  prefs: []
  type: TYPE_NORMAL
- en: ', "Creed"'
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("Deferred execution"
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '// Question: Which names end with an M?'
  prefs: []
  type: TYPE_NORMAL
- en: // (written using a LINQ extension method)
  prefs: []
  type: TYPE_NORMAL
- en: var
  prefs: []
  type: TYPE_NORMAL
- en: query1 = names.Where(name => name.EndsWith("m"
  prefs: []
  type: TYPE_NORMAL
- en: ));
  prefs: []
  type: TYPE_NORMAL
- en: '// Question: Which names end with an M?'
  prefs: []
  type: TYPE_NORMAL
- en: // (written using LINQ query comprehension syntax)
  prefs: []
  type: TYPE_NORMAL
- en: var
  prefs: []
  type: TYPE_NORMAL
- en: query2 = from
  prefs: []
  type: TYPE_NORMAL
- en: name in
  prefs: []
  type: TYPE_NORMAL
- en: names where
  prefs: []
  type: TYPE_NORMAL
- en: name.EndsWith("m"
  prefs: []
  type: TYPE_NORMAL
- en: ) select
  prefs: []
  type: TYPE_NORMAL
- en: name;
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'To ask the question and get the answer, i.e. execute the query, you must **materialize**
    it by either calling one of the "To" methods like `ToArray` or `ToLookup` or by
    enumerating the query, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: // Answer returned as an array of strings containing Pam and Jim
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: '[] result1 = query1.ToArray();'
  prefs: []
  type: TYPE_NORMAL
- en: // Answer returned as a list of strings containing Pam and Jim
  prefs: []
  type: TYPE_NORMAL
- en: List<string
  prefs: []
  type: TYPE_NORMAL
- en: result2 = query2.ToList();
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: // Answer returned as we enumerate over the results
  prefs: []
  type: TYPE_NORMAL
- en: foreach
  prefs: []
  type: TYPE_NORMAL
- en: (string
  prefs: []
  type: TYPE_NORMAL
- en: name in
  prefs: []
  type: TYPE_NORMAL
- en: query1)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine(name); // outputs Pam
  prefs: []
  type: TYPE_NORMAL
- en: names[2
  prefs: []
  type: TYPE_NORMAL
- en: '] = "Jimmy"'
  prefs: []
  type: TYPE_NORMAL
- en: ; // change Jim to Jimmy
  prefs: []
  type: TYPE_NORMAL
- en: // on the second iteration Jimmy does not end with an M
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the console app and note the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: Deferred execution
  prefs: []
  type: TYPE_NORMAL
- en: Pam
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Due to deferred execution, after outputting the first result, `Pam` , if the
    original array values change, then by the time we loop back around, there are
    no more matches because `Jim` has become `Jimmy` and does not end with an `M`
    , so only `Pam` is outputted.
  prefs: []
  type: TYPE_NORMAL
- en: Before we get too deep into the weeds, let's slow down and look at some common
    LINQ extension methods and how to use them, one at a time.
  prefs: []
  type: TYPE_NORMAL
- en: Filtering entities with Where
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The most common reason for using LINQ is to filter items in a sequence using
    the `Where` extension method. Let''s explore filtering by defining a sequence
    of names and then applying LINQ operations to it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the project file, comment out the element that enables implicit usings,
    as shown highlighted in the following markup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: <Project Sdk="Microsoft.NET.Sdk"
  prefs: []
  type: TYPE_NORMAL
- en: '>'
  prefs: []
  type: TYPE_NORMAL
- en: <PropertyGroup>
  prefs: []
  type: TYPE_NORMAL
- en: <OutputType>Exe</OutputType>
  prefs: []
  type: TYPE_NORMAL
- en: <TargetFramework>net6.0
  prefs: []
  type: TYPE_NORMAL
- en: </TargetFramework>
  prefs: []
  type: TYPE_NORMAL
- en: <Nullable>enable</Nullable>
  prefs: []
  type: TYPE_NORMAL
- en: '**<!--<ImplicitUsings>enable</ImplicitUsings>-->**'
  prefs: []
  type: TYPE_NORMAL
- en: </PropertyGroup>
  prefs: []
  type: TYPE_NORMAL
- en: </Project>
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs` , attempt to call the `Where` extension method on the array
    of names, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("Writing queries"
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: var
  prefs: []
  type: TYPE_NORMAL
- en: query = names.W
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: As you try to type the `Where` method, note that it is missing from the IntelliSense
    list of members of a string array, as shown in *Figure 11.1* :![](img/Image00095.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 11.1: IntelliSense with the Where extension method missing'
  prefs: []
  type: TYPE_NORMAL
- en: This is because `Where` is an extension method. It does not exist on the array
    type. To make the `Where` extension method available, we must import the `System.Linq`
    namespace. This is implicitly imported by default in new .NET 6 projects, but
    we disabled it.
  prefs: []
  type: TYPE_NORMAL
- en: In the project file, uncomment out the element that enables implicit usings.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Retype the `Where` method and note that the IntelliSense list now includes the
    extension methods added by the `Enumerable` class, as shown in *Figure 11.2* :![](img/Image00096.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 11.2: IntelliSense showing LINQ Enumerable extension methods now'
  prefs: []
  type: TYPE_NORMAL
- en: As you type the parentheses for the `Where` method, IntelliSense tells us that
    to call `Where` , we must pass in an instance of a `Func<string, bool>` delegate.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter an expression to create a new instance of a `Func<string, bool>` delegate,
    and for now note that we have not yet supplied a method name because we will define
    it in the next step, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: var
  prefs: []
  type: TYPE_NORMAL
- en: query = names.Where(new
  prefs: []
  type: TYPE_NORMAL
- en: Func<string
  prefs: []
  type: TYPE_NORMAL
- en: ', bool'
  prefs: []
  type: TYPE_NORMAL
- en: '>( ))'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: The `Func<string, bool>` delegate tells us that for each `string` variable passed
    to the method, the method must return a `bool` value. If the method returns `true`
    , it indicates that we should include the `string` in the results, and if the
    method returns `false` , it indicates that we should exclude it.
  prefs: []
  type: TYPE_NORMAL
- en: Targeting a named method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s define a method that only includes names that are longer than four characters:'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the bottom of `Program.cs` , define a method that will include only names
    longer than four characters, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: static
  prefs: []
  type: TYPE_NORMAL
- en: bool
  prefs: []
  type: TYPE_NORMAL
- en: NameLongerThanFour
  prefs: []
  type: TYPE_NORMAL
- en: (
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: name
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: return
  prefs: []
  type: TYPE_NORMAL
- en: name.Length > 4
  prefs: []
  type: TYPE_NORMAL
- en: ;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Above the `NameLongerThanFour` method, pass the method''s name into the `Func<string,
    bool>` delegate, and then loop through the query items, as shown highlighted in
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: var
  prefs: []
  type: TYPE_NORMAL
- en: query = names.Where(
  prefs: []
  type: TYPE_NORMAL
- en: new
  prefs: []
  type: TYPE_NORMAL
- en: Func<string
  prefs: []
  type: TYPE_NORMAL
- en: ', bool'
  prefs: []
  type: TYPE_NORMAL
- en: '>('
  prefs: []
  type: TYPE_NORMAL
- en: '**NameLongerThanFour**'
  prefs: []
  type: TYPE_NORMAL
- en: ));
  prefs: []
  type: TYPE_NORMAL
- en: '**foreach**'
  prefs: []
  type: TYPE_NORMAL
- en: '**(**'
  prefs: []
  type: TYPE_NORMAL
- en: '**string**'
  prefs: []
  type: TYPE_NORMAL
- en: '**item**'
  prefs: []
  type: TYPE_NORMAL
- en: '**in**'
  prefs: []
  type: TYPE_NORMAL
- en: '**query)**'
  prefs: []
  type: TYPE_NORMAL
- en: '**{**'
  prefs: []
  type: TYPE_NORMAL
- en: '**WriteLine(item);**'
  prefs: []
  type: TYPE_NORMAL
- en: '**}**'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code and view the results, noting that only names longer than four
    letters are listed, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: Writing queries
  prefs: []
  type: TYPE_NORMAL
- en: Michael
  prefs: []
  type: TYPE_NORMAL
- en: Dwight
  prefs: []
  type: TYPE_NORMAL
- en: Angela
  prefs: []
  type: TYPE_NORMAL
- en: Kevin
  prefs: []
  type: TYPE_NORMAL
- en: Creed
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Simplifying the code by removing the explicit delegate instantiation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can simplify the code by deleting the explicit instantiation of the `Func<string,
    bool>` delegate because the C# compiler can instantiate the delegate for us:'
  prefs: []
  type: TYPE_NORMAL
- en: To help you learn by seeing progressively improved code, copy and paste the
    query
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Comment out the first example, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: // var query = names.Where(
  prefs: []
  type: TYPE_NORMAL
- en: //   new Func<string, bool>(NameLongerThanFour));
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the copy to remove the explicit instantiation of the delegate, as shown
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: var
  prefs: []
  type: TYPE_NORMAL
- en: query = names.Where(NameLongerThanFour);
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Run the code and note that it has the same behavior.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Targeting a lambda expression
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can simplify our code even further using a **lambda expression** in place
    of a named method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although it can look complicated at first, a lambda expression is simply a
    *nameless function* . It uses the `=>` (read as "goes to") symbol to indicate
    the return value:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Copy and paste the query, comment the second example, and modify the query,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: var
  prefs: []
  type: TYPE_NORMAL
- en: query = names.Where(name => name.Length > 4
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the syntax for a lambda expression includes all the important parts
    of the `NameLongerThanFour` method, but nothing more. A lambda expression only
    needs to define the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The names of input parameters: `name`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A return value expression: `name.Length > 4`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The type of the `name` input parameter is inferred from the fact that the sequence
    contains `string` values, and the return type must be a `bool` value as defined
    by the delegate for `Where` to work, so the expression after the `=>` symbol must
    return a `bool` value.
  prefs: []
  type: TYPE_NORMAL
- en: The compiler does most of the work for us, so our code can be as concise as
    possible.
  prefs: []
  type: TYPE_NORMAL
- en: Run the code and note that it has the same behavior.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sorting entities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Other commonly used extension methods are `OrderBy` and `ThenBy` , used for
    sorting a sequence.
  prefs: []
  type: TYPE_NORMAL
- en: Extension methods can be chained if the previous method returns another sequence,
    that is, a type that implements the `IEnumerable<T>` interface.
  prefs: []
  type: TYPE_NORMAL
- en: Sorting by a single property using OrderBy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s continue working with the current project to explore sorting:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Append a call to `OrderBy` to the end of the existing query, as shown in the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: var
  prefs: []
  type: TYPE_NORMAL
- en: query = names
  prefs: []
  type: TYPE_NORMAL
- en: .Where(name => name.Length > 4
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: .OrderBy(name => name.Length);
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice** : Format the LINQ statement so that each extension method
    call happens on its own line to make them easier to read.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code and note that the names are now sorted by shortest first, as shown
    in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: Kevin
  prefs: []
  type: TYPE_NORMAL
- en: Creed
  prefs: []
  type: TYPE_NORMAL
- en: Dwight
  prefs: []
  type: TYPE_NORMAL
- en: Angela
  prefs: []
  type: TYPE_NORMAL
- en: Michael
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: To put the longest name first, you would use `OrderByDescending` .
  prefs: []
  type: TYPE_NORMAL
- en: Sorting by a subsequent property using ThenBy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We might want to sort by more than one property, for example, to sort names
    of the same length in alphabetical order:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a call to the `ThenBy` method at the end of the existing query, as shown
    highlighted in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: var
  prefs: []
  type: TYPE_NORMAL
- en: query = names
  prefs: []
  type: TYPE_NORMAL
- en: .Where(name => name.Length > 4
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: .OrderBy(name => name.Length)
  prefs: []
  type: TYPE_NORMAL
- en: '**.ThenBy(name => name);**'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code and note the slight difference in the following sort order. Within
    a group of names of the same length, the names are sorted alphabetically by the
    full value of the `string` , so `Creed` comes before `Kevin` , and `Angela` comes
    before `Dwight` , as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: Creed
  prefs: []
  type: TYPE_NORMAL
- en: Kevin
  prefs: []
  type: TYPE_NORMAL
- en: Angela
  prefs: []
  type: TYPE_NORMAL
- en: Dwight
  prefs: []
  type: TYPE_NORMAL
- en: Michael
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Declaring a query using var or a specified type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While writing a LINQ expression it is convenient to use `var` to declare the
    query object. This is because the type frequently changes as you work on the LINQ
    expression. For example, our query started as an `IEnumerable<string>` and is
    currently an `IOrderedEnumerable<string>` :'
  prefs: []
  type: TYPE_NORMAL
- en: Hover your mouse over the `var` keyword and note that its type is `IOrderedEnumerable<string>`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Replace `var` with the actual type, as shown highlighted in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: '**IOrderedEnumerable<**'
  prefs: []
  type: TYPE_NORMAL
- en: '**string**'
  prefs: []
  type: TYPE_NORMAL
- en: '**>**'
  prefs: []
  type: TYPE_NORMAL
- en: query = names
  prefs: []
  type: TYPE_NORMAL
- en: .Where(name => name.Length > 4
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: .OrderBy(name => name.Length)
  prefs: []
  type: TYPE_NORMAL
- en: .ThenBy(name => name);
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice** : Once you have finished working on a query, you could change
    the declared type from `var` to the actual type to make it clearer what the type
    is. This is easy because your code editor can tell you what it is.'
  prefs: []
  type: TYPE_NORMAL
- en: Filtering by type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Where` extension method is great for filtering by values, such as text
    and numbers. But what if the sequence contains multiple types, and you want to
    filter by a specific type and respect any inheritance hierarchy?
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine that you have a sequence of exceptions. There are hundreds of exception
    types that form a complex hierarchy, as partially shown in *Figure 11.3* :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram Description automatically generated](img/Image00097.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.3: A partial exception inheritance hierarchy'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s explore filtering by type:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs` , define a list of exception-derived objects, as shown in the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("Filtering by type"
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: List<Exception> exceptions = new
  prefs: []
  type: TYPE_NORMAL
- en: ()
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: new
  prefs: []
  type: TYPE_NORMAL
- en: ArgumentException(),
  prefs: []
  type: TYPE_NORMAL
- en: new
  prefs: []
  type: TYPE_NORMAL
- en: SystemException(),
  prefs: []
  type: TYPE_NORMAL
- en: new
  prefs: []
  type: TYPE_NORMAL
- en: IndexOutOfRangeException(),
  prefs: []
  type: TYPE_NORMAL
- en: new
  prefs: []
  type: TYPE_NORMAL
- en: InvalidOperationException(),
  prefs: []
  type: TYPE_NORMAL
- en: new
  prefs: []
  type: TYPE_NORMAL
- en: NullReferenceException(),
  prefs: []
  type: TYPE_NORMAL
- en: new
  prefs: []
  type: TYPE_NORMAL
- en: InvalidCastException(),
  prefs: []
  type: TYPE_NORMAL
- en: new
  prefs: []
  type: TYPE_NORMAL
- en: OverflowException(),
  prefs: []
  type: TYPE_NORMAL
- en: new
  prefs: []
  type: TYPE_NORMAL
- en: DivideByZeroException(),
  prefs: []
  type: TYPE_NORMAL
- en: new
  prefs: []
  type: TYPE_NORMAL
- en: ApplicationException()
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write statements using the `OfType<T>` extension method to remove exceptions
    that are not arithmetic exceptions and write only the arithmetic exceptions to
    the console, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: IEnumerable<ArithmeticException> arithmeticExceptionsQuery =
  prefs: []
  type: TYPE_NORMAL
- en: exceptions.OfType<ArithmeticException>();
  prefs: []
  type: TYPE_NORMAL
- en: foreach
  prefs: []
  type: TYPE_NORMAL
- en: (ArithmeticException exception in
  prefs: []
  type: TYPE_NORMAL
- en: arithmeticExceptionsQuery)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine(exception);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code and note that the results only include exceptions of the `ArithmeticException`
    type, or the `ArithmeticException` -derived types, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.OverflowException: Arithmetic operation resulted in an overflow.'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.DivideByZeroException: Attempted to divide by zero.'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Working with sets and bags using LINQ
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sets are one of the most fundamental concepts in mathematics. A **set** is a
    collection of one or more unique objects. A **multiset** , aka **bag** , is a
    collection of one or more objects that can have duplicates.
  prefs: []
  type: TYPE_NORMAL
- en: You might remember being taught about Venn diagrams in school. Common set operations
    include the **intersect** or **union** between sets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a console application that will define three arrays of `string`
    values for cohorts of apprentices and then perform some common set and multiset
    operations on them:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use your preferred code editor to add a new console app named `LinqWithSets`
    to the `Chapter11` solution/workspace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Visual Studio, set the startup project for the solution to the current selection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Visual Studio Code, select `LinqWithSets` as the active OmniSharp project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Program.cs` , delete the existing code and statically import the `Console`
    type, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: static
  prefs: []
  type: TYPE_NORMAL
- en: System.Console;
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the bottom of `Program.cs` , add the following method that outputs any sequence
    of `string` variables as a comma-separated single `string` to the console output,
    along with an optional description, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: static
  prefs: []
  type: TYPE_NORMAL
- en: void
  prefs: []
  type: TYPE_NORMAL
- en: Output
  prefs: []
  type: TYPE_NORMAL
- en: (
  prefs: []
  type: TYPE_NORMAL
- en: IEnumerable<
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: cohort,
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: description =
  prefs: []
  type: TYPE_NORMAL
- en: '""'
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: if
  prefs: []
  type: TYPE_NORMAL
- en: (!string
  prefs: []
  type: TYPE_NORMAL
- en: .IsNullOrEmpty(description))
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine(description);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: Write(" "
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine(string
  prefs: []
  type: TYPE_NORMAL
- en: .Join(", "
  prefs: []
  type: TYPE_NORMAL
- en: ', cohort.ToArray()));'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Above the `Output` method, add statements to define three arrays of names,
    output them, and then perform various set operations on them, as shown in the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: '[] cohort1 = new'
  prefs: []
  type: TYPE_NORMAL
- en: '[]'
  prefs: []
  type: TYPE_NORMAL
- en: '{ "Rachel"'
  prefs: []
  type: TYPE_NORMAL
- en: ', "Gareth"'
  prefs: []
  type: TYPE_NORMAL
- en: ', "Jonathan"'
  prefs: []
  type: TYPE_NORMAL
- en: ', "George"'
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: '[] cohort2 = new'
  prefs: []
  type: TYPE_NORMAL
- en: '[]'
  prefs: []
  type: TYPE_NORMAL
- en: '{ "Jack"'
  prefs: []
  type: TYPE_NORMAL
- en: ', "Stephen"'
  prefs: []
  type: TYPE_NORMAL
- en: ', "Daniel"'
  prefs: []
  type: TYPE_NORMAL
- en: ', "Jack"'
  prefs: []
  type: TYPE_NORMAL
- en: ', "Jared"'
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: '[] cohort3 = new'
  prefs: []
  type: TYPE_NORMAL
- en: '[]'
  prefs: []
  type: TYPE_NORMAL
- en: '{ "Declan"'
  prefs: []
  type: TYPE_NORMAL
- en: ', "Jack"'
  prefs: []
  type: TYPE_NORMAL
- en: ', "Jack"'
  prefs: []
  type: TYPE_NORMAL
- en: ', "Jasmine"'
  prefs: []
  type: TYPE_NORMAL
- en: ', "Conor"'
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: Output(cohort1, "Cohort 1"
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: Output(cohort2, "Cohort 2"
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: Output(cohort3, "Cohort 3"
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: Output(cohort2.Distinct(), "cohort2.Distinct()"
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: Output(cohort2.DistinctBy(name => name.Substring(0
  prefs: []
  type: TYPE_NORMAL
- en: ', 2'
  prefs: []
  type: TYPE_NORMAL
- en: )),
  prefs: []
  type: TYPE_NORMAL
- en: '"cohort2.DistinctBy(name => name.Substring(0, 2)):"'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: Output(cohort2.Union(cohort3), "cohort2.Union(cohort3)"
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: Output(cohort2.Concat(cohort3), "cohort2.Concat(cohort3)"
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: Output(cohort2.Intersect(cohort3), "cohort2.Intersect(cohort3)"
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: Output(cohort2.Except(cohort3), "cohort2.Except(cohort3)"
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: Output(cohort1.Zip(cohort2,(c1, c2) => $"
  prefs: []
  type: TYPE_NORMAL
- en: '{c1}'
  prefs: []
  type: TYPE_NORMAL
- en: matched with
  prefs: []
  type: TYPE_NORMAL
- en: '{c2}'
  prefs: []
  type: TYPE_NORMAL
- en: '"'
  prefs: []
  type: TYPE_NORMAL
- en: ),
  prefs: []
  type: TYPE_NORMAL
- en: '"cohort1.Zip(cohort2)"'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code and view the results, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: Cohort 1
  prefs: []
  type: TYPE_NORMAL
- en: Rachel, Gareth, Jonathan, George
  prefs: []
  type: TYPE_NORMAL
- en: Cohort 2
  prefs: []
  type: TYPE_NORMAL
- en: Jack, Stephen, Daniel, Jack, Jared
  prefs: []
  type: TYPE_NORMAL
- en: Cohort 3
  prefs: []
  type: TYPE_NORMAL
- en: Declan, Jack, Jack, Jasmine, Conor
  prefs: []
  type: TYPE_NORMAL
- en: cohort2.Distinct()
  prefs: []
  type: TYPE_NORMAL
- en: Jack, Stephen, Daniel, Jared
  prefs: []
  type: TYPE_NORMAL
- en: 'cohort2.DistinctBy(name => name.Substring(0, 2)):'
  prefs: []
  type: TYPE_NORMAL
- en: Jack, Stephen, Daniel
  prefs: []
  type: TYPE_NORMAL
- en: cohort2.Union(cohort3)
  prefs: []
  type: TYPE_NORMAL
- en: Jack, Stephen, Daniel, Jared, Declan, Jasmine, Conor
  prefs: []
  type: TYPE_NORMAL
- en: cohort2.Concat(cohort3)
  prefs: []
  type: TYPE_NORMAL
- en: Jack, Stephen, Daniel, Jack, Jared, Declan, Jack, Jack, Jasmine, Conor
  prefs: []
  type: TYPE_NORMAL
- en: cohort2.Intersect(cohort3)
  prefs: []
  type: TYPE_NORMAL
- en: Jack
  prefs: []
  type: TYPE_NORMAL
- en: cohort2.Except(cohort3)
  prefs: []
  type: TYPE_NORMAL
- en: Stephen, Daniel, Jared
  prefs: []
  type: TYPE_NORMAL
- en: cohort1.Zip(cohort2)
  prefs: []
  type: TYPE_NORMAL
- en: Rachel matched with Jack, Gareth matched with Stephen, Jonathan matched with
    Daniel, George matched with Jack
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: With `Zip` , if there are unequal numbers of items in the two sequences, then
    some items will not have a matching partner. Those without a partner, like `Jared`
    , will not be included in the result.
  prefs: []
  type: TYPE_NORMAL
- en: For the `DistinctBy` example, instead of removing duplicates by comparing the
    whole name, we define a lambda key selector to remove duplicates by comparing
    the first two characters, so `Jared` is removed because `Jack` already is a name
    that starts with `Ja` .
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have used the LINQ to Objects provider to work with in-memory objects.
    Next, we will use the LINQ to Entities provider to work with entities stored in
    a database.
  prefs: []
  type: TYPE_NORMAL
- en: Using LINQ with EF Core
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have looked at LINQ queries that filter and sort, but none that change the
    shape of the items in the sequence. This is called **projection** because it's
    about projecting items of one shape into another shape. To learn about projection,
    it is best to have some more complex types to work with, so in the next project,
    instead of using `string` sequences, we will use sequences of entities from the
    Northwind sample database.
  prefs: []
  type: TYPE_NORMAL
- en: I will give instructions to use SQLite because it is cross-platform but if you
    prefer to use SQL Server then feel free to do so. I have included some commented
    code to enable SQL Server if you choose.
  prefs: []
  type: TYPE_NORMAL
- en: Building an EF Core model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We must define an EF Core model to represent the database and tables that we
    will work with. We will define the model manually to take complete control and
    to prevent a relationship from being automatically defined between the `Categories`
    and `Products` tables. Later, you will use LINQ to join the two entity sets:'
  prefs: []
  type: TYPE_NORMAL
- en: Use your preferred code editor to add a new console app named `LinqWithEFCore`
    to the `Chapter11` solution/workspace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Visual Studio Code, select `LinqWithEFCore` as the active OmniSharp project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `LinqWithEFCore` project, add a package reference to the EF Core provider
    for SQLite and/or SQL Server, as shown in the following markup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: <ItemGroup>
  prefs: []
  type: TYPE_NORMAL
- en: <PackageReference
  prefs: []
  type: TYPE_NORMAL
- en: Include="Microsoft.EntityFrameworkCore.Sqlite"
  prefs: []
  type: TYPE_NORMAL
- en: Version="6.0.0"
  prefs: []
  type: TYPE_NORMAL
- en: />
  prefs: []
  type: TYPE_NORMAL
- en: <PackageReference
  prefs: []
  type: TYPE_NORMAL
- en: Include="Microsoft.EntityFrameworkCore.SqlServer"
  prefs: []
  type: TYPE_NORMAL
- en: Version="6.0.0"
  prefs: []
  type: TYPE_NORMAL
- en: />
  prefs: []
  type: TYPE_NORMAL
- en: </ItemGroup>
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Build the project to restore packages.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the `Northwind4Sqlite.sql` file into the `LinqWithEFCore` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At a command prompt or terminal, create the Northwind database by executing
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: sqlite3 Northwind.db -init Northwind4Sqlite.sql
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Be patient because this command might take a while to create the database structure.
    Eventually you will see the SQLite command prompt, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: -- Loading resources from Northwind.sql
  prefs: []
  type: TYPE_NORMAL
- en: SQLite version 3.36.0 2021-08-02 15:20:15
  prefs: []
  type: TYPE_NORMAL
- en: Enter ".help" for usage hints.
  prefs: []
  type: TYPE_NORMAL
- en: sqlite>
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Press cmd + D on macOS or Ctrl + C on Windows to exit SQLite command mode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add three class files to the project, named `Northwind.cs` , `Category.cs` ,
    and `Product.cs` .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Modify the class file named `Northwind.cs` , as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft.EntityFrameworkCore; // DbContext, DbSet<T>
  prefs: []
  type: TYPE_NORMAL
- en: namespace
  prefs: []
  type: TYPE_NORMAL
- en: Packt.Shared
  prefs: []
  type: TYPE_NORMAL
- en: ;
  prefs: []
  type: TYPE_NORMAL
- en: // this manages the connection to the database
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: class
  prefs: []
  type: TYPE_NORMAL
- en: Northwind
  prefs: []
  type: TYPE_NORMAL
- en: ': DbContext'
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: // these properties map to tables in the database
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: DbSet<Category>? Categories { get
  prefs: []
  type: TYPE_NORMAL
- en: ; set
  prefs: []
  type: TYPE_NORMAL
- en: ; }
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: DbSet<Product>? Products { get
  prefs: []
  type: TYPE_NORMAL
- en: ; set
  prefs: []
  type: TYPE_NORMAL
- en: ; }
  prefs: []
  type: TYPE_NORMAL
- en: protected
  prefs: []
  type: TYPE_NORMAL
- en: override
  prefs: []
  type: TYPE_NORMAL
- en: void
  prefs: []
  type: TYPE_NORMAL
- en: OnConfiguring
  prefs: []
  type: TYPE_NORMAL
- en: (
  prefs: []
  type: TYPE_NORMAL
- en: DbContextOptionsBuilder optionsBuilder
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: path = Path.Combine(
  prefs: []
  type: TYPE_NORMAL
- en: Environment.CurrentDirectory, "Northwind.db"
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: optionsBuilder.UseSqlite($"Filename=
  prefs: []
  type: TYPE_NORMAL
- en: '{path}'
  prefs: []
  type: TYPE_NORMAL
- en: '"'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: /*
  prefs: []
  type: TYPE_NORMAL
- en: string connection = "Data Source=.;" +
  prefs: []
  type: TYPE_NORMAL
- en: '"Initial Catalog=Northwind;" +'
  prefs: []
  type: TYPE_NORMAL
- en: '"Integrated Security=true;" +'
  prefs: []
  type: TYPE_NORMAL
- en: '"MultipleActiveResultSets=true;";'
  prefs: []
  type: TYPE_NORMAL
- en: optionsBuilder.UseSqlServer(connection);
  prefs: []
  type: TYPE_NORMAL
- en: '*/'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: protected
  prefs: []
  type: TYPE_NORMAL
- en: override
  prefs: []
  type: TYPE_NORMAL
- en: void
  prefs: []
  type: TYPE_NORMAL
- en: OnModelCreating
  prefs: []
  type: TYPE_NORMAL
- en: (
  prefs: []
  type: TYPE_NORMAL
- en: ModelBuilder modelBuilder
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: modelBuilder.Entity<Product>()
  prefs: []
  type: TYPE_NORMAL
- en: .Property(product => product.UnitPrice)
  prefs: []
  type: TYPE_NORMAL
- en: .HasConversion<double
  prefs: []
  type: TYPE_NORMAL
- en: '>();'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the class file named `Category.cs` , as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: System.ComponentModel.DataAnnotations;
  prefs: []
  type: TYPE_NORMAL
- en: namespace
  prefs: []
  type: TYPE_NORMAL
- en: Packt.Shared
  prefs: []
  type: TYPE_NORMAL
- en: ;
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: class
  prefs: []
  type: TYPE_NORMAL
- en: Category
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: int
  prefs: []
  type: TYPE_NORMAL
- en: CategoryId { get
  prefs: []
  type: TYPE_NORMAL
- en: ; set
  prefs: []
  type: TYPE_NORMAL
- en: ; }
  prefs: []
  type: TYPE_NORMAL
- en: '[Required'
  prefs: []
  type: TYPE_NORMAL
- en: ']'
  prefs: []
  type: TYPE_NORMAL
- en: '[StringLength(15)'
  prefs: []
  type: TYPE_NORMAL
- en: ']'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: CategoryName { get
  prefs: []
  type: TYPE_NORMAL
- en: ; set
  prefs: []
  type: TYPE_NORMAL
- en: ; } = null
  prefs: []
  type: TYPE_NORMAL
- en: '!;'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: '? Description { get'
  prefs: []
  type: TYPE_NORMAL
- en: ; set
  prefs: []
  type: TYPE_NORMAL
- en: ; }
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the class file named `Product.cs` , as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: System.ComponentModel.DataAnnotations;
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: System.ComponentModel.DataAnnotations.Schema;
  prefs: []
  type: TYPE_NORMAL
- en: namespace
  prefs: []
  type: TYPE_NORMAL
- en: Packt.Shared
  prefs: []
  type: TYPE_NORMAL
- en: ;
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: class
  prefs: []
  type: TYPE_NORMAL
- en: Product
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: int
  prefs: []
  type: TYPE_NORMAL
- en: ProductId { get
  prefs: []
  type: TYPE_NORMAL
- en: ; set
  prefs: []
  type: TYPE_NORMAL
- en: ; }
  prefs: []
  type: TYPE_NORMAL
- en: '[Required'
  prefs: []
  type: TYPE_NORMAL
- en: ']'
  prefs: []
  type: TYPE_NORMAL
- en: '[StringLength(40)'
  prefs: []
  type: TYPE_NORMAL
- en: ']'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: ProductName { get
  prefs: []
  type: TYPE_NORMAL
- en: ; set
  prefs: []
  type: TYPE_NORMAL
- en: ; } = null
  prefs: []
  type: TYPE_NORMAL
- en: '!;'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: int
  prefs: []
  type: TYPE_NORMAL
- en: '? SupplierId { get'
  prefs: []
  type: TYPE_NORMAL
- en: ; set
  prefs: []
  type: TYPE_NORMAL
- en: ; }
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: int
  prefs: []
  type: TYPE_NORMAL
- en: '? CategoryId { get'
  prefs: []
  type: TYPE_NORMAL
- en: ; set
  prefs: []
  type: TYPE_NORMAL
- en: ; }
  prefs: []
  type: TYPE_NORMAL
- en: '[StringLength(20)'
  prefs: []
  type: TYPE_NORMAL
- en: ']'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: '? QuantityPerUnit { get'
  prefs: []
  type: TYPE_NORMAL
- en: ; set
  prefs: []
  type: TYPE_NORMAL
- en: ; }
  prefs: []
  type: TYPE_NORMAL
- en: '[Column(TypeName ='
  prefs: []
  type: TYPE_NORMAL
- en: '"money"'
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '] // required for SQL Server provider'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: decimal
  prefs: []
  type: TYPE_NORMAL
- en: '? UnitPrice { get'
  prefs: []
  type: TYPE_NORMAL
- en: ; set
  prefs: []
  type: TYPE_NORMAL
- en: ; }
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: short
  prefs: []
  type: TYPE_NORMAL
- en: '? UnitsInStock { get'
  prefs: []
  type: TYPE_NORMAL
- en: ; set
  prefs: []
  type: TYPE_NORMAL
- en: ; }
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: short
  prefs: []
  type: TYPE_NORMAL
- en: '? UnitsOnOrder { get'
  prefs: []
  type: TYPE_NORMAL
- en: ; set
  prefs: []
  type: TYPE_NORMAL
- en: ; }
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: short
  prefs: []
  type: TYPE_NORMAL
- en: '? ReorderLevel { get'
  prefs: []
  type: TYPE_NORMAL
- en: ; set
  prefs: []
  type: TYPE_NORMAL
- en: ; }
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: bool
  prefs: []
  type: TYPE_NORMAL
- en: Discontinued { get
  prefs: []
  type: TYPE_NORMAL
- en: ; set
  prefs: []
  type: TYPE_NORMAL
- en: ; }
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Build the project and fix any compiler errors.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you are using Visual Studio 2022 for Windows, then the compiled application
    executes in the `LinqWithEFCore\bin\Debug\net6.0` folder so it will not find the
    database file unless we indicate that it should always be copied to the output
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: In **Solution Explorer** , right-click the `Northwind.db` file and select **Properties**
    .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In **Properties** , set **Copy to Output Directory** to **Copy always** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Filtering and sorting sequences
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now let''s write statements to filter and sort sequences of rows from the tables:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs` , statically import the `Console` type and namespaces for working
    with EF Core and your entity model using LINQ, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: Packt.Shared; // Northwind, Category, Product
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft.EntityFrameworkCore; // DbSet<T>
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: static
  prefs: []
  type: TYPE_NORMAL
- en: System.Console;
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the bottom of `Program.cs` , write a method to filter and sort products,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: static
  prefs: []
  type: TYPE_NORMAL
- en: void
  prefs: []
  type: TYPE_NORMAL
- en: FilterAndSort
  prefs: []
  type: TYPE_NORMAL
- en: ()
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: (Northwind db = new
  prefs: []
  type: TYPE_NORMAL
- en: ())
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: DbSet<Product> allProducts = db.Products;
  prefs: []
  type: TYPE_NORMAL
- en: IQueryable<Product> filteredProducts =
  prefs: []
  type: TYPE_NORMAL
- en: allProducts.Where(product => product.UnitPrice < 10
  prefs: []
  type: TYPE_NORMAL
- en: M);
  prefs: []
  type: TYPE_NORMAL
- en: IOrderedQueryable<Product> sortedAndFilteredProducts =
  prefs: []
  type: TYPE_NORMAL
- en: filteredProducts.OrderByDescending(product => product.UnitPrice);
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("Products that cost less than $10:"
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: foreach
  prefs: []
  type: TYPE_NORMAL
- en: (Product p in
  prefs: []
  type: TYPE_NORMAL
- en: sortedAndFilteredProducts)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: 'WriteLine("{0}: {1} costs {2:$#,##0.00}"'
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: p.ProductId, p.ProductName, p.UnitPrice);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: '`DbSet<T>` implements `IEnumerable<T>` , so LINQ can be used to query and manipulate
    collections of entities in models built for EF Core. (Actually, I should say `TEntity`
    instead of `T` but the name of this generic type has no functional effect. The
    only requirement is that the type is a `class` . The name just indicates the class
    is expected to be an entity model.)'
  prefs: []
  type: TYPE_NORMAL
- en: You might have also noticed that the sequences implement `IQueryable<T>` (or
    `IOrderedQueryable<T>` after a call to an ordering LINQ method) instead of `IEnumerable<T>`
    or `IOrderedEnumerable<T>` .
  prefs: []
  type: TYPE_NORMAL
- en: This is an indication that we are using a LINQ provider that builds the query
    in memory using expression trees. They represent code in a tree-like data structure
    and enable the creation of dynamic queries, which is useful for building LINQ
    queries for external data providers like SQLite.
  prefs: []
  type: TYPE_NORMAL
- en: The LINQ expression will be converted into another query language, such as SQL.
    Enumerating the query with `foreach` or calling a method such as `ToArray` will
    force the execution of the query and materialize the results.
  prefs: []
  type: TYPE_NORMAL
- en: After the namespace imports in `Program.cs` , call the `FilterAndSort` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: 'Products that cost less than $10:'
  prefs: []
  type: TYPE_NORMAL
- en: '41: Jack''s New England Clam Chowder costs $9.65'
  prefs: []
  type: TYPE_NORMAL
- en: '45: Rogede sild costs $9.50'
  prefs: []
  type: TYPE_NORMAL
- en: '47: Zaanse koeken costs $9.50'
  prefs: []
  type: TYPE_NORMAL
- en: '19: Teatime Chocolate Biscuits costs $9.20'
  prefs: []
  type: TYPE_NORMAL
- en: '23: TunnbrÃ¶d costs $9.00'
  prefs: []
  type: TYPE_NORMAL
- en: '75: RhÃ¶nbrÃ¤u Klosterbier costs $7.75'
  prefs: []
  type: TYPE_NORMAL
- en: '54: TourtiÃ¨re costs $7.45'
  prefs: []
  type: TYPE_NORMAL
- en: '52: Filo Mix costs $7.00'
  prefs: []
  type: TYPE_NORMAL
- en: '13: Konbu costs $6.00'
  prefs: []
  type: TYPE_NORMAL
- en: '24: GuaranÃ¡ FantÃ¡stica costs $4.50'
  prefs: []
  type: TYPE_NORMAL
- en: '33: Geitost costs $2.50'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Although this query outputs the information we want, it does so inefficiently
    because it gets all columns from the `Products` table instead of just the three
    columns we need, which is the equivalent of the following SQL statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: SELECT * FROM Products;
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: In *Chapter 10* , *Working with Data Using Entity Framework Core* , you learned
    how to log the SQL commands executed against SQLite so that you could see this
    for yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Projecting sequences into new types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we look at projection, we need to review object initialization syntax.
    If you have a class defined, then you can instantiate an object using the class
    name, `new()` , and curly braces to set initial values for fields and properties,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: public class
  prefs: []
  type: TYPE_NORMAL
- en: Person
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: Name { get
  prefs: []
  type: TYPE_NORMAL
- en: ; set
  prefs: []
  type: TYPE_NORMAL
- en: ; }
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: DateTime DateOfBirth { get
  prefs: []
  type: TYPE_NORMAL
- en: ; set
  prefs: []
  type: TYPE_NORMAL
- en: ; }
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: Person knownTypeObject = new
  prefs: []
  type: TYPE_NORMAL
- en: ()
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: Name = "Boris Johnson"
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: DateOfBirth = new
  prefs: []
  type: TYPE_NORMAL
- en: '(year: 1964'
  prefs: []
  type: TYPE_NORMAL
- en: ', month: 6'
  prefs: []
  type: TYPE_NORMAL
- en: ', day: 19'
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'C# 3.0 and later allow instances of **anonymous types** to be instantiated
    using the `var` keyword, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: var
  prefs: []
  type: TYPE_NORMAL
- en: anonymouslyTypedObject = new
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: Name = "Boris Johnson"
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: DateOfBirth = new
  prefs: []
  type: TYPE_NORMAL
- en: 'DateTime(year: 1964'
  prefs: []
  type: TYPE_NORMAL
- en: ', month: 6'
  prefs: []
  type: TYPE_NORMAL
- en: ', day: 19'
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Although we did not specify a type, the compiler can infer an anonymous type
    from the setting of two properties named `Name` and `DateOfBirth` . The compiler
    can infer the types of the two properties from the values assigned: a literal
    `string` and a new instance of a date/time value.'
  prefs: []
  type: TYPE_NORMAL
- en: This capability is especially useful when writing LINQ queries to project an
    existing type into a new type without having to explicitly define the new type.
    Since the type is anonymous, this can only work with `var` -declared local variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s make the SQL command executed against the database table more efficient
    by adding a call to the `Select` method to project instances of the `Product`
    class into instances of a new anonymous type with only three properties:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `FilterAndSort` , add a statement to extend the LINQ query to use the `Select`
    method to return only the three properties (that is, table columns) that we need,
    and modify the `foreach` statement to use the `var` keyword and the projection
    LINQ expression, as shown highlighted in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: IOrderedQueryable<Product> sortedAndFilteredProducts =
  prefs: []
  type: TYPE_NORMAL
- en: filteredProducts.OrderByDescending(product => product.UnitPrice);
  prefs: []
  type: TYPE_NORMAL
- en: '**var**'
  prefs: []
  type: TYPE_NORMAL
- en: '**projectedProducts = sortedAndFilteredProducts**'
  prefs: []
  type: TYPE_NORMAL
- en: '**.Select(product =>**'
  prefs: []
  type: TYPE_NORMAL
- en: '**new**'
  prefs: []
  type: TYPE_NORMAL
- en: '**// anonymous type**'
  prefs: []
  type: TYPE_NORMAL
- en: '**{**'
  prefs: []
  type: TYPE_NORMAL
- en: '**product.ProductId,**'
  prefs: []
  type: TYPE_NORMAL
- en: '**product.ProductName,**'
  prefs: []
  type: TYPE_NORMAL
- en: '**product.UnitPrice**'
  prefs: []
  type: TYPE_NORMAL
- en: '**});**'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("Products that cost less than $10:"
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: foreach
  prefs: []
  type: TYPE_NORMAL
- en: (
  prefs: []
  type: TYPE_NORMAL
- en: '**var**'
  prefs: []
  type: TYPE_NORMAL
- en: '**p**'
  prefs: []
  type: TYPE_NORMAL
- en: '**in**'
  prefs: []
  type: TYPE_NORMAL
- en: '**projectedProducts**'
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Hover your mouse over the `new` keyword in the `Select` method call and the
    `var` keyword in the `foreach` statement and note that it is an anonymous type,
    as shown in *Figure 11.4* :![](img/Image00098.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 11.4: An anonymous type used during LINQ projection'
  prefs: []
  type: TYPE_NORMAL
- en: Run the code and confirm that the output is the same as before.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Joining and grouping sequences
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two extension methods for joining and grouping:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Join** : This method has four parameters: the sequence that you want to join
    with, the property or properties on the *left* sequence to match on, the property
    or properties on the *right* sequence to match on, and a projection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GroupJoin** : This method has the same parameters, but it combines the matches
    into a group object with a `Key` property for the matching value and an `IEnumerable<T>`
    type for the multiple matches.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Joining sequences
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s explore these methods when working with two tables: `Categories` and
    `Products` :'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the bottom of `Program.cs` , create a method to select categories and products,
    join them, and output them, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: static
  prefs: []
  type: TYPE_NORMAL
- en: void
  prefs: []
  type: TYPE_NORMAL
- en: JoinCategoriesAndProducts
  prefs: []
  type: TYPE_NORMAL
- en: ()
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: (Northwind db = new
  prefs: []
  type: TYPE_NORMAL
- en: ())
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: // join every product to its category to return 77 matches
  prefs: []
  type: TYPE_NORMAL
- en: var
  prefs: []
  type: TYPE_NORMAL
- en: queryJoin = db.Categories.Join(
  prefs: []
  type: TYPE_NORMAL
- en: 'inner: db.Products,'
  prefs: []
  type: TYPE_NORMAL
- en: 'outerKeySelector: category => category.CategoryId,'
  prefs: []
  type: TYPE_NORMAL
- en: 'innerKeySelector: product => product.CategoryId,'
  prefs: []
  type: TYPE_NORMAL
- en: 'resultSelector: (c, p) =>'
  prefs: []
  type: TYPE_NORMAL
- en: new
  prefs: []
  type: TYPE_NORMAL
- en: '{ c.CategoryName, p.ProductName, p.ProductId });'
  prefs: []
  type: TYPE_NORMAL
- en: foreach
  prefs: []
  type: TYPE_NORMAL
- en: (var
  prefs: []
  type: TYPE_NORMAL
- en: item in
  prefs: []
  type: TYPE_NORMAL
- en: queryJoin)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: 'WriteLine("{0}: {1} is in {2}."'
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: 'arg0: item.ProductId,'
  prefs: []
  type: TYPE_NORMAL
- en: 'arg1: item.ProductName,'
  prefs: []
  type: TYPE_NORMAL
- en: 'arg2: item.CategoryName);'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: In a join, there are two sequences, *outer* and *inner* . In the previous example,
    `categories` is the outer sequence and `products` is the inner sequence.
  prefs: []
  type: TYPE_NORMAL
- en: At the top of `Program.cs` , comment out the call to `FilterAndSort` and call
    `JoinCategoriesAndProducts` .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the code and view the results. Note that there is a single line of output
    for each of the 77 products, as shown in the following output (edited to only
    include the first 10 items):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: '1: Chai is in Beverages.'
  prefs: []
  type: TYPE_NORMAL
- en: '2: Chang is in Beverages.'
  prefs: []
  type: TYPE_NORMAL
- en: '3: Aniseed Syrup is in Condiments.'
  prefs: []
  type: TYPE_NORMAL
- en: '4: Chef Anton''s Cajun Seasoning is in Condiments.'
  prefs: []
  type: TYPE_NORMAL
- en: '5: Chef Anton''s Gumbo Mix is in Condiments.'
  prefs: []
  type: TYPE_NORMAL
- en: '6: Grandma''s Boysenberry Spread is in Condiments.'
  prefs: []
  type: TYPE_NORMAL
- en: '7: Uncle Bob''s Organic Dried Pears is in Produce.'
  prefs: []
  type: TYPE_NORMAL
- en: '8: Northwoods Cranberry Sauce is in Condiments.'
  prefs: []
  type: TYPE_NORMAL
- en: '9: Mishi Kobe Niku is in Meat/Poultry.'
  prefs: []
  type: TYPE_NORMAL
- en: '10: Ikura is in Seafood.'
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end of the existing query, call the `OrderBy` method to sort by `CategoryName`
    , as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: .OrderBy(cp => cp.CategoryName);
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code and view the results. Note that there is a single line of output
    for each of the 77 products, and the results show all products in the `Beverages`
    category first, then the `Condiments` category, and so on, as shown in the following
    partial output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: '1: Chai is in Beverages.'
  prefs: []
  type: TYPE_NORMAL
- en: '2: Chang is in Beverages.'
  prefs: []
  type: TYPE_NORMAL
- en: '24: GuaranÃ¡ FantÃ¡stica is in Beverages.'
  prefs: []
  type: TYPE_NORMAL
- en: '34: Sasquatch Ale is in Beverages.'
  prefs: []
  type: TYPE_NORMAL
- en: '35: Steeleye Stout is in Beverages.'
  prefs: []
  type: TYPE_NORMAL
- en: '38: CÃ´te de Blaye is in Beverages.'
  prefs: []
  type: TYPE_NORMAL
- en: '39: Chartreuse verte is in Beverages.'
  prefs: []
  type: TYPE_NORMAL
- en: '43: Ipoh Coffee is in Beverages.'
  prefs: []
  type: TYPE_NORMAL
- en: '67: Laughing Lumberjack Lager is in Beverages.'
  prefs: []
  type: TYPE_NORMAL
- en: '70: Outback Lager is in Beverages.'
  prefs: []
  type: TYPE_NORMAL
- en: '75: RhÃ¶nbrÃ¤u Klosterbier is in Beverages.'
  prefs: []
  type: TYPE_NORMAL
- en: '76: LakkalikÃ¶Ã¶ri is in Beverages.'
  prefs: []
  type: TYPE_NORMAL
- en: '3: Aniseed Syrup is in Condiments.'
  prefs: []
  type: TYPE_NORMAL
- en: '4: Chef Anton''s Cajun Seasoning is in Condiments.'
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Group-joining sequences
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'At the bottom of `Program.cs` , create a method to group and join, show the
    group name, and then show all the items within each group, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: static
  prefs: []
  type: TYPE_NORMAL
- en: void
  prefs: []
  type: TYPE_NORMAL
- en: GroupJoinCategoriesAndProducts
  prefs: []
  type: TYPE_NORMAL
- en: ()
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: (Northwind db = new
  prefs: []
  type: TYPE_NORMAL
- en: ())
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: // group all products by their category to return 8 matches
  prefs: []
  type: TYPE_NORMAL
- en: var
  prefs: []
  type: TYPE_NORMAL
- en: queryGroup = db.Categories.AsEnumerable().GroupJoin(
  prefs: []
  type: TYPE_NORMAL
- en: 'inner: db.Products,'
  prefs: []
  type: TYPE_NORMAL
- en: 'outerKeySelector: category => category.CategoryId,'
  prefs: []
  type: TYPE_NORMAL
- en: 'innerKeySelector: product => product.CategoryId,'
  prefs: []
  type: TYPE_NORMAL
- en: 'resultSelector: (c, matchingProducts) => new'
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: c.CategoryName,
  prefs: []
  type: TYPE_NORMAL
- en: Products = matchingProducts.OrderBy(p => p.ProductName)
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  prefs: []
  type: TYPE_NORMAL
- en: foreach
  prefs: []
  type: TYPE_NORMAL
- en: (var
  prefs: []
  type: TYPE_NORMAL
- en: category in
  prefs: []
  type: TYPE_NORMAL
- en: queryGroup)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("{0} has {1} products."
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: 'arg0: category.CategoryName,'
  prefs: []
  type: TYPE_NORMAL
- en: 'arg1: category.Products.Count());'
  prefs: []
  type: TYPE_NORMAL
- en: foreach
  prefs: []
  type: TYPE_NORMAL
- en: (var
  prefs: []
  type: TYPE_NORMAL
- en: product in
  prefs: []
  type: TYPE_NORMAL
- en: category.Products)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine($"
  prefs: []
  type: TYPE_NORMAL
- en: '{product.ProductName}'
  prefs: []
  type: TYPE_NORMAL
- en: '"'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we had not called the `AsEnumerable` method, then a runtime exception would
    have been thrown, as shown in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: 'Unhandled exception. System.ArgumentException:  Argument type ''System.Linq.IOrderedQueryable`1[Packt.Shared.Product]''
    does not match the corresponding member type ''System.Linq.IOrderedEnumerable`1[Packt.Shared.Product]''
    (Parameter ''arguments[1]'')'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: This is because not all LINQ extension methods can be converted from expression
    trees into some other query syntax like SQL. In these cases, we can convert from
    `IQueryable<T>` to `IEnumerable<T>` by calling the `AsEnumerable` method, which
    forces query processing to use LINQ to EF Core only to bring the data into the
    application and then use LINQ to Objects to execute more complex processing in
    memory. But, often, this is less efficient.
  prefs: []
  type: TYPE_NORMAL
- en: At the top of `Program.cs` , comment out the previous method call and call `GroupJoinCategoriesAndProducts`
    .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the code, view the results, and note that the products inside each category
    have been sorted by their name, as defined in the query and as shown in the following
    partial output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: Beverages has 12 products.
  prefs: []
  type: TYPE_NORMAL
- en: Chai
  prefs: []
  type: TYPE_NORMAL
- en: Chang
  prefs: []
  type: TYPE_NORMAL
- en: Chartreuse verte
  prefs: []
  type: TYPE_NORMAL
- en: CÃ´te de Blaye
  prefs: []
  type: TYPE_NORMAL
- en: GuaranÃ¡ FantÃ¡stica
  prefs: []
  type: TYPE_NORMAL
- en: Ipoh Coffee
  prefs: []
  type: TYPE_NORMAL
- en: LakkalikÃ¶Ã¶ri
  prefs: []
  type: TYPE_NORMAL
- en: Laughing Lumberjack Lager
  prefs: []
  type: TYPE_NORMAL
- en: Outback Lager
  prefs: []
  type: TYPE_NORMAL
- en: RhÃ¶nbrÃ¤u Klosterbier
  prefs: []
  type: TYPE_NORMAL
- en: Sasquatch Ale
  prefs: []
  type: TYPE_NORMAL
- en: Steeleye Stout
  prefs: []
  type: TYPE_NORMAL
- en: Condiments has 12 products.
  prefs: []
  type: TYPE_NORMAL
- en: Aniseed Syrup
  prefs: []
  type: TYPE_NORMAL
- en: Chef Anton's Cajun Seasoning
  prefs: []
  type: TYPE_NORMAL
- en: Chef Anton's Gumbo Mix
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Aggregating sequences
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are LINQ extension methods to perform aggregation functions, such as
    `Average` and `Sum` . Let''s write some code to see some of these methods in action
    aggregating information from the `Products` table:'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the bottom of `Program.cs` , create a method to show the use of the aggregation
    extension methods, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: static
  prefs: []
  type: TYPE_NORMAL
- en: void
  prefs: []
  type: TYPE_NORMAL
- en: AggregateProducts
  prefs: []
  type: TYPE_NORMAL
- en: ()
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: (Northwind db = new
  prefs: []
  type: TYPE_NORMAL
- en: ())
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("{0,-25} {1,10}"
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: 'arg0: "Product count:"'
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: 'arg1: db.Products.Count());'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("{0,-25} {1,10:$#,##0.00}"
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: 'arg0: "Highest product price:"'
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: 'arg1: db.Products.Max(p => p.UnitPrice));'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("{0,-25} {1,10:N0}"
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: 'arg0: "Sum of units in stock:"'
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: 'arg1: db.Products.Sum(p => p.UnitsInStock));'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("{0,-25} {1,10:N0}"
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: 'arg0: "Sum of units on order:"'
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: 'arg1: db.Products.Sum(p => p.UnitsOnOrder));'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("{0,-25} {1,10:$#,##0.00}"
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: 'arg0: "Average unit price:"'
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: 'arg1: db.Products.Average(p => p.UnitPrice));'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("{0,-25} {1,10:$#,##0.00}"
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: 'arg0: "Value of units in stock:"'
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: 'arg1: db.Products'
  prefs: []
  type: TYPE_NORMAL
- en: .Sum(p => p.UnitPrice * p.UnitsInStock));
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: At the top of `Program.cs` , comment out the previous method and call `AggregateProducts`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: 'Product count:                    77'
  prefs: []
  type: TYPE_NORMAL
- en: 'Highest product price:       $263.50'
  prefs: []
  type: TYPE_NORMAL
- en: 'Sum of units in stock:         3,119'
  prefs: []
  type: TYPE_NORMAL
- en: 'Sum of units on order:           780'
  prefs: []
  type: TYPE_NORMAL
- en: 'Average unit price:           $28.87'
  prefs: []
  type: TYPE_NORMAL
- en: 'Value of units in stock:  $74,050.85'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Sweetening LINQ syntax with syntactic sugar
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C# 3.0 introduced some new language keywords in 2008 to make it easier for programmers
    with experience with SQL to write LINQ queries. This syntactic sugar is sometimes
    called the **LINQ query comprehension syntax** .
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following array of `string` values:'
  prefs: []
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: '[] names = new'
  prefs: []
  type: TYPE_NORMAL
- en: '[] { "Michael"'
  prefs: []
  type: TYPE_NORMAL
- en: ', "Pam"'
  prefs: []
  type: TYPE_NORMAL
- en: ', "Jim"'
  prefs: []
  type: TYPE_NORMAL
- en: ', "Dwight"'
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: '"Angela"'
  prefs: []
  type: TYPE_NORMAL
- en: ', "Kevin"'
  prefs: []
  type: TYPE_NORMAL
- en: ', "Toby"'
  prefs: []
  type: TYPE_NORMAL
- en: ', "Creed"'
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'To filter and sort the names, you could use extension methods and lambda expressions,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: var
  prefs: []
  type: TYPE_NORMAL
- en: query = names
  prefs: []
  type: TYPE_NORMAL
- en: .Where(name => name.Length > 4
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: .OrderBy(name => name.Length)
  prefs: []
  type: TYPE_NORMAL
- en: .ThenBy(name => name);
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Or you could achieve the same results by using query comprehension syntax,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: var
  prefs: []
  type: TYPE_NORMAL
- en: query = from
  prefs: []
  type: TYPE_NORMAL
- en: name in
  prefs: []
  type: TYPE_NORMAL
- en: names
  prefs: []
  type: TYPE_NORMAL
- en: where
  prefs: []
  type: TYPE_NORMAL
- en: name.Length > 4
  prefs: []
  type: TYPE_NORMAL
- en: orderby
  prefs: []
  type: TYPE_NORMAL
- en: name.Length, name
  prefs: []
  type: TYPE_NORMAL
- en: select
  prefs: []
  type: TYPE_NORMAL
- en: name;
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: The compiler changes the query comprehension syntax to the equivalent extension
    methods and lambda expressions for you.
  prefs: []
  type: TYPE_NORMAL
- en: The `select` keyword is always required for LINQ query comprehension syntax.
    The `Select` extension method is optional when using extension methods and lambda
    expressions because if you do not call `Select` , then the whole item is implicitly
    selected.
  prefs: []
  type: TYPE_NORMAL
- en: Not all extension methods have a C# keyword equivalent, for example, the `Skip`
    and `Take` extension methods, which are commonly used to implement paging for
    lots of data.
  prefs: []
  type: TYPE_NORMAL
- en: 'A query that skips and takes cannot be written using only the query comprehension
    syntax, so we could write the query using all extension methods, as shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: var
  prefs: []
  type: TYPE_NORMAL
- en: query = names
  prefs: []
  type: TYPE_NORMAL
- en: .Where(name => name.Length > 4
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: .Skip(80
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: .Take(10
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Or you can wrap query comprehension syntax in parentheses and then switch to
    using extension methods, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: var
  prefs: []
  type: TYPE_NORMAL
- en: query = (from
  prefs: []
  type: TYPE_NORMAL
- en: name in
  prefs: []
  type: TYPE_NORMAL
- en: names
  prefs: []
  type: TYPE_NORMAL
- en: where
  prefs: []
  type: TYPE_NORMAL
- en: name.Length > 4
  prefs: []
  type: TYPE_NORMAL
- en: select
  prefs: []
  type: TYPE_NORMAL
- en: name)
  prefs: []
  type: TYPE_NORMAL
- en: .Skip(80
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: .Take(10
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice** : Learn both extension methods with lambda expressions and
    the query comprehension syntax ways of writing LINQ queries, because you are likely
    to have to maintain code that uses both.'
  prefs: []
  type: TYPE_NORMAL
- en: Using multiple threads with parallel LINQ
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By default, only one thread is used to execute a LINQ query. **Parallel LINQ**
    (**PLINQ** ) is an easy way to enable multiple threads to execute a LINQ query.
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice** : Do not assume that using parallel threads will improve
    the performance of your applications. Always measure real-world timings and resource
    usage.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating an app that benefits from multiple threads
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To see it in action, we will start with some code that only uses a single thread
    to calculate Fibonacci numbers for 45 integers. We will use the `StopWatch` type
    to measure the change in performance.
  prefs: []
  type: TYPE_NORMAL
- en: We will use operating system tools to monitor the CPU and CPU core usage. If
    you do not have multiple CPUs or at least multiple cores, then this exercise won't
    show much!
  prefs: []
  type: TYPE_NORMAL
- en: Use your preferred code editor to add a new console app named `LinqInParallel`
    to the `Chapter11` solution/workspace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Visual Studio Code, select `LinqInParallel` as the active OmniSharp project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `Program.cs` , delete the existing statements and then import the `System.Diagnostics`
    namespace so that we can use the `StopWatch` type, and statically import the `System.Console`
    type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add statements to create a stopwatch to record timings, wait for a keypress
    before starting the timer, create 45 integers, calculate the last Fibonacci number
    for each of them, stop the timer, and display the elapsed milliseconds, as shown
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: Stopwatch watch = new
  prefs: []
  type: TYPE_NORMAL
- en: ();
  prefs: []
  type: TYPE_NORMAL
- en: Write("Press ENTER to start. "
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: ReadLine();
  prefs: []
  type: TYPE_NORMAL
- en: watch.Start();
  prefs: []
  type: TYPE_NORMAL
- en: int
  prefs: []
  type: TYPE_NORMAL
- en: max = 45
  prefs: []
  type: TYPE_NORMAL
- en: ;
  prefs: []
  type: TYPE_NORMAL
- en: IEnumerable<int
  prefs: []
  type: TYPE_NORMAL
- en: 'numbers = Enumerable.Range(start: 1'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ', count: max);'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine($"Calculating Fibonacci sequence up to
  prefs: []
  type: TYPE_NORMAL
- en: '{max}'
  prefs: []
  type: TYPE_NORMAL
- en: . Please wait..."
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: int
  prefs: []
  type: TYPE_NORMAL
- en: '[] fibonacciNumbers = numbers'
  prefs: []
  type: TYPE_NORMAL
- en: .Select(number => Fibonacci(number)).ToArray();
  prefs: []
  type: TYPE_NORMAL
- en: watch.Stop();
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("{0:#,##0} elapsed milliseconds."
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: 'arg0: watch.ElapsedMilliseconds);'
  prefs: []
  type: TYPE_NORMAL
- en: Write("Results:"
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: foreach
  prefs: []
  type: TYPE_NORMAL
- en: (int
  prefs: []
  type: TYPE_NORMAL
- en: number in
  prefs: []
  type: TYPE_NORMAL
- en: fibonacciNumbers)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: Write($"
  prefs: []
  type: TYPE_NORMAL
- en: '{number}'
  prefs: []
  type: TYPE_NORMAL
- en: '"'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: static
  prefs: []
  type: TYPE_NORMAL
- en: int
  prefs: []
  type: TYPE_NORMAL
- en: Fibonacci
  prefs: []
  type: TYPE_NORMAL
- en: (
  prefs: []
  type: TYPE_NORMAL
- en: int
  prefs: []
  type: TYPE_NORMAL
- en: term
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: =>
  prefs: []
  type: TYPE_NORMAL
- en: term switch
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: => 0
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: '2'
  prefs: []
  type: TYPE_NORMAL
- en: => 1
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: _ => Fibonacci(term - 1
  prefs: []
  type: TYPE_NORMAL
- en: ) + Fibonacci(term - 2
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Run the code, but do not press Enter to start the stopwatch yet because we need
    to make sure a monitoring tool is showing processor activity.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using Windows
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are using Windows, then right-click on the Windows **Start** button or
    press Ctrl + Alt + Delete , and then click on **Task Manager** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the bottom of the **Task Manager** window, click **More details** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the top of the **Task Manager** window, click on the **Performance** tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the **CPU Utilization** graph, select **Change graph to** , and
    then select **Logical processors** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using macOS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are using macOS, then launch **Activity Monitor** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to **View** | **Update Frequency Very often (1 sec)** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To see the CPU graphs, navigate to **Window** | **CPU History** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For all operating systems
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Rearrange your monitoring tool and your code editor so that they are side by
    side.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Wait for the CPUs to settle and then press Enter to start the stopwatch and
    run the query. The result should be a number of elapsed milliseconds, as shown
    in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: Press ENTER to start.
  prefs: []
  type: TYPE_NORMAL
- en: Calculating Fibonacci sequence up to 45\. Please wait...
  prefs: []
  type: TYPE_NORMAL
- en: 17,624 elapsed milliseconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'Results: 0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765
    10946 17711 28657 46368 75025 121393 196418 317811 514229 832040 1346269 2178309
    3524578 5702887 9227465 14930352 24157817 39088169 63245986 102334155 165580141
    267914296 433494437 701408733'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: The monitoring tool will probably show that one or two CPUs were used the most,
    alternating over time. Others may execute background tasks at the same time, such
    as the garbage collector, so the other CPUs or cores won't be completely flat,
    but the work is certainly not being evenly spread among all the possible CPUs
    or cores. Also, note that some of the logical processors are maxing out at 100%.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs` , modify the query to make a call to the `AsParallel` extension
    method and to sort the resulting sequence because when processing in parallel
    the results can become misordered, as shown highlighted in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: int
  prefs: []
  type: TYPE_NORMAL
- en: '[] fibonacciNumbers = numbers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**AsParallel()**'
  prefs: []
  type: TYPE_NORMAL
- en: .Select(number => Fibonacci(number))
  prefs: []
  type: TYPE_NORMAL
- en: '**.OrderBy(number => number)**'
  prefs: []
  type: TYPE_NORMAL
- en: .ToArray();
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice** : Never call `AsParallel` at the end of a query. This does
    nothing. You must perform at least one operation after the call to `AsParallel`
    for that operation to be parallelized. .NET 6 introduces a code analyzer that
    will warn about this type of misuse.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code, wait for CPU charts in your monitoring tool to settle, and then
    press Enter to start the stopwatch and run the query. This time, the application
    should complete in less time (although it might not be as less as you might hope
    forâmanaging those multiple threads takes extra effort!):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: Press ENTER to start.
  prefs: []
  type: TYPE_NORMAL
- en: Calculating Fibonacci sequence up to 45\. Please wait...
  prefs: []
  type: TYPE_NORMAL
- en: 9,028 elapsed milliseconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'Results: 0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765
    10946 17711 28657 46368 75025 121393 196418 317811 514229 832040 1346269 2178309
    3524578 5702887 9227465 14930352 24157817 39088169 63245986 102334155 165580141
    267914296 433494437 701408733'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: The monitoring tool should show that all CPUs were used equally to execute the
    LINQ query, and note that none of the logical processors max out at 100% because
    the work is more evenly spread.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will learn more about managing multiple threads in *Chapter 12* , *Improving
    Performance and Scalability Using Multitasking* .
  prefs: []
  type: TYPE_NORMAL
- en: Creating your own LINQ extension methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In *Chapter 6* , *Implementing Interfaces and Inheriting Classes* , you learned
    how to create your own extension methods. To create LINQ extension methods, all
    you must do is extend the `IEnumerable<T>` type.
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice** : Put your own extension methods in a separate class library
    so that they can be easily deployed as their own assembly or NuGet package.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will improve the `Average` extension method as an example. A well-educated
    school child will tell you that *average* can mean one of three things:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Mean** : Sum the numbers and divide by the count.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mode** : The most common number.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Median** : The number in the middle of the numbers when ordered.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Microsoft''s implementation of the `Average` extension method calculates the
    *mean* . We might want to define our own extension methods for `Mode` and `Median`
    :'
  prefs: []
  type: TYPE_NORMAL
- en: In the `LinqWithEFCore` project, add a new class file named `MyLinqExtensions.cs`
    .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Modify the class, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: namespace
  prefs: []
  type: TYPE_NORMAL
- en: System.Linq
  prefs: []
  type: TYPE_NORMAL
- en: ; // extend Microsoft's namespace
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: static
  prefs: []
  type: TYPE_NORMAL
- en: class
  prefs: []
  type: TYPE_NORMAL
- en: MyLinqExtensions
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: // this is a chainable LINQ extension method
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: static
  prefs: []
  type: TYPE_NORMAL
- en: IEnumerable
  prefs: []
  type: TYPE_NORMAL
- en: <
  prefs: []
  type: TYPE_NORMAL
- en: T
  prefs: []
  type: TYPE_NORMAL
- en: '>'
  prefs: []
  type: TYPE_NORMAL
- en: ProcessSequence
  prefs: []
  type: TYPE_NORMAL
- en: <
  prefs: []
  type: TYPE_NORMAL
- en: T
  prefs: []
  type: TYPE_NORMAL
- en: '>('
  prefs: []
  type: TYPE_NORMAL
- en: this
  prefs: []
  type: TYPE_NORMAL
- en: IEnumerable<T> sequence
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: // you could do some processing here
  prefs: []
  type: TYPE_NORMAL
- en: return
  prefs: []
  type: TYPE_NORMAL
- en: sequence;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: static
  prefs: []
  type: TYPE_NORMAL
- en: IQueryable
  prefs: []
  type: TYPE_NORMAL
- en: <
  prefs: []
  type: TYPE_NORMAL
- en: T
  prefs: []
  type: TYPE_NORMAL
- en: '>'
  prefs: []
  type: TYPE_NORMAL
- en: ProcessSequence
  prefs: []
  type: TYPE_NORMAL
- en: <
  prefs: []
  type: TYPE_NORMAL
- en: T
  prefs: []
  type: TYPE_NORMAL
- en: '>('
  prefs: []
  type: TYPE_NORMAL
- en: this
  prefs: []
  type: TYPE_NORMAL
- en: IQueryable<T> sequence
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: // you could do some processing here
  prefs: []
  type: TYPE_NORMAL
- en: return
  prefs: []
  type: TYPE_NORMAL
- en: sequence;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: // these are scalar LINQ extension methods
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: static
  prefs: []
  type: TYPE_NORMAL
- en: int
  prefs: []
  type: TYPE_NORMAL
- en: '? Median('
  prefs: []
  type: TYPE_NORMAL
- en: this
  prefs: []
  type: TYPE_NORMAL
- en: IEnumerable<int
  prefs: []
  type: TYPE_NORMAL
- en: ?> sequence)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: var
  prefs: []
  type: TYPE_NORMAL
- en: ordered = sequence.OrderBy(item => item);
  prefs: []
  type: TYPE_NORMAL
- en: int
  prefs: []
  type: TYPE_NORMAL
- en: middlePosition = ordered.Count() / 2
  prefs: []
  type: TYPE_NORMAL
- en: ;
  prefs: []
  type: TYPE_NORMAL
- en: return
  prefs: []
  type: TYPE_NORMAL
- en: ordered.ElementAt(middlePosition);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: static
  prefs: []
  type: TYPE_NORMAL
- en: int
  prefs: []
  type: TYPE_NORMAL
- en: '? Median<T>('
  prefs: []
  type: TYPE_NORMAL
- en: this
  prefs: []
  type: TYPE_NORMAL
- en: IEnumerable<T> sequence, Func<T, int
  prefs: []
  type: TYPE_NORMAL
- en: ?> selector)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: return
  prefs: []
  type: TYPE_NORMAL
- en: sequence.Select(selector).Median();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: static
  prefs: []
  type: TYPE_NORMAL
- en: decimal
  prefs: []
  type: TYPE_NORMAL
- en: '? Median('
  prefs: []
  type: TYPE_NORMAL
- en: this
  prefs: []
  type: TYPE_NORMAL
- en: IEnumerable<decimal
  prefs: []
  type: TYPE_NORMAL
- en: ?> sequence)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: var
  prefs: []
  type: TYPE_NORMAL
- en: ordered = sequence.OrderBy(item => item);
  prefs: []
  type: TYPE_NORMAL
- en: int
  prefs: []
  type: TYPE_NORMAL
- en: middlePosition = ordered.Count() / 2
  prefs: []
  type: TYPE_NORMAL
- en: ;
  prefs: []
  type: TYPE_NORMAL
- en: return
  prefs: []
  type: TYPE_NORMAL
- en: ordered.ElementAt(middlePosition);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: static
  prefs: []
  type: TYPE_NORMAL
- en: decimal
  prefs: []
  type: TYPE_NORMAL
- en: '? Median<T>('
  prefs: []
  type: TYPE_NORMAL
- en: this
  prefs: []
  type: TYPE_NORMAL
- en: IEnumerable<T> sequence, Func<T, decimal
  prefs: []
  type: TYPE_NORMAL
- en: ?> selector)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: return
  prefs: []
  type: TYPE_NORMAL
- en: sequence.Select(selector).Median();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: static
  prefs: []
  type: TYPE_NORMAL
- en: int
  prefs: []
  type: TYPE_NORMAL
- en: '? Mode('
  prefs: []
  type: TYPE_NORMAL
- en: this
  prefs: []
  type: TYPE_NORMAL
- en: IEnumerable<int
  prefs: []
  type: TYPE_NORMAL
- en: ?> sequence)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: var
  prefs: []
  type: TYPE_NORMAL
- en: grouped = sequence.GroupBy(item => item);
  prefs: []
  type: TYPE_NORMAL
- en: var
  prefs: []
  type: TYPE_NORMAL
- en: orderedGroups = grouped.OrderByDescending(
  prefs: []
  type: TYPE_NORMAL
- en: group
  prefs: []
  type: TYPE_NORMAL
- en: => group
  prefs: []
  type: TYPE_NORMAL
- en: .Count());
  prefs: []
  type: TYPE_NORMAL
- en: return
  prefs: []
  type: TYPE_NORMAL
- en: orderedGroups.FirstOrDefault()?.Key;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: static
  prefs: []
  type: TYPE_NORMAL
- en: int
  prefs: []
  type: TYPE_NORMAL
- en: '? Mode<T>('
  prefs: []
  type: TYPE_NORMAL
- en: this
  prefs: []
  type: TYPE_NORMAL
- en: IEnumerable<T> sequence, Func<T, int
  prefs: []
  type: TYPE_NORMAL
- en: ?> selector)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: return
  prefs: []
  type: TYPE_NORMAL
- en: sequence.Select(selector)?.Mode();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: static
  prefs: []
  type: TYPE_NORMAL
- en: decimal
  prefs: []
  type: TYPE_NORMAL
- en: '? Mode('
  prefs: []
  type: TYPE_NORMAL
- en: this
  prefs: []
  type: TYPE_NORMAL
- en: IEnumerable<decimal
  prefs: []
  type: TYPE_NORMAL
- en: ?> sequence)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: var
  prefs: []
  type: TYPE_NORMAL
- en: grouped = sequence.GroupBy(item => item);
  prefs: []
  type: TYPE_NORMAL
- en: var
  prefs: []
  type: TYPE_NORMAL
- en: orderedGroups = grouped.OrderByDescending(
  prefs: []
  type: TYPE_NORMAL
- en: group
  prefs: []
  type: TYPE_NORMAL
- en: => group
  prefs: []
  type: TYPE_NORMAL
- en: .Count());
  prefs: []
  type: TYPE_NORMAL
- en: return
  prefs: []
  type: TYPE_NORMAL
- en: orderedGroups.FirstOrDefault()?.Key;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: static
  prefs: []
  type: TYPE_NORMAL
- en: decimal
  prefs: []
  type: TYPE_NORMAL
- en: '? Mode<T>('
  prefs: []
  type: TYPE_NORMAL
- en: this
  prefs: []
  type: TYPE_NORMAL
- en: IEnumerable<T> sequence, Func<T, decimal
  prefs: []
  type: TYPE_NORMAL
- en: ?> selector)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: return
  prefs: []
  type: TYPE_NORMAL
- en: sequence.Select(selector).Mode();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: If this class was in a separate class library, to use your LINQ extension methods,
    you simply need to reference the class library assembly because the `System.Linq`
    namespace is already implicitly imported.
  prefs: []
  type: TYPE_NORMAL
- en: '**Warning!** All but one of the above extension methods cannot be used with
    `IQueryable` sequences like those used by LINQ to SQLite or LINQ to SQL Server
    because we have not implemented a way to translate our code into the underlying
    query language like SQL.'
  prefs: []
  type: TYPE_NORMAL
- en: Trying the chainable extension method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First, we will try chaining the `ProcessSequence` method with other extension
    methods:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs` , in the `FilterAndSort` method, modify the LINQ query for
    `Products` to call your custom chainable extension method, as shown highlighted
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: DbSet<Product>? allProducts = db.Products;
  prefs: []
  type: TYPE_NORMAL
- en: if
  prefs: []
  type: TYPE_NORMAL
- en: (allProducts is
  prefs: []
  type: TYPE_NORMAL
- en: 'null'
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("No products found."
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: return
  prefs: []
  type: TYPE_NORMAL
- en: ;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '**IQueryable<Product> processedProducts = allProducts.ProcessSequence();**'
  prefs: []
  type: TYPE_NORMAL
- en: IQueryable<Product> filteredProducts =
  prefs: []
  type: TYPE_NORMAL
- en: '**processedProducts**'
  prefs: []
  type: TYPE_NORMAL
- en: .Where(product => product.UnitPrice < 10
  prefs: []
  type: TYPE_NORMAL
- en: M);
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: In `Program.cs` , uncomment the `FilterAndSort` method and comment out any calls
    to other methods.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the code and note that you see the same output as before because your method
    doesn't modify the sequence. But you now know how to extend a LINQ expression
    with your own functionality.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Trying the mode and median methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Second, we will try using the `Mode` and `Median` methods to calculate other
    kinds of average:'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the bottom of `Program.cs` , create a method to output the mean, median,
    and mode, for `UnitsInStock` and `UnitPrice` for products, using your custom extension
    methods and the built-in `Average` extension method, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: static
  prefs: []
  type: TYPE_NORMAL
- en: void
  prefs: []
  type: TYPE_NORMAL
- en: CustomExtensionMethods
  prefs: []
  type: TYPE_NORMAL
- en: ()
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: (Northwind db = new
  prefs: []
  type: TYPE_NORMAL
- en: ())
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: 'WriteLine("Mean units in stock: {0:N0}"'
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: db.Products.Average(p => p.UnitsInStock));
  prefs: []
  type: TYPE_NORMAL
- en: 'WriteLine("Mean unit price: {0:$#,##0.00}"'
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: db.Products.Average(p => p.UnitPrice));
  prefs: []
  type: TYPE_NORMAL
- en: 'WriteLine("Median units in stock: {0:N0}"'
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: db.Products.Median(p => p.UnitsInStock));
  prefs: []
  type: TYPE_NORMAL
- en: 'WriteLine("Median unit price: {0:$#,##0.00}"'
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: db.Products.Median(p => p.UnitPrice));
  prefs: []
  type: TYPE_NORMAL
- en: 'WriteLine("Mode units in stock: {0:N0}"'
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: db.Products.Mode(p => p.UnitsInStock));
  prefs: []
  type: TYPE_NORMAL
- en: 'WriteLine("Mode unit price: {0:$#,##0.00}"'
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: db.Products.Mode(p => p.UnitPrice));
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: In `Program.cs` , comment any previous method calls and call `CustomExtensionMethods`
    .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: 'Mean units in stock: 41'
  prefs: []
  type: TYPE_NORMAL
- en: 'Mean unit price: $28.87'
  prefs: []
  type: TYPE_NORMAL
- en: 'Median units in stock: 26'
  prefs: []
  type: TYPE_NORMAL
- en: 'Median unit price: $19.50'
  prefs: []
  type: TYPE_NORMAL
- en: 'Mode units in stock: 0'
  prefs: []
  type: TYPE_NORMAL
- en: 'Mode unit price: $18.00'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: There are four products with a unit price of $18.00\. There are five products
    with 0 units in stock.
  prefs: []
  type: TYPE_NORMAL
- en: Working with LINQ to XML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**LINQ to XML** is a LINQ provider that allows you to query and manipulate
    XML.'
  prefs: []
  type: TYPE_NORMAL
- en: Generating XML using LINQ to XML
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s create a method to convert the `Products` table into XML:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `LinqWithEFCore` project, at the top of `Program.cs` , import the `System.Xml.Linq`
    namespace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the bottom of `Program.cs` , create a method to output the products in XML
    format, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: static
  prefs: []
  type: TYPE_NORMAL
- en: void
  prefs: []
  type: TYPE_NORMAL
- en: OutputProductsAsXml
  prefs: []
  type: TYPE_NORMAL
- en: ()
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: (Northwind db = new
  prefs: []
  type: TYPE_NORMAL
- en: ())
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: Product[] productsArray = db.Products.ToArray();
  prefs: []
  type: TYPE_NORMAL
- en: XElement xml = new
  prefs: []
  type: TYPE_NORMAL
- en: ("products"
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: from
  prefs: []
  type: TYPE_NORMAL
- en: p
  prefs: []
  type: TYPE_NORMAL
- en: in
  prefs: []
  type: TYPE_NORMAL
- en: productsArray
  prefs: []
  type: TYPE_NORMAL
- en: select
  prefs: []
  type: TYPE_NORMAL
- en: new
  prefs: []
  type: TYPE_NORMAL
- en: XElement
  prefs: []
  type: TYPE_NORMAL
- en: (
  prefs: []
  type: TYPE_NORMAL
- en: '"product"'
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: new
  prefs: []
  type: TYPE_NORMAL
- en: XAttribute(
  prefs: []
  type: TYPE_NORMAL
- en: '"id"'
  prefs: []
  type: TYPE_NORMAL
- en: ',  p.ProductId'
  prefs: []
  type: TYPE_NORMAL
- en: ),
  prefs: []
  type: TYPE_NORMAL
- en: new
  prefs: []
  type: TYPE_NORMAL
- en: XAttribute
  prefs: []
  type: TYPE_NORMAL
- en: (
  prefs: []
  type: TYPE_NORMAL
- en: '"price"'
  prefs: []
  type: TYPE_NORMAL
- en: ', p.UnitPrice'
  prefs: []
  type: TYPE_NORMAL
- en: ),
  prefs: []
  type: TYPE_NORMAL
- en: new
  prefs: []
  type: TYPE_NORMAL
- en: XElement
  prefs: []
  type: TYPE_NORMAL
- en: (
  prefs: []
  type: TYPE_NORMAL
- en: '"name"'
  prefs: []
  type: TYPE_NORMAL
- en: ', p.ProductName'
  prefs: []
  type: TYPE_NORMAL
- en: )))
  prefs: []
  type: TYPE_NORMAL
- en: ;
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine(xml.ToString());
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: In `Program.cs` , comment the previous method call and call `OutputProductsAsXml`
    .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the code, view the result, and note that the structure of the XML generated
    matches the elements and attributes that the LINQ to XML statement declaratively
    described in the preceding code, as shown in the following partial output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: <products>
  prefs: []
  type: TYPE_NORMAL
- en: <product id="1" price="18">
  prefs: []
  type: TYPE_NORMAL
- en: <name>Chai</name>
  prefs: []
  type: TYPE_NORMAL
- en: </product>
  prefs: []
  type: TYPE_NORMAL
- en: <product id="2" price="19">
  prefs: []
  type: TYPE_NORMAL
- en: <name>Chang</name>
  prefs: []
  type: TYPE_NORMAL
- en: </product>
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Reading XML using LINQ to XML
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You might want to use LINQ to XML to easily query or process XML files:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `LinqWithEFCore` project, add a file named `settings.xml` .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Modify its contents, as shown in the following markup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: <?xml version="1.0" encoding="utf-8" ?>
  prefs: []
  type: TYPE_NORMAL
- en: <
  prefs: []
  type: TYPE_NORMAL
- en: appSettings
  prefs: []
  type: TYPE_NORMAL
- en: '>'
  prefs: []
  type: TYPE_NORMAL
- en: <
  prefs: []
  type: TYPE_NORMAL
- en: add
  prefs: []
  type: TYPE_NORMAL
- en: key
  prefs: []
  type: TYPE_NORMAL
- en: '='
  prefs: []
  type: TYPE_NORMAL
- en: '"color"'
  prefs: []
  type: TYPE_NORMAL
- en: value
  prefs: []
  type: TYPE_NORMAL
- en: '='
  prefs: []
  type: TYPE_NORMAL
- en: '"red"'
  prefs: []
  type: TYPE_NORMAL
- en: />
  prefs: []
  type: TYPE_NORMAL
- en: <
  prefs: []
  type: TYPE_NORMAL
- en: add
  prefs: []
  type: TYPE_NORMAL
- en: key
  prefs: []
  type: TYPE_NORMAL
- en: '='
  prefs: []
  type: TYPE_NORMAL
- en: '"size"'
  prefs: []
  type: TYPE_NORMAL
- en: value
  prefs: []
  type: TYPE_NORMAL
- en: '='
  prefs: []
  type: TYPE_NORMAL
- en: '"large"'
  prefs: []
  type: TYPE_NORMAL
- en: />
  prefs: []
  type: TYPE_NORMAL
- en: <
  prefs: []
  type: TYPE_NORMAL
- en: add
  prefs: []
  type: TYPE_NORMAL
- en: key
  prefs: []
  type: TYPE_NORMAL
- en: '='
  prefs: []
  type: TYPE_NORMAL
- en: '"price"'
  prefs: []
  type: TYPE_NORMAL
- en: value
  prefs: []
  type: TYPE_NORMAL
- en: '='
  prefs: []
  type: TYPE_NORMAL
- en: '"23.99"'
  prefs: []
  type: TYPE_NORMAL
- en: />
  prefs: []
  type: TYPE_NORMAL
- en: </
  prefs: []
  type: TYPE_NORMAL
- en: appSettings
  prefs: []
  type: TYPE_NORMAL
- en: '>'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: If you are using Visual Studio 2022 for Windows, then the compiled application
    executes in the `LinqWithEFCore\bin\Debug\net6.0` folder so it will not find the
    `settings.xml` file unless we indicate that it should always be copied to the
    output directory.
  prefs: []
  type: TYPE_NORMAL
- en: In **Solution Explorer** , right-click the `settings.xml` file and select **Properties**
    .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In **Properties** , set **Copy to Output Directory** to **Copy always** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the bottom of `Program.cs` , create a method to complete these tasks, as
    shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Load the XML file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use LINQ to XML to search for an element named `appSettings` and its descendants
    named `add` .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Project the XML into an array of an anonymous type with `Key` and `Value` properties.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Enumerate through the array to show the results:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: static
  prefs: []
  type: TYPE_NORMAL
- en: void
  prefs: []
  type: TYPE_NORMAL
- en: ProcessSettings
  prefs: []
  type: TYPE_NORMAL
- en: ()
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: XDocument doc = XDocument.Load("settings.xml"
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: var
  prefs: []
  type: TYPE_NORMAL
- en: appSettings = doc.Descendants("appSettings"
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: .Descendants("add"
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: .Select(node => new
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: Key = node.Attribute("key"
  prefs: []
  type: TYPE_NORMAL
- en: )?.Value,
  prefs: []
  type: TYPE_NORMAL
- en: Value = node.Attribute("value"
  prefs: []
  type: TYPE_NORMAL
- en: )?.Value
  prefs: []
  type: TYPE_NORMAL
- en: '}).ToArray();'
  prefs: []
  type: TYPE_NORMAL
- en: foreach
  prefs: []
  type: TYPE_NORMAL
- en: (var
  prefs: []
  type: TYPE_NORMAL
- en: item in
  prefs: []
  type: TYPE_NORMAL
- en: appSettings)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine($"
  prefs: []
  type: TYPE_NORMAL
- en: '{item.Key}'
  prefs: []
  type: TYPE_NORMAL
- en: ':'
  prefs: []
  type: TYPE_NORMAL
- en: '{item.Value}'
  prefs: []
  type: TYPE_NORMAL
- en: '"'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: In `Program.cs` , comment the previous method call and call `ProcessSettings`
    .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: 'color: red'
  prefs: []
  type: TYPE_NORMAL
- en: 'size: large'
  prefs: []
  type: TYPE_NORMAL
- en: 'price: 23.99'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Practicing and exploring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Test your knowledge and understanding by answering some questions, get some
    hands-on practice, and explore with deeper research into the topics covered in
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 11.1 â Test your knowledge
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Answer the following questions:'
  prefs: []
  type: TYPE_NORMAL
- en: What are the two required parts of LINQ?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which LINQ extension method would you use to return a subset of properties from
    a type?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which LINQ extension method would you use to filter a sequence?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: List five LINQ extension methods that perform aggregation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between the `Select` and `SelectMany` extension methods?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between `IEnumerable<T>` and `IQueryable<T>` ? And how
    do you switch between them?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does the last type parameter `T` in generic `Func` delegates like `Func<T1,
    T2, T>` represent?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the benefit of a LINQ extension method that ends with `OrDefault` ?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is query comprehension syntax optional?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you create your own LINQ extension methods?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Exercise 11.2 â Practice querying with LINQ
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the `Chapter11` solution/workspace, create a console application, named
    `Exercise02` , that prompts the user for a city and then lists the company names
    for Northwind customers in that city, as shown in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the name of a city: London'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are 6 customers in London:'
  prefs: []
  type: TYPE_NORMAL
- en: Around the Horn
  prefs: []
  type: TYPE_NORMAL
- en: B's Beverages
  prefs: []
  type: TYPE_NORMAL
- en: Consolidated Holdings
  prefs: []
  type: TYPE_NORMAL
- en: Eastern Connection
  prefs: []
  type: TYPE_NORMAL
- en: North/South
  prefs: []
  type: TYPE_NORMAL
- en: Seven Seas Imports
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, enhance the application by displaying a list of all unique cities that
    customers already reside in as a prompt to the user before they enter their preferred
    city, as shown in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: Aachen, Albuquerque, Anchorage, Ãrhus, Barcelona, Barquisimeto, Bergamo, Berlin,
    Bern, Boise, BrÃ¤cke, Brandenburg, Bruxelles, Buenos Aires, Butte, Campinas, Caracas,
    Charleroi, Cork, Cowes, Cunewalde, Elgin, Eugene, Frankfurt a.M., GenÃ¨ve, Graz,
    Helsinki, I. de Margarita, Kirkland, Kobenhavn, KÃ¶ln, Lander, Leipzig, Lille,
    Lisboa, London, LuleÃ¥, Lyon, Madrid, Mannheim, Marseille, MÃ©xico D.F., MontrÃ©al,
    MÃ¼nchen, MÃ¼nster, Nantes, Oulu, Paris, Portland, Reggio Emilia, Reims, Resende,
    Rio de Janeiro, Salzburg, San CristÃ³bal, San Francisco, Sao Paulo, Seattle, Sevilla,
    Stavern, Strasbourg, Stuttgart, Torino, Toulouse, Tsawassen, Vancouver, Versailles,
    Walla Walla, Warszawa
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 11.3 â Explore topics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the links on the following page to learn more details about the topics
    covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/markjprice/cs10dotnet6/blob/main/book-links.md#chapter-11---querying-and-manipulating-data-using-linq](https://github.com/markjprice/cs10dotnet6/blob/main/book-links.md#chapter-11---querying-and-manipulating-data-using-linq)'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to write LINQ queries to select, project, filter,
    sort, join, and group data in many different formats, including XML, which are
    tasks you will perform every day.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will use the `Task` type to improve the performance
    of your applications.
  prefs: []
  type: TYPE_NORMAL
