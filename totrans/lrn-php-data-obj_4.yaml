- en: Chapter 4. Prepared Statements
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, we have looked at the basics of PDO, and you may have
    noticed that most of its functionality resembles the traditional extensions used
    to connect to databases. The only new thing is exceptions, but even that can be
    similar to traditional error handling.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we will look at a new concept that was not present in PHP before
    PDO: prepared statements. We will see how they can further simplify our code and
    even lead to better performance. We will also look at how PDO works with BLOBs—all
    in a database-independent manner, of course.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Regarding our library management application, we will rewrite the edit/update
    functionality added in the previous chapter so as to facilitate prepared statements,
    as well as add support for book cover images, which we will keep in the database.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Prepared Statements
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **prepared statement** is a template for executing one or more SQL queries
    against the database. The idea behind prepared statements is that, with queries
    that use the same syntax but different values, it is much faster to pre-process
    the syntax once and then execute it several times using different parameters.
    Consider the following task. We have to insert the names of several new authors
    into our database. Of course, we can use command line client or the `add author`
    page we recently created, but we decide to use a PHP script.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s assume that the authors to be added are kept in a PHP array:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This is a two-dimensional array, through which we will iterate using a `foreach`
    loop so as to insert both the authors' details into the database.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you can see, we create an SQL statement on each iteration for every author
    and take care of quoting all the parameters.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: 'With prepared statements, we can construct the query just once and execute
    it any number of times by just passing different values to it. Our code would
    then look like this:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: From the above code snippet, you can see that a prepared statement is first
    *prepared* by calling the `PDO::prepare()` method. This method accepts a string
    containing an SQL command where the values that change are replaced with question
    mark characters. The call returns an object of class `PDOStatement`. Then in the
    loop we call the statement's `execute()` method rather than `PDO::query()` method.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: The `PDOStatement::execute()` method accepts an array of values, which are inserted
    into the SQL query in place of the question marks. The number and order of elements
    in that array must be same as the number and match the order of question marks
    in the query template passed to `PDO::prepare()`.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: You must have noticed that we don't use `PDO::quote()` in the code—PDO takes
    care of proper quoting of the incoming values.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Positional and Named Placeholders
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The previous example used question marks to designate the position of values
    in the prepared statement. That's why these question marks are called **positional
    placeholders**. When using them you must take care of proper order of the elements
    in the array that you are passing to the `PDOStatement::execute()` method. While
    they are quick to write, they may become a source for hard-to-track errors, especially
    when you change the query columns. To protect yourself, against this you can use
    the so-called **named placeholders**, which consist of descriptive names preceded
    by a colon, instead of question marks.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: 'With named placeholders, we can rewrite the code to insert the two authors
    in the following way:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you can see, we replaced the three question marks with named placeholders
    and then in the call to `PDOStatement::execute()` we supplied an array of key-value
    pairs where keys are the corresponding named placeholders and values are the data
    that we want to insert into the database.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: 'With named placeholders, the order of the elements in the array is not significant,
    only the association matters. For example, we could rewrite the loop as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'With positional placeholders, however, we can pass the values of the `$author`
    array to the `PDOStatement::execute()` method as long as we are sure that the
    order of its elements matches the order of the placeholders:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note how we used the `array_values()` function to get rid of the string keys
    and convert the associative array to a list.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: If we supply an array of values that do not match the number of placeholders
    in the query to `PDOStatement::execute()` or we pass an associative array to a
    statement that uses positional placeholders (or a list to a statement, which uses
    named placeholders), this will be treated as an error and an exception will be
    thrown (provided that exceptions have been enabled previously in a call to `PDO::setAttribute()`
    method).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one important thing to note about the usage of placeholders. They
    cannot be used as a part of a value that you pass to the database. This is best
    demonstrated with an example of invalid usage:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This must be rewritten as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The idea here is, not to put the placeholder inside a string in the SQL template—this
    has to be done in the call to `PDOStatement::execute()` method.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Prepared Statements and Bound Values
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The examples above used the so-called **unbound statements**. This means that
    we were supplying the values for the query in an array passed to the `PDOStatement::execute()`
    method. PDO also supports **bound statements** where you can explicitly bind an
    immediate value or a variable to a named or positional placeholder.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: 'To bind an immediate value to a statement, the `PDOStatement::bindValue()`
    method is used. This method accepts the placeholder identifier and a value. The
    placeholder identifier is the 1-based index of the question mark in the query
    for positional placeholders or the name of the named placeholder. For example,
    we could rewrite the example with positional placeholders to use bound values
    in the following way:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If you prefer named placeholders, you can write:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As you can see, in both cases we don't supply anything in the call to `PDOStatement::execute()`.
    Again, as with unbound statements, if you don't bind a value for every placeholder,
    the call to `PDOStatement::execute()` will fail, leading to an exception.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: 'PDO can also bind result set columns to PHP variables for SELECT queries. These
    variables will be modified with corresponding column values on every call to `PDOStatement::fetch()`.
    This is an alternative to fetching the result set row as an array or an object
    as discussed in [Chapter 2](ch02.html "Chapter 2. Using PHP Data Objects: First
    Steps"). Consider the following example:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This will render all the authors in the table. The variables are bound in the
    call to the `PDOStatement::bindColumn()` method, which expects the first parameter
    to be the 1-based index of the column in the result set or the column name as
    returned from the database, and the second parameter is the variable to be updated.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: Note that when using bound columns, the `PDOStatement::fetch()` method should
    be called with the `PDO::FETCH_BOUND` mode, or this should be preset with a `PDOStatement::setFetchMode(PDO::FETCH_BOUND)`
    call. Also, the call to the `PDOStatement::bindColumn()` method must be made after
    the call to `PDOStatement::execute()` method so that PDO knows how many columns
    there are in the result set.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: Let's get back to our library application now and enhance it with some prepared
    statements. Since the only pages that rely on the values supplied by the user
    are *add/edit a book* and *add/edit an author*, we will rewrite the two corresponding
    scripts, `editBook.php` and `editAuthor.php`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, we will only rewrite those bits of the code that update the database.
    For `editBook.php` these are lines 65 to 102\. I will present these lines here
    for your convenience:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As we can see, the part that constructs the query is very long. With a prepared
    statement, this code snippet can be rewritten as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We follow the same logic—if we are editing an existing book, we construct an
    `UPDATE` query. If we are adding a new book, then we have to use an `INSERT` query.
    The `$sql` variable will hold the appropriate statement template. In both cases,
    the statement has six positional placeholders, and I intentionally hard-coded
    the book ID into the `UPDATE` query so that we can create and execute the statement
    regardless of the required operation.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: After we have instantiated the statement, we wrap the call to its `execute()`
    method into a *try…catch* block as an exception that may get thrown if the ISBN
    already existed in the database. Upon successful execution of the statement we
    redirect the browser to the books listing page. If the call fails, we alert the
    user with a note that the ISBN is incorrect (or that the book already exists in
    the database).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: You can see that our code is now much shorter. Also, we don't need to quote
    the values as the prepared statement does this for us. Now you can play with this
    a bit and change the databases between MySQL and SQLite in `common.inc.php` to
    see that prepared statements work for both of them. You may also want to rewrite
    this code to use named placeholders instead of positional ones. If you do, remember
    to supply placeholder names in the array passed to the `PDOStatement::execute()`
    method.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s look at the corresponding code block in `editAuthor.php` (lines
    42 to 59):'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'As we don''t expect an exception here, the code is shorter. Now let''s rewrite
    it to use a prepared statement:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Again, depending on the required operation, we create the SQL template and assign
    it to the `$sql` variable. Then we instantiate the `PDOStatement` object and call
    its `execute` method with the author's details. As our query should never fail
    (except for an unforeseen database failure) we don't expect an exception here
    and redirect to the authors listing pages.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: Make sure that you test this code with both MySQL and SQLite.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: Working with BLOBs
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's now extend our application so that we can upload the books' cover images
    and display them. Just as with traditional database access, we will use a **BLOB
    field** in the books table for this purpose, as well as a **varchar field** to
    store the image's MIME type, which we will need to supply to the browser along
    with the image data. Also, we will need another script that will fetch the image
    data from the table and pass it to the browser. (We will reference this script
    from the`<img>` tag.).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: Traditionally, we would not care that we are inserting a BLOB column into the
    calls to `mysql_query()` or `sqlite_query()`—we would just make sure that they
    are properly quoted. With PDO, however, things are different. PDO works with BLOB
    columns with the help of streams and prepared statements.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the following example:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As you can see, we open the file to be inserted with the `fopen()` function
    for reading in the binary mode (so that we don't have problems with newline characters
    across platforms) and then bind the file handle to the statement in the call to
    the `PDOStatement::bindParam()` method specifying the `PDO::PARAM_LOB` flag (so
    that PDO understands that we have bound a file handle rather than an immediate
    value).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: In the call to the `PDOStatement::execute()` method, PDO will read the data
    from the file and pass it to the database.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are wondering why PDO works in such a way, a short explanation is that,
    if your BLOB is very large, the query may fail. Normally database servers have
    a setting that limits communication packet size. (You can compare this with `post_max_size`
    PHP setting). If you are passing relatively large string inside an SQL `INSERT`
    or `UPDATE` statement, it may exceed that packet size and the query will fail.
    With streams, PDO ensures that data is sent in smaller packets so that the query
    executes successfully.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: 'The BLOBs should also be read with streams. So to retrieve a BLOB column inserted
    in the above example, the following code could be used:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In this case, the `$blob` variable will be a stream resource that can be read
    with stream-handling functions. Here we used the `stream_get_contents()` function
    to read all the data into the `$data` variable. If we want to directly return
    the data to the browser (as we will in our application), we could employ the `fpassthru()`
    function.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: 'As of this writing (PHP version 5.2.3), the returned blob column is not a stream
    but the actual data contained in the column (string). Please refer to PHP bug
    #40913 at [http://bugs.php.net/bug.php?id=40913](http://bugs.php.net/bug.php?id=40913)
    for details. Hence the last line in the above code snippet is not required, the
    `$blob` variable will hold the actual data. The source of showCover.php file below
    treats the returned data as a string rather than a blob, so that the code works
    in current PHP version.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s begin with altering our database and adding the new columns to it:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You can also execute these queries in the SQLite command line client without
    modifications. Now, let's modify the `editBook.php` file. We will add another
    field to the existing form. This line will allow the user to upload the cover
    image and enhance the form validation to check whether the user has really uploaded
    an image (by examining the MIME type of the uploaded file).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: We will also allow the user to modify the book's details without resubmitting
    the cover image file. To achieve this, we will update the cover columns only when
    there has been a successful file upload. So our script logic will use two queries.
    The first one will update or create the book record, and the second will update
    the `coverMime` and `coverImage` columns.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: 'With this in mind, the `editBook.php` file will look like the following:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The highlighted parts are the bits that we have added or changed. Now, we need
    to validate our form and the uploaded file (on lines 60 to 73). If there is a
    successful upload, the `$uploadSuccess` boolean variable will be set to `true`,
    and we will use this value later to see whether we need to update the cover columns.
    Since we allow the upload to happen for new books too, we use the `PDO::lastInsertId()`
    method value (on line 100) to get the ID of the newly created books (otherwise
    we just use the `$books['id']` value). If the upload fails, we add a corresponding
    warning to the `$warnings` array and let the existing error logic do its job.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: 'The actual cover image update happens on lines 105 to 110, using the prepared
    statement and the stream. On our form, see how we add the `multipart/form-data`
    attribute to the form tag on line 140\. It is needed for the file uploads to work.
    Also, the form now has a new input field (lines #182-185) allowing us to select
    and upload a file. The next lines will display the current cover image (if any).
    Note that the`<img>` tag references a new file, `showCover.php`, which we will
    have to create now:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now for a new book, the form looks like this:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with BLOBs](graphics/2660_04_01.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, there is a new field allowing us to upload the cover image.
    Since a newly created book does not have any cover image, there is no current
    cover image. For a book with a cover image the page will look like the following:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with BLOBs](graphics/2660_04_02.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
- en: You can now play with the application to see how the form works without uploading
    the image. (It should preserve the old image if any.) You can also see how it
    processes files that are too large or non-image files. (It should display a warning
    above the form.) Make sure that you switch between databases so that we are database-independent.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: 'As the final touch to the cover images, we can reformat the books listing page,
    `books.php`, so that the cover images are displayed there too. I will present
    the new code here with the changed part highlighted:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The first cell will contain the image (if any). The author and title are now
    rendered in the same cell to save table width. Now the Books listing should look
    something like this:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个单元格将包含图片（如果有的话）。现在作者和标题都在同一个单元格中呈现，以节省表格宽度。现在图书列表应该看起来像这样：
- en: '![Working with BLOBs](graphics/2660_04_03.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![使用BLOBs](graphics/2660_04_03.jpg)'
- en: Summary
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'This chapter introduced us to a new concept: Prepared Statements. We have seen
    how they simplify our queries and further protect us from SQL syntax errors and
    code vulnerabilities. We also took a look at how to work with BLOBs using streams
    so that we don''t run the risk of query failures. Our application can now be used
    to upload and show cover images for the books in the database.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向我们介绍了一个新概念：准备语句。我们已经看到它们如何简化我们的查询，并进一步保护我们免受SQL语法错误和代码漏洞的影响。我们还看了如何使用流处理BLOBs，以便我们不会出现查询失败的风险。我们的应用现在可以用于上传和显示数据库中书籍的封面图片。
- en: 'In the next chapter, we shall see how to determine the number of rows in a
    result set, which is necessary to paginate long lists of items. (The most common
    example is a search engine that breaks the result list into 10 results per page.)
    Also, we will familiarize ourselves with a new concept: scrollable cursors that
    will allow us to fetch a subset of rows from a result set starting at a specified
    position.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到如何确定结果集中的行数，这对于对长列表进行分页是必要的。（最常见的例子是搜索引擎将结果列表分成每页10个结果。）此外，我们将熟悉一个新概念：可滚动的游标，它将允许我们从指定位置开始获取结果集的子集行。
