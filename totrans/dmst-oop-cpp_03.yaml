- en: '*Chapter 2*: Adding Language Necessities'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will introduce necessary non-OO features of C++ that are critical
    building blocks for C++'s object-oriented features. The features presented in
    this chapter represent topics that you will see matter-of-factly used from this
    point onward in the book. C++ is a language shrouded in areas of gray; from this
    chapter forward, you will become versed in not only language features, but in
    language nuances. The goal of this chapter will be to begin enhancing your skills
    from those of an average C++ programmer to one who is capable of operating amongst
    language subtleties successfully while creating maintainable code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The `const` qualifier
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function prototyping
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function overloading
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will understand non-OO features such as the
    `const` qualifier, function prototyping (including using default values), and
    function overloading (including how standard type conversion affects overloaded
    function choices and may create potential ambiguities). Many of these seemingly
    straightforward topics include an assortment of interesting details and nuances.
    These skills will be necessary in order to move forward with the next chapters
    in the book successfully.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Online code for full program examples can be found at the following GitHub
    URL: [https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter02](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter02).
    Each full program example can be found in the GitHub repository under the appropriate
    chapter heading (subdirectory) in a file that corresponds to the chapter number,
    followed by a dash, followed by the example number in the chapter at hand. For
    example, the first full program in [*Chapter 2*](B15702_02_Final_NM_ePub.xhtml#_idTextAnchor066),
    *Adding Language Necessities* can be found in the subdirectory `Chapter02` in
    a file named `Chp2-Ex1.cpp` under the aforementioned GitHub directory.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The CiA video for this chapter can be viewed at: [https://bit.ly/3cTYgnB](https://bit.ly/3cTYgnB).'
  prefs: []
  type: TYPE_NORMAL
- en: Using the const qualifier
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will add the `const` qualifier to variables, and discuss
    how it can be added to functions in both their input parameters and as return
    values. The `const` qualifier will be used quite liberally as we move forward
    in the C++ language. The use of `const` can enable values to be initialized, yet
    never again modified. Functions can advertise that they will not modify their
    input parameters, or that their return value may only be captured (but not modified)
    by using `const`. The `const` qualifier helps make C++ a more secure language.
    Let's take a look at `const` in action.
  prefs: []
  type: TYPE_NORMAL
- en: Const variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A `const` qualified variable is a variable that must be initialized, and may
    never be assigned a new value. It is seemingly a paradox to pair the usage of
    `const` and a variable together – `const` implies not to change, yet the concept
    of a variable is to inherently hold different values. Nonetheless, it is useful
    to have a strongly type-checked variable whose one and only value can be determined
    at run time. The keyword `const` is added to the variable declaration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider a few examples in the following program. We will break this
    program into two segments for a more targeted explanation, however, the full program
    example can be found in its entirety at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter02/Chp2-Ex1.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter02/Chp2-Ex1.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous program segment, notice how we declare a variable with the
    `const` qualifier preceding the data type. Here, `const int MAX = 50;` simply
    initializes `MAX` to `50`. `MAX` may not be modified via assignment later in the
    code. Out of convention, simple `const` qualified variables are often capitalized.
    Next, we have the definition for the function `minimum()`; notice the use of the
    ternary conditional operator `?:` in this function body. Next, let''s examine
    the body of the `main()` function as we continue with the remainder of this program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In `main()`, let''s consider the sequence of code in which we prompt the user
    to `"Enter two values: "` into variables `x` and `y`, respectively. Here, we call
    the function `minimum(x,y)` and pass as actual parameters our two values `x` and
    `y`, which were just read in using `cin` and the extraction operator `>>`. Notice
    that alongside the `const` variable declaration of `MIN`, we initialize `MIN`
    with the return value of the function call `minimum()`. It is important to note
    that setting `MIN` is bundled as a single declaration and initialization. Had
    this been broken into two lines of code – a variable declaration followed by an
    assignment – the compiler would have flagged an error. `const` variables may only
    be initialized with a value, never assigned a value after declaration.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the last sequence of code above, notice that we use `MAX` (defined in the
    earlier segment of this full program example) to define a size for the fixed-sized
    array `bigName` in the declaration: `char bigName[MAX];`. We then further use
    `MAX` in `setw(MAX)` to ensure that we do not overflow `bigName` while reading
    keyboard input with `cin` and the extraction operator `>>`. Finally, we initialize
    the variable `const int NAMELEN` with the return value of the function `strlen(bigname)`
    and print this value out using `cout`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The output to accompany the above full program example is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have seen how to `const` qualify variables, let's consider `const`
    qualification with functions.
  prefs: []
  type: TYPE_NORMAL
- en: Const qualification with functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The keyword `const` can also be used in conjunction with functions. The `const`
    qualifier can be used amongst parameters to indicate that the parameters themselves
    will not be modified. This is a useful feature -- the caller of the function will
    understand that the function will not modify input parameters qualified in this
    manner. However, because non-pointer (and non-reference) variables are passed
    "by value" to functions, as copies of the actual parameters on the stack, `const`
    qualifying these inherent copies of parameters does not serve a purpose. Hence,
    `const` qualifying parameters that are of standard data types are not necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same principle applies to return values from functions. A return value
    from a function can be `const` qualified, however, unless a pointer (or reference)
    is returned, the item passed back on the stack as the return value is a copy.
    For this reason, `const` qualifying return values are more meaningful when the
    return type is a pointer to a constant object (which we will cover in [*Chapter
    3*](B15702_03_Final_NM_ePub.xhtml#_idTextAnchor112), *Indirect Addressing: Pointers*
    and beyond). As one final use of `const`, we can utilize this keyword when we
    move onto OO details for a class to specify that a particular member function
    will not modify any data members of that class. We will look at this scenario
    in [*Chapter 5*](B15702_05_Final_NM_ePub.xhtml#_idTextAnchor199), *Exploring Classes
    in Detail*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we understand the use of the `const` qualifier for variables and have
    seen potential uses of `const` in conjunction with functions, let''s move onward
    to the next language feature in this chapter: function prototypes.'
  prefs: []
  type: TYPE_NORMAL
- en: Working with function prototypes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will examine the mechanics of function prototyping, such
    as necessary placement in files and across multiple files for greater program
    flexibility. We will also add optional names to prototype arguments, as well as
    understanding how and why we may choose to add default values to C++ prototypes.
    Function prototypes ensure C++ code is strongly type-checked.
  prefs: []
  type: TYPE_NORMAL
- en: Prior to proceeding to function prototypes, let's take a moment to review some
    necessary programming terms. A **function definition** refers to the body of code
    comprising a function. Whereas a declaration of a function (also known as a **forward
    declaration**) merely introduces a function name with its return type and argument
    types, forward declarations allow the compiler to perform strong type checking
    between the function call and its definition by instead comparing the call with
    the forward declaration. Forward declarations are useful because function definitions
    do not always appear in a file prior to a function call; sometimes, function definitions
    appear in a separate file from their calls.
  prefs: []
  type: TYPE_NORMAL
- en: Defining function prototypes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A **function prototype** is a forward declaration of a function that describes
    how a function should be correctly invoked. A prototype ensures strong type checking
    between a function call and its definition. A function prototype consists of:'
  prefs: []
  type: TYPE_NORMAL
- en: The function's return type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The function's name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The function's type and number of arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A function prototype allows a function call to precede the function''s definition
    or allows calls to functions that exist in separate files. Let''s examine a simple
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter02/Chp2-Ex2.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter02/Chp2-Ex2.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we prototype `int minimum(int, int);` near the beginning of the
    example above. This prototype lets the compiler know that any calls to `minimum()`
    should take two integer arguments and should return an integer value (we'll discuss
    type conversions later in this section).
  prefs: []
  type: TYPE_NORMAL
- en: Next, in the `main()` function, we call the function `minimum(x, y)`. At this
    point, the compiler checks that the function call matches the aforementioned prototype
    with respect to the type and number of arguments and the return type. Namely,
    that the two arguments are integers (or could easily be converted to integers)
    and that the return type is an integer (or could easily be converted to an integer).
    The return value will be utilized as a value to print using `cout`. Lastly, the
    function `minimum()` is defined in the file. Should the function definition not
    match the prototype, the compiler will raise an error.
  prefs: []
  type: TYPE_NORMAL
- en: The existence of the prototype allows the call of a given function to be fully
    type-checked prior to the function's definition being seen by the compiler. The
    example above is of course contrived to demonstrate this point; we could have
    instead switched the order in which `minimum()` and `main()` appear in the file.
    However, imagine that the definition of `minimum()` was contained in a separate
    file (the more typical scenario). In this case, the prototype will appear at the
    top of the file, which will call this function (along with header file inclusions)
    so that the function call can be fully type-checked against the prototype.
  prefs: []
  type: TYPE_NORMAL
- en: In the above-mentioned multiple file scenario, the file containing the function
    definition will be separately compiled. It will then be the linker's job to ensure
    that when the two files are linked together, the function definition and prototypes
    match so that the linker can resolve any references to such function calls. Should
    prototypes and definitions not match, the linker will not be able to link the
    two sections of code together into one compiled unit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at this example''s output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Now that we understand function prototype basics, let's see how we can add optional
    argument names to function prototypes.
  prefs: []
  type: TYPE_NORMAL
- en: Naming arguments in function prototypes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Function prototypes may optionally contain names, which may differ from those
    in either the formal or actual parameter lists. Argument names are ignored by
    the compiler, yet can often enhance readability. Let's revisit our previous example,
    adding optional argument names in the function prototype.
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter02/Chp2-Ex3.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter02/Chp2-Ex3.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This example is nearly identical to the one preceding it. However, notice that
    the function prototype contains named arguments `arg1` and `arg2`. These identifiers
    are immediately ignored by the compiler. As such, these named arguments do not
    need to match either the formal or actual parameters of the function and are optionally
    present merely to enhance readability.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output to accompany this example is the same as the previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s move forward with our discussion by adding a useful feature to
    function prototypes: default values.'
  prefs: []
  type: TYPE_NORMAL
- en: Adding default values to function prototypes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Default values** may be specified in function prototypes. These values will
    be used in the absence of actual parameters in the function call and will serve
    as the actual parameters themselves. Default values adhere to the following criteria:'
  prefs: []
  type: TYPE_NORMAL
- en: Default values must be specified from right to left in the function prototype,
    without omitting any values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Actual parameters are substituted from left to right in the function call; hence
    the right to left order for default value specification in the prototype is significant.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A function prototype may have all, some, or none of its values filled with default
    values, as long as the default values adhere to the above specifications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see an example using default values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter02/Chp2-Ex4.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter02/Chp2-Ex4.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, notice that a default value is added to the right-most argument
    in the function prototype for `int minimum(int arg1, int arg2 = 100000);`. This
    means that when `minimum` is called from `main()`, it may be called with either
    one argument: `minimum(x)` or with two arguments: `minimum(x, y)`. When `minimum()`
    is called with a single argument, the single argument is bound to the left-most
    argument in the formal parameters of the function and the default value is bound
    to the next sequential argument in the formal parameter list. However, when `minimum()`
    is called with two arguments, both of the actual parameters are bound to the formal
    parameters in the function; the default value is not used.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the output for this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have a handle on default values within a function prototype, let's
    expand on this idea by using different default values with prototypes in various
    program scopes.
  prefs: []
  type: TYPE_NORMAL
- en: Prototyping with different default values in different scopes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Functions may be prototyped in different scopes with different default values.
    This allows functions to be built generically and customized through prototypes
    within multiple applications or for use in multiple sections of code.
  prefs: []
  type: TYPE_NORMAL
- en: Here is an example illustrating multiple prototypes for the same function (in
    different scopes) using different default values.
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter02/Chp2-Ex5.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter02/Chp2-Ex5.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, notice that `int minimum(int, int);` is prototyped near the
    top of the file. Then notice that `minimum()` is re-prototyped in the more local
    scope of `function1()` as `int minimum(int arg1, int arg2 = 500);`, specifying
    a default value of `500` for its right-most argument. Likewise, in the scope of
    `function2()`, function `minimum()` is re-prototyped as: `int minimum(int arg1,
    int arg2 = 90);`, specifying a default value of `90` in the right-most argument.
    When `minimum()` is called from within `function1()` or `function2()`, the local
    prototypes in each of these function scopes, respectively, will be used – each
    with their own default values.'
  prefs: []
  type: TYPE_NORMAL
- en: In this fashion, specific areas of a program may be easily customized with default
    values that may be meaningful within a specific portion of an application. However,
    be sure to *only* employ re-prototyping a function with individualized default
    values within the scope of a calling function to ensure that this customization
    can be easily contained within the safety of a very limited scope. Never re-prototype
    a function in a global scope with differing default values – this could lead to
    unexpected and error-prone results.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output for the example is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Having now explored function prototypes with respect to default usage in single
    and multiple files, using default values in prototypes, and re-prototyping functions
    in different scopes with individual default values, we are now able to move forward
    with the last major topic in this chapter: function overloading.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding function overloading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C++ allows two or more functions that share a similar purpose, yet differ in
    the types or number of arguments they take, to co-exist with the same function
    name. This is known as **function overloading**. This allows more generic function
    calls to be made, leaving the compiler to choose the correct version of the function
    based on the type of the variable (object) using the function. In this section,
    we will add default values to the basics of function overloading to provide flexibility
    and customization. We will also learn how standard type conversions may impact
    function overloading, and potential ambiguities that may arise (as well as how
    to resolve those types of uncertainties).
  prefs: []
  type: TYPE_NORMAL
- en: Learning the basics of function overloading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When two or more functions with the same name exist, the differentiating factor
    between these similar functions will be their signature. By varying a function''s
    signature, two or more functions with otherwise identical names may exist in the
    same namespace. Function overloading depends on the signature of a function as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The **signature of a function** refers to a function's name, plus its type and
    number of arguments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A function's return type is not included as part of its signature.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two or more functions with the same purpose may share the same name, provided
    that their signatures differ.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A function's signature helps provide an internal, "mangled" name for each function.
    This encoding scheme guarantees that each function is uniquely represented internally
    to the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a few minutes to understand a slightly larger example that will
    incorporate function overloading. To simplify the explanation, this example is
    broken into three segments; nonetheless, the full program can be found in its
    entirety at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter02/Chp2-Ex6.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter02/Chp2-Ex6.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'At the beginning of this example, notice that we include the math library with
    `#include <cmath>`, to provide access to basic math functions, such as `pow()`.
    Next, notice the class definitions for `Circle` and `Rectangle`, each with relevant
    data members (`radius` and `area` for `Circle`; `length`, `width`, and `area`
    for `Rectangle`). Once these types have been defined, prototypes for two overloaded
    display functions are shown. Since the prototypes for the two display functions
    utilize user-defined types `Circle` and `Rectangle`, it is important that `Circle`
    and `Rectangle` have both previously been defined. Now, let''s examine the body
    of the `main()` function as we continue with the next segment of this program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, in the `main()` function, we declare a variable of type `Circle` and two
    variables of type `Rectangle`. We then proceed to load the data members for each
    of these variables in `main()` using the dot operator `.` with appropriate values.
    Next in `main()`, there are three calls to `display()`. The first function call,
    `display(myCircle)`, will call the version of `display()` that takes a `Circle`
    as a formal parameter because the actual parameter passed to this function is
    in fact of the user-defined type `Circle`. The next two function calls, `display(myRect)`
    and `display(mySquare)`, will call the overloaded version of `display()`, which
    takes `Rectangle` as a formal parameter because the actual parameters passed in
    each of these two calls are Rectangles themselves. Let''s complete this program
    by examining both function definitions for `display()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Notice in the final segment of this example, both versions of `display()` are
    defined. One of the functions takes `Circle` as the formal parameter, and the
    overloaded version takes `Rectangle` as its formal parameter. Each function body
    accesses data members specific to each of its formal parameter types, yet the
    overall functionality of each function is similar in that in each case a specific
    shape (`Circle` or `Rectangle`) is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the output for this full program example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Next, let's add to our discussion of function overloading by understanding how
    standard type conversion allows for one function to be used by multiple data types.
    This can allow function overloading to be used more selectively.
  prefs: []
  type: TYPE_NORMAL
- en: Eliminating excess overloading with standard type conversion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Basic language types can be converted from one type to another automatically
    by the compiler. This allows the language to supply a smaller set of operators
    to manipulate standard types than would otherwise be necessary. Standard type
    conversion can also eliminate the need for function overloading when preserving
    the exact data type of the function parameters is not crucial. Promotion and demotion
    between standard types are often handled transparently, without explicit casting,
    in expressions including assignments and operations.
  prefs: []
  type: TYPE_NORMAL
- en: Here is an example illustrating simple standard type conversions. This example
    does not include function overloading.
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter02/Chp2-Ex7.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter02/Chp2-Ex7.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `maximum()` function takes two double-precision floating-point
    numbers as parameters, and the function returns the result as an `int`. First,
    notice that `int maximum(double, double);` is prototyped near the top of the program
    and is defined at the bottom of this same file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, in the `main()` function, notice that we have three int variables defined:
    `result`, `a`, and `x`. The latter two are initialized with values of `6` and
    `10`, respectively. We also have two floats defined and initialized: `float x
    = 5.7, y = 9.89;`. In the first call to function `maximum()`, we use `x` and `y`
    as actual parameters. These two floating-point numbers are promoted to double-precision
    floating-point numbers and the function is called as expected.'
  prefs: []
  type: TYPE_NORMAL
- en: This is an example of standard type conversion. Let's notice that the return
    value of `int maximum(double, double)` is an integer – not a double. This means
    that the value returned from this function (either formal parameter `a` or `b`)
    will be a copy of `a` or `b` first truncated to an integer before being used as
    a return value. This return value is neatly assigned to `result`, which has been
    declared an `int` in `main()`. These are all examples of standard type conversion.
  prefs: []
  type: TYPE_NORMAL
- en: Next, `maximum()` is called with actual parameters `m` and `n`. Similar to the
    previous function call, the integers `m` and `n` are promoted to doubles and the
    function is called as expected. The return value will also be truncated back to
    an `int`, and this value will be passed to `cout` for printing as an integer.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output for this example is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Now that we understand how function overloading and standard type conversions
    work, let's examine a situation where the two combined could create an ambiguous
    function call.
  prefs: []
  type: TYPE_NORMAL
- en: Ambiguities arising from function overloading and type conversion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a function is invoked and the formal and actual parameters match exactly
    in type, no ambiguities arise with respect to which of a selection of overloaded
    functions should be called – the function with the exact match is the obvious
    choice. However, when a function is called and the formal and actual parameters
    differ in type, standard type conversion may be performed on the actual parameters,
    as necessary. There are situations, however, when the formal and actual parameter
    types do not match, and overloaded functions exist. In these cases, it may be
    difficult for the compiler to select which function should be selected as the
    best match. In these cases, a compiler error is generated indicating that the
    available choices paired with the function call itself are ambiguous. Explicit
    type casting or re-prototyping the desired choice in a more local scope can help
    correct these otherwise ambiguous situations.
  prefs: []
  type: TYPE_NORMAL
- en: Let's review a simple function illustrating the function overloading, standard
    type conversion, and potential ambiguity.
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter02/Chp2-Ex8.cpp](https://github.com/PacktPublishing/Demystified-Object-Oriented-Programming-with-CPP/blob/master/Chapter02/Chp2-Ex8.cpp)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In this preceding simple example, two versions of `maximum()` are both prototyped
    and defined. These functions are overloaded; notice that their names are the same,
    but they differ in the types of arguments that they utilize. Also note that their
    return types differ; however, since return type is not part of a function's signature,
    the return types need not match.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, in `main()`, two variables each of type `char`, `int`, and `float` are
    declared and initialized. Next, `maximum(a, b)` is called and the two `char` actual
    parameters are converted to integers (using their ASCII equivalents) to match
    the `maximum(int, int)` version of this function. This is the match closest to
    the `char` argument types of `a` and `b`: `maximum(int, int)` versus `maximum(float,
    float)`. Then, `maximum(x, y)` is called with two floats and this call will exactly
    match the `maximum(float, float)` version of this function. Similarly, `maximum(m,
    n)` will be called and will perfectly match the `maximum(int, int)` version of
    this function.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, notice the next function call (which, not coincidentally, is commented
    out): `maximum(a, y)`. Here, the first actual parameter perfectly matches the
    first argument in `maximum(int, int)`, yet the second actual parameter perfectly
    matches the second argument in `maximum(float, float)`. And for the non-matching
    parameter, a type conversion *could* be applied – but it is not! Instead, this
    function call is flagged by the compiler as an ambiguous function call since either
    of the overloaded functions could be an appropriate match.'
  prefs: []
  type: TYPE_NORMAL
- en: On the line of code `maximum((float) a, y)`, notice that the function call to
    `maximum((float) a, y)` forces an explicit typecast to the first actual parameter
    `a`, resolving any potential ambiguity of which overloaded function to call. With
    parameter `a` now cast to be a `float`, this function call easily matches `maximum(float,
    float)`, and is no longer considered ambiguous. Type casting can be a tool to
    disambiguate crazy situations such as these.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the output to accompany our example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned additional non-OO C++ features that are essential
    building blocks needed to base C++'s object-oriented features. These language
    necessities include using the `const` qualifier, understanding function prototypes,
    using default values in prototypes, function overloading, how standard type conversion
    affects overloaded function choices, and how possible ambiguities may arise (and
    be resolved).
  prefs: []
  type: TYPE_NORMAL
- en: Very importantly, you are now ready to move forward to the next chapter, in
    which we will explore indirect addressing using pointers in reasonable detail.
    The matter-of-fact skills that you have accumulated in this chapter will help
    you more easily navigate each progressively more detailed chapter to ensure you
    are ready to easily tackle the OO concepts starting in [*Chapter 5*](B15702_05_Final_NM_ePub.xhtml#_idTextAnchor199),
    *Exploring Classes in Detail*.
  prefs: []
  type: TYPE_NORMAL
- en: Remember, C++ is a language filled with more gray areas than most other languages.
    The subtle nuances you are accumulating with your skillset will enhance your value
    as a C++ developer – one who can not only navigate and understand existing nuanced
    code but can create easily maintainable code.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the signature of a function and how is a function's signature related
    to name mangling in C++? How do you think this facilitates how overloaded functions
    are handled internally by the compiler?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a small C++ program to prompt a user to enter information regarding a
    `Student`, and print out the data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. `Student` information should minimally include first name, last name, GPA,
    and the current course in which the `Student` is registered. This information
    may be stored in a simple class. You may utilize arrays to represent the string
    fields since we have not yet covered pointers. Also, you may read in this information
    in the main function rather than creating a separate function to read in the data
    (since the latter will require knowledge of pointers or references). Please do
    not use global (that is, extern variables).
  prefs: []
  type: TYPE_NORMAL
- en: 'b. Create a function to print out all the data for the `Student`. Remember
    to prototype this function. Use a default value of 4.0 for GPA in the prototype
    of this function. Call this function two ways: once passing in each argument explicitly,
    and once using the default gpa.'
  prefs: []
  type: TYPE_NORMAL
- en: c. Now, overload the `Print` function with one that either prints out selected
    data (that is, last name and GPA) or with a version of this function that takes
    a `Student` as an argument (but not a pointer or reference to a `Student` – we'll
    do that later). Remember to prototype this function.
  prefs: []
  type: TYPE_NORMAL
- en: d. Use iostreams for I/O.
  prefs: []
  type: TYPE_NORMAL
