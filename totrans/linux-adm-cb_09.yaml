- en: Containers and Virtualization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What is a container?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing Docker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running your first Docker container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging a container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Searching for containers (and security)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is virtualization?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Starting a QEMU machine with our VM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using virsh and virt-install
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparing the benefits of local installs, containers, and VMs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Brief comparison of virtualization options (VMware, proxmox, and more)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I''m going to be honest: containers and virtualization is one of my favorite
    things to talk about in relation to computers and servers. The very concept of
    being able to install an entirely different computer, within your computer, is
    a concept that just sings brilliance to me.'
  prefs: []
  type: TYPE_NORMAL
- en: It's not a new idea; this principle has been around for quite some time, with
    even my first OS9 computer being capable of virtualization to some degree. Going
    back further, the root of the term is from the 1960s, though it had a slightly
    different meaning than it does in modern-day vernacular.
  prefs: []
  type: TYPE_NORMAL
- en: You've probably used a **virtual machine** (**VM**) already, though you might
    not even know you have. VMs are quick these days, with a negligible performance
    hit compared to running on the underlying tin, thanks to advantages in virtualization
    that mean that you're no longer emulating everything to do with the VM, and instead
    you're passing VM instructions straight through to the host computer's CPU.
  prefs: []
  type: TYPE_NORMAL
- en: VMs are undeniably a powerhouse of hosting and development, with the ability
    to quickly spin up and tear down machines, being a godsend when you're constantly
    breaking things or looking into a secure and cheap way to segment a massive workhorse
    of a server.
  prefs: []
  type: TYPE_NORMAL
- en: These days, containers have somewhat taken the mantle away from VMs, though
    they each have their advantages, and they exist in harmony rather than in constant
    war with each other.
  prefs: []
  type: TYPE_NORMAL
- en: Containers, unlike virtual machines, are more like a slice of a system, if you
    will, with a shared core.
  prefs: []
  type: TYPE_NORMAL
- en: When you're using a container on a Linux system, you're sharing the kernel of
    the host machine, rather than installing your own, and you've usually not bothered
    with the emulation of extra hardware, like disk controllers.
  prefs: []
  type: TYPE_NORMAL
- en: Again, containers and containerization aren't new concepts, with the idea having
    been around since the days of jails on FreeBSD, and latterly Zones on Solaris
    (both of which still exist in one shape or another, and which we'll look at later).
    They have exploded recently though (within the last few years) with the introduction
    of **Docker**, which made the whole idea of containers a lot easier for people
    to swallow (and their marketing was stellar).
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we're going to look at containers and virtual machines, discuss
    the pros and cons of each, and talk about management of a virtual environment.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, and for this chapter, we're going to use our Ubuntu machine
    primarily.
  prefs: []
  type: TYPE_NORMAL
- en: Mostly, this is because Ubuntu comes with a lot of the more up-to-date elements
    we require out of the box, whereas CentOS has had a lot of things patched backward
    (back-ported) thanks to its long shelf life.
  prefs: []
  type: TYPE_NORMAL
- en: 'Feel free to use the following `Vagrantfile`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: What is a container?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we're going to look at what containers actually are at a bit
    of a deeper level than we covered in the introduction.
  prefs: []
  type: TYPE_NORMAL
- en: We won't go into a huge amount of depth (because we'd get lost and have to call
    James Cameron to get us out), but we will touch on the core of what makes a container
    a container, and how it differs from running a full-fledged virtual machine.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'SSH to your Ubuntu VM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We're going to create a container without using the most popular tool on the
    market.
  prefs: []
  type: TYPE_NORMAL
- en: Containers utilize certain kernel features (namespaces and cgroups), which means
    that they're not strictly portable to the Windows and Macs of the world.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''re going to create a storage pool for our containers to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Directory storage pools are discouraged for production use. You're better off
    using a tailored solution that uses LVM or ZFS, but for testing and examples,
    it's fine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we''re going to start a container with this pool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The preceding retrieval can take some time, and will depend on your network
    connection speed.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end of this process, our container should be created. We can list it
    by using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can execute the commands inside it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Here, we're running a command that, when run on our host VM, would tell us `ubuntu-bionic`.
    Therefore, by checking it alongside our `lxc` command, we can prove it's running
    in the container.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we wanted to enter the container, we could simply start a shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: There you have it – a very quick slice of an operating system, inside your operating
    system!
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you''re done, simply type `exit` or hit *Ctrl* + *D* to log out of the
    container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can destroy it with the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: One thing people frequently forget, both in the LXC world and the Docker world,
    is that you've got more than just the container to contend with. We've deleted
    the container, but if you really want to clean up shop, you will have to delete
    the image you downloaded and the storage pool, too.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To elaborate somewhat on the cgroups and namespaces comment, what containers
    are in reality are functions of the kernel and user space tools to make things
    look nice. LXC is a tool that abstracts complexity away, simplifying the setup
    of our semi-segregated machines into a few easy-to-use commands.
  prefs: []
  type: TYPE_NORMAL
- en: cgroups (Linux control groups)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here''s an excerpt from the *Linux Programmer''s Manual*:'
  prefs: []
  type: TYPE_NORMAL
- en: '"Control groups, usually referred to as cgroups, are a Linux kernel feature
    that allows processes to be organized into hierarchical groups whose usage of
    various types of resources can then be limited and monitored. The kernel''s cgroup
    interface is provided through a pseudo-filesystem called cgroupfs. Grouping is
    implemented in the core cgroup kernel code, while resource tracking and limits
    are implemented in a set of per-resource-type subsystems (memory, CPU, and so
    on)."'
  prefs: []
  type: TYPE_NORMAL
- en: In practice, this means that the kernel has the ability to group processes together
    into a stack and that it can then control and monitor the resource usage of it.
  prefs: []
  type: TYPE_NORMAL
- en: namespaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Without starting a trend, here''s the *Linux Programmer''s Manual* again:'
  prefs: []
  type: TYPE_NORMAL
- en: '"A namespace wraps a global system resource in an abstraction that makes it
    appear to the processes within the namespace that they have their own isolated
    instance of the global resource. Changes to the global resource are visible to
    other processes that are members of the namespace, but are invisible to other
    processes. One use of namespaces is to implement containers."'
  prefs: []
  type: TYPE_NORMAL
- en: In practice, this means that your singular network interface can have multiple
    namespaces attached to it, which the utilizing processes will believe is the sole
    instance of that device.
  prefs: []
  type: TYPE_NORMAL
- en: Network interfaces aren't the only example, but they're one of the more obvious
    candidates as every VM needs a NIC.
  prefs: []
  type: TYPE_NORMAL
- en: The breakdown of our creation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we created the storage pool at the beginning of this section, what we
    were really doing was informing our system (the `lxd` daemon) that it needed to
    use a specific directory for container storage, namely the one below `/var/lib/lxd/storage-pools/`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: When we started our container, what we first did was download a prepackaged
    image from a default internet location that served as the base for the container
    we created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, it''s seen as an alphanumeric string, but it''s really Ubuntu 18.04 in
    cut-down-container form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note the size of this container, `175 M`, which is one of the primary advantages
    that people highlight regarding containers (they're tiny, and this is actually
    one of the bigger examples!).
  prefs: []
  type: TYPE_NORMAL
- en: 'When our container is running, we can see it from the host as a collection
    of processes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should look something like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4de248d9-dd2c-40aa-a38a-950383b5813c.png)'
  prefs: []
  type: TYPE_IMG
- en: This container therefore has most of an OS inside it, which it has inherited
    from the image we pulled down, though it notably doesn't contain a kernel that
    is shared with the host VM.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine a container like an orange (I also quite like oranges) where each segment
    can exist as its own little parcel of juicy goodness, but without the outer rind
    of the orange giving it structure and passing it nutrients, it's useless. This
    is in contrast to a virtual machine, which is more like an eternally young baby
    spider (hear me out) where each exist independently as living, breathing creatures,
    but they still ride around on their mother's back, ready to deliver a dose of
    eldritch horror to anyone who comes into contact with a brood.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the moment, you should have a container created by LXC, inside a virtual
    machine managed by Vagrant (and utilizing VirtualBox) atop your own laptop, desktop,
    or server.
  prefs: []
  type: TYPE_NORMAL
- en: This can get a bit tricky to visualize, but a lot of clever people put a lot
    of hours into making sure this sort of setup works without problems.
  prefs: []
  type: TYPE_NORMAL
- en: The LXD daemon
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As ever, we can use `systemctl` to visualize our service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the top of this section, we ran `hostname` inside our container, but that
    doesn't give you a clue as to what the container is doing. One thing that I find
    particularly handy is the ability to check the processes running in my container,
    without having to dig out process IDs for my `ps` command first.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, I''m using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives me the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/339e1759-742e-4a74-8e37-1a88d8cc6913.png)'
  prefs: []
  type: TYPE_IMG
- en: Note that it's significantly quieter than the host machine, and very few daemons
    are actually running in the container.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Docker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By far the most popular solution to running containers on Linux (at least at
    the time of writing) is Docker.
  prefs: []
  type: TYPE_NORMAL
- en: Starting out as a way for Docker Inc. (then dotCloud) to better utilize containers
    in their **PaaS** (**Platform-as-a-Service**) company, Docker quickly gained traction
    in the open source world and was soon seen as the future of computing in a lot
    of circles (the cynical sysadmins generally came after the developers got wind
    of it).
  prefs: []
  type: TYPE_NORMAL
- en: Because it's effectively a simple way to use already-present kernel features,
    and includes the Docker Hub for people to both upload and download pre-built images,
    it made containers easy.
  prefs: []
  type: TYPE_NORMAL
- en: Soon, people were containerizing everything, from Firefox, to Nginx, to entire
    distributions, just because.
  prefs: []
  type: TYPE_NORMAL
- en: I firmly believe that the ease with which Docker made it possible to upload
    and download their images contributed to its success. As I've already mentioned,
    the concepts of containers go back to the nineties, but there was no "jail prison"
    or "zones zone" for people to download pre-built collections of software from.
    Docker Hub provided this on an already popular platform.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most distributions come with Docker in some form or another in the traditional
    repositories. However, this is frequently out of step with upstream or just plain
    old, so it's a good idea to utilize the upstream Docker repositories in your environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'SSH to your Ubuntu VM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Docker keeps a page up to date on how to install Docker on your distribution
    of choice (see [https://docs.docker.com/install](https://docs.docker.com/install)).
    The following are the condensed instructions for Ubuntu.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run an update to make sure you''re ready to install Docker:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Install the GPG key and then add the repository itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As ever, check the GPG fingerprint against an official source.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can finally install Docker itself (this may take some time):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also check the status of our Docker daemon by using `systemctl`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed we haven't started and enabled this service. This is mostly
    because Debian-derived systems like to start services for you... there are a variety
    of reasons I don't like this approach personally, but it is what it is.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we start, you may have noticed that we constantly worked with a package
    called `docker-ce`, and this is for a very good reason.
  prefs: []
  type: TYPE_NORMAL
- en: There are two base versions of Docker, **Community Edition**** (CE)** and **Enterprise
    Edition**** (EE)**. Mostly, you will only ever see CE in the wild, and it's perfectly
    functional for all of your needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'All we did here was go to the writers of the software directly and add their
    own GPG key and repository information, alongside our Ubuntu defaults. Docker
    is a very dynamic program, meaning it has frequent and sizable releases. At the
    time of writing, we installed `18.06.1-ce`, but that might change before you know
    it. Docker works on a YEAR-MONTH release format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We also installed two primary components (alongside a lot of tools and extras),
    which were the Docker command-line tool and the Docker daemon.
  prefs: []
  type: TYPE_NORMAL
- en: Docker works in the same way as other user space tools, making use of the kernel
    functionality. What sets it apart is how user-friendly it can be.
  prefs: []
  type: TYPE_NORMAL
- en: You mostly work with Docker through the command-line tool `docker`, which, in
    turn, communicated with the Docker daemon. This daemon is the component that's
    responsible for managing the containers it's instructed to create, and maintaining
    the images that it pulls in from Docker Hub or other registries.
  prefs: []
  type: TYPE_NORMAL
- en: A Docker registry is a repository of images. The most popular is Docker Hub,
    but there's nothing stopping you from creating your own, or using an off-the-shelf
    solution to manage one, like Artifactory.
  prefs: []
  type: TYPE_NORMAL
- en: The last component to be aware of for now is the runtime that Docker is using,
    which is `runC` (the universal container runtime) out of the box.
  prefs: []
  type: TYPE_NORMAL
- en: The runtime is actually just the name given to the collection of unified systems
    that Docker will use to run containers (think of cgroups and namespaces bundled
    into one word, though there's other features, too). What this means is that while
    `runC` is Linux-specific, if Windows has a container runtime (Host Compute Service),
    then Docker can utilize this instead.
  prefs: []
  type: TYPE_NORMAL
- en: This does not make the containers universal between operating systems – you
    can't create a container for Linux and spin it up in the Windows-specific runtime,
    but it does make the Docker tooling universal.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The easiest way to get all the information you could want to know about your
    Docker installation is to use the `docker info` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Slightly more
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One thing I haven't touched on is `containerd` and the likes of `CRI-O`. If
    you already know these terms, then there's a good chance you understand why I
    haven't mentioned them, because they're far too far out of scope for what this
    book is trying to accomplish.
  prefs: []
  type: TYPE_NORMAL
- en: I would encourage anyone who is interested to pick up dedicated literature on
    Docker and its various components as you'll not be out of work for the next few
    years if you understand the most popular containerization tool of the day, inside
    and out.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Did you spot `pigz` in the list of extras downloaded with Docker? This is a
    particularly interesting bit of software, as it's basically a parallelized version
    of `gzip.` When you're decompressing a file and you've got eighteen cores, it's
    nice to use as many of them as you can, instead of overloading one.
  prefs: []
  type: TYPE_NORMAL
- en: Running your first Docker container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've already used a container, way back in the LXC section, but now we're going
    to use the more popular system for running containers.
  prefs: []
  type: TYPE_NORMAL
- en: This section will cover some basic commands, without going into a great deal
    of depth.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we're going to use our Ubuntu VM, but make sure that Docker
    from the previous section is set up first.
  prefs: []
  type: TYPE_NORMAL
- en: 'SSH to your VM, and be sure to use the previous section to set up the upstream
    Docker repository before installing Docker:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As with the LXC section, we're going to start an Ubuntu container, and we're
    then going to interact with it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Begin with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that the container is up and running, you can view it with `docker ps`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also enter it, should you wish, with `docker exec`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: You could also use `docker attach`, which would accomplish the same thing on
    the face of it (giving you access to a shell in the container). The only problem
    with this method is that you would be attaching to the active process, meaning
    that when you closed your session, the container would stop too.
  prefs: []
  type: TYPE_NORMAL
- en: Leaving the container again (`exit`) will bring you back to your VM's prompt.
  prefs: []
  type: TYPE_NORMAL
- en: 'From here, you can stop your container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This may take a few seconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'The container is now deleted, and we can confirm this with another `docker
    ps`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's break down our commands.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Starting with the creation of our new container, this was the command we used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we''re telling Docker we want to `run` a command in a new container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re then informing it that we want it to be interactive, to have a pseudo-TTY,
    and to start detached (knocking us back to the VM shell):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''re telling Docker that when the container stops, we want it to automatically
    remove itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This is a relatively new feature, only introduced because people didn't realize
    containers linger after they stop, and people would end up with lists of hundreds
    of stopped containers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, we''re saying what image (from Docker Hub) we want to use, and what
    command to run (here, it''s Alpine Linux''s default shell, `ash`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Listing our container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Secondly, we used the following command to list our new container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This showed the `CONTAINER ID`, `IMAGE`, `COMMAND`, `CREATED`, `STATUS`, `PORTS`,
    and `NAMES` of all our containers (or, in this case, just one).
  prefs: []
  type: TYPE_NORMAL
- en: The `CONTAINER ID` portion is a random string allocation, and the `NAMES` section
    features the randomly generated friendly names of your containers (though this
    can also be defined at creation time).
  prefs: []
  type: TYPE_NORMAL
- en: When we latterly added `-a` to our listing command, it was to show that the
    container wasn't omitted from the initial list simply because it was stopped,
    as the `-a` flag will show all containers, not just running ones.
  prefs: []
  type: TYPE_NORMAL
- en: Executing commands in our container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next, we jumped inside our container, starting another (atop the one we''ve
    already started at creation time) shell session:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Here, we executed a command by using an interactive session and another pseudo-TTY
    within our container (denoted here by its friendly name from `docker ps`).
  prefs: []
  type: TYPE_NORMAL
- en: 'This dropped us inside the container. If we then run `top`, we will see both
    instances of the `/bin/ash` command we''ve started:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4340b198-411c-4038-b90f-ad36e8361aec.png)'
  prefs: []
  type: TYPE_IMG
- en: Did you spot that one of the `/bin/ash` instances is `PID 1`?
  prefs: []
  type: TYPE_NORMAL
- en: Stopping our container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once we''d jumped out again, we then stopped our running container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This takes a few seconds, but, once completed, the container will vanish (as
    we saw), though the image it used (alpine) will remain.
  prefs: []
  type: TYPE_NORMAL
- en: Because our image is still kicking around, the next time you want to use it
    for something, you won't have to download it!
  prefs: []
  type: TYPE_NORMAL
- en: Debugging a container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we're going to start up our container again, make a few changes,
    and check to see whether our changes have had any affect.
  prefs: []
  type: TYPE_NORMAL
- en: This serves to highlight the transient nature of containers, and what you can
    do with a running instance.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this section, we're going to continue using our Ubuntu VM.
  prefs: []
  type: TYPE_NORMAL
- en: 'SSH to your VM, if not already connected, and start up a container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You should now have a running docker container, listed here with `docker ps`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Note that we also have a port forwarded in this example, namely port `8080.`
  prefs: []
  type: TYPE_NORMAL
- en: Port forwarding in this instance is the same as any other—we're forwarding a
    port from the host to a port in the container.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try to `curl` the port:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, jump into the VM and let''s start a web server on the specified port:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we need to install some additional busybox things:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can start a small web server on port `8080` before exiting the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, from your VM, you''ll be able to `curl` your container''s new web server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Stop the container, and start a new one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that when you now `curl` your port again, it won''t work, because all
    your previous changes to the running container have been lost, and a new one has
    a risen in its place:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All we've done here is highlight that containers are ephemeral by nature, and
    while you can stop and start the same container (minus the `--rm` to the `docker
    run` command), you're running in a transient state until you tag your container
    and upload it to a registry somewhere.
  prefs: []
  type: TYPE_NORMAL
- en: It's generally not good practice to build a container by starting one and then
    installing a bunch of software inside it, before leaving it and saving it for
    later. The better method is to use a `Dockerfile` or some other automated and
    reproducible way of building containers.
  prefs: []
  type: TYPE_NORMAL
- en: What we've also done is point out that while docker containers should be a self-contained
    little entity, that doesn't mean you can't hop inside them to see what's going
    on, and even install extra software to help with your debugging, should you so
    wish.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are interested in using a `Dockerfile` to do what we did here, it's a
    fairly trivial one, though it's technically outside the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following would be enough to get you started:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'You could then build this with something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you could start your resulting container (detached, and forwarding the
    port):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'We added the `-f` in the `Dockerfile` to ensure that the process remains in
    the foreground (and the container doesn''t stop immediately):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Searching for containers (and security)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you're mostly going to need access to a browser of some sort,
    though in a pinch, you might get away with calling up a friend and asking them
    to do an internet search for you (if you're a really good friend and they have
    literally nothing better to do).
  prefs: []
  type: TYPE_NORMAL
- en: We're also going to use our VM a bit to practice what we discover.
  prefs: []
  type: TYPE_NORMAL
- en: We're going to search for containers on Docker Hub, and we're going to touch
    upon the security implications of downloading and using public images.
  prefs: []
  type: TYPE_NORMAL
- en: This section is not designed to scare you, in the same way you're not supposed
    to be scared to run any piece of free (as in open source) software that you find
    – it's about doing due diligence.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Jump onto your Ubuntu VM (and install docker from the previous section, if
    you haven''t already done so):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: From your browser of choice, which is Firefox for me, head over to [https://hub.docker.com](https://hub.docker.com).
  prefs: []
  type: TYPE_NORMAL
- en: 'You''ll be greeted by a page that looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fc79e940-83c1-4660-9a05-a88c0b474f6e.png)'
  prefs: []
  type: TYPE_IMG
- en: There's something of an implication here, which is the section entitled New
    to Docker?. There's no need to create a Docker ID to get started, despite what
    the first sentence there might suggest. You may find it handy to do so, and you
    may even have good reason to create an ID, but there's absolutely no need to do
    so initially (at least not at the time of writing...).
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, use the search bar at the top of the screen, and type `redis`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e5f3b6f7-83c8-4bfc-b402-760e156a2832.png)'
  prefs: []
  type: TYPE_IMG
- en: Wow! That's a lot of repositories!
  prefs: []
  type: TYPE_NORMAL
- en: Herein is the first thing it's good to know about Docker. Because it's just
    so easy to create images and upload them to Docker Hub (I have a few myself),
    there's a good chance that there's going to be multiple versions of what you want.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we can see that the top result is simply titled redis instead of being
    `<username>/redis-foo` like the rest.
  prefs: []
  type: TYPE_NORMAL
- en: When an image is official, it gets the privileged honor of only having the explicit
    name of its software, in this case, redis.
  prefs: []
  type: TYPE_NORMAL
- en: 'Click it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8d5a1c09-ddaf-4cba-851d-5bb77087e479.png)'
  prefs: []
  type: TYPE_IMG
- en: There's a few things to note here.
  prefs: []
  type: TYPE_NORMAL
- en: Helpfully, we get a command to get started, that is, `docker pull redis` on
    the right.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We get repository information, which is the default view that provides us with
    a short and full description. In practice, this can be as short or as long as
    the maintainer feels like making it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally, for this moment, we get a Tags section at the top. Click this now:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/69cd9d17-f020-4149-8ed7-09dd57f44d04.png)'
  prefs: []
  type: TYPE_IMG
- en: Tags, as with Git, are a way of denoting a specific version of the container
    you want to download.
  prefs: []
  type: TYPE_NORMAL
- en: 'The default tag is the latest and it''s the image you would download if you
    were to run the following command (as you can see in the line immediately following
    our command):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'If we wanted to specifically pull in the Alpine version of Redis (as in Redis
    installed atop Alpine Linux), we would instead run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Note that we pulled every later except the base one, which already existed in
    our setup.
  prefs: []
  type: TYPE_NORMAL
- en: Et voilà! You used Docker Hub to seek out a version of everyone's favorite in-memory
    database!
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All we're doing here is pulling in a functional image from the global Docker
    Registry; this is the default, the omega, the biggest, the original, and the best
    (according to some people.)
  prefs: []
  type: TYPE_NORMAL
- en: Docker Hub is a repository of smaller repositories, with everyone able to put
    their own spin on containers they've built (or forked) and thus adding to the
    software soup of the world.
  prefs: []
  type: TYPE_NORMAL
- en: This obviously has disadvantages, as I alluded to in the previous sardonic line.
    This means that because it's so easy to punt your image onto Docker Hub, it can
    become increasingly frustrating to find that one image you want.
  prefs: []
  type: TYPE_NORMAL
- en: People can also be malicious, uploading containers that may very well do what
    they say on the tin, while at the same time using an entire core of your computer
    to mine bitcoin (though this sort of thing is generally found out pretty quickly
    when it does happen). It is up to you, as a systems administrator, DevOps person,
    jack-of-all-trades for your company, to work out what a container is doing, and
    if it's what you need.
  prefs: []
  type: TYPE_NORMAL
- en: 'I follow some basic principles here:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check whether the `Dockerfile` and source are freely available:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Usually, repositories on Docker Hub are triggered builds from GitLab or other
    source code hosting sites, meaning that you can check the code behind the container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Check the number of downloads of the container:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While not an indicator of quality, since frequently the first image of a piece
    of software is the most popular, it's generally a good example of the thousand-eyes
    principle. If thousands of people are using it, there's a higher likelihood that
    nothing malicious is hidden in the container (though there's still a chance).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Check to see whether it''s an official project''s Docker container:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Projects such as Redis, Kibana, and Swift all have official Docker containers,
    so generally I'd go with their offering above others.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There may also be containers from the project that aren't tagged as official
    and still bear the creator's moniker. Those sit firmly above Jane Bloggs containers
    in my books.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That's not to say that unofficial ones are bad, or that they don't cover a slightly
    different need, but, nine times out of ten, I've found this not to be the case.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can you just build it yourself?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assuming that the `Dockerfile` is licensed freely, you could just lift it off
    GitLab and stick it into your build server to create an image of your own. At
    least that way, you know that what you see is what you get at the end of the process
    (assuming you're not downloading software as part of the build, from some dodgy
    third-party repository you've never heard of).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All that said – and it sounds like I'm being very down on homespun containers –
    Docker has won the war of container supremacy because of its market mind share
    and its ease-of-use (if it's building containers or the simplicity of finding
    them).
  prefs: []
  type: TYPE_NORMAL
- en: Docker Hub means that even if I have no local repositories configures, but I
    do have Docker installed, I can soon be running a web server on an Alpine container,
    that plugs into a MariaDB container, atop Gentoo.
  prefs: []
  type: TYPE_NORMAL
- en: This container could then feed logs into a containerized Elasticsearch instance,
    running on Slackware, on the exact same host, in about ten minutes.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can also search from the command line, if you feel so inclined:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5af54ef9-20f8-4d9a-91f4-80fc5d4482b5.png)'
  prefs: []
  type: TYPE_IMG
- en: I'll be honest, I never do this, and it's mostly because everyone carries a
    browser around in their pocket these days. However, I know that some people out
    there are purists.
  prefs: []
  type: TYPE_NORMAL
- en: What is virtualization?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you've opened this book randomly on this page, then you might now know what
    virtualization actually is. If you've done the normal thing, and started at the
    beginning, then there's an equally good chance you already understand that you've
    been using virtualization for almost all of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Virtualization is the act of virtualizing (I know right?) one machine inside
    another machine. Unlike a container, though, we visualize everything from the
    USB controllers to the floppy drive (seriously).
  prefs: []
  type: TYPE_NORMAL
- en: This concept is not new, but the technology marches on.
  prefs: []
  type: TYPE_NORMAL
- en: For our examples, you've probably done the same thing I did and resorted to
    Vagrant with VirtualBox. I chose to go this route because VirtualBox is everywhere,
    with versions available for macOS, Linux, and Windows (along with others!). This
    has great advantages, but also disadvantages.
  prefs: []
  type: TYPE_NORMAL
- en: Virtualization, by its very nature, is closely tied to the software and hardware
    of the box it's run on. With this in mind, you might understand why enterprises
    generally choose to not use VirtualBox everywhere (despite having Windows and
    Linux machines), but instead use HyperV and KVM respectively... they're more native.
  prefs: []
  type: TYPE_NORMAL
- en: In Linux land, the virtualization software of choice is **KVM** (**Kernel Virtual
    Machine**).
  prefs: []
  type: TYPE_NORMAL
- en: 'Siderant: KVM is a terrible name for a product or piece of software. It already
    had a meaning before Kernel Virtual Machine was decided upon, and data center
    engineers the world over have been cursing this particular three letter acronym
    since its inception. Keyboard Video Mouse was a standard, and, in my head, I still
    picture a DC crash-cart when I hear those letters.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we're going to be looking at some basic differences between
    containers and virtualization.
  prefs: []
  type: TYPE_NORMAL
- en: We're going to use our Ubuntu VM, and our CentOS one, for the first time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Log on to your CentOS and Ubuntu VMs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our container steps, we looked briefly at the fact that the kernel that was
    being run was the same on the host VM as it was inside the container.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this step, we''re going to run the same command on both of our VMs and
    compare the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Our Ubuntu box is running kernel 4.15.0, and our CentOS box, version 3.10.0.
  prefs: []
  type: TYPE_NORMAL
- en: Therein is the first advantage of containers, which are able to run completely
    different versions of the Linux kernel.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second advantage in this vein is the fact that virtual machines don''t
    have to be the same operating system as their host: you can emulate a Windows,
    FreeBSD, or even macOS machine on a Linux box, and mostly any combination of the
    same.'
  prefs: []
  type: TYPE_NORMAL
- en: macOS is a bit of a special case (isn't it always?) because there are license
    problems and you have to do it in a very specific fashion, but it can be done.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at something else that's a little bit cool.
  prefs: []
  type: TYPE_NORMAL
- en: 'On our CentOS VM, I''ve listed the disks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: These aren't physical drives, they're virtual, and, as a result, you can screw
    up their configuration as many times as you like without damaging your host's
    booting potential.
  prefs: []
  type: TYPE_NORMAL
- en: This is one thing I hark on about all the time, mostly since I completely hosed
    the installation I had on my laptop by running a bunch of Ansible in a container.
    This Ansible, though I didn't know it at the time, messed around with disk partitions
    and layout quite forcefully, and, in the case of containers, the devices listed
    in `/dev/` are the devices on your machine, meaning that I'd most excellently
    destroyed my local install. Thankfully, I worked out what had happened before
    I rebooted, and was able to save the work I needed before reinstalling, but I
    didn't do that again. I also changed the tests to use Vagrant and Virtual Machines
    instead...
  prefs: []
  type: TYPE_NORMAL
- en: Now, obviously, there are disadvantages too—you're basically running an entire
    machine, meaning that they have to boot (though you can get this down to a few
    seconds) and will be inherently slower than most containers to start up.
  prefs: []
  type: TYPE_NORMAL
- en: You might also only need one program to be installed (such as Steam on a Windows
    VM), but you get the other guff along for the ride, meaning that if you want it
    or not, you'll get Edge browser, Paint, and those annoying folders in the `Documents`
    section that are titled `Music`, `Videos`, and `Pictures` even, inexplicably,
    on server installations.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It works on modern computers by taking advantage of CPU features, for the most
    part.
  prefs: []
  type: TYPE_NORMAL
- en: When you emulate your hardware, using either VirtualBox or KVM, what you're
    really doing is creating a whole separate set of instructions for the CPU to process. If
    we emulate VMs on top of CPUs that aren't aware of them natively, and can't deal
    with their instructions at near-native speeds, you have to emulate even the CPU,
    which can be costly and slow (more on this later).
  prefs: []
  type: TYPE_NORMAL
- en: Generally, CPUs from the last decade will have either AMD-V (in the case of
    AMD) or VT-x (in the case of Intel), which means that your VMs will be nearly
    indistinguishable from your host machine in terms of raw processing speed.
  prefs: []
  type: TYPE_NORMAL
- en: There's also **full virtualization** and **paravirtualization**, the former
    of which means emulating everything (like, say, emulating an aarch64 processor
    atop an x86_64 processor) and the latter of which means that, while the execution
    of processes is segregated, the actual processor being used is the same one as
    the host (what we talked about before in terms of CPUs being virtualization-aware).
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There's even more cool things you can do with VMs that just aren't possible
    with containers.
  prefs: []
  type: TYPE_NORMAL
- en: Say you're a gamer, and you really don't like using Windows, but begrudgingly
    admit that you really want to play Civilization with your friends, all of whom
    are avid Windows fanatics. You can do it (sort of) from within Linux.
  prefs: []
  type: TYPE_NORMAL
- en: Okay okay, so it's a bit disingenuous to suggest you're doing it from within
    Linux, but there's a method here.
  prefs: []
  type: TYPE_NORMAL
- en: You start a VM, install Windows (legally), and then connect your graphics card
    to your VM...
  prefs: []
  type: TYPE_NORMAL
- en: What?
  prefs: []
  type: TYPE_NORMAL
- en: Yes!
  prefs: []
  type: TYPE_NORMAL
- en: With PCI-passthrough, it's perfectly possible to give a graphics card to a virtual
    machine, plug a monitor in the back, and then do all your gaming on a separate
    screen (using the same mouse and keyboard).
  prefs: []
  type: TYPE_NORMAL
- en: Progress!
  prefs: []
  type: TYPE_NORMAL
- en: Starting a QEMU machine with our VM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we're going to start a VM inside our VM and attempt to connect
    to it.
  prefs: []
  type: TYPE_NORMAL
- en: Be forewarned. You will probably think that the elements of this section are
    slow. This is not the fault of your machine, or your own configuration—this is
    the fault of physics and the fact that we don't have consumer-grade quantum computing
    yet.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'SSH to your Ubuntu VM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Install the appropriate components for running virtual machines on Ubuntu:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''re going to download an Alpine ISO and attempt an installation inside a
    virtual machine (inside our virtual machine):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: I chose Alpine for this because it's tiny, fitting into 32 MB.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to create a virtual disk on which to install our OS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can use QEMU to boot our ISO atop our virtual drive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'With any luck, you should see something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9fb5b5b4-7578-419b-9698-0d4ea89aa886.png)'
  prefs: []
  type: TYPE_IMG
- en: 'At the command-line prompt, you should be able to log in as the root user (there''s
    no password by default):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Alpine functions like something approaching a live CD, so we can now go ahead
    and run through a quick installation to the local drive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'You''ll be asked some standard questions. Mostly, you can just answer with
    the defaults, but for the sake of completeness, here''s what I did:'
  prefs: []
  type: TYPE_NORMAL
- en: Keyboard: `gb`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keyboard variant: `gb`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hostname: `[default (localhost)]`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interface: `[default (eth0)]`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IP address: `[default (dhcp)]`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manual network configuration: `[default (no)]`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Password: Random'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Time zone: `[default (UTC)]`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Proxy: `[default (none)]`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mirror: `3` (UK, you may find one closer to you)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SSH server: `[default (openssh)]`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disk to use: `sda`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use: `sys`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Erase and continue: `y`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once completed, you'll have an installed Alpine Linux VM inside your Ubuntu
    VM.
  prefs: []
  type: TYPE_NORMAL
- en: 'Power down the Alpine installation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'You''ll find yourself back inside your Ubuntu VM. Now, we''re going to boot
    Alpine again, but this time we''re going to omit the ISO file and the `-boot`
    parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: As I said at the start, all of these steps can take a long time to complete,
    depending on the age of your computer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once booted, you''ll find yourself back in your Alpine installation, this time
    booted from our virtual drive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: To terminate your session, either power off the VM again or hit *Ctrl* + *A*,
    and then *X*.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Breaking down what we're doing here step by step, we started out by downloading
    an ISO image from the Alpine website. This is the easiest thing to explain, as
    we're effectively using the ISO as a source of truth for our installation. You
    can also do things such as pass `/dev/cdrom` through to your VM, should you wish
    to use the physical drive in your machine (and you live in 2009).
  prefs: []
  type: TYPE_NORMAL
- en: Once we had our ISO image, we then created a file-based block device to install
    atop. This is so that we can segment one installation from another, and even move
    the installation from machine to machine should we wish. There are other solutions
    that don't involve using files – you could partition an LVM setup, giving some
    of the space to your VM, or you could attach a physical disk and give the entire
    thing to the installation.
  prefs: []
  type: TYPE_NORMAL
- en: We used `qemu-img` to create the file, but there's no reason you couldn't have
    used another tool such as `fallocate` to accomplish the same thing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we booted our VM using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Breaking this down, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the QEMU architecture that we want to emulate. I stuck with x86_64
    for this, as it''s the most common and it''s the architecture that the ISO we
    downloaded expects to find. We could have used `qemu-system-aarch64` if we so
    desired, and provided we had the appropriate disc image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we''re passing QEMU a drive to use, specifically the `example-disk` file
    that we just created, and the format it was created in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'We specifically tell QEMU that we want to use the ISO we downloaded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'We want to boot, specifically from the CD-ROM rather than the virtual drive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: We're on a server here, connected over SSH, so we can't use a graphical output
    for our VM. This option redirects serial input and output to the console.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There's nothing stopping you from using your QEMU-driver VM as a full-fledged
    machine, aside from the speed.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can install packages, and even run things such as `htop`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/9e5f8e7c-10a6-43e1-93e1-db890fa186a5.png)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You might have noticed a lot of options that we didn't use here, and QEMU's
    system tools are capable of quite a lot. Typically, people don't build VMs using
    QEMU directly – they rely on shinier and more user-friendly tools to do the job
    for them.
  prefs: []
  type: TYPE_NORMAL
- en: On servers, Virsh is a good choice (covered later in this chapter) and, on desktop
    machines, **Virtual Machine Manager (virt-manager)** is a very commonly installed
    package that also lets you connect to remote (headless) servers to set up VMs
    using clicky buttons.
  prefs: []
  type: TYPE_NORMAL
- en: Using virsh and virt-install
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`virsh` and `virt-install` are good tools for individuals who are getting started
    with VMs on Linux. It sounds a bit old hat now, but if you can do something well
    on the command line, you''ll wonder why you ever needed a clicky-button GUI to
    do the job for you.'
  prefs: []
  type: TYPE_NORMAL
- en: When we talk about clients in this way, what we're referring to are frontends
    to the `libvirt` library, which is a C toolkit that was designed to make interacting
    with the kernel's virtualization functionality easier.
  prefs: []
  type: TYPE_NORMAL
- en: '`virsh` and `virt-install` talk to `libvirt`, which, in turn, talks to the
    kernel.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'SSH to your Ubuntu VM, and then install the `virtinst`, `libvirt-clients`,
    `libvirt-bin`, and `libvirt-daemon` packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, we're going to use the `virt-install` tool that we've installed to create
    our VM, and then we're going to probe it with `virsh`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the VM is the simple step; it's the heartache that comes with maintaining
    machines that's the real drag.
  prefs: []
  type: TYPE_NORMAL
- en: virt-install
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To begin, let's use the Alpine ISO we downloaded previously to spin up and install
    a virtual machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you haven''t got the ISO from the previous section, here''s the command
    to download it again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s use `fallocate` this time to create a block device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s use a single line to provision our domain (domain being the collective
    term used here for the machine and other bits):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: We're using `virtio26` as the OS variant here because there isn't an explicit
    `alpine` option. Instead, this tells `virt-install` that the OS we're installing
    is using a kernel later than 2.6, and it supports VirtIO devices (for disks, networking,
    and so on). This results in us having a functioning VM, which is nice.
  prefs: []
  type: TYPE_NORMAL
- en: Assuming this goes to plan, you should again see the Alpine boot sequence.
  prefs: []
  type: TYPE_NORMAL
- en: Use the `root` user and blank password to log in, and then run through the install
    process, as we did in the previous section (installing to the vda device).
  prefs: []
  type: TYPE_NORMAL
- en: Disconnect from the console once the install has finished with *Ctrl* + *]*.
  prefs: []
  type: TYPE_NORMAL
- en: virsh
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's perfectly possible to use Virsh as a series of commands on the command
    line, in the traditional Unix style of `<command>` `<flag>` `<argument>` that
    we've seen previously.
  prefs: []
  type: TYPE_NORMAL
- en: However, it's also perfectly acceptable to use Virsh interactively, in its own
    mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start the Virsh Terminal by using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we''re going to interact with the machine we created a moment before.
    Start by listing it on the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: By default, this command will show you running domains.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we connect to our VM and hit *Enter* a couple of times, we can interact
    with our install:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Hop out of the VM again with *Ctrl* + *]*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s build on the bare-bones domain that we have, starting by taking a look
    at what `virt-install` has given us with `dominfo`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Now here''s the fun bit – we haven''t actually rebooted our VM yet, following
    the install, so let''s issue that using `virsh`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Yes, destroy is a confusing word here, but it's because the actual state of
    the VM is ephemeral. The data is safe on the drive. The actual configuration is
    part of the domain so that when we issue the `destroy` and `start` commands, we're
    not really deleting anything. I dislike the terminology, but it's just something
    you learn to live with.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can console connect to our VM, again from `virsh` (this bit, again,
    can take some time):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: And, at any time, we can disconnect using *Ctrl* + *]*.
  prefs: []
  type: TYPE_NORMAL
- en: Virsh is full of tricks, my favorite of which is the easy way to edit the configuration
    XML of your domain.
  prefs: []
  type: TYPE_NORMAL
- en: 'Issue an `edit` command as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'You should be dropped into the editor you selected and presented with the configuration
    file for your VM:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e8f22a38-a1a7-47c6-a008-a97db952c3d2.png)'
  prefs: []
  type: TYPE_IMG
- en: This is sort of the additional way of doing things. If you're comfortable editing
    files directly, this might be your jam more than using the command line (and,
    in my experience, there are a couple of options that are just not possible to
    do without delving into this file).
  prefs: []
  type: TYPE_NORMAL
- en: 'There are also a couple more things before we leave the world of `virsh`, the
    first of which is the `version` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: It's a great way to work out the version of the hypervisor you're connected
    to, the `libvirt` library version, and the API.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also check the vCPU count:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you can adjust the numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'We also know from `dominfo` that we gave our VM 512 MiB of memory, so let''s
    lower that to make space for other VMs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: We could up it too, but not beyond the max memory setting that the VM already
    has (in this state, at least).
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As hinted at previously, when you create a VM using `virt-install`, what you're
    actually doing is writing an initial XML file that contains the recipe for how
    the VM looks and acts.
  prefs: []
  type: TYPE_NORMAL
- en: This file actually exists at `/etc/libvirt/qemu/ex-alpine-2.xml` and can be
    read in the same way as any other file on the system (`virsh` just makes it easier,
    like `systemctl cat`).
  prefs: []
  type: TYPE_NORMAL
- en: When we use tools such as `virt-install`, `virt-viewer`, or any of the `virt-*`
    suite, we're taking a lot of typing and copying of files out of the equation.
    You can write a runbook that recreates an environment with just a few one-line
    commands. Virsh then exists to query your setup and get some basic information
    about the solutions you've spun up.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use something like `virsh autostart` to start a VM on boot, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: By doing this, we're enabling the script located at `/usr/lib/libvirt/libvirt-guests.sh` to
    start the VM during boot.
  prefs: []
  type: TYPE_NORMAL
- en: 'This script, in turn, is triggered by a `systemd` unit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Take a look at the rest of the `virt` suite:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: There's a tool for everything, and everything's got a tool.
  prefs: []
  type: TYPE_NORMAL
- en: When you get a few minutes, take a look at `virt-clone` and `virt-viewer` –
    they're my favorites.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing the benefits of local installs, containers, and VMs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We're going to take a look at some obvious advantages and disadvantages to local
    installations, containers, and VMs, as well as deciding when it might be ideal
    to use one or the other.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you want to follow along in this section, ensure that you've got Docker installed
    and set up, as well as having QEMU tools enabled (both from the previous sections).
  prefs: []
  type: TYPE_NORMAL
- en: 'SSH to your Ubuntu VM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you might want to install Vagrant inside our Vagrant VM (for the VM examples
    that follow):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: Once you've added yourself to the appropriate groups, log out of your VirtualBox
    VM and back in, prior to moving into this section.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: From your command line, let's start an Nginx instance.
  prefs: []
  type: TYPE_NORMAL
- en: You could go about this in one of three ways.
  prefs: []
  type: TYPE_NORMAL
- en: Use `apt` to install Nginx from the default repositories
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use Docker to pull the official Nginx image from Docker Hub
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set up a VM and install Nginx inside it, using port forwarding from the host
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'These could be done in the following fashion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: I used a `Vagrantfile` here because it's what we've used throughout this book,
    but there are other ways we could go about spinning up a VM. This also might not
    work if there are already other VMs running inside your VM (from the previous
    section) and could just be far too slow to work at all.
  prefs: []
  type: TYPE_NORMAL
- en: What are the advantages and disadvantages to these different methods?
  prefs: []
  type: TYPE_NORMAL
- en: Local Nginx install
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, the local install. This is the simplest method, as we're simply installing
    software that is readily available from the default Ubuntu repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pros:'
  prefs: []
  type: TYPE_NORMAL
- en: It comes configured in an Ubuntu fashion (that is, some Ubuntu defaults, such
    as start scripts) and it is pretty much guaranteed to work with your setup
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It installs extremely quickly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It will also be kept up to date as long as the repository is kept up to date,
    and other software installed from the same location should interact with it in
    a native fashion, avoiding things like manual pointing of dependencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It'll obviously be fast, and thus able to utilize whatever your box grants it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can generally expect reasonable help with issues too, be it on the official
    forums, or if you have a specific support contract with Ubuntu (they may start
    by assuming you've installed things from their default repositories)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Cons:'
  prefs: []
  type: TYPE_NORMAL
- en: You can't install multiple versions of Nginx easily; though it's certainly possible,
    it's more work
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can't easily delete all of your configuration and files without something
    potentially getting left behind (making a reinstall a faff)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nginx isn't as segregated as it could be from the rest of the system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker Nginx install
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Moving on, we next set up an Nginx Docker container, forwarding a port as we
    did.
  prefs: []
  type: TYPE_NORMAL
- en: 'The positives here are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: It's quick to start up your instance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiple instances can be started with no worry of cross contamination
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The processes are reasonably segregated from the host machine (though exploits
    can and do happen)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Containers can be torn down and redeployed in a heartbeat, with no worry that
    lingering files might cause you problems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some negatives are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: You have to download the container first
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mapping ports (when not defined explicitly) results in a randomly NAT'd port,
    rather than port `80` by default
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You might end up with an OS in the container that isn't the same as the host
    OS (there can be internal security compliance issues with this)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You've now effectively got two sources of truth for software running on your
    system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuration within the container isn't consistent – you have to explicitly
    save a container's state if you modify it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging becomes slightly more awkward
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No init system (usually) if you do need one for things such as service file
    testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: VM Nginx install
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There's a small consideration to take into account here, and that's the fact
    we're running a VM inside a VM, but it highlights a few problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some positives are:'
  prefs: []
  type: TYPE_NORMAL
- en: It has pretty much complete OS segregation (except for some vulnerabilities
    like Meltdown)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Good control over resource allocation for the VM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ability to tear down and spin up on a whim
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you need to specifically make hardware changes to account for software requirements,
    VMs are the only way to do this easily
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some negatives are:'
  prefs: []
  type: TYPE_NORMAL
- en: VMs can be slower than containers, and there's a lot of factors you have to
    account for (such as if your server is already a VM)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You're running an entirely separate OS and kernel, for the sake of one program
    (in this example)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: VMs usually take up more space, owing to the disk space needed for the rest
    of the OS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You have to manage the updates for another machine, besides the host
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You need to keep an eye on resource segregation, which can mean extra monitoring
    (this is especially true if you do things such as specific CPU pinning)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This isn't an attempt to dissuade you from choosing any particular method of
    installing your software, and there's plenty of reasons for choosing one method
    over the other.
  prefs: []
  type: TYPE_NORMAL
- en: I've worked in environments where I had to primarily use a VM, and not wanting
    the headache of using a VM inside a VM, I've tested software by using containers
    instead.
  prefs: []
  type: TYPE_NORMAL
- en: Likewise, as mentioned previously, I've screwed up host installations by making
    hardware configuration changes inside a Docker container, resulting in a host
    system that would never boot again.
  prefs: []
  type: TYPE_NORMAL
- en: Speaking from experience, you'll quickly get tired of managing different methods
    of installation, and having used systems where some things were installed from
    default repositories, some from Snaps, some from Flatpak, and some utilizing Docker
    containers, it gets really old, really fast.
  prefs: []
  type: TYPE_NORMAL
- en: In the example we looked at here, I would be hard pressed to not choose Docker
    on a web server, specifically because of the management capabilities it offers.
    I could easily install multiple instances of Nginx and be relatively confident
    they'd never know that another instance existed, without having to segregate configuration
    files in a weird and wonderful fashion.
  prefs: []
  type: TYPE_NORMAL
- en: It's never simple.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, it''s worth remembering that because we used Vagrant in our VM and `libvirt`
    underneath, we can see our VM with Virsh:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also see our container with docker:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: Brief comparison of virtualization options (VMware, proxmox, and more)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When it comes to virtualization, everyone has their favorite solution.
  prefs: []
  type: TYPE_NORMAL
- en: You should know about two options by now, those being VirtualBox (which we've
    been using throughout this book) and QEMU/KVM. However, these aren't the only
    options available to you, should you want to run virtual machines on your server,
    just as containers aren't limited to Docker.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we''re going to run through a few other options, most of which you''ll
    probably come across in your career at some point:'
  prefs: []
  type: TYPE_NORMAL
- en: VMware ESXi
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Proxmox
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OpenStack
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open your web browser of choice.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We're going to look at some of the options available to us, in a section dedicated
    to each.
  prefs: []
  type: TYPE_NORMAL
- en: VMware ESXi
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the various offerings from VMware (now a subsidiary of Dell) ESXi isn't
    Linux; it's a dedicated "OS" that sits atop your hardware, and virtual machines
    can be configured atop ESXi.
  prefs: []
  type: TYPE_NORMAL
- en: It is a licensed product, and it isn't open source, but it fits in well with
    the VMware management offerings that they have alongside the hypervisor itself
    (for example, you can easily have several hypervisors in a pool, which are managed
    by a centralized box).
  prefs: []
  type: TYPE_NORMAL
- en: 'In terms of pros, VMware ESXi offers you the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A dedicated hypervisor, designed to do one job, and do it well
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easy setup – a few clicks and you've got a box installed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A wide range of hardware support, including a range of servers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easy-to-use software and understandable menus (in this author's opinion)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In terms of cons, you might consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: VMware ESXi isn't open source; this may or may not impact your decision
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a dedicated virtual machine server, ESXi can't do anything else of note
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can get expensive as an offering, and while support can be bought and agreements
    signed, you might go for a free offering based entirely on budget
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'VMware is available from [https://www.vmware.com/products/esxi-and-esx.html](https://www.vmware.com/products/esxi-and-esx.html):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/26a21fbb-86bf-4db1-b667-6f27cab36ac1.png)'
  prefs: []
  type: TYPE_IMG
- en: On a personal note, I admit to having used VMware products many times, for various
    jobs, and it does exactly what it says on the tin, with very little flourish on
    top. It handles things such as VM failover gracefully, in the right circumstances,
    and it's simple enough that anyone can be put in front of the console and navigate
    around easily (though I wasn't a massive fan of their first attempts at a web-based
    GUI).
  prefs: []
  type: TYPE_NORMAL
- en: Proxmox Virtual Environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another dedicated hypervisor install, Proxmox (VE), is a Linux-based (Debian,
    specifically) operating system that, again, has a wide range of hardware support
    and a friendly GUI to get you started.
  prefs: []
  type: TYPE_NORMAL
- en: This open source solution is ideal for a home-lab environment, and scales up
    to large installations well, meaning that you can deploy the same solution for
    your developers and your production rollout.
  prefs: []
  type: TYPE_NORMAL
- en: 'In terms of pros, you might think about the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The fact it's open source, which again, may influence your decision
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fact it's free (as in beer), with the option of paid support and training
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The knowledge that it's based on known and well-supported technologies, such
    as KVM and QEMU
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fact it supports containers, as well as virtual machines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In terms of negatives, you could consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The install base, and the fact it's not as well-known as VMware ESXi and others
    (though this might influence you as a positive, too)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a dedicated virtualization install, your Proxmox server won't do much of
    anything else (like ESXi)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Proxmox Virtual Environment is available at [https://www.proxmox.com/en/downloads](https://www.proxmox.com/en/downloads):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6bce4ecb-af3b-4130-a14c-7aeaa5eebe6c.png)'
  prefs: []
  type: TYPE_IMG
- en: Proxmox Virtualization Homepage
  prefs: []
  type: TYPE_NORMAL
- en: Again, speaking from personal experience, I've set up three node Proxmox clusters
    with automatic failover with relative ease, and everyone I've spoken to that uses
    Proxmox seems to appreciate what a nice solution it is in a pinch, while knowing
    it can extend further when needed.
  prefs: []
  type: TYPE_NORMAL
- en: OpenStack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The new kid on the block, OpenStack, is a collection of technologies that, when
    added together, make a solution that rivals any of the bigger virtualization environment
    providers.
  prefs: []
  type: TYPE_NORMAL
- en: It can be a virtual machine host, container host, file storage provider, block
    storage provider, and it has a rapid development cycle that keeps new features
    constantly coming in.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike the other two solutions on this list, OpenStack is the name given to
    a few different software components.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the pros, give some thought to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: OpenStack has an enthusiastic and dedicated community behind it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The components are open source and worked on by people all over the globe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many companies offer OpenStack solutions and offer different levels of support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you know OpenStack well, you won't be out of work for the next fifty years
    (conjecture)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In terms of cons, I might get some hate mail for this:'
  prefs: []
  type: TYPE_NORMAL
- en: OpenStack has a rapid development cycle, meaning that you generally get left
    behind if you don't stay on top of updates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OpenStack sits atop whatever distribution of Linux you want it to, meaning that
    you have to manage the underlying OS as well in a lot of cases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Certainly in places where I've seen OpenStack being used, it almost takes a
    dedicated OpenStack team to keep on top of management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's not easy to set up in a usable fashion, in a pinch (though development
    environments do exist)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are multiple schools of thought on what makes a good OpenStack deployment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's a right pain when you come to an OpenStack solution that's been neglected
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you want to give OpenStack a go (and I would encourage you to do so), the
    Getting Started guide can be found here: [https://wiki.openstack.org/wiki/Getting_Started](https://wiki.openstack.org/wiki/Getting_Started).'
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s also a start page, including links to the devstack dev environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9e96ca1d-b327-4cb8-95b9-2dae73c252ec.png)'
  prefs: []
  type: TYPE_IMG
- en: Personal thought – I know some incredibly intelligent people that love OpenStack
    and swear by it, but it's an area that requires a lot of love and attention, along
    with dedication.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are different ways to do the same thing. This is true for most experiences,
    and it's especially true in the Unix and Unix-like (Linux) world.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we have three good examples of software and solutions that allow you to
    control virtual machine deployment in a mostly user-friendly fashion, even though
    you might think that all of these solutions are much more complex than you require.
  prefs: []
  type: TYPE_NORMAL
- en: I mention them here because it's good to know these options are out there, and
    even if you start your journey by installing VMs locally on an Ubuntu installation
    (using VirtualBox or KVM and Libvirt), you might wish to expand to something grander
    in the future.
  prefs: []
  type: TYPE_NORMAL
- en: Another option to consider is public cloud offerings, and while I'll talk about
    these in greater detail later, it's worth noting that there are several providers
    out there who'll take away the headache of managing the underlying software and
    let you simply install and break VMs.
  prefs: []
  type: TYPE_NORMAL
- en: If you don't have the hardware or the resources, or even the budget, you can
    use public cloud providers for pennies by the hour.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at Scaleway, Digital Ocean, and AWS (specifically, their Lightsail
    offering).
  prefs: []
  type: TYPE_NORMAL
- en: Roundup - containers and virtualization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A short few years ago, there was a movement in the Linux community. Containers
    were suddenly everywhere, and making fantastical promises about what was possible
    in an ephemeral and ever-changing world. Containers were going to solve every
    problem you'd ever face with software, they were going to fix every security problem
    you'd ever fought, and they were going to tuck you in at night while feeding your
    pets.
  prefs: []
  type: TYPE_NORMAL
- en: We know now that while containers are great, and they are indeed an excellent
    solution in a lot of circumstances, they aren't the be-all and end-all. There
    will still be situations where software atop a bare-metal machine will be best,
    or instances where a VM just makes more sense than a container, and you know what?
    That's okay.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to, don't let me dissuade you from trying to get your own pet project
    working in a container – it's definitely a good learning experience, and you may
    find that it actually is the best way to lift and shift your installation, but
    don't get carried away.
  prefs: []
  type: TYPE_NORMAL
- en: VMs will always have their place too, and while a lot of testing, deployments,
    and dev environments have gone the way of serverless container deployments, a
    good local VM can still offer a nice way to work, especially if you want to understand
    how certain software interacts with the OS as a whole (be it a monolithic application,
    or lots of little applications that make up one program).
  prefs: []
  type: TYPE_NORMAL
- en: At the end of the day, it's like most things in our world. Just because you
    can do something in one way, doesn't necessarily mean it's the best way to do
    it; in the same vein, that doesn't make your proposed solution bad, and it could
    be perfectly functional for what you need—it's just handy to be aware of all the
    options.
  prefs: []
  type: TYPE_NORMAL
- en: I sincerely wish I could fit more exploration in this book, and look deeper
    into the different ways and means of managing and maintaining both VMs and containers,
    but this is not a book about either of those things – it's supposed to be a general
    peek into the world of Linux administration.
  prefs: []
  type: TYPE_NORMAL
- en: Remember holy wars? I've also met people who are against the very idea of containers,
    deeming them variously "difficult" and "pointless" solutions. If you take up this
    mantle and fight this corner, be prepared to lose, because the army of container
    proponents is bigger than the opponents at this point by a wide margin.
  prefs: []
  type: TYPE_NORMAL
