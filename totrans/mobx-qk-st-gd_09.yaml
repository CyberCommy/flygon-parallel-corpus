- en: Mobx Internals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The MobX we have seen so far was from a consumer's standpoint, which focused
    on how it should be used, the best practices, and the APIs for tackling real-world
    use cases. This chapter takes it a level below and exposes the machinery behind
    the MobX reactive system. We will look at the underpinnings and the core abstractions
    that makes the triad of *Observables-Actions-Reactions* come to life.
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics that will be covered in this chapter include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The layered architecture of MobX
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Atoms and ObservableValues
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Derivations and reactions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is *Transparent Functional Reactive Programming*?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will be required to have Node.js installed on a system. Finally, to use
    the Git repository of this book, the user needs to install Git.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code files of this chapter can be found on GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Mobx-Quick-Start-Guide/tree/master/src/Chapter09](https://github.com/PacktPublishing/Mobx-Quick-Start-Guide/tree/master/src/Chapter09)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the code in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://bit.ly/2LvAouE](http://bit.ly/2LvAouE)'
  prefs: []
  type: TYPE_NORMAL
- en: A layered architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Like any good system, MobX is built up of layers where each layer provides
    the services and behaviors for the higher layers. If you apply this lens on MobX,
    you can see these layers, bottom-up:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00037.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '**Atoms**: Atoms are the foundation of MobX observables. As the name suggests,
    they are the atomic pieces of the observable dependency tree. It keeps track of
    its observers but does not actually store any value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ObservableValue, ComputedValue, and Derivations**: `ObservableValue` extends `Atom`
    and provides the actual storage. It is also the core implementation of boxed Observables. In
    parallel, we have derivations and reactions, which are the *observers* of the
    atoms. They respond to changes in atoms and schedule reactions. `ComputedValue` builds
    upon the derivations and also acts as an observable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Observable{Object, Array, Map} and APIs**: These data structures build on
    top of `ObservableValue` and use it to represent their properties and values.
    This also acts as the API layer of MobX, the primary means of interfacing with
    the library from the consumer''s standpoint.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The separation of layers is also visible in the source code where there are
    separate folders for different abstraction layers of MobX. It is not a one-to-one
    match with what we have described here, but conceptually these layers have lot
    of parallels in code as well. All of the code in MobX has been written using TypeScript
    with first class support.
  prefs: []
  type: TYPE_NORMAL
- en: The Atom
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The reactive system of MobX is backed by a graph of dependencies that exist
    between the observables. One observable''s value could depend on a set of observables,
    which in turn could depend on other observables. For example, a shopping cart
    could have a *computed property* called `description` that depends on the array
    of `items` it holds and any `coupons` that were applied. Internally, `coupons` could
    depend on the `validCoupons` *computed property* of the `CouponManager` class.
    In code, this could look like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Visualizing this set of dependencies could give us a simple diagram like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00038.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: At runtime, MobX will create a backing dependency tree. Each node in this tree
    will be represented by an instance of `Atom`, the core building block of MobX.
    Thus, we can expect five *atoms* for the nodes in the tree in the preceding diagram.
  prefs: []
  type: TYPE_NORMAL
- en: 'An atom serves two purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: Notify when it is *read*. This is done by calling `reportObserved()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Notify when it is *changed*. This is done by calling `reportChanged()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a node of the MobX reactivity fabric, an atom plays the important role of
    notifying the reads and writes happening on each node.
  prefs: []
  type: TYPE_NORMAL
- en: Internally, an atom keeps track of its observers and informs them of the changes.
    This will happen when `reportChanged()` is called. A glaring omission here is
    that the actual value of the atom is not stored in the `Atom` itself. For that,
    we have a subclass called `ObservableValue` that builds on top of the `Atom`.
    We will look at that in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, an atom''s core contract consists of the two methods we mentioned earlier.
    It also contains a few housekeeping properties like an array of `observers`, whether
    it is being observed, and so on. We can safely ignore them for our discussion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Reading atoms at runtime
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'MobX also gives you the ability to see the backing atoms at runtime. Going
    back to our previous example of the computed `description` property, let''s explore
    its dependency tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'There are few details that stand out in the preceding snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: MobX gives you a special symbol, `$mobx`, that contains a reference to the internal
    housekeeping structure of the observable. The `cart` instance maintains a map
    of all of its observable properties using `cart[$mobx].values`. The backing atom
    for the `description` property is obtained by reading from this map: `cart[$mobx].values.get('description')`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can get hold of the dependency tree for this property using the `getDependencyTree()`
    function exposed by MobX. It takes in an `Atom` as its input and gives back an
    object describing the dependency tree.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is the output of `getDependencyTree()` for the `description` property.
    A few extra details have been removed for clarity. The reason why you see `ShoppingCart@16.items`
    mentioned twice is because it points to the `items` (the reference) and `items.length`
    properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'There is also a convenient API, `getAtom(thing: any, property: string)`, to
    read atoms from observables and observers. For example, in our previous example,
    instead of using the special symbol `$mobx` and reading into its internal structure,
    we can get the *description* atom with `getAtom(cart, ''description'')`. `getAtom()`
    is exported from the `mobx` package.As an exercise, find out the dependency tree
    for `autorun()` in the previous code snippet. You can get hold of the instance
    of the reaction with `disposer[$mobx]` or `getAtom(disposer)`. Similarly, there
    is also the `getObserverTree()` utility that gives you the observers depending
    on the given observable. See if you can find the connection to `autorun()` from
    the atom backing the `description` property.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating an Atom
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a MobX user, you would rarely use an `Atom` directly. Instead, you would
    rely on other convenience APIs exposed by MobX or data structures like `ObservableObject`,
    `ObservableArray`, or `ObservableMap`. However, the real world always creates
    situations where you may have to dive a few levels deeper.
  prefs: []
  type: TYPE_NORMAL
- en: 'MobX does give you a convenient factory function for creating atoms, aptly
    named `createAtom()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '**`createAtom(name, onBecomeObservedHandler, onBecomeUnobservedHandler)`**'
  prefs: []
  type: TYPE_NORMAL
- en: '`name` (`string`): The name of the atom, which is utilized by the debugging
    and tracing facilities in MobX'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onBecomeObservedHandler` (`() => { }`): A callback function to get notified
    when an atom gets observed for the first time'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onBecomeUnobservedHandler` (`() => { }`): A callback function to get notified
    when an atom is no longer being observed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onBecomeObserved` and `onBecomeUnobserved` are the two points in time when
    an atom becomes active and inactive in the reactivity system. These are normally
    meant for resource management, to set up and tear down, respectively.'
  prefs: []
  type: TYPE_NORMAL
- en: The atomic clock example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s look at an example of using `Atom` that also illustrates how an atom
    participates in the reactive system. We will create a *simple clock* that starts
    ticking when an atom gets observed and stops when it is no longer observed. In
    essence, our resource here is the timer (clock) that is being managed by the use
    of an `Atom`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'There are many interesting details in the preceding snippet. Let''s list them
    out here:'
  prefs: []
  type: TYPE_NORMAL
- en: In the call to `createAtom()`, we are supplying the handler when the atom becomes
    observed and also when it is no longer being observed. It might seem a little
    mysterious when the ato*m actually becomes observed*. The secret here is the use
    of `autorun()`, which sets up a side effect to read the current value of the atomic
    clock. *S*ince an `autorun()` runs immediately, `clock.get()` is called, which
    in turn calls `this.atom.reportObserved()`. This is how the atom becomes active
    in the reactive system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once the atom becomes observed, we start the clock timer, which ticks every
    second. This is happening in the `onBecomeObserved` callback, where we call `this.startTicking()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every second, we call `this.atom.reportChanged()`, which propagates the changed
    value to all observers. In our case, we only have one, `autorun()`, which re-executes
    and prints the console log.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We don't have to store the current time since we return a new value in every
    call to `get()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The other mysterious detail is when the atom becomes *unobserved*. This happens
    when we dispose of `autorun()` after three seconds, causing the `onBecomeUnobserved`
    callback to be invoked on the atom. Inside the callback, we stop the timer and
    clean up the resource.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since `Atoms` are just the nodes of the dependency tree, we need a construct
    that can store the value of the observable. That is where the `ObservableValue` class
    comes in. Think of it as an `Atom` with value. MobX internally distinguishes between
    two kinds of observable values, `ObservableValue` and `ComputedValue`. Let's see
    them in turn.
  prefs: []
  type: TYPE_NORMAL
- en: ObservableValue
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`ObservableValue` is a subclass of `Atom` that adds the ability to store the
    value of the observable. It also adds a few more capabilities such as providing
    hooks for intercepting a value change and observing the value. This is also part
    of the definition for `ObservableValue`. Here is a simplified definition of `ObservableValue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Notice the calls to `reportObserved()` in the `get()` method and `reportChanged()`
    in the `set()` method. These are the places where the atom's value is read and
    written to. By invoking these methods, an `ObservableValue` participates in the
    reactivity system. Also note that `intercept()` and `observe()` are not really
    part of the reactivity system. They are more like *event emitters* that hook into
    the changes happening to the observable value. These events are not affected by
    transactions, which means that they are not queued up till the end of the batch
    and instead fire immediately.
  prefs: []
  type: TYPE_NORMAL
- en: An `ObservableValue` is also the foundation for all of the higher-level constructs
    in MobX. This includes Boxed Observables, Observable Objects, Observable Arrays,
    and Observable Maps. The values stored in these data structures are instances
    of an `ObservableValue`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The thinnest wrapper around an `ObservableValue` is the boxed observable, which
    you create using `observable.box()`. This API literally gives you back an instance
    of the `ObservableValue`. You can use this to call any of the methods on `ObservableValue`,
    as you can see in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: ComputedValue
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The other kind of *observable value* that you can have in an observable tree
    is the `ComputedValue`. This is different from an `ObservableValue` in many ways.
    An `ObservableValue` provides storage for the underlying atom and has its *own
    value*. All the data structures provided by MobX, such as Observable Object/Array/Map,
    rely on the `ObservableValue` to store the leaf-level values. `ComputedValue`
    is special in the sense that it does not have an intrinsic value of its own. Its
    *value*, as the name suggests, is computed from other observables, including other
    computed values:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00039.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'This becomes evident in the definition of `ComputedValue`, where it does not
    subclass `Atom`. Instead, it has an interface that is similar to `ObservableValue`,
    except for the ability to intercept. The following is a simplified definition
    that highlights the interesting parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: An important thing to notice in the preceding snippet is that since a `ComputedValue`
    does not rely on an `Atom`, it uses a different approach for `reportObserved()`.
    This is a lower-level implementation that establishes a link between the observable
    and the observer. This is also used by `Atom` internally so that the behavior
    is exactly the same. Additionally, there is no call to `reportChanged()` as the
    setter for a `ComputedValue` is not well-defined.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, a `ComputedValue` is mostly a read-only observable. Although
    MobX provides a way to *set* a computed value, in most cases, it doesn't really
    make much sense. A setter for a computed value has to apply the reverse computation
    of the getter. This is almost impossible in most cases. Consider the example from
    earlier in this chapter about the `description` of a cart. This is a computed
    value that produces a string from other observables, like `items` and `coupons`.
    What would the *setter* for this computed property look like? It has to parse
    the string and somehow arrive at the values for `items` and `coupons`. That is
    definitely not possible. Thus, in general, it is better to treat `ComputedValue`
    as a readonly observable.
  prefs: []
  type: TYPE_NORMAL
- en: Since a computed value depends on other observables, the actual *value computation*
    is more like a side effect. It is a side effect of a change in any of the depending
    observables. MobX refers to this computation as a derivation. A derivation, as
    we will see a little later, is synonymous with reactions, emphasizing the side
    effect aspect of computation.
  prefs: []
  type: TYPE_NORMAL
- en: A `ComputedValue` is the only kind of node in the dependency tree that is an
    observable as well as an observer. Its value is an observable and due to its dependency
    on other observables, it is also an observer.
  prefs: []
  type: TYPE_NORMAL
- en: '`ObservableValue` = Observable only'
  prefs: []
  type: TYPE_NORMAL
- en: '`Reaction` = Observer only'
  prefs: []
  type: TYPE_NORMAL
- en: '`ComputedValue` = Both observable and observer'
  prefs: []
  type: TYPE_NORMAL
- en: Efficient computation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The derivation function of a `ComputedValue` could be an expensive operation.
    So, it is prudent to cache this value and compute as lazily as possible. That
    is the norm in MobX and it employs a bunch of optimizations to make this a lazy
    evaluation:'
  prefs: []
  type: TYPE_NORMAL
- en: To start with, a value is never computed unless explicitly requested or there
    is a reaction that depends on this `ComputedValue`. As expected, when there are
    no observers, it will not be computed at all.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once computed, its value is cached for future reads. It will stay that way until
    a depending observable signals a change (via its `reportChanged()`) and causes
    the derivation to re-evaluate.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `ComputedValue` can depend on other computed values creating a dependency
    tree. It does not recompute unless the immediate children have changed. If there
    is a change deep in the dependency tree, it waits until the immediate dependencies
    have changed. This behavior improves efficiency and does not recompute unnecessarily.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, there are multiple levels of optimization baked into a `ComputedValue`.
    It is highly recommended to leverage the power of computed properties to represent
    the various nuances of domain logic and its UI.
  prefs: []
  type: TYPE_NORMAL
- en: Derivation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have seen the building blocks of MobX, which represent the observable
    state with `Atoms`, `ObservableValue`, and `ComputedValue`. These are good to
    construct the reactive state graph of your application. But the true power of
    reactivity is unleashed with the use of derivations or reactions. Together, the
    observables and reactions form the yin-yang of MobX. Each relies on the other
    to fuel the reactive system.
  prefs: []
  type: TYPE_NORMAL
- en: A derivation or a reaction is where the tracking happens. It keeps track of
    all the observables used in the context of a derivation or reaction. MobX will
    listen to their `reportObserved()` and add them to the list of tracked observables
    (`ObservableValue` or `ComputedValue`). Any time the observable calls `reportChanged()` (which
    will happen when it's mutated), MobX will schedule a run of all the connected
    observers.
  prefs: []
  type: TYPE_NORMAL
- en: We will be using ***derivation*** and ***reaction*** interchangeably. Both are
    intended to convey the execution of a side effect that uses the observables to
    produce a new value (*derivation*) or a side effect (*reaction*). The tracking
    behavior is common between these two types and hence we will use them synonymously.
  prefs: []
  type: TYPE_NORMAL
- en: The cycle of derivation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MobX uses a `globalState` to keep a reference to the currently executing *derivation*
    or *reaction*. Whenever a reaction is running, all observables that fire their
    `reportObserved()` will be tagged to this reaction. In fact, the relationship
    is bi-directional. An *observable* keeps track of all of its observers (reactions),
    while a *reaction* keeps track of all the observables it is currently observing.
    The currently executing reaction will be added as an *observer* for each of the
    observables. If the observer was already added, it will be ignored.
  prefs: []
  type: TYPE_NORMAL
- en: 'The observers all give back a disposer function when you set them up. We have
    already seen this with the return values of `autorun()`, `reaction()`, or `when()`,
    which are disposer functions. On calling this disposer, the observer will be removed
    from the connected observables:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00040.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: During the execution of a reaction, only the existing observables are considered
    for tracking. However, it is possible that in a different run of the same reaction,
    some new observables are referenced. This is possible when a piece of code executes
    that was originally skipped due to some branching logic. Since new observables
    can be discovered while tracking a reaction, MobX keeps a check on the observables.
    New ones are added to the list of observables, while ones that are not used anymore
    will be removed. Removal of an observable doesn't happen immediately; they are
    queued up for removal after completion of the current reaction.
  prefs: []
  type: TYPE_NORMAL
- en: In this interplay between observables and reactions, the **actions** seem to
    be missing sorely. Well, not entirely. They do have a role to play. As mentioned
    several times in this book, actions are the recommended way to mutate observables.
    An action creates a transaction boundary and ensures all change notifications
    are fired only after completion. These actions can also be nested, resulting in
    a nested transaction. It is only when the top most *action* (or transaction) completes
    that the notifications will be fired. This also means that none of the *reactions*
    run while a transaction (nested or not) is in progress. MobX treats this transaction
    boundary as a **batch** and keeps track of the nesting internally. During a batch,
    all reactions will be queued up and executed at the end of the top-most batch.
  prefs: []
  type: TYPE_NORMAL
- en: When the queued up reactions execute, the cycle begins yet again. It will track
    observables, link them with the executing derivation, add any newly discovered
    observables, and queue up any reactions that are found during a batch. If there
    are no more batches, MobX deems itself to be stable and goes back to waiting for
    any observable mutations.
  prefs: []
  type: TYPE_NORMAL
- en: An interesting thing about reactions is that they could re-trigger themselves.
    Inside a reaction, you can read an observable and also fire an action that mutates
    that same *observable*. This may happen within the same block of code or indirectly
    via some function invoked from the reaction. The only requirement is that it should
    ***not*** lead to an infinite loop. MobX expects the reaction to become stable
    as quickly as possible.
  prefs: []
  type: TYPE_NORMAL
- en: If, for some reason, it takes more than **100** iterations and there is no stability,
    MobX will bail out with an exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'Reaction doesn''t converge to a stable state after 100 iterations. There is
    probably a cycle in the reactive function: `Reaction[Reaction@14]`'
  prefs: []
  type: TYPE_NORMAL
- en: Without the upper limit of 100 iterations, it would cause a stack overflow at
    runtime, making it much harder to track down its cause. MobX protects you from
    this predicament by guarding with the **100-iterations** limit. Note that it does
    not forbid you from cyclic dependencies but assists in identifying the code that
    is causing the instability (infinite loop).
  prefs: []
  type: TYPE_NORMAL
- en: A simple snippet that is unstable even after *100 iterations of the reaction*
    is shown as follows. This reaction observes the `counter` observable, and also
    modifies it by invoking the `spinLoop()` action. This causes the reaction to run
    again and again until it gives up after *100 iterations:*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As you can tell, executing a derivation or reaction is crucial for establishing
    the link between *observables* and *observers*. Without a *reaction*, there is
    no life in the reactivity system. It would just be a collection of observables.
    You could still fire actions and mutate them, but it would still be very static
    and non-reactive. Reactions (Derivations) complete the triad of *Observables-Actions-Reactions*
    and pump life into this reactive system.
  prefs: []
  type: TYPE_NORMAL
- en: Ultimately, **reactions** are the ones that *pull values* from your state and
    fire up the whole reactive process!
  prefs: []
  type: TYPE_NORMAL
- en: Exception handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Handling errors is considered an essential part of MobX reactions. In fact,
    it provides an option to supply an error handler (`onError`) for `autorun()`,
    `reaction()`, and `when()`, and in the case of `computed()`, it will throw the
    error back to you any time the computed value is read. In each of these cases,
    MobX continues to work as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Internally, MobX puts additional `try-catch` blocks around the execution of
    reactions and derivations. It will catch the errors thrown inside these blocks
    and propagate them back to you via the `onError` handlers or when a computed value
    is read. This behavior ensures that you can continue running your reactions and
    take any recovery measures inside the `onError` handlers.
  prefs: []
  type: TYPE_NORMAL
- en: 'If there is no `onError` handler specified for a reaction, MobX also has a
    global `onReactionError()` handler that will be called for any exception thrown
    in a reaction. You can register a listener for these global reaction errors to
    do things like error monitoring, reporting, and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '`onReactionError(handler-function: (error, reaction) => { })`'
  prefs: []
  type: TYPE_NORMAL
- en: '**handler-function**: A function accepting the error and the instance of a
    reaction as its arguments.'
  prefs: []
  type: TYPE_NORMAL
- en: Before a global `onReactionError` handler is called, MobX first checks for an
    `onError` handler for the reaction that is failing. It's only when that doesn't
    exist that the global handler is invoked.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if for some reason you don''t want this behavior where MobX catches the
    exception and reports it on a global `onReactionError` handler, you have a way
    out. By configuring MobX with `configure({ disableErrorBoundaries: true })`, you
    will get a regular exception thrown at the *point of failure*. You will now be
    expected to handle it via a *try-catch* block right inside the reaction.'
  prefs: []
  type: TYPE_NORMAL
- en: '`configure({ disableErrorBoundaries: true })` shouldn''t be used in normal
    circumstances as leaving exceptions unchecked can corrupt the internal state of
    MobX. However, turning on this configuration can help you in debugging since it
    will make the exception uncaught. Youcan now pause your debugger on the exact
    statement that causes the exception.'
  prefs: []
  type: TYPE_NORMAL
- en: The API layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is the consumer facing, outermost layer of MobX and builds on the foundations
    mentioned thus far. The prominent APIs that stand out in this layer include the
    ones seen throughout this book: `observable()`, `observable.box()`, `computed()`,
    `extendObservable()`, `action()`, `reaction()`, `autorun()`, `when()`, and others.
    Of course, we also have the decorators, such as `observable.ref`, `observable.deep`,
    `observable.shallow`, `action.bound`, `computed.struct`, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: The core data structures such as `ObservableObject`, `ObservableArray`, and
    `ObservableMap` rely on the `ObservableValue` to store all of their values.
  prefs: []
  type: TYPE_NORMAL
- en: 'For an `ObservableObject...`:'
  prefs: []
  type: TYPE_NORMAL
- en: A key-value pair has its value backed by an `ObservableValue`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every computed property, as expected, is backed by a `ComputedValue`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `keys()` method of an *ObservableObject* is also backed by an `Atom`. This
    is needed as you may be iterating on the `keys()` in one of your reactions. When
    a key gets added or removed, you want your reactions to execute again. This atom
    for `keys()` fires the `reportChanged()` for additions and removals and ensures
    that the connected reactions are re-executed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For an `ObservableArray...`:'
  prefs: []
  type: TYPE_NORMAL
- en: Every indexed value is backed by `ObservableValue`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `length` property is explicitly backed by an `Atom`. Note that *ObservableArray*
    has the same interface as JavaScript arrays. In ***MobX 4***, it was an array-like
    data structure, which has become a real JS Array in ***MobX 5*** (backed by an
    ES6 *Proxy*). The reads and writes on `length` will result in `reportObserved()`
    and `reportChanged()` being called on the atom. In fact, when any of the methods
    like *map*, *reduce*, *filter*, and so on are used, the backing `Atom` is used
    to fire `reportObserved()`. For any mutating methods like *splice*, *push*, *pop*,
    *shift*, and so on, the `reportChanged()` is fired. This ensures the connected
    reactions fire as expected.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For an `ObservableMap...`:'
  prefs: []
  type: TYPE_NORMAL
- en: A *key-value* pair has its value backed by an `ObservableValue`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Just like *ObservableObject*, it too maintains an instance of `Atom` for the
    `keys()` method. Any addition or removal of keys is notified with a `reportChanged()`
    on the atom. Calling the `keys()` method itself will fire the `reportObserved()`
    on the atom.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The collections in MobX, which are objects, arrays, and maps, are essentially
    collections of observable boxes (`ObservableValue`). They may be organized as
    a list or as a map, or combined to create complex structures.
  prefs: []
  type: TYPE_NORMAL
- en: All of these data structures also expose the `intercept()` and `observe()` methods
    that allows granular interception and observation of values. By building on the
    foundations of `Atom`, `ObservableValue`, and *derivations*, MobX gives you a
    powerful toolbox of APIs to build sophisticated state management solutions in
    your applications.
  prefs: []
  type: TYPE_NORMAL
- en: Transparent functional reactive programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MobX is considered a **Transparent functional reactive programming** (**TFRP**)
    system. Yes, too many adjectives in that line! Let's break it down word by word.
  prefs: []
  type: TYPE_NORMAL
- en: It is Transparent...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Connecting the *observables* to the *observers*, it allows the observers to
    react to changes in observables. This is a basic expectation we have from MobX
    and the way we establish these connections feels very intuitive. There is no explicit
    wiring besides the use of decorators and dereferencing observables inside the
    observer. Because of the low overhead in wiring, MobX becomes very *declarative*,
    where you express your intent without worrying about the machinery. The automatic
    connections established between the *observables* and *observers* enables the
    *reactive system* to function autonomously. This makes MobX a *transparent* system
    as the work of connecting observables with observers is essentially lifted away.
    The usage of an observable inside a reaction is enough to wire the two.
  prefs: []
  type: TYPE_NORMAL
- en: It is reactive...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This reactivity is also very fine-grained. The dependency tree of observables
    can be as simple as you need and also equally as deep. The interesting part is
    that you never worry about the complexity of wiring or the efficiency. MobX has
    a deep knowledge of your dependencies and ensures the efficiencies by reacting
    only when needed. There is no polling or excessive events being fired as the dependencies
    keep changing. Thus, MobX is also a very reactive system.
  prefs: []
  type: TYPE_NORMAL
- en: It is functional...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Functional** programming, as we know, is about leveraging the power of functions
    to perform data flow transformations. By using a variety of functional operators
    like map, reduce, filter, compose, and so on, we can apply transformations on
    *input data* and produce output values. The catch in the case of MobX is that
    the *input da*ta is an observable, a time *varying* value. MobX combines the qualities
    of a reactive system and ensures the functional -transformations are automatically
    applied when the input data (observable) changes. It does this in a transparent
    fashion, as discussed earlier, by establishing implicit connections between the
    observables and reactions.'
  prefs: []
  type: TYPE_NORMAL
- en: This combination of qualities makes MobX a TFRP system.
  prefs: []
  type: TYPE_NORMAL
- en: From the author's point of view, the *origins* of the acronymn TFRP has come
    from the following article: [https://github.com/meteor/docs/blob/version-NEXT/long-form/tracker-manual.md](https://github.com/meteor/docs/blob/version-NEXT/long-form/tracker-manual.md).
  prefs: []
  type: TYPE_NORMAL
- en: Value Oriented Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MobX is also about **Value Oriented Programming** (**VOP**), where you focus
    on the change in values, its dependencies, and its propagation across the reactive
    system. With VOP*,* you focus on *What are the connected values? * rather than
    the  *How are the values connected? *Its counterpart is **Event Oriented Programming**
    (**EOP**), where you focus on a stream of events to notify changes. Events only
    report what has happened with no notion of dependencies. It's at a lower level
    conceptually, compared to Value-Oriented-Programming.
  prefs: []
  type: TYPE_NORMAL
- en: VOP relies on events to do its job internally. When a value changes, events
    are raised to notify the change. The handlers for these events will then propagate
    the value to all listeners (***observers***) of that ***observable value***. This
    usually results in a reaction/derivation being invoked. Thus, reactions and derivations,
    which are the side effects of the value change, are at the tail-end of the value
    propagation event.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thinking in VOP raises the level of abstraction, bringing you closer to the
    domain that you are dealing with. Rather than worrying about the mechanism of
    value propagation, you just focus on establishing connections via observables,
    computed properties, and observers (reactions/derivations). This, as we know,
    is the triad of MobX: *Observables-Actions-Reactions*. This style of thinking
    is very ***declarative*** in nature: the *What versus How* of value changes. As
    you get more steeped into this mindset, many of the scenarios in state management
    become much more tenable. You will be amazed at the *simplicity, power, and efficiency*
    that this paradigm offers.'
  prefs: []
  type: TYPE_NORMAL
- en: If you do need to dive deeper into the eventing layer, MobX has the `intercept()`
    and `observe()` APIs. They allow you to hook into the events that are raised when
    observables are *added, updated, or deleted*. There is also the `fromStream()`
    and `toStream()` APIs from the `mobx-utils` npm package, which gives you a stream
    of events that are compatible with RxJS. These events don't participate in the
    MobX transaction (batching), are never queued up, and always fire immediately.
  prefs: []
  type: TYPE_NORMAL
- en: It is rare to use the eventing APIs in consumer code; they are mostly used by
    tools and utility functions such as `spy()`, `trace()`, and so on to give insight
    into the event layer of MobX.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With this under-the-hood peek at MobX, you can appreciate the power of the TFRP
    system, exposed with a surprisingly simple API. The layers of functionality, starting
    with the `Atoms`, wrapped by `ObservableValue`, with APIs and higher-level data
    structures, offer a comprehensive solution to model your domains.
  prefs: []
  type: TYPE_NORMAL
- en: Internally, MobX manages all the connections between the observables and observers
    (reactions/derivations). It is done automatically with minimal interference to
    your usual style of programming. As a developer, you write code that feels natural,
    with MobX lifting away the complexity of managing the reactive connections.
  prefs: []
  type: TYPE_NORMAL
- en: MobX is an open source project that has been battle-tested for various domains,
    accepted contributions from developers all over the world, and has been constantly
    maturing over the years. With this inside look at MobX, we sure hope to reduce
    the barriers to contributing to this powerful state management library.
  prefs: []
  type: TYPE_NORMAL
