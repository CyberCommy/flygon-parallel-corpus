- en: Docker Compose
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will be taking a look at another core Docker tool called
    Docker Compose, and also the currently in-development Docker App. We will break
    the chapter down into the following sections:'
  prefs: []
  type: TYPE_NORMAL
- en: Docker Compose introduction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our first Docker Compose application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker Compose YAML files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker Compose commands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker App
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As in previous chapters, we will continue to use our local Docker installations.
    Again, the screenshots in this chapter will be from my preferred operating system,
    macOS.
  prefs: []
  type: TYPE_NORMAL
- en: As before, the Docker commands we will be running will work on all three of
    the operating systems on which we have installed Docker so far. However, some
    of the supporting commands, which will be few and far between, may only apply
    to macOS and Linux-based operating systems.
  prefs: []
  type: TYPE_NORMAL
- en: A full copy of the code used in this chapter can be found at: [https://github.com/PacktPublishing/Mastering-Docker-Third-Edition/tree/master/chapter05](https://github.com/PacktPublishing/Mastering-Docker-Third-Edition/tree/master/chapter05).
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the Code in Action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://bit.ly/2q7MJZU](http://bit.ly/2q7MJZU)'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Docker Compose
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Chapter 1*, Docker Overview,* we discussed a few of the problems that Docker
    has been designed to solve. We explained how it addresses challenges such as running
    two applications side by side by isolating processes into a single container,
    meaning that you can run two entirely different versions of the same software
    stack, say PHP 5.6 and PHP 7, on the same host, as we did in [Chapter 2](55a49886-9299-4a9b-a3b6-241641a6c097.xhtml)*, Building
    Container Images*.
  prefs: []
  type: TYPE_NORMAL
- en: Towards the end of [Chapter 4](d1bc49d6-f8f8-4c0d-b094-695d42c09f88.xhtml)*,
    Managing Containers*, we launched an application that was made up of multiple
    containers rather than running the required software stack in a single container.
    The example application we started, Moby Counter, is written in Node.js and uses
    Redis as a backend to store key values, which, in our case, were the location
    of the Docker logos on screen.
  prefs: []
  type: TYPE_NORMAL
- en: This meant that we had to launch two containers, one for the application and
    one for Redis. While it was quite simple to do this as the application itself
    was quite basic, there are a number of disadvantages to manually launching single
    containers.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if I wanted a colleague to deploy the same application, I would
    have to pass them the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Okay, I could get away with losing the first two commands as the image will
    be pulled during the run if they haven't already pulled it, but as the application
    starts to get more complex, I will have to start passing on an ever-growing set
    of commands and instructions.
  prefs: []
  type: TYPE_NORMAL
- en: I would also have to make it clear that they would have to take into account
    the order in which the commands need to be executed. Furthermore, my notes would
    have to include details of any potential issues to support them through any problems—which
    could mean we find ourselves in a *worked is DevOps problem now* scenario, which
    we want to avoid at all costs.
  prefs: []
  type: TYPE_NORMAL
- en: While Docker's responsibility should end at creating the images and launching
    containers using these images, they saw this as a scenario that the technology
    is meant to stop us from finding ourselves in. Thanks to Docker, people no longer
    have to worry about inconsistencies in the environment they are launching their
    applications in as they can now be shipped in images.
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, back in July 2014, Docker purchased a small British start-up
    who offered two container-based products called Orchard Laboratories.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first of the two products was a Docker-based hosting platform: think of
    it as a hybrid of Docker Machine, which we will be looking at in a later chapter,
    and Docker itself. From a single command, `orchard`, you could launch a host machine
    and then proxy your Docker commands through to the newly launched host; for example,
    you would use the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: These would have launched a Docker host on Orchard's platform and then a Redis
    container.
  prefs: []
  type: TYPE_NORMAL
- en: The second product was an open source project called **Fig**. Fig lets you use
    a `YAML` file to define how you would like your multi-container application to
    be structured. It would then take the `YAML` file and automate the launch of the
    containers as defined. The advantage of this was that because it was a YAML file,
    it was straightforward for developers to start shipping `fig.yml` files alongside
    their Dockerfiles within their code bases.
  prefs: []
  type: TYPE_NORMAL
- en: Of these two products, Docker purchased Orchard Laboratories for Fig. After
    a short while, the Orchard service was discontinued, and, in February 2015, Fig
    became Docker Compose.
  prefs: []
  type: TYPE_NORMAL
- en: As part of our installation of Docker for Mac, Docker for Windows, and Docker
    on Linux in [Chapter 1](db23d482-1df4-41c2-af33-d38a98fc5a1c.xhtml)*, Docker Overview,*
    we installed Docker Compose, so rather than discussing what it does any further,
    let's try and bring up the two-container application we launched manually at the
    end of the last chapter using just Docker Compose.
  prefs: []
  type: TYPE_NORMAL
- en: Our first Docker Compose application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As already mentioned, Docker Compose uses a YAML file, typically named `dockercompose.yml`,
    to define what your multi-container application should look like. The Docker Compose
    representation of the two-container application we launched in [Chapter 4](d1bc49d6-f8f8-4c0d-b094-695d42c09f88.xhtml)*,
    Managing Containers*, is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Even without working through each of the lines in the file, it should be quite
    straightforward to follow along with what is going on. To launch our application,
    we simply change to the folder that contains your `docker-compose.yml` file and
    run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from the following Terminal output, a lot happened when it launched:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/4e69ce24-f7a6-4080-a784-5b049cc7c666.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, from the first few lines, Docker Compose did the following:'
  prefs: []
  type: TYPE_NORMAL
- en: It created a volume called `mobycounter_redis_data`, using the default driver
    as we defined at the end of the `docker-compose.yml` file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It created a network called `mobycounter_default` using the default network
    driver – at no point did we ask Docker Compose to do this. More on this in a minute.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It launched two containers, one called `mobycounter_redis_1` , and the second
    called `mobycounter_mobycounter_1`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You may have also spotted the Docker Compose namespace in our multi-container
    application has prefixed everything with `mobycounter`. It took this name from
    the folder our Docker Compose file was being stored in.
  prefs: []
  type: TYPE_NORMAL
- en: Once launched, Docker Compose attached to `mobycounter_redis_1` and `mobycounter_mobycounter_1`
    and streamed the output to our Terminal session. On the Terminal screen, you can
    see both `redis_1` and `mobycounter_1` starting to interact with each other.
  prefs: []
  type: TYPE_NORMAL
- en: When running Docker Compose using `docker-compose up`, it will run in the foreground.
    Pressing *Ctrl* + *C* will stop the containers and return access to your Terminal
    session.
  prefs: []
  type: TYPE_NORMAL
- en: Docker Compose YAML file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we look at using Docker Compose more, we should have a deeper dive into
    `docker-compose.yml` files as these are the heart of Docker Compose.
  prefs: []
  type: TYPE_NORMAL
- en: YAML is a recursive acronym that stands for **YAML Ain't Markup Language**.
    It is used by a lot of different applications for both configuration and also
    for defining data in a human-readable structured data format. The indentation
    you see in the examples is very important as it helps to define the structure
    of the data.
  prefs: []
  type: TYPE_NORMAL
- en: Moby counter application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `docker-compose.yml` file we used to launch our multi-container application
    is split into three separate sections.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first section simply specifies which version of the Docker Compose definition
    language we are using; in our case, as we are running a recent version of Docker
    and Docker Compose, we are using version 3:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The next section is where our containers are defined; this section is the services
    section. It takes the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In our example, we defined two containers. I have separated them out to make
    it easy to read:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The syntax for defining the service is close to how you would launch a container
    using the `docker container run` command. I say close because although it makes
    perfect sense when you read the definition, it is only on closer inspection that
    you realize there is actually a lot of difference between the Docker Compose syntax
    and the `docker container run` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, there are no flags for the following when running the `docker
    container run` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '`image:` This tells Docker Compose which image to download and use. This does
    not exist as an option when running `docker container run` on the command line
    as you can only run a single container; as we have seen in previous chapters,
    the image is always defined toward the end of the command without the need for
    a flag being passed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`volume:` This is the equivalent of the `--volume flag`, but it can accept
    multiple volumes. It only uses the volumes that are declared in the Docker Compose
    YAML file; more on that in a moment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`depends_on:` This would never work as a `docker container run` invocation
    because the command is only targeting a single container. When it comes to Docker
    Compose, `depends_on` is used to help build some logic into the order your containers
    are launched in. For example, only launch container B when container A has successfully
    started.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ports:` This is basically the `--publish` flag, which accepts a list of ports.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The only part of the command we used that has an equivalent flag when running
    `docker container run` is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`restart:` This is the same as using the `--restart` flag and accepts the same
    input.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The final section of our Docker Compose YAML file is where we declare our volumes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Example voting application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned already, the Docker Compose file for the Moby counter application
    is quite a simple example. Let's take a look at a more complex Docker Compose
    file and see how we can introduce building containers and multiple networks.
  prefs: []
  type: TYPE_NORMAL
- en: In the repository for this book, you will find a folder in the `chapter05` directory
    called `example-voting-app`. This is a fork of the voting application from the
    official Docker sample repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, if you were to open up the `docker-compose.yml` file, the application
    is made up of five containers, two networks, and a single volume. Ignore the other
    files, for now; we will look at some of these in future chapters. Let''s walk
    through the `docker-compose.yml` file as there is a lot going on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, it starts simply enough by defining the version and then it
    starts to list the services. Our first container is called `vote`; it is a Python
    application that allows users to submit their vote. As you can see from the following
    definition, rather than downloading an image, we are actually building an image
    from scratch by using `build` instead of the `image` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The build instruction here tells Docker Compose to build a container using the
    Dockerfile, which can be found in the `./vote` folder. The Dockerfile itself is
    quite straightforward for a Python application.
  prefs: []
  type: TYPE_NORMAL
- en: Once the container launches, we are then mounting the `./vote` folder from our
    host machine into the container, which is achieved by passing the path of the
    folder we want to mount and where within the container we would like it mounted.
  prefs: []
  type: TYPE_NORMAL
- en: We are telling the container to run the `python app.py` when it launches. We
    are mapping port `5000` on our host machine to port `80` on the container, and
    finally, we are further attaching two networks to the container, one called `front-tier`
    and the second called `back-tier`.
  prefs: []
  type: TYPE_NORMAL
- en: The `front-tier` network will have the containers that have to have ports mapped
    to the host machine; the `back-tier` network is reserved for containers that do
    not need their ports to be exposed and acts as a private, isolated network.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next up, we have another container that is connected to the `front-tier` network.
    This container displays the results of the vote. The `result` container contains
    a Node.js application that connects to the PostgreSQL database, which we will
    get to in a moment, and displays the results in real time as votes are cast in
    the `vote` container. Like the `vote` container, the image is built locally using
    a `Dockerfile` that can be found in the `./result` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We are exposing port `5001`, which is where we can connect to see the results.
    The next, and final, application container is called `worker`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The worker container runs a .NET application whose only job is to connect to
    Redis and register each vote by transferring it into a PostgreSQL database running
    on a container called `db`. The container is again built using a `Dockerfile`,
    but this time, rather than passing the path to the folder where the `Dockerfile`
    and application are stored, we are using context. This sets the working directory
    for the docker build and also allows you to define additional options such as
    labels and changing the name of the `Dockerfile`.
  prefs: []
  type: TYPE_NORMAL
- en: As this container is doing nothing other than connecting to `redis` and the
    `db` container, it does not need any ports exposed as it has nothing connecting
    directly to it; it also does not need to communicate with either of the containers
    running on the `front-tier` network, meaning we just have to add the `back-tier`
    network.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we now have the `vote` application, which registers the votes from the
    end users and sends them to the `redis` container, where the vote is then processed
    by the `worker` container. The service definition for the `redis` container looks
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This container uses the official Redis image and is not built from a Dockerfile;
    we are making sure that port `6379` is available, but only on the `back-tier`
    network. We are also specifying the name of the container, setting it to `redis`
    by using `container_name`. This is to avoid us having to make any considerations
    on the default names generated by Docker Compose within our code since, if you
    remember, Docker Compose uses the folder name to launch the containers in their
    own application namespace.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next and final container is the PostgreSQL one which we have already mentioned called `db`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, it looks quite similar to the `redis` container in that we are
    using the official image; however, you may notice that we are not exposing a port
    as this is a default option in the official image. We are also specifying the
    name of the container.
  prefs: []
  type: TYPE_NORMAL
- en: 'As this is where our votes will be stored, we are creating and mounting a volume
    to act as persistent storage for our PostgreSQL database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, finally, here are the two networks we have been speaking about:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Running `docker-compose up` gives a lot of feedback on what is happening during
    the launch; it takes about 5 minutes to launch the application for the first time.
    If you are not following along and launching the application yourself, what follows
    is an abridged version of the launch.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may get an error that states `npm ERR! request to https://registry.npmjs.org/nodemon
    failed, reason: Hostname/IP doesn''t match certificate''s altnames`. If you do,
    then run the following command `echo "104.16.16.35 registry.npmjs.org" >> /etc/hosts` as
    a user with privileges to write to `/etc/hosts`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by creating the networks and getting the volume ready for our containers
    to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We then build the `vote` container image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Once this `vote` image has been built, the `worker` image is constructed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Then the `redis` image is pulled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This is followed by the PostgreSQL image for the `db` container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now it is time for the big one; the building of the `result` image. Node.js
    is quite verbose, so you will get quite a bit of output being printed to the screen
    as the `npm` sections of the `Dockerfile` are executed; in fact, there are over
    250 lines of output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The `result` part of the application can be accessed at `http://localhost:5001`.
    By default, there are no votes and it is split 50/50:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/4a22ffa8-8c43-4c3b-a426-6219b0ee85a0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `vote` part of the application can be found at `http://localhost:5000`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/f8de0f3e-20dd-45db-ae5f-7488b207f103.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Clicking on either **CATS** or **DOGS** will register a vote; you should be
    able to see this logged in the Docker Compose output in your Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/b3a3eb0d-f32c-46be-8b36-0257af71fc63.png)'
  prefs: []
  type: TYPE_IMG
- en: 'There are a few errors, as the Redis table structure is only created when the
    vote application registers the first vote; once a vote has been cast, the Redis
    table structure will be created and the worker container will take that vote and
    process it by writing to the `db` container. Once the vote has been cast, the
    `result` container will update in real time:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/bbd70927-10dc-48ab-ae1a-cada61daea24.png)'
  prefs: []
  type: TYPE_IMG
- en: We will be looking at the Docker Compose YAML files again in the upcoming chapters
    when we look at launching both Docker Swarm stacks and Kubenetes clusters. For
    now, let's get back to Docker Compose and look at some of the commands we can
    run.
  prefs: []
  type: TYPE_NORMAL
- en: Docker Compose commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are over halfway through the chapter and the only Docker Compose command
    we have run is `docker-compose up`. If you have been following along and you run
    `docker container ls -a`, you will see something similar to the following Terminal
    screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/5d363680-67d7-437f-bd51-5dbf01bffb15.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, we have a lot of containers with the status of `EXITED`. This
    is because when we used *Ctrl* + *C* to return to our Terminal, the Docker Compose
    containers were stopped.
  prefs: []
  type: TYPE_NORMAL
- en: Choose one of the Docker Compose applications and change to the folder that
    contains the `docker-compose.yml` file, and we will work through some more Docker
    Compose commands. I will be using the **Example Vote** application.
  prefs: []
  type: TYPE_NORMAL
- en: Up and PS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first one is `docker-compose up`, but this time, we will be adding a flag.
    In your chosen application folder, run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This will start your application back up, this time in detached mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/0b96c910-8548-4bf7-ac18-d2d5daf3b40f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once control of your Terminal is returned, you should be able to check that
    the containers are running using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from the following Terminal output, all of the containers have
    the state of `Up`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/bb818478-bc68-4381-84be-11090fbd2b00.png)'
  prefs: []
  type: TYPE_IMG
- en: When running these commands, Docker Compose will only be aware of the containers
    defined in the service section of your `docker-compose.yml` file; all other containers
    will be ignored as they don't belong to our service stack.
  prefs: []
  type: TYPE_NORMAL
- en: Config
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Running the following command will validate our `docker-compose.yml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'If there are no issues, it will print a rendered copy of your Docker Compose
    YAML file to screen; this is how Docker Compose will interpret your file. If you
    don''t want to see this output and just want to check for errors, then you can
    run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This is shorthand for `--quiet`. If there are any errors, which the examples
    we have worked through so far shouldn''t have, they will be displayed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Pull, build, and create
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next two commands will help you prepare to launch your Docker Compose application.
    The following command will read your Docker Compose YAML file and pull any of
    the images it finds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The following command will execute any build instructions it finds in your
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: These commands are useful when you are first defining your Docker Compose-powered
    application and want to test without launching your application. The `docker-compose
    build` command can also be used to trigger a build if there are updates to any
    of the Dockerfiles used to originally build your images.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `pull` and `build` command only generate/pull the images needed for our
    application; they do not configure the containers themselves. For this, we need
    to use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This will create but not launch the containers. In the same way that the `docker
    container create` command does, they will have an exited state until you start
    them. The `create` command has a few useful flags you can pass:'
  prefs: []
  type: TYPE_NORMAL
- en: '`--force-recreate`: This recreates the container even if there is no need to
    as nothing within the configuration has changed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--no-recreate`: This doesn''t recreate a container if it already exists; this
    flag cannot be used with the preceding flag'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--no-build`: This doesn''t build the images, even if an image that needs to
    be built is missing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--build`: This builds the images before creating the containers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Start, stop, restart, pause, and unpause
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following commands work exactly in the same way as their docker container
    counterparts, the only difference being that they effect change on all of the
    containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'It is possible to target a single service by passing its name; for example,
    to `pause` and `unpause` the `db` service, we would run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Top, logs, and events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next three commands all give us feedback on what is happening within our
    running containers and Docker Compose.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command, like its docker container counterpart, displays information
    on the processes running within each of our Docker Compose-launched containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from the following Terminal output, each container is split
    into its own section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/47672e5f-ef23-41ba-96ac-f09431f5030f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you would like to see just one of the services, you simply have to pass
    its name when running the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The next command streams the `logs` from each of the running containers to
    screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Like the `docker container` command, you can pass flags such as `-f` or `--follow`
    to keep the stream flowing until you press *Ctrl* + *C*. Also, you can stream
    the logs for a single service by appending its name to the end of your command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/ce0c8f42-1208-4a13-b767-c02b3bb462ef.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `events` command again works like the docker container version; it streams
    events, such as the ones triggered by the other commands we have been discussing,
    in real time. For example, run this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Running `docker-compose pause` in a second terminal window gives the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/332e23d6-bc34-4a7e-8e48-c1b910707a23.png)'
  prefs: []
  type: TYPE_IMG
- en: 'These two commands run similar to their docker container equivalents. Run the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'This will launch a new process in the already running `worker` container and
    ping the `db` container three times, as seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/0647960c-03ed-4c9d-9e24-259c4e0ab85f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `run` command is useful if you need to run a containerized command as a
    one-off within your application. For example, if you use a package manager such
    as composer to update the dependencies of your project that is stored on a volume,
    you could run something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This would run the `composer` container with the `install` command and mount
    the `data_volume` to `/app` within the container.
  prefs: []
  type: TYPE_NORMAL
- en: Scale
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `scale` command will take the service you pass to the command and scale
    it to the number you define; for example, to add more worker containers, I just
    need to run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'However, this actually gives the following warning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'What we should now be using is the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: While the `scale` command is in the current version of Docker Compose, it will
    be removed from future versions of the software.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will notice that I chose to scale the number of worker containers. There
    is a good reason for this as you will see for yourself if you try running the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'You will notice that while Docker Compose creates the additional two containers,
    they fail to start with the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/4a6ae0cb-5db8-4bf8-99cc-2cc1c667be78.png)'
  prefs: []
  type: TYPE_IMG
- en: That is because we cannot have three individual containers all trying to map
    to the same port. There is a workaround for this and we will look at that in more
    detail in a later chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Kill, rm, and down
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The three Docker Compose commands we are finally going to look at are the ones
    that remove/terminate our Docker Compose application. The first command stops
    our running containers by immediately stopping running container processes. This
    is the `kill` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Be careful when running this as it does not wait for containers to gracefully
    stop, such as when running `docker-compose stop`, meaning that using the `docker-compose
    kill` command may result in data loss.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next up is the `rm` command; this removes any containers with the state of
    `exited`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have the `down` command. This, as you might have already guessed,
    has the opposite effect of running `docker-compose up`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'That will remove the containers and the networks created when running `docker-compose
    up`. If you want to remove everything, you can do so by running the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'This will remove all of the containers, networks, volumes, and images (both
    pulled and built) when you ran the `docker-compose up` command; this includes
    images that may be in use outside of your Docker Compose application. There will,
    however, be an error if the images are in use, and they will not be removed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/08087e2a-53d9-4ff6-829c-6133c8470532.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see from the preceding output, there is a container using the `redis`
    image, the Moby counter application, so it was not removed. However, all other
    images used by the Example Vote application are removed, both the ones built as
    part of the initial `docker-compose up` , and the ones downloaded from Docker
    Hub.
  prefs: []
  type: TYPE_NORMAL
- en: Docker App
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we start this section, I should issue the following warning:'
  prefs: []
  type: TYPE_NORMAL
- en: '*The feature we are going to discuss is very much an experimental one. It is
    in its very early stages of development and should not be considered any more
    than a preview of an upcoming feature.*'
  prefs: []
  type: TYPE_NORMAL
- en: Because of this, I am only going to cover the installation of the macOS version.
    However, before we install it, lets discuss what exactly is meant by a Docker
    App.
  prefs: []
  type: TYPE_NORMAL
- en: While Docker Compose files are really useful when it comes to sharing your environment
    with others, you may have noticed that there is one quite crucial element we have
    been missing so far in this chapter, and that is the ability to actually distribute
    your Docker Compose files in a similar way to how you can distribute your Docker
    images.
  prefs: []
  type: TYPE_NORMAL
- en: Docker has acknowledged this and is currently working on a new feature called
    Docker App, which it hopes will fill this gap.
  prefs: []
  type: TYPE_NORMAL
- en: '**Docker App** is a self-contained binary that helps you to create an application
    bundle that can be shared via Docker Hub or a Docker Enterprise Registry.'
  prefs: []
  type: TYPE_NORMAL
- en: I would recommend checking the GitHub projects **R****eleases** page (you can
    find the link in the *Further reading* section) to make sure you are a using the
    latest version. If the version is later than 0.4.1, you will need to replace the
    version number in the following command.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install Docker App on macOS, you can run the following commands, starting
    with setting the version to download:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that you have the correct version, you can download it and put it in place
    using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Once in place, you should be able to run the following command that will print
    some basic information about binary on screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The full output of the preceding commands can be seen here for those not following
    along:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/9c5da96b-a744-4c5f-9cb5-3e853db7aa53.png)'
  prefs: []
  type: TYPE_IMG
- en: 'There is a slight change to the `docker-compose.yml` file we will be using.
    The version needs to be updated to `3.6` rather than just `3`. Not doing this
    will result in the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The command we need to run, and which also generates the preceding error, is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: This command takes our `docker-compose.yml` file and embeds it in a `.dockerapp`
    file. Initially, there will be quite a few comments in the file that detail what
    changes you need to make before moving on to the next steps. I have left an unaltered
    version of the file in the repository, in the `chapter5/mobycounter-app` folder
    called `mobycounter.dockerapp.original`.
  prefs: []
  type: TYPE_NORMAL
- en: 'An edited version of the `mobycounter.dockerapp` file can be found here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, it split into three sections; the first contains metadata about
    the application, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Version`: This the version of the app that will be published on Docker Hub'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Name`: The name of the application as it will appear on Docker Hub'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Description`: A short description of the application'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Namespace`: This is typically your Docker Hub username or an organisation
    you have access to'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Maintainers`: A list of maintainers for the application'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second section contains our Docker Compose file. You may notice that a few
    of the options have been replaced with variables. In our example, I have replaced
    port `8080` with `${port}` . The default value for the `port` variable is defined
    in the final section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the `.dockerapp` file is complete, you can run the following command to
    save the Docker App as an image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'You can view just the Docker Apps you have active on your host by running this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'As the Docker App is mostly just a bunch of metadata wrapped in a standard
    Docker image, you can also see it by running the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are not following along with this part, you can see the results in the
    terminal output here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/b63c6b9b-a8dd-40fa-9651-068f329248e4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Running the following command gives an overview of the Docker App, in much
    the same way you can use `docker image inspect` to find out details on how the
    image was built:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from the following terminal output, running the command using
    `docker-app inspect` rather than `docker image inspect` gives a much more friendly
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/81756d0f-6074-4664-8738-faf34d524d47.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that we have our finished application, we need to push it to Docker Hub.
    To do this, simply run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '![](Images/eced72f8-ac1c-4291-a9a1-ff80917c217c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This means that our application is now published on Docker Hub:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/449dc815-8dcf-408d-a7b7-fad918ab0dd0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'So how do you get the Docker App? First of all, we need to remove the local
    image. To do this, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Once gone, move to a different directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s download the Docker App, make a change to the port, and start it
    up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, for those not following along, the terminal output of the preceding
    command can be found here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/5d14eae8-47a2-4f33-92d7-e7ad8427c401.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, without having to even manually download the Docker App image,
    we have our application up and running. Going to `http://localhost:9090/` should
    present you with the screen that invites you to click to add logos.
  prefs: []
  type: TYPE_NORMAL
- en: As per a normal foregrounded Docker Compose app, press *Ctrl* + *C* to return
    to your terminal.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can run the following commands to interact and terminate your app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: There is more functionality within Docker App. However, we are not quite ready
    to go into further details. We will return to Docker App in [Chapter 8](1c5ca271-e40d-48c9-9fb2-c50e9535953b.xhtml)*,
    Docker* *Swarm,* and [Chapter 9](d3b2dadf-ed17-460b-8d06-ac7edc133ba6.xhtml)*,
    Docker and Kubernetes*.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned at the top of this section, this feature is in its early stages
    of development and it is possible that the commands and functionality we have
    discussed so far may change in the future. But, even at this early stage, I hope
    you can see the advantages of Docker App and how it is building on the solid foundations
    laid by Docker Compose.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I hope you have enjoyed this chapter on Docker Compose, and I hope that like
    I did, you can see that it has evolved from being an incredibly useful third-party
    tool to an extremely important part of the core Docker experience.
  prefs: []
  type: TYPE_NORMAL
- en: Docker Compose introduces some key concepts in how you should approach running
    and managing your containers. We will be taking these concepts one step further
    in [Chapter 8](https://cdp.packtpub.com/mastering_docker___thirdedition/wp-admin/post.php?post=28&action=edit#post_31)*,
    Docker** Swarm,* and [Chapter 9](https://cdp.packtpub.com/mastering_docker___thirdedition/wp-admin/post.php?post=28&action=edit#post_32)*,
    Docker and Kubernetes*.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to move away from Linux-based containers and
    take a whistle-stop tour of Windows containers.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Docker Compose files use which open source format?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In our initial Moby counter Docker Compose file, which was the only flag that
    works exactly the same as its Docker CLI counterpart?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True or false: You can only use images from the Docker Hub with your Docker
    Compose files?'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By default, how does Docker Compose decide on the namespace to use?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which flag do you add to docker-compose up to start the containers in the background?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the best way to run a syntax check on your Docker Compose files?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Explain the basic principle about how Docker App works.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For details on Orchard Laboratories, see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Orchard Laboratories website: [https://www.orchardup.com/](https://www.orchardup.com/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Orchard Laboratories joins Docker: [https://blog.docker.com/2014/07/welcoming-the-orchard-and-fig-team](https://blog.docker.com/2014/07/welcoming-the-orchard-and-fig-team)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For more information on the Docker App project, see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: GitHub Repository: [http://github.com/docker/app/](http://github.com/docker/app/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Releases page – [https://github.com/docker/app/releases](https://github.com/docker/app/releases)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally, here are some further links to a number of other topics that we have
    covered:'
  prefs: []
  type: TYPE_NORMAL
- en: YAML Project home page: [http://www.yaml.org/](http://www.yaml.org/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker Sample Repository: [https://github.com/dockersamples/](https://github.com/dockersamples/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
