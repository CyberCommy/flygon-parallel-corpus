- en: Chapter 3. Using Loops and the sleep Command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter shows how to use loops to perform iterative operations. It also
    shows how to create a delay in a script. The reader will learn how to use loops
    and the sleep command in a script.
  prefs: []
  type: TYPE_NORMAL
- en: 'Topics covered in this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Standard `for`, `while`, and `until` loops.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nesting of loops, and how not to get confused.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduce the `sleep` command and how it is used to cause a delay in a script.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Go over a common pitfall of using `sleep`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using loops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most important features of any programming language is the ability
    to perform a task, or tasks, a number of times and then stop when an ending condition
    is met. This is accomplished by using a loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next section shows an example of a very simple `while` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 3 - Script 1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'And here is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Chapter 3 - Script 1](img/B07040_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We start by setting variable `x` to `1`. The `while` statement checks to see
    if `x` is less than or equal to `10` and if so, runs the commands between the
    `do` and `done` statements. It will continue to do this until `x` equals `11`,
    in which case the lines after the done statement are then run.
  prefs: []
  type: TYPE_NORMAL
- en: Run this on your system. It is very important to understand this script so that
    we can move on to more advanced loops.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at another script in the next section—see if you can determine what
    is wrong with it.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 3 - Script 2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Feel free to skip the running of this one unless you really want to. Look carefully
    at the `while` test. It says while `x` is greater than or equal to `0`, run the
    commands inside the loop. Is `x` ever going to not meet this condition? No, it
    is not, and this is what is known as an infinite loop. Don't worry; you can still
    end the script by pressing *Ctrl* + *C* (hold down the *Ctrl* key and press *C*).
    This will terminate the script.
  prefs: []
  type: TYPE_NORMAL
- en: I wanted to cover infinite loops right away as you will almost certainly do
    this from time to time, and I wanted you to know how to terminate the script when
    it happens. I certainly did this a few times when I was first starting out.
  prefs: []
  type: TYPE_NORMAL
- en: Okay let's do something more useful. Suppose you are starting a new project
    and need to create some directories on your system. You could do it one command
    at a time, or use a loop in a script.
  prefs: []
  type: TYPE_NORMAL
- en: We'll a look at this in *Script 3*.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 3 - Script 3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This simple script assumes you are starting at the base directory. When run
    it will create directories `chapter 1` through `chapter 10` and then proceed to
    the end.
  prefs: []
  type: TYPE_NORMAL
- en: When running scripts that make changes to your computer, it is a good idea to
    make sure the logic is correct before running it for real. For example, before
    running this I commented out the `mkdir` line. I then ran the script to make sure
    it stopped after it displayed that `x` was equal to `10`. I then uncommented the
    line and ran it for real.
  prefs: []
  type: TYPE_NORMAL
- en: Screen manipulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll see another script in the next section that uses a loop to put text
    on the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 3 - Script 4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Before executing this script run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If the number of lines in that terminal is not displayed run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Then proceed to run the script. The following is the output on my system when
    run with `script4` `Linux`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Chapter 3 - Script 4](img/B07040_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Okay, so I agree this might not be terribly useful, but it does show a few things.
    The `LINES` env var contains the current number of lines (or rows) in the current
    terminal. This can be useful for limiting output in more complex scripts and that
    will be shown in a later chapter. This example also shows how the screen can be
    manipulated in a script.
  prefs: []
  type: TYPE_NORMAL
- en: If you needed to export the `LINES` variable, you may want to put it in your
    `.bashrc` file and re-source it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll take a look at another script in the next section:'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 3 - Script 5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This is similar to *Script 4* in that it shows how to display output within
    the confines of the terminal. Note, you may have to export the `COLUMNS` env var
    like we did with the `LINES` var.
  prefs: []
  type: TYPE_NORMAL
- en: You probably noticed something a little different in this script. There is a
    `while` statement inside a `while` statement. This is called a nested loop and
    is used very frequently in programming.
  prefs: []
  type: TYPE_NORMAL
- en: We start by declaring `row=1` and then begin the outer `while` loop. The `col`
    var is then set to `1` and then the inner loop is started. This inner loop is
    what displays the character on each column of the line. When the end of the line
    is reached, the loop ends and the `echo` statement outputs a carriage return.
    The `row` var is incremented, and then the process starts again. It ends after
    the last line.
  prefs: []
  type: TYPE_NORMAL
- en: By using the `LINES` and `COLUMNS` env vars only the actual screen is written
    to. You can test this by running the program and then expanding the terminal.
  prefs: []
  type: TYPE_NORMAL
- en: 'When using nested loops it can be easy to get mixed up about what goes where.
    Here is something I try to do every time. When I first realize a loop is going
    to be needed in a program (which can be a script, C, or Java, and so on), I code
    the loop body first like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This way I don''t forget the `done` statement and it''s also lined up correctly.
    If I then need another loop I just do it again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: You can nest as many loops as you need.
  prefs: []
  type: TYPE_NORMAL
- en: Indenting your code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is probably a good time to talk about indenting. In the past (that is,
    30+ years ago) everyone used a text editor with a mono-spaced font to write their
    code and so it was relatively easy to keep everything lined up with just a one
    space indent. Later, when people started using word processors with a variable
    pitched font, it became harder to see the indentation and so more spaces (or tabs)
    were used. My suggestion is to use what you feel most comfortable with. However,
    with that said you may have to learn to read and use whatever code style that
    is in place for your company.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far we have only talked about the `while` statement. Now let''s look at
    an `until` loop in the next section:'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 3 - Script 6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Chapter 3 - Script 6](img/B07040_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Take a look at this script. The output from both loops is the same; however,
    the conditions are the opposite. The first loop continues while the condition
    is true, the second loop continues until the condition is true. A not-so-subtle
    difference so be on the watch for that.
  prefs: []
  type: TYPE_NORMAL
- en: Using the for statement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another way to loop is to use the `for` statement. It is commonly used when
    working with files and other lists. The general syntax of a `for` loop is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The list can be a collection of strings, or a filename wildcard, and so on.
    We can take a look at this in the example given in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 3 - Script 7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'And the output on my system. This is my `chap3` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Chapter 3 - Script 7](img/B07040_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The next script shows how the `for` statement can be used with files:'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 3 - Script 8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Chapter 3 - Script 8](img/B07040_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There are a few other things you can do with the `for` statement, consult the
    `man` page of Bash for more information.
  prefs: []
  type: TYPE_NORMAL
- en: Leaving a loop early
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes when you are coding a script, you encounter a situation where you
    would like to exit the loop early, before the ending condition is met. This can
    be accomplished using the `break` and `continue` commands.
  prefs: []
  type: TYPE_NORMAL
- en: Here is a script that shows these commands. I am also introducing the `sleep`
    command which will be talked about in detail in the next script.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 3 - Script 9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the output from my system:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Chapter 3 - Script 9](img/B07040_03_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Run this on your system, and in another terminal `cd` to the `/tmp` directory.
    Run the command `touch continue.txt` and watch what happens. If you like you can
    do this multiple times (remember that up arrow recalls the previous command).
    Notice how the variable `x` does not get incremented when the `continue` command
    is hit. This is because the control goes immediately back to the `while` statement.
  prefs: []
  type: TYPE_NORMAL
- en: Now run the `touch break.txt` command. The script will end, and again, `x` has
    not been incremented. This is because `break` immediately causes the loop to end.
  prefs: []
  type: TYPE_NORMAL
- en: The `break` and `continue` commands are used quite often in scripts and so be
    sure to play with this one enough to really understand what is going on.
  prefs: []
  type: TYPE_NORMAL
- en: The sleep command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I showed the `sleep` command earlier, let's look at that in much more detail.
    In general, the `sleep` command is used to introduce a delay in the script. For
    example, in the previous script if I had not used `sleep` the output would have
    scrolled off too quickly to see what was going on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `sleep` command takes a parameter indicating how long to make the delay.
    For example, `sleep 1` means to introduce a delay of one second. Here are a few
    examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `sleep` command actually has a bit more capability that what is shown here.
    For more information, please consult the `man` page (`man sleep`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a script showing in more detail how `sleep` works:'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 3 - Script 10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'And the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Chapter 3 - Script 10](img/B07040_03_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You may have noticed that I pressed *Ctrl* + *C* to terminate the script since
    I didn't want to wait 2 hours for it to finish. Scripts of this nature are used
    very extensively in a Linux system to monitor processes, watch for files, and
    so on.
  prefs: []
  type: TYPE_NORMAL
- en: There is a common pitfall when using the `sleep` command that needs to be mentioned.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember that the `sleep` command introduces a delay into the script. To be
    clear, when you code a `sleep 60` it means to introduce a delay of 60 seconds;
    it does not mean it is going to run the script every 60 seconds. There is a big
    difference.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll see an example of this in the following section:'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 3 - Script 11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the output on my system. It doesn''t take all that long to eventually
    get out of sync:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Chapter 3 - Script 11](img/B07040_03_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: For the vast majority of scripts this is never going to be a problem. Just remember
    if what you are trying to accomplish is time critical, like trying to run a command
    at exactly 12:00 am every night, you might want to look at some other approach.
    Note that `crontab` will also not do this as there is about a 1 or 2 second delay
    before it runs the command.
  prefs: []
  type: TYPE_NORMAL
- en: Watching a process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a few more topics that we should look at in this chapter. Suppose
    you want to be alerted when a running process ends on your system.
  prefs: []
  type: TYPE_NORMAL
- en: Here's a script that notifies the user when the specified process ends. Note
    that there are other ways to do this task, this is just one approach.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 3 - Script 12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'To see this script in action run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: In a terminal, run `script9`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In another terminal run `ps auxw | grep script9`. The output will be something
    like this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the process ID from `script9` (in this case `20686`) and use it as the
    parameter to run `script12`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: You may let it run for a bit if you want. Eventually go back to the terminal
    that is running `script9` and terminate it with *Ctrl* + *C*. You will see `script12`
    output a message and then also terminate. Feel free to experiment with this one
    as it has a lot of important information in it.
  prefs: []
  type: TYPE_NORMAL
- en: You may notice that in this script I used a variable, `rc`, to determine when
    to end the loop. I could have used the `break` command as we saw earlier in this
    chapter. However, using a control variable (as it's often called) is considered
    to be a better programming style.
  prefs: []
  type: TYPE_NORMAL
- en: A script like this can be very useful when you have started a command and then
    it takes longer than you expected for it to finish.
  prefs: []
  type: TYPE_NORMAL
- en: For example, a while back I started a format operation on an external 1 TB USB
    drive using the `mkfs` command. It took a few days to complete and I wanted to
    know exactly when so that I could continue working with the drive.
  prefs: []
  type: TYPE_NORMAL
- en: Creating numbered backup files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now for a bonus here is a ready-to-run script that can be used to make numbered
    backup files. Before I came up with this (many years ago) I would go through the
    ritual of making the backup by hand. My numbering scheme was not always consistent,
    and I quickly realized it would be easier to have a script do it. This is something
    computers are really good at.
  prefs: []
  type: TYPE_NORMAL
- en: I call this script `cbS`. I wrote this so long ago I'm not even sure what it
    stands for. Maybe it was **Computer Backup Script** or something like that.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 3 – Script 13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: It starts with a `Usage` message as it needs at least one filename to work on.
  prefs: []
  type: TYPE_NORMAL
- en: Note that this command requires the files be in the current directory, so doing
    something like `cbS /tmp/file1.txt` will generate an error.
  prefs: []
  type: TYPE_NORMAL
- en: The `rc` variable is initialized to `0`. If a file is not found, it will be
    set to `1`.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's look at the inner loop. The logic here is a backup file will be created
    from the original file using the `cp` command. The naming scheme for the backup
    file is `bak-(number).original-filename` where `number` is the next one in sequence.
    The code determines what the next number is by going through all of the `bak-#.filename`
    files until it doesn't find one. That one then becomes the new filename.
  prefs: []
  type: TYPE_NORMAL
- en: Get this one going on your system. Feel free to name it whatever you like, but
    be careful to name it something other than an existing Linux command. Use the
    `which` command to check.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is some example output on my system:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Chapter 3 – Script 13](img/B07040_03_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This script could be greatly improved upon. It could be made to work with paths/files,
    and the `cp` command should be checked for errors. This level of coding will be
    covered in a later chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we covered the different types of loop statements and how they
    differ from each other. Nesting loops and the `sleep` command were also covered.
    The common pitfall when using the `sleep` command was also mentioned, and a backup
    script was introduced to show how to easily create numbered backup files.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter we will go over the creation and calling of subroutines.
  prefs: []
  type: TYPE_NORMAL
