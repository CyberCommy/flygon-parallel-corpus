- en: Chapter 7. Form Mason – a Monkey of your own
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our journey to learn Django, we have traveled far. We started from baby steps,
    learning to set up databases, basic views, and templates. We then moved on to
    more difficult stuff such as management commands and the Django shell. This is
    the last chapter in that journey, where we use all the knowledge that we have
    gained, and use it to create one of the most complicated applications yet. It's
    always fun to end things with a bang, and that's what we'll do here!
  prefs: []
  type: TYPE_NORMAL
- en: You might have heard of SurveyMonkey ([www.surveymonkey.com](http://www.surveymonkey.com))
    or Wufoo ([www.wufoo.com](http://www.wufoo.com)). If not, these are web applications
    that allow you to create custom forms to gather data from audiences. You use the
    control panel available on these sites to set up a form, defining all the fields
    and how they should be validated, and configuring some basic stuff such as what
    the form should look like, what theme it should use, and so on. After configuring
    the form, you get a link to a web page that displays that form.
  prefs: []
  type: TYPE_NORMAL
- en: You then send this link out to the intended audience and they fill it in, with
    their responses being saved. As part of your control panel, you also get a web
    page where you can view and filter these responses.
  prefs: []
  type: TYPE_NORMAL
- en: Services like these make it dead simple for even the least computer-savvy people
    to create online surveys and gather data for any purpose from a wide audience.
    This seems like a cool service that we will replicate in this chapter. It will
    also be the most complex application that we will have created, as it requires
    us to dive deep into Django and understand how Django forms work behind the scenes.
    In a sense, you will learn about the magic that makes Django tick. Exciting, isn't
    it!
  prefs: []
  type: TYPE_NORMAL
- en: Code pack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter does not have a code pack because almost all of the stuff that
    we are about to do here is new. Plus, we will do a lot of exploring in this chapter
    as well. This is both fun and shows you one of the many ways of approaching a
    tough project.
  prefs: []
  type: TYPE_NORMAL
- en: 'As there is no code pack to work from, you''ll need to start the project by
    yourself. First, as always, create a new virtual environment for the new project.
    Next, with the environment activated, install Django and run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This should create a `formmason` folder with our new Django project, ready
    for us to start working on. Use the `cd` command to get into this folder and create
    a new application that we''ll be using to hold our views, models, and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Finally, add the `main` application to our list of `INSTALLED_APPS` in `formmason/settings.py`.
    Once that's done, we're ready to start!
  prefs: []
  type: TYPE_NORMAL
- en: Looking at a Django form
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As our aim is to allow users to create dynamic forms based on parameters stored
    in a database, a good place to start is to look at how a Django form works under
    the hood and what options we have to customize it. First, let''s create a basic
    form. Create a new `main/forms.py` file and add the following code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a pretty basic form. However, it has a variety of form fields that
    we can look at. Let''s play around a bit in the shell, which you can start as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I usually like to install another package called ipython. When you start the
    Django shell with ipython installed, you get an enhanced version of the basic
    shell with a lot of cool features such as autocomplete and a much better looking
    interface. I always install it in any Django project because I almost always use
    the shell at the start of the project to play around. I highly advise you to install
    it as well when you start a new Django project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Import our form in the shell as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In the same shell, type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The first line of code simply created an instance of our form class. It's the
    second line where the fun begins. However, I'll first explain the `OrderedDict`
    data structure a bit.
  prefs: []
  type: TYPE_NORMAL
- en: As the name suggests, `OrderedDict` is a dictionary that maintains the order
    in which its elements were inserted. A normal dictionary in Python has no fixed
    order. If you insert three elements into a dictionary with keys `A`, `B`, and
    `C`, and then you ask for the keys back using the `keys()` method on the dictionary
    instance, the order in which you will get them back is not guaranteed, which is
    why normal built-in dictionaries are said to be unordered.
  prefs: []
  type: TYPE_NORMAL
- en: In contrast, the keys in `OrderedDict`, which is from the `collections` library
    (part of the Python standard library), are guaranteed to be in the same order
    that you inserted them in. So if you were to iterate over the keys using either
    the `keys()` or `items()` method, you would always get them back in the same order
    that you inserted them.
  prefs: []
  type: TYPE_NORMAL
- en: Getting back to the output, you will see that the dictionary printed has the
    same keys as the names of the fields that we used when we created our `SampleForm`
    class. The values of these keys are the `Field` subclasses (`CharField`, `IntegerField`,
    and so on) that we used in our form.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try something. In the shell, type the following and look at the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: It seems that the `name` attribute that we defined on our `SampleForm` class
    is no longer there. Weird, huh?
  prefs: []
  type: TYPE_NORMAL
- en: So far you have learned two facts about a Django form. The first, that the `fields`
    attribute on a form instance contains a mapping of field names to the `Field`
    classes. Second, that the field attributes we defined when creating our `SampleForm`
    class are not accessible on the instance.
  prefs: []
  type: TYPE_NORMAL
- en: Putting these two facts together gives us some indication of what Django does
    with the `SampleForm` class when creating an instance of it. It removes the field
    attributes and adds them to the `fields` dictionary. After a form instance is
    created, the only way to find out the fields that are defined on it is the `fields`
    dictionary attribute.
  prefs: []
  type: TYPE_NORMAL
- en: So, if we wanted to add another field to a form after the class has been defined
    and we could not change the code of the class itself, we could add an instance
    of a `Field` subclass to the `fields` attribute on the form instance. Let's try
    it out and see if this works.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I lied a little when I said that Django removes the field attributes from a
    `SampleForm` class when creating an instance of it. In reality, the `SampleForm`
    class also has its field attributes removed. If you typed `SampleForm.name` in
    the shell, you would get a similar `AttributeError`. However, this information
    is not relevant to our current task, and the reason why this happens is complicated
    so I won't go into it in this book. If you want all the details, check out the
    source for the `django.forms.Form` class.
  prefs: []
  type: TYPE_NORMAL
- en: Adding an extra field to a SampleForm instance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will now try an experiment. We will create an instance of our `SampleForm`
    with some valid test data, and then we will add another field to the `fields`
    attribute on our instance. We will then call the `is_valid()` method to see if
    our form instance considers the dynamically added field when validating the data
    provided earlier. Let''s see what happens. In the Django shell, enter the following
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Nice! It seems like our idea worked. Even though we added the `country` field
    after our `SampleForm` had been instantiated and provided the data, the form validation
    did consider our new field. As the `country` field was not part of the `test_data`
    dictionary and the field is required, the form validation failed and the `errors`
    list included the appropriate error.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a technique to achieve our objective, let's create some views
    and templates to render a dynamic form.
  prefs: []
  type: TYPE_NORMAL
- en: Generating dynamic forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we get to the code, we have to decide on a data format to specify the
    structure of our dynamic forms. **JSON** is one of the most popular, if not the
    most popular, data storage and exchange formats on the web right now. You will
    probably be aware of what JSON, is and how it works and what it looks like. However,
    if you're not, here's a quick introduction.
  prefs: []
  type: TYPE_NORMAL
- en: 'JSON stands for JavaScript Object Notation. It uses the same format that JavaScript
    uses to declare objects. The biggest benefit for us Python guys is that it is
    almost exactly the same as the dictionary declaration syntax in Python. Let''s
    say that we want to store some details about a user. In JSON, here is what that
    information would look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we can even copy and paste this into our Python code and it
    would be a valid dictionary definition, which makes it very easy for us to work
    with.
  prefs: []
  type: TYPE_NORMAL
- en: 'JSON has a number of benefits over other data storage/exchange formats:'
  prefs: []
  type: TYPE_NORMAL
- en: It's text only, so no need to have special tools built around it for the viewing
    and parsing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parsing JSON is very easy, and most languages have a library for this. Python
    comes with a standard library to parse JSON.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's simple to write by hand.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can be stored in a number of ways without needing to do anything special.
    We will use this fact later on to store JSON in our database as a simple text
    field.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that you know a bit about JSON, let's see how to use it. We will store information
    about how to construct a dynamic form in JSON. We will then use the Python standard
    library `json` to convert the JSON string to a Python dictionary, which we will
    then iterate over and create our form.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For this section, we will hardcode the JSON that we use in order to generate
    the form. Later on, we will allow our users to create and store the JSON themselves
    in a database from a control panel that we will make for them.
  prefs: []
  type: TYPE_NORMAL
- en: We will look at how to define the form fields in JSON and generate a dynamic
    form from this schema. We will also create an HTML form to render our form so
    we can test that everything works as expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the format for a simple form that can be used to collect basic
    demographic information about people:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This is the sample JSON that we will use in this section to generate and display
    our dynamic form. This structure is a simple dictionary with strings for the values.
    We have to write code to parse this dictionary and create a Django form out of
    this information.
  prefs: []
  type: TYPE_NORMAL
- en: Generating a form out of JSON
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first thing that we will need to do is convert the JSON data that our view
    will get to a Python dictionary so that we can iterate over it. Python comes with
    the `json` module as part of the standard library that will handle the parsing
    for us. You can read the documentation for it at [https://docs.python.org/3/library/json.html](https://docs.python.org/3/library/json.html).
    It is dead simple to use, however, so let's just dive in.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open up `main/views.py` and add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'There are a couple of things to explain here. However, let''s first get the
    view working and see if it does what we want. Then I''ll explain what this code
    does. Next, let''s create the `main/templates/custom_form.html` template. You
    will need to create the `templates` folder under the `main/` folder first. Put
    this code in there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, put the following code in `formmason/urls.py` to include our new view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s it for now. To test it out, run the development server using the `runserver`
    command and then open up `http://127.0.0.1:8000` in any browser. You should see
    a screen similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Generating a form out of JSON](img/00698_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Try submitting an incomplete form and the page should be rendered with the
    correct error messages. Try to complete the form and submit it. Now you should
    see an error page, with the `ImproperlyConfigured: No URL to redirect to. Provide
    a success_url` error. This error comes from our use of the `FormView` generic
    view. When the form is valid, it expects `success_url` to be defined so that the
    user can be redirected to it. We don''t have anywhere to redirect the user to,
    so we will ignore this for now. Let''s take a look at the code and see what we
    have done here.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This example also highlighted the power of generic views. By just redefining
    one function, `get_form`, we were able to use all the features of `FormView` with
    a form that is generated dynamically. As the Django generic views are made with
    modularity in mind, the rest of the view does not care how the form is created,
    just that the `get_form` method returns a valid form.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the action happens in the `get_form` method of our `CustomFormView`,
    so let's start there. The first line of code defines the JSON data structure that
    we will use to generate our form. As I've mentioned before, this data will eventually
    be coming from a database backend; however, for testing purposes, we are hardcoding
    it for now. Next, we use the `json.loads` method to convert the JSON string to
    a Python object. This conversion process is pretty intuitive. The JSON string
    that we have is a dictionary with keys for `name`, `age`, `city`, `country`, and
    `time_lived_in_current_city`. The Python object that we get from `json.loads`
    is a dictionary as well, with the same key/value pairs. You can also have arrays
    in your JSON string and loading it would give you a Python list. JSON has support
    for nested objects, so you could have an array of dictionaries or a dictionary
    with an array for a value.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create an instance of the base `django.forms.Form` class. As we saw
    in our experimentation before, we can take an instance of a Django form and add
    fields to it. Instead of creating an empty form class and using that, we just
    use the base `Form` class from Django directly. To the constructor of the form
    class, we pass whatever we receive from `self.get_form_kwargs()`. This method
    is part of the Django `FormView` class and depending on the request type creates
    the correct keyword arguments to be passed to a `Form` class. For instance, if
    the request was a POST/PUT request, `get_form_kwargs()` would return a dictionary
    that contains the `data` keyword argument so that we can use the form to validate
    and take further action on the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The interesting bit happens next, when we loop over the items list of our custom
    fields data. The `items()` method on the data that we loaded from JSON returns
    a list as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We loop over this list, assigning each of these item pairs to variables `key`
    and `value` in the `for` loop. We then pass the values to the `get_field_class_from_type`
    method, which decides which of the available form field classes to use for the
    type of data passed. The method's code is a simple `if/else`, which returns a
    field class or `None` if it was passed an invalid type.
  prefs: []
  type: TYPE_NORMAL
- en: We use the return value of this method, which is a class, and assign an instance
    of it to the form's `fields` attribute dictionary. *Note that we assign an instance
    of the field class and not the class itself*. The name of the field is the key
    from our JSON dictionary. We also do some basic error handling, raising `TypeError`
    if we cannot find a matching field class for the type we got in our JSON data
    dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we return our customized form class. From there on, the Django `FormView`
    takes over and either renders the form, with errors if necessary, or redirects
    the user to the success URL if the form data submitted by the user was valid.
    As we didn't define any success URL, we get an error when we submit a valid form.
  prefs: []
  type: TYPE_NORMAL
- en: That's it. That is all the code that we need to create a dynamically generated
    form. We can add a couple of more features such as custom validation or advanced
    features such as supporting choice fields with a limited set of choices, but I'll
    leave that as an interesting project for you to try on your own.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's take a look at how we can store the JSON data that defines our custom
    form in a database. We'll create a model for it and allow the user to create multiple
    forms with different fields from an admin panel.
  prefs: []
  type: TYPE_NORMAL
- en: A model for our JSON
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As I have mentioned earlier, one of the biggest benefits of using JSON as the
    definition format for our forms is that it uses just simple text data to encode
    the definition of complex objects. While some databases such as PostgreSQL have
    a column type for JSON, others do not. However, because we are dealing with simple
    text data, we don't need one! We can store our JSON data in a simple `TextField`
    and then encode and decode the data to and from a Python dictionary whenever required.
    In fact, there are many people in the Django community who have already dealt
    with this problem and open sourced their solutions for us to use.
  prefs: []
  type: TYPE_NORMAL
- en: One such package that I have used in the past is `django-jsonfield`. You can
    find it at [https://github.com/bradjasper/django-jsonfield](https://github.com/bradjasper/django-jsonfield),
    and we will be using it in our project. First, install the required package by
    typing the following command in your command line. Make sure to have the virtual
    environment activated first so that it is installed in the correct location.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'With the package installed, we can create a model for our form. Open up `main/models.py`
    and change it to have the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Save the file and then create and run migrations so that Django creates the
    tables for our new model. In the command line, run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'With the migrations done, let''s see how we can use this model. Instead of
    writing the code for the view, I like to start by doing a bit of experimentation
    in the Django shell. Open it up by typing as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Then type in the following to test out our new model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: What we have done here should be pretty simple for you to understand by now.
    The important thing to note here is the value that we assigned to the `schema`
    field. Instead of using a string representation of the JSON data, we simply assigned
    a Python dictionary to it. The `JSONField` class we used as the field class in
    our model does the heavy lifting of converting from a Python dictionary to a JSON
    string when saving to the database.
  prefs: []
  type: TYPE_NORMAL
- en: The reverse is also the same. Notice how, in the last line of our shell session,
    we simply accessed the schema field directly and got a Python dictionary back
    instead of the string JSON data that is actually saved in the database. This makes
    working with JSON transparent to us.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You might be wondering why I am asking you to experiment in this chapter and
    play around in the shell, whereas in the previous chapters, I just showed you
    the relevant view/model/template code directly.
  prefs: []
  type: TYPE_NORMAL
- en: Like I mentioned at the start of this chapter, this chapter is about showing
    you how to arrive at a solution by yourself instead of me holding your hand and
    showing you the end result immediately.
  prefs: []
  type: TYPE_NORMAL
- en: All good Django developers that I know have a similar method of developing solutions
    for the projects that they work on. They experiment a bit, and in doing so figure
    out a solution to the problem they are working on. Everyone has a different way
    of experimenting though. Some people, like me, use the Django shell a lot. Others
    write test code in views and models. Others might create simple Django management
    commands to do the same. However, everyone goes through the same process.
  prefs: []
  type: TYPE_NORMAL
- en: We find a problem that needs to be solved, we research it a bit, and then experiment
    with the various methods of solving it, finally choosing one which we like the
    best. You will eventually develop a method that you are comfortable with. In the
    meanwhile, I'll be walking you through my method and you can use this if you like.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now have a `FormSchema` object in our database, so let''s create a view
    that can use this object to generate a form. In `main/views.py`, first import
    our new model near the top:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Then change the `get_form` method in our `CustomFormView` to match this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: I have highlighted the new line. We have removed the hardcoded JSON string that
    we used and instead assigned the `schema` field's value from our database object
    to the `form_structure` variable. The rest of the code stays the same. Try opening
    the home page for the application again. You'll find that the frontend has stayed
    the same. The interactions will be the same as well. You can try to submit invalid
    or incomplete data and it will show you the errors as before. Trying to submit
    a valid form will still result in the error about success URL not being defined.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's create a better frontend for our users. We'll create a list view
    where the user can see a list of all forms available on the site and a form view
    that displays the actual form and handles the interactions.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a better user interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There isn't anything complicated about what we'll do here. It should be very
    easy for you to follow along, so I'll just give you the code to write and leave
    the explanation, as we have done all of this many times before in the previous
    chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by creating a `templates` directory in the project root. Next, add it
    to the list of `DIRS` in the `TEMPLATES` configuration variable in our `formmason/settings.py`
    file. The `settings.py` file already has a `TEMPLATES` variable configured, so
    go ahead and replace the `DIRS` list in this dictionary with the value that you
    see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create a `base.html` template in the new `templates` directory that you
    just created and put this code in there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Modify `main/templates/custom_form.html` to match this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Change `main/views.py` to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new home template at `main/templates/home.html` and give it the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, change `formmason/urls.py` to match this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have done all this, open up the home page for the application again
    at `http://127.0.0.1:8000`, and you should see a page similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a better user interface](img/00698_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Clicking on the link for the form should take you to the same form page that
    we had before; the only difference is that now it is served at the URL, `http://127.0.0.1:8000/form/1/`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like I said, all this is pretty basic stuff that we have done repeatedly in
    the past few chapters. One thing that might be new is our use of `self.kwargs[''form_pk'']`
    in the `CustomFormView.get_form` method. Here''s the relevant line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'For any generic view that Django provides (except for the base `View` class),
    `self.kwargs` is a dictionary of all named parameters that matched the URL pattern.
    If you look at our `formmason/urls.py` file, we defined the URL for our custom
    form page like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In our view, the `form_pk` parameter defined in the regex pattern for the URL
    is available in `self.kwargs`. Likewise, any non-keyword parameters in the URL
    pattern are available for use in `self.args`.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a useable user interface, we will move on to storing the form
    responses in our database and giving our customers a page to view these responses.
  prefs: []
  type: TYPE_NORMAL
- en: Saving the responses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We want to save the response of the user filling in one of our dynamic forms.
    As the data from a dynamic form will also be dynamic, we need to store an unknown
    number of fields and their values in our database. As we have already seen, JSON
    is a reasonable way to store such data. Let''s create a new model in `main/models.py`
    to store the responses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create and run the migrations to add this new model to our database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our model, we need to save valid responses for our forms in
    this model. The `form_valid` method of `CustomFormView` is the correct place to
    add this logic. First, we need to import a few things from Django and our new
    model at the top of our `main/views.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, add a `form_valid` method with this code to the `CustomFormView` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s it. Now try submitting the custom form that we created earlier and
    if the data was valid, you should be redirected to the home page after your response
    was saved. Right now, we have no way to see these responses in the frontend; however,
    we can use the Django shell to make sure that our data has been saved. Start the
    shell with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Then use the following lines of code to see the response that was saved:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: You should see the data that you entered when saving the form. Now let's create
    a screen where our customers can see the responses for their custom forms.
  prefs: []
  type: TYPE_NORMAL
- en: Showing the responses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code in this section is pretty simple and should not have any surprises
    for you. First, let''s create the view in `main/views.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create the `main/templates/form_responses.html` template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'In `formmason/urls.py`, import our new view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Add this URL pattern to the `urlpatterns` list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, edit `main/templates/home.html` to add a link to this new view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The new line of code is highlighted. After making all these changes, open the
    home page and you should see the **See Responses** links for the new view next
    to each of the existing form links:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Showing the responses](img/00698_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Clicking on the link should take you to a page as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Showing the responses](img/00698_07_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: While it does get the job done, it is very crude. We can do better. Let's improve
    this.
  prefs: []
  type: TYPE_NORMAL
- en: An improved responses list
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'What we''d like is to show the responses in a tabular fashion with the field
    names as the header and response values for these fields underneath them. Let''s
    start out by modifying our view code. In `main/views.py`, first import `TemplateView`
    as we will no longer be using `ListView` as the base class for our `FormResponsesListView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, modify `FormResponsesListView` to match the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The major changes here are in the `get_context_data` method. We also changed
    the base class to `TemplateView` from `ListView`. Let's look at what we are doing
    in the `get_context_data` method.
  prefs: []
  type: TYPE_NORMAL
- en: First, we use the `keys` method on the JSON form schema, which is saved in the
    `FormSchema` model, to create a list of field headers. We pass this to the template
    in the `headers` context variable.
  prefs: []
  type: TYPE_NORMAL
- en: The slightly complicated part comes next. We loop over each of the `FormResponse`
    objects in our database. For each response object, we then loop over the form
    field names and get that attribute from the response data. We do this because,
    in the Django template, there is no way to get a value from a dictionary with
    a variable key name. We could create a custom template tag; however, that would
    add unnecessary complexity. Instead, we do the same thing in our view, where it
    is easier. For each response object, we create a list of values that is in the
    same order as the field headers. We then add this list of field values to our
    list of responses. The reason that our data is structured in this way becomes
    clear when we look at our template.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we assign the list of responses to the `object_list` template context
    variable and return the context. Next, let''s change the `main/templates/form_responses.html`
    template to match the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: If you understood how our data was structured in the view, the template should
    be simple enough to follow. These are all the changes that we need to make for
    now.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you open the responses page again, you should now see a neatly aligned table,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![An improved responses list](img/00698_07_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We have so far created a page to list the available forms, a page to submit
    data with a dynamic form, and a page to show those responses. Our application
    is nearly done. However, we are still missing a page that allows customers to
    create a custom form. Let's tackle this next.
  prefs: []
  type: TYPE_NORMAL
- en: Designing a form creation interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We want to provide our users with a friendly interface to edit the structure
    of their dynamic forms. The ideal interface would be something that allows users
    to drag and drop their fields and set the properties for these fields using simple
    click and type operations on a web page. However, creating an interface like this
    is a major undertaking and a project on its own. It requires a team of frontend
    developers and designers to create something that user friendly.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, we can't create something like that as an interface like that
    is more of a frontend project than something related to Django. However, if you
    want, it is a good exercise if you are looking to improve your frontend skills.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this project, we will create a simple Django form where the user can manually
    enter the JSON to define the structure of their forms. We will provide basic validation
    and editing capabilities. So let''s start by creating our form. Change the `main/forms.py`
    file to match the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The form itself is pretty simple. However, we need to take a closer look at
    the `clean_schema` method. When the `is_valid()` method is called on a Django
    form, it goes through a couple of steps. The exact details can be found in the
    documentation at [https://docs.djangoproject.com/en/stable/ref/forms/validation/](https://docs.djangoproject.com/en/stable/ref/forms/validation/).
    However, a good approximation is that Django calls two different types of clean
    methods on the form class. First, it looks for methods named `clean_<fieldname>`
    for *each* field defined on the form. This method should return the cleaned value
    of the field that will then be stored in the `cleaned_data` dictionary of the
    form. Next, Django calls the `clean` method on the form class. This method is
    meant to clean data for fields that depend on each other as dependent cleaning
    should not be done in individual `clean_<fieldname>` methods. The `clean` method
    should return a dictionary that will replace the form's `cleaned_data` dictionary
    completely.
  prefs: []
  type: TYPE_NORMAL
- en: Either type of clean methods can raise a `forms.ValidationError` exception if
    the data is not in the expected format. If `ValidationError` is raised in a `clean_<fieldname>`
    method, the error is tied to that field and displayed next to it when the form
    is rendered. If the error is raised in the general `clean` method, the error is
    displayed in the form error list that is displayed right before the form fields
    start in the HTML of the form.
  prefs: []
  type: TYPE_NORMAL
- en: As we wish to make sure that the data entered by the user in the schema field
    is valid JSON, we use `json.loads` on the user-entered data and raise an exception
    if the call fails. One important thing to note is that we return a modified version
    of the schema if our `clean_schema` call succeeds. This is because, in our model,
    we need to save a Python dictionary instead of a JSON string. Our `JSONField`
    model field handles the necessary conversion from a Python object to a JSON string
    when saving to the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another side note is that the `clean_schema` method is not given any arguments.
    It must get the value for the schema field from the form''s `cleaned_data` dictionary.
    With our form created, let''s add a view to `main/views.py` to display this form.
    First, import our new form and the `json` library at the top:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the following code to the view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create the `main/templates/create_edit_form.html` file and put this code
    in there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, import this new view in our `formmason/urls.py` and add two patterns
    for it to the `urlpatterns` file. Here is the final `formmason/urls.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: We are using the same view twice—once as a create view and once as an edit view.
    If you look at the code for the view, we provide the form with initial data from
    a `FormSchema` object if the `form_pk` keyword argument was matched from the URL.
    If it wasn't, we know that we are creating a new form and our initial data dictionary
    is empty. One thing to note is that in the initial data, we use `json.dumps(form.schema)`
    to provide the initial value for the schema field. This is the reverse of what
    we do in the `clean_schema` method of our form. That's because `form.schema` is
    a Python object; however, our frontend needs to show the JSON for the structure.
    So we convert from a Python object to a JSON string using the `json.dumps` method.
  prefs: []
  type: TYPE_NORMAL
- en: We handle both the cases—new form creation and form editing—in the `form_valid`
    method of our view. On successfully saving or creating our form, we redirect the
    user to the home page again.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last thing we need to do is add links to our base template and home page
    to create and edit forms. First, add this link right after the link for **Home**
    in `templates/base.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'In `main/templates/home.html`, add this after the link for **See Respo** **nses**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s it. Let''s test it out. Open the home page at `http://127.0.0.1:8000/`
    first and you should see something similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Designing a form creation interface](img/00698_07_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on the **Edit Form** button and you should see the following page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Designing a form creation interface](img/00698_07_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s change the title to something new and then type this in the **Schema**
    field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Click on the **Create New Form** link. This should save the form and take you
    back to the home page. The title of your form on the home page should be changed
    to whatever you edited it to. Click on the link to see the form, and you should
    see a screen similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Designing a form creation interface](img/00698_07_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Nice! Our form has changed to match the schema that we entered while editing
    the form. Let''s take a look at what our responses page looks like. Submit some
    test data with the new form schema and open up the responses page. You should
    see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Designing a form creation interface](img/00698_07_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This page works as expected, without having to change any of the code. You'll
    see that the previous responses are no longer visible; however, there seems to
    be some empty cells above the latest response. We'll look into fixing this and
    other small issues next. However, our application is complete except for a few
    small fixes that we need to do.
  prefs: []
  type: TYPE_NORMAL
- en: You should use the **Create New Form** link at the top of the pages as well
    to create a new form and test it out. It should work as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Small fixes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I noticed three small errors while working on this last section that I''d like
    to fix. First of all, if you take a closer look at the form submission page (where
    the user can enter data in a custom form), you''ll notice that the heading on
    the top says **Custom Form**. This is from our first test, when our form schema
    was defined in a hardcoded JSON string and didn''t have a title. As our form model
    now has a title field, edit `main/templates/custom_form.html` and change the `h1`
    tag to match the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, edit `CustomFormView` in `main/views.py` and add the `this get_context_data`
    method to the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Look at the form detail page again. This time, the heading should reflect the
    form title, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Small fixes](img/00698_07_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The next error that I noticed was on the form editing page. Right now, whether
    you are creating a new form or editing an existing one, the heading always says
    `Create/Edit Form` and the **Submit** button always says **Create New Form**.
    Let''s modify our `main/templates/create_edit_form.html` template to tell the
    user explicitly what action they are taking. Here is the final code for the template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Now if you edit an existing form or create a new one, the heading and button
    should match that action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Small fixes](img/00698_07_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The last issue I saw was on the responses page. If you edit a form that already
    has responses and the new form has none of the fields that the old form had, you
    will see some empty table rows at the start. That''s because even though our view
    code doesn''t include any data for those rows, it still includes an empty row.
    Let''s fix this by modifying the `get_context_data` method of `FormResponsesListView`
    in `main/views.py`. Look for this piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Change it to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The last two lines, the highlighted ones, are the changes. The `any` function
    is a built-in Python method that returns `True` if any of the values in the given
    list evaluates to `True`. If our `responses_list` contains all empty strings,
    which is the case if our new form structure has no fields that overlap with the
    old form structure, the `if` condition will fail and we will not include a completely
    empty row in our responses list. Try looking at the responses list page again
    and you should see that the empty rows have now disappeared:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Small fixes](img/00698_07_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: That's it. Our last, and most ambitious, application is complete. Congratulations!
    You have come a long way from the simple blog that we created at the start of
    this book. You should now be ready to tackle any web application project that
    comes your way.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter was more about exploration than new concepts. The only major new
    concept that you learned was about the inner workings of Django forms, and this
    section took up fewer than five pages. The rest of the chapter was about finding
    solutions to problems that we encountered along the way.
  prefs: []
  type: TYPE_NORMAL
- en: As I said at the start of this chapter, this was the most complicated application
    that we have created in the book. It is also likely to be one of the more complicated
    applications you will create at the start of your career. It is by no means a
    polished product; that's more because we didn't do any frontend work, rather than
    some lack of features in the Django backend.
  prefs: []
  type: TYPE_NORMAL
- en: While the knowledge we gained about Django forms in this chapter will prove
    invaluable to you, I would like the main takeaway from it to be the approach to
    solving problems. We found a problem we needed to solve, we experimented in the
    Django shell, and we found a solution. Sometimes it's a bit more complicated than
    that. You probably need to search the Internet for existing solutions or ask your
    colleagues. However, after finding answers that seem to be relevant to your problem,
    you will always have to go back to the experimentation and make sure that the
    solution really does solve your problem.
  prefs: []
  type: TYPE_NORMAL
- en: The way I showed you how to play around in the Django shell is just one of the
    many ways that you can choose to experiment with different solutions. As I've
    mentioned before, everyone has their own technique. Some use management commands,
    some use simple Python scripts, and some write test code in the views. In the
    end, you will come up with a way that you like the best.
  prefs: []
  type: TYPE_NORMAL
- en: Another thing that I hope you take away from this chapter is the use of external
    libraries to help solve our problems. When we needed a way to store JSON in our
    database, we used the `jsonfield` library that was available as open source instead
    of rolling our own custom solution. This has benefits and drawbacks. The benefits
    are that if you find a package, such as `jsonfield` that is widely used, you will
    get a solution that has been tested by many before you. Due to that testing, the
    library will be much more stable than what you, or any person, can come up with
    on your own. The drawback of using something external is that you have no control
    over the direction the project takes and in some projects, you'll have to painstakingly
    go over the code for the external library to make sure that it meets any regulations
    your project might have about external code usage.
  prefs: []
  type: TYPE_NORMAL
- en: However, personally, I prefer to use a tried and tested third-party library
    every time over creating something by myself. For me, the pros usually outweigh
    the cons.
  prefs: []
  type: TYPE_NORMAL
- en: That's it! This was the final chapter in this epic journey that we started with
    a simple blog! We have come a long way from where we started; however, I'm sure
    that your journey as a Django web developer is just starting. You have many more
    exciting things to look forward to, and I wish you the best of luck in this journey.
    I hope you enjoyed reading this book as much as I enjoyed writing it. Bon voyage!
  prefs: []
  type: TYPE_NORMAL
