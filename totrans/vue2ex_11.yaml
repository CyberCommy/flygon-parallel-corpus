- en: Building an E-Commerce Store – Adding a Checkout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Over the last couple of chapters, we have been creating an e-commerce store.
    So far, we have created a product page that allows us to view the images and product
    variations, which may be size or style. We have also created a category page with
    filters and pagination—including a homepage category page that features specific,
    selected products.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our users can browse and filter products and view more information about a
    specific product. We are now going to:'
  prefs: []
  type: TYPE_NORMAL
- en: Build the functionality to allow the user to add and remove products to their
    basket
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allow a user to Checkout
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add an Order Confirmation page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a reminder—we won't be taking any billing details but we will make an Order
    Confirmation screen.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the basket array placeholder
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To help us persist the products in the basket throughout the app, we are going
    to be storing the user's selected products in the Vuex store. This will be in
    the form of an array of objects. Each object will contain several key pieces of
    information that will allow us to display the products in the basket without having
    to query the Vuex store each time. It also allows us to store details about the
    current state of the product page—remembering the image updates when a variant
    is selected.
  prefs: []
  type: TYPE_NORMAL
- en: 'The details we''re going to store for each product added to the basket are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Product title
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Product handle, so we can link back to the product
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selected variation title (as it appears in the select box)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Currently selected image, so we can show an appropriate image in the Checkout
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variation details, this contains price and weight along with other details
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variation SKU, this will help us identify whether the product has already been
    added
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Quantity, how many items the user has added to their basket
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As we will be storing all this information within an object, contained in an
    array, we need to create a placeholder array within the store. Add a new key to
    the `state` object within the store titled `basket` and make it a blank array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Adding product information to the store
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With our `basket` array ready to receive data, we can now create a mutation
    to add the product object. Open the `ProductPage.js` file and update the `addToBasket`
    method to call a `$store` commit function, instead of the `alert` we put in place.
  prefs: []
  type: TYPE_NORMAL
- en: All of the information we require for products to be added to the basket is
    stored on the `ProductPage` component—so we can pass the component instance through
    to the `commit()` function using the `this` keyword.  This will become clear when
    we build the mutation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the function call to the `ProductPage` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Creating the store mutation to add products to the basket
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Navigate to the Vuex store and create a new mutation titled `addToBasket`.
    This will accept the `state` as the first parameter and the component instance
    as the second. Passing the instance through allows us to access the variables,
    methods, and computed values on the component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We can now proceed with adding the products to the `basket` array. The first
    step is to add the product object with the mentioned properties. As it's an array,
    we can use the `push()` function to add the object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, add an object to the array, using the `item` and its properties to build
    the object. With access to the `ProductPage` component, we can construct the variant
    title as it appears in the select box, using the `variantTitle` method. Set the
    quantity to `1` by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This now adds the product to the `basket` array. An issue appears, however,
    when you add two of the same item to the basket. Rather than increasing the `quantity`,
    it simply adds a second product.
  prefs: []
  type: TYPE_NORMAL
- en: This can be remedied by checking if the `sku` exists within the array already.
    If it does, we can increment the quantity on that item, if not we can add a new
    item to the `basket` array. The `sku` is unique for each variation of each product.
    Alternatively, we could use the barcode property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the native `find` JavaScript function, we can identify any products that
    have an SKU matching that of the one being passed in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If it matches, we can increment the quantity by one on that object, using the
    `++` notation in JavaScript. If not, we can add the new object to the `basket`
    array. When using the `find` function, we can return the product if it exists.
    If not, we can add a new item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We now have a basket being populated as the item is added to the basket, and
    incrementing when it exists already.
  prefs: []
  type: TYPE_NORMAL
- en: To improve the usability of the app, we should give the user some feedback when
    they have added an item to the basket. This can be done by updating the "Add to
    Basket" button briefly and showing a product count with a link to the basket in
    the header of the site.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the Add to basket button when adding an item
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a usability improvement to our shop, we are going to update the Add to basket
    button when a user clicks it. This will change to Added to your basket and apply
    a class for a set period of time, for example, two seconds, before returning to
    its previous state. The CSS class will allow you to style the button differently—for
    example, changing the background to green or transforming it slightly.
  prefs: []
  type: TYPE_NORMAL
- en: This will be achieved by using a data property on the component—setting it to
    `true` and `false` as the item gets added. The CSS class and text will use this
    property to determine what to show and a `setTimeout` JavaScript function will
    change the state of the property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `ProductPage` component and add a new key to the data object titled
    `addedToBasket`. Set this to `false` by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Update the button text to allow for this variation. As there is already a ternary
    `if` within this, we are going to nest them with another one. This could be abstracted
    into a method if desired.
  prefs: []
  type: TYPE_NORMAL
- en: 'Replace the `Add to basket` condition in your button with an additional ternary
    operator, dependent on whether the `addedToBasket` variable is true. We can also
    add a conditional class based on this property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Refresh the app and navigate to a product to ensure the correct text is being
    shown. Update the `addedToBasket` variable to `true` to make sure everything is
    displaying as it should. Set it back to `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, within the `addToBasket()` method, set the property to true. This should
    update the text when the item is added to the basket:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'When you click the button, the text will now update, however it will never
    reset. Add a `setTimeout` JavaScript function afterward, which sets it back to
    `false` after a certain period of time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The timing for `setTimeout` is in milliseconds, so `2000` is equal to two seconds.
    Feel free to tweak and play with this figure as much as you see fit.
  prefs: []
  type: TYPE_NORMAL
- en: 'One last addition would be to reset this value back to `false` if the variation
    is updated or the product is changed. Add the statement to both `watch` functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Showing the product count in the header of the app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's common practice for a shop to show a link to the cart in the site's header—along
    with the number of items in the cart next to it. To achieve this, we'll use a
    Vuex getter to calculate and return the number of items in the basket.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `index.html` file and add a `<header>` element to the app HTML and
    insert a placeholder, `span`—we''ll convert this to a link once we''ve set up
    the routes. Within the span, output a `cartQuantity` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Navigate to your `Vue` instance and create a `computed` object containing a
    `cartQuantity` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: If our header were to feature more items than our cart link, it would be advisable
    to abstract it out into a separate component to keep the methods, layout, and
    functions contained. However, as it is only going to feature this one link in
    our example app, adding the function to the `Vue` instance will suffice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new getter in the store titled `cartQuantity`.  As a placeholder,
    return `1`. The `state` will be required to calculate the quantity, so ensure
    that is passed into the function for now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Head back to your `Vue` instance and return the result of the getter. Ideally,
    we want to show the count of the `basket` in brackets, but we only want to show
    the brackets if there are items. Within the computed function, check the result
    of this getter and output the result with brackets if the result exists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Changing the result within the Vuex getter should reveal either the number in
    brackets or nothing at all.
  prefs: []
  type: TYPE_NORMAL
- en: Calculating the basket quantity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the display logic in place, we can now proceed with calculating how many
    items are in the basket. We could count the number of items in the `basket` array,
    however, this will only tell us how many different products are there now and
    not if the same product was added many times.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, we need to loop through each product in the basket and add the quantities
    together. Create a variable called `quantity` and set it to `0`. Loop through
    the basket items and add the `item.quantity` variable to the `quantity` variable.
    Lastly, return our variable with the right sum:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Navigate to the app and add some items to your basket to verify the basket count
    is being calculated correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Finalizing the Shop Vue-router URLs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''re now at a stage where we can finalize the URLs for our shop - including
    creating the redirects and Checkout links. Referring back to [Chapter 8](part0135.html#40NRU0-985bf4ae118d4f62b18ae64204cb251c),
    *Introducing Vue-Router and Loading URL-Based Components*, we can see which ones
    we are missing. These are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/category` -redirect to `/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/product` - redirect to `/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/basket` - load `OrderBasket` component'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/checkout`- load `OrderCheckout` component'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/complete`- load `OrderConfirmation` component'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Create the redirects in the appropriate places within the routes array. At
    the bottom of the routes array, create three new routes for the `Order` components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now update the placeholder `<span>` in the header of our app with a
    `router-link`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Building the Order process and ListProducts component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For the three steps of the Checkout, we are going to be utilizing the same
    component in all three: the `ListProducts` component. In the `OrderCheckout`, and
    `OrderConfirmation` components, it will be in a fixed, uneditable state, whereas
    when it is in the `OrderBasket` component, the user needs to be able to update
    quantities and remove items if desired.'
  prefs: []
  type: TYPE_NORMAL
- en: As we're going to be working at the Checkout, we need products to exist in the
    `basket` array. To save us having to find products and add them to the basket
    every time we refresh the app, we can ensure there are some products in the `basket`
    array by hardcoding an array in the store.
  prefs: []
  type: TYPE_NORMAL
- en: 'To achieve this, navigate to a few products and add them to your basket. Ensure
    there is a good selection of products and quantities for testing. Next, open your
    JavaScript console in the browser and enter the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This will output a string of your products array. Copy this and paste it into
    your store—replacing the `basket` array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: On page load, your Cart count in the header should update to be the correct
    number of items you added.
  prefs: []
  type: TYPE_NORMAL
- en: We can now proceed with building our Checkout process. The product display in
    the basket is more complicated than the Checkout and Order Confirmation screens
    so, unusually, we'll work backward. Starting with the Order Confirmation page
    and moving to the Checkout page, adding more complexity before we head to the
    basket, adding the ability to exit the products.
  prefs: []
  type: TYPE_NORMAL
- en: Order Confirmation screen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Order Confirmation screen is one that is shown once the order is complete.
    This confirms the items purchased and may include the expected delivery date.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a template within the `OrderConfirmation.js` file with a `<h1>` and
    some relevant content relating to the order being complete:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Open up the application in your browser, add a product to your basket and complete
    an order to confirm it''s working. The next step is to include the `ListProducts`
    component. First, ensure the `ListProducts` component is correctly initialized
    and features an initial template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the `components` object to the `OrderConfirmation` component and include
    the `ListProducts` component. Next, include it in the template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Open the `ListPurchases` component once more to start displaying the products.
    The default state of this component will be to list the products in the basket,
    along with the variation selected. The price for each product will be displayed,
    along with the price if the quantity is more than one. Lastly, a grand total will
    be shown.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to get the basket list into our component. Create a `computed`
    object with a `products` function. This should return the basket products:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'With the products in the basket now available to us, we can loop through them
    in the table displaying the information required. This includes a thumbnail image,
    the product and variation title, price, quantity, and the total price of the item.
    Add a header row to the table too, so the user knows what the column is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Note that the price for each row is simply the unit price multiplied by the
    quantity. We now have a standard product list of the items the user has purchased.
  prefs: []
  type: TYPE_NORMAL
- en: Using Vue filters to format the price
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The price is currently an integer, as that it is in the data. On the product
    page, we just prepended a `$` sign to represent a price, however, this is now
    the perfect opportunity to utilize Vue filters. Filters allow you to manipulate
    the data in the template without using a method. Filters can be chained and are
    used to carry out, generally, a single modification—for example converting a string
    to lowercase or formatting a number to be a currency.
  prefs: []
  type: TYPE_NORMAL
- en: 'Filters are used with the pipe (`|`) operator. If, for example, we had a filter
    to lowercase text, it would be used like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Filters are declared within a `filters` object on the component and accept a
    single parameter of the output preceding it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `filters` object within the `ListPurchases` component and create a
    function inside titled `currency()`. This function accepts a single parameter
    of `val` and should return the variable inside:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now use this function to manipulate the price integers. Add the filter
    to both the unit and total price within the template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'You won''t notice anything in the browser, as we have yet to manipulate the
    value. Update the function to ensure the number is fixed to two decimal places
    and has a `$` preceding it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Our prices are now nicely formatted and displaying correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Calculating a total price
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next addition to our purchase list is a total value of the basket. This
    will need to be calculated in a similar way to the basket count we did earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new `computed` function title: `totalPrice`. This function should
    loop through the products and add the price up, taking into consideration any
    multiple quantities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now update our template to include the total price—ensuring we pass
    it through the `currency` filter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Creating an Order Checkout page
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our `OrderCheckout` page will have a similar makeup to the `OrderConfirmation`
    page - however, in a real shop, this would be the page before payment. This page
    would allow the user to fill in their billing and delivery details before navigating
    to the payment page. Copy the `OrderConfirmation` page and update the title and
    info text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Below the `<list-purchases />` component, create a form with several fields
    so we can collect the billing and delivery name and addresses. For this example,
    just collect the name, first line of the address, and ZIP code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We now need to create a data object and bind each field to a key. To help group
    each set, create an object for both `delivery` and `billing` and create the fields
    inside with the correct names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a `v-model` to each input, linking it to the appropriate data key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to create a `submit` method and collate the data to be able
    to pass it on to the next screen. Create a new method titled `submitForm()`. As
    we are not handling payment in this example, we can route to the confirmation
    page in the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: We can now bind a `submit` event to the form and add a submit button. Like the
    `v-bind:click` attribute (or `@click`), Vue allows you to bind a `submit` event
    to a method using a `@submit=""` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the declaration to the `<form>` element and create a submit button in your
    form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: On submitting your form, the app should redirect you to our Confirmation page.
  prefs: []
  type: TYPE_NORMAL
- en: Copying details between addresses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One feature that several shops have is the ability to mark the delivery address
    to be the same as the billing address. There are several ways we could approach
    this, and how you choose to do it is up to you. The immediate options are:'
  prefs: []
  type: TYPE_NORMAL
- en: Have a "copy details" button—this copies the details from billing to delivery
    but does not keep them in sync
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Have a checkbox that keeps the two in sync—checking the box disables the delivery
    box fields but populates them with the billing details
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For this example, we are going to code the second option.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a checkbox between the two fieldsets that is bound to a property in
    the data object via `v-model` called `sameAddress`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new key in the data object and set it to `false` by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to disable the delivery fields if the checkbox is checked.
    This can be done by activating the  `disabled` HTML attribute based on the checkbox
    result. In a similar way to how we disabled the "Add to cart" button on the product
    page, bind the disabled attribute on the delivery fields to the `sameAddress`
    variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Checking the box will now deactivate the fields - making the user unable to
    enter any data. The next step is to replicate the data across the two sections.
    As our data objects are the same structure, we can create a `watch` function to
    set the `delivery` object to the same as the `billing` object when the checkbox
    is checked.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new `watch` object and function for the `sameAddress` variable. If
    it is `true`, set the delivery object to the same as the billing one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: With the `watch` function added, we can enter data into the billing address,
    check the box, and the delivery address gets populated. The best thing about this
    is that they now stay in sync, so if you update the billing address, the delivery
    address updates on the fly. The problem arises when you uncheck the box and edit
    the billing address—the delivery address still updates. This is because we have
    bound the objects together.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add an `else` statement to make a *copy* of the billing address when the box
    is unchecked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: We now have a functioning Order Confirmation page, which collects billing and
    delivery details.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an editable basket
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We now need to create our basket. This needs to show the products in a similar
    fashion to the Checkout and Confirmation, but it needs to give the user the ability
    to edit the basket contents—either to delete an item or update the quantity.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a starting point, open `OrderBasket.js` and include the `list-purchases`
    component, as we did on the confirmation page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The next thing we need to do is edit the `list-purchases` component. To ensure
    we can differentiate between the views, we are going to add an `editable` prop.
    This will be set to `false` by default and `true` in the basket. Add the `prop` to
    the component in the basket:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'We now need to tell the `ListPurchases` component to accept this parameter
    so we can do something with it within the component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Creating editable fields
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We now have a prop determining if our basket should be editable or not. This
    allows us to show the delete links and make the quantity an editable box.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new table cell next to the quantity one in the `ListPurchases` component
    and make it visible only when the purchases are visible. Make the static quantity
    hidden in this state too. In the new cell, add an input box with the value set
    to the quantity. We are also going to bind a `blur` event to the box. The `blur`
    event is a native JavaScript event that triggers when the input is unfocused.
    On blur, trigger an `updateQuantity` method. This method should accept two arguments;
    the event, which will contain the new quantity, and the SKU for that particular
    product:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Create the new method on the component. This method should loop through the
    products, locating the one with a matching SKU and updating the quantity to an
    integer. We also need to update the store with the result - so that the quantity
    can be updated at the top of the page. We'll create a general mutation that accepts
    the full `basket` array back with new values to allow the same one to be used
    for the product deletion.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the mutation that updates the quantity and commits a mutation titled `updatePurchases`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'In the store, create the mutation that sets the `state.basket` equal to the
    payload:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Updating the quantity should now update the total price of the item and the
    basket count at the top of the page.
  prefs: []
  type: TYPE_NORMAL
- en: Removing items from your cart
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next step is to give the user the ability to remove items from their cart.
    Create a button in the `ListPurchases` component with a click binding. This button
    can go anywhere you want - our example shows it as an extra cell at the end of
    the row. Bind the click action to a method titled `removeItem`. This just needs
    to accept a single parameter of the SKU. Add the following to the `ListPurchases`
    component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the `removeItem` method. This method should filter the `basket` array,
    only returning the objects that *don''t* match the SKU passed in. Once the result
    is filtered, pass the result to the same mutation we used in the `updateQuantity()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'One last enhancement we can make is to trigger the `removeItem` method if the
    quantity is set to 0\. Within the `updateQuantity` method, check the value before
    looping through the products. If it is `0`, or doesn''t exist, run the `removeItem`
    method - passing the SKU through:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Completing the shop SPA
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The last step is to add a link from the `OrderBasket` component to the `OrderCheckout`
    page. This can be done by linking to the `Checkout` route. With that, your checkout
    is complete, along with your shop! Add the following link to the basket:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Well done! You have created a full shop single-page application using `Vue.js`.
    You have learned how to list products and their variations, along with adding
    specific variations to the basket. You've learned how to create shop filters and
    category links, along with creating an editable shopping basket.
  prefs: []
  type: TYPE_NORMAL
- en: As with everything, there are always improvements to be made. Why don't you
    give some of these ideas a go?
  prefs: []
  type: TYPE_NORMAL
- en: Persisting the basket using `localStorage`—so products added to the basket are
    retained between visits and the user pressing refresh
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calculating shipping based on the weight attribute of the products in the basket—use
    a switch statement to create bands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allowing products without variations to be added to the basket from the category
    listing page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Indicating which products have items out of stock when filtered on that variation
    on the category page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any ideas of your own!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
