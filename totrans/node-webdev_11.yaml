- en: Dynamic Client/Server Interaction with Socket.IO
  prefs: []
  type: TYPE_NORMAL
- en: 'The original design model of the web is similar to the way that mainframes worked
    in the 1970s. Both old-school dumb terminals, such as the IBM 3270, and web browsers
    follow a request-response paradigm. The user sends a request and the far-off computer
    sends a response. That request-response paradigm is evident in the Node.js HTTP
    Server API, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]js\1'
  prefs: []
  type: TYPE_NORMAL
- en: We will incorporate user authentication with the `passport` module, used in
    [Chapter 8](1ef2de06-5b7d-44c8-a132-55f822d113cf.xhtml), *Authenticating Users
    with a Microservice*, into some of the real-time interactions we'll implement.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the beginning of `app.mjs`, add this to the `import` statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]js\1'
  prefs: []
  type: TYPE_NORMAL
- en: What this does is create a couple of global scope variables to hold objects
    related to the session configuration. We had been using these values as constants
    when setting up the Express session support. We now need to share those values
    with both the Socket.IO and the Express session managers. When we initialize both Express
    and Socket.IO session handlers, there is an initialization object taking initialization
    parameters. In each, we will pass in the same values for the `secret` and `sessionStore` fields,
    to ensure they are in agreement.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next change is moving some code related to setting up the server object
    from the bottom of `app.mjs` closer to the top, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]js\1'
  prefs: []
  type: TYPE_NORMAL
- en: This is the same configuration of Express session support that we added in [Chapter
    8](1ef2de06-5b7d-44c8-a132-55f822d113cf.xhtml), *Authenticating Users with a Microservice*,
    but modified to use the configuration variables we set up earlier. Done this way,
    both Express and Socket.IO session handling is managed from the same set of information.
  prefs: []
  type: TYPE_NORMAL
- en: We have accomplished the basic setup of Socket.IO in our Express application.
    First, we connected the Socket.IO library to the HTTP Server so that it can handle
    requests on the Socket.IO service. Then we integrated it with Passport session
    management.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now learn how we can use Socket.IO to add real-time updating in Notes.
  prefs: []
  type: TYPE_NORMAL
- en: Real-time updates on the Notes homepage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The goal we're working toward is for the Notes home page to automatically update
    the list of notes as notes are edited or deleted. What we've done so far is to
    restructure the application startup so that Socket.IO is initialized in the Notes
    application. There's no change of behavior yet.
  prefs: []
  type: TYPE_NORMAL
- en: What we will do is send an event whenever a note is created, updated, or deleted.
    Any interested part of the Notes application can listen to those events and act
    appropriately. For example, the Notes home page router module can listen for events,
    and then send an update to the browser. The code in the web browser will listen
    for an event from the server, and in response, it would rewrite the home page.
    Likewise, when a Note is modified, a listener can send a message to the web browser
    with the new note content, or if the Note is deleted, a listener can send a message
    so that the web browser redirects to the home page.
  prefs: []
  type: TYPE_NORMAL
- en: 'These changes are required:'
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring the Notes Store implementations to send create, update, and delete
    events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refactoring the templates to support both Bootstrap on every page and a custom
    Socket.IO client for each page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refactoring the home page and Notes' viewing router modules to listen for Socket.IO
    events and send updates to the browser
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll handle this over the next few sections, so let's get started.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring the NotesStore classes to emit events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to automatically update the user interface when a Note is changed or
    deleted or created, the `NotesStore` must send events to notify interested parties
    of those changes. We will employ our old friend, the `EventEmitter` class, to
    manage the listeners to the events we must send.
  prefs: []
  type: TYPE_NORMAL
- en: Recall that we created a class, `AbstractNotesStore`, and that every storage
    module contains a subclass of `AbstractNotesStore`. Hence we can add listener
    support in `AbstractNotesStore`, making it automatically available to the implementations.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `models/Notes.mjs`, make this change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]js\1'
  prefs: []
  type: TYPE_NORMAL
- en: The changes do not change the original contract of these methods, since they
    still create, update, and destroy notes. The other `NotesStore` implementations
    require similar changes. What's new is that now those methods emit the appropriate
    events for any code that may be interested.
  prefs: []
  type: TYPE_NORMAL
- en: Another task to take care of is initialization, which must happen after `NotesStore`
    is initialized. Recall that setting up `NotesStore` is asynchronous. Therefore,
    calling the `.on` function to register an event listener must happen after `NotesStore`
    is initialized.
  prefs: []
  type: TYPE_NORMAL
- en: 'In both `routes/index.mjs` and `routes/notes.mjs`, add the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]js\1'
  prefs: []
  type: TYPE_NORMAL
- en: This imports the two `init` functions, giving them unique names, then calling
    them once `NotesStore` is set up. At the moment, both functions do nothing, but
    that will change shortly. The important thing is these two `init` functions will
    be called after `NotesStore` is completely initialized.
  prefs: []
  type: TYPE_NORMAL
- en: We have our `NotesStore` sending events when a Note is created, updated, or
    destroyed. Let's now use those events to update the user interface appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: Real-time changes in the Notes home page
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Notes model now sends events as Notes are created, updated, or destroyed.
    For this to be useful, the events must be displayed to our users. Making the events
    visible to our users means the controller and view portions of the application
    must consume those events.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the top of `routes/index.mjs`, add this to the list of imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]js\1'
  prefs: []
  type: TYPE_NORMAL
- en: This extracts what had been the body of the `router` function into a separate
    function. We need to use this function not only in the home page `router` function
    but also when we emit Socket.IO messages for the home page.
  prefs: []
  type: TYPE_NORMAL
- en: We did change the return value. Originally, it contained an array of Note objects,
    and now it contains an array of anonymous objects containing `key` and `title`
    data. We did this because providing the array of Note objects to Socket.IO resulted
    in an array of empty objects being sent to the browser while sending the anonymous
    objects worked correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, add this at the bottom:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]js\1'
  prefs: []
  type: TYPE_NORMAL
- en: This code had been at the bottom of `views/layout.hbs`, and it is the shared
    code snippet we just mentioned. This is meant to be used on every page template,
    and to be followed by custom JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now need to modify `views/layout.hbs` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]js\1'
  prefs: []
  type: TYPE_NORMAL
- en: With this, every one of the templates explicitly loads the JavaScript code for
    Bootstrap and FeatherJS at the bottom of the page. They were previously loaded
    at the bottom of the page in `layout.hbs`. What this bought us is the freedom
    to load Socket.IO client code after Bootstrap and jQuery are loaded.
  prefs: []
  type: TYPE_NORMAL
- en: We have changed every template to use a new policy for loading the JavaScript.
    Let's now take care of the Socket.IO client on the home page.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a Socket.IO client to the Notes home page
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember that our task is to add a Socket.IO client to the home page so that
    the home page receives notifications about created, updated, or deleted Notes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `views/index.hbs`, add this at the bottom, after the `footerjs` partial:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]js\1'
  prefs: []
  type: TYPE_NORMAL
- en: You'll notice in the script that it references `$("#notetitles")` to clear the
    existing list of note titles, then to add a new list. Obviously, that requires
    an `id="notetitles"` attribute on this `<div>`.
  prefs: []
  type: TYPE_NORMAL
- en: Our code in `routes/index.mjs` listened to various events from the Notes model
    and, in response, sent a `notetitles` event to the browser. The browser code takes
    that list of note information and redraws the screen.
  prefs: []
  type: TYPE_NORMAL
- en: You might notice that our browser-side JavaScript is not using ES-2015/2016/2017
    features. This code would, of course, be cleaner if we were to do so. How can
    we know whether our visitors use a browser modern enough for those language features?
    We could use Babel to transpile ES-2015/2016/2017 code into ES5 code capable of
    running on any browser. However, it is a pragmatic trade-off to still write ES5
    code in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Running Notes with real-time home page updates
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We now have enough implemented to run the application and see some real-time
    action.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you did earlier, start the user information microservice in one window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]js\1'
  prefs: []
  type: TYPE_NORMAL
- en: Then, in a browser window, go to `http://localhost:3000` and log in to the Notes
    application. To see the real-time effects, open multiple browser windows. If you
    can use Notes from multiple computers, then do that as well.
  prefs: []
  type: TYPE_NORMAL
- en: In one browser window, start creating and deleting notes, while leaving the
    other browser windows viewing the home page. Create a note, and it should show
    up immediately on the home page in the other browser windows. Delete a note and it
    should disappear immediately as well.
  prefs: []
  type: TYPE_NORMAL
- en: One scenario you might try requires three browser windows. In one window, create
    a new note, and then leave that browser window showing the newly created note.
    In another window, show the Notes home page. And in the third window, show the
    newly created note. Now, delete this newly created note. Of those windows, two
    are correctly updated and are now showing the home page. The third, where we were
    simply viewing the note, is still showing that note even though it no longer exists.
  prefs: []
  type: TYPE_NORMAL
- en: We'll get to that shortly, but first, we need to talk about how to debug your
    Socket.IO client code.
  prefs: []
  type: TYPE_NORMAL
- en: A word on enabling debug tracing in Socket.IO code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is useful to inspect what Socket.IO is doing in case you're having trouble.
    Fortunately, the Socket.IO package uses the same Debug package that Express uses,
    and we can turn on debug tracing just by setting the `DEBUG` environment variable.
    It even uses a variable, `localStorage.debug`, with the same syntax on the client
    side, and we can enable debug tracing in the browser as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the server side, this is a useful `DEBUG` environment variable setting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]js\1'
  prefs: []
  type: TYPE_NORMAL
- en: Immediately, you will start seeing a constant chatter of messages from Socket.IO.
    One thing you'll learn is that even when the application is idle, Socket.IO is
    communicating back and forth.
  prefs: []
  type: TYPE_NORMAL
- en: There are several other `DEBUG` strings to use. For example, Socket.IO relies
    on the Engine.IO package for its transport layer. If you want debug tracing of
    that package, add `engine*` to the `DEBUG` string. The strings shown were most
    helpful during the testing of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've learned about debug tracing, we can take care of changing the
    `/notes/view` pages to react so they changes to the Note being viewed.
  prefs: []
  type: TYPE_NORMAL
- en: Real-time action while viewing notes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It''s cool how we can now see real-time changes in a part of the Notes application.
    Let''s turn to the `/notes/view` page to see what we can do. What comes to mind
    is this functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: Update the note if someone else edits it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Redirect the viewer to the home page if someone else deletes the note.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allow users to leave comments on the note.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the first two features, we can rely on the existing events coming from the
    Notes model. Therefore, we can implement those two features in this section. The
    third feature will require a messaging subsystem, so we'll get to that later in
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: To implement this, we could create one Socket.IO namespace for each Note, such
    as `/notes/${notekey}`. Then, when the browser is viewing a Note, the client code
    added to the `noteview.hbs` template would connect to that namespace. However,
    that raises the question of how to create those namespaces. Instead, the implementation
    selected was to have one namespace, `/notes`, and to create one room per Note.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `routes/notes.mjs`, make sure to import the `io` object as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]js\1'
  prefs: []
  type: TYPE_NORMAL
- en: This simply adds the `export` keyword so we can access the function from elsewhere.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, change the `init` function to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]js\1'
  prefs: []
  type: TYPE_NORMAL
- en: This is how we use Socket.IO to send a message to any browser connected to the
    given namespace and room.
  prefs: []
  type: TYPE_NORMAL
- en: For `noteupdated`, we simply send the new Note data. We again had to convert
    the Note object into an anonymous JavaScript object, because otherwise, an empty
    object arrived in the browser. The client code will have to use, as we will see
    shortly, jQuery operations to update the page.
  prefs: []
  type: TYPE_NORMAL
- en: For `notedestroyed`, we simply send the `key`. Since the client code will respond
    by redirecting the browser to the home page, we don't have to send anything at
    all.
  prefs: []
  type: TYPE_NORMAL
- en: In both, we also call `emitNoteTitles` to ensure the home page is updated if
    it is being viewed.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the note view template for real-time action
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As we did in the home page template, the data contained in these events must
    be made visible to the user. We must not only add client code to the template,
    `views/noteview.hbs`; we need a couple of small changes to the template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]js\1'
  prefs: []
  type: TYPE_NORMAL
- en: In this script, we first connect to the `/notes` namespace and then create listeners
    for the `noteupdated` and `notedestroyed` events.
  prefs: []
  type: TYPE_NORMAL
- en: 'When connecting to the `/notes` namespace, we are passing an extra parameter.
    The optional second parameter to this function is an options object, and in this
    case, we are passing the `query` option. The `query` object is identical in form
    to the `query` object of the `URL` class. This means the namespace is as if it
    were a URL such as `/notes?key=${notekey}`. Indeed, according to the Socket.IO
    documentation, we can pass a full URL, and it also works if the connection is
    created like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]js\1'
  prefs: []
  type: TYPE_NORMAL
- en: We needed to update the title at the top of the page as well, and this `id`
    attribute helps to target the correct element.
  prefs: []
  type: TYPE_NORMAL
- en: For the `notedestroyed` event, we simply redirect the browser window back to
    the home page. The note being viewed has been deleted, and there's no point the user
    continuing to look at a note that no longer exists.
  prefs: []
  type: TYPE_NORMAL
- en: Running Notes with pseudo-real-time updates while viewing a note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At this point, you can now rerun the Notes application and try the new real-time
    updates feature.
  prefs: []
  type: TYPE_NORMAL
- en: By now you have put Notes through its paces many times, and know what to do.
    Start by launching the user authentication server and the Notes application. Make
    sure there is at least one note in the database; add one if needed. Then, open
    multiple browser windows with one viewing the home page and two viewing the same
    note. In a window viewing the note, edit the note to make a change, making sure
    to change the title. The text change should change on both the home page and the
    page viewing the note.
  prefs: []
  type: TYPE_NORMAL
- en: Then delete the note and watch it disappear from the home page, and further,
    the browser window that had viewed the note is now on the home page.
  prefs: []
  type: TYPE_NORMAL
- en: We took care of a lot of things in this section, and the Notes application now
    has dynamic updates happening. To do this, we created an event-based notification
    system, then used Socket.IO in both browser and server to communicate data back
    and forth.
  prefs: []
  type: TYPE_NORMAL
- en: We have implemented most of what we've set out to do. By refactoring the Notes
    Store implementations to send events, we are able to send events to Socket.IO
    clients in the browser. That in turn is used to automatically update the Notes
    home page, and the `/notes/view` page.
  prefs: []
  type: TYPE_NORMAL
- en: The remaining feature is for users to be able to write comments on Notes. In
    the next section, we will take care of that by adding a whole new database table
    to handle messages.
  prefs: []
  type: TYPE_NORMAL
- en: Inter-user chat and commenting for Notes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is cool! We now have real-time updates in Notes as we edit delete or create
    notes. Let's now take it to the next level and implement something akin to inter-user
    chatting.
  prefs: []
  type: TYPE_NORMAL
- en: Earlier, we named three things we could do with Socket.IO on `/notes/view` pages.
    We've already implemented live updating when a Note is changed and a redirect
    to the home page if a Note is deleted; the remaining task is to allow users to
    make comments on Notes.
  prefs: []
  type: TYPE_NORMAL
- en: It's possible to pivot our Notes application concept and take it in the direction
    of a social network. In the majority of such networks, users post things (notes,
    pictures, videos, and so on), and other users comment on those things. Done well,
    these basic elements can develop a large community of people sharing notes with
    each other. While the Notes application is kind of a toy, it's not too terribly
    far from being a basic social network. Commenting the way we will do now is a
    tiny step in that direction.
  prefs: []
  type: TYPE_NORMAL
- en: On each note page, we'll have an area to display messages from Notes users.
    Each message will show the username, a timestamp, and their message. We'll also
    need a method for users to post a message, and we'll also allow users to delete
    messages.
  prefs: []
  type: TYPE_NORMAL
- en: Each of those operations will be performed without refreshing the screen. Instead,
    code running inside the web page will send commands to/from the server and take
    action dynamically. By doing this, we'll learn about Bootstrap modal dialogs,
    as well as more about sending and receiving Socket.IO messages. Let's get started.
  prefs: []
  type: TYPE_NORMAL
- en: Data model for storing messages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We need to start by implementing a data model for storing messages. The basic fields
    required are a unique ID, the username of the person sending the message, the
    namespace and the room associated with the message, the message, and finally a
    timestamp for when the message was sent. As messages are received or deleted,
    events must be emitted from the data model so we can do the right thing on the
    web page. We associate messages with a room and namespace combination because
    in Socket.IO that combination has proved to be a good way to address a specific
    page in the Notes application.
  prefs: []
  type: TYPE_NORMAL
- en: This data model implementation will be written for Sequelize. If you prefer
    a different storage solution, you can, by all means, re-implement the same API
    on other data storage systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file, `models/messages-sequelize.mjs`, containing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]js\1'
  prefs: []
  type: TYPE_NORMAL
- en: The structure of `connectDB` is similar to what we did in `notes-sequelize.mjs`.
    We use the same `connectSequlz` function to connect with the same database, and
    we return immediately if the database is already connected.
  prefs: []
  type: TYPE_NORMAL
- en: With `SQMessage.init`, we define our message schema in the database. We have
    a simple database schema that is fairly self-explanatory. To emit events about
    messages, we're using a `Sequelize` feature to be called at certain times.
  prefs: []
  type: TYPE_NORMAL
- en: The `id` field won't be supplied by the caller; instead, it will be autogenerated.
    Because it is an `autoIncrement` field, each message that's added will be assigned a
    new `id` number by the database. The equivalent in MySQL is the `AUTO_INCREMENT`
    attribute on a column definition.
  prefs: []
  type: TYPE_NORMAL
- en: The `namespace` and `room` fields together define which page in Notes each message
    belongs to. Remember that when emitting an event with Socket.IO we can target
    the event to one or both of those spaces, and therefore we will use these values
    to target each message to a specific page.
  prefs: []
  type: TYPE_NORMAL
- en: So far we defined one namespace, `/home`, for the Notes home page, and another
    namespace, `/notes`, for viewing an individual note. In theory, the Notes application
    could be expanded to have messages displayable in other areas. For example, a
    `/private-message` namespace could be used for private messages. Therefore, the
    schema is defined with both a `namespace` and `room` field so that, in due course,
    we could use messages in any future part of the Notes application that may be
    developed.
  prefs: []
  type: TYPE_NORMAL
- en: For our current purposes, messages will be stored with `namespace` equal to
    `/home`, and `room` equal to the `key` of a given Note.
  prefs: []
  type: TYPE_NORMAL
- en: We will use the `timestamp` to present messages in the order of when they were
    sent. The `from` field is the username of the sender.
  prefs: []
  type: TYPE_NORMAL
- en: To send notifications about created and destroyed messages, let's try something
    different. If we follow the pattern we used earlier, the functions we're about
    to create will have `emitter.emit` calls with corresponding messages. But Sequelize
    offers a different approach.
  prefs: []
  type: TYPE_NORMAL
- en: With `Sequelize`, we can create what are called hook methods. Hooks can also
    be called **life cycle events**, and they are a series of functions we can declare.
    Hook methods are invoked when certain trigger states exist for the objects managed
    by Sequelize. In this case, our code needs to know when a message is created,
    and when a message is deleted.
  prefs: []
  type: TYPE_NORMAL
- en: Hooks are declared as shown in the options object. A field named `hooks` in
    the `schema` options object defines hook functions. For each hook we want to use,
    add an appropriately named field containing the hook function. For our needs,
    we need to declare `hooks.afterCreate` and `hooks.afterDestroy`. For each, we've
    declared a function that takes the instance of the `SQMessage` object that has
    just been created or destroyed. And, with that object, we call `emitter.emit`
    with either the `newmessage` or `destroymessage` event name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Continue by adding this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]js\1'
  prefs: []
  type: TYPE_NORMAL
- en: This is to be called when a user posts a new comment/message. We store it in
    the database, and the hook emits an event saying the message was created.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that the `id` field is auto-created as the new message is stored. Therefore,
    it is not supplied when calling `SQMessage.create`.
  prefs: []
  type: TYPE_NORMAL
- en: This function, and the next, could have contained the `emitter.emit` call to
    send the `newmessage` or `destroymessage` events. Instead, those events are sent
    in the hook functions we created earlier. The question is whether it is correct
    to place `emitter.emit` in a hook function, or to place it here.
  prefs: []
  type: TYPE_NORMAL
- en: The rationale used here is that by using hooks we are assured of always emitting
    the messages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, add this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]js\1'
  prefs: []
  type: TYPE_NORMAL
- en: This function retrieves recent messages, and the immediate use case is for this
    to be used while rendering `/notes/view` pages.
  prefs: []
  type: TYPE_NORMAL
- en: While our current implementation is for viewing a Note, it is generalized to
    work for any Socket.IO namespace and room. This is for possible future expansion,
    as we explained earlier. It finds the most recent 20 messages associated with
    the given namespace and room combination, then returns a cleaned-up list to the
    caller.
  prefs: []
  type: TYPE_NORMAL
- en: In `findAll`, we specify an `order` attribute. This is similar to the `ORDER
    BY` phrase in SQL. The `order` attribute takes an array of one or more descriptors
    declaring how Sequelize should sort the results. In this case, there is one descriptor,
    saying to sort by the `timestamp` field in descending order. This will cause the
    most recent message to be displayed first.
  prefs: []
  type: TYPE_NORMAL
- en: We have created a simple module to store messages. We didn't implement the full
    set of **create, read, update, and delete** (**CRUD**) operations because they
    weren't necessary for this task. The user interfaces we're about to create only
    let folks add new messages, delete existing messages, and view the current messages.
  prefs: []
  type: TYPE_NORMAL
- en: Let's get on with creating the user interface.
  prefs: []
  type: TYPE_NORMAL
- en: Adding support for messages to the Notes router
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we can store messages in the database, let's integrate this into the
    Notes router module.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating messages to the `/notes/view` page will require some new HTML and
    JavaScript in the `notesview.hbs` template, and some new Socket.IO communications
    endpoints in the `init` function in `routes/notes.mjs`. In this section, let's
    take care of those communications endpoints, then in the next section let's talk
    about how to set it up in the user interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `routes/notes.mjs`, add this to the `import` statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]js\1'
  prefs: []
  type: TYPE_NORMAL
- en: These receive notifications of new messages, or destroyed messages, from `models/messages-sequelize.mjs`,
    then forwards the notification to the browser. Remember that the message object
    contains the namespace and room, therefore this lets us address this notification
    to any Socket.IO communication channel.
  prefs: []
  type: TYPE_NORMAL
- en: Why didn't we just make the Socket.IO call in `models/messages-sequelize.mjs`?
    Clearly, it would have been slightly more efficient, require fewer lines of code,
    and therefore fewer opportunities for a bug to creep in, to have put the Socket.IO
    call in `messages-sequelize.mjs`. But we are maintaining the separation between
    model, view, and controller, which we talked of earlier in [Chapter 5](582d3898-0135-430c-8b6e-8326f287e18b.xhtml), *Your
    First Express Application*. Further, can we predict confidently that there will
    be no other use for messages in the future? This architecture allows us to connect
    multiple listener methods to those message events, for multiple purposes.
  prefs: []
  type: TYPE_NORMAL
- en: In the user interface, we'll have to implement corresponding listeners to receive
    these messages, then take appropriate user interface actions.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `connect` listener in the `init` function, add these two new event listeners:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]js\1'
  prefs: []
  type: TYPE_NORMAL
- en: That function in the third parameter becomes the `fn` parameter in the `create-message`
    event handler function. Then, anything supplied to a call to `fn` will arrive
    in this function as the `result` parameter. It doesn't matter that it's a browser
    supplying that function across a connection to the server and that the call to
    the function happens on the server, Socket.IO takes care of transporting the response
    data back to the browser code and invoking the acknowledgment function there.
    The last thing to note is that we're being lazy with error reporting. So, put
    a task on the backlog to improve error reporting to the users.
  prefs: []
  type: TYPE_NORMAL
- en: The next task is to implement code in the browser to make all this visible to
    the user.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the note view template for messages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We need to dive back into `views/noteview.hbs` with more changes so that we
    can view, create, and delete messages. This time, we will add a lot of code, including
    using a Bootstrap modal popup to get the message, the Socket.IO messages we just
    discussed, and the jQuery manipulations to make everything appear on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: We want the `/notes/view` page to not cause unneeded page reloads. Instead,
    we want the user to add a comment by having a pop-up window collect the message
    text, and then the new message is added to the page, without causing the page
    to reload. Likewise, if another user adds a message to a Note, we want the message
    to show up without the page reloading. Likewise, we want to delete messages without
    causing the page to reload, and for messages to be deleted for others viewing
    the note without the page reloading.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, this will involve several Socket.IO messages going back and forth
    between browser and server, along with some jQuery DOM manipulations. We can do
    both without reloading the page, which generally improves the user experience.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by implementing the user interface to create a new message.
  prefs: []
  type: TYPE_NORMAL
- en: Composing messages on the Note view page
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next task for the `/notes/view` page is to let the user add a message. They'll
    click a button, a pop-up window lets them enter the text, they'll click a button
    in the popup, the popup will be dismissed, and the message will show up. Further,
    the message will be shown to other viewers of the Note.
  prefs: []
  type: TYPE_NORMAL
- en: The Bootstrap framework includes support for Modal windows. They serve a similar
    purpose to Modal dialogs in desktop applications. Modal windows appear above existing
    windows of an application, while preventing interaction with other parts of the
    web page or application. They are used for purposes such as asking a question
    of the user. The typical interaction is to click a button, then the application
    pops up a Modal window containing some UI elements, the user interacts with the
    Modal, then dismisses it. You will certainly have interacted with many thousands
    of Modal windows while using computers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s first add a button with which the user will request to add a comment.
    In the current design, there is a row of two buttons below the Note text. In `views/noteview.hbs`,
    let''s add a third button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]js\1'
  prefs: []
  type: TYPE_NORMAL
- en: Again, this comes directly from the Bootstrap documentation for the Modal component,
    along with a simple form to collect the message.
  prefs: []
  type: TYPE_NORMAL
- en: Notice there is `<div class="modal-dialog">`, and within that, `<div class="model-content">`.
    Together, these form what is shown within the dialog window. The content is split
    between a `<div class="modal-header">` for the top row of the dialog, and a `<div
    class="modal-body">` for the main content.
  prefs: []
  type: TYPE_NORMAL
- en: The `id` value on the outermost element, `id="notes-comment-modal"`, matches
    the target declared in the button, `data-target="#notes-comment-modal"`. Another
    connection to make is `aria-labelledby`, which matches the `id` of the `<h5 class="modal-title">`
    element.
  prefs: []
  type: TYPE_NORMAL
- en: '`<form id="submit-comment">` is minimal because we will not use it to submit
    anything over an HTTP connection to a regular URL. Therefore, it does not have
    `action` and `method` attributes. Otherwise, this is a normal everyday Bootstrap
    `form`, with a `fieldset` and various form elements.'
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to add the client-side JavaScript code to make this functional.
    When clicking the button, we want some client code to run, which will send a `create-message`
    event matching the code we added to `routes/notes.mjs`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `views/noteview.hbs`, we have a section using `$(document).ready` that contains
    the client code. In that function, add a section that exists only if the `user`
    object exists, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]js\1'
  prefs: []
  type: TYPE_NORMAL
- en: This matches the button in the form we just created. Normally in the event handler
    for a `type="submit"` button, we would use `event.preventDefault` to prevent the
    normal result, which is to reload the page. But that's not required in this case.
  prefs: []
  type: TYPE_NORMAL
- en: The function gathers various values from the form elements and sends the `create-message`
    event. If we refer back to the server-side code, `create-message` calls `postMessage`,
    which saves the message to the database, which then sends a `newmessage` event,
    which makes its way to the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, we will need a `newmessage` event handler, which we'll get to in
    the next section. In the meantime, you should be able to run the Notes application,
    add some messages, and see they are added to the database.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that this has a third parameter, a function that when called causes the
    Modal to be dismissed, and clears any message that was entered. This is the acknowledgment
    function we mentioned earlier, which is invoked on the server, and Socket.IO arranges
    to then invoke it here in the client.
  prefs: []
  type: TYPE_NORMAL
- en: Showing any existing messages on the Note view page
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we can add messages, let's learn how to display messages. Remember
    that we've defined an SQMessage schema and that we've defined a function, `recentMessages`,
    to retrieve the recent messages.
  prefs: []
  type: TYPE_NORMAL
- en: We have two possible methods to display existing messages when rendering Note
    pages. One option is for the page, when it initially displays, to send an event requesting
    the recent messages, and rendering those messages on the client once they're received.
    The other option is to render the messages on the server, instead. We've chosen
    the second option, server-side rendering.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `routes/notes.mjs`, modify the `/view` router function like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]js\1'
  prefs: []
  type: TYPE_NORMAL
- en: If there is a `messages` object, these steps through the array, and for each
    entry, it sets up a Bootstrap `card` component to display the message. The messages
    are displayed within `<div id="noteMessages">`, which we'll target in DOM manipulations
    later. The markup for each message comes directly from the Bootstrap documentation,
    with a few modifications.
  prefs: []
  type: TYPE_NORMAL
- en: In each case, the `card` component has an `id` attribute we can use to associate
    with a given message in the database. The `button` component will be used to cause
    a message to be deleted, and it carries data attributes to identify which message
    would be deleted.
  prefs: []
  type: TYPE_NORMAL
- en: With this, we can view a Note, and see any messages that have been attached.
    We did not select the ordering of the messages but remember that in `models/messages-sequelize.mjs`
    the database query orders the messages in reverse chronological order.
  prefs: []
  type: TYPE_NORMAL
- en: In any case, our goal was for messages to automatically be added without having
    to reload the page. For that purpose, we need a handler for the `newmessage` event,
    which is a task left over from the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Below the handler for the `submitNewComment` button, add this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]js\1'
  prefs: []
  type: TYPE_NORMAL
- en: The `socket` object already exists and is the Socket.IO connection to the room
    for this Note. We send to the room a `delete-message` event giving the values
    stored in data attributes on the button.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we''ve already seen, on the server the `delete-message` event invokes the
    `destroyMessage` function. That function deletes the message from the database
    and also emits a `destroymessage` event. That event is received in `routes/notes.mjs`,
    which forwards the message to the browser. Therefore, we need an event listener
    in the browser to receive the `destroymessage` event:'
  prefs: []
  type: TYPE_NORMAL
- en: '```js\1'
  prefs: []
  type: TYPE_NORMAL
- en: Refer back and see that every message display `card` has an `id` parameter fitting
    the pattern shown here. Therefore, the jQuery `remove` function takes care of
    removing the message from the display.
  prefs: []
  type: TYPE_NORMAL
- en: Running Notes and passing messages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: That was a lot of code, but we now have the ability to compose messages, display
    them on the screen, and delete them, all with no page reloads.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can run the application as we did earlier, first starting the user authentication
    server in one command-line window and the Notes application in another:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8600d6c4-884c-4758-bf91-e57db6f92371.png)'
  prefs: []
  type: TYPE_IMG
- en: It shows us any existing messages on a Note.
  prefs: []
  type: TYPE_NORMAL
- en: 'While entering a message, the Modal looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/332a268c-23b4-440f-aa4c-b3084db30df7.png)'
  prefs: []
  type: TYPE_IMG
- en: Try this with multiple browser windows viewing the same note or different notes.
    This way, you can verify that notes show up only on the corresponding note window.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We came a long way in this chapter, but maybe Facebook doesn't have anything
    to fear from the baby steps we took toward converting the Notes application into
    a social network. Still, we added interesting new features to the application,
    which gave us the opportunity to explore some really cool technology for pseudo-real-time
    communication between browser sessions.
  prefs: []
  type: TYPE_NORMAL
- en: We learned about using Socket.IO for pseudo-real-time web experiences. As we
    learned, it is a framework for dynamic interaction between server-side code and
    client code running in the browser. It follows an event-driven model for sending
    events between the two. Our code used this both for notifications to the browser
    of events occurring on the server and for users who wish to write comments.
  prefs: []
  type: TYPE_NORMAL
- en: We learned about the value of events being sent from one part of the server-side
    code to another. This lets us have client-side updates based on changes occurring
    in the server. This used the `EventEmitter` class with listener methods that directed
    events and data to the browser.
  prefs: []
  type: TYPE_NORMAL
- en: In the browser, we used jQuery DOM manipulation to change the user interface
    in response to these dynamically sent messages. By using Socket.IO and normal
    DOM manipulation, we were able to refresh the page content while avoiding page
    reloads.
  prefs: []
  type: TYPE_NORMAL
- en: We also learned about Modal windows, using that technique to create comments. Of
    course, there is much more that could be done, such as a different experience
    of creating, deleting, or editing notes.
  prefs: []
  type: TYPE_NORMAL
- en: To support all this, we added another kind of data, the *message*, and an accompanying
    database table, managed by a new Sequelize schema. It is used for representing
    the comments our users can make on notes, but is general enough to be used in
    other ways.
  prefs: []
  type: TYPE_NORMAL
- en: Socket.IO, as we've seen, gives us a rich foundation of events passing between
    server and client that can build multiuser, multichannel communication experiences
    for your users.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look into Node.js application deployment on real
    servers. Running code on our laptop is cool, but to hit the big time, the application
    needs to be properly deployed.
  prefs: []
  type: TYPE_NORMAL
