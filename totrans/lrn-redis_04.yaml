- en: Chapter 4. Functions in the Redis Server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, we saw some features of Redis Server that make it
    a key-value NoSQL. We also saw that Redis, apart from storing vanilla key-values,
    also provides semantics to store data in a structured way. This feature in itself
    makes Redis stand out in the crowd, since most of the other databases (RDBMS and
    other NoSQL) don't provide interfaces which programmers can use. Other data stores
    have a fixed way of storing information, such as documents or maps, and programmers
    have to convert their data into these semantics to hold information. However,
    in Redis, programmers can store information in the same sematic that they use
    in their programs, such as a map, list, and so on. This in way provides a better
    and an easier way of understanding the program. Apart from that, Redis provides
    functions which elevate Redis from being just a data store to more like a framework
    builder, or in other words, more like a Swiss army knife. In this chapter, we
    will explore these functions and try to understand them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following are the functionalities that we would be discussing:'
  prefs: []
  type: TYPE_NORMAL
- en: Real time messaging (Publish/Subscribe)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pipeline
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transaction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scripting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connection management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Real-time messaging (PUB/SUB)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Enterprises and social media solutions use messaging in a similar way, and
    in a way, this forms the backbone of any framework or any solution. Messaging
    also enables us to have architectures which are loosely coupled where components
    interact via messages and events. Redis provides mechanism to have real time messaging
    between components. Unlike other messaging systems, the big difference in the
    messaging model provided in Redis is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: It does not store the message after delivering it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It does not store the message if the client (subscriber) was unable to consume
    it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This can be a disadvantage if compared to a traditional messaging system but
    is advantageous where data has importance in real time and need not be stored.
    The message is always sent sequentially. Apart from that, Redis messaging system
    is simplistic and easy to learn, and does not have the fluff of some of the other
    messaging systems.
  prefs: []
  type: TYPE_NORMAL
- en: '![Real-time messaging (PUB/SUB)](img/0123OS_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Publish subscribe model of Redis
  prefs: []
  type: TYPE_NORMAL
- en: 'Following are the commands in Redis that can be used for creating a messaging
    framework:'
  prefs: []
  type: TYPE_NORMAL
- en: '`PUBLISH`: This will post a message to a given channel or pattern.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The time complexity for this command is given by `O (N+M)`, where `N` is the
    number of clients who have subscribed to this channel and `M` is the number of
    patterns the client is subscribed to.
  prefs: []
  type: TYPE_NORMAL
- en: '`SUBSCRIBE`: This subscribes a client to a channel for messages. For example,
    if a client is subscribed to channel `news.headlines`, then it will get any message
    published for `news.headlines` channel.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The time complexity for this command is given by `O (N)`, where `N` is the number
    of channels the client is subscribed to.
  prefs: []
  type: TYPE_NORMAL
- en: '`PSUBSCRIBE`: This subscribes a client to channels where the pattern name matches
    the channel name. For example, suppose the channels are registered by the following
    names:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`news.sports.cricket`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`news.sports.tennis`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, for a pattern like `news.sports.*`, the subscriber will be getting messages
    for channels `news.sports.cricket` and `news.sports.tennis`.
  prefs: []
  type: TYPE_NORMAL
- en: The time complexity for this command is `O (N)`, where `N` is the number of
    patterns the client is subscribed to.
  prefs: []
  type: TYPE_NORMAL
- en: '`PUBSUB`: This is a command which along with some sub-command helps to take
    a stock of patterns and channels registered in Redis.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is only available as of Redis 2.8.0\. The Windows version of Redis is based
    on the 2.6 branch and does not support this command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Other `PUBSUB` related commands which help in finding information regarding
    publishers and subscribers are listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`PUBSUB CHANNELS [pattern]`: This lists the currently active channels'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PUBSUB NUMSUB [channel]`: This lists the number of subscribers to the mentioned
    channels'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PUBSUB NUMPAT`: This lists the number of subscriptions to all the patterns'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PUNSUBSCRIBE`: This command unsubscribes the client from a pattern'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UNSUBSCRIBE`: This command unsubscribes the client from a channel'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s have a simple program in Java using Jedis to demonstrate a simple PUB/SUB
    program. Jedis exposes interface for publishing and has all the functionalities
    supported by Redis. The interface exposed for subscribing to a message is a bit
    tricky since the subscriber should be in a ready state before the publisher publishes
    a message. This is because Redis cannot store message if the subscriber is unavailable.
    The code for publisher: `SubscriberProcessor.java`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The subscriber processor needs to subscribe to a channel. For doing so, it
    needs to have an instance which is always in a listening mode. In this sample,
    `Subscriber.java` is the class which does so by extending Jedis PUB/SUB. This
    abstract class provides methods to manage the life cycle of the subscriber. Next
    is the code which provides necessary hooks to subscribe to a channel pattern and
    listen to messages for a channel or a pattern. The code to subscribe to a pattern
    is commented; to see it in action, we need to uncomment it and comment the code
    which is subscribing to a channel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Before you start the publisher to send messages to a channel, it's better to
    start the subscriber processor, which is going to listen to any message posted
    to its subscribed channel or pattern. In this case, the subscriber processor will
    be listening to a news channel or will subscribe to pattern `[news.*]`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A common class used in these samples is connection manager and the code for
    the same is listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'To fire the publishers, use the following code for publisher. The code for
    publisher, `Publisher.java`, is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In this sample, the code will publish a message to a channel called `news`,
    and to see it working make sure that the subscriber is ready and to publish the
    message to a pattern, comment the code which publishes to a channel, and uncomment
    the code which publishes the message to a pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Pipelines in Redis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Redis provides a mechanism for faster execution, called *pipeline*. This groups
    up all the commands as one command block and sends it to the server for execution.
    The results of all the commands get queued in a response block and sent back.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing the way pipeline works with multiple individual commands sent across
    a connection will give us an idea of how pipeline is more efficient and where
    it needs to be used. Let's assume a scenario where we have to send three commands
    to Redis. The time taken to send any command to Redis is *X* seconds, so the same
    amount of time is required to send the response. The total time spent in going
    and return journey is *2X* seconds. Let's also assume that the time taken for
    execution is another *X* seconds. Now in the pipeline commands, since we are sending
    three commands as one block, the time taken for going to Redis is around *X* seconds
    , the time taken for processing all the three commands is *3X* seconds, and the
    time taken for the return journey is also *X* seconds. The total time taken in
    pipeline commands is *5X* seconds. Compare this with a scenario where we have
    to send individual commands. The time taken for sending a single command and its
    return journey is equal to *2X* and time taken for including execution is *3X*.
    Since we are talking of three commands, the total time is equal to *9X*. This
    *9X* seconds time compared to *5X* seconds proves its efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: 'One thing we have to keep in mind is that pipeline does guarantee atomicity
    but only executes multiple commands and returns response in one response block.
    Following is a simple representation of commands invoked in a pipeline:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Pipelines in Redis](img/0123OS_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Pipeline in Redis
  prefs: []
  type: TYPE_NORMAL
- en: 'Next is the representation of multiple commands sent across multiple connections.
    As we can see, the time taken for sending the response back is saved in case of
    pipelining the commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Pipelines in Redis](img/0123OS_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Multiple commands using individual connections in Redis
  prefs: []
  type: TYPE_NORMAL
- en: 'This way of sending bulk command can be seen in RDBMS also, where we have the
    provision for sending bulk JDBC as a *batch*. To check this fact, let''s write
    a program and check the time difference between running a program in pipeline
    and without pipeline:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The result in my computer is as follows, which of course, may vary depending
    upon machine configurations used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Pipeline gives the advantage of faster execution but comes with some limitations.
    This works only when target Redis instance is same, that is, it won't work in
    a Sharded environment since the connection will be different for every Redis instance.
    Pipeline also has a lacuna when the commands are not inter-dependent or where
    custom logic has to be written to form a compound command. In this case also,
    Redis provides a mechanism of *scripting*, which we will be covering later in
    the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Transactions in Redis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Redis as a NOSQL data store provides a loose sense of transaction. As in a
    traditional RDBMS, the transaction starts with a `BEGIN` and ends with either
    `COMMIT` or `ROLLBACK`. All these RDBMS servers are multithreaded, so when a thread
    locks a resource, it cannot be manipulated by another thread unless and until
    the lock is released. Redis by default has `MULTI` to start and `EXEC` to execute
    the commands. In case of a transaction, the first command is always `MULTI`, and
    after that all the commands are stored, and when `EXEC` command is received, all
    the stored commands are executed in sequence. So inside the hood, once Redis receives
    the `EXEC` command, all the commands are executed as a single isolated operation.
    Following are the commands that can be used in Redis for transaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '`MULTI`: This marks the start of a transaction block'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EXEC`: This executes all the commands in the pipeline after `MULTI`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WATCH`: This watches the keys for conditional execution of a transaction'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UNWATCH`: This removes the `WATCH` keys of a transaction'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DISCARD`: This flushes all the previously queued commands in the pipeline'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following figure represents how transaction in Redis works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Transactions in Redis](img/0123OS_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Transaction in Redis
  prefs: []
  type: TYPE_NORMAL
- en: Pipeline versus transaction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we have seen for many generic terms in pipeline the commands are grouped
    and executed, and the responses are queued in a block and sent. But in transaction,
    until the `EXEC` command is received, all the commands received after `MULTI`
    are queued and then executed. To understand that, it is important to take a case
    where we have a multithreaded environment and see the outcome.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the first case, we take two threads firing pipelined commands at Redis.
    In this sample, the first thread fires a pipelined command, which is going to
    change the value of a key multiple number of times, and the second thread will
    try to read the value of that key. Following is the class which is going to fire
    the two threads at Redis: `MultiThreadedPipelineCommandTest.java`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The code for the client which is going to read the value of the key when pipeline
    is executed is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The result will vary as per machine configuration but by changing the thread
    sleep time and running the program couple of times, the result will be similar
    to the one shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Please fire `FLUSHDB` command every time you run the test, otherwise you end
    up seeing the value of the previous test run, that is 300,000
  prefs: []
  type: TYPE_NORMAL
- en: Now we will run the sample in a transaction mode, where the command pipeline
    will be preceded by `MULTI` keyword and succeeded by `EXEC` command. This client
    is similar to the previous sample where two clients in separate threads will fire
    commands to a single key on Redis.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following program is a test client that gives two threads one with commands
    in transaction mode and the second thread will try to read and modify the same
    resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This program will try to modify the resource and read the resource while the
    transaction is going on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This program will start with `MULTI` command, try to modify the resource, end
    it with `EXEC` command, and later read the value of the resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of the preceding program will vary as per machine configuration
    but by changing the thread sleep time and running the program couple of times,
    the result will be similar to the one shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Fire the `FLUSHDB` command every time you run the test. The idea is that the
    program should not pick up a value obtained because of a previous run of the program.
    The proof that the single command program is able to write to the key is if we
    see the following line: `The return code is [1]`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s analyze the result. In case of pipeline, a single command reads the
    value and the pipeline command sets a new value to that key as evident in the
    following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now compare this with what happened in case of transaction when a single command
    tried to read the value but it was blocked because of the transaction. Hence the
    value will be `NULL` or 300,000.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: So the difference in output can be attributed to the fact that in a transaction,
    if we have started a `MULTI` command, and are still in the process of queueing
    commands (that is, we haven't given the server the `EXEC` request yet), then any
    other client can still come in and make a request, and the response would be sent
    to the other client. Once the client gives the `EXEC` command, then all other
    clients are blocked while all of the queued transaction commands are executed.
  prefs: []
  type: TYPE_NORMAL
- en: Pipeline and transaction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To have a better understanding, let''s analyze what happened in case of pipeline.
    When two different connections made requests to the Redis for the same resource,
    we saw a result where client-2 picked up the value while client-1 was still executing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Pipeline and transaction](img/0123OS_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Pipeline in Redis in a multi connection environment
  prefs: []
  type: TYPE_NORMAL
- en: What it tells us is that requests from the first connection which is pipeline
    command is stacked as one command in its execution stack, and the command from
    the other connection is kept in its own stack specific to that connection. The
    Redis execution thread time slices between these two executions stacks, and that
    is why client-2 was able to print a value when the client-1 was still executing.
  prefs: []
  type: TYPE_NORMAL
- en: Let's analyze what happened in case of transaction here. Again the two commands
    (transaction commands and `GET` commands) were kept in their own execution stacks,
    but when the Redis execution thread gave time to the `GET` command, and it went
    to read the value, seeing the lock it was not allowed to read the value and was
    blocked. The Redis execution thread again went back to executing the transaction
    commands, and again it came back to `GET` command where it was again blocked.
    This process kept happening until the transaction command released the lock on
    the resource and then the `GET` command was able to get the value. If by any chance,
    the `GET` command was able to reach the resource before the transaction lock,
    it got a null value.
  prefs: []
  type: TYPE_NORMAL
- en: Please bear in mind that Redis does not block execution to other clients while
    queuing transaction commands but blocks only during executing them.
  prefs: []
  type: TYPE_NORMAL
- en: '![Pipeline and transaction](img/0123OS_04_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Transaction in Redis multi connection environment
  prefs: []
  type: TYPE_NORMAL
- en: This exercise gave us an insight into what happens in the case of pipeline and
    transaction.
  prefs: []
  type: TYPE_NORMAL
- en: Scripting in Redis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Lua** is a high performing scripting language with interpreter written in
    C. Redis provides mechanism to extend the functionality of Redis by providing
    support for Lua in the server side. Since Redis is implemented in C, it gives
    a natural synergy for Lua to be offered along with Redis as a server add on. The
    Lua interpreter shipped along with Redis is with limited capability and following
    libraries are shipped along with it:'
  prefs: []
  type: TYPE_NORMAL
- en: The `base` library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `table` library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `string` library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `math` library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `debug` library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `cjson` library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `cmsgpack` library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Libraries which can do File I/O and Networking are not included, so you cannot
    send a message from LUA script in REDIS to another external system.
  prefs: []
  type: TYPE_NORMAL
- en: Before we start with fun stuff, it's always better to have a hang of the language.
    LUA has its own dedicated site and tons of resources are available to LUA, but
    the next section concentrates on just enough LUA to get started for Redis.
  prefs: []
  type: TYPE_NORMAL
- en: Brief introduction on Lua
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Okay, by now we all know that LUA is an interpreted language and it has support
    in Redis. To make use of the capability of Redis, let''s learn couple of things
    about LUA. Types and values supported in LUA are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Nil**: Nil is a type with single value *nil*. On comparing it with Java,
    it can be taken as *null*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Booleans**: These will have either true or false as values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Numbers**: These represent double precession floating point numbers. So we
    can write our numbers as 1, 1.1, 2e+10, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**String**: These represent a sequence of characters as is common in most of
    the scripting and programming languages. In LUA, strings are immutable in nature;
    for example, `"Learning Redis"` and `''Learning Redis''`. LUA provides methods
    in string library to find substring, replace characters, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tables**: These are like arrays which can be indexed with numbers and strings
    except *nil*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Control statements and loops in LUA are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `if then else` statement: As in Java, where we have only `if`/`else`, LUA
    supports something similar in the form of `if`/`then`/`else`. Following is the
    code example for it:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The `while` loop: This is similar to Java where looping has a similar syntax:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The `repeat` statement: This is similar to `do`/`while` in Java. This will
    guarantee at least one time iteration:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The `for` loop: This is similar to the `for` loop in Java:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Two keywords in LUA that you will use frequently while executing control statements
    are `return` and `break`. Following is a simple sample to demonstrate return keyword,
    getting used in a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Next is a simple sample to demonstrate break keyword getting used in a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: With this minimal understanding of how LUA works, let's run a sample in Redis,
    and then take the understanding forward. But before that, let's understand how
    LUA works in Redis.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure describes how LUA works with Redis. To understand how
    things happen internally, it is important to remember that Redis works in a single
    thread model and that all the Redis command and LUA logic would execute in a sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Brief introduction on Lua](img/0123OS_04_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: LUA scripting in Redis
  prefs: []
  type: TYPE_NORMAL
- en: When a client sends the script to the Redis server, the script gets validated
    for its syntax and is stored in an internal map in Redis against a SHA-1 digest.
    The SHA-1 digest is returned to the client.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try a simple program in LUA which will basically read a value for a
    key and check if the value is equal to the argument passed. If yes, then it will
    set it to the second argument passed or else it will set it to the third argument
    passed to the script. Okay, let''s prepare the test environment. Open your Redis
    command line client and set the value of `msg` key to `"Learning Redis"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Brief introduction on Lua](img/0123OS_04_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Preparing for the test executing LUA script
  prefs: []
  type: TYPE_NORMAL
- en: 'Now with the value of `msg` set, let''s execute the Java program listed as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The code for `Reader` is a simple Java program which reads program from file
    location:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s take a look at the LUA script written in the file `LuaScript.txt`
    that we would be passing to the Java program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The first run of the program should give you the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The second run of the program should give you the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'So if you see the messages printed as shown in the preceding code then you
    actually have successfully executed your first LUA program in Redis. The following
    are the learnings that we have got with this sample:'
  prefs: []
  type: TYPE_NORMAL
- en: Redis treats LUA script as one function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: LUA script uses `Redis.call()` method to fire Redis commands.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Redis commands which return values can be assigned to a local variable. Over
    here we are assigning the value to a variable called `data`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arrays in LUA start index from `1` not `0`. So you will never have array index
    such as `ARGV[0]` or `KEYS[0]`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are some further restrictions that Redis imposes on the Lua scripting
    engine which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: In Redis, LUA scripts cannot have global variables.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In Redis, LUA scripts cannot call transaction commands such as `MULTI` or `EXEC`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In Redis, LUA scripts cannot access external systems using I/O libraries that
    come in LUA. The only way it can communicate to external system is via Redis commands
    such as `PUBLISH`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: LUA scripts to access system time are not supported via LUA. Instead, use `TIME`
    command, that is `Redis.call('TIME')`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions such as `Redis.call('TIME')` are non-deterministic in nature and so
    are not allowed before a `WRITE` command.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nesting of conditions is not allowed since nested condition will end with `END`
    keyword which impacts the outer conditions which again has to end with `END`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following commands are supported for managing the LUA scripts in Redis.
    Let''s have a look at it and understand how they can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '`EVAL`: This command will process the Redis script and the response would be
    the result of the executed script.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EVALSHA`: This command will process the cached script based on SHA-1 digest
    of the script and the response would be the result of the executed script.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SCRIPT EXISTS`: This command will check for the existence of script in the
    script cache. This check is done by passing SHA-1 digest of the script.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SCRIPT FLUSH`: This will flush the LUA script from the script cache.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SCRIPT KILL`: This command will kill the script whose execution is taking
    a lot of time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SCRIPT LOAD`: This command will load the script in the cache and return the
    SHA-1 digest of the script.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use case – reliable messaging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By using PUB/SUB capability of Redis, we can create a real time messaging framework
    but the problem with this is that if the intended subscriber is not available
    then the message is lost. To overcome this problem, we can take the help of LUA
    scripting which will store the message if the subscriber is not available.
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation of this will vary depending upon the framework design of
    the solution, but in our case we will take a simplistic approach where every subscriber
    and publisher will agree upon a channel. When the subscriber goes down, the publisher
    will store the message in a message box unique to the subscriber. When the subscriber
    again comes up, it will start consuming the lost messages, as well as the real
    time messages coming from the publisher. The following figure is representing
    the steps that we will have to follow to achieve reliable messaging:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Use case – reliable messaging](img/0123OS_04_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Simple reliable messaging
  prefs: []
  type: TYPE_NORMAL
- en: To begin with, the publisher will send the message to a channel client-1, oblivious
    to the fact whether the subscriber is in a receiving mode or not. Assuming that
    the subscriber is running, the messages from the publisher will be consumed in
    real-time. Then if we bring down the subscriber for a while and publish few more
    messages, in our case the publisher will be intelligent enough to know if the
    subscriber is running or not, and sensing that the subscriber is down, it will
    store the message in a `MSGBOX`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the meantime, the moment the subscriber is up and running, the first thing
    it will do is get the missed messages from the `MSGBOX` and publish it to self.
    The code for publisher is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The code for the LUA script is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Following is a brief explanation of the step written in LUA:'
  prefs: []
  type: TYPE_NORMAL
- en: In the first line we get the message and convert it into a table object. Array
    index starts with `1` in LUA.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We publish the message in the second line and get the result. The result tells
    us how many subscribers consumed the message.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the result is equal to `0`, then all the listeners were down and we need
    to persist it. The data type used here is a `Set` and it subsequently returns
    a message back to the server (this return is optional).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the message was consumed by the subscriber, then the statement in the `Else`
    is executed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we `end` the function. (Make sure there is only one `end` in the script.
    LUA in Redis will not compile if there is more than one `end`.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Redis will wrap the code in LUA as one function in LUA. The code for `Subscriber`
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The program has following responsibilities and a brief explanation of the program
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: When it starts it should check if it has any messages in the message box, such
    as `MSGBOX`, while it was down. If it has messages then its job is to publish
    it to self.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second thing it should do is to listen for messages it has subscribed to.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For better performance, run the `SCRIPT LOAD` command which will load the script
    and return a SHA-1 digest, and instead of using `EVAL`, use the `EVALSHA` command,
    where you pass the same SHA-1 digest. This will prevent the script getting checked
    for syntax correctness and will be executed directly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connection management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section we will be focusing on the way we can manage the connection
    to Redis. The functions provided under connection management in Redis help us
    to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AUTH`: This command with the password allows the request to be processed if
    the password matches the configured password. Redis server can be configured with
    `requirepass` in the `config` file along with the password.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ECHO`: This command echoes back the text sent to a Redis instance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PING`: This command replies with `PONG` when sent to a Redis instance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QUIT`: This command kills the connection held by the Redis instance for a
    client.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SELECT`: This command helps in selecting a database in Redis for executing
    the command. Data in Redis can have separation of concern and this is achieved
    by creating a silo and storing the data in that. The data in each silo don''t
    interfere and are isolated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Redis authentication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Adding a simple password to your Redis server via Redis client and testing
    it via Java client is explained in following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the Redis client and type `CONFIG SET requirepass "Learning Redis"`. You
    have set the password for your Redis server as `"Learning Redis"`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Write the following program in Java using Jedis, which will perform some simple
    getter and setter without authenticating against the Redis server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The outcome in the console would be `ERR operation not permitted`, or based
    upon version, you might get `NOAUTH Authentication required`, which is indicative
    of the fact that since the password was not passed in the request, the operation
    could not be permitted. To make the program work, the client need, to pass the
    password for authentication:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The outcome of the program in the console would be `bar`.
  prefs: []
  type: TYPE_NORMAL
- en: Redis SELECT
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Redis provides a mechanism of segregating the Redis server into databases. Instead
    of an elaborate naming mechanism in some of the databases, Redis has a simple
    process of dividing the database into separate key spaces, and each key space
    is represented by an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '![Redis SELECT](img/0123OS_04_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Multiple database in Redis
  prefs: []
  type: TYPE_NORMAL
- en: The program here attempts to store some data in a database and tries to successfully
    retrieve the data from it. It then changes the database and attempts to retrieve
    the same data, which of course ends up in failure. Remember to remove any authentication
    that might be set in the previous program for this code to run or just restart
    Redis server.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The outcome of this program should be as following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Redis ECHO and PING
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Redis provides some utility functions, such as `ECHO` and `PING`, which can
    be used to check if the server is responding or not, and how much time is it taking
    in responding to a request. This gives an idea on the latency at network and I/O
    level.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following program will demonstrate a sample usage where the `ECHO` and
    `PING` commands will be fired when no other connections are made to the server,
    and then again it will fire these commands (`ECHO` and `PING`) when the Redis
    server is under the load of 100 connections. The outcome when no other connections
    are made is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The outcome when 100 other connections are doing activity on the server is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The outcome when 50 other connections are doing activity on the server is as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'This proves that it is immaterial the amount of activity the Redis server is
    doing, but depends on the availability of the I/O and network resources. The following
    program is for reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The code for `LoadGenerator` is noted as follows for reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: We can play around with this program by changing the number of threads and commenting
    the thread start code in the `TestEchoAndPing`, and seeing the result ourselves.
    The result is going to show the same consistency as shown in the preceding code.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we saw how to use Redis, not simply as a datastore, but also
    as pipeline the commands which is so much more like bulk processing. Apart from
    that, we covered areas such as transaction, messaging, and scripting. We also
    saw how to combine messaging and scripting, and create reliable messaging in Redis.
    This capability of Redis makes it different from some of the other datastore solutions.
    In the next chapter, we will focus on data handling capabilities of Redis.
  prefs: []
  type: TYPE_NORMAL
