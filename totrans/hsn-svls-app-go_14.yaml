- en: Infrastructure as Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A typical Lambda-based application consists of multiple functions triggered
    by events, such as a new object in the S3 bucket, incoming HTTP requests, or a
    new SQS message. Those functions can stand alone or leverage other resources,
    such as DynamoDB tables, Amazon S3 buckets, and other Lambda functions. So far,
    we have seen how to create those resources from the AWS Management Console or
    with the AWS CLI. In a real-world scenario, you want to spend less time provisioning
    the required resources and focus more on your application logic. In the end, that's
    the serverless approach.
  prefs: []
  type: TYPE_NORMAL
- en: This last chapter will introduce the concept of Infrastructure as Code to help
    you design and deploy your N-Tier serverless application in an automated way,
    in order to avoid human error and repeatable tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This book assumes some basic familiarity with the AWS Serverless Application
    Model. If you're new to SAM itself, refer to [Chapter 1](746d14b6-7349-4f9e-b76f-f56706e1d0d5.xhtml),
    *Go Serverless* through [Chapter 10](c5d49fcf-6c18-46c5-8841-6b39f7ec4b89.xhtml),
    *Testing Your Serverless Application*. You will get a step-by-step guide on how
    to get started with SAM. The code bundle for this chapter is hosted on GitHub
    at [https://github.com/PacktPublishing/Hands-On-serverless-Applications-with-Go](https://github.com/PacktPublishing/Hands-On-Serverless-Applications-with-Go).
  prefs: []
  type: TYPE_NORMAL
- en: Deploying AWS Lambda with Terraform
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Terraform** is an open source automation tool built by HashiCorp. It is used
    to create, manage, and update infrastructure resources through declarative configuration
    files. It supports the following providers:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Cloud providers**: AWS, Azure, Oracle Cloud, and GCP'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Infrastructure software**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Consul**: It is a distributed, highly available service-discovery and configuration
    system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Docker**: It is a tool designed to make it easier to create, deploy, and
    run applications by using containers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Nomad**: It is an easy-to-use enterprise-grade cluster scheduler.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Vault**: It is a tool that provides a secure, reliable way to store and distribute
    secrets.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other **SaaS** and **PaaS**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Terraform is not a configuration-management tool (such as Ansible, Chef, and
    Puppet & Salt). It was created to spawn and destroy infrastructure, while configuration-management
    tools were used to install things on top of existing infrastructure. However,
    Terraform can do a bit of provisioning ([https://www.terraform.io/docs/provisioners/index.html](https://www.terraform.io/docs/provisioners/index.html)).
  prefs: []
  type: TYPE_NORMAL
- en: 'This guide will show you how to deploy AWS Lambda using Terraform, so you will
    need to have Terraform installed. You can find the appropriate package for your
    system and download it ([https://www.terraform.io/downloads.html](https://www.terraform.io/downloads.html)).
    Once downloaded, make sure that the `terraform` binary is available on the `PATH`
    variable. Configure your credentials so that Terraform is able to act on your
    behalf. The following are four ways to provide credentials for authentication:'
  prefs: []
  type: TYPE_NORMAL
- en: Provide AWS `access_key` and `secret_key` directly through the provider.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AWS environment variables.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shared credentials file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: EC2 IAM role.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you followed [Chapter 2](52476096-dfc4-445d-ab4c-df692471bff7.xhtml), *Getting
    Started with AWS Lambda*, you should have installed and configured the AWS CLI.
    Therefore, no action is required on your part.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Lambda function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To begin creating the Lambda function, follow the given steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new project with the following structure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/fd50ed4b-1380-47ea-b8cf-f65b91f15a5d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We will use the easiest Hello world example. The `function` folder contains
    a Go-based Lambda function that displays a simple message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You can build a Linux-based binary and generate a `deployment` package with
    the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that the function code is defined, let''s create our first Lambda function
    with Terraform. Copy the following content to the `main.tf` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This is telling Terraform that we''re going to be using the AWS provider and
    to default to the `us-east-1` region for creating our resources:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**IAM role** is an execution role that will be assumed by the Lambda function
    during execution. It defines the resources our Lambda function has access to:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '**IAM policy** is a list of permissions to grant our Lambda function the right
    to stream its logs to CloudWatch. The following policy will be attached to the
    IAM role:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '**Lambda function** is a Go-based Lambda function. The deployment package can
    be specified either directly as a local file (using the `filename` attribute)
    or via Amazon S3 bucket. For in-depth details on how to deploy the Lambda function
    to AWS, refer to [Chapter 6](3b3b7465-2646-4532-8303-9e0b8d06bc64.xhtml), *Deploying
    Your Serverless Application*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'On the terminal, run the `terraform init` command to download and install the
    AWS provider, shown as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/793cedcf-efd2-4df4-884b-2dcff8c945b3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Create an execution plan (dry run) with the `terraform plan` command. It shows
    you things that will be created in advance, which is good for debugging and ensuring
    that you''re not doing anything wrong, as shown in the next screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ff77d443-7739-47c1-bf80-f60ebccac982.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You will be able to examine Terraform''s execution plan before you deploy it
    to AWS. When you''re ready, go ahead and apply the changes by issuing the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Confirm the configuration by typing `yes`. The following output will be displayed
    (some parts were cropped for brevity):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d87027bf-45ba-4bc0-b2bd-9c3134baadb6.png)'
  prefs: []
  type: TYPE_IMG
- en: Make sure the IAM user used to execute these commands has permissions to perform
    IAM and Lambda operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you head back to AWS Lambda Console, a new Lambda function should be created.
    If you try to invoke it, it should return the expected message, as shown in the
    next screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f704065d-9e21-4134-93c4-4191896b72e4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'So far, we defined the AWS region and function name in the template file. However,
    one of the reasons we use infrastructure-as-code tools is usability and automation.
    Hence, you should always use variables and avoid hardcoding values. Luckily, Terraform
    allows you to define your own variables. To do so, create a `variables.tf` file
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Update `main.tf` to use the variables instead of hardcoded values. Note the
    usage of the `${var.variable_name}` keyword:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: With the function working as expected, create the serverless API we built so
    far with Terraform.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In a new directory, create a file named `main.tf` that contains the following
    configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code snippet creates an IAM role with permissions to scan a DynamoDB
    table and writes the log entry to CloudWatch. Configure a Go-based Lambda function
    with the DynamoDB table name as an environment variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Setting up DynamoDB table
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next, we have to set up the DynamoDB table. Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a DynamoDB table with an ID as the partition key for the table:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Initialize the `movies` table with a new item:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The item attributes are defined in the `movie.json` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Configuring API Gateway
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Finally, we need to trigger the function with API Gateway:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `movies` resource on the REST API and expose a `GET` method on it.
    If the incoming requests match the resource defined, it will call the Lambda function
    defined earlier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Issue the following commands to install the AWS plugin, generate an execution
    plan, and apply the changes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'It should take a few seconds to create the whole infrastructure. After the
    creation steps are complete, the Lambda function should be created and properly
    configured, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d1897e2e-f42c-4e22-85a4-81d1b9f222fe.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The same goes for API Gateway, a new REST API should be defined with a `GET`
    method on `/movies` resource, shown as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6f59c9fa-c19d-4738-8a0a-c26d9cc75ab8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In DynamoDB Console, a new table should be created with a movie item, as shown
    in the next screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7c0ef84f-bef8-42c4-b050-753afab85f38.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In order to invoke our API Gateway, we need to deploy it. Create a deployment
    stage, let''s call it `staging`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We will use Terraform''s output feature to expose the API URL; create an `outputs.tf`
    file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Run `terraform apply` again to create these new objects, it will detect the
    changes and ask you to confirm it should perform the actions, shown as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/cf53db32-5b7b-4831-9695-d12ed0177c8e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The API Gateway URL will be displayed in the Outputs section; copy it to the
    clipboard:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/681877fa-8271-4164-a912-a941b72f6142.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you point your favorite browser to the API Invocation URL, an error message
    should be displayed, as shown in the next screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5de0d7f6-45c5-4d7d-ae2f-1ab45692a4d4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We will fix that, by granting execution permission to API Gateway to invoke
    the Lambda function. Update the `main.tf` file to create a `aws_lambda_permission`
    resource:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Apply the latest changes with the `terraform apply` command. On the Lambda
    Console, the API Gateway trigger should be displayed, shown as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b8921922-962d-4e9b-a955-f2f4a7b66b09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Load the URL given in the output from your run in your favorite web browser.
    If everything has worked, you will see the movie stored in the DynamoDB table
    in a JSON format, as shown in the next screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7d8b3b18-2817-4eea-bde5-b2163cd7af3e.png)'
  prefs: []
  type: TYPE_IMG
- en: Terraform stores the state of the infrastructure in a state file (`.tfstate`).
    The state contains resource IDs and all the resource attributes. If you're using
    Terraform to create a RDS instance, the database credentials will be in plaintext
    in the state file. Hence, you should keep your file in a remote backend, such
    as S3 bucket.
  prefs: []
  type: TYPE_NORMAL
- en: Cleaning up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Finally, to delete all the resources (Lambda function, IAM role, IAM policies,
    DynamoDB table, and API Gateway), you can issue the `terraform destroy` command,
    shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a90beaea-d753-4a9b-8518-4142389ae9f7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you want to delete a specific resource, you can use the `--target` option
    as follows: `terraform destroy --target=RESOURCE_NAME`. The operation will be
    limited to the resource and its dependencies.'
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have defined the AWS Lambda function and its dependencies using a
    template file. Hence, we can version it just like any other code. The whole serverless
    infrastructure we use and configure is treated as a source code, allowing us to
    share it among team members, replicate it in other AWS regions, and rollback in
    case of failure.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying AWS Lambda with CloudFormation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**AWS CloudFormation** is an infrastructure-as-code tool for specifying resources
    in a declarative way. You model all the resources you want AWS to spin up in a
    blueprint document (template) and AWS creates the defined resources for you. Thus, you
    spend less time managing those resources and more time focusing on your applications
    that run in AWS.'
  prefs: []
  type: TYPE_NORMAL
- en: Terraform covers almost all services and features by AWS and supports third-party
    providers (platform-agnostic) while CloudFormation is AWS specific (vendor lock-in).
  prefs: []
  type: TYPE_NORMAL
- en: You can use AWS CloudFormation to specify, deploy, and configure serverless
    applications. You create a template that describes your serverless application
    dependencies (Lambda functions, DynamoDB tables, API Gateway, IAM roles, and so
    on), and AWS CloudFormation takes care of provisioning and configuring those resources
    for you. You don't need to individually create and configure AWS resources and
    figure out what depends on what.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we dive into CloudFormation, we need to understand the template structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '**AWSTemplateFormatVersion**: CloudFormation template version.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Description**: A brief description of the template.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mappings**: A mapping of keys and associated values that you can use to specify
    conditional parameter values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Parameters**: Values to pass to your template at runtime.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resources**: AWS resources and their properties (Lambda, DynamoDB, S3, and
    so on).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Outputs**: Describe the values that are returned whenever you view your stack’s
    properties.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After you understand the different parts of the AWS CloudFormation template,
    you can put them together and define a minimal template in a `template.yml` file,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding file defines two resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ExecutionRole`: The IAM role assigned to the Lambda function, it defines what
    entitlements the code invoked by the Lambda runtime has.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HelloWorldFunction`: The AWS Lambda definition, we have set the runtime property
    to use Go and set the function''s code to be stored in a ZIP file on S3\. The
    function references the IAM role using CloudFormation''s built-in `GetAtt` function;
    it also uses the `Ref` keyword to reference variables defined in the parameters
    section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The JSON format can be used also; a JSON version can be found on the GitHub
    repository ([https://github.com/PacktPublishing/Hands-On-serverless-Applications-with-Go](https://github.com/PacktPublishing/Hands-On-Serverless-Applications-with-Go)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps to begin:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an S3 bucket on which you store the deployment package after building
    it with the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Navigate to AWS CloudFormation Console, and choose Create Stack, as shown in
    the next screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/0feeae8d-1e10-4f28-a4f4-3aaf49b8e73a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'On the Select Template page, select the template file, and it will be uploaded
    to the Amazon S3 bucket, shown as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c4b8d238-5224-4326-a5d1-3322e5aac1ed.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on Next, define the stack name, and override the default parameters if
    needed, as shown in the next screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/9682d28e-043c-4206-978c-54277bc9adb6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on Next, leave the options as default, and click on Create, as shown
    in the next screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/378aec0b-6713-4877-9cf7-a203509f0361.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The stack will start creating all the resources defined in the template file.
    Once created, the stack status will change from **CREATE_IN_PROGRESS** to **CREATE_COMPLETE** (in
    case something went wrong, a rollback will be executed automatically), shown as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6a932901-01dd-476c-a189-00a7a4cdbad7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As a result, our Lambda function should be created as illustrated in the following
    screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/4a2a75b1-0523-49df-8036-eb09c05a80f0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can always update your CloudFormation template file. For example, let''s
    create a new DynamoDB table:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'On the CloudFormation Console, select the stack we created earlier and click
    on Update Stack from the menu, shown as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/cbd01613-eb12-4154-bc05-eb91302dba44.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Upload the updated template file, shown as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e9ffce4b-26db-44e2-ab9b-5358cdd81cfc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Similar to Terraform, AWS CloudFormation will detect the changes and display
    the resources that will be changed in advance, shown as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6b64c142-d567-4f82-b452-c5426fc57337.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on the Update button to apply the changes. The stack status will change
    to UPDATE_IN_PROGRESS, as shown in the next screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/aff2ab2c-6736-42f4-a8ea-55cb7db47223.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After the changes have been applied, a new DynamoDB table will be created and
    DynamoDB permissions will be granted to the Lambda function, shown as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f01be3a6-0f19-4e9c-9304-212617986da1.png)'
  prefs: []
  type: TYPE_IMG
- en: The `--capabilities CAPABILITY_IAM` option is required whenever the CloudFormation
    has to define IAM roles, policies, or related resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'The AWS CLI can also be used to create your CloudFormation stack with the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: CloudFormation designer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In addition to writing your own template from scratch, you can use the CloudFormation
    design template feature to create your stack easily. The following screenshot
    shows how to view the design of the stack we''ve created so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/53509c27-1e72-49ac-9539-882a4a98d329.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If all has gone well, you should see the following components:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eb2d5838-3e48-49e6-85de-7913d9c3e669.png)'
  prefs: []
  type: TYPE_IMG
- en: You can now create a complex CloudFormation template by dragging and dropping
    components from the left menu.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying AWS Lambda with SAM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **AWS Serverless Application Model** (**AWS SAM**) is a model to define
    serverless applications. AWS SAM is natively supported by AWS CloudFormation and
    defines a simplified syntax for expressing serverless resources. You simply define
    the resources you need as part of your application in the template file and create
    a CloudFormation stack with the SAM deploy command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Previously, we saw how AWS SAM can be used to locally test your Lambda function.
    In addition, SAM can be used to design and deploy your function to AWS Lambda.
    You can initialize a quick Go-based serverless project (a boilerplate) with the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command will create a folder with the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0b5d1241-e25c-46a6-aa2b-cad64a26be94.png)'
  prefs: []
  type: TYPE_IMG
- en: The `sam init` command provides a quick way to create a serverless application.
    It generates a simple Lambda function in Go with an associated unit test. In addition,
    a Makefile will be generated with a list of steps to build and generate the deployment
    package. Finally, a template file, called a SAM file, will be created which describes
    all the AWS resources needed to deploy the function to AWS Lambda.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we know how to generate a boilerplate with SAM, let''s write our own
    template from scratch. Create a folder called `findall`, and inside it, create
    a `main.go` file with the content of the `FindAllMovies` function''s code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create a serverless app definition in a `template.yaml` file. The following
    example illustrates how to create a Lambda function with a DynamoDB table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The template is similar to the CloudFormation template we wrote earlier. SAM
    extends CloudFormation and simplifies the syntax for expressing serverless resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the `package` command to upload the deployment package to the S3 bucket
    created in the *CloudFormation* section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command will upload the deployment page to the S3 bucket, as
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8bfd86bd-6cd4-407a-82d4-4f837e7cc92a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In addition, a SAM template file called `serverless.yaml` will be generated
    based on the definition file you provided. It should contain the `CodeUri` property that
    points to the `deployment` ZIP in the Amazon S3 bucket that you specified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, deploy the function to AWS Lambda with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '`CAPABILITY_IAM` is used to explicitly acknowledge that AWS CloudFormation
    is allowed to create an IAM role for the Lambda function on your behalf.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you run the `sam deploy` command, it creates an AWS CloudFormation stack
    called APIStack, as shown in the next screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/33f5c604-5883-4c0c-9f17-c13f094a2a34.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once the resources are created, the function should be deployed to AWS Lambda,
    shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7a65c8f6-52b6-472f-859d-5e1718705e77.png)'
  prefs: []
  type: TYPE_IMG
- en: The SAM scope is limited to serverless resources (a list of supported AWS services
    is available at: [https://docs.aws.amazon.com/serverlessrepo/latest/devguide/using-aws-sam.html](https://docs.aws.amazon.com/serverlessrepo/latest/devguide/using-aws-sam.html)).
  prefs: []
  type: TYPE_NORMAL
- en: Exporting a serverless application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'AWS Lambda allows you to export SAM template files for existing functions.
    Select the target function and click on Export function from the Actions menu,
    shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3807cd11-1678-4917-b8e8-dc14dc4d60d6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on Download AWS SAM file to download the template file, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/83cc9b85-60af-4865-a357-6e17562ba2af.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The template will contain the definition of your function, necessary permissions,
    and triggers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: You can now use the `sam package` and `sam deploy` commands to import the function
    into a different AWS region or AWS account.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Managing serverless application resources can be either very manual, or you
    can automate the workflow. Automating the process can be tricky, though, if you
    have a complex infrastructure. This is where tools such as AWS CloudFormation,
    SAM, and Terraform come in.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we learned how to use infrastructure-as-code tools to automate
    the creation of the serverless application resources and dependencies in AWS.
    We saw tools that are cloud-specific, and loosely coupled ones that work on multiple
    platforms. Then, we saw how these tools can be used to deploy Lambda-based applications
    to AWS.
  prefs: []
  type: TYPE_NORMAL
- en: By now, you can write your serverless infrastructure code once and then use
    it many times. The code that defines the infrastructure can be versioned, forked,
    rolled back (going back in time), and used for auditing the infrastructure changes,
    just like any other code. Moreover, it can be discovered and addressed in a programmatic
    fashion. In other words, if the infrastructure has been manually modified, you
    destroy that infrastructure and respawn a clean copy—the Immutable Infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Write a Terraform template to create the `InsertMovie` Lambda function resources.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update the CloudFormation template to trigger the defined Lambda function with
    API Gateway in response to incoming HTTP requests.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a SAM file to model and define all the resources needed to build the serverless
    API we built throughout this book.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure Terraform to store the generated state file in a remote S3 backend.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a CloudFormation template for the serverless API we built throughout
    this book.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a Terraform template for the serverless API we built throughout this
    book.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
