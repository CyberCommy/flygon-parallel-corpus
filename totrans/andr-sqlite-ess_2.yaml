- en: Chapter 2. Connecting the Dots
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '|   | *"You don''t understand anything until you learn it more than one way."*
    |   |'
  prefs: []
  type: TYPE_TB
- en: '|   | --*-Marvin Minsky* |'
  prefs: []
  type: TYPE_TB
- en: 'In the previous chapter, we learned the two important Android classes and their
    corresponding methods in order to work with an SQLite database:'
  prefs: []
  type: TYPE_NORMAL
- en: The `SQLiteOpenHelper` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `SQLiteDatabase` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We also saw code snippets explaining their implementation. Now, we are ready
    to use all these concepts in an Android application. We will be leveraging what
    we learned in the previous chapter to make a functional application. We will further
    look into the SQL statements to insert, query, and delete data from a database.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will be building and running an Android application on an
    Android emulator. We will also be building our own full-fledged `contacts` database.
    We will encounter Android UI components, such as `Buttons` and `ListView`, while
    progressing through this chapter. In case a revisit of UI components in Android
    is required, please visit the link [http://developer.android.com/design/building-blocks/index.html](http://developer.android.com/design/building-blocks/index.html).
  prefs: []
  type: TYPE_NORMAL
- en: Before we begin, the code in this chapter is meant to explain the concepts related
    to an SQLite database in Android and is not production ready; in a lot of places,
    you will find lack of proper exception handling or lack of proper null checks
    and similar practices to reduce verbosity in the code. You can download the complete
    code from Packt's website for the current and following chapters. For best results,
    we recommend downloading the code and referring to it as we move along the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Building blocks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Database handler and queries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting the UI and database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building blocks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Android is known to run on a variety of devices with different hardware and
    software specifications. At the time of writing this book, 1 billion activation
    marks have been crossed. The number of devices running Android is staggering,
    providing users with a rich variety of options in different form factors and on
    different hardware bases. This adds a roadblock when it comes to testing your
    application on different devices, because it is humanly impossible to get hold
    of them all, not to forget the time and capital needed to be invested in it. Emulator
    in itself is a great tool; it enables us to circumvent this problem by giving
    us the flexibility to mimic different hardware features, such as CPU architecture,
    RAM, and camera, and different software versions ranging from early Cupcake to
    KitKat. We will also try to leverage this to our advantage in our project and
    try to run our application on the emulator. An added benefit of using the emulator
    is that we will be running a rooted device that will allow us to perform some
    actions. We will not be able to achieve these actions on a normal device.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by setting up an emulator in Eclipse:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to **Android Virtual Device Manager** from the **Window** menu to start the
    emulator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can set different hardware properties such as the CPU type, front/back camera,
    RAM preferably less than 768 MB on a Windows machine, internal, and external storage
    size.
  prefs: []
  type: TYPE_NORMAL
- en: While launching the app, enable **Save to snapshot**; this will reduce the launch
    time the next time we are launching an emulator instance from the snapshot:![Building
    blocks](img/2951_02_01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Interested readers who want to try out a faster emulator can give Genymotion
    a try at [http://www.genymotion.co](http://www.genymotion.co).
  prefs: []
  type: TYPE_NORMAL
- en: Let's start building our Android application now.
  prefs: []
  type: TYPE_NORMAL
- en: We will start by creating a new project `PersonalContactManager`. Go to **File**
    | **New** | **Project**. Now, navigate to **Android** and then select **Android
    Application Project**. This step will give us an activity file and a corresponding
    XML file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will come back to these components after we have all the blocks we need in
    place. For our application, we will create a database called `contact`, which
    will contain one table, `ContactsTable`. In the previous chapter, we went over
    how to create a database using a SQL statement; let's construct a database schema
    for our project. This is a very important step that is based on our application's
    requirements; for example, in our case, we are building a personal contact manager
    and will require fields such as name, number, e-mail, and a display picture.
  prefs: []
  type: TYPE_NORMAL
- en: 'The database schema for `ContactsTable` is outlined:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Column | Data type |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Contact_ID` | Integer / primary key/ autoincrement |'
  prefs: []
  type: TYPE_TB
- en: '| `Name` | Text |'
  prefs: []
  type: TYPE_TB
- en: '| `Number` | Text |'
  prefs: []
  type: TYPE_TB
- en: '| `Email` | Text |'
  prefs: []
  type: TYPE_TB
- en: '| `Photo` | Blob |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An Android application can have more than one database and each database can
    have more than one table. Each table stores data in the 2D (rows and columns)
    format.
  prefs: []
  type: TYPE_NORMAL
- en: The first column is `Contact_ID`. Its datatype is integer and its **column constraint**
    is the primary key. Also, the column is autoincremented, which means for each
    row it will be incremented by one when data is inserted in that row.
  prefs: []
  type: TYPE_NORMAL
- en: 'The primary key uniquely identifies each row and cannot be null. Each table
    in a database can have one primary key at the most. The primary key of one table
    can act as the foreign key for another table. The foreign key serves as a connection
    between two related tables; for instance, our current `ContactsTable` schema is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s say we have another table `ColleagueTable` with the following schema:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here, the primary key of `ContactTable`, that is, `Contact_ID` can be termed
    as a foreign key for `ColleagueTable`. It serves the purpose of linking two tables
    in a relational database and hence allows us to perform operations on `ColleagueTable`.
    We will explore this concept in detail in the chapters and examples ahead.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Column constraint**'
  prefs: []
  type: TYPE_NORMAL
- en: Constraints are the rules enforced on data columns in a table. This ensures
    the accuracy and reliability of data in the database.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike most SQL databases, SQLite does not restrict the type of data that may
    be inserted into a column based on the declared type of columns. Instead, SQLite
    uses **dynamic typing**. The declared type of a column is used to determine the
    **affinity** of the column only. There is a type conversion also (automatically)
    when one type of variable is stored in the other.
  prefs: []
  type: TYPE_NORMAL
- en: Constraints can be column level or table level. Column-level constraints are
    applied only to one column, whereas table-level constraints are applied to the
    whole table.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the commonly used constraints and keywords available in SQLite:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `NOT NULL` constraint: This ensures that a column does not have a `NULL`
    value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `DEFAULT` constraint : This provides a default value for a column when
    none is specified.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `UNIQUE` constraint: This ensures that all the values in a column are different.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `PRIMARY` key: This uniquely identifies all rows/records in a database
    table.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `CHECK` constraint: The `CHECK` constraint ensures that all the values
    in a column satisfy certain conditions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `AUTO INCREMENT` keyword: `AUTOINCREMENT` is a keyword used to autoincrement
    a value of a field in the table. We can autoincrement a field value by using the
    `AUTOINCREMENT` keyword when creating a table with a specific column name to autoincrement
    it. The keyword `AUTOINCREMENT` can be used with the `INTEGER` field only.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The next step is to prepare our data model; we will use our schema to frame
    the data model class. The `ContactModel` class will have `Contact_ID`, `Name`,
    `Number`, `Email`, and `Photo` as fields, they are represented as `id`, `name`,
    `contactNo`, `email`, and `byteArray` respectively. The class will consist of
    a getter/setter method to set and fetch property values as needed. The use of
    a data model will facilitate in the communication of the activity used to show/process
    data and our database handler, which we are going to define later in this chapter.
    We will create a new package and a new class in it called the `ContactModel` class.
    Please note that creating a new package is not a necessary step; it is used to
    organize our classes in a logical and easily accessible manner. This class can
    be described as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Eclipse provides a lot of helpful shortcuts but not for generating getter and
    setter methods. We can bind generating getter and setter methods to any key binding
    as per our liking. In Eclipse, go to **Window** | **Preferences** | **General**
    | **Keys**, search for getter, and add your bindings. We are using *Alt* + *Shift*
    + *G*; you are free to set any other key combination.
  prefs: []
  type: TYPE_NORMAL
- en: A database handler and queries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will build our support class that will contain methods to read, update,
    and delete data as per our database requirements. This class will enable us to
    create and update the database and will act as our hub for data management. We
    will use this class to run SQLite queries and send across data to the UI; in our
    case, a listview to display the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We will create an object of the `SQLiteDatabase` class, which we will initialize
    later with either `getWritableDatabase()` or `getReadableDatabase()`. We will
    define the constants that we will be using through the class.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By convention, constants are defined in capitals but use of `static final` in
    defining a constant is bit more than the convention. To know more, refer to [http://goo.gl/t0PoQj](http://goo.gl/t0PoQj).
  prefs: []
  type: TYPE_NORMAL
- en: We will define the name of our database as `contact` and define the version
    as 1\. If we look back to the previous chapter, we will recall the importance
    of this value. A quick recap of this enables us to upgrade the database from the
    current version to the new version. The use case will become clear with this example.
    Let's say in future there is a new requirement, that is, we need to add a fax
    number to our contact details. We will modify our current schema to incorporate
    this change and our contact database will correspondingly change. If we are installing
    the application on new devices, there will be no issue; but in case of a device
    where we already have a running instance of the application, we will face problems.
    In this situation, `DB_VERSION` will come in handy and help us replace the old
    version of the database with the current version. Another approach would be to
    uninstall the application and install it again, but that is not encouraged.
  prefs: []
  type: TYPE_NORMAL
- en: 'The table name and important fields such as table columns will be defined now.
    `TABLE_ROW_ID` is a very important column. This will serve as the primary key
    for the table; it will also autoincrement and cannot be null. `NOT NULL` is again
    a column constraint, which may only be attached to a column definition and is
    not specified as a table constraint. Not surprisingly, a `NOT NULL` constraint
    dictates that the associated column may not contain a `NULL` value. Attempting
    to set the column value to `NULL` when inserting a new row or updating an existing
    one, causes a constraint violation. This will be used to find a particular value
    in the table. The uniqueness of the ID guarantees that we do not have any conflicts
    with data in the table, since each row is uniquely identified by the key. The
    rest of the table columns are pretty self-explanatory. The constructor for the
    `DatabaseManager` class is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we are using a class called `CustomSQLiteOpenHelper`. We will come
    back to this later. We will use the class object to get our `SQLitedatabase` instance.
  prefs: []
  type: TYPE_NORMAL
- en: Building the Create query
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create a table with the desired columns, we will build a query statement
    and execute it. The statement will contain the table name, different table columns,
    and respective datatype. We will now look at methods for creating a new database
    and also upgrading an existing database according to the needs of the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '`CustomSQLiteOpenHelper` extends `SQLiteOpenHelper` and provides us with the
    key methods `onCreate()` and `onUpgrade()`. We have defined this class as the
    inner class of our `DatabaseManager` class. This enables us to manage all the
    database-related functions, namely CRUD (Create,Read,Update, and Delete), from
    one place.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In our `CustomSQLiteOpenHelper` constructor, which is responsible for creating
    an instance of our class, we will pass a context, which in turn will be passed
    to the super constructor with the following parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Context context`: This is the context we passed to our constructor'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`String name`: This is the name of our database'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CursorFactory factory`: This is the cursor factory object, which can be passed
    as `null`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int version`: This is the database version of the database'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The next important method is `onCreate()`. We will build our SQLite query string,
    which will create our database table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous statement is based on the following syntax diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building the Create query](img/2951OS_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here, the keyword `create table` is used to create a table. This is followed
    by the table name, the declaration of columns, and their datatype. After preparing
    our SQL statement, we will execute it using the `execSQL()` method of the SQLite
    database. In case something is wrong with the query statement that we built earlier,
    we will encounter the exception, `android.database.sqlite.SQLiteException`. By
    default, the database is formed in the internal memory space allocated to the
    application. The folder can be found at `/data/data/<yourpackage>/databases/`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can easily verify whether our database is formed while running this piece
    of code on an emulator or a rooted phone. In Eclipse, go to the DDMS perspective
    and then go to the file manager. We can easily navigate to the given folder if
    we have sufficient permission, that is, a rooted device. We can also pull up our
    database with the help of the file explorer, and with the help of a standalone
    SQLite manager tool, we can view our database and perform CRUD operations on it
    as well. What makes the Android application''s database readable through another
    tool? Remember how we discussed cross-platform in SQLite features in the last
    chapter? In the following screenshot, notice the table name, the SQL statement
    used to build it, and the column names along with their datatype:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building the Create query](img/2951_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The SQLite Manager tool can be downloaded either in the Chrome or Firefox browser.
    The following is the link for Firefox extension: [http://goo.gl/NLu8JT](http://goo.gl/NLu8JT).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another handy way of pulling up our database or any other file is by using
    the `adb pull` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Another interesting point to note is that the datatype of `TABLE_ROW_PHOTOID`
    is `BLOB`. BLOB stands for binary large object. It is different from other datatype,
    such as text and integer, as it can store binary data. The binary data can be
    an image, audio, or any other type of multimedia object.
  prefs: []
  type: TYPE_NORMAL
- en: It is not advisable to store large images in a database; we can store filenames
    or locations, but storing images is bit of overkill. Imagine a situation like
    this where we store contact images. To amplify this situation, instead of a few
    hundred contacts, make it a few thousand contacts. The size of the database will
    become large and the access time will also increase. We want to demonstrate the
    use of BLOBs by storing contact images.
  prefs: []
  type: TYPE_NORMAL
- en: The `onUpgrade()` method is called when the database is upgraded. The database
    is upgraded by changing the version number of the database. Here, the implementation
    depends on the need of the application. In some cases, the whole table may have
    to be deleted and a new one may need to be created, and in some applications,
    only slight modification is needed. How to migrate from one version to another
    is covered in [Chapter 4](ch04.html "Chapter 4. Thread Carefully"), *Thread Carefully*.
  prefs: []
  type: TYPE_NORMAL
- en: Building the Insert query
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To insert a new row of data in the database table, we need to use either the
    `insert()` method or we can make an insert query statement and use the `execute()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In case our table name is wrong, SQLite will give a log `no such table` message
    and the exception, `android.database.sqlite.SQLiteException`. The `addRow()` method
    is used to insert contact details in the database row; notice that the parameter
    of the method is an object of `ContactModel`. We have created an additional method
    `prepareData()` to construct a `ContentValues` object from the `ContactModel`
    object''s getter methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'After the preparation of the `ContentValues` object, we are going to use the
    `insert()` method of the `SQLiteDatabase` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The parameters of the `insert()` method are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`table`: The database table to insert the row into.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`values`: This key-value map contains the initial column values for the table
    row. Column names act as keys. Values as the column values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nullColumnHack`: This is as interesting as its name. Here''s a quote from
    the Android documentation website:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*"optional; may be null. SQL doesn''t allow inserting a completely empty row
    without naming at least one column name. If your provided values are empty, no
    column names are known and an empty row can''t be inserted. If not set to null,
    the nullColumnHack parameter provides the name of nullable column name to explicitly
    insert NULL into the case where your values are empty."*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In short, in cases where we are trying to pass an empty `ContentValues` to be
    inserted, SQLite needs some column that is safe to be assigned `NULL`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, instead of the `insert()` method, we can prepare the SQL statement
    and execute it as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We will be covering alternatives for a lot of the methods we mentioned here.
    The idea is to make you comfortable with other possible ways to build and execute
    queries. The explanation of the alternative part is left as an exercise for you.
    The `getRowAsObject()` method will return the fetched row from the database in
    the form of a `ContactModel` object, as shown in the following code. It will require
    `rowID` as a parameter to uniquely identify which row in the table we want to
    access:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This method will return the fetched row from the database in the form of a
    `ContactModel` object. We are using the `SQLiteDatabase()` query method to fetch
    the row from our contact table against the provided `rowID` parameter. The method
    returns a cursor over the result set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are the parameters of the previous code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`table`: This denotes the database table against which the query will be run.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`columns`: This is a list of the columns that are returned; if we pass `null`,
    it will return all the columns.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`selection`: This is where we define which rows are to be returned and framed
    as a SQL `WHERE` clause. Passing `null` will return all the rows.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`selectionArgs`: We can pass `null` for this parameter or we may include question
    marks in the selection, which will be replaced by the values from `selectionArgs`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`groupBy`: This is a filter framed as a SQL `GROUP BY` clause declaring how
    to group rows. Passing `null` will cause the rows to not be grouped.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Having`: This is a filter that tells which row groups are to be made part
    of the cursor, framed as a SQL `HAVING` clause. Passing `null` will cause all
    the row groups to be included.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OrderBy`: This tells the query how to order the rows framed as an SQL `ORDER
    BY` clause. Passing `null` will use the default sort order.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`limit`: This will limit the number of rows returned by the query framed as
    the `LIMIT` clause. Passing `null` denotes a no `LIMIT` clause.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Another important concept here is moving the cursor around to access data.
    Notice the following methods: `cursor.moveToFirst()`, `cursor.isAfterLast()`,
    and `cursor.moveToNext()`.'
  prefs: []
  type: TYPE_NORMAL
- en: When we try to retrieve data-building SQL query statements, the database will
    first create an object of the cursor object and return its reference. The pointer
    of this returned reference is pointing to the 0th location, which is also known
    as "before first location" of the cursor. When we want to retrieve data, we have
    to first move to the first record; hence, the use of `cursor.moveToFirst()`.Talking
    about the rest of the two methods, `cursor.isAfterLast()` returns whether the
    cursor is pointing to the position after the last row and `cursor.moveToNext()`
    moves the cursor to the next row.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Readers are advised to go through more of the cursor methods at the Android
    developer site: [http://goo.gl/fR75t8](http://goo.gl/fR75t8).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, we can use the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The `update` statement is based on the following syntax diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building the Insert query](img/2951OS_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Before we move to other methods in the `datamanager` class, let''s have a look
    at fetching data from a cursor object in the `prepareSendObject()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Here `cursor.getstring()` takes the column index as a parameter and returns
    the value of the requested column, whereas `cursor.getColumnIndexOrThrow()` takes
    the column name as a parameter and returns the zero-based index for the given
    column name. Instead of this chaining approach, we can directly use `cursor.getstring()`.
    If we know the column number of the required column to fetch data from, we can
    use the following notation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Building the Delete query
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To delete a particular row of data from our database table, we need to provide
    the primary key to uniquely identify the data set to be removed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This method uses the SQLiteDatabase `delete()` method to delete the row of
    the given ID in the table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are the parameters of the preceding code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '`table`: This is the database table against which the query will be run'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`whereClause`: This is a clause to be applied when deleting a row; passing
    `null` in this clause will delete all the rows'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`whereArgs`: We may include question marks in the `where` clause, which will
    be replaced by the values that will be bound as strings'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Alternatively, we can use the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The `delete` statement is based on the following syntax diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building the Delete query](img/2951OS_02_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Building the Update query
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To update an existing value, we need to use the `update()` method with the
    required parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Generally, we need the primary key, in our case the `rowId` parameter, to identify
    the row to be modified. An SQLiteDatabase `update()` method is used to modify
    the existing data of zero or more rows in a database table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are the parameters of the preceding code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '`table`: This is the qualified database table name to be updated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`values`: This is a mapping from the column names to the new column values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`whereClause`: This is the optional `WHERE` clause to be applied when updating
    a value/row. If the `UPDATE` statement does not have a `WHERE` clause, all the
    rows in the table are modified.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`whereArgs`: We may include question marks in the `where` clause, which will
    be replaced by the values that will be bound as strings.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Alternatively, you can use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The `update` statement is based on the following syntax diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building the Update query](img/2951OS_02_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Connecting the UI and database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have our database hooks in place, let''s connect our UI with the
    data:'
  prefs: []
  type: TYPE_NORMAL
- en: The first step would be to get the data from the user. We can use the existing
    contact data from the Android's contact application by means of the content provider.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will be covering this approach in the next chapter. For now, we will be
    asking the user to add a new contact, which we will insert into the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Connecting the UI and database](img/2951_02_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We are using standard Android UI widgets, such as `EditText`, `TextView`, and
    `Buttons` to collect the data provided by the user:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '`prepareSendData`() is the method that is responsible for bundling data into
    our object model and later inserting it in our database. Notice that instead of
    using null check and length check on `contactName`, we are using `TextUtils.isEmpty()`,
    which is a very handy method. This returns `true` if the string is null or of
    zero length.'
  prefs: []
  type: TYPE_NORMAL
- en: We prepare our `ContactModel` object from the data received by the user filling
    the form. We create an instance of our `DatabaseManager` class and access our
    `addRow()` method passing our contact object to be inserted in the database, as
    we discussed earlier.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Another important method is `getBlob()`, which is used to get the image data
    in the BLOB format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We create a new `ByteArrayOutputStream` object `blob`. Bitmap''s `compress()`
    method will be used to write a compressed version of the bitmap to our `o``utputstream`
    object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are the parameters of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`format`: This is the format of a compressed image, in our case, JPEG.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`quality`: This is a hint to the compressor, which ranges from `0` to `100`.
    The value `0` means to compress to a smaller size and low quality, while `100`
    is for maximum quality.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stream`: This is the output stream to write the compressed data to.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, we create our `byte[]` object, which will be constructed from the `ByteArrayOutputStream
    toByteArray()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You will notice that we are not covering all the methods; only those that are
    relevant to data operations and some methods or calls that might cause confusion.
    There are a few more methods that are used to invoke the camera or gallery to
    pick a photo to be used as the contact image. You are advised to explore the methods
    in the code provided along with the book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s move on to the presentation part where we use a custom listview to display
    our contact information in a presentable and readable manner. We are going to
    skip a bulk of the code related to the presentation and concentrate on the parts
    where we fetch and provide data to our listview. We will also implement a context
    menu in order to provide a user with the functionality of deleting a particular
    contact. We will be touching base on the database manager methods such as `getAllData()`
    to fetch all our added contacts. We will use `deleteRow()` in order to remove
    any unwanted contacts from our contacts database. The final outcome will be something
    like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Connecting the UI and database](img/2951_02_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To make a custom listview similar to the one shown in the preceding screenshot,
    we create `CustomListAdapter` extending `BaseAdapter` and using the custom layout
    for the listview rows. Notice in the following constructor we have initialized
    a new array list and will use our database manager to fetch values by using the
    getAllData() method to fetch all the database entries:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Another very important method is the `getView()` method. This is where we inflate
    our custom layout in a view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We will use the view holder pattern to improve the listview scrolling smoothness:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, set the data to the corresponding views:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Holding view objects in a view holder improves the performance by reducing calls
    to `findViewById()`. You can read more about this and how to make listview scrolling
    smooth at [http://developer.android.com/training/improving-layouts/smooth-scrolling.html](http://developer.android.com/training/improving-layouts/smooth-scrolling.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'We will also be implementing a way to delete a listview entry. We will use
    the context menu for this purpose. We will first create a menu item in the `menu`
    folder under `res` of our application structure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, in our main activity where we will display our listview, we will use the
    following call to register our listview with the context menu. In order to launch
    the context menu, we need to perform a long press action on the listview item:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'There are a few more methods that we need to implement in order to achieve
    the delete functionality:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This method is used to inflate the context menu with the menu we defined earlier
    in XML. The `MenuInfater` class generates menu objects from the menu XML files.
    Menu inflation relies heavily on the preprocessing of XML files that is done at
    build time; this is done to improve performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will implement a method to capture the click on the context menu:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we will find the position ID of the clicked listview item and invoke
    the `delRow()` method of the CustomListAdapter, and in the end, we will notify
    the adapter that the dataset has changed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The `delRow()` method is responsible for connecting our database's `deleteRowAlternative()`
    method to our context menu's `delete()` method. Here, we fetch the ID of the object
    set on the particular listview item and pass it to the `deleteRowAlternative()`
    method of `databaseManager` in order to delete the data from the database. After
    removing the data from the database, we will instruct our listview to remove the
    corresponding entry from our contact list.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `onContextItemSelected()` method, we can also see the `update_item`
    in case the user has clicked on the `update` button. We will launch the activity
    to add a new contact and add the data we already have in case the user wants to
    edit some fields. The catch is to know from where the call has been initiated.
    Is it to add a new entry or update an existing one? We take the help of the following
    code to tell the activity that this action is used to update rather than add a
    new entry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered the steps of building up a database-based application,
    from scratch and then from schema to object model and then from object model to
    building actual databases. We underwent the process of building our database manager
    and finally implemented the UI database connect to achieve a fully functional
    application. The topics covered ranged from the building blocks of the model class,
    database schema to our database handler, and CRUD methods. We also covered the
    important concept of connecting a database to the Android views with proper hooks
    in place to pick up user data, add data to the database, and show relevant information
    after picking up data from the database.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will focus on building upon the groundwork we have done
    here. We will explore `ContentProviders`. We will also learn how to fetch data
    from `ContentProviders`, how to make our own content provider, the best practices
    associated while building them, and much more.
  prefs: []
  type: TYPE_NORMAL
