- en: Chapter 4. Getting Started with Layouts and Material Design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already seen the Android Studio UI designer, as well as a little bit
    more of Kotlin in action. In this hands-on chapter, we will build three more layouts
    – still quite simple, yet a step up from what we have done so far.
  prefs: []
  type: TYPE_NORMAL
- en: Before we get to the hands-on part, we will have a quick introduction to the
    concept of **Material Design**.
  prefs: []
  type: TYPE_NORMAL
- en: We will look at another type of layout, called `LinearLayout`, and walk through
    it, using it to create a usable UI. We will take things a step further using `ConstraintLayout`,
    both to understand constraints and to design more complex and precise UI designs.
    Finally, we will meet the `TableLayout` to lay data out in an easily readable
    table.
  prefs: []
  type: TYPE_NORMAL
- en: We will also write some Kotlin code to switch between our different layouts
    within one app/project. This is the first major app that links together multiple
    topics into one neat parcel. The app is called Exploring Layouts.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Material Design
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a `LinearLayout` and learning when it is best to use this type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building another, slightly more advanced, `ConstraintLayout` and finding out
    a bit more about using constraints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a `TableLayout` and filling it with data to display
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linking everything together in a single app called Exploring Layouts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First on the list is material design.
  prefs: []
  type: TYPE_NORMAL
- en: Material design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You might have heard of material design, but what exactly is it? The objective
    of material design is, quite simply, to achieve beautiful user interfaces. It
    is also, however, about making these user interfaces consistent across Android
    devices. Material design is not a new idea. It is taken straight from the design
    principles used in pen-and-paper design, like having visually pleasing embellishments
    such as shadows and depth.
  prefs: []
  type: TYPE_NORMAL
- en: Material design uses the concept of layers of materials that you can think of
    in the same way you would think of layers in a photo-editing app. Consistency
    is achieved with a set of principles, rules, and guidelines. It must be stressed
    that material design is entirely optional, but it also must be stressed that material
    design works, and, if you are not following it, there is a good chance your design
    will be disliked by the user. The user, after all, has become used to a certain
    type of UI, and that UI was most likely created using material design principles.
  prefs: []
  type: TYPE_NORMAL
- en: So, material design is a sensible standard to strive for, but while we are learning
    the details of material design, we mustn't let it hold us back from learning how
    to get started with Android.
  prefs: []
  type: TYPE_NORMAL
- en: This book will focus on getting things done, while occasionally pointing out
    when material design is influencing how we do it, as well as pointing you to further
    resources for those who want to look at material design in more depth right away.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring Android UI design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will see with Android UI design that so much of what we learn is context-sensitive.
    The way that a given widget's x attribute will influence its appearance might
    depend on a widget's y attribute, or even on an attribute on another widget. It
    isn't easy to learn this verbatim. It is best to expect to gradually achieve better
    and faster results with practice.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if you play with the designer by dragging and dropping widgets
    onto the design, the XML code that is generated will vary considerably depending
    upon which layout type you are using. We will see this as we proceed through this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: This is because different layout types use different means to decide the position
    of their children. For example, the `LinearLayout`, which we will explore next,
    works very differently to `ConstraintLayout`, which was added by default to our
    project in [Chapter 1](ch01.html "Chapter 1. Getting Started with Android and
    Kotlin"), *Getting Started with Android and Kotlin*.
  prefs: []
  type: TYPE_NORMAL
- en: This information might initially seem like a problem, or even a bad idea, and
    it certainly can be a little awkward. What we will begin to learn, however, is
    that this clear abundance of layout options and their individual quirks are a
    good thing, because they give us almost unlimited design potential. There are
    very few layouts you can imagine that are not possible to achieve.
  prefs: []
  type: TYPE_NORMAL
- en: As implied, however, this almost unlimited potential comes with a bit of complexity.
    The best way to start to get to grips with this is to build some working examples
    of several types. In this chapter, we will see three – a `LinearLayout`, a `ConstraintLayout`,
    and a `TableLayout`. We will see how to make things easier using the distinctive
    features of the visual designer, and we will also pay some attention to the XML
    that is auto-generated to make our understanding more rounded.
  prefs: []
  type: TYPE_NORMAL
- en: Layouts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already seen `ConstraintLayout,` but there are more. Layouts are the
    building blocks that group together the other UI elements/widgets. Layouts can,
    and often do, contain other layouts themselves.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at some commonly used layouts in Android, because knowing the different
    layouts and their pros and cons will make us more aware of what can be achieved,
    and therefore will expand our horizons of what is possible.
  prefs: []
  type: TYPE_NORMAL
- en: We have already seen that, once we have designed a layout, we can put it into
    action using the `setContentView` function in our Kotlin code.
  prefs: []
  type: TYPE_NORMAL
- en: Let's build three designs with different layout types and then put `setContentView`
    to work and switch between them.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Exploring Layouts project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the toughest things in Android is not just finding out how to do something,
    but finding out how to do something amongst other things. That is why, throughout
    this book, as well as showing you how to do some neat stuff, we will link lots
    of topics together into apps that span multiple topics and often chapters. The
    **Exploring Layouts** project is the first app of this type. We will learn how
    to build multiple types of layout while linking them all together in one handy
    app:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new project in Android Studio. If you already have a project open,
    select **File** | **New Project**. When prompted, choose **Open in same window**,
    as we do not need to refer to our previous project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are on the start screen of Android Studio, you can create a new project
    simply by clicking the **Start a new Android Studio project** option.
  prefs: []
  type: TYPE_NORMAL
- en: Select the **Empty Activity** project template, as we will build most of the
    UI from scratch. Click the **Next** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `Exploring Layouts` for the name of the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All the rest of the settings are the same as we have used for the previous three
    projects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the **Finish** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Look at the `MainActivity.kt` file. Here is the entirety of the code, excluding
    the `import…` statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Locate the call to `setContentView` and delete the entire line. The line is
    shown highlighted in the previous code.
  prefs: []
  type: TYPE_NORMAL
- en: This is just what we want, because now we can build our very own layouts, explore
    the underlying XML, and write our own Kotlin code to display these layouts. If
    you run the app now, you will just get a blank screen with a title; not even a
    Hello World! message.
  prefs: []
  type: TYPE_NORMAL
- en: The first type of layout we will explore is the `LinearLayout`.
  prefs: []
  type: TYPE_NORMAL
- en: Building a menu with LinearLayout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`LinearLayout` is probably the simplest layout that Android offers. As the
    name suggests, all the UI items within it are laid out linearly. You have just
    two choices – vertical and horizontal. By adding the following line of code (or
    editing via the Attribute window), you can configure a `LinearLayout` to lay things
    out vertically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You can then (as you could probably have guessed) change `"vertical"` to `"horizontal"`
    to lay things out horizontally.
  prefs: []
  type: TYPE_NORMAL
- en: Before we can do anything with `LinearLayout`, we need to add one to a layout
    file. And, as we are building three layouts in this project, we also need a new
    layout file.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a LinearLayout to the project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the project window, expand the `res` folder. Now right-click the `layout`
    folder and select **New**. Notice that there is an option for **Layout resource**
    **file,** as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding a LinearLayout to the project](img/B12806_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Select **Layout resource file** and you will see the **New Resource File**
    dialog window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding a LinearLayout to the project](img/B12806_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the **File name** field, enter `main_menu`. The name is arbitrary, but this
    layout is going to be our "main" menu that is used to select the other layouts,
    so the name seems appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that it has already selected **LinearLayout** as the **Root** **element**
    option.
  prefs: []
  type: TYPE_NORMAL
- en: Click the **OK** button, and Android Studio will generate a new `LinearLayout`
    in an XML file called `main_menu` and place it in the `layout` folder ready for
    us to build our new main menu UI. Android Studio will also open the UI designer
    with the palette on the left and the attributes window on the right.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing your workspace
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Adjust the windows by dragging and resizing their borders (as you can in most
    windowed apps) to make the palette, design, and attributes as clear as possible,
    but no bigger than necessary. This small screenshot shows the approximate window
    proportions I chose to make designing our UI and exploring the XML as clear as
    possible. The detail in the screenshot is not important:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Preparing your workspace](img/B12806_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Observe that I have made the project, palette, and attribute windows as narrow
    as possible, yet without obscuring any content. I have also closed the build/logcat
    window at the bottom of the screen, the result being that I have a nice clear
    canvas on which to build the UI.
  prefs: []
  type: TYPE_NORMAL
- en: Examining the generated XML
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Click on the **Text** tab and we will have a look at the current state of the
    XML code that forms our design at this stage. Here is the code so that we can
    discuss this further:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We have the usual starting and closing tags and, as we could have predicted,
    they are `<LinearLayout` and `</LinearLayout>`. There is no child element yet,
    but there are three attributes. We know they are attributes, and not children,
    of the `LinearLayout`, because they appear before the first closing `>`. The three
    attributes that define this `LinearLayout` have been highlighted in the previous
    code for clarity.
  prefs: []
  type: TYPE_NORMAL
- en: The first attribute is `android:orientation`, or, more succinctly, we will just
    refer to the attributes without the `android:` part. The `orientation` attribute
    has a value of `vertical`. This means that, when we start to add items to this
    layout, it will arrange them vertically from top to bottom. We could change the
    value from `vertical` to `horizontal` and it would lay things out from left to
    right.
  prefs: []
  type: TYPE_NORMAL
- en: The next two attributes are `layout_width` and `layout_height`. These determine
    the size of the `LinearLayout`. The value given to both attributes is `match_parent`.
    The parent of a layout is the entire available space. By matching the parent horizontally
    and vertically, therefore, the layout will fill the entire space available.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a TextView to the UI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Switch back to the **Design** tab and we will add some elements to the UI.
  prefs: []
  type: TYPE_NORMAL
- en: First, find the **TextView** in the palette. This can be found in both the **Common**
    and **Text** categories. Left-click and drag the **TextView** onto the UI, and
    notice that it sits neatly at the top of the `LinearLayout`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at the XML on the **Text** tab and confirm that it is a child of the `LinearLayout`
    and that it is indented by one tab to make this clear. Here is the code for the
    `TextView` without the surrounding code for the `LinearLayout`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that it has four attributes: `id`, in case we need to refer to it from
    another UI element or from our Kotlin code; `layout_width` is set to `match_parent`,
    which means the that `TextView` stretches across the whole width of the `LinearLayout`;
    a `layout_height` attribute is set to `wrap_content`, which means the that `TextView`
    is precisely tall enough to contain the text within it; and finally, for now,
    it has a `text` element that determines the actual text it will display, and this
    is currently just set to `TextView.`'
  prefs: []
  type: TYPE_NORMAL
- en: Switch back to the design tab and we will make some changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'We want this text to be the heading text of this screen, which is the main
    menu screen. In the attributes window, click the search icon, type `text` into
    the search box, and change the **text** attribute to `Menu`, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding a TextView to the UI](img/B12806_04_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can find any attribute by searching or just by scrolling through the options.
    When you have found the attribute you want to edit, left-click it to select it
    and then press the *Enter* key on the keyboard to make it editable.
  prefs: []
  type: TYPE_NORMAL
- en: Next, find the `textSize` attribute using your preferred search technique and
    set `textSize` to `50sp`. When you have entered this new value, the text size
    will increase.
  prefs: []
  type: TYPE_NORMAL
- en: The `sp` stands for scalable pixels. This means that when the user changes the
    font size settings on their Android device, the font will dynamically rescale
    itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, search for the **gravity** attribute and expand the options by clicking
    the little arrow indicated in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding a TextView to the UI](img/B12806_04_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Set **gravity** to **center_horizontal,** as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding a TextView to the UI](img/B12806_04_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `gravity` attribute refers to the gravity within the `TextView` itself,
    and our change has the effect of moving the actual text inside the `TextView`
    to the center.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Note that `gravity` is different to `layout_gravity`. The `layout_gravity`
    property sets the gravity within the layout: in this case, the parent `LinearLayout`.
    We will use `layout_gravity` later in this project.'
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we have changed the text of the `TextView`, increased its size,
    and centered it horizontally. The UI designer should now look like the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding a TextView to the UI](img/B12806_04_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'A quick glance at the **Text** tab to see the XML would reveal the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see the new attributes as follows: `gravity`, which is set to `center_horizontal`;
    text, which has changed to `Menu`; and `textSize`, which is set to `50sp`.'
  prefs: []
  type: TYPE_NORMAL
- en: If you run the app, you might not see what you expected. This is because we
    haven't called `setContentView` in our Kotlin code to load the UI. You will still
    see the blank UI. We will fix this once we have made a bit more progress with
    the UI.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a multi-line TextView to the UI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Switch back to **Design** tab, find the **Multiline Text** in the **Text** category
    of the palette, and drag it onto the design just below the `TextView` we added
    a moment ago.
  prefs: []
  type: TYPE_NORMAL
- en: Using your preferred search technique, set **text** to `Select a layout type
    to view an example. The onClick attribute of each button will call a function
    which executes setContentView to load the new layout`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your layout will now look like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding a multi-line TextView to the UI](img/B12806_04_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Your XML will be updated with another child in the `LinearLayout`, after the
    `TextView`, that looks like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: You can see the details of the UI item and it turns out that the description
    on the palette of **Multiline Text** was not entirely obvious as to exactly what
    this would be. A look at the XML reveals that we have an `inputType` attribute,
    indicating that this text is editable by the user. There is also another attribute
    that we haven't seen before, and that is `ems`. The `ems` attribute controls how
    many characters can be entered per line, and the value of `10` was chosen automatically
    by Android Studio. However, another attribute, `layout_width="match_parent"`,
    overrides this value because it causes the element to expand to fit its parent;
    in other words, to cover the whole width of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: When you run the app (in the next section), you will see that the text is, indeed,
    editable – although, for the purposes of this demo app, it serves no practical
    purpose.
  prefs: []
  type: TYPE_NORMAL
- en: Wiring up the UI with the Kotlin code (part 1)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To achieve an interactive app, we will do the following three things:'
  prefs: []
  type: TYPE_NORMAL
- en: We will call `setContentView` from the `onCreate` function to show the progress
    of our UI when we run the app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will write two more functions of our own and each one will call `setContentView`
    on a different layout (that we have yet to design).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, later in this chapter, when we design two more UI layouts, we will be
    able to load them at the click of a button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As we will be building a `ConstraintLayout` and a `TableLayout`, we will call
    our new functions, `loadConstraintLayout` and `loadTableLayout`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Let's do that now, and then we'll see how we can add some buttons that call
    these functions alongside some neatly formatted text.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `onCreate` function, add the following highlighted code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The code uses the `setContentView` function to load the UI we are currently
    working on. You can now run the app to see the following results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Wiring up the UI with the Kotlin code (part 1)](img/B12806_04_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Add these two new functions inside the `MainActivity` class after the `onCreate`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'There is one error with the first function and two with the second. The first
    we can fix by adding an `import` statement so that Android Studio is aware of
    the `View` class. Left-click the word `View` to select the error. Hold down the
    *Alt* key and then tap the *Enter* key. You will see the following popup:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Wiring up the UI with the Kotlin code (part 1)](img/B12806_04_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Chose **Import class**. The error is now gone. If you scroll to the top of
    the code, you will see that a new line of code has been added by that shortcut
    we just performed. Here is the new code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Android Studio no longer considers the `View` class an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second function still has an error, however. The problem is that the function
    calls the `setContentView` function to load a new UI (`R.layout.my_table_layout`).
    As this UI layout does not exist yet, it produces an error. You can comment out
    this call to remove the error until we create the file and design the UI layout
    later this chapter. Add the double forward slash (`//`), as highlighted in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Now we can add some buttons that we can click to call our new functions and
    load the new layouts we will be building soon. But adding a couple of buttons
    with some text on is too easy – we have done that before. What we want to do is
    line up some text with a button to the right of it. The problem is that our `LinearLayout`
    has the `orientation` attribute set to `vertical` and, as we have seen, all the
    new parts we add to the layout will be lined up vertically.
  prefs: []
  type: TYPE_NORMAL
- en: Adding layouts within layouts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The solution to laying out some elements with a different orientation to others
    is to nest layouts within layouts. Here is how to do it.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the **Layouts** category of the palette, drag a **LinearLayout (Horizontal)**
    onto the design, placing it just below the **Multiline Text**. Notice that there
    is a blue border occupying all the space below the **Multiline Text**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding layouts within layouts](img/B12806_04_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This indicates that our new **LinearLayout (Horizontal)** is filling the space.
    Keep this blue border area in mind, as it is where we will put the next item on
    our UI.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, go back to the **Text** category of the palette and drag a **TextView**
    onto the new `LinearLayout` we just added. Notice how the `TextView` sits snuggly
    in the top left-hand corner of the new `LinearLayout`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding layouts within layouts](img/B12806_04_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At first, this seems no different to what happened with the previous vertical
    `LinearLayout` that was part of our UI from the start. But watch what happens
    when we add our next piece of the UI.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The term used to refer to adding layouts within layouts is **nesting**. The
    Android term applied to any item that appears on the UI (buttons and text, for
    example) is **view**, and anything that contains views is a **view group.** As
    the terms **view** and **view group** do not always make their meanings clear
    in certain contexts, I will usually refer to parts of the UI either specifically
    (such as `TextView`, `Button`, and `LinearLayout`) or more broadly (UI element,
    item, or widget).
  prefs: []
  type: TYPE_NORMAL
- en: 'From the **Button** category, drag a **Button** onto the right-hand side of
    the previous `TextView`. Notice that the button sits to the right of the text,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding layouts within layouts](img/B12806_04_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, select the `LinearLayout` (the horizontal one) by clicking on an empty
    part of it. Find the `layout_height` attribute and set it to `wrap_content`. Observe
    that the `LinearLayout` is now taking up only as much space as it needs:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding layouts within layouts](img/B12806_04_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Let's configure the text attribute of the `TextView` and the `Button` before
    we add the next part of the UI. Change the `text` attribute of the `Button` to
    `LOAD`. Change the text attribute of our new `TextView` to `Load ConstraintLayout`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Did you work out how to achieve the previous instruction for yourself? Yes?
    Excellent! You are now familiar with editing attributes of Android views. No?
    Left-click the item you want to edit (in this case, the `TextView`), search using
    the search icon or scroll to find the attribute you want to edit in the **Attributes**
    window (in this case, the `text` attribute), select the attribute, and press *Enter*
    to edit it. I can now give more succinct instructions on how to build future UI
    projects, and this makes your journey to becoming an Android ninja much quicker.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can repeat ourselves and add another `TextView` and `Button` attribute
    within another **LinearLayout (Horizontal)** just below the one we have just finished.
    To do so, follow these steps in order:'
  prefs: []
  type: TYPE_NORMAL
- en: Add another **LinearLayout (Horizontal)**, just below the previous one
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a **TextView** to the new `LinearLayout`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the `text` attribute of the `TextView` to `Load TableLayout`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `Button` on the right-hand side of the `TextView`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the `text` attribute of the `Button` to `LOAD`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Resize the `LinearLayout` by changing the `layout_height` attribute to `wrap_content`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we have two neatly (and horizontally) aligned texts and buttons.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just for fun, and for the sake of exploring the palette a bit more, find the
    **Widgets** category of the palette and drag a **RatingBar** onto the design just
    below the final `LinearLayout`. Now, your UI should look very similar to this
    next screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding layouts within layouts](img/B12806_04_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the previous two screenshots, I hadn't yet changed the `text` attribute of
    the two `Button` elements. Everything else should be the same as yours.
  prefs: []
  type: TYPE_NORMAL
- en: Let's add some visual finishing touches to the layout.
  prefs: []
  type: TYPE_NORMAL
- en: Making the layout look pretty
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will explore some more attributes that control the finer
    details of our UI. You have probably noticed how the UI looks a bit squashed in
    some places, and wonky and unsymmetrical in others. As we progress through the
    book, we will continually add to our repertoire to improve our layouts, but these
    short steps will introduce and take care of some of the basics:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the `Multiline Text`, and then expand the `Padding` attribute. Set the
    `all` option to `15sp`. This has made a neat area of space around the outside
    of the text.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To make a nice space below the `Multiline text`, find and expand the `Layout_Margin`
    attribute and set `bottom` to `100sp`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On both `TextView` widgets that are aligned/related to the buttons, set the
    `textSize` attribute to `20sp`, the `layout_gravity` to `center_vertical`, the
    `layout_width` to `match_parent`, and the `layout_weight` to `.7`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On both buttons, set the weight to `.3`. Notice how both buttons now take up
    exactly `.3` of the width and the text `.7` of the `LinearLayout`, making the
    whole appearance more pleasing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the `RatingBar`, find the `Layout_Margin` attribute, and then set `left`
    and `right` to `15sp`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Still with the `RatingBar` and the `Layout_Margin` attribute, change `top` to
    `75sp`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can now run the app and see our first full layout in all its glory:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Making the layout look pretty](img/B12806_04_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Notice that you can play with the `RatingBar`, although the rating won't persist
    when the app is turned off.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By way of a reader challenge, find an attribute or two that could further improve
    the appearance of the `LoadConstraintLayout` and `LoadTableLayout` text. They
    look a little bit close to the edges of the screen. Refer to the section Attributes
    – a quick summary at the start of [Chapter 5](ch05.html "Chapter 5. Beautiful
    Layouts with CardView and ScrollView"), *Beautiful Layouts with CardView and ScrollView*.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, the buttons don't do anything yet. Let's fix that.
  prefs: []
  type: TYPE_NORMAL
- en: Wiring up the UI with the Kotlin code (part 2)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Select the button next to the `Load ConstraintLayout` text. Find the `onClick`
    attribute and set it to `loadConstraintLayout`.
  prefs: []
  type: TYPE_NORMAL
- en: Select the button next to the `Load TableLayout` text. Find the `onClick` attribute
    and set it to `loadTableLayout`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, the buttons will call the functions, but the code inside the `loadTableLayout`
    function is commented out to avoid errors. Feel free to run the app and see that
    you can switch to the `ConstraintLayout` by clicking the `loadConstraintLayout`
    button. But all it has is a **Hello World** message.
  prefs: []
  type: TYPE_NORMAL
- en: We can now move on to building this `ConstraintLayout`.
  prefs: []
  type: TYPE_NORMAL
- en: Building a precise UI with ConstraintLayout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the `ConstraintLayout` that was auto-generated when we created the project.
    It is probably already in a tab at the top of the editor. If not, it will be in
    the `res`/`layout` folder. Its name is `activity_main.xml`.
  prefs: []
  type: TYPE_NORMAL
- en: Inspect the XML in the **Text** tab and note that it is empty, apart from a
    `TextView` that says `Hello World`. Switch back to the **Design** tab, left-click
    the `TextView` to select it, and tap the *Delete* key to get rid of it.
  prefs: []
  type: TYPE_NORMAL
- en: Now we can build ourselves a simple, yet intricate, UI. `ConstraintLayout` is
    very useful when you want to position parts of your UI very precisely and/or relative
    to the other parts.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a CalenderView
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To get started, look in the **Widgets** category of the palette and find the
    `CalenderView`. Drag and drop the `CalenderView` near the top and horizontally
    central. As you drag the `CalenderView` around, notice that it jumps/snaps to
    certain locations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also notice the subtle visual cues that show when the view is aligned. I have
    highlighted the horizontally central visual cue in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding a CalenderView](img/B12806_04_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Let go when it is horizontally central, as it is in the screenshot. Now, we
    will resize it.
  prefs: []
  type: TYPE_NORMAL
- en: Resizing a view in a ConstraintLayout
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Left-click and hold one of the corner squares that are revealed when you let
    go of the `CalenderView`, and drag inwards to decrease the size of the `CalenderView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Resizing a view in a ConstraintLayout](img/B12806_04_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Reduce the size by about half and leave the `CalenderView` near the top, horizontally
    centered. You might need to reposition it a little after you have resized it,
    a bit like the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Resizing a view in a ConstraintLayout](img/B12806_04_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You do not need to place the `CalenderView` in exactly the same place as me.
    The purpose of the exercise is to get familiar with the visual cues that inform
    you where you have placed it, not to create a carbon copy of my layout.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Component Tree window
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now look at the **Component Tree** window – the one to the left of the visual
    designer and below the palette. The component tree is a way of visualizing the
    layout of the XML, but without all the details.
  prefs: []
  type: TYPE_NORMAL
- en: In the following screenshot, we can see that the `CalenderView` is indented
    to the right of the `ConstraintLayout`, and is therefore a child. In the next
    UI we build, we will see that we sometimes need to take advantage of the **Component
    Tree** to build the UI.
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, I just want you to observe that there is a warning sign by our `CalenderView`.
    I have highlighted it in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the Component Tree window](img/B12806_04_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The error says **This view is not constrained. It only has designtime positions,
    so it will jump to (0,0) at runtime unless you add the constraints**. Remember
    when we first added buttons to the screen in [Chapter 2](ch02.html "Chapter 2. Kotlin,
    XML, and the UI Designer"), *Kotlin, XML, and the UI Designer*, that they simply
    disappeared off to the top-left corner?
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Run the app now and click on the **Load ConstraintLayout** button if you want
    to be reminded of this problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we could fix this by clicking the **Infer constraints** button that we
    used in [Chapter 2](ch02.html "Chapter 2. Kotlin, XML, and the UI Designer"),
    *Kotlin, XML, and the UI Designer*. Here it is again as a reminder:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the Component Tree window](img/B12806_04_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: But learning to add the constraints manually is worthwhile because it offers
    us more options and flexibility. And, as your layouts become more complex, there
    is always an item or two that doesn't behave as you want it to, and fixing it
    manually is nearly always necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Adding constraints manually
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Make sure that the `CalenderView` is selected and observe the four small circles
    at the top, bottom, left, and right:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding constraints manually](img/B12806_04_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: These are the constraint handles. We can click and drag them to anchor them
    with other parts of the UI or the sides of the screen. By anchoring the `CalenderView`
    with the four edges of the screen, we can lock it into position when the app is
    run.
  prefs: []
  type: TYPE_NORMAL
- en: One at a time, click and drag the top handle to the top of the design, the right
    to the right of the design, the bottom to the bottom of the design, and the left
    to the left of the design.
  prefs: []
  type: TYPE_NORMAL
- en: 'Observe that the `CalenderView` is now constrained in the center. Left-click
    and drag the `CalenderView` back to the upper part of the screen somewhere, as
    in the following diagram. Use the visual cues (also shown in the following screenshot)
    to make sure the `CalenderView` is horizontally centered:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding constraints manually](img/B12806_04_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At this stage, you could run the app and the `CalenderView` would be positioned
    as shown in the preceding screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: Let's add a couple more items to the UI and see how to constrain them.
  prefs: []
  type: TYPE_NORMAL
- en: Adding and constraining more UI elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Drag an `ImageView` from the **Widgets** category of the palette and position
    it below and to the left of the `CalenderView`. When you place the `ImageView`,
    a pop-up window will prompt you to choose an image. Select **Project** | **ic_launcher,**
    and then click **OK**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Constrain the left-hand side of the `ImageView` and the bottom of the `ImageView`
    to the left and bottom of the UI, respectively. Here is the position you should
    be in now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding and constraining more UI elements](img/B12806_04_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `ImageView` is constrained in the bottom-left corner. Now, grab the top
    constraint handle on the `ImageView` and drag it to the bottom constraint handle
    of the `CalenderView`. This is now the current situation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding and constraining more UI elements](img/B12806_04_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `ImageView` is only constrained horizontally on one side, so is pinned/constrained
    to the left. It is also constrained vertically and equally between the `CalenderView`
    and the bottom of the UI.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, add a `TextView` to the right of the `ImageView`. Constrain the right
    of the `TextView` to the right of the UI and constrain the left of the `TextView`
    to the right of the `ImageView`. Constrain the top of the `TextView` to the top
    of the `ImageView` and constrain the bottom of the `TextView` to the bottom of
    the UI. Now you will be left with something resembling the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding and constraining more UI elements](img/B12806_04_28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Notice that all the warnings in the **Component Tree** window about unconstrained
    items are gone.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are warnings about hardcoded strings because we are adding text directly
    to the layout instead of the `strings.xml` file and a warning about missing the
    **contentDescription** attribute. The **contentDescription** attribute should
    be used to add a textual description so that visually impaired users can get a
    spoken description of images in the app. For the sake of making rapid progress
    with the `ConstraintLayout`, we will ignore these two warnings. We will look at
    adding string resources correctly in [Chapter 18,](ch18.html "Chapter 18. Localization")
    *Localization*, and you can read about accessibility features in Android Studio
    on the Android developer's website, at [https://developer.android.com/studio/intro/accessibility](https://developer.android.com/studio/intro/accessibility).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can move the three UI elements around and line them up neatly, just how
    you want them. Notice that when you move the `ImageView`, the `TextView` moves
    with it because the `TextView` is constrained to the `ImageView`. But also notice
    that you can move the `TextView` independently, and wherever you drop it, this
    represents its new constrained position relative to the `ImageView`. Whatever
    an item is constrained to, its position will always be relative to that item.
    And, as we have seen, the horizontal and vertical constraints are distinct from
    each other. I positioned mine as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding and constraining more UI elements](img/B12806_04_29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`ConstraintLayout` is the newest layout type, and, while it is more complex
    than the other layouts, it is the most powerful, as well as the one that runs
    the best on our user''s device. It is worth spending more time looking at some
    more tutorials about `ConstraintLayout`. Especially look on YouTube, as video
    is a great medium to learn about tweaking `ConstraintLayout`. We will return to
    `ConstraintLayout` throughout the book, and you do not need to know any more than
    we have covered already to be able to move on.'
  prefs: []
  type: TYPE_NORMAL
- en: Making the text clickable
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are nearly done with our `ConstraintLayout`. We just want to wire up a link
    back to the main menu screen. This is a good opportunity to demonstrate that `TextView`
    (and most other UI items) are also clickable. In fact, clickable text is probably
    more common in modern Android apps than conventional-looking buttons.
  prefs: []
  type: TYPE_NORMAL
- en: Change the `text` attribute of the `TextView` to `Back to the menu`. Now, find
    the `onClick` attribute and enter `loadMenuLayout`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add the following function to the `MainActivity.kt` file just after the
    `loadTableLayout` function, as highlighted here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Now, whenever the user clicks the `Back to the menu` text, the `loadMenuLayout`
    function will be called and the `setContentView function` will load the layout
    in `main_menu.xml`.
  prefs: []
  type: TYPE_NORMAL
- en: You can run the app, and click back and forth between the main menu (`LinearLayout`)
    and the `CalenderView` widget (`ConstraintLayout`).
  prefs: []
  type: TYPE_NORMAL
- en: Let's build the final layout for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Laying out data with TableLayout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the project window, expand the `res` folder. Now, right-click the `layout`
    folder and select **New**. Notice that there is an option for **Layout resource**
    **file**.
  prefs: []
  type: TYPE_NORMAL
- en: Select **Layout resource file**, and you will see the **New Resource File**
    dialog window.
  prefs: []
  type: TYPE_NORMAL
- en: In the **File name** field, enter `my_table_layout`. This is the same name we
    used in the call to `setContentView` within the `loadTableLayout` function.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that it has already selected **LinearLayout** as the **Root** element
    option. Delete `LinearLayout` and type `TableLayout` in its place.
  prefs: []
  type: TYPE_NORMAL
- en: Click the **OK** button and Android Studio will generate a new `TableLayout`
    in an XML file called `my_table_layout` and place it in the `layout` folder ready
    for us to build our new table-based UI. Android Studio will also open the UI designer
    (if it isn't already) with the palette on the left and the attributes window on
    the right.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can now uncomment the `loadTableLayout` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: You can now switch to the `TableLayout`-based screen when you run the app, although
    currently, it is blank.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a TableRow to TableLayout
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Drag a `TableRow` element from the `Layouts` category on to the UI design. Notice
    that the appearance of this new `TableRow` is virtually imperceptible, so much
    so that it is not worth inserting a diagram in the book. There is just a thin
    blue line at the top of the UI. This is because the `TableRow` has collapsed itself
    around its content, which is currently empty.
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to drag and drop our chosen UI elements onto this thin blue line,
    but it is also a little awkward, even counter intuitive. Furthermore, once we
    have multiple `TableRow` elements next to each other, it gets even harder. The
    solution lies in the **Component Tree** window, which we introduced briefly when
    building the `ConstraintLayout`.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Component Tree when the visual designer won't do
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Look at the **Component Tree** and notice how you can see the `TableRow` as
    a child of the `TableLayout`. We can drag our UI directly onto the `TableRow`
    in the **Component Tree**. Drag three `TextView` objects onto the `TableRow` in
    the **Component Tree** and that should leave you with the following layout. I
    have photoshopped the following screenshot to show you the **Component Tree**
    and the regular UI designer in the same diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the Component Tree when the visual designer won''t do](img/B12806_04_30.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now add another two `TableRow` objects (from the **Layouts** category). You
    can add them via the **Component Tree** window or the UI designer.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You need to drop them on the far-left of the window, otherwise the new `TableRow`
    will become a child of the previous `TableRow`. This will leave the whole table
    a bit of a muddle. If you accidentally add a `TableRow` as a child of the previous
    `TableRow,` you can either select it, then tap the *Delete* key, use the *Ctrl*
    + Z keyboard combination to undo it, or drag the mispositioned `TableRow` to the
    left (in the **Component Tree**) to make it a child of the Table – as it should
    be.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add three `TextView` objects to each of the new `TableRow` items. This
    will be most easily achieved by adding them via the **Component Tree** window.
    Check your layout to make sure it is as in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the Component Tree when the visual designer won''t do](img/B12806_04_31.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Let's make the table look more like a genuine table of data that you might get
    in an app by changing some attributes.
  prefs: []
  type: TYPE_NORMAL
- en: On the `TableLayout`, set the `layout_width` and `layout_height` attributes
    to `wrap_content`. This gets rid of extra cells.
  prefs: []
  type: TYPE_NORMAL
- en: Change the color of all the outer (along the top and down the left-hand side)
    `TextView` objects to black by editing the `textColor` attribute. You achieve
    this by selecting the first `TextView`, searching for its `color` attribute, and
    then typing `black` in the `color` attribute values field. You will then be able
    to select `@android:color/black` from a drop-down list. Do this for each of the
    outer `TextView` elements.
  prefs: []
  type: TYPE_NORMAL
- en: Edit the `padding` of each `TextView` and change the `all` attribute to `10sp`.
  prefs: []
  type: TYPE_NORMAL
- en: Organizing the table columns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It might seem at this point that we are done, but we need to organize the data
    better. Our table, like many tables, will have a blank cell in the top-left to
    divide the column and row titles. To achieve this, we need to number all the cells.
    For this, we need to edit the `layout_column` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Cell numbers are numbered from zero from the left.
  prefs: []
  type: TYPE_NORMAL
- en: Start by deleting the top-left `TextView`. Notice that the `TextView` from the
    right has moved into the top-left position.
  prefs: []
  type: TYPE_NORMAL
- en: Next, in the new top-left `TextView,` edit the `layout_column` attribute to
    be `1` (this assigns it to the second cell, because the first is `0` and we want
    to leave the first one empty) and, for the next cell along, edit the `layout_column`
    attribute to be `2`.
  prefs: []
  type: TYPE_NORMAL
- en: For the next two rows of cells, edit their `layout_column` attributes from `0`
    to `2` from left to right.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want clarification on the precise code for this row after editing, here
    is a snippet, and remember to look in the download bundle in the `Chapter04` `/LayoutExploration`
    folder to see the whole file in context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Try to complete this exercise, however, using the **Attributes** window if possible.
  prefs: []
  type: TYPE_NORMAL
- en: Linking back to the main menu
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Finally, for this layout, we will add a button that links back to the main menu.
    Add another `TableRow` via the **Component Tree**. Drag a button onto the new
    `TableRow`. Edit its `layout_column` attribute to `1` so that it is in the middle
    of the row. Edit its `text` attribute to `Menu` and edit its `onClick` attribute
    to match our already existing `loadMenuLayout` function.
  prefs: []
  type: TYPE_NORMAL
- en: You can now run the app and switch back and forth between the different layouts.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to, you can add some meaningful titles and data to the table by
    editing all the `text` attributes of the `TextView` widgets, as I have done in
    this following screenshot, showing the `TableLayout` running in the emulator:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Linking back to the main menu](img/B12806_04_32.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As a final thought, think about an app that presents tables of data. Chances
    are that data will be added to the table dynamically, not by the developer at
    design time as we have just done, but more likely by the user or from a database
    on the web. In [Chapter 16,](ch16.html "Chapter 16. Adapters and Recyclers") *Adapters
    and Recyclers*, we will see how to dynamically add data to different types of
    layout using adapters, and, in [Chapter 27](ch27.html "Chapter 27. Android Databases"),
    *Android Databases*, we will also see how to create and use databases in our apps.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have covered many topics in just a few dozen pages. We have not only built
    three different types of layout, including `LinearLayout` with nested layouts,
    `ConstraintLayout` with manually configured constraints, and `TableLayout` (albeit
    with fake data), but we have also wired all the layouts together with clickable
    buttons and text that trigger our Kotlin code to switch between all these different
    layouts.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will stick with the topic of layouts. We will review
    the many attributes we have seen, and we will build our most aesthetically pleasing
    layout so far by incorporating multiple `CardView` layouts, complete with depth
    and shadow, into a smooth-scrolling `ScrollView` layout.
  prefs: []
  type: TYPE_NORMAL
