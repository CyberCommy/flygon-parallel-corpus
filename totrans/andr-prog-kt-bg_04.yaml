- en: Chapter 4. Getting Started with Layouts and Material Design
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章.开始使用布局和材料设计
- en: We have already seen the Android Studio UI designer, as well as a little bit
    more of Kotlin in action. In this hands-on chapter, we will build three more layouts
    – still quite simple, yet a step up from what we have done so far.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了安卓工作室的UI设计师，以及Kotlin的一些实际应用。在这个动手实践的章节中，我们将构建三个更多的布局-仍然相当简单，但比我们迄今为止所做的更进一步。
- en: Before we get to the hands-on part, we will have a quick introduction to the
    concept of **Material Design**.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始动手之前，我们将快速介绍**材料设计**的概念。
- en: We will look at another type of layout, called `LinearLayout`, and walk through
    it, using it to create a usable UI. We will take things a step further using `ConstraintLayout`,
    both to understand constraints and to design more complex and precise UI designs.
    Finally, we will meet the `TableLayout` to lay data out in an easily readable
    table.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看看另一种布局类型，称为`LinearLayout`，并通过使用它来创建可用的UI来详细介绍它。我们将进一步使用`ConstraintLayout`，既了解约束，又设计更复杂和精确的UI设计。最后，我们将介绍`TableLayout`，以便在易于阅读的表格中布置数据。
- en: We will also write some Kotlin code to switch between our different layouts
    within one app/project. This is the first major app that links together multiple
    topics into one neat parcel. The app is called Exploring Layouts.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将编写一些Kotlin代码，以在一个应用程序/项目中在不同的布局之间进行切换。这是第一个将多个主题整合到一个整洁包裹中的重要应用程序。该应用程序名为“探索布局”。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Material Design
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 材料设计
- en: Building a `LinearLayout` and learning when it is best to use this type
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建`LinearLayout`并学习何时最好使用此类型
- en: Building another, slightly more advanced, `ConstraintLayout` and finding out
    a bit more about using constraints
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建另一个稍微更高级的`ConstraintLayout`，并了解更多关于使用约束的信息
- en: Building a `TableLayout` and filling it with data to display
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建`TableLayout`并填充数据以显示
- en: Linking everything together in a single app called Exploring Layouts
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将所有内容链接在一个名为“探索布局”的单个应用程序中
- en: First on the list is material design.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 首先是材料设计。
- en: Material design
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 材料设计
- en: You might have heard of material design, but what exactly is it? The objective
    of material design is, quite simply, to achieve beautiful user interfaces. It
    is also, however, about making these user interfaces consistent across Android
    devices. Material design is not a new idea. It is taken straight from the design
    principles used in pen-and-paper design, like having visually pleasing embellishments
    such as shadows and depth.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能听说过材料设计，但它究竟是什么？材料设计的目标很简单，就是实现美观的用户界面。然而，它也是为了使这些用户界面在安卓设备上保持一致。材料设计并不是一个新的想法。它直接采用了纸和笔设计中使用的设计原则，比如具有视觉上令人愉悦的装饰，如阴影和深度。
- en: Material design uses the concept of layers of materials that you can think of
    in the same way you would think of layers in a photo-editing app. Consistency
    is achieved with a set of principles, rules, and guidelines. It must be stressed
    that material design is entirely optional, but it also must be stressed that material
    design works, and, if you are not following it, there is a good chance your design
    will be disliked by the user. The user, after all, has become used to a certain
    type of UI, and that UI was most likely created using material design principles.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 材料设计使用材料层的概念，您可以将其视为照片编辑应用程序中的图层。一套原则、规则和指南实现了一致性。必须强调材料设计完全是可选的，但也必须强调材料设计是有效的，如果您不遵循它，用户很可能不喜欢您的设计。毕竟，用户已经习惯了某种类型的UI，而该UI很可能是使用材料设计原则创建的。
- en: So, material design is a sensible standard to strive for, but while we are learning
    the details of material design, we mustn't let it hold us back from learning how
    to get started with Android.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，材料设计是一个值得努力的合理标准，但在学习材料设计的细节时，我们不应该让它阻碍我们学习如何开始使用安卓。
- en: This book will focus on getting things done, while occasionally pointing out
    when material design is influencing how we do it, as well as pointing you to further
    resources for those who want to look at material design in more depth right away.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本书将专注于完成任务，同时偶尔指出材料设计如何影响我们的做法，并指向更深入了解材料设计的进一步资源。
- en: Exploring Android UI design
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索安卓UI设计
- en: We will see with Android UI design that so much of what we learn is context-sensitive.
    The way that a given widget's x attribute will influence its appearance might
    depend on a widget's y attribute, or even on an attribute on another widget. It
    isn't easy to learn this verbatim. It is best to expect to gradually achieve better
    and faster results with practice.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到在安卓UI设计中，我们学到的很多东西都是依赖上下文的。给定小部件的x属性如何影响其外观可能取决于小部件的y属性，甚至取决于另一个小部件的属性。这并不容易直接学习。最好期望通过实践逐渐取得更好和更快的结果。
- en: For example, if you play with the designer by dragging and dropping widgets
    onto the design, the XML code that is generated will vary considerably depending
    upon which layout type you are using. We will see this as we proceed through this
    chapter.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您通过将小部件拖放到设计中来玩转设计师，生成的XML代码将根据您使用的布局类型而有很大不同。随着我们在本章中的进行，我们将看到这一点。
- en: This is because different layout types use different means to decide the position
    of their children. For example, the `LinearLayout`, which we will explore next,
    works very differently to `ConstraintLayout`, which was added by default to our
    project in [Chapter 1](ch01.html "Chapter 1. Getting Started with Android and
    Kotlin"), *Getting Started with Android and Kotlin*.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为不同的布局类型使用不同的方法来决定其子元素的位置。例如，我们将在下一节中探索的`LinearLayout`与我们项目中默认添加的`ConstraintLayout`的工作方式完全不同，[第1章](ch01.html
    "第1章.开始使用安卓和Kotlin")中已经介绍了*开始使用安卓和Kotlin*。
- en: This information might initially seem like a problem, or even a bad idea, and
    it certainly can be a little awkward. What we will begin to learn, however, is
    that this clear abundance of layout options and their individual quirks are a
    good thing, because they give us almost unlimited design potential. There are
    very few layouts you can imagine that are not possible to achieve.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: As implied, however, this almost unlimited potential comes with a bit of complexity.
    The best way to start to get to grips with this is to build some working examples
    of several types. In this chapter, we will see three – a `LinearLayout`, a `ConstraintLayout`,
    and a `TableLayout`. We will see how to make things easier using the distinctive
    features of the visual designer, and we will also pay some attention to the XML
    that is auto-generated to make our understanding more rounded.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Layouts
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already seen `ConstraintLayout,` but there are more. Layouts are the
    building blocks that group together the other UI elements/widgets. Layouts can,
    and often do, contain other layouts themselves.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at some commonly used layouts in Android, because knowing the different
    layouts and their pros and cons will make us more aware of what can be achieved,
    and therefore will expand our horizons of what is possible.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: We have already seen that, once we have designed a layout, we can put it into
    action using the `setContentView` function in our Kotlin code.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: Let's build three designs with different layout types and then put `setContentView`
    to work and switch between them.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Exploring Layouts project
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the toughest things in Android is not just finding out how to do something,
    but finding out how to do something amongst other things. That is why, throughout
    this book, as well as showing you how to do some neat stuff, we will link lots
    of topics together into apps that span multiple topics and often chapters. The
    **Exploring Layouts** project is the first app of this type. We will learn how
    to build multiple types of layout while linking them all together in one handy
    app:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Create a new project in Android Studio. If you already have a project open,
    select **File** | **New Project**. When prompted, choose **Open in same window**,
    as we do not need to refer to our previous project.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are on the start screen of Android Studio, you can create a new project
    simply by clicking the **Start a new Android Studio project** option.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Select the **Empty Activity** project template, as we will build most of the
    UI from scratch. Click the **Next** button.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `Exploring Layouts` for the name of the project.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All the rest of the settings are the same as we have used for the previous three
    projects.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the **Finish** button.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Look at the `MainActivity.kt` file. Here is the entirety of the code, excluding
    the `import…` statements:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Locate the call to `setContentView` and delete the entire line. The line is
    shown highlighted in the previous code.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: This is just what we want, because now we can build our very own layouts, explore
    the underlying XML, and write our own Kotlin code to display these layouts. If
    you run the app now, you will just get a blank screen with a title; not even a
    Hello World! message.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: The first type of layout we will explore is the `LinearLayout`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: Building a menu with LinearLayout
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`LinearLayout` is probably the simplest layout that Android offers. As the
    name suggests, all the UI items within it are laid out linearly. You have just
    two choices – vertical and horizontal. By adding the following line of code (or
    editing via the Attribute window), you can configure a `LinearLayout` to lay things
    out vertically:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You can then (as you could probably have guessed) change `"vertical"` to `"horizontal"`
    to lay things out horizontally.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: Before we can do anything with `LinearLayout`, we need to add one to a layout
    file. And, as we are building three layouts in this project, we also need a new
    layout file.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Adding a LinearLayout to the project
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the project window, expand the `res` folder. Now right-click the `layout`
    folder and select **New**. Notice that there is an option for **Layout resource**
    **file,** as shown in the following screenshot:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding a LinearLayout to the project](img/B12806_04_03.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
- en: 'Select **Layout resource file** and you will see the **New Resource File**
    dialog window:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding a LinearLayout to the project](img/B12806_04_04.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
- en: In the **File name** field, enter `main_menu`. The name is arbitrary, but this
    layout is going to be our "main" menu that is used to select the other layouts,
    so the name seems appropriate.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: Notice that it has already selected **LinearLayout** as the **Root** **element**
    option.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: Click the **OK** button, and Android Studio will generate a new `LinearLayout`
    in an XML file called `main_menu` and place it in the `layout` folder ready for
    us to build our new main menu UI. Android Studio will also open the UI designer
    with the palette on the left and the attributes window on the right.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: Preparing your workspace
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Adjust the windows by dragging and resizing their borders (as you can in most
    windowed apps) to make the palette, design, and attributes as clear as possible,
    but no bigger than necessary. This small screenshot shows the approximate window
    proportions I chose to make designing our UI and exploring the XML as clear as
    possible. The detail in the screenshot is not important:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '![Preparing your workspace](img/B12806_04_05.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
- en: Observe that I have made the project, palette, and attribute windows as narrow
    as possible, yet without obscuring any content. I have also closed the build/logcat
    window at the bottom of the screen, the result being that I have a nice clear
    canvas on which to build the UI.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: Examining the generated XML
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Click on the **Text** tab and we will have a look at the current state of the
    XML code that forms our design at this stage. Here is the code so that we can
    discuss this further:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We have the usual starting and closing tags and, as we could have predicted,
    they are `<LinearLayout` and `</LinearLayout>`. There is no child element yet,
    but there are three attributes. We know they are attributes, and not children,
    of the `LinearLayout`, because they appear before the first closing `>`. The three
    attributes that define this `LinearLayout` have been highlighted in the previous
    code for clarity.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: The first attribute is `android:orientation`, or, more succinctly, we will just
    refer to the attributes without the `android:` part. The `orientation` attribute
    has a value of `vertical`. This means that, when we start to add items to this
    layout, it will arrange them vertically from top to bottom. We could change the
    value from `vertical` to `horizontal` and it would lay things out from left to
    right.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: The next two attributes are `layout_width` and `layout_height`. These determine
    the size of the `LinearLayout`. The value given to both attributes is `match_parent`.
    The parent of a layout is the entire available space. By matching the parent horizontally
    and vertically, therefore, the layout will fill the entire space available.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Adding a TextView to the UI
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Switch back to the **Design** tab and we will add some elements to the UI.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: First, find the **TextView** in the palette. This can be found in both the **Common**
    and **Text** categories. Left-click and drag the **TextView** onto the UI, and
    notice that it sits neatly at the top of the `LinearLayout`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at the XML on the **Text** tab and confirm that it is a child of the `LinearLayout`
    and that it is indented by one tab to make this clear. Here is the code for the
    `TextView` without the surrounding code for the `LinearLayout`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Notice that it has four attributes: `id`, in case we need to refer to it from
    another UI element or from our Kotlin code; `layout_width` is set to `match_parent`,
    which means the that `TextView` stretches across the whole width of the `LinearLayout`;
    a `layout_height` attribute is set to `wrap_content`, which means the that `TextView`
    is precisely tall enough to contain the text within it; and finally, for now,
    it has a `text` element that determines the actual text it will display, and this
    is currently just set to `TextView.`'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，它有四个属性：`id`，以防我们需要从另一个UI元素或我们的Kotlin代码中引用它；`layout_width`设置为`match_parent`，这意味着`TextView`横跨整个`LinearLayout`的宽度；`layout_height`属性设置为`wrap_content`，这意味着`TextView`的高度恰好足够容纳其中的文本；最后，目前，它具有一个`text`元素，用于确定它将显示的实际文本，目前仅设置为`TextView`。
- en: Switch back to the design tab and we will make some changes.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 切换回设计选项卡，我们将进行一些更改。
- en: 'We want this text to be the heading text of this screen, which is the main
    menu screen. In the attributes window, click the search icon, type `text` into
    the search box, and change the **text** attribute to `Menu`, as shown in the following
    screenshot:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望这段文本成为此屏幕的标题文本，即主菜单屏幕。在属性窗口中，单击搜索图标，输入`text`到搜索框中，并将**text**属性更改为`Menu`，如下截图所示：
- en: '![Adding a TextView to the UI](img/B12806_04_06.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![将TextView添加到UI](img/B12806_04_06.jpg)'
- en: Tip
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You can find any attribute by searching or just by scrolling through the options.
    When you have found the attribute you want to edit, left-click it to select it
    and then press the *Enter* key on the keyboard to make it editable.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过搜索或滚动选项来查找任何属性。找到要编辑的属性后，左键单击选择它，然后按键盘上的*Enter*键使其可编辑。
- en: Next, find the `textSize` attribute using your preferred search technique and
    set `textSize` to `50sp`. When you have entered this new value, the text size
    will increase.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用您喜欢的搜索技术找到`textSize`属性，并将`textSize`设置为`50sp`。输入新值后，文本大小将增加。
- en: The `sp` stands for scalable pixels. This means that when the user changes the
    font size settings on their Android device, the font will dynamically rescale
    itself.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`sp`代表可伸缩像素。这意味着当用户在其Android设备上更改字体大小设置时，字体将动态重新调整大小。'
- en: 'Now, search for the **gravity** attribute and expand the options by clicking
    the little arrow indicated in the following screenshot:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，搜索**gravity**属性，并通过单击以下截图中指示的小箭头展开选项：
- en: '![Adding a TextView to the UI](img/B12806_04_07.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![将TextView添加到UI](img/B12806_04_07.jpg)'
- en: 'Set **gravity** to **center_horizontal,** as shown in the following screenshot:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 将**gravity**设置为**center_horizontal**，如下截图所示：
- en: '![Adding a TextView to the UI](img/B12806_04_08.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![将TextView添加到UI](img/B12806_04_08.jpg)'
- en: The `gravity` attribute refers to the gravity within the `TextView` itself,
    and our change has the effect of moving the actual text inside the `TextView`
    to the center.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`gravity`属性指的是`TextView`本身的重力，我们的更改会使`TextView`内的实际文本移动到中心。'
- en: Tip
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'Note that `gravity` is different to `layout_gravity`. The `layout_gravity`
    property sets the gravity within the layout: in this case, the parent `LinearLayout`.
    We will use `layout_gravity` later in this project.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`gravity`与`layout_gravity`是不同的。`layout_gravity`属性设置了布局内的重力：在这种情况下，是父`LinearLayout`。我们将在项目的后续部分使用`layout_gravity`。
- en: 'At this point, we have changed the text of the `TextView`, increased its size,
    and centered it horizontally. The UI designer should now look like the following
    diagram:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们已更改了`TextView`的文本，增加了其大小，并使其水平居中。UI设计师现在应该如下图所示：
- en: '![Adding a TextView to the UI](img/B12806_04_09.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![将TextView添加到UI](img/B12806_04_09.jpg)'
- en: 'A quick glance at the **Text** tab to see the XML would reveal the following
    code:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 快速浏览**Text**选项卡，查看XML代码，会发现以下代码：
- en: '[PRE4]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You can see the new attributes as follows: `gravity`, which is set to `center_horizontal`;
    text, which has changed to `Menu`; and `textSize`, which is set to `50sp`.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到新的属性如下：`gravity`设置为`center_horizontal`；文本更改为`Menu`；`textSize`设置为`50sp`。
- en: If you run the app, you might not see what you expected. This is because we
    haven't called `setContentView` in our Kotlin code to load the UI. You will still
    see the blank UI. We will fix this once we have made a bit more progress with
    the UI.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果运行应用程序，可能看不到预期的效果。这是因为我们在Kotlin代码中没有调用`setContentView`来加载UI。您仍然会看到空白的UI。我们将在UI有了更多进展后解决这个问题。
- en: Adding a multi-line TextView to the UI
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将多行TextView添加到UI
- en: Switch back to **Design** tab, find the **Multiline Text** in the **Text** category
    of the palette, and drag it onto the design just below the `TextView` we added
    a moment ago.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 切换回**Design**选项卡，在调色板的**Text**类别中找到**Multiline Text**，并将其拖放到刚刚添加的`TextView`下方的设计中。
- en: Using your preferred search technique, set **text** to `Select a layout type
    to view an example. The onClick attribute of each button will call a function
    which executes setContentView to load the new layout`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 使用您喜欢的搜索技术，将**text**设置为`选择布局类型以查看示例。每个按钮的onClick属性将调用一个函数，该函数执行setContentView以加载新布局`。
- en: 'Your layout will now look like the following screenshot:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 您的布局现在将如下截图所示：
- en: '![Adding a multi-line TextView to the UI](img/B12806_04_10.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![将多行TextView添加到UI](img/B12806_04_10.jpg)'
- en: 'Your XML will be updated with another child in the `LinearLayout`, after the
    `TextView`, that looks like the following code:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 您的XML将在`TextView`之后的`LinearLayout`中更新为另一个子元素，代码如下：
- en: '[PRE5]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You can see the details of the UI item and it turns out that the description
    on the palette of **Multiline Text** was not entirely obvious as to exactly what
    this would be. A look at the XML reveals that we have an `inputType` attribute,
    indicating that this text is editable by the user. There is also another attribute
    that we haven't seen before, and that is `ems`. The `ems` attribute controls how
    many characters can be entered per line, and the value of `10` was chosen automatically
    by Android Studio. However, another attribute, `layout_width="match_parent"`,
    overrides this value because it causes the element to expand to fit its parent;
    in other words, to cover the whole width of the screen.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: When you run the app (in the next section), you will see that the text is, indeed,
    editable – although, for the purposes of this demo app, it serves no practical
    purpose.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: Wiring up the UI with the Kotlin code (part 1)
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To achieve an interactive app, we will do the following three things:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: We will call `setContentView` from the `onCreate` function to show the progress
    of our UI when we run the app.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will write two more functions of our own and each one will call `setContentView`
    on a different layout (that we have yet to design).
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, later in this chapter, when we design two more UI layouts, we will be
    able to load them at the click of a button.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As we will be building a `ConstraintLayout` and a `TableLayout`, we will call
    our new functions, `loadConstraintLayout` and `loadTableLayout`, respectively.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: Let's do that now, and then we'll see how we can add some buttons that call
    these functions alongside some neatly formatted text.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `onCreate` function, add the following highlighted code:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The code uses the `setContentView` function to load the UI we are currently
    working on. You can now run the app to see the following results:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '![Wiring up the UI with the Kotlin code (part 1)](img/B12806_04_11.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
- en: 'Add these two new functions inside the `MainActivity` class after the `onCreate`
    function:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'There is one error with the first function and two with the second. The first
    we can fix by adding an `import` statement so that Android Studio is aware of
    the `View` class. Left-click the word `View` to select the error. Hold down the
    *Alt* key and then tap the *Enter* key. You will see the following popup:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '![Wiring up the UI with the Kotlin code (part 1)](img/B12806_04_12.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
- en: 'Chose **Import class**. The error is now gone. If you scroll to the top of
    the code, you will see that a new line of code has been added by that shortcut
    we just performed. Here is the new code:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Android Studio no longer considers the `View` class an error.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: 'The second function still has an error, however. The problem is that the function
    calls the `setContentView` function to load a new UI (`R.layout.my_table_layout`).
    As this UI layout does not exist yet, it produces an error. You can comment out
    this call to remove the error until we create the file and design the UI layout
    later this chapter. Add the double forward slash (`//`), as highlighted in the
    following code:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now we can add some buttons that we can click to call our new functions and
    load the new layouts we will be building soon. But adding a couple of buttons
    with some text on is too easy – we have done that before. What we want to do is
    line up some text with a button to the right of it. The problem is that our `LinearLayout`
    has the `orientation` attribute set to `vertical` and, as we have seen, all the
    new parts we add to the layout will be lined up vertically.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: Adding layouts within layouts
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The solution to laying out some elements with a different orientation to others
    is to nest layouts within layouts. Here is how to do it.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: 'From the **Layouts** category of the palette, drag a **LinearLayout (Horizontal)**
    onto the design, placing it just below the **Multiline Text**. Notice that there
    is a blue border occupying all the space below the **Multiline Text**:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding layouts within layouts](img/B12806_04_13.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
- en: This indicates that our new **LinearLayout (Horizontal)** is filling the space.
    Keep this blue border area in mind, as it is where we will put the next item on
    our UI.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, go back to the **Text** category of the palette and drag a **TextView**
    onto the new `LinearLayout` we just added. Notice how the `TextView` sits snuggly
    in the top left-hand corner of the new `LinearLayout`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding layouts within layouts](img/B12806_04_14.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
- en: At first, this seems no different to what happened with the previous vertical
    `LinearLayout` that was part of our UI from the start. But watch what happens
    when we add our next piece of the UI.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The term used to refer to adding layouts within layouts is **nesting**. The
    Android term applied to any item that appears on the UI (buttons and text, for
    example) is **view**, and anything that contains views is a **view group.** As
    the terms **view** and **view group** do not always make their meanings clear
    in certain contexts, I will usually refer to parts of the UI either specifically
    (such as `TextView`, `Button`, and `LinearLayout`) or more broadly (UI element,
    item, or widget).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: 'From the **Button** category, drag a **Button** onto the right-hand side of
    the previous `TextView`. Notice that the button sits to the right of the text,
    as shown in the following screenshot:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding layouts within layouts](img/B12806_04_15.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
- en: 'Next, select the `LinearLayout` (the horizontal one) by clicking on an empty
    part of it. Find the `layout_height` attribute and set it to `wrap_content`. Observe
    that the `LinearLayout` is now taking up only as much space as it needs:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding layouts within layouts](img/B12806_04_16.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
- en: Let's configure the text attribute of the `TextView` and the `Button` before
    we add the next part of the UI. Change the `text` attribute of the `Button` to
    `LOAD`. Change the text attribute of our new `TextView` to `Load ConstraintLayout`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Did you work out how to achieve the previous instruction for yourself? Yes?
    Excellent! You are now familiar with editing attributes of Android views. No?
    Left-click the item you want to edit (in this case, the `TextView`), search using
    the search icon or scroll to find the attribute you want to edit in the **Attributes**
    window (in this case, the `text` attribute), select the attribute, and press *Enter*
    to edit it. I can now give more succinct instructions on how to build future UI
    projects, and this makes your journey to becoming an Android ninja much quicker.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can repeat ourselves and add another `TextView` and `Button` attribute
    within another **LinearLayout (Horizontal)** just below the one we have just finished.
    To do so, follow these steps in order:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: Add another **LinearLayout (Horizontal)**, just below the previous one
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a **TextView** to the new `LinearLayout`
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the `text` attribute of the `TextView` to `Load TableLayout`
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `Button` on the right-hand side of the `TextView`
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the `text` attribute of the `Button` to `LOAD`
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Resize the `LinearLayout` by changing the `layout_height` attribute to `wrap_content`
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we have two neatly (and horizontally) aligned texts and buttons.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: 'Just for fun, and for the sake of exploring the palette a bit more, find the
    **Widgets** category of the palette and drag a **RatingBar** onto the design just
    below the final `LinearLayout`. Now, your UI should look very similar to this
    next screenshot:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding layouts within layouts](img/B12806_04_17.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
- en: Note
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the previous two screenshots, I hadn't yet changed the `text` attribute of
    the two `Button` elements. Everything else should be the same as yours.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: Let's add some visual finishing touches to the layout.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Making the layout look pretty
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will explore some more attributes that control the finer
    details of our UI. You have probably noticed how the UI looks a bit squashed in
    some places, and wonky and unsymmetrical in others. As we progress through the
    book, we will continually add to our repertoire to improve our layouts, but these
    short steps will introduce and take care of some of the basics:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: Select the `Multiline Text`, and then expand the `Padding` attribute. Set the
    `all` option to `15sp`. This has made a neat area of space around the outside
    of the text.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To make a nice space below the `Multiline text`, find and expand the `Layout_Margin`
    attribute and set `bottom` to `100sp`.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On both `TextView` widgets that are aligned/related to the buttons, set the
    `textSize` attribute to `20sp`, the `layout_gravity` to `center_vertical`, the
    `layout_width` to `match_parent`, and the `layout_weight` to `.7`.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On both buttons, set the weight to `.3`. Notice how both buttons now take up
    exactly `.3` of the width and the text `.7` of the `LinearLayout`, making the
    whole appearance more pleasing.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the `RatingBar`, find the `Layout_Margin` attribute, and then set `left`
    and `right` to `15sp`.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Still with the `RatingBar` and the `Layout_Margin` attribute, change `top` to
    `75sp`.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can now run the app and see our first full layout in all its glory:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '![Making the layout look pretty](img/B12806_04_18.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
- en: Notice that you can play with the `RatingBar`, although the rating won't persist
    when the app is turned off.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By way of a reader challenge, find an attribute or two that could further improve
    the appearance of the `LoadConstraintLayout` and `LoadTableLayout` text. They
    look a little bit close to the edges of the screen. Refer to the section Attributes
    – a quick summary at the start of [Chapter 5](ch05.html "Chapter 5. Beautiful
    Layouts with CardView and ScrollView"), *Beautiful Layouts with CardView and ScrollView*.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, the buttons don't do anything yet. Let's fix that.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: Wiring up the UI with the Kotlin code (part 2)
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Select the button next to the `Load ConstraintLayout` text. Find the `onClick`
    attribute and set it to `loadConstraintLayout`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Select the button next to the `Load TableLayout` text. Find the `onClick` attribute
    and set it to `loadTableLayout`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: Now, the buttons will call the functions, but the code inside the `loadTableLayout`
    function is commented out to avoid errors. Feel free to run the app and see that
    you can switch to the `ConstraintLayout` by clicking the `loadConstraintLayout`
    button. But all it has is a **Hello World** message.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: We can now move on to building this `ConstraintLayout`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: Building a precise UI with ConstraintLayout
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the `ConstraintLayout` that was auto-generated when we created the project.
    It is probably already in a tab at the top of the editor. If not, it will be in
    the `res`/`layout` folder. Its name is `activity_main.xml`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: Inspect the XML in the **Text** tab and note that it is empty, apart from a
    `TextView` that says `Hello World`. Switch back to the **Design** tab, left-click
    the `TextView` to select it, and tap the *Delete* key to get rid of it.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: Now we can build ourselves a simple, yet intricate, UI. `ConstraintLayout` is
    very useful when you want to position parts of your UI very precisely and/or relative
    to the other parts.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: Adding a CalenderView
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To get started, look in the **Widgets** category of the palette and find the
    `CalenderView`. Drag and drop the `CalenderView` near the top and horizontally
    central. As you drag the `CalenderView` around, notice that it jumps/snaps to
    certain locations.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: 'Also notice the subtle visual cues that show when the view is aligned. I have
    highlighted the horizontally central visual cue in the following screenshot:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding a CalenderView](img/B12806_04_19.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
- en: Let go when it is horizontally central, as it is in the screenshot. Now, we
    will resize it.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: Resizing a view in a ConstraintLayout
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Left-click and hold one of the corner squares that are revealed when you let
    go of the `CalenderView`, and drag inwards to decrease the size of the `CalenderView`:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '![Resizing a view in a ConstraintLayout](img/B12806_04_20.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
- en: 'Reduce the size by about half and leave the `CalenderView` near the top, horizontally
    centered. You might need to reposition it a little after you have resized it,
    a bit like the following diagram:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '![Resizing a view in a ConstraintLayout](img/B12806_04_21.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
- en: You do not need to place the `CalenderView` in exactly the same place as me.
    The purpose of the exercise is to get familiar with the visual cues that inform
    you where you have placed it, not to create a carbon copy of my layout.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: Using the Component Tree window
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now look at the **Component Tree** window – the one to the left of the visual
    designer and below the palette. The component tree is a way of visualizing the
    layout of the XML, but without all the details.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: In the following screenshot, we can see that the `CalenderView` is indented
    to the right of the `ConstraintLayout`, and is therefore a child. In the next
    UI we build, we will see that we sometimes need to take advantage of the **Component
    Tree** to build the UI.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, I just want you to observe that there is a warning sign by our `CalenderView`.
    I have highlighted it in the following screenshot:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the Component Tree window](img/B12806_04_22.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
- en: The error says **This view is not constrained. It only has designtime positions,
    so it will jump to (0,0) at runtime unless you add the constraints**. Remember
    when we first added buttons to the screen in [Chapter 2](ch02.html "Chapter 2. Kotlin,
    XML, and the UI Designer"), *Kotlin, XML, and the UI Designer*, that they simply
    disappeared off to the top-left corner?
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Run the app now and click on the **Load ConstraintLayout** button if you want
    to be reminded of this problem.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we could fix this by clicking the **Infer constraints** button that we
    used in [Chapter 2](ch02.html "Chapter 2. Kotlin, XML, and the UI Designer"),
    *Kotlin, XML, and the UI Designer*. Here it is again as a reminder:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the Component Tree window](img/B12806_04_23.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
- en: But learning to add the constraints manually is worthwhile because it offers
    us more options and flexibility. And, as your layouts become more complex, there
    is always an item or two that doesn't behave as you want it to, and fixing it
    manually is nearly always necessary.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Adding constraints manually
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Make sure that the `CalenderView` is selected and observe the four small circles
    at the top, bottom, left, and right:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding constraints manually](img/B12806_04_24.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
- en: These are the constraint handles. We can click and drag them to anchor them
    with other parts of the UI or the sides of the screen. By anchoring the `CalenderView`
    with the four edges of the screen, we can lock it into position when the app is
    run.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: One at a time, click and drag the top handle to the top of the design, the right
    to the right of the design, the bottom to the bottom of the design, and the left
    to the left of the design.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: 'Observe that the `CalenderView` is now constrained in the center. Left-click
    and drag the `CalenderView` back to the upper part of the screen somewhere, as
    in the following diagram. Use the visual cues (also shown in the following screenshot)
    to make sure the `CalenderView` is horizontally centered:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding constraints manually](img/B12806_04_25.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
- en: At this stage, you could run the app and the `CalenderView` would be positioned
    as shown in the preceding screenshot.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Let's add a couple more items to the UI and see how to constrain them.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: Adding and constraining more UI elements
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Drag an `ImageView` from the **Widgets** category of the palette and position
    it below and to the left of the `CalenderView`. When you place the `ImageView`,
    a pop-up window will prompt you to choose an image. Select **Project** | **ic_launcher,**
    and then click **OK**.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: 'Constrain the left-hand side of the `ImageView` and the bottom of the `ImageView`
    to the left and bottom of the UI, respectively. Here is the position you should
    be in now:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding and constraining more UI elements](img/B12806_04_26.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
- en: 'The `ImageView` is constrained in the bottom-left corner. Now, grab the top
    constraint handle on the `ImageView` and drag it to the bottom constraint handle
    of the `CalenderView`. This is now the current situation:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding and constraining more UI elements](img/B12806_04_27.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
- en: The `ImageView` is only constrained horizontally on one side, so is pinned/constrained
    to the left. It is also constrained vertically and equally between the `CalenderView`
    and the bottom of the UI.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, add a `TextView` to the right of the `ImageView`. Constrain the right
    of the `TextView` to the right of the UI and constrain the left of the `TextView`
    to the right of the `ImageView`. Constrain the top of the `TextView` to the top
    of the `ImageView` and constrain the bottom of the `TextView` to the bottom of
    the UI. Now you will be left with something resembling the following diagram:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding and constraining more UI elements](img/B12806_04_28.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
- en: Notice that all the warnings in the **Component Tree** window about unconstrained
    items are gone.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are warnings about hardcoded strings because we are adding text directly
    to the layout instead of the `strings.xml` file and a warning about missing the
    **contentDescription** attribute. The **contentDescription** attribute should
    be used to add a textual description so that visually impaired users can get a
    spoken description of images in the app. For the sake of making rapid progress
    with the `ConstraintLayout`, we will ignore these two warnings. We will look at
    adding string resources correctly in [Chapter 18,](ch18.html "Chapter 18. Localization")
    *Localization*, and you can read about accessibility features in Android Studio
    on the Android developer's website, at [https://developer.android.com/studio/intro/accessibility](https://developer.android.com/studio/intro/accessibility).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: 'You can move the three UI elements around and line them up neatly, just how
    you want them. Notice that when you move the `ImageView`, the `TextView` moves
    with it because the `TextView` is constrained to the `ImageView`. But also notice
    that you can move the `TextView` independently, and wherever you drop it, this
    represents its new constrained position relative to the `ImageView`. Whatever
    an item is constrained to, its position will always be relative to that item.
    And, as we have seen, the horizontal and vertical constraints are distinct from
    each other. I positioned mine as shown in the following diagram:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding and constraining more UI elements](img/B12806_04_29.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
- en: Tip
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`ConstraintLayout` is the newest layout type, and, while it is more complex
    than the other layouts, it is the most powerful, as well as the one that runs
    the best on our user''s device. It is worth spending more time looking at some
    more tutorials about `ConstraintLayout`. Especially look on YouTube, as video
    is a great medium to learn about tweaking `ConstraintLayout`. We will return to
    `ConstraintLayout` throughout the book, and you do not need to know any more than
    we have covered already to be able to move on.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: Making the text clickable
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are nearly done with our `ConstraintLayout`. We just want to wire up a link
    back to the main menu screen. This is a good opportunity to demonstrate that `TextView`
    (and most other UI items) are also clickable. In fact, clickable text is probably
    more common in modern Android apps than conventional-looking buttons.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: Change the `text` attribute of the `TextView` to `Back to the menu`. Now, find
    the `onClick` attribute and enter `loadMenuLayout`.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add the following function to the `MainActivity.kt` file just after the
    `loadTableLayout` function, as highlighted here:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now, whenever the user clicks the `Back to the menu` text, the `loadMenuLayout`
    function will be called and the `setContentView function` will load the layout
    in `main_menu.xml`.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: You can run the app, and click back and forth between the main menu (`LinearLayout`)
    and the `CalenderView` widget (`ConstraintLayout`).
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: Let's build the final layout for this chapter.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: Laying out data with TableLayout
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the project window, expand the `res` folder. Now, right-click the `layout`
    folder and select **New**. Notice that there is an option for **Layout resource**
    **file**.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: Select **Layout resource file**, and you will see the **New Resource File**
    dialog window.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: In the **File name** field, enter `my_table_layout`. This is the same name we
    used in the call to `setContentView` within the `loadTableLayout` function.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: Notice that it has already selected **LinearLayout** as the **Root** element
    option. Delete `LinearLayout` and type `TableLayout` in its place.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: Click the **OK** button and Android Studio will generate a new `TableLayout`
    in an XML file called `my_table_layout` and place it in the `layout` folder ready
    for us to build our new table-based UI. Android Studio will also open the UI designer
    (if it isn't already) with the palette on the left and the attributes window on
    the right.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: 'You can now uncomment the `loadTableLayout` function:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You can now switch to the `TableLayout`-based screen when you run the app, although
    currently, it is blank.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: Adding a TableRow to TableLayout
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Drag a `TableRow` element from the `Layouts` category on to the UI design. Notice
    that the appearance of this new `TableRow` is virtually imperceptible, so much
    so that it is not worth inserting a diagram in the book. There is just a thin
    blue line at the top of the UI. This is because the `TableRow` has collapsed itself
    around its content, which is currently empty.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to drag and drop our chosen UI elements onto this thin blue line,
    but it is also a little awkward, even counter intuitive. Furthermore, once we
    have multiple `TableRow` elements next to each other, it gets even harder. The
    solution lies in the **Component Tree** window, which we introduced briefly when
    building the `ConstraintLayout`.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: Using the Component Tree when the visual designer won't do
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Look at the **Component Tree** and notice how you can see the `TableRow` as
    a child of the `TableLayout`. We can drag our UI directly onto the `TableRow`
    in the **Component Tree**. Drag three `TextView` objects onto the `TableRow` in
    the **Component Tree** and that should leave you with the following layout. I
    have photoshopped the following screenshot to show you the **Component Tree**
    and the regular UI designer in the same diagram:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the Component Tree when the visual designer won''t do](img/B12806_04_30.jpg)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
- en: Now add another two `TableRow` objects (from the **Layouts** category). You
    can add them via the **Component Tree** window or the UI designer.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You need to drop them on the far-left of the window, otherwise the new `TableRow`
    will become a child of the previous `TableRow`. This will leave the whole table
    a bit of a muddle. If you accidentally add a `TableRow` as a child of the previous
    `TableRow,` you can either select it, then tap the *Delete* key, use the *Ctrl*
    + Z keyboard combination to undo it, or drag the mispositioned `TableRow` to the
    left (in the **Component Tree**) to make it a child of the Table – as it should
    be.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add three `TextView` objects to each of the new `TableRow` items. This
    will be most easily achieved by adding them via the **Component Tree** window.
    Check your layout to make sure it is as in the following screenshot:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the Component Tree when the visual designer won''t do](img/B12806_04_31.jpg)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
- en: Let's make the table look more like a genuine table of data that you might get
    in an app by changing some attributes.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: On the `TableLayout`, set the `layout_width` and `layout_height` attributes
    to `wrap_content`. This gets rid of extra cells.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: Change the color of all the outer (along the top and down the left-hand side)
    `TextView` objects to black by editing the `textColor` attribute. You achieve
    this by selecting the first `TextView`, searching for its `color` attribute, and
    then typing `black` in the `color` attribute values field. You will then be able
    to select `@android:color/black` from a drop-down list. Do this for each of the
    outer `TextView` elements.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: Edit the `padding` of each `TextView` and change the `all` attribute to `10sp`.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: Organizing the table columns
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It might seem at this point that we are done, but we need to organize the data
    better. Our table, like many tables, will have a blank cell in the top-left to
    divide the column and row titles. To achieve this, we need to number all the cells.
    For this, we need to edit the `layout_column` attribute.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Cell numbers are numbered from zero from the left.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: Start by deleting the top-left `TextView`. Notice that the `TextView` from the
    right has moved into the top-left position.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: Next, in the new top-left `TextView,` edit the `layout_column` attribute to
    be `1` (this assigns it to the second cell, because the first is `0` and we want
    to leave the first one empty) and, for the next cell along, edit the `layout_column`
    attribute to be `2`.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: For the next two rows of cells, edit their `layout_column` attributes from `0`
    to `2` from left to right.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want clarification on the precise code for this row after editing, here
    is a snippet, and remember to look in the download bundle in the `Chapter04` `/LayoutExploration`
    folder to see the whole file in context:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Try to complete this exercise, however, using the **Attributes** window if possible.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: Linking back to the main menu
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Finally, for this layout, we will add a button that links back to the main menu.
    Add another `TableRow` via the **Component Tree**. Drag a button onto the new
    `TableRow`. Edit its `layout_column` attribute to `1` so that it is in the middle
    of the row. Edit its `text` attribute to `Menu` and edit its `onClick` attribute
    to match our already existing `loadMenuLayout` function.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: You can now run the app and switch back and forth between the different layouts.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to, you can add some meaningful titles and data to the table by
    editing all the `text` attributes of the `TextView` widgets, as I have done in
    this following screenshot, showing the `TableLayout` running in the emulator:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '![Linking back to the main menu](img/B12806_04_32.jpg)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
- en: As a final thought, think about an app that presents tables of data. Chances
    are that data will be added to the table dynamically, not by the developer at
    design time as we have just done, but more likely by the user or from a database
    on the web. In [Chapter 16,](ch16.html "Chapter 16. Adapters and Recyclers") *Adapters
    and Recyclers*, we will see how to dynamically add data to different types of
    layout using adapters, and, in [Chapter 27](ch27.html "Chapter 27. Android Databases"),
    *Android Databases*, we will also see how to create and use databases in our apps.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have covered many topics in just a few dozen pages. We have not only built
    three different types of layout, including `LinearLayout` with nested layouts,
    `ConstraintLayout` with manually configured constraints, and `TableLayout` (albeit
    with fake data), but we have also wired all the layouts together with clickable
    buttons and text that trigger our Kotlin code to switch between all these different
    layouts.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will stick with the topic of layouts. We will review
    the many attributes we have seen, and we will build our most aesthetically pleasing
    layout so far by incorporating multiple `CardView` layouts, complete with depth
    and shadow, into a smooth-scrolling `ScrollView` layout.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
