- en: Smart Wearable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are going to look at a simple healthcare application that
    can be created using Raspberry Pi 3\. We are going to build a smart wearable with
    a 16x2 LCD that displays the location of the user, and also displays an accelerometer's
    values on the web/desktop/mobile interface. The target audience for this product
    would primarily be elderly people and the main use case being fall detection,
    which we are going to work with in [Chapter 7](part0120.html#3IE3G0-ce91715363d04669bca1c1545beb57ee),
    *Smart Wearable and IFTTT* .
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to look at the following in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: IoT and healthcare
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set up the required hardware
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrate the accelerometer and view live data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IoT and healthcare
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine a patient who successfully underwent a heart transplant surgery and
    is being sent home after post operational care in the hospital. The amount of
    attention on this patient would significantly reduce, as the facilities in the
    home would be minimal compared to a hospital. This is where IoT comes in with
    its real-time capability.
  prefs: []
  type: TYPE_NORMAL
- en: IoT and healthcare is a match made in heaven. The risks and rewards are equally
    high. Ability to monitor a patient's health in real time and get information about
    their pulse rate, body temperature, and other vital statistics, diagnose and act
    on it is quite precious. At the same time, if the connectivity was lost for two
    minutes, a life would be at stake.
  prefs: []
  type: TYPE_NORMAL
- en: In my opinion, to realize the full potential of IoT in healthcare, we may need
    to wait for another 5 - 10 years, where the connectivity is absolutely seamless
    and packet loss is a word of ancient history.
  prefs: []
  type: TYPE_NORMAL
- en: Smart wearable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned in the preceding section, we are going to do one of the critical
    things in healthcare using IoT. The main purpose of the smart wearable we are
    going to build is to identify fall detection. Once fall detection is identified,
    we notify the cloud about it. This is a very precious feature when we have elderly
    or sick people around who collapse due to unexpected reasons. Identifying the
    fall immediately and taking an action on it can be life saving at times.
  prefs: []
  type: TYPE_NORMAL
- en: 'To detect falls, we are going to use an accelerometer. Quoting from Wikipedia:'
  prefs: []
  type: TYPE_NORMAL
- en: '"An **accelerometer** is a device that measures proper acceleration. Proper
    acceleration, being the acceleration (or rate of change of velocity) of a body
    in its own instantaneous rest frame, is not the same as coordinate acceleration,
    being the acceleration in a fixed coordinate system. For example, an accelerometer
    at rest on the surface of the Earth will measure an acceleration due to Earth''s
    gravity, straight upwards (by definition) of g â‰ˆ 9.81 m/s2\. By contrast, accelerometers
    in free fall (falling toward the centre of the Earth at a rate of about 9.81 m/s2)
    will measure zero."'
  prefs: []
  type: TYPE_NORMAL
- en: 'To know more about an accelerometer and how it works, refer to *How an accelerometer
    works* at: [https://www.youtube.com/watch?v=i2U49usFo10](https://www.youtube.com/watch?v=i2U49usFo10).'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we are going to implement the basic system that gathers the
    X, Y, and Z axis acceleration raw values and gets displayed on web, desktop, and
    mobile apps. In [Chapter 7](part0120.html#3IE3G0-ce91715363d04669bca1c1545beb57ee),
    *Smart Wearable and IFTTT*, we are going to implement fall detection using these
    values.
  prefs: []
  type: TYPE_NORMAL
- en: Along with gathering the accelerometer values in real time, we are going to
    use the 16x2 LCD display to show the current time and the geolocation of the user.
    If needed, we can add other texts to this display as well. 16x2 is a simple interface
    to display content. This can be extended with Nokia 5110 LCD ([http://www.amazon.in/inch-Nokia-5110-KG075-KitsGuru/dp/B01CXNSJOA](http://www.amazon.in/inch-Nokia-5110-KG075-KitsGuru/dp/B01CXNSJOA))
    to have a more advanced display with graphics.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we are going to put together the required hardware and
    then update the Raspberry Pi code. After that we are going to start working on
    the API engine and the UI templates.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up smart wearable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first thing to note about the hardware setup is that it is big and bulky.
    This is only a POC and is not even a remotely close production setup. The hardware
    setup would consist of an accelerometer connected to Raspberry Pi 3 and a 16X2
    LCD.
  prefs: []
  type: TYPE_NORMAL
- en: The accelerometer ADXL345 gives the acceleration of X, Y, and Z axis over I2C
    protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'Connect the hardware as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00093.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see in the preceding schematic, we have made the following connections:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Raspberry Pi and LCD:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| **Raspberry Pi number - Pin name** | **16x2 LCD Pi name** |'
  prefs: []
  type: TYPE_TB
- en: '| 6 - GND - Breadboard rail 1 | 1 - GND |'
  prefs: []
  type: TYPE_TB
- en: '| 2 - 5V - Breadboard rail 2 | 2 - VCC |'
  prefs: []
  type: TYPE_TB
- en: '| 1 k Ohm potentiometer | 3 - VEE |'
  prefs: []
  type: TYPE_TB
- en: '| 32 - GPIO 12 | 4 - RS |'
  prefs: []
  type: TYPE_TB
- en: '| 6 - GND - Breadboard rail 1 | 5 -R/W |'
  prefs: []
  type: TYPE_TB
- en: '| 40 - GPIO 21 | 6 - EN |'
  prefs: []
  type: TYPE_TB
- en: '| NC | 7 - DB0 |'
  prefs: []
  type: TYPE_TB
- en: '| NC | 8 - DB1 |'
  prefs: []
  type: TYPE_TB
- en: '| NC | 9 - DB2 |'
  prefs: []
  type: TYPE_TB
- en: '| NC | 10 - DB3 |'
  prefs: []
  type: TYPE_TB
- en: '| 29 - GPIO 5 | 11 - DB4 |'
  prefs: []
  type: TYPE_TB
- en: '| 31 - GPIO 6 | 12 - DB5 |'
  prefs: []
  type: TYPE_TB
- en: '| 11 - GPIO 17 | 13 - DB6 |'
  prefs: []
  type: TYPE_TB
- en: '| 12 - GPIO 18 | 14 - DB7 |'
  prefs: []
  type: TYPE_TB
- en: '| 2 - 5V - Breadboard rail 2 | 15 - LED+ |'
  prefs: []
  type: TYPE_TB
- en: '| 6 - GND - Breadboard rail 1 | 16 - LED- |'
  prefs: []
  type: TYPE_TB
- en: 'Raspberry Pi and ADXL345:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| **Raspberry Pi number - Pin name** | **ADXL345 pin number - Pin name** |'
  prefs: []
  type: TYPE_TB
- en: '| 1 - 3.3V | VCC |'
  prefs: []
  type: TYPE_TB
- en: '| 6 - GND - Breadboard rail 1 | GND |'
  prefs: []
  type: TYPE_TB
- en: '| 5 - GPIO3/SCL1 | SCL |'
  prefs: []
  type: TYPE_TB
- en: '| 3 - GPIO2/SDA1 | SDA |'
  prefs: []
  type: TYPE_TB
- en: '| 6 - GND - Breadboard rail 1 | SDO |'
  prefs: []
  type: TYPE_TB
- en: 'We will add the required code:'
  prefs: []
  type: TYPE_NORMAL
- en: First create a folder named `chapter6` and then copy the contents of `chapter4`
    into it. We will update this code as we go along
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, we will start with the `pi-client`. On the Raspberry Pi, open `pi-client/index.js`
    and update it as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the preceding code, we are displaying the location, using
    `displayLocation()`, every one hour, as we are assuming that the location would
    not change frequently. We are using the [http://ipinfo.io/](http://ipinfo.io/)
    service to get the user's location.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, using `readSensorValues()` we get the value of `accelerometer` every
    `3` seconds and publish this data to a topic named `accelerometer`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, we will install the required dependencies. From inside the `pi-client`
    folder, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Save all the files and start the mosca broker on the server or our desktop
    machine by running:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, run the code on Raspberry Pi:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This will start the `pi-client` and will start collecting the accelerometer
    and display the location on the LCD display as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00094.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'My setup is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00095.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Next, we will work with the API engine.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the API engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have the smart wearable running and sending the three axis data,
    we will now implement the required logic needed to accept that data in the API
    engine and send the data to the web/desktop/mobile app:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `api-engine/server/mqtt/index.js` and update it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are subscribing to a topic named `accelerometer` and listening for
    changes on it. Next, we update `api-engine/server/api/data/data.controller.js`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is used to save the data to database and fetch the data from
    database when requested from web, desktop, and mobile apps.
  prefs: []
  type: TYPE_NORMAL
- en: 'Save all the files and run the API engine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This will start the API engine, if needed we can restart the smart wearable
    and we should see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00096.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In the next section, we will work on the web app to display the data.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the web app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we are done with the API engine, we will update the template in the
    web app to display the three axis data. Open `web-app/src/app/device/device.component.html`
    and update it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The required logic will be inside `device.component.ts`. Open `web-app/src/app/device/device.component.ts`
    and update it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Save all the files and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Navigate to `http://localhost:4200` and view the device and we should see the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00097.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: With this, we are done with the web app.
  prefs: []
  type: TYPE_NORMAL
- en: Updating a desktop app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that the web app is done, we are going to build the same and deploy it inside
    our desktop app.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started, head back to the terminal/prompt of the `web-app` folder and
    run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'And this will create a new folder inside the `web-app` folder named `dist`.
    The contents of the `dist` folder should be similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'All the code we have written is finally bundled into the preceding files. We
    will grab all the files (not the `dist` folder) present inside the `dist` folder
    and then paste it inside the `desktop-app/app` folder. The final structure of
    the desktop app after the preceding changes will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'To test drive, run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'And then when we navigate to the VIEW DEVICE page, we should see the following
    screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00098.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: With this we are done with the development of the desktop app. In the next section,
    we will update the mobile app.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the mobile app template
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last section, we have updated the desktop app. In this section, we are
    going to update the mobile app template to display the three axis data.
  prefs: []
  type: TYPE_NORMAL
- en: 'First we are going to update the view-device template. Update `mobile-app/src/pages/view-device/view-device.html`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we update `mobile-app/src/pages/view-device/view-device.ts` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Save all the files and run the mobile app either by using `ionic serve` or `ionic
    cordova run android`.
  prefs: []
  type: TYPE_NORMAL
- en: 'And we should see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00099.gif)'
  prefs: []
  type: TYPE_IMG
- en: With this we are done with displaying the data from the smart wearable on the
    mobile app.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have seen how to build a simple smart wearable using Raspberry
    Pi 3\. We have set up a LCD and a three-axis accelerometer and we displayed the
    location information on the display. We have posted the accelerometer data in
    real time to the cloud and displayed it on the web, desktop, and mobile apps.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 7](part0120.html#3IE3G0-ce91715363d04669bca1c1545beb57ee), *Smart
    Wearable and IFTTT*, we are going to take the smart wearable to the next level
    by implementing IFTTT rules on top of it. We are going to perform actions such
    as making a phone call or sending an SMS to the patience emergency contact so
    that immediate care can be given.
  prefs: []
  type: TYPE_NORMAL
