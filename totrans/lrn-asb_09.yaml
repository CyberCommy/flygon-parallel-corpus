- en: Building Out a Cloud Network
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have launched servers in DigitalOcean, we will move on to starting
    to look at launching services within **Amazon Web Services** (**AWS**).
  prefs: []
  type: TYPE_NORMAL
- en: Before we launch instances, we will need to create a network for them to be
    hosted in. This is called a VPC, and there are a few different elements we will
    need to bring together in a playbook to create one, which we will then be able
    to use for our instances.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will:'
  prefs: []
  type: TYPE_NORMAL
- en: Get an introduction to AWS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cover what it is we are trying to achieve and why
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a VPC, subnets, and routes—networking and routing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create security groups—firewall
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create an **Elastic Load Balancing** (**ELB**)—load balancer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are going to use AWS; you will need administrator access
    to be able to create the roles needed to allow Ansible to interact with your account.
    As with other chapters, you can find the complete playbooks in the `Chapter09`
    folder in the accompanying GitHub repository at [https://github.com/PacktPublishing/Learn-Ansible/tree/master/Chapter09/vpc](https://github.com/PacktPublishing/Learn-Ansible/tree/master/Chapter09/vpc).
  prefs: []
  type: TYPE_NORMAL
- en: An introduction to AWS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'AWS has been around since 2002; it started by offering a few services which
    were not linked in any way—it progressed in this form until early 2006 when it
    was relaunched. The relaunched AWS brought together three services:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Amazon Elastic Compute Cloud (Amazon EC2)**: This is the AWS compute service'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Amazon Simple Storage Service (Amazon S3)**: Amazon''s scalable object storage
    accessible service'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Amazon Simple Queue Service (Amazon SQS)**: This service provides a message
    queue, primarily for web applications'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Since 2006 it has grown from three unique services to over 160, covering over
    15 primary areas such as:'
  prefs: []
  type: TYPE_NORMAL
- en: Compute
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Networking and content delivery
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Machine learning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analytics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security, identity, and compliance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Internet of Things
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At its earnings call in February 2018, it was revealed that AWS had $17.46 billion
    in revenue in 2017 which accounted for 10% of Amazon's total revenue; not bad
    for a service which originally offered to share idle compute time.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the time of writing, AWS spans 18 geographic regions, which host a total
    of 54 availability zones: [https://aws.amazon.com/about-aws/global-infrastructure/](https://aws.amazon.com/about-aws/global-infrastructure/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'So what makes AWS so successful? Not only its coverage, but its approach to
    putting out its services. Andy Jassy, AWS CEO, has been quoted as saying:'
  prefs: []
  type: TYPE_NORMAL
- en: '"Our mission is to enable any developer or any company to be able to build
    all their technology applications on top of our infrastructure technology platform."'
  prefs: []
  type: TYPE_NORMAL
- en: As an individual, you have access to the same APIs, service, regions, tools,
    and also pricing models as large multi-national companies and also Amazon themselves
    as they consume their services. This really gives you the freedom to start small
    and scale massively. For example, Amazon EC2 instances start from around $4.50
    per month for a t2.nano (1 vCPU, 0.5G) all the way up to over $19,000 per month
    for an x1e.32xlarge (128 vCPU, 3,904 GB RAM, two 1920 GB SSD storage)—as you can
    see, there are instance types for every workload imaginable.
  prefs: []
  type: TYPE_NORMAL
- en: Both of these instances and most services are billed as pay-as-you-go modules,
    from per-second billing for EC2 instances or pay per GB per month for the storage
    you are using.
  prefs: []
  type: TYPE_NORMAL
- en: Amazon Virtual Private Cloud overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are going to be concentrating on launching an **Amazon Virtual
    Private Cloud** (**Amazon VPC**); this is the networking layer which will house
    the compute and other Amazon services we will be launching in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'An overview of the VPC our playbook is going to launch is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/3cc7aae7-3f58-4999-bffc-621d0535095e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, we are going to be launching our VPC into the **EU-West #1**
    (Ireland) region; we will be spanning all three availability zones for our EC2
    instances and also the **Application Elastic Load Balancer**. We will only be
    using two availability zones for our Amazon **Relational Database Service** (**RDS**)
    instance and also two zones for the **Amazon Elastic File System** (**Amazon EFS**)
    volumes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This all means our Ansible playbook needs to create/configure the following:'
  prefs: []
  type: TYPE_NORMAL
- en: One Amazon VPC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Three subnets for EC2 instances
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two subnets for Amazon RDS instances
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two subnets for Amazon EFS volumes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Three subnets for the Application Load Balancer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One internet gateway
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will also need to configure the following:'
  prefs: []
  type: TYPE_NORMAL
- en: One route to allow access through the internet gateway
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One security group which allows everyone to access to port `80` (HTTP) and `443`
    (HTTPS) on the Application Load Balancer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One security group which allows trusted source access to port `22` (SSH) on
    the EC2 instances
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One security group which allows access to port `80` (HTTP) from the Application
    Load Balancer to the EC2 instances
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One security group which allows access to port `3306` (MySQL) on the Amazon
    RDS instances from the EC2 instances
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One security group which allows access to port `2049` (NGF) on the Amazon EFS
    volumes from the EC2 instances
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This will give us our basic network, allowing restrictive access to everything
    but the Application Load Balancer which we want to be publicly available. Before
    we start creating an Ansible playbook which deploys the network, we need to get
    an AWS API access key and secret.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an access key and secret
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is more than possible to create an access key and secret key for your own
    AWS user that would give Ansible full access to your AWS account.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because of this, we are going to look at creating a user for Ansible which
    only has permission to access the parts of AWS we know that Ansible will need
    to interact with for the tasks we are covering in this chapter. We will be giving
    Ansible full access to the following services:'
  prefs: []
  type: TYPE_NORMAL
- en: Amazon VPC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Amazon EC2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Amazon RDS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Amazon EFS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To do this, log in to the AWS console, which can be found at [https://console.aws.amazon.com/](https://console.aws.amazon.com/).
    Once logged in, click on Services, which can be found in the menu at the very
    top of the screen. In the menu which opens, enter `IAM` into the search box and
    then click on what should be the only result, IAM Manage User Access and Encryption
    Keys. This will take you to a page that looks something similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/b5d44c52-1d83-43b8-87a8-749837229570.png)'
  prefs: []
  type: TYPE_IMG
- en: On the IAM page, click on Groups in the left-hand side menu; we are going to
    be creating a group which will have the permissions assigned to it, then we will
    create a user and assign it to our group.
  prefs: []
  type: TYPE_NORMAL
- en: Once you are on the Groups page, click on the Create New Group button. This
    process has three main steps, the first of which is setting the name of the group.
    In the space provided, enter the group name `Ansible` and then click on the Next
    Step button.
  prefs: []
  type: TYPE_NORMAL
- en: The next step is where we attach the policies; we will be using the Amazon-supplied
    ones. Select AmazonEC2FullAccess, AmazonVPCFullAccess, AmazonRDSFullAccess, and
    AmazonElasticFileSystemFullAccess; once all four have been selected, click on
    the Next Step button.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should now be on a page which is giving you an overview of the options
    you have selected; it should look something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ab3872af-5311-4a14-80ee-b2ff16b83a6e.png)'
  prefs: []
  type: TYPE_IMG
- en: When you are happy with your selection, click on the Create Group button and
    then click on Users in the left-hand side menu.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once on the Users page, click on Add user, and this will take you to a page
    where you can configure your desired username and also what type of user you want.
    Enter the following information:'
  prefs: []
  type: TYPE_NORMAL
- en: 'User name: Enter `Ansible` in here'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'AWS access type: Check the box next to where it says Programmatic access; our
    `Ansible` user does not need AWS Management Console access so leave that option
    unchecked'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You should now be able to click on the Next: Permissions button; this will
    take you to the page where you set the permissions for your user. As we have already
    created the group, select the `Ansible` group from the list and then click on
    Next: Reviewwhich will take you to an overview of the options you have entered.
    If you are happy with them, then click on the Create user button.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This will take you to a page that looks like the following (I have blurred
    the access key ID on purpose):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/6ed3ccc4-4fd1-468d-8e81-f34d65bd0dc1.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the success message tells you that this is the last time you
    will be able to download the credentials, meaning that you will not be able to
    see the secret access key again. Either click on the Show button and make a note
    of the key or click the Download .csv button; you will not have the opportunity
    to recover the secret access key, only to allow it to expire and generate a new
    one.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have an access key ID and secret access key for a user with the
    permissions we need to launch our VPC using Ansible, we can make a start at writing
    the playbook.
  prefs: []
  type: TYPE_NORMAL
- en: The VPC playbook
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first thing we need to discuss is how we can pass our access key ID and
    also the secret access key to Ansible in a safe and secure way. As I will be sharing
    the final playbooks in a public repository on GitHub, I do not want to share my
    AWS keys with the world as that could get expensive! Typically, if it were a private
    repository, I would use Ansible Vault to encrypt the keys and include them in
    there with other potentially sensitive data such as deployment keys and so on.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, I don't want to include any encrypted information in the repository
    as it would mean that people would need to unencrypt it, edit the values, and
    then re-encrypt it. Luckily, the AWS modules provided by Ansible allows you to
    set two environment variables on your Ansible controller; those variables will
    then be read as part of the playbook execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'To set the variables, run the following commands to make sure that you replace
    the content with your own access key and secret (the information listed as follows
    is just placeholder values):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Once set, you can view the contents by running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from the output, this will display the content of the `AWS_ACCESS_KEY`
    variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/2fae39d3-2fab-490c-a908-82b2e8bc720d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that we have a way to pass our credentials to Ansible, we can create the
    playbook structure by running the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have the basics in place, we can make a start at creating the roles;
    unlike previous chapters, we are going to be running the playbook after we have
    added each role so we can discuss in more detail what has happened.
  prefs: []
  type: TYPE_NORMAL
- en: The VPC role
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first role we are going to create is the one which creates the VPC itself.
    Everything we are going to configure/create in the upcoming roles needs to be
    hosted within a VPC, so it needs to be created and then we need to gather some
    information on it so we can proceed with the rest of the playbook.
  prefs: []
  type: TYPE_NORMAL
- en: 'To bootstrap the role, run the following command from within your working folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have the files for the role, open `roles/vpc/tasks/main.yml` and
    enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we are using an Ansible module called `ec2_vpc_net`; this module
    replaces one called `ec2_vpc` which was deprecated and removed in Ansible 2.5.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are using three variables within the task; the first two, `ec2_region` and
    `environment_name`, should be placed in `group_vars/common.yml` as we will be
    using them in most of the of the roles we will be creating:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Both variables are self-explanatory: the first is the name we will be using
    to reference the various elements we will be launching in AWS and the second lets
    Ansible know where we would like the VPC to be created.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The third variable, `vpc_cidr_block`, should be placed in the `roles/vpc/defaults/main.yml`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This defines the CIDR we want to use; `10.0.0.0/16` means that we would like
    to reserve 10.0.0.1 to 10.0.255.254 which gives us a range of around 65,534 usable
    IP address, which should be more than enough for our tests.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of the first task, we are using the register flag to take all of
    the content which has been captured during the creation of the VPC and register
    that as a variable. We are then using the debug module to print this content to
    the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have our first role, we can add some content to our `site.yml`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Then run the playbook using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This should give you something like the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Checking the VPC section of the AWS console should show you that the VPC has
    been created, and the information should match what has been captured by Ansible:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/03e9bc2f-fa70-4e2d-82e2-f5111b81b5ab.png)'
  prefs: []
  type: TYPE_IMG
- en: If you rerun the playbook, you will notice that, rather than creating the VPC
    again, Ansible recognizes that there is already a VPC called `my-vpc` and it discovers
    the information on the already existing VPC and populates the `vpc_info` variable.
    This is useful as we will be using the information gathered in the next role.
  prefs: []
  type: TYPE_NORMAL
- en: The subnets role
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have our VPC, we can start to populate it. The first thing we are
    going to configure is the 10 subnets. If you recall, we need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Three EC2 instances
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Three ELB instances
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two RDS instances
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two EFS instances
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Create the role by running the following command from your working directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, in `roles/subnets/defaults/main.yml`, enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we have a list of variables containing what the subnet is being
    used for (`ec2`, `elb`, `rds`, or `efs`), which availability zone the subnet should
    be created in (`a`, `b`, or `c`), and then the subnet itself. Here we are using
    a /24 for each of the availability zones.
  prefs: []
  type: TYPE_NORMAL
- en: 'Grouping the subnets like this should remove some of the repetition when it
    comes to creating the subnets. However, it doesn''t remove it all, as we can see
    from the content of `roles/subnets/tasks/main.yml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The task starts off pretty simple: here we are using the `ec2_vpc_subnet` module
    to create subnets by looping through the `the_subnets` variable. As you can see,
    we are using the variable we registered in the previous role to correctly deploy
    the subnets into our VPC; this is `vpc_info.vpc.id`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that we are not registering the results of this task;
    this is because, if we did, we would have had information on all ten subnets.
    Instead, we want to break this information down based on what the subnet is being
    used for. To find this information out, we can use the `ec2_vpc_subnet_facts`
    module to gather information based on our filtering using the `Environment` and
    `Use` tag we set when creating the subnets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, here we are filtering the use of and registering four different
    sets of information: `subnets_ec2`, `subnets_elb`, `subnets_rds`, and `subnets_efs`.
    We are not quite there yet, however, because we only want to know the subnet IDs
    rather than all of the information about each of the subnets.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we need to use the `set_fact` module and some Jinja2 filtering:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can print out all of the IDs to the screen in one big list by joining
    the variables together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have all of the parts of our role together, let''s run it. Update
    the `site.yml` file so it looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Then run the playbook using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Before running the playbook, I commented out the `debug` task in the VPC role.
    Your output should look something like the output that follows; you may have noticed
    that the VPC role returns an `ok` as our VPC is there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The only change recorded is the addition of the subnets; if we were to run
    it again, then this would also return an `ok` as the subnets exist. As you can
    also see, we have ten subnet IDs returned and this is also reflected in the AWS
    console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c64f7a9f-9ec7-4c01-b840-f5e5e7367277.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that we have our subnets, we need to make sure that the EC2 instances can
    route to the internet.
  prefs: []
  type: TYPE_NORMAL
- en: The internet gateway role
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While the internet gateway role is going to only variables which we have defined
    in `common.yml`, and through gathering information in previous tasks, we should
    continue to bootstrap the `roles` folder as we have been doing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We are going to be using two modules in the role; the first, `ec2_vpc_igw`,
    creates the internet gateway and tags it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We then print the information we have registered about the internet gateway
    to the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Before finally using the second module, `ec2_vpc_route_table`, we create a
    route which sends all traffic destined for `0.0.0.0/0` to the newly created internet
    gateway for just the EC2 subnets using the list of IDs we created in the previous
    role:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the role of the `site.yml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Then run the playbook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, as we have run the playbook three times now, I should quickly
    mention the `WARNING`. This is because we are not using an inventory file, as
    we have defined `localhost` at the top of our `site.yml` file. You should receive
    something like the following output; again I have commented out the debug tasks
    from previous roles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Back to the AWS console. You should be able to view the internet gateway:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/2b3f505c-0ec7-4212-b931-dcbdd76896e6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the preceding screenshot, you can see the default VPC internet gateway and
    also the one we created using Ansible. You can also see the route table we created:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/3d308540-a5d0-491b-8912-58b35cbb716d.png)'
  prefs: []
  type: TYPE_IMG
- en: Here you can see the route Ansible configured along with the default route that
    was created when we created the VPC. This default route is set to be the main
    route and allows routing between all of the subnets we added in the previous role.
  prefs: []
  type: TYPE_NORMAL
- en: Next up, we need to add some security groups to our VPC.
  prefs: []
  type: TYPE_NORMAL
- en: The security group role
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have a few different aims with this role. The first is simple enough: create
    a security group which opens port `80` and `443` to the world, or `0.0.0.0/0`
    in IP terms. The second aim is to create a rule that allows SSH access, but only
    to us, and the third is to make sure that only our EC2 instances can connect to
    RDS and EFS.'
  prefs: []
  type: TYPE_NORMAL
- en: The first aim is easy as `0.0.0.0/0` is a known quantity, the others not so
    much. Our IP could often change so we don't want to hardcode it. Also, we haven't
    launched any EC2 instances, so we don't know their IP addresses.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s bootstrap the role and create the first set of rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We are going to be using the `ec2_group` module to create our first group in
    `roles/securitygroups/tasks/main.yml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Here we are creating a rule called `my-vpc-elb`, tagging it, and then opening
    up ports `80` and `443` to `0.0.0.0/0`. As you can see, adding a rule is easy
    when you know the source IP address is straightforward. Let's now look at adding
    the rule the for the EC2 instances; this one is a little different.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, we do not want to give everyone access to SSH on our instances
    so we need to know the IP address of our Ansible controller. To do this we will
    use the `ipify_facts` module.
  prefs: []
  type: TYPE_NORMAL
- en: ipify is a free web API which simply returns the current public IP address of
    the device you use to query the API.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see from the tasks that follow, we are making an API call to ipify
    and then setting a fact which contains the IP address before printing the IP address
    to the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we know what IP address to allow access to port `22`, we can create
    a rule called `my-vpc-ec2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: There is also the second rule in the `my-vpc-ec2`security group; this rule allows
    access to port `80` from any source which has the `my-vpc-elb`security group attached,
    which in our case will be just the ELBs. This means that the only way anyone can
    access port `80` on our EC2 instances is through the ELB.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to use this same principle to create the RDS and EFS groups, this
    time only allowing access to ports `3306` and `2049` respectively to any instances
    in the `my-vpc-ec2` security group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our main groups created, let''s add a `debug` task to print
    the security group IDs to the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our full role, we can run the playbook. Remember to add `-
    roles/securitygroups` to the `site.yml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, I have commented out any output from the `debug` module outside the
    `securitygroups` role:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'You can view the groups that Ansible has created in the AWS console. In the
    following screenshot, you can see the `my-vpc-ec2`security group:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/2a7aa377-4181-4b69-96a2-390834eb4deb.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that we have our basic VPC configured, we can start to launch services in
    it, starting with an Application Load Balancer.
  prefs: []
  type: TYPE_NORMAL
- en: The ELB role
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The final role we are going to look at in this chapter is one which launches
    an Application Load Balancer. Well, it creates a target group which is then attached
    to an Application Load Balancer. The load balancer we will be creating with this
    role is basic; we will be going into a lot more detail in the later chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like the other roles, we first need to bootstrap the files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Now open `roles/elb/tasks/main.yml` and use the `elb_target_group` module to
    create the target group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we are creating the target group in our VPC and calling it
    `my-vpc-target-group`. Now we have the target group, we can launch the Application
    Elastic Balancer using the `elb_application_lb` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are provisioning an Application Load Balancer called `my-vpc-elb` in
    our VPC; we are passing the IDs of the ELB subnets we created using the `subnet_elb_ids`.
    We are also adding the ELB security group to the load balancer using the `sg_elb.group_id`
    and configuring a listener on port `80`, which forwards traffic to the `my-vpc-target-group`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final part of the task prints the information we have captured about the
    ELB:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'That completes our final role; update the `site.yml` file so it looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now run our playbook for the final time by running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'You can probably guess that the output of the playbook run is going to look
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'You should now be able to see the ELB in the EC2 part of the AWS console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/65e6ad53-1d4f-401b-82d1-5e2e63cc0e69.png)While VPC''s do not incur
    any cost, ELBs do; please ensure that you remove any unused resources as soon
    as you have completed your test.'
  prefs: []
  type: TYPE_NORMAL
- en: That concludes this chapter on the VPC playbook; we will be using elements of
    this in the next chapter, where we will be looking at deploying our WordPress
    installation into AWS using a VPC as the foundation of our installation.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have taken our next step in using Ansible to launch resources
    in a public cloud. We have laid the groundwork for automating quite a complex
    environment by creating a VPC, setting up the subnets we need for our application,
    provisioning an internet gateway, and setting our instances to route their outgoing
    traffic through it.
  prefs: []
  type: TYPE_NORMAL
- en: We have also configured four security groups, three of which contained dynamic
    content, to secure our services before finally provisioning an ELB into our VPC.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will build on the foundations we have laid in this chapter
    and launch a more complex set of services.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are the two environment variables used by the AWS modules to read your
    access ID and secret?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True or false: Every time you run the playbook, you will get a new VPC.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: State and explain why we are not bothering to register the results of creating
    the subnets.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between using `cidr_ip` and `group_id` when defining
    a rule in a security group?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True or false: The order in which the security groups are added when using
    rules which have `group_id` defined doesn''t matter.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a second VPC alongside the existing VPC, give it a different name, and
    also have it use 10.1.0.0/24.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can find more details on the AWS technologies we have used in this chapter
    at the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: '**AWS**: [https://aws.amazon.com/](https://aws.amazon.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**AWS Management Console**: [https://aws.amazon.com/console/](https://aws.amazon.com/console/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**AWS IAM**: [https://aws.amazon.com/iam/](https://aws.amazon.com/iam/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Amazon VPC**: [https://aws.amazon.com/vpc/](https://aws.amazon.com/vpc/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ELB**: [https://aws.amazon.com/elasticloadbalancing/](https://aws.amazon.com/elasticloadbalancing/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
