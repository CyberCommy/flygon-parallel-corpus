- en: Building the World and Optimizing for VR
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Through the course of our work so far in this book, we've been focused for the
    most part on the player avatar. This makes sense—virtual reality dramatically
    changes the way the player engages with the world. We needed to learn new ways
    of enabling the player to get around, new ways of using their hands to interact
    with the world, and new ways of constructing user interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: This is no small achievement, so congratulations for getting this far!
  prefs: []
  type: TYPE_NORMAL
- en: Now, we're going to shift our focus a bit and begin to look at the environment
    around us. Up to this point, we've been using existing environments, but now it's
    time to begin to build our own. As we do this, we are going to learn that environments
    in VR present challenges that we're going to need to address. Lighting, object
    scale, and sightlines all come into play to a greater degree than they do on the
    flat screen, and performance is a major consideration.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we're going to learn how to use the tools and techniques at
    our disposal to address these challenges as we build. We'll learn how to use the
    VR editor to lay out our environment from within the headset and see how it's
    actually going to appear in VR as we build it, and we'll learn how to profile
    and optimize these environments to make sure that we can meet our frame rate requirements.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to explore the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Building and lighting a scene using the VR editor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Profiling the scene to identify performance bottlenecks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimizing the scene using static mesh instancing, LODs, mesh combination, and
    lighting changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Project settings for optimization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Special considerations and technical requirements for mobile VR
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's get to it and give ourselves a place to play.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the project and collecting assets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this chapter''s work, let''s create a new project with the following template
    options:'
  prefs: []
  type: TYPE_NORMAL
- en: A Blank Blueprint template
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Targeting Mobile/Tablet hardware
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scalable 2D or 3D
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No starter content
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once the project has been created, open its Project Settings and set the following menu
    options:'
  prefs: []
  type: TYPE_NORMAL
- en: Project | Description | Settings | Start in VR: True
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Engine | Rendering | Forward Renderer | Forward Shading: True
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Engine | Rendering | Default Settings | Ambient Occlusion Static Fraction: False
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Engine | Rendering | Default Settings | Anti-Aliasing Method: MSAA
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Engine | Rendering | VR | Instanced Stereo: True
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Engine | Rendering | VR | Round Robin Occlusion Queries: True
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allow the project to restart once all these settings have been set.
  prefs: []
  type: TYPE_NORMAL
- en: Once the project has restarted, open the File menu and use it to load the previous
    chapter's project. Just as we did last time, we're going to grab elements that
    we previously created and carry them forward using the Migrate tool.
  prefs: []
  type: TYPE_NORMAL
- en: Migrating blueprints into the new project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: From your previous project, select BP_VRGameMode from the content explorer,
    right-click it, and select Asset Actions | Migrate. Select your new project's
    `Content` directory as its destination content folder. Because the GameMode references
    BP_VRPawn, and BP_VRPawn references BP_CompanionCharacter, all of these objects
    and their required supporting assets should come across.
  prefs: []
  type: TYPE_NORMAL
- en: Once the migration is complete, there's one more thing we need to do. We have
    a few custom inputs set up for our previous project, and we'll need them for our
    new one as well. Navigate to last chapter's project directory and copy the `Config/DefaultInput.ini`
    file to your new project's config directory.
  prefs: []
  type: TYPE_NORMAL
- en: Verifying the migrated content
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Re-open the new project. The first thing we''re going to want to do here is
    verify that everything we''ve brought across is working correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: Let's select File | New Level | VR Basic to create a starting VR map.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drop a Nav Mesh Bounds Volume onto the map and make sure it surrounds the floor.
    Setting its Location to (X=0.0, Y=0.0, Z=0.0) and Scale to (X=10.0, Y=10.0, Z=2.0)
    will take care of this. Remember to hit the *P* key to visualize your navmesh
    and make sure it's generating properly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save this level (we named ours VRModePractice and placed it in `Content/C07/Maps`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open Settings | Project Settings | Maps & Modes | Default Modes, and set your
    Default GameMode to the BP_VRGameMode we migrated from the other project. Set
    your Editor Startup Map and Game Default Map to this map, as well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drop an instance of BP_CompanionCharacter anywhere onto the level.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Test the map in a VR preview. You should be able to move and teleport, and
    your companion character should follow you:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fc9c3181-0e37-4c0e-941c-dce2a397c9fb.png)'
  prefs: []
  type: TYPE_IMG
- en: This map is a great map to use for learning the Unreal Editor's VR Mode—it's
    easy to get around, and gives us lots of pieces we can manipulate as we practice
    with the interface. Let's take advantage of this.
  prefs: []
  type: TYPE_NORMAL
- en: Using the VR editor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unreal Engine comes equipped with a very capable virtual reality editor that
    allows you to build your scenes entirely from within the virtual environment.
    Nearly any editor operation you might need to perform can be done without leaving
    VR.
  prefs: []
  type: TYPE_NORMAL
- en: 'It may be tempting, though, to look at the VR Mode editor as a gimmick when
    you first encounter it. After all, what''s wrong with the existing editor? Nothing,
    but here''s the thing: virtual reality isn''t a flat screen. Depth exists. Sightlines
    are different. Colors render differently. Developing for virtual reality by using
    a flat screen adds a layer of abstraction to your design process. You''ll understand
    more and get better results by working directly in your target medium when you
    can.'
  prefs: []
  type: TYPE_NORMAL
- en: In practice, you're likely to find both editing modes useful. Just as it's difficult
    to see what a scene is really going to look like in VR from the flat-screen editor
    view, it's difficult to achieve precision in placing objects in VR Mode. You'll
    discover your workflow as you get comfortable with the tools, and you'll discover
    which operations you prefer to do in which domains. The point here, though, is
    that it's worthwhile to think of VR Mode as an important part of your scene layout
    workflow for VR. Take the time to get comfortable with it so you can rely on it
    when it's warranted.
  prefs: []
  type: TYPE_NORMAL
- en: A good practice for VR editing is to do your initial block-out in VR. Place
    objects in ways that evoke the sense of space you want to convey, and then go
    to traditional flat-screen editing to refine your layout and populate it further.
    Finally, return to VR editing for your final refinements so you can see exactly
    what you're going to get.
  prefs: []
  type: TYPE_NORMAL
- en: Let's activate the VR editor and see what we can do with it. Since you won't
    be able to read this book while you're inside the headset, we'll go over a few
    basic principles, allow you to try them out, and then return here to explore a
    few more.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing to know is how to enter and exit the VR editor.
  prefs: []
  type: TYPE_NORMAL
- en: Entering and exiting VR Mode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can activate the VR editor by using the VR Mode toolbar button. To exit
    VR Mode, activate the radial menu (more on this later) and select System | Exit.
    It''s easiest, though, to get used to using *Alt* + *V* to enter and exit VR Mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f2ae6c39-2220-4e8a-9a50-b632e84f25e1.png)'
  prefs: []
  type: TYPE_IMG
- en: It's also possible to configure VR Mode to enter automatically when the headset
    is put on while the editor is running. To do this, select Edit | Editor Preferences
    | General | VR Mode, and set Enable VR Mode Auto-Entry to True. Whether you'd
    like to do this is your choice, but, in practice, it tends to have a difficult
    time figuring out when to turn itself back off, so using *Alt* + *V* to enter
    and exit is usually a better idea.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you prefer to interact primarily using your left hand, you have the option
    here in the VR Mode preferences to switch your Interactor Hand:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a392086e-d933-429b-a2c3-4f1bf5fc4f12.png)'
  prefs: []
  type: TYPE_IMG
- en: VR Mode settings are found under Edit | Editor Preferences | General | VR Mode.
  prefs: []
  type: TYPE_NORMAL
- en: Set either of these options if you'd like. We're going to leave the rest of
    these at their defaults for our work here.
  prefs: []
  type: TYPE_NORMAL
- en: The other thing we're going to need to address is how to move and look around.
  prefs: []
  type: TYPE_NORMAL
- en: Navigating in VR Mode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You activate movement mode in the VR editor by squeezing the grip buttons. When
    movement mode activates, the movement grid will appear and the interaction beam
    will turn green.
  prefs: []
  type: TYPE_NORMAL
- en: The interaction beam in the VR editor changes colors to indicate what mode it's
    in. Red indicates standard interaction mode, green indicates movement mode, yellow
    indicates that you currently have an actor selected, and blue indicates that you're
    in UI interaction mode.
  prefs: []
  type: TYPE_NORMAL
- en: The metaphor for movement in the VR editor is **pushing** and **pulling** the
    world. It's fairly intuitive. In most instances, the world will move in the way
    your hand is moving while your movement mode is active.
  prefs: []
  type: TYPE_NORMAL
- en: Moving through the world
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you move the controller while holding the grip, the world moves as though
    you''re pulling it, or swimming through it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f2dc78f9-a553-4565-8de0-6e296858c517.png)'
  prefs: []
  type: TYPE_IMG
- en: If you release the grip while moving the controller, the movement continues
    for a bit, as though you'd pushed off of an object and were now floating away
    from it. This takes a bit of practice, but it becomes fairly intuitive once you
    get the hang of it. Squeezing the grip again stops your movement.
  prefs: []
  type: TYPE_NORMAL
- en: The movement grid displays the location of the floor in your real-world tracking
    volume. Align it with the floor in your scene to see what objects will really
    look like from the perspective of someone standing on the floor.
  prefs: []
  type: TYPE_NORMAL
- en: Teleporting through the world
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To teleport through the world, squeeze the grip button on your dominant hand''s
    controller and squeeze the trigger. Aim the controller at an object or destination,
    and you''ll teleport there on release:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8b12e78c-502a-4277-b5a6-c0cf29469f4c.png)'
  prefs: []
  type: TYPE_IMG
- en: Using a combination of teleport and drag moves, you can get around the world
    pretty well.
  prefs: []
  type: TYPE_NORMAL
- en: Rotating the world
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you need to rotate your viewpoint, hold both controllers'' grips and rotate
    the controllers around each other as though you were trying to spin the world:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6670d6e8-9842-40d5-8e06-93375f97a53f.png)'
  prefs: []
  type: TYPE_IMG
- en: The number you see over the rotation axis is the world's current scale. We can
    manipulate that too.
  prefs: []
  type: TYPE_NORMAL
- en: Scaling the world
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To scale the world, squeeze the grips and move the controllers toward each
    other to shrink the world, or away from each other to expand it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f9f14b1e-e254-4ebe-8ede-68b9a207c0ba.png)'
  prefs: []
  type: TYPE_IMG
- en: It's weirdly satisfying to shrink your scene down until it looks like miniatures
    on a table.
  prefs: []
  type: TYPE_NORMAL
- en: Moving the controllers toward each other shrinks the world. Moving them away
    from each other grows the world. This can be useful for layout, as you can assemble
    the world in miniature, then teleport back to the ground and restore its normal
    scale to see what you've made.
  prefs: []
  type: TYPE_NORMAL
- en: One of the fastest ways to get around the world in VR Mode is to shrink the
    world, then use the teleport action (grip + trigger) to teleport to a new location
    on your map. The world will return to its default size when you teleport.
  prefs: []
  type: TYPE_NORMAL
- en: Practicing movement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Take some time now to practice navigating through the world using your controllers.
    Use *Alt* + *V* to enter VR Mode, and hit *Alt* + *V* again when you want to exit.
    Use the grip buttons to move through the world, teleport, rotate, and change its
    scale. Play with it until it feels natural. There's a bit of subtlety to getting
    this, but it's a very useful tool once you've made yourself comfortable.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying the world in VR Mode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you've practiced moving around the world a bit, let's start to learn
    some of the skills we'll need to do scene composition in VR.
  prefs: []
  type: TYPE_NORMAL
- en: Moving, rotating, and scaling objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To select an object, just point at it and pull the trigger. Your interaction
    beam will turn yellow to indicate that you''ve entered selection mode. A gizmo
    will appear that allows you to move the object. By default, this will be a translate
    gizmo, which allows you to move the selected object around (we''ll see in a moment
    how to switch to other types of gizmo):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/80c407e4-b9b3-4693-bf34-7108cdaaa4c5.png)'
  prefs: []
  type: TYPE_IMG
- en: If you'd like to move the selected object, release the trigger and then pull
    it again while pointing at the object or at the transform gizmo. You can use the
    transform gizmo's arrows and planes to constrain your movement, or interact directly
    with the object to move it freely. When moving an object directly with the interaction
    beam, you can use the trackpad to move it closer or further from you.
  prefs: []
  type: TYPE_NORMAL
- en: Be aware that hidden objects with collision can sometimes interfere with selection
    in VR Mode. If your selection beam appears to pass through the object you want
    to select, move to a different vantage point to select it.
  prefs: []
  type: TYPE_NORMAL
- en: Usually it's a better idea to use the gizmo to move an object, as it's fairly
    difficult to move objects in depth with any precision.
  prefs: []
  type: TYPE_NORMAL
- en: 'The default transform gizmo can be switched to other modes using the radial
    menu interface. To activate the radial menu, touch the trackpad or thumbstick
    on your non-interactor hand and point at the menu option you''d like to select.
    Use the trigger to select it. Your controller''s menu button takes you back out
    of sub-menus, or closes the radial menu if you''re already at the top menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dab60762-c626-49ee-97e7-5d65f28008b3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Selecting the Gizmo submenu allows you to switch between transform gizmo options:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/155452c0-31cd-40fa-a1d4-61ddd45c5fbf.png)'
  prefs: []
  type: TYPE_IMG
- en: The Universal gizmo provides translation, rotation, and scale handles on a single
    gizmo. The Translate, Rotate, and Scale gizmos provide individual tools for those
    operations. Switching the transform mode to Local Space rotates, scales, and moves
    the object along its own axes, while the World Space mode transforms the object
    along the world axes.
  prefs: []
  type: TYPE_NORMAL
- en: Using both controllers to rotate and scale objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You also may have noticed that, whenever you have an object selected and you''re
    holding the trigger over the object itself (rather than a gizmo handle), a second
    interaction beam appears on your off-hand controller. If you aim that second interaction
    beam at the object and squeeze the trigger, you can use them both to tumble and
    stretch the object:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b2e8f473-afa4-4b7c-a554-b2fc53f4fd6a.png)'
  prefs: []
  type: TYPE_IMG
- en: This is a great tool for exploring improvising rough layouts. It's intuitive
    and invites natural interaction with objects in your environment. This is a good
    tool to use for exploring and improvising layouts. You'll probably have a tough
    time getting things exactly where you want them, but if you use this tool for
    rough layouts and then clean them up in the flat-screen editor, you can achieve
    good results.
  prefs: []
  type: TYPE_NORMAL
- en: Practicing moving objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Try it out now. Hit *Alt* + *V* to enter VR Mode, and, in addition to practicing
    moving around the world, practice using the transform gizmos and free movement
    to move objects around the world. Remember to use the radial menu to change movement
    modes, and use the Menu button to get back out to the Home menu. Take some time
    to practice this. The controls will probably feel unfamiliar at first, but once
    you get the hang of them, world-building in VR is a rewarding experience.
  prefs: []
  type: TYPE_NORMAL
- en: When you're done, hit *Alt* + *V* to exit VR Mode again, and, if you'd like,
    clean up your object alignments in flat-screen editing.
  prefs: []
  type: TYPE_NORMAL
- en: Now we're ready to begin composing a scene, and to do this, we'll be using the
    VR Mode menus.
  prefs: []
  type: TYPE_NORMAL
- en: Composing a new scene in VR Mode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we''ve learned the basics of operating the VR Mode editor, let''s
    go deeper and really see how we can use this as a scene composition tool. First,
    we''re going to need some assets to work with. The free Infinity Blade: Grass
    Lands package will give us something to play with.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open your Epic Games Launcher (it''s fine to leave your existing project open
    as you do this), navigate to the Unreal Engine | Marketplace | Free tab, and search
    for Infinity Blade: Grass Lands. Hit Add to Project and select your new project
    as the target project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/de76f21f-15b8-4547-aea8-0b70bc57d246.png)'
  prefs: []
  type: TYPE_IMG
- en: Once the assets have finished downloading and installing, let's force the new
    shaders to compile. Open up `Content/InfinityBladeGrassLands/Maps/Overview`, and
    let the shaders compile. While these shaders are compiling, feel free to enter
    VR Mode using *Alt* + *V* and navigate around the overview map to see what assets
    we have available to us.
  prefs: []
  type: TYPE_NORMAL
- en: After you've built your shaders, we can do some work composing a scene using
    these assets. For this exercise, we're going to start with an existing map and
    modify it.
  prefs: []
  type: TYPE_NORMAL
- en: First, we'll need to learn how to navigate the editor menus in VR.
  prefs: []
  type: TYPE_NORMAL
- en: Navigating the radial menu
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Menu interaction in the VR editor, is for the most part, handled by a series
    of radial menus attached to the controller. In practice, these are fairly intuitive
    to use, as they map clearly to the touchpad or thumbstick inputs on the hand controllers.
    Let''s look at how they work:'
  prefs: []
  type: TYPE_NORMAL
- en: Select `Content/InfinityBladeGrassLands/Maps/ElvenRuins` and open it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you'd like, you can also change your Project Settings | Maps & Modes | Default
    Maps to open this map automatically.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use *Alt* + *V* to enter VR Mode, and, while you're in this mode, touch the
    left trackpad or thumbstick to activate the radial menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To enter a menu, aim the interaction beam at it and squeeze the trigger or use
    the menu hand's trackpad to select options.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To back out of the submenus, use the non-dominant hand''s menu button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d0ebaa31-c31e-4b5a-af82-d439d01952b0.png)'
  prefs: []
  type: TYPE_IMG
- en: You can use the interaction beam or the menu hand's trackpad to navigate menus
    in VR Mode
  prefs: []
  type: TYPE_NORMAL
- en: Let's get into VR Mode and explore the menus. You have eight major menu categories
    available from the Home menu.
  prefs: []
  type: TYPE_NORMAL
- en: Gizmo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've already explored the Gizmo menu, so we won't dive back into detail here.
    Remember that it's used to switch between behaviors of your in-editor movement
    tools.
  prefs: []
  type: TYPE_NORMAL
- en: Snapping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Snapping menu is a close partner to the Gizmo menu. Most of these behave
    as you''re used to in the flat-screen editor, but the Smart Snapping option is
    especially worth knowing about:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0d9a5d14-bdee-44c3-b3f7-0d9b4a6d0ab6.png)'
  prefs: []
  type: TYPE_IMG
- en: With Smart Snapping active, objects you move in-scene will attempt to align
    themselves to other objects as you move them. Since precise placement can be challenging
    to achieve in VR Mode, this is a big help.
  prefs: []
  type: TYPE_NORMAL
- en: Use the Set Targets option to select a specific object you'd like other objects
    to snap to, and use the Reset Targets option to clear it.
  prefs: []
  type: TYPE_NORMAL
- en: Windows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Windows submenu provides access to the individual palettes and menus you''ll
    be using as you compose your scene:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/08e0c5ff-bf84-4ffe-b5f7-6106e96a719d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Each button opens its associated panel. These are the same panels you''re used
    to from the flat-screen editor:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1c3a8eb8-99ed-4ec7-b102-ad48fb8b989e.png)'
  prefs: []
  type: TYPE_IMG
- en: The Content Browser as seen in the editor's VR Mode
  prefs: []
  type: TYPE_NORMAL
- en: 'To move a window, aim the interaction beam at the large bar beneath it. You
    can place and angle it any way you want. The downward-facing arrow to the left
    of the move bar pins the window in place. When it''s activated, the window will
    stay where you place it, regardless of how you move through the world. When it''s
    un pinned, the window will move with you when you move. The X-shaped button to
    the right of the bar closes the window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/356e00a5-a2bb-40f3-b05e-b134d6f70583.png)'
  prefs: []
  type: TYPE_IMG
- en: You can move your active windows around to create a virtual workspace from which
    to work
  prefs: []
  type: TYPE_NORMAL
- en: These windows work just as they do in the flat-screen editor. An effective practice
    in using them is to open only the windows that you need, and arrange them around
    yourself in a virtual workspace for the task you're doing.
  prefs: []
  type: TYPE_NORMAL
- en: In practice, much of the time, you'll find it useful to leave your content browser
    open to your side along with the details pane.
  prefs: []
  type: TYPE_NORMAL
- en: Edit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Edit menu allows you to duplicate, delete, and snap objects in your scene:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4488086f-c2ca-40b5-b0c8-61c05d031518.png)'
  prefs: []
  type: TYPE_IMG
- en: Most of these options should be pretty self-explanatory and what you'd expect
    an edit menu to contain. Snap to Floor is a bit of an outlier, so it's worth remembering
    that it's in here. You'll use it often.
  prefs: []
  type: TYPE_NORMAL
- en: Tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Tools menu is primarily geared toward managing simulations in the editor.
    Here, you can start, pause, and resume simulations, and save their results back
    to the editor:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5892c6f2-95f1-45d8-8bee-99f8bff1de4e.png)'
  prefs: []
  type: TYPE_IMG
- en: Two options that aren't related to simulations are also contained here. The
    Screenshot tool snaps a standard-resolution screenshot, but be aware that the
    screenshot will include the menu, so move it out of sight if you want a clean
    shot. The Flashlight tool is useful for finding your way around dark scenes, especially
    if you're midway through composing your scene lighting.
  prefs: []
  type: TYPE_NORMAL
- en: Modes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Modes panel allows you to place actors such as lights, volumes, and primitives;
    manage foliage; enter landscape sculpting mode; and paint textures and vertex
    colors, just as it does in the flat-screen editor:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/64bd219b-1806-4c61-bd7c-c849fa96e31f.png)'
  prefs: []
  type: TYPE_IMG
- en: Selecting one of these options will bring up a Modes panel that can then be
    placed in the world and used in the same way as the other panels available from
    the Windows menu.
  prefs: []
  type: TYPE_NORMAL
- en: Actions and System
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At present, the System menu just gives you a way to exit VR Mode. At the time
    of writing, it doesn't do anything else. The Actions menu's behavior varies depending
    on context.
  prefs: []
  type: TYPE_NORMAL
- en: Making changes to our scene
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we've learned how to get around in VR Mode, let's put some of this
    learning into practice. We're going to modify the Elven Ruins map from within
    VR Mode.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we're going to do is change the time of day. Let's see how these
    ruins would look at dawn.
  prefs: []
  type: TYPE_NORMAL
- en: Use *Alt* + *V* to enter VR Mode and touch your non-interaction hand's trackpad
    or thumbstick to bring up the radial menu. Use the menu button to navigate back
    up to home if you're currently in a submenu. Select the Windows menu and, from
    there, activate the World Outliner.
  prefs: []
  type: TYPE_NORMAL
- en: Use the interaction beam to drag the movement box at the base of the menu. Put
    it to your side and a bit below you.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re going to look for the directional light that''s acting as our sun in
    this scene. To find it, click the Type column''s header to sort your actor list
    by type, and then use the trackpad to scroll through the list and find the Directional
    Light named Light Source:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/140918b5-9f61-407c-9946-f1c8c0a90074.png)'
  prefs: []
  type: TYPE_IMG
- en: Unfortunately, you don't have an easy way to enter text in VR Mode. The radial
    menu offers a number pad that you can use when setting values, but if you wanted
    to search for light, you'd have to type it using a conventional keyboard. Sorting,
    scrolling, and selecting works pretty well for this sort of work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you''ve selected the directional light, use the radial menu to activate
    the Details panel. Use the bar beneath it to drag it to a location where you can
    read it and interact with it, but can still see the sky:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f3da5d9f-2324-46c8-b3c8-f9ef685ac4a7.png)'
  prefs: []
  type: TYPE_IMG
- en: In this shot taken from within the VR headset, you can see how we've been able
    to create a virtual workspace by manipulating the panels in 3D space.
  prefs: []
  type: TYPE_NORMAL
- en: Point the interaction beam at the light's Rotation Y value and drag it back
    and forth over the box to change its value. You'll see the sun changing overhead.
    It starts out at around -48\. Drag it to around 210 (or wherever you like, really)
    to create some nice dramatic shadows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, select BP_SkySphere. From its Details panel, turn on Colors Determined
    by Sun Position, and check the Refresh Material checkbox to change the sky''s
    color:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e22807ac-9bb1-4709-8745-a18250d6ae31.png)'
  prefs: []
  type: TYPE_IMG
- en: That's kind of nice, right? Lighting changes like this are often best made inside
    the VR Mode editor, as light and colors render very differently in the headset
    than they do on the flat screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Building new elements in your map is generally best done in the flat-screen
    editor. VR Mode is excellent for checking sightlines and adjusting object positions,
    but, in practice, it still suffers from some growing pains that can make object
    selection difficult:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c765d94a-f495-4905-81c7-2f95b9da01af.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here are a few effective ways to work within VR Mode, benefit from its strengths,
    and work around its weaknesses:'
  prefs: []
  type: TYPE_NORMAL
- en: Get around by scaling the world down, then use teleport to land where you want
    to go
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do rough lighting adjustments inside VR Mode where you can see what their effects
    on the world will really be
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build geometry in the traditional editor, but use VR Mode to experiment with
    its placement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get into the habit of using *Alt* + *V* frequently to check your environment
    in VR as you build it. You'll get a sense of which adjustments make sense to do
    in VR Mode and which work best in the traditional editor.
  prefs: []
  type: TYPE_NORMAL
- en: Most importantly, what we wanted to communicate in this section is that VR Mode,
    far from being a luxury or a gimmick, should be considered an essential tool for
    your scene construction workflow in VR.
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing scenes for VR
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we've spoken a fair bit about editing scenes using VR Mode, let's talk
    about an absolutely crucial topic in VR development – maintaining an acceptable
    frame rate.
  prefs: []
  type: TYPE_NORMAL
- en: We've discussed the paramount importance of maintaining frame rate in virtual
    reality several times before. It's critical, and it's challenging to do. In the
    remainder of this chapter, we're going to talk about things that you can do to
    speed up your scenes and to find out what's preventing them from running faster.
  prefs: []
  type: TYPE_NORMAL
- en: Testing your current performance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first thing you need to do when assessing your scene's performance is to
    find out how fast you're currently running. We're going to look at a few commands
    we can use for this.
  prefs: []
  type: TYPE_NORMAL
- en: 'From within the editor, click on the **`** (backtick) key. It''s to the left
    of the *1* key on your keyboard, above the Tab key. A console entry box will appear:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9b17c2c8-c708-4a46-b879-a20869b57de7.png)'
  prefs: []
  type: TYPE_IMG
- en: A wide range of console commands can be entered here. We're going to talk about
    those you're most likely to use as you optimize your scenes.
  prefs: []
  type: TYPE_NORMAL
- en: Stat FPS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Enter `stat fps` into the console command line. A frame rate counter will appear
    in your editor window, displaying two values:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/11449d96-431c-4d3b-8911-fce9fbf607fe.png)'
  prefs: []
  type: TYPE_IMG
- en: The first is your frames per second (FPS). The second value tells you how many
    milliseconds it took to draw the frame, and this is the value you should train
    yourself to focus on. Frame rate is what your player perceives, but, as you're
    developing and trying to solve problems that impact your frame rate, you're going
    to have a much easier time thinking about how the changes you make affect your
    performance if you train yourself to think in milliseconds. The frame rate describes
    your desired result, but the milliseconds you're spending on each part of getting
    the frame rendered are the cause. When fixing your scene, you need to look at
    the individual costs of each operation that's contributing to your frame time,
    and these are expressed in milliseconds.
  prefs: []
  type: TYPE_NORMAL
- en: Determining your frame time budget
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we're going to think in terms of milliseconds, the first thing we need to
    do is establish how many milliseconds we can spend drawing our frame and still
    hit our target frame rate. Figuring this out is simple.
  prefs: []
  type: TYPE_NORMAL
- en: To find your application's frame time budget, divide 1,000 by your target frame
    rate.
  prefs: []
  type: TYPE_NORMAL
- en: 'This gives you the number of milliseconds in which you have to draw your frame
    to achieve this frame rate. So, for example, if you''re targeting a headset that
    refreshes at 90 FPS (which describes most of them), we find our frame budget like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*1000 / 90 = 11.11*'
  prefs: []
  type: TYPE_NORMAL
- en: This gives us a frame budget of around 11 milliseconds. Your VR application
    will refresh at 90 FPS if it takes you 11 milliseconds or less to deliver the
    frame. That's not a lot of time, so we're going to have to do some work with most
    scenes to achieve this.
  prefs: []
  type: TYPE_NORMAL
- en: Warnings about performance profiling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we dive too deep down the performance optimization rabbit hole, let's
    keep a few important things in mind.
  prefs: []
  type: TYPE_NORMAL
- en: First, the frame time reported on a flat screen isn't going to be accurate for
    VR. It's a good baseline value that you can use to see roughly how you're doing,
    but when you activate VR, your frame rate is going to drop.
  prefs: []
  type: TYPE_NORMAL
- en: If you see a really substantial drop in frame rate between your flat-screen
    values and your VR values, check your Project Settings and make sure you have
    Instanced Stereo turned on. If it's off, which is its default setting, you'll
    be paying the full cost of rendering your entire scene twice, which you definitely
    don't want to do.
  prefs: []
  type: TYPE_NORMAL
- en: Be sure you're not just checking your values on flat-screen. Test in VR often.
    A quick way of checking your VR performance is to read your stat fps values from
    within VR Mode.
  prefs: []
  type: TYPE_NORMAL
- en: Activate VR Mode with stat fps visible. The text will probably be too small
    to read from within the headset, but you can read it from the flat-screen output.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use this method to spot-check your environment. Move through the map and check
    for problem areas using VR Mode.
  prefs: []
  type: TYPE_NORMAL
- en: Another important thing to consider is that, because we're testing in-editor,
    our numbers are affected by the editor itself. We're paying to render all those
    windows that your editor displays along with the in-game scene. For accurate values,
    we have to run the game in a stand alone session. Checking your numbers in-editor
    is a good practice to see whether changes you're making are making things better
    or worse, but you should remember that they don't accurately describe what your
    packaged application will do.
  prefs: []
  type: TYPE_NORMAL
- en: We also need to remember that, when we test frame time in-editor, we're really
    just looking at rendering performance, but we're not getting any information about
    what the rest of our application is costing us. This is fine much of the time,
    since the bulk of your problems are likely to be in rendering, but you should
    still make sure you're testing the running application to make sure you don't
    have a runaway Blueprint or too many animated characters bringing you down.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we should talk about system specifications. Different hardware configurations
    will perform in different ways. If you're planning to release an application to
    the public, you should be sure that you're testing it on your minimum spec hardware,
    as well as on your development machines. Just because your application is running
    fine on a beast with a brand-new high-end video card doesn't mean it's going to
    run so well on older hardware. If you can test on your min-spec target, do so.
    If you can't, be conscious of how far your development machine is from your min-spec
    and make sure you leave a decent amount of headroom in your frame time budget
    to accommodate this.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've talked a bit about the things that can affect our measurements,
    let's dive in deeper and learn how to get better information than we can get with
    stat fps alone.
  prefs: []
  type: TYPE_NORMAL
- en: Stat unit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Checking our frame rate is useful and it's an important thing to do frequently,
    but on it's own it doesn't tell us much. It may tell us that we have a problem,
    but it won't give us much guidance in finding what's wrong or how to fix it. For
    this, we have a few more useful commands at our disposal.
  prefs: []
  type: TYPE_NORMAL
- en: The stat unit command breaks down the frame's cost in milliseconds and shows
    us which parts of that cost are coming from the scene we're rendering and which
    parts are coming from other things going on in our application, such as animations
    and AI.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try it now. Click on the **` **(backtick) key to bring up your console command
    window, and type stat unit to add this additional information below your frame
    rate information:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5122dfe5-e217-4074-91b6-280a4a5dedf2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The stat unit command displays four primary pieces of information:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Frame: This is the total time it took to draw the frame. This is the same value
    we saw in the stat fps results.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Game: This tells you how long your game thread is taking on your CPU. This
    covers things such as animation updates, AI, and anything else your CPU has to
    figure out in order to update the frame. If you have Blueprints doing inefficient
    things on the Tick event, that will drive this value up.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Draw: This tells you how long your CPU spent preparing the scene for rendering.
    High values here may mean that you''re doing too much occlusion culling or spending
    too much on lights or shadows.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'GPU: This value tells you how long the GPU took to draw the frame. High values
    here may mean that you''re drawing too many polygons, using too many materials,
    or that your materials are too complex. Most of the time, your problems will be
    here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These values are not additive. Your game thread will wait for the rendering
    thread to complete, so, if the Game timing matches your GPU timing, what that's
    really telling you is that your CPU isn't holding you up, and that your frame
    time is being driven by rendering.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to these four base values, we also have two advanced pieces of
    information that you don''t need to worry about right now:'
  prefs: []
  type: TYPE_NORMAL
- en: 'RHIT: This is your rendering hardware interface thread. Realistically, you
    won''t be seeing values here that differ much from your GPU values unless you''re
    working with advanced rendering hardware or a video game console, and you''re
    running your rendering hardware interface calls on a dedicated thread. Until you''re
    working on an advanced project with a dedicated team of engineers, this probably
    doesn''t apply to you.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'DynRes: This indicates whether dynamic resolution is supported or being used
    by your application. In practice, this is only supported on video game consoles,
    so you don''t need to worry about it here. If you''re curious, further information
    can be found at [https://docs.unrealengine.com/en-us/Engine/Rendering/DynamicResolution](https://docs.unrealengine.com/en-us/Engine/Rendering/DynamicResolution).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What we're interested in finding from our stat unit information is whether we're
    spending most of our time on our Game CPU, our Game rendering operations, or on
    our GPU. We're looking for the largest number, because this is going to tell us
    what we need to fix.
  prefs: []
  type: TYPE_NORMAL
- en: You should make it a habit to leave stat fps and stat unit on nearly all the
    time as you develop. If you introduce something new to the scene that is going
    to hammer your frame rate, the best time to discover this is when you put it in.
    If you go a long time before you discover a problem, you're going to have to do
    a lot more work to find out what caused it.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s often worth it to see how your stat unit values are changing over time,
    either as things happen in your application (this is useful for finding hitches)
    or as you move through the scene. To get this information, use stat unitgraph
    to display a graph over time of your scene''s performance metrics:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/971499d0-346e-437d-b48f-f10bb04678da.png)'
  prefs: []
  type: TYPE_IMG
- en: You'll see that your stat unit values have now been color-coded to correspond
    with lines on the graph.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned previously, most of the time, your problems will be with the GPU
    art that's just too heavy to fit within your scene.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, if you're doing ridiculous things on your Tick, you may be getting
    killed on your CPU, in which case you're going to want to look for Blueprints
    that could be refactored to act in response to events or changes in data instead
    of using the tick. But, most of the time, GPU is where you're going to run into
    trouble.
  prefs: []
  type: TYPE_NORMAL
- en: Profiling the GPU
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first tool you should learn to use in optimizing your scene is the GPU
    profiler. You can activate this by typing profilegpu in the console, but since
    you''re going to use it so often, it''s a better idea to memorize the hotkey:
    *Ctrl* + *Shift* + *,* (comma). Hit it now and let''s look at the numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/97c0ff5f-9d7a-462c-a3b4-3a2ee3630f01.png)'
  prefs: []
  type: TYPE_IMG
- en: The most important part of this profile report is the graph under the Scene
    heading. Roll over the graph, and you'll see that tooltips tell you what each
    block represents. The two biggest blocks will usually be your BasePass and your
    PostProcessing pass. The base pass represents the act of drawing everything in
    the scene. Post processing handles anything that's taken care of after the scene
    has been drawn, such as screen-space ambient occlusion, color correction, and
    other effects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hit the expander to the left of the Scene heading to drill down for more detail
    into your scene rendering:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ae6955a0-d425-4afa-8eb5-9d33ee1045fa.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, we can see a more detailed breakdown of what's costing us time in drawing
    our frame. Lighting looks good here, as does translucency. Our BasePass is fairly
    sizeable, but that's to be expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'You''re not going to get too much more information by drilling down into your
    BasePass, but you can learn some useful stuff by drilling into your PostProcessing
    operations. Use the triangle beside your PostProcessing header to drill into it,
    and then click on large chunks in your PostProcessing operations to see what they
    are:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d6640a19-f716-4575-8685-0433e7722b89.png)'
  prefs: []
  type: TYPE_IMG
- en: In this instance, these post numbers look pretty good. We don't have anything
    returning an unreasonably high duration.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure you profile with the game running, or you'll see a lot of operations
    coming from the editor.
  prefs: []
  type: TYPE_NORMAL
- en: We're not going to have the space here to dig into everything involved in the
    rendering process and what it means, but in general, what you're looking for are
    large items that may be unnecessarily impacting your frame rate. When you find
    something that looks suspicious, search for it on the Unreal forums, and you'll
    likely find a discussion of what it means and what to do about it.
  prefs: []
  type: TYPE_NORMAL
- en: As you use this tool more and more, you'll develop a sense for what looks healthy
    and what problem areas look like. Use it often to get a clear handle on what your
    application is doing.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's look at a few other useful commands we can use to debug our scene.
  prefs: []
  type: TYPE_NORMAL
- en: Stat scenerendering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Behind the GPU profiler, your next most useful command is likely to be stat
    scenerendering. This command gives you a detailed list of the steps your system
    is taking to render the scene with their associated timings:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6087c36f-4f15-4688-b71f-292166f05f8a.png)'
  prefs: []
  type: TYPE_IMG
- en: It's especially worthwhile in here to look at your Dynamic shadow setup and
    your Translucency drawing.
  prefs: []
  type: TYPE_NORMAL
- en: If you're seeing high values in your shadow setup, see whether one or more of
    your lights is doing too many shadow cascades or has a shadow distance that's
    too long. You can find more information on this topic at [https://docs.unrealengine.com/en-us/Platforms/Mobile/Lighting/HowTo/CascadedShadow](https://docs.unrealengine.com/en-us/Platforms/Mobile/Lighting/HowTo/CascadedShadow).
  prefs: []
  type: TYPE_NORMAL
- en: 'If your Translucency drawing is high, activate your editor''s Quad Overdraw
    optimization viewmode, and look for translucent objects stacking over one another.
    If you have a problem here, you might be able to solve it by using masked rather
    than translucent materials, or by being careful about how they overlap in views:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/acd1e832-c2fe-4486-89d3-c317d9df8bd0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'At the bottom of this list are some very important numbers: Mesh draw calls
    and Static List draw calls. We should talk about these.'
  prefs: []
  type: TYPE_NORMAL
- en: Draw calls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the biggest factors that will impact your scene performance is the number
    of **draw calls** required to get its information onto the GPU. What are we talking
    about here? It breaks down like this: everything you want the video card to draw
    has to be copied onto that card''s memory. The act of sending a set of instructions
    to the card is called a draw call, or a **draw primitive call** (sometimes abbreviated
    to **DPC**). Let''s say you have a static mesh appearing in your scene that has
    three materials on it. That''s going to take four draw calls to set it up on the
    card: one for the mesh, and one for each material. You should endeavor to keep
    the number of draw calls in your scene as low as you can get it. Realistically,
    2,000 draw calls is probably your limit for a VR scene. On mobile VR, like the
    Oculus Go or Quest, that number is lower.'
  prefs: []
  type: TYPE_NORMAL
- en: What does this mean for you? First, put as few materials on your objects as
    you can get away with; ideally, one material per object. By adding just one more
    material slot, you've literally added one-third more to the cost of loading that
    object onto the video hardware, and if that object appears frequently in your
    scene, that's going to add up in a hurry.
  prefs: []
  type: TYPE_NORMAL
- en: We're going to talk shortly about what you can do about high draw call counts,
    but for now what you need to know about them is that, if these numbers are high,
    you're sending too many separate instructions to the video card, and that's going
    to slow you down. Maybe you have too many material slots on your objects, or too
    many individual objects being sent separately, but in all cases, it's a thing
    you'll need to fix.
  prefs: []
  type: TYPE_NORMAL
- en: Stat RHI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another closely related command you''ll use often is stat rhi. **RHI** stands
    for **rendering hardware interface**, and it tells you specifically what''s impacting
    your rendering performance:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bc2c62aa-340e-407c-99c4-2d67ef13d687.png)'
  prefs: []
  type: TYPE_IMG
- en: The two values you'll care most about here are Triangles drawn and your DrawPrimitive
    calls. Make it a habit to look through your scene with these values displayed,
    and look for views with unreasonably high triangle counts or draw call counts.
    For a VR scene on a desktop VR headset, you want to keep the number of triangles
    drawn below 2 million, and you want to keep your draw calls under 2,000.
  prefs: []
  type: TYPE_NORMAL
- en: The other value you should care about here is your memory consumption. Another
    way to get a scene running really slowly in real time is to use textures that
    are unreasonably large. Don't put a 4K texture on a pebble. We've seen it happen.
  prefs: []
  type: TYPE_NORMAL
- en: '`Stat rhi` is one of the most useful commands overall for getting a general
    sense of how well your scene is fitting within its budget.'
  prefs: []
  type: TYPE_NORMAL
- en: Stat memory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you need more information about what''s blowing your memory budget, you
    can use stat memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d76c5890-822a-441f-9c67-8ade3e67b798.png)'
  prefs: []
  type: TYPE_IMG
- en: Most of the time, if you're consuming too much memory, the culprit will be textures.
    Be on the lookout for textures that are too large for what they're being used
    for. A huge object or a hero character might warrant a 2048x2048 texture. Anything
    else should be 1024x1024 or smaller. A 4K texture is probably not reasonable under
    any circumstances in VR. As you consider where to cut your textures down, look
    at the object in scene. How big is it? How close can the player get to it? Is
    it something the player really cares about looking at? It's awfully easy to spend
    way too much on an object the player can barely see. Start to think in terms of
    spending your texture and polycount budgets where they matter, and economizing
    where you can get away with it.
  prefs: []
  type: TYPE_NORMAL
- en: Optimization view modes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to the stat commands, we also have a few optimization view modes
    that can be used to find problems in your scene. These are each accessed from
    the editor viewport's view mode menu. We're just going to talk about two of them
    here.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Shader Complexity view shows you where your materials may be slowing you
    down. When you find a suspect object, select it, and see what''s going on in its
    materials. Is your material too complicated or doing expensive math? Consider
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2e5b4544-4e4d-4bb0-87b6-e97ca675ea5a.png)'
  prefs: []
  type: TYPE_IMG
- en: In the case of the preceding screenshot, the grass and tree are registering
    as expensive materials. When we select their objects and look at those materials,
    we can see that what's driving up their cost is that they use their World Position
    Offset input to simulate wind. That's expensive, but it's a nice effect and the
    player would notice if we turned it off, so we can leave it alone since the rest
    of our scene is running pretty efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: Use this view to search for materials that may be costing you a lot without
    adding much value to the scene.
  prefs: []
  type: TYPE_NORMAL
- en: The Light Complexity view comes into play if you're using dynamic lights under
    the deferred shading model. Because we're using forward rendering and static lights
    here, it won't show us anything on this scene. When you are using dynamic lights
    and deferred shading, this view can show you where your lights are causing problems.
  prefs: []
  type: TYPE_NORMAL
- en: CPU profiling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you're having trouble with your CPU times, you can use CPU profiling to find
    out where the problems are, just as we did earlier with the GPU profiler.
  prefs: []
  type: TYPE_NORMAL
- en: To activate CPU profiling, while the game is running, open a console command
    and type stat startfile to begin profiling. Profiling generates a lot of data,
    so you don't want to run your profiler over an entire session – just capture things
    you're interested in, such as, *why does the game slow down so much when that
    character alerts to an enemy?*
  prefs: []
  type: TYPE_NORMAL
- en: After you've captured whatever you're looking for, type `stat stopfile` to turn
    profiling back off. The profiler will save the captured data to a `.ue4stats`
    file in your project's `\Saved\Profiling\UnrealStats\` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, open your Unreal Engine''s install directory, and, inside its `Binaries\Win64`
    folder, look for the `UnrealFrontend.exe` application. Launch it and use the tabs
    to select Session | Frontend | Profiler. Use the profiler''s Load button to open
    the `.ue4stats` file you just generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/79471103-c543-4e39-80c6-7eaf659f054e.png)'
  prefs: []
  type: TYPE_IMG
- en: The CPU Profiler shows you how much time each operation called during a frame
    takes.
  prefs: []
  type: TYPE_NORMAL
- en: Just as we did with the GPU profiler, you can use this tool to burrow through
    expensive-looking function calls and see what's going on. It would take us beyond
    the scope of this book to go deeply into using the CPU profiler here—it's an extremely
    useful and powerful tool, but it does take some time to learn how to get good
    information from it. We recommend that you explore the write-up on the topic to
    go further, which can be found at [https://www.unrealengine.com/en-US/blog/how-to-improve-game-thread-cpu-performance](https://www.unrealengine.com/en-US/blog/how-to-improve-game-thread-cpu-performance).
  prefs: []
  type: TYPE_NORMAL
- en: Turning things on and off
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As primitive as it may sound, one of the most effective ways to find out what's
    costing you frame rate is simply to turn features on and off with the relevant
    stat information displayed (usually, stat unit is what you want for this). Use
    the viewport's Show menu to turn individual elements on and off, especially if
    you've determined through your GPU profiling or your stat information that the
    thing in question might be causing a problem. It can also be helpful to start
    deleting objects from your level (as long as you have a backup or it's under source
    control), and see whether a particular object makes a big change.
  prefs: []
  type: TYPE_NORMAL
- en: Addressing frame rate problems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we've learned a bit about how to find problems in your scene, let's
    talk a bit about what to do about them.
  prefs: []
  type: TYPE_NORMAL
- en: Cleaning up Blueprint Tick events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you're seeing high numbers on your CPU, one of the first culprits you want
    to look for is any Blueprint doing operations on the Tick event. This is an extremely
    common culprit. Remember that Tick events happen every single frame, so if you're
    doing a lot of work on your Tick, you're impacting every single frame you need
    to draw. Look for ways to spread this work out over multiple frames, or to avoid
    using the Tick altogether and use events to make objects change their state only
    when something changes.
  prefs: []
  type: TYPE_NORMAL
- en: Managing skeletal animations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have a lot of skeletal meshes animating, make sure they don't have a
    ridiculous number of bones in their skeletons, and make sure they're not using
    a ton of blend space animations. It's a much better practice to use skeletal mesh **Level
    of Detail** (**LOD**) to include fine details only when the player can see them,
    or to use separate skeletal meshes for cinematics, where highly-detailed facial
    animations matter, and for in-game meshes, use skeletons with lower bone counts.
    For more information on setting up skeletal mesh LODs, begin by looking at [https://docs.unrealengine.com/en-US/Engine/Content/ImportingContent/ImportingSkeletalLODs](https://docs.unrealengine.com/en-US/Engine/Content/ImportingContent/ImportingSkeletalLODs).
  prefs: []
  type: TYPE_NORMAL
- en: Merging actors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is a big one. Remember a short while ago when we mentioned that draw call
    counts have a big impact on your frame rate? One of the cheapest and easiest ways
    to drop your draw call counts is to merge multiple meshes into a single mesh.
    This will not only create a single mesh out of the multiple individual meshes
    you've selected, but it will also create a combined material for that mesh out
    of each child mesh's materials. This is a big deal.
  prefs: []
  type: TYPE_NORMAL
- en: Let's say you have a bunch of debris in a corner of a room; maybe 25 objects
    or so, and each of them uses one material slot. You're looking at 50 draw calls
    right there, out of a total of maybe 2,000 that you have available for your entire
    scene. That's a big hit. By merging these into a single object, you can drop 50
    draw calls down to two. This is one of the fastest and most effective ways you
    can bring down your draw call count.
  prefs: []
  type: TYPE_NORMAL
- en: 'One caveat about this though: remember earlier in this book when we talked
    about Kent Beck''s advice to *make it work, make it right, make it fast*? This
    is one of those areas where that wisdom applies. Once you bake all these objects
    into a single object, you no longer have the freedom to rearrange the individual
    components, so get the scene looking the way you want it, and then merge your
    actors to bring things under control.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how to do it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Select Window | Developer Tools | Merge Actors. The Merge Actors window will
    appear. Select the actors you want to merge. In general, it''s a good idea to
    merge actors that are close together and likely to be in the same view. Once they''re
    merged, all of them will be drawn even if only one of them is on camera, so merge
    items that are all going to be on camera simultaneously most of the time:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/050ceecf-612a-4b08-a493-794364c8321a.png)'
  prefs: []
  type: TYPE_IMG
- en: The Merge Actors dialog seen with multiple selected actors in the viewport behind
    it
  prefs: []
  type: TYPE_NORMAL
- en: If you select Replace Source Actors, the actors you've selected in-scene will
    be replaced by the merged model. For more information about merging actors, begin
    with [https://docs.unrealengine.com/en-us/Engine/Actors/Merging](https://docs.unrealengine.com/en-us/Engine/Actors/Merging).
  prefs: []
  type: TYPE_NORMAL
- en: Using mesh LODs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The number of triangles you're drawing in a scene (usually called the **polycount**)
    is another huge factor in determining your scene's rendering speed.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, your first line of defense against high polycounts is in modeling.
    Use an application such as Pixologic's ZBrush to bake normal maps from a high-detail
    model, and apply them to a lower-detail mesh that you import into the game engine.
    Much of the time, your players will never notice the difference. VR is less forgiving
    of using normal maps to simulate geometric detail than the flat screen is, because
    players can sometimes see that the depth isn't real, but you should still make
    use of this technique anywhere you can get away with it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have a mesh in-game, however, you have a powerful LOD tool available
    to you to manage how many triangles you''re drawing. LODs work like this: they
    store several versions of the same model, with increasingly small polycounts.
    As the model gets smaller on screen, the system switches out the high-detail mesh
    for a lower-detail mesh, since the player won''t be able to see the detail anyway,
    now that it''s further away.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how to set up an LOD:'
  prefs: []
  type: TYPE_NORMAL
- en: Select a static mesh and open the Static Mesh editor from the content browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under its Details, look for the LOD Settings section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find the Number of LODs entry, and set it to a value greater than  1\. (For
    this test, just set it to 2 to create 2 LODs.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on Apply Changes. One or more additional LOD models will now be created
    and added to the static mesh asset.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under the LOD Picker section, find the LOD entry, and use it to select one of
    the new LODs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: LOD 0 is the original model. Most of the time you'll leave this unchanged. LOD
    1 is the first LOD after LOD 0.
  prefs: []
  type: TYPE_NORMAL
- en: With the new LOD, such as LOD 1, selected, open the Reduction Settings entry
    from its LOD detail section and modify it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You have a number of options available here, but most of the time, you''ll
    be managing the Percent Triangles value. If you make changes here, click on Apply
    Changes to see the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6a7ebedb-cecd-4c70-af01-6fdb195e3d3e.png)'
  prefs: []
  type: TYPE_IMG
- en: You'll see the modified mesh in your viewport. To see what it will look like
    at the real view distance, switch your LOD Picker back to LOD Auto and move your
    view around to see how the object changes as it switches between LODs. The LOD
    generator is surprisingly good.
  prefs: []
  type: TYPE_NORMAL
- en: For more information about creating and using LODs, start by looking at [https://docs.unrealengine.com/en-us/Engine/Content/Types/StaticMeshes/HowTo/LODs](https://docs.unrealengine.com/en-us/Engine/Content/Types/StaticMeshes/HowTo/LODs).
  prefs: []
  type: TYPE_NORMAL
- en: Static mesh instancing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Remember those draw calls we were so concerned about a moment ago? There's another
    powerful way to reduce their count and dramatically speed up your rendering.
  prefs: []
  type: TYPE_NORMAL
- en: Say you have a big collection of mostly the same assets, such as a forest that
    reuses the same tree mesh hundreds of times. If you simply place those meshes
    in the environment individually, every single one of them is going to generate
    a minimum of two draw calls, and even more if it uses more materials. That's a
    recipe for a slide show. What you want to do instead is **instance** this geometry.
    Instancing is a way of telling your GPU that, even though it's about to draw a
    few hundred meshes, they're really all just the same mesh with different transforms.
    So, instead of making a separate draw call for each tree, the system makes one
    set of draw calls and gives the video hardware a list of locations, orientations,
    and scales at which to draw them. This is wildly faster than passing each item
    as a separate item.
  prefs: []
  type: TYPE_NORMAL
- en: By default in Unreal, the easiest way to instance objects is to use the foliage
    tool. While it's most commonly used for foliage, as the name suggests, you can
    also use it for repeated objects in lots of other contexts, like streetlamps on
    city streets. You can find more information on foliage instancing at [https://docs.unrealengine.com/en-us/Engine/Foliage](https://docs.unrealengine.com/en-us/Engine/Foliage).
  prefs: []
  type: TYPE_NORMAL
- en: Instancing static meshes outside the foliage tool is a bit more of a complex
    topic, but it can be done and can be a good idea if you're procedurally generating
    an actor that contains a large array of individual static meshes. Most of the
    time, however, when you're instancing objects in scenes, use the foliage tool
    to do it.
  prefs: []
  type: TYPE_NORMAL
- en: Nativizing Blueprints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Blueprints are already interpreted amazingly fast, but they can be made even
    faster by translating them automatically into C++ and then allowing the system
    to compile them.
  prefs: []
  type: TYPE_NORMAL
- en: To turn this on, open Project Settings | Project | Packaging | Blueprints, and
    use the Blueprint Nativization Method selector to select **inclusive** or **exclusive** nativization.
  prefs: []
  type: TYPE_NORMAL
- en: '**Inclusive** nativization will convert all your Blueprints to C++ when they
    compile.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Exclusive** nativization will convert only those Blueprints for which you
    set the nativize flag.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you''re using exclusive nativization, select the Blueprints you want to
    nativize by opening their Class Settings, and turn on the Nativize option in their Details
    | Packaging panel. Again, you don''t need to do this if you''re using inclusive
    nativization. In that case, every Blueprint is nativized:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ff134984-41b9-4db7-a36c-3ae3e9514914.png)'
  prefs: []
  type: TYPE_IMG
- en: If you're planning to ship your application on desktop VR, inclusive nativization
    may be fine, but if you're planning to deploy to mobile VR, such as the Oculus
    Go or Quest, it's probably smarter to use exclusive nativization to choose which
    Blueprints you want to nativize, since including them all can increase your executable
    size.
  prefs: []
  type: TYPE_NORMAL
- en: This is a bit of an advanced topic. In general, you'll see a benefit if you
    nativize Blueprints that do a lot of work on the Tick event, or that just do a
    lot of work in general. If your Blueprints are fairly simple, you won't really
    see a difference either way. Because speed is so critical to VR development, it's
    good to know that this option is available to you.
  prefs: []
  type: TYPE_NORMAL
- en: If you do plan to do this, turn nativization on early in your project's development,
    and test on cooked builds frequently. Nativization is extremely good, but it can
    sometimes still cause unexpected side effects.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned quite a lot about how to use Unreal's VR Mode editor
    to compose environments from within VR, and we learned how to analyze and optimize
    scenes to see where our performance bottlenecks are.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we're going to take a detour from building real-time 3D
    worlds in VR and look at another common application – movies and immersive photography.
  prefs: []
  type: TYPE_NORMAL
