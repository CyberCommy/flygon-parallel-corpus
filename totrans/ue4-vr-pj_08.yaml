- en: Building the World and Optimizing for VR
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建世界并针对VR进行优化
- en: Through the course of our work so far in this book, we've been focused for the
    most part on the player avatar. This makes sense—virtual reality dramatically
    changes the way the player engages with the world. We needed to learn new ways
    of enabling the player to get around, new ways of using their hands to interact
    with the world, and new ways of constructing user interfaces.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书迄今为止的工作过程中，我们大部分时间都专注于玩家角色。这是有道理的-虚拟现实极大地改变了玩家与世界互动的方式。我们需要学习新的方法来让玩家四处移动，使用手来与世界互动，以及构建用户界面的新方法。
- en: This is no small achievement, so congratulations for getting this far!
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一项不小的成就，所以恭喜你走到了这一步！
- en: Now, we're going to shift our focus a bit and begin to look at the environment
    around us. Up to this point, we've been using existing environments, but now it's
    time to begin to build our own. As we do this, we are going to learn that environments
    in VR present challenges that we're going to need to address. Lighting, object
    scale, and sightlines all come into play to a greater degree than they do on the
    flat screen, and performance is a major consideration.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们要稍微改变一下焦点，开始关注我们周围的环境。到目前为止，我们一直在使用现有的环境，但现在是时候开始建立我们自己的环境了。在这个过程中，我们将会发现VR环境带来了一些需要解决的挑战。光照、物体比例和视线都比平面屏幕更重要，并且性能是一个重要考虑因素。
- en: In this chapter, we're going to learn how to use the tools and techniques at
    our disposal to address these challenges as we build. We'll learn how to use the
    VR editor to lay out our environment from within the headset and see how it's
    actually going to appear in VR as we build it, and we'll learn how to profile
    and optimize these environments to make sure that we can meet our frame rate requirements.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何利用我们手头的工具和技术来解决这些挑战。我们将学习如何使用VR编辑器在头戴式显示器中布置环境，并在构建过程中实际查看其在VR中的外观，还将学习如何对这些环境进行性能分析和优化，以确保我们能够满足帧率要求。
- en: 'In this chapter, we''re going to explore the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下主题：
- en: Building and lighting a scene using the VR editor
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用VR编辑器构建和照明场景
- en: Profiling the scene to identify performance bottlenecks
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对场景进行性能分析以识别瓶颈
- en: Optimizing the scene using static mesh instancing, LODs, mesh combination, and
    lighting changes
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用静态网格实例化、LOD、网格组合和光照更改来优化场景
- en: Project settings for optimization
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化的项目设置
- en: Special considerations and technical requirements for mobile VR
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移动VR的特殊考虑和技术要求
- en: Let's get to it and give ourselves a place to play.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧，给自己一个玩耍的地方。
- en: Setting up the project and collecting assets
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置项目并收集资产
- en: 'For this chapter''s work, let''s create a new project with the following template
    options:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章的工作，让我们使用以下模板选项创建一个新项目：
- en: A Blank Blueprint template
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个空白的蓝图模板
- en: Targeting Mobile/Tablet hardware
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 针对移动/平板硬件进行优化
- en: Scalable 2D or 3D
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可扩展的2D或3D
- en: No starter content
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有起始内容
- en: 'Once the project has been created, open its Project Settings and set the following menu
    options:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 创建项目后，打开其项目设置并设置以下菜单选项：
- en: Project | Description | Settings | Start in VR: True
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目 | 描述 | 设置 | 在VR中启动：True
- en: Engine | Rendering | Forward Renderer | Forward Shading: True
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引擎 | 渲染 | 正向渲染器 | 正向着色：True
- en: Engine | Rendering | Default Settings | Ambient Occlusion Static Fraction: False
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引擎 | 渲染 | 默认设置 | 环境遮蔽静态分数：False
- en: Engine | Rendering | Default Settings | Anti-Aliasing Method: MSAA
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引擎 | 渲染 | 默认设置 | 抗锯齿方法：MSAA
- en: Engine | Rendering | VR | Instanced Stereo: True
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引擎 | 渲染 | VR | 实例化立体声：True
- en: Engine | Rendering | VR | Round Robin Occlusion Queries: True
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引擎 | 渲染 | VR | 循环轮询遮挡查询：True
- en: Allow the project to restart once all these settings have been set.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置完所有这些设置后，允许项目重新启动。
- en: Once the project has restarted, open the File menu and use it to load the previous
    chapter's project. Just as we did last time, we're going to grab elements that
    we previously created and carry them forward using the Migrate tool.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 项目重新启动后，打开文件菜单并使用它加载上一章的项目。就像上次一样，我们将使用迁移工具获取之前创建的元素并将它们带入新项目中。
- en: Migrating blueprints into the new project
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将蓝图迁移到新项目中
- en: From your previous project, select BP_VRGameMode from the content explorer,
    right-click it, and select Asset Actions | Migrate. Select your new project's
    `Content` directory as its destination content folder. Because the GameMode references
    BP_VRPawn, and BP_VRPawn references BP_CompanionCharacter, all of these objects
    and their required supporting assets should come across.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 从之前的项目中，选择内容资源管理器中的BP_VRGameMode，右键点击它，选择资源操作 | 迁移。将你的新项目的`Content`目录作为目标内容文件夹。因为GameMode引用了BP_VRPawn，而BP_VRPawn引用了BP_CompanionCharacter，所有这些对象及其所需的支持资产都应该被迁移过来。
- en: Once the migration is complete, there's one more thing we need to do. We have
    a few custom inputs set up for our previous project, and we'll need them for our
    new one as well. Navigate to last chapter's project directory and copy the `Config/DefaultInput.ini`
    file to your new project's config directory.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 迁移完成后，还有一件事情需要做。我们在之前的项目中设置了一些自定义输入，我们在新项目中也需要它们。导航到上一章的项目目录，并将`Config/DefaultInput.ini`文件复制到新项目的配置目录中。
- en: Verifying the migrated content
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证迁移的内容
- en: 'Re-open the new project. The first thing we''re going to want to do here is
    verify that everything we''ve brought across is working correctly:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 重新打开新项目。这里我们要做的第一件事是验证我们带入的所有内容是否正常工作：
- en: Let's select File | New Level | VR Basic to create a starting VR map.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择文件 | 新建关卡 | VR基础，创建一个起始的VR地图。
- en: Drop a Nav Mesh Bounds Volume onto the map and make sure it surrounds the floor.
    Setting its Location to (X=0.0, Y=0.0, Z=0.0) and Scale to (X=10.0, Y=10.0, Z=2.0)
    will take care of this. Remember to hit the *P* key to visualize your navmesh
    and make sure it's generating properly.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个导航网格边界体放置在地图上，并确保它围绕着地板。将其位置设置为(X=0.0，Y=0.0，Z=0.0)，将其缩放设置为(X=10.0，Y=10.0，Z=2.0)即可。记得按下“P”键来可视化你的导航网格，并确保它正常生成。
- en: Save this level (we named ours VRModePractice and placed it in `Content/C07/Maps`).
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存这个关卡（我们将其命名为VRModePractice，并放置在`Content/C07/Maps`中）。
- en: Open Settings | Project Settings | Maps & Modes | Default Modes, and set your
    Default GameMode to the BP_VRGameMode we migrated from the other project. Set
    your Editor Startup Map and Game Default Map to this map, as well.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开设置|项目设置|地图和模式|默认模式，并将默认游戏模式设置为我们从其他项目迁移的BP_VRGameMode。将编辑器启动地图和游戏默认地图也设置为这个地图。
- en: Drop an instance of BP_CompanionCharacter anywhere onto the level.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在关卡上放置一个BP_CompanionCharacter的实例。
- en: 'Test the map in a VR preview. You should be able to move and teleport, and
    your companion character should follow you:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在VR预览中测试地图。你应该能够移动和传送，你的伴侣角色应该跟随你：
- en: '![](img/fc9c3181-0e37-4c0e-941c-dce2a397c9fb.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fc9c3181-0e37-4c0e-941c-dce2a397c9fb.png)'
- en: This map is a great map to use for learning the Unreal Editor's VR Mode—it's
    easy to get around, and gives us lots of pieces we can manipulate as we practice
    with the interface. Let's take advantage of this.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这张地图非常适合用于学习虚幻编辑器的VR模式-它易于操作，并且提供了许多我们可以在界面上练习时操作的部件。让我们充分利用它。
- en: Using the VR editor
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用VR编辑器
- en: Unreal Engine comes equipped with a very capable virtual reality editor that
    allows you to build your scenes entirely from within the virtual environment.
    Nearly any editor operation you might need to perform can be done without leaving
    VR.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 虚幻引擎配备了一个非常强大的虚拟现实编辑器，可以让你完全在虚拟环境中构建场景。几乎任何你可能需要执行的编辑操作都可以在不离开VR的情况下完成。
- en: 'It may be tempting, though, to look at the VR Mode editor as a gimmick when
    you first encounter it. After all, what''s wrong with the existing editor? Nothing,
    but here''s the thing: virtual reality isn''t a flat screen. Depth exists. Sightlines
    are different. Colors render differently. Developing for virtual reality by using
    a flat screen adds a layer of abstraction to your design process. You''ll understand
    more and get better results by working directly in your target medium when you
    can.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当你第一次遇到VR模式编辑器时，可能会认为它只是一个花招。毕竟，现有的编辑器有什么问题呢？没有问题，但是这里有一点需要注意：虚拟现实不是一个平面屏幕。深度是存在的。视线是不同的。颜色的渲染也不同。通过使用平面屏幕进行虚拟现实开发会给你的设计过程增加一层抽象。当你能够直接在目标媒介中工作时，你会更加了解并获得更好的结果。
- en: In practice, you're likely to find both editing modes useful. Just as it's difficult
    to see what a scene is really going to look like in VR from the flat-screen editor
    view, it's difficult to achieve precision in placing objects in VR Mode. You'll
    discover your workflow as you get comfortable with the tools, and you'll discover
    which operations you prefer to do in which domains. The point here, though, is
    that it's worthwhile to think of VR Mode as an important part of your scene layout
    workflow for VR. Take the time to get comfortable with it so you can rely on it
    when it's warranted.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，你可能会发现两种编辑模式都很有用。就像在平面屏幕编辑器视图中很难看清楚一个场景在VR中的真实样子一样，在VR模式下放置物体时很难达到精确。当你熟悉工具时，你会发现自己的工作流程，并发现你更喜欢在哪个领域进行哪些操作。然而，这里的重点是，将VR模式视为VR场景布局工作流程的重要组成部分是值得的。花时间熟悉它，这样当需要时就可以依赖它。
- en: A good practice for VR editing is to do your initial block-out in VR. Place
    objects in ways that evoke the sense of space you want to convey, and then go
    to traditional flat-screen editing to refine your layout and populate it further.
    Finally, return to VR editing for your final refinements so you can see exactly
    what you're going to get.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: VR编辑的一个好的实践是在VR中进行初始的块状布局。以一种能够传达你想要表达的空间感的方式放置物体，然后转到传统的平面编辑来进一步完善你的布局并填充它。最后，返回到VR编辑中进行最后的调整，这样你就可以清楚地看到你将要得到的结果。
- en: Let's activate the VR editor and see what we can do with it. Since you won't
    be able to read this book while you're inside the headset, we'll go over a few
    basic principles, allow you to try them out, and then return here to explore a
    few more.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们激活VR编辑器，看看我们可以用它做些什么。由于你在戴头盔时无法阅读这本书，我们将介绍一些基本原则，让你尝试一下，然后再回到这里探索更多内容。
- en: The first thing to know is how to enter and exit the VR editor.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要知道的是如何进入和退出VR编辑器。
- en: Entering and exiting VR Mode
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进入和退出VR模式
- en: 'You can activate the VR editor by using the VR Mode toolbar button. To exit
    VR Mode, activate the radial menu (more on this later) and select System | Exit.
    It''s easiest, though, to get used to using *Alt* + *V* to enter and exit VR Mode:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用VR模式工具栏按钮来激活VR编辑器。要退出VR模式，请激活径向菜单（稍后会详细介绍）并选择“系统|退出”。不过，最简单的方法是习惯使用*Alt*
    + *V*来进入和退出VR模式：
- en: '![](img/f2ae6c39-2220-4e8a-9a50-b632e84f25e1.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f2ae6c39-2220-4e8a-9a50-b632e84f25e1.png)'
- en: It's also possible to configure VR Mode to enter automatically when the headset
    is put on while the editor is running. To do this, select Edit | Editor Preferences
    | General | VR Mode, and set Enable VR Mode Auto-Entry to True. Whether you'd
    like to do this is your choice, but, in practice, it tends to have a difficult
    time figuring out when to turn itself back off, so using *Alt* + *V* to enter
    and exit is usually a better idea.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以将VR模式配置为在编辑器运行时自动进入头戴式显示器时自动进入。要做到这一点，选择“编辑|编辑器首选项|常规|VR模式”，并将“启用VR模式自动进入”设置为True。是否这样做取决于你的选择，但是在实践中，它往往很难确定何时关闭自身，因此使用*Alt*
    + *V*进入和退出通常是一个更好的主意。
- en: 'If you prefer to interact primarily using your left hand, you have the option
    here in the VR Mode preferences to switch your Interactor Hand:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更喜欢使用左手进行交互，你可以在VR模式首选项中选择此选项：
- en: '![](img/a392086e-d933-429b-a2c3-4f1bf5fc4f12.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a392086e-d933-429b-a2c3-4f1bf5fc4f12.png)'
- en: VR Mode settings are found under Edit | Editor Preferences | General | VR Mode.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: VR模式的设置可以在“编辑”|“编辑器首选项”|“常规”|“VR模式”下找到。
- en: Set either of these options if you'd like. We're going to leave the rest of
    these at their defaults for our work here.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意，可以设置其中任何一个选项。我们将保留这些选项的默认设置。
- en: The other thing we're going to need to address is how to move and look around.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要解决的另一件事是如何移动和观察周围。
- en: Navigating in VR Mode
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在VR模式下导航
- en: You activate movement mode in the VR editor by squeezing the grip buttons. When
    movement mode activates, the movement grid will appear and the interaction beam
    will turn green.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在VR编辑器中，通过挤压握持按钮来激活移动模式。当移动模式激活时，移动网格将出现，交互光束将变为绿色。
- en: The interaction beam in the VR editor changes colors to indicate what mode it's
    in. Red indicates standard interaction mode, green indicates movement mode, yellow
    indicates that you currently have an actor selected, and blue indicates that you're
    in UI interaction mode.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: VR编辑器中的交互光束会改变颜色以指示其所处的模式。红色表示标准交互模式，绿色表示移动模式，黄色表示你当前选择了一个角色，蓝色表示你处于UI交互模式。
- en: The metaphor for movement in the VR editor is **pushing** and **pulling** the
    world. It's fairly intuitive. In most instances, the world will move in the way
    your hand is moving while your movement mode is active.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在VR编辑器中，移动的隐喻是**推动**和**拉动**世界。这是相当直观的。在大多数情况下，当你的移动模式处于活动状态时，世界会按照你的手的移动方式移动。
- en: Moving through the world
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在世界中移动
- en: 'If you move the controller while holding the grip, the world moves as though
    you''re pulling it, or swimming through it:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在握持按钮的同时移动控制器，世界会移动，就像你在拉动它，或者在其中游泳一样：
- en: '![](img/f2dc78f9-a553-4565-8de0-6e296858c517.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f2dc78f9-a553-4565-8de0-6e296858c517.png)'
- en: If you release the grip while moving the controller, the movement continues
    for a bit, as though you'd pushed off of an object and were now floating away
    from it. This takes a bit of practice, but it becomes fairly intuitive once you
    get the hang of it. Squeezing the grip again stops your movement.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在移动控制器时松开握持按钮，移动会继续一段时间，就像你从一个物体上推开并且现在漂离它一样。这需要一些练习，但一旦你掌握了它，它就会变得相当直观。再次挤压握持按钮会停止你的移动。
- en: The movement grid displays the location of the floor in your real-world tracking
    volume. Align it with the floor in your scene to see what objects will really
    look like from the perspective of someone standing on the floor.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 移动网格显示了你真实世界跟踪体积中地板的位置。将其与场景中的地板对齐，以查看从站在地板上的人的视角看物体的真实样子。
- en: Teleporting through the world
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过世界传送
- en: 'To teleport through the world, squeeze the grip button on your dominant hand''s
    controller and squeeze the trigger. Aim the controller at an object or destination,
    and you''ll teleport there on release:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过世界传送，挤压你主手控制器上的握持按钮并按下扳机。将控制器对准一个物体或目的地，释放时你将传送到那里：
- en: '![](img/8b12e78c-502a-4277-b5a6-c0cf29469f4c.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8b12e78c-502a-4277-b5a6-c0cf29469f4c.png)'
- en: Using a combination of teleport and drag moves, you can get around the world
    pretty well.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 通过传送和拖动的组合，你可以很好地在世界中移动。
- en: Rotating the world
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 旋转世界
- en: 'When you need to rotate your viewpoint, hold both controllers'' grips and rotate
    the controllers around each other as though you were trying to spin the world:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要旋转视角时，握住两个手柄的握持按钮，将手柄彼此旋转，就像你试图旋转世界一样：
- en: '![](img/6670d6e8-9842-40d5-8e06-93375f97a53f.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6670d6e8-9842-40d5-8e06-93375f97a53f.png)'
- en: The number you see over the rotation axis is the world's current scale. We can
    manipulate that too.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你在旋转轴上看到的数字是世界当前的比例。我们也可以操纵它。
- en: Scaling the world
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缩放世界
- en: 'To scale the world, squeeze the grips and move the controllers toward each
    other to shrink the world, or away from each other to expand it:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 要缩放世界，挤压握持按钮并将控制器向彼此移动以缩小世界，或将其远离彼此以扩大世界：
- en: '![](img/f9f14b1e-e254-4ebe-8ede-68b9a207c0ba.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f9f14b1e-e254-4ebe-8ede-68b9a207c0ba.png)'
- en: It's weirdly satisfying to shrink your scene down until it looks like miniatures
    on a table.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 将场景缩小到看起来像桌子上的微型场景真是一种奇妙的满足感。
- en: Moving the controllers toward each other shrinks the world. Moving them away
    from each other grows the world. This can be useful for layout, as you can assemble
    the world in miniature, then teleport back to the ground and restore its normal
    scale to see what you've made.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 将控制器彼此靠近会缩小世界。将它们远离彼此会扩大世界。这对于布局很有用，因为你可以将世界组装成微型，然后传送回地面并恢复其正常比例，以查看你所做的事情。
- en: One of the fastest ways to get around the world in VR Mode is to shrink the
    world, then use the teleport action (grip + trigger) to teleport to a new location
    on your map. The world will return to its default size when you teleport.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在VR模式下，最快的方法之一是缩小世界，然后使用传送动作（握住+扳机）在地图上传送到新的位置。当你传送时，世界会恢复到默认大小。
- en: Practicing movement
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习移动
- en: Take some time now to practice navigating through the world using your controllers.
    Use *Alt* + *V* to enter VR Mode, and hit *Alt* + *V* again when you want to exit.
    Use the grip buttons to move through the world, teleport, rotate, and change its
    scale. Play with it until it feels natural. There's a bit of subtlety to getting
    this, but it's a very useful tool once you've made yourself comfortable.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在花点时间用你的控制器练习在世界中导航。使用*Alt* + *V*进入VR模式，当你想退出时再次按下*Alt* + *V*。使用握持按钮在世界中移动、传送、旋转和改变其比例。玩弄它直到感觉自然。这需要一些细微的技巧，但一旦你熟悉了，它就是一个非常有用的工具。
- en: Modifying the world in VR Mode
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改VR模式下的世界
- en: Now that you've practiced moving around the world a bit, let's start to learn
    some of the skills we'll need to do scene composition in VR.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经练习了一下在世界中移动，让我们开始学习一些在VR中进行场景构图所需的技巧。
- en: Moving, rotating, and scaling objects
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移动、旋转和缩放对象
- en: 'To select an object, just point at it and pull the trigger. Your interaction
    beam will turn yellow to indicate that you''ve entered selection mode. A gizmo
    will appear that allows you to move the object. By default, this will be a translate
    gizmo, which allows you to move the selected object around (we''ll see in a moment
    how to switch to other types of gizmo):'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/80c407e4-b9b3-4693-bf34-7108cdaaa4c5.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
- en: If you'd like to move the selected object, release the trigger and then pull
    it again while pointing at the object or at the transform gizmo. You can use the
    transform gizmo's arrows and planes to constrain your movement, or interact directly
    with the object to move it freely. When moving an object directly with the interaction
    beam, you can use the trackpad to move it closer or further from you.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: Be aware that hidden objects with collision can sometimes interfere with selection
    in VR Mode. If your selection beam appears to pass through the object you want
    to select, move to a different vantage point to select it.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: Usually it's a better idea to use the gizmo to move an object, as it's fairly
    difficult to move objects in depth with any precision.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: 'The default transform gizmo can be switched to other modes using the radial
    menu interface. To activate the radial menu, touch the trackpad or thumbstick
    on your non-interactor hand and point at the menu option you''d like to select.
    Use the trigger to select it. Your controller''s menu button takes you back out
    of sub-menus, or closes the radial menu if you''re already at the top menu:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dab60762-c626-49ee-97e7-5d65f28008b3.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
- en: 'Selecting the Gizmo submenu allows you to switch between transform gizmo options:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/155452c0-31cd-40fa-a1d4-61ddd45c5fbf.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
- en: The Universal gizmo provides translation, rotation, and scale handles on a single
    gizmo. The Translate, Rotate, and Scale gizmos provide individual tools for those
    operations. Switching the transform mode to Local Space rotates, scales, and moves
    the object along its own axes, while the World Space mode transforms the object
    along the world axes.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: Using both controllers to rotate and scale objects
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You also may have noticed that, whenever you have an object selected and you''re
    holding the trigger over the object itself (rather than a gizmo handle), a second
    interaction beam appears on your off-hand controller. If you aim that second interaction
    beam at the object and squeeze the trigger, you can use them both to tumble and
    stretch the object:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b2e8f473-afa4-4b7c-a554-b2fc53f4fd6a.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
- en: This is a great tool for exploring improvising rough layouts. It's intuitive
    and invites natural interaction with objects in your environment. This is a good
    tool to use for exploring and improvising layouts. You'll probably have a tough
    time getting things exactly where you want them, but if you use this tool for
    rough layouts and then clean them up in the flat-screen editor, you can achieve
    good results.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: Practicing moving objects
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Try it out now. Hit *Alt* + *V* to enter VR Mode, and, in addition to practicing
    moving around the world, practice using the transform gizmos and free movement
    to move objects around the world. Remember to use the radial menu to change movement
    modes, and use the Menu button to get back out to the Home menu. Take some time
    to practice this. The controls will probably feel unfamiliar at first, but once
    you get the hang of them, world-building in VR is a rewarding experience.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: When you're done, hit *Alt* + *V* to exit VR Mode again, and, if you'd like,
    clean up your object alignments in flat-screen editing.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: Now we're ready to begin composing a scene, and to do this, we'll be using the
    VR Mode menus.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: Composing a new scene in VR Mode
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we''ve learned the basics of operating the VR Mode editor, let''s
    go deeper and really see how we can use this as a scene composition tool. First,
    we''re going to need some assets to work with. The free Infinity Blade: Grass
    Lands package will give us something to play with.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: 'Open your Epic Games Launcher (it''s fine to leave your existing project open
    as you do this), navigate to the Unreal Engine | Marketplace | Free tab, and search
    for Infinity Blade: Grass Lands. Hit Add to Project and select your new project
    as the target project:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/de76f21f-15b8-4547-aea8-0b70bc57d246.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
- en: Once the assets have finished downloading and installing, let's force the new
    shaders to compile. Open up `Content/InfinityBladeGrassLands/Maps/Overview`, and
    let the shaders compile. While these shaders are compiling, feel free to enter
    VR Mode using *Alt* + *V* and navigate around the overview map to see what assets
    we have available to us.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: After you've built your shaders, we can do some work composing a scene using
    these assets. For this exercise, we're going to start with an existing map and
    modify it.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: First, we'll need to learn how to navigate the editor menus in VR.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: Navigating the radial menu
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Menu interaction in the VR editor, is for the most part, handled by a series
    of radial menus attached to the controller. In practice, these are fairly intuitive
    to use, as they map clearly to the touchpad or thumbstick inputs on the hand controllers.
    Let''s look at how they work:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Select `Content/InfinityBladeGrassLands/Maps/ElvenRuins` and open it.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you'd like, you can also change your Project Settings | Maps & Modes | Default
    Maps to open this map automatically.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use *Alt* + *V* to enter VR Mode, and, while you're in this mode, touch the
    left trackpad or thumbstick to activate the radial menu.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To enter a menu, aim the interaction beam at it and squeeze the trigger or use
    the menu hand's trackpad to select options.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To back out of the submenus, use the non-dominant hand''s menu button:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d0ebaa31-c31e-4b5a-af82-d439d01952b0.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
- en: You can use the interaction beam or the menu hand's trackpad to navigate menus
    in VR Mode
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Let's get into VR Mode and explore the menus. You have eight major menu categories
    available from the Home menu.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: Gizmo
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've already explored the Gizmo menu, so we won't dive back into detail here.
    Remember that it's used to switch between behaviors of your in-editor movement
    tools.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: Snapping
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Snapping menu is a close partner to the Gizmo menu. Most of these behave
    as you''re used to in the flat-screen editor, but the Smart Snapping option is
    especially worth knowing about:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0d9a5d14-bdee-44c3-b3f7-0d9b4a6d0ab6.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
- en: With Smart Snapping active, objects you move in-scene will attempt to align
    themselves to other objects as you move them. Since precise placement can be challenging
    to achieve in VR Mode, this is a big help.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Use the Set Targets option to select a specific object you'd like other objects
    to snap to, and use the Reset Targets option to clear it.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: Windows
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Windows submenu provides access to the individual palettes and menus you''ll
    be using as you compose your scene:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/08e0c5ff-bf84-4ffe-b5f7-6106e96a719d.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
- en: 'Each button opens its associated panel. These are the same panels you''re used
    to from the flat-screen editor:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1c3a8eb8-99ed-4ec7-b102-ad48fb8b989e.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
- en: The Content Browser as seen in the editor's VR Mode
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: 'To move a window, aim the interaction beam at the large bar beneath it. You
    can place and angle it any way you want. The downward-facing arrow to the left
    of the move bar pins the window in place. When it''s activated, the window will
    stay where you place it, regardless of how you move through the world. When it''s
    un pinned, the window will move with you when you move. The X-shaped button to
    the right of the bar closes the window:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/356e00a5-a2bb-40f3-b05e-b134d6f70583.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
- en: You can move your active windows around to create a virtual workspace from which
    to work
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: These windows work just as they do in the flat-screen editor. An effective practice
    in using them is to open only the windows that you need, and arrange them around
    yourself in a virtual workspace for the task you're doing.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: In practice, much of the time, you'll find it useful to leave your content browser
    open to your side along with the details pane.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Edit
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Edit menu allows you to duplicate, delete, and snap objects in your scene:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4488086f-c2ca-40b5-b0c8-61c05d031518.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
- en: Most of these options should be pretty self-explanatory and what you'd expect
    an edit menu to contain. Snap to Floor is a bit of an outlier, so it's worth remembering
    that it's in here. You'll use it often.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: Tools
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Tools menu is primarily geared toward managing simulations in the editor.
    Here, you can start, pause, and resume simulations, and save their results back
    to the editor:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5892c6f2-95f1-45d8-8bee-99f8bff1de4e.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
- en: Two options that aren't related to simulations are also contained here. The
    Screenshot tool snaps a standard-resolution screenshot, but be aware that the
    screenshot will include the menu, so move it out of sight if you want a clean
    shot. The Flashlight tool is useful for finding your way around dark scenes, especially
    if you're midway through composing your scene lighting.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Modes
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Modes panel allows you to place actors such as lights, volumes, and primitives;
    manage foliage; enter landscape sculpting mode; and paint textures and vertex
    colors, just as it does in the flat-screen editor:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/64bd219b-1806-4c61-bd7c-c849fa96e31f.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
- en: Selecting one of these options will bring up a Modes panel that can then be
    placed in the world and used in the same way as the other panels available from
    the Windows menu.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: Actions and System
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At present, the System menu just gives you a way to exit VR Mode. At the time
    of writing, it doesn't do anything else. The Actions menu's behavior varies depending
    on context.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Making changes to our scene
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we've learned how to get around in VR Mode, let's put some of this
    learning into practice. We're going to modify the Elven Ruins map from within
    VR Mode.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we're going to do is change the time of day. Let's see how these
    ruins would look at dawn.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: Use *Alt* + *V* to enter VR Mode and touch your non-interaction hand's trackpad
    or thumbstick to bring up the radial menu. Use the menu button to navigate back
    up to home if you're currently in a submenu. Select the Windows menu and, from
    there, activate the World Outliner.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Use the interaction beam to drag the movement box at the base of the menu. Put
    it to your side and a bit below you.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re going to look for the directional light that''s acting as our sun in
    this scene. To find it, click the Type column''s header to sort your actor list
    by type, and then use the trackpad to scroll through the list and find the Directional
    Light named Light Source:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/140918b5-9f61-407c-9946-f1c8c0a90074.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
- en: Unfortunately, you don't have an easy way to enter text in VR Mode. The radial
    menu offers a number pad that you can use when setting values, but if you wanted
    to search for light, you'd have to type it using a conventional keyboard. Sorting,
    scrolling, and selecting works pretty well for this sort of work.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you''ve selected the directional light, use the radial menu to activate
    the Details panel. Use the bar beneath it to drag it to a location where you can
    read it and interact with it, but can still see the sky:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f3da5d9f-2324-46c8-b3c8-f9ef685ac4a7.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
- en: In this shot taken from within the VR headset, you can see how we've been able
    to create a virtual workspace by manipulating the panels in 3D space.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: Point the interaction beam at the light's Rotation Y value and drag it back
    and forth over the box to change its value. You'll see the sun changing overhead.
    It starts out at around -48\. Drag it to around 210 (or wherever you like, really)
    to create some nice dramatic shadows.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, select BP_SkySphere. From its Details panel, turn on Colors Determined
    by Sun Position, and check the Refresh Material checkbox to change the sky''s
    color:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e22807ac-9bb1-4709-8745-a18250d6ae31.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
- en: That's kind of nice, right? Lighting changes like this are often best made inside
    the VR Mode editor, as light and colors render very differently in the headset
    than they do on the flat screen.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这样很好，对吧？像这样的光照变化通常最好在VR模式编辑器中进行，因为头戴式显示器中的光照和颜色与平面屏幕上的显示非常不同。
- en: 'Building new elements in your map is generally best done in the flat-screen
    editor. VR Mode is excellent for checking sightlines and adjusting object positions,
    but, in practice, it still suffers from some growing pains that can make object
    selection difficult:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 通常最好在平面屏幕编辑器中构建地图中的新元素。VR模式非常适合检查视线和调整物体位置，但在实践中，它仍然存在一些问题，这可能会使物体选择变得困难：
- en: '![](img/c765d94a-f495-4905-81c7-2f95b9da01af.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c765d94a-f495-4905-81c7-2f95b9da01af.png)'
- en: 'Here are a few effective ways to work within VR Mode, benefit from its strengths,
    and work around its weaknesses:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在VR模式下工作的几种有效方法，以发挥其优势并解决其弱点：
- en: Get around by scaling the world down, then use teleport to land where you want
    to go
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过缩小世界规模来移动，然后使用传送来到达目的地
- en: Do rough lighting adjustments inside VR Mode where you can see what their effects
    on the world will really be
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在VR模式中进行粗略的光照调整，以便您可以看到它们对世界的真实影响
- en: Build geometry in the traditional editor, but use VR Mode to experiment with
    its placement
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在传统编辑器中构建几何体，但使用VR模式来尝试其位置
- en: Get into the habit of using *Alt* + *V* frequently to check your environment
    in VR as you build it. You'll get a sense of which adjustments make sense to do
    in VR Mode and which work best in the traditional editor.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 养成经常使用*Alt* + *V*来在VR中检查环境的习惯，以便在构建时了解哪些调整在VR模式下是有意义的，哪些在传统编辑器中效果最好。
- en: Most importantly, what we wanted to communicate in this section is that VR Mode,
    far from being a luxury or a gimmick, should be considered an essential tool for
    your scene construction workflow in VR.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的是，我们在本节中想要传达的是，VR模式绝非奢侈品或花招，而应被视为VR场景构建工作流程中的必备工具。
- en: Optimizing scenes for VR
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为VR优化场景
- en: Now that we've spoken a fair bit about editing scenes using VR Mode, let's talk
    about an absolutely crucial topic in VR development – maintaining an acceptable
    frame rate.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经谈了很多关于使用VR模式编辑场景的内容，让我们谈谈VR开发中一个非常关键的主题-保持可接受的帧率。
- en: We've discussed the paramount importance of maintaining frame rate in virtual
    reality several times before. It's critical, and it's challenging to do. In the
    remainder of this chapter, we're going to talk about things that you can do to
    speed up your scenes and to find out what's preventing them from running faster.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前已经多次讨论了在虚拟现实中保持帧率的至关重要性。这是至关重要的，也是具有挑战性的。在本章的剩余部分，我们将讨论一些可以加快场景速度并找出导致速度变慢的原因的方法。
- en: Testing your current performance
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试当前性能
- en: The first thing you need to do when assessing your scene's performance is to
    find out how fast you're currently running. We're going to look at a few commands
    we can use for this.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在评估场景性能时，您需要做的第一件事是找出当前运行速度有多快。我们将看一些可以用于此的命令。
- en: 'From within the editor, click on the **`** (backtick) key. It''s to the left
    of the *1* key on your keyboard, above the Tab key. A console entry box will appear:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 从编辑器中，点击**`**（反引号）键。它位于键盘上1键的左边，Tab键的上方。将出现一个控制台输入框：
- en: '![](img/9b17c2c8-c708-4a46-b879-a20869b57de7.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9b17c2c8-c708-4a46-b879-a20869b57de7.png)'
- en: A wide range of console commands can be entered here. We're going to talk about
    those you're most likely to use as you optimize your scenes.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在此处输入各种控制台命令。我们将讨论您在优化场景时最有可能使用的命令。
- en: Stat FPS
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Stat FPS
- en: 'Enter `stat fps` into the console command line. A frame rate counter will appear
    in your editor window, displaying two values:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在控制台命令行中输入`stat fps`。编辑器窗口中将出现一个帧率计数器，显示两个值：
- en: '![](img/11449d96-431c-4d3b-8911-fce9fbf607fe.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![](img/11449d96-431c-4d3b-8911-fce9fbf607fe.png)'
- en: The first is your frames per second (FPS). The second value tells you how many
    milliseconds it took to draw the frame, and this is the value you should train
    yourself to focus on. Frame rate is what your player perceives, but, as you're
    developing and trying to solve problems that impact your frame rate, you're going
    to have a much easier time thinking about how the changes you make affect your
    performance if you train yourself to think in milliseconds. The frame rate describes
    your desired result, but the milliseconds you're spending on each part of getting
    the frame rendered are the cause. When fixing your scene, you need to look at
    the individual costs of each operation that's contributing to your frame time,
    and these are expressed in milliseconds.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个是每秒帧数（FPS）。第二个值告诉您绘制帧所花费的毫秒数，这是您应该训练自己关注的值。帧率是玩家所感知到的，但在开发和尝试解决影响帧率的问题时，如果您训练自己以毫秒为单位思考，那么您在思考所做更改如何影响性能时会更容易。帧率描述了您期望的结果，但您在渲染帧的每个部分上花费的毫秒数是原因。在修复场景时，您需要查看每个操作的单独成本，这些成本以毫秒为单位表示。
- en: Determining your frame time budget
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确定您的帧时间预算
- en: If we're going to think in terms of milliseconds, the first thing we need to
    do is establish how many milliseconds we can spend drawing our frame and still
    hit our target frame rate. Figuring this out is simple.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要以毫秒为单位思考，首先要做的是确定我们可以花多少毫秒来绘制帧并仍然达到目标帧率。这很简单。
- en: To find your application's frame time budget, divide 1,000 by your target frame
    rate.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到应用程序的帧时间预算，将1,000除以目标帧率。
- en: 'This gives you the number of milliseconds in which you have to draw your frame
    to achieve this frame rate. So, for example, if you''re targeting a headset that
    refreshes at 90 FPS (which describes most of them), we find our frame budget like
    this:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这给出了您必须绘制帧的毫秒数以实现此帧率。例如，如果您的目标是刷新率为90 FPS的头戴式显示器（大多数头戴式显示器都是如此），我们可以这样找到我们的帧预算：
- en: '*1000 / 90 = 11.11*'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '*1000 / 90 = 11.11*'
- en: This gives us a frame budget of around 11 milliseconds. Your VR application
    will refresh at 90 FPS if it takes you 11 milliseconds or less to deliver the
    frame. That's not a lot of time, so we're going to have to do some work with most
    scenes to achieve this.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们一个大约11毫秒的帧预算。如果你在11毫秒或更短的时间内交付帧，你的VR应用程序将以90 FPS刷新。这不是很多时间，所以我们需要在大多数场景中做一些工作来实现这一点。
- en: Warnings about performance profiling
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于性能分析的警告
- en: Before we dive too deep down the performance optimization rabbit hole, let's
    keep a few important things in mind.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入性能优化的兔子洞之前，让我们记住几个重要的事情。
- en: First, the frame time reported on a flat screen isn't going to be accurate for
    VR. It's a good baseline value that you can use to see roughly how you're doing,
    but when you activate VR, your frame rate is going to drop.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，平面屏幕上报告的帧时间对于VR来说不准确。它是一个可以用来大致了解你的情况的基准值，但当你激活VR时，你的帧率会下降。
- en: If you see a really substantial drop in frame rate between your flat-screen
    values and your VR values, check your Project Settings and make sure you have
    Instanced Stereo turned on. If it's off, which is its default setting, you'll
    be paying the full cost of rendering your entire scene twice, which you definitely
    don't want to do.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在平面屏幕值和VR值之间看到了明显的帧率下降，请检查你的项目设置，确保已经打开了实例化立体。如果关闭了（这是默认设置），你将支付渲染整个场景两次的全部成本，这绝对是你不想做的。
- en: Be sure you're not just checking your values on flat-screen. Test in VR often.
    A quick way of checking your VR performance is to read your stat fps values from
    within VR Mode.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你不仅仅在平面屏幕上检查数值。经常在VR中进行测试。一种快速检查VR性能的方法是从VR模式中读取stat fps的值。
- en: Activate VR Mode with stat fps visible. The text will probably be too small
    to read from within the headset, but you can read it from the flat-screen output.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在可见的stat fps下激活VR模式。从头戴式显示器中可能无法读取文本，但你可以从平面屏幕输出中读取。
- en: Use this method to spot-check your environment. Move through the map and check
    for problem areas using VR Mode.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法来检查你的环境。在地图中移动并使用VR模式检查问题区域。
- en: Another important thing to consider is that, because we're testing in-editor,
    our numbers are affected by the editor itself. We're paying to render all those
    windows that your editor displays along with the in-game scene. For accurate values,
    we have to run the game in a stand alone session. Checking your numbers in-editor
    is a good practice to see whether changes you're making are making things better
    or worse, but you should remember that they don't accurately describe what your
    packaged application will do.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的事情要考虑的是，因为我们是在编辑器中进行测试，所以我们的数字受到编辑器本身的影响。我们需要支付渲染编辑器显示的所有窗口以及游戏场景的成本。为了获得准确的值，我们必须在独立会话中运行游戏。在编辑器中检查你的数字是一个好的实践，可以看到你所做的更改是好还是坏，但你应该记住它们并不能准确描述你打包的应用程序会做什么。
- en: We also need to remember that, when we test frame time in-editor, we're really
    just looking at rendering performance, but we're not getting any information about
    what the rest of our application is costing us. This is fine much of the time,
    since the bulk of your problems are likely to be in rendering, but you should
    still make sure you're testing the running application to make sure you don't
    have a runaway Blueprint or too many animated characters bringing you down.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要记住，当我们在编辑器中测试帧时间时，我们实际上只是在看渲染性能，但我们没有得到关于应用程序的其他部分成本的任何信息。这在大多数情况下都没问题，因为你的问题很可能在渲染方面，但你仍然应该确保测试正在运行的应用程序，以确保你没有一个失控的蓝图或太多的动画角色拖累你。
- en: Finally, we should talk about system specifications. Different hardware configurations
    will perform in different ways. If you're planning to release an application to
    the public, you should be sure that you're testing it on your minimum spec hardware,
    as well as on your development machines. Just because your application is running
    fine on a beast with a brand-new high-end video card doesn't mean it's going to
    run so well on older hardware. If you can test on your min-spec target, do so.
    If you can't, be conscious of how far your development machine is from your min-spec
    and make sure you leave a decent amount of headroom in your frame time budget
    to accommodate this.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们应该谈一下系统规格。不同的硬件配置会有不同的性能表现。如果你计划向公众发布一个应用程序，你应该确保你在最低规格的硬件上进行测试，以及在开发机器上进行测试。仅仅因为你的应用程序在一台配备全新高端显卡的怪物上运行良好，并不意味着它在旧硬件上也会运行得很好。如果你可以在最低规格的目标上进行测试，那就这样做。如果不能，要意识到你的开发机器与最低规格相差多远，并确保在帧时间预算中留出足够的余地来适应这一点。
- en: Now that we've talked a bit about the things that can affect our measurements,
    let's dive in deeper and learn how to get better information than we can get with
    stat fps alone.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经谈了一些可能影响我们测量结果的因素，让我们深入了解如何获得比仅仅使用stat fps更好的信息。
- en: Stat unit
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Stat unit
- en: Checking our frame rate is useful and it's an important thing to do frequently,
    but on it's own it doesn't tell us much. It may tell us that we have a problem,
    but it won't give us much guidance in finding what's wrong or how to fix it. For
    this, we have a few more useful commands at our disposal.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 检查我们的帧率是有用的，也是一个重要的频繁操作，但仅仅这样并不能告诉我们太多信息。它可能告诉我们有问题，但它不会给我们提供找出问题所在或如何修复问题的指导。为此，我们还有一些更有用的命令可以使用。
- en: The stat unit command breaks down the frame's cost in milliseconds and shows
    us which parts of that cost are coming from the scene we're rendering and which
    parts are coming from other things going on in our application, such as animations
    and AI.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: stat unit命令以毫秒为单位分解了帧的成本，并显示了我们渲染场景所花费的成本和应用程序中其他活动（如动画和AI）所花费的成本。
- en: 'Try it now. Click on the **` **(backtick) key to bring up your console command
    window, and type stat unit to add this additional information below your frame
    rate information:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试。点击**`**(反引号)键以打开控制台命令窗口，然后输入stat unit以在帧率信息下添加此额外信息：
- en: '![](img/5122dfe5-e217-4074-91b6-280a4a5dedf2.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
- en: 'The stat unit command displays four primary pieces of information:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: 'Frame: This is the total time it took to draw the frame. This is the same value
    we saw in the stat fps results.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Game: This tells you how long your game thread is taking on your CPU. This
    covers things such as animation updates, AI, and anything else your CPU has to
    figure out in order to update the frame. If you have Blueprints doing inefficient
    things on the Tick event, that will drive this value up.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Draw: This tells you how long your CPU spent preparing the scene for rendering.
    High values here may mean that you''re doing too much occlusion culling or spending
    too much on lights or shadows.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'GPU: This value tells you how long the GPU took to draw the frame. High values
    here may mean that you''re drawing too many polygons, using too many materials,
    or that your materials are too complex. Most of the time, your problems will be
    here.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These values are not additive. Your game thread will wait for the rendering
    thread to complete, so, if the Game timing matches your GPU timing, what that's
    really telling you is that your CPU isn't holding you up, and that your frame
    time is being driven by rendering.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to these four base values, we also have two advanced pieces of
    information that you don''t need to worry about right now:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: 'RHIT: This is your rendering hardware interface thread. Realistically, you
    won''t be seeing values here that differ much from your GPU values unless you''re
    working with advanced rendering hardware or a video game console, and you''re
    running your rendering hardware interface calls on a dedicated thread. Until you''re
    working on an advanced project with a dedicated team of engineers, this probably
    doesn''t apply to you.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'DynRes: This indicates whether dynamic resolution is supported or being used
    by your application. In practice, this is only supported on video game consoles,
    so you don''t need to worry about it here. If you''re curious, further information
    can be found at [https://docs.unrealengine.com/en-us/Engine/Rendering/DynamicResolution](https://docs.unrealengine.com/en-us/Engine/Rendering/DynamicResolution).'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What we're interested in finding from our stat unit information is whether we're
    spending most of our time on our Game CPU, our Game rendering operations, or on
    our GPU. We're looking for the largest number, because this is going to tell us
    what we need to fix.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: You should make it a habit to leave stat fps and stat unit on nearly all the
    time as you develop. If you introduce something new to the scene that is going
    to hammer your frame rate, the best time to discover this is when you put it in.
    If you go a long time before you discover a problem, you're going to have to do
    a lot more work to find out what caused it.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s often worth it to see how your stat unit values are changing over time,
    either as things happen in your application (this is useful for finding hitches)
    or as you move through the scene. To get this information, use stat unitgraph
    to display a graph over time of your scene''s performance metrics:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/971499d0-346e-437d-b48f-f10bb04678da.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
- en: You'll see that your stat unit values have now been color-coded to correspond
    with lines on the graph.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned previously, most of the time, your problems will be with the GPU
    art that's just too heavy to fit within your scene.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: Of course, if you're doing ridiculous things on your Tick, you may be getting
    killed on your CPU, in which case you're going to want to look for Blueprints
    that could be refactored to act in response to events or changes in data instead
    of using the tick. But, most of the time, GPU is where you're going to run into
    trouble.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: Profiling the GPU
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first tool you should learn to use in optimizing your scene is the GPU
    profiler. You can activate this by typing profilegpu in the console, but since
    you''re going to use it so often, it''s a better idea to memorize the hotkey:
    *Ctrl* + *Shift* + *,* (comma). Hit it now and let''s look at the numbers:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/97c0ff5f-9d7a-462c-a3b4-3a2ee3630f01.png)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
- en: The most important part of this profile report is the graph under the Scene
    heading. Roll over the graph, and you'll see that tooltips tell you what each
    block represents. The two biggest blocks will usually be your BasePass and your
    PostProcessing pass. The base pass represents the act of drawing everything in
    the scene. Post processing handles anything that's taken care of after the scene
    has been drawn, such as screen-space ambient occlusion, color correction, and
    other effects.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: 'Hit the expander to the left of the Scene heading to drill down for more detail
    into your scene rendering:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ae6955a0-d425-4afa-8eb5-9d33ee1045fa.png)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
- en: Here, we can see a more detailed breakdown of what's costing us time in drawing
    our frame. Lighting looks good here, as does translucency. Our BasePass is fairly
    sizeable, but that's to be expected.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: 'You''re not going to get too much more information by drilling down into your
    BasePass, but you can learn some useful stuff by drilling into your PostProcessing
    operations. Use the triangle beside your PostProcessing header to drill into it,
    and then click on large chunks in your PostProcessing operations to see what they
    are:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d6640a19-f716-4575-8685-0433e7722b89.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
- en: In this instance, these post numbers look pretty good. We don't have anything
    returning an unreasonably high duration.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: Make sure you profile with the game running, or you'll see a lot of operations
    coming from the editor.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: We're not going to have the space here to dig into everything involved in the
    rendering process and what it means, but in general, what you're looking for are
    large items that may be unnecessarily impacting your frame rate. When you find
    something that looks suspicious, search for it on the Unreal forums, and you'll
    likely find a discussion of what it means and what to do about it.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: As you use this tool more and more, you'll develop a sense for what looks healthy
    and what problem areas look like. Use it often to get a clear handle on what your
    application is doing.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's look at a few other useful commands we can use to debug our scene.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: Stat scenerendering
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Behind the GPU profiler, your next most useful command is likely to be stat
    scenerendering. This command gives you a detailed list of the steps your system
    is taking to render the scene with their associated timings:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6087c36f-4f15-4688-b71f-292166f05f8a.png)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
- en: It's especially worthwhile in here to look at your Dynamic shadow setup and
    your Translucency drawing.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: If you're seeing high values in your shadow setup, see whether one or more of
    your lights is doing too many shadow cascades or has a shadow distance that's
    too long. You can find more information on this topic at [https://docs.unrealengine.com/en-us/Platforms/Mobile/Lighting/HowTo/CascadedShadow](https://docs.unrealengine.com/en-us/Platforms/Mobile/Lighting/HowTo/CascadedShadow).
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: 'If your Translucency drawing is high, activate your editor''s Quad Overdraw
    optimization viewmode, and look for translucent objects stacking over one another.
    If you have a problem here, you might be able to solve it by using masked rather
    than translucent materials, or by being careful about how they overlap in views:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/acd1e832-c2fe-4486-89d3-c317d9df8bd0.png)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
- en: 'At the bottom of this list are some very important numbers: Mesh draw calls
    and Static List draw calls. We should talk about these.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: Draw calls
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the biggest factors that will impact your scene performance is the number
    of **draw calls** required to get its information onto the GPU. What are we talking
    about here? It breaks down like this: everything you want the video card to draw
    has to be copied onto that card''s memory. The act of sending a set of instructions
    to the card is called a draw call, or a **draw primitive call** (sometimes abbreviated
    to **DPC**). Let''s say you have a static mesh appearing in your scene that has
    three materials on it. That''s going to take four draw calls to set it up on the
    card: one for the mesh, and one for each material. You should endeavor to keep
    the number of draw calls in your scene as low as you can get it. Realistically,
    2,000 draw calls is probably your limit for a VR scene. On mobile VR, like the
    Oculus Go or Quest, that number is lower.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: What does this mean for you? First, put as few materials on your objects as
    you can get away with; ideally, one material per object. By adding just one more
    material slot, you've literally added one-third more to the cost of loading that
    object onto the video hardware, and if that object appears frequently in your
    scene, that's going to add up in a hurry.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: We're going to talk shortly about what you can do about high draw call counts,
    but for now what you need to know about them is that, if these numbers are high,
    you're sending too many separate instructions to the video card, and that's going
    to slow you down. Maybe you have too many material slots on your objects, or too
    many individual objects being sent separately, but in all cases, it's a thing
    you'll need to fix.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: Stat RHI
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another closely related command you''ll use often is stat rhi. **RHI** stands
    for **rendering hardware interface**, and it tells you specifically what''s impacting
    your rendering performance:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bc2c62aa-340e-407c-99c4-2d67ef13d687.png)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
- en: The two values you'll care most about here are Triangles drawn and your DrawPrimitive
    calls. Make it a habit to look through your scene with these values displayed,
    and look for views with unreasonably high triangle counts or draw call counts.
    For a VR scene on a desktop VR headset, you want to keep the number of triangles
    drawn below 2 million, and you want to keep your draw calls under 2,000.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: The other value you should care about here is your memory consumption. Another
    way to get a scene running really slowly in real time is to use textures that
    are unreasonably large. Don't put a 4K texture on a pebble. We've seen it happen.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '`Stat rhi` is one of the most useful commands overall for getting a general
    sense of how well your scene is fitting within its budget.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: Stat memory
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you need more information about what''s blowing your memory budget, you
    can use stat memory:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d76c5890-822a-441f-9c67-8ade3e67b798.png)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
- en: Most of the time, if you're consuming too much memory, the culprit will be textures.
    Be on the lookout for textures that are too large for what they're being used
    for. A huge object or a hero character might warrant a 2048x2048 texture. Anything
    else should be 1024x1024 or smaller. A 4K texture is probably not reasonable under
    any circumstances in VR. As you consider where to cut your textures down, look
    at the object in scene. How big is it? How close can the player get to it? Is
    it something the player really cares about looking at? It's awfully easy to spend
    way too much on an object the player can barely see. Start to think in terms of
    spending your texture and polycount budgets where they matter, and economizing
    where you can get away with it.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: Optimization view modes
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to the stat commands, we also have a few optimization view modes
    that can be used to find problems in your scene. These are each accessed from
    the editor viewport's view mode menu. We're just going to talk about two of them
    here.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: 'The Shader Complexity view shows you where your materials may be slowing you
    down. When you find a suspect object, select it, and see what''s going on in its
    materials. Is your material too complicated or doing expensive math? Consider
    the following screenshot:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2e5b4544-4e4d-4bb0-87b6-e97ca675ea5a.png)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
- en: In the case of the preceding screenshot, the grass and tree are registering
    as expensive materials. When we select their objects and look at those materials,
    we can see that what's driving up their cost is that they use their World Position
    Offset input to simulate wind. That's expensive, but it's a nice effect and the
    player would notice if we turned it off, so we can leave it alone since the rest
    of our scene is running pretty efficiently.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: Use this view to search for materials that may be costing you a lot without
    adding much value to the scene.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: The Light Complexity view comes into play if you're using dynamic lights under
    the deferred shading model. Because we're using forward rendering and static lights
    here, it won't show us anything on this scene. When you are using dynamic lights
    and deferred shading, this view can show you where your lights are causing problems.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: CPU profiling
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you're having trouble with your CPU times, you can use CPU profiling to find
    out where the problems are, just as we did earlier with the GPU profiler.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: To activate CPU profiling, while the game is running, open a console command
    and type stat startfile to begin profiling. Profiling generates a lot of data,
    so you don't want to run your profiler over an entire session – just capture things
    you're interested in, such as, *why does the game slow down so much when that
    character alerts to an enemy?*
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: After you've captured whatever you're looking for, type `stat stopfile` to turn
    profiling back off. The profiler will save the captured data to a `.ue4stats`
    file in your project's `\Saved\Profiling\UnrealStats\` directory.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, open your Unreal Engine''s install directory, and, inside its `Binaries\Win64`
    folder, look for the `UnrealFrontend.exe` application. Launch it and use the tabs
    to select Session | Frontend | Profiler. Use the profiler''s Load button to open
    the `.ue4stats` file you just generated:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/79471103-c543-4e39-80c6-7eaf659f054e.png)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
- en: The CPU Profiler shows you how much time each operation called during a frame
    takes.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: Just as we did with the GPU profiler, you can use this tool to burrow through
    expensive-looking function calls and see what's going on. It would take us beyond
    the scope of this book to go deeply into using the CPU profiler here—it's an extremely
    useful and powerful tool, but it does take some time to learn how to get good
    information from it. We recommend that you explore the write-up on the topic to
    go further, which can be found at [https://www.unrealengine.com/en-US/blog/how-to-improve-game-thread-cpu-performance](https://www.unrealengine.com/en-US/blog/how-to-improve-game-thread-cpu-performance).
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: Turning things on and off
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As primitive as it may sound, one of the most effective ways to find out what's
    costing you frame rate is simply to turn features on and off with the relevant
    stat information displayed (usually, stat unit is what you want for this). Use
    the viewport's Show menu to turn individual elements on and off, especially if
    you've determined through your GPU profiling or your stat information that the
    thing in question might be causing a problem. It can also be helpful to start
    deleting objects from your level (as long as you have a backup or it's under source
    control), and see whether a particular object makes a big change.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: Addressing frame rate problems
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we've learned a bit about how to find problems in your scene, let's
    talk a bit about what to do about them.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: Cleaning up Blueprint Tick events
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you're seeing high numbers on your CPU, one of the first culprits you want
    to look for is any Blueprint doing operations on the Tick event. This is an extremely
    common culprit. Remember that Tick events happen every single frame, so if you're
    doing a lot of work on your Tick, you're impacting every single frame you need
    to draw. Look for ways to spread this work out over multiple frames, or to avoid
    using the Tick altogether and use events to make objects change their state only
    when something changes.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: Managing skeletal animations
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have a lot of skeletal meshes animating, make sure they don't have a
    ridiculous number of bones in their skeletons, and make sure they're not using
    a ton of blend space animations. It's a much better practice to use skeletal mesh **Level
    of Detail** (**LOD**) to include fine details only when the player can see them,
    or to use separate skeletal meshes for cinematics, where highly-detailed facial
    animations matter, and for in-game meshes, use skeletons with lower bone counts.
    For more information on setting up skeletal mesh LODs, begin by looking at [https://docs.unrealengine.com/en-US/Engine/Content/ImportingContent/ImportingSkeletalLODs](https://docs.unrealengine.com/en-US/Engine/Content/ImportingContent/ImportingSkeletalLODs).
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: Merging actors
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is a big one. Remember a short while ago when we mentioned that draw call
    counts have a big impact on your frame rate? One of the cheapest and easiest ways
    to drop your draw call counts is to merge multiple meshes into a single mesh.
    This will not only create a single mesh out of the multiple individual meshes
    you've selected, but it will also create a combined material for that mesh out
    of each child mesh's materials. This is a big deal.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: Let's say you have a bunch of debris in a corner of a room; maybe 25 objects
    or so, and each of them uses one material slot. You're looking at 50 draw calls
    right there, out of a total of maybe 2,000 that you have available for your entire
    scene. That's a big hit. By merging these into a single object, you can drop 50
    draw calls down to two. This is one of the fastest and most effective ways you
    can bring down your draw call count.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: 'One caveat about this though: remember earlier in this book when we talked
    about Kent Beck''s advice to *make it work, make it right, make it fast*? This
    is one of those areas where that wisdom applies. Once you bake all these objects
    into a single object, you no longer have the freedom to rearrange the individual
    components, so get the scene looking the way you want it, and then merge your
    actors to bring things under control.'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how to do it:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: 'Select Window | Developer Tools | Merge Actors. The Merge Actors window will
    appear. Select the actors you want to merge. In general, it''s a good idea to
    merge actors that are close together and likely to be in the same view. Once they''re
    merged, all of them will be drawn even if only one of them is on camera, so merge
    items that are all going to be on camera simultaneously most of the time:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/050ceecf-612a-4b08-a493-794364c8321a.png)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
- en: The Merge Actors dialog seen with multiple selected actors in the viewport behind
    it
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: If you select Replace Source Actors, the actors you've selected in-scene will
    be replaced by the merged model. For more information about merging actors, begin
    with [https://docs.unrealengine.com/en-us/Engine/Actors/Merging](https://docs.unrealengine.com/en-us/Engine/Actors/Merging).
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: Using mesh LODs
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The number of triangles you're drawing in a scene (usually called the **polycount**)
    is another huge factor in determining your scene's rendering speed.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: Of course, your first line of defense against high polycounts is in modeling.
    Use an application such as Pixologic's ZBrush to bake normal maps from a high-detail
    model, and apply them to a lower-detail mesh that you import into the game engine.
    Much of the time, your players will never notice the difference. VR is less forgiving
    of using normal maps to simulate geometric detail than the flat screen is, because
    players can sometimes see that the depth isn't real, but you should still make
    use of this technique anywhere you can get away with it.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have a mesh in-game, however, you have a powerful LOD tool available
    to you to manage how many triangles you''re drawing. LODs work like this: they
    store several versions of the same model, with increasingly small polycounts.
    As the model gets smaller on screen, the system switches out the high-detail mesh
    for a lower-detail mesh, since the player won''t be able to see the detail anyway,
    now that it''s further away.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how to set up an LOD:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: Select a static mesh and open the Static Mesh editor from the content browser.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under its Details, look for the LOD Settings section.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find the Number of LODs entry, and set it to a value greater than  1\. (For
    this test, just set it to 2 to create 2 LODs.)
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on Apply Changes. One or more additional LOD models will now be created
    and added to the static mesh asset.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under the LOD Picker section, find the LOD entry, and use it to select one of
    the new LODs.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: LOD 0 is the original model. Most of the time you'll leave this unchanged. LOD
    1 is the first LOD after LOD 0.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: With the new LOD, such as LOD 1, selected, open the Reduction Settings entry
    from its LOD detail section and modify it.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You have a number of options available here, but most of the time, you''ll
    be managing the Percent Triangles value. If you make changes here, click on Apply
    Changes to see the result:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6a7ebedb-cecd-4c70-af01-6fdb195e3d3e.png)'
  id: totrans-305
  prefs: []
  type: TYPE_IMG
- en: You'll see the modified mesh in your viewport. To see what it will look like
    at the real view distance, switch your LOD Picker back to LOD Auto and move your
    view around to see how the object changes as it switches between LODs. The LOD
    generator is surprisingly good.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: For more information about creating and using LODs, start by looking at [https://docs.unrealengine.com/en-us/Engine/Content/Types/StaticMeshes/HowTo/LODs](https://docs.unrealengine.com/en-us/Engine/Content/Types/StaticMeshes/HowTo/LODs).
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: Static mesh instancing
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Remember those draw calls we were so concerned about a moment ago? There's another
    powerful way to reduce their count and dramatically speed up your rendering.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: Say you have a big collection of mostly the same assets, such as a forest that
    reuses the same tree mesh hundreds of times. If you simply place those meshes
    in the environment individually, every single one of them is going to generate
    a minimum of two draw calls, and even more if it uses more materials. That's a
    recipe for a slide show. What you want to do instead is **instance** this geometry.
    Instancing is a way of telling your GPU that, even though it's about to draw a
    few hundred meshes, they're really all just the same mesh with different transforms.
    So, instead of making a separate draw call for each tree, the system makes one
    set of draw calls and gives the video hardware a list of locations, orientations,
    and scales at which to draw them. This is wildly faster than passing each item
    as a separate item.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: By default in Unreal, the easiest way to instance objects is to use the foliage
    tool. While it's most commonly used for foliage, as the name suggests, you can
    also use it for repeated objects in lots of other contexts, like streetlamps on
    city streets. You can find more information on foliage instancing at [https://docs.unrealengine.com/en-us/Engine/Foliage](https://docs.unrealengine.com/en-us/Engine/Foliage).
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: Instancing static meshes outside the foliage tool is a bit more of a complex
    topic, but it can be done and can be a good idea if you're procedurally generating
    an actor that contains a large array of individual static meshes. Most of the
    time, however, when you're instancing objects in scenes, use the foliage tool
    to do it.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: Nativizing Blueprints
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Blueprints are already interpreted amazingly fast, but they can be made even
    faster by translating them automatically into C++ and then allowing the system
    to compile them.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: To turn this on, open Project Settings | Project | Packaging | Blueprints, and
    use the Blueprint Nativization Method selector to select **inclusive** or **exclusive** nativization.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: '**Inclusive** nativization will convert all your Blueprints to C++ when they
    compile.'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Exclusive** nativization will convert only those Blueprints for which you
    set the nativize flag.'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you''re using exclusive nativization, select the Blueprints you want to
    nativize by opening their Class Settings, and turn on the Nativize option in their Details
    | Packaging panel. Again, you don''t need to do this if you''re using inclusive
    nativization. In that case, every Blueprint is nativized:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ff134984-41b9-4db7-a36c-3ae3e9514914.png)'
  id: totrans-319
  prefs: []
  type: TYPE_IMG
- en: If you're planning to ship your application on desktop VR, inclusive nativization
    may be fine, but if you're planning to deploy to mobile VR, such as the Oculus
    Go or Quest, it's probably smarter to use exclusive nativization to choose which
    Blueprints you want to nativize, since including them all can increase your executable
    size.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: This is a bit of an advanced topic. In general, you'll see a benefit if you
    nativize Blueprints that do a lot of work on the Tick event, or that just do a
    lot of work in general. If your Blueprints are fairly simple, you won't really
    see a difference either way. Because speed is so critical to VR development, it's
    good to know that this option is available to you.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: If you do plan to do this, turn nativization on early in your project's development,
    and test on cooked builds frequently. Nativization is extremely good, but it can
    sometimes still cause unexpected side effects.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned quite a lot about how to use Unreal's VR Mode editor
    to compose environments from within VR, and we learned how to analyze and optimize
    scenes to see where our performance bottlenecks are.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we're going to take a detour from building real-time 3D
    worlds in VR and look at another common application – movies and immersive photography.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
