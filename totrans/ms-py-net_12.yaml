- en: Continuous Integration with Jenkins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The network touches every part of the technology stack; in all of the environments
    I have worked in, it is always a Tier-Zero service. It is a foundation service
    that other services rely on for their services to work. In the minds of other
    engineers, business managers, operators, and support staff, the network should
    just work. It should always be accessible and function correctly—a good network
    is a network that nobody hears about.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, as network engineers, we know the network is as complex as any other
    technology stack. Due to its complexity, the constructs that make up a running
    network can be fragile at times. Sometimes, I look at a network and wonder how
    it can work at all, let alone how it's been running for months and years without
    business impacts.
  prefs: []
  type: TYPE_NORMAL
- en: Part of the reason we are interested in network automation is to find ways to
    repeat our network-change process reliably and consistently. By using Python scripts
    or the Ansible framework, we can make sure the change that we make will stay consistent
    and be reliably applied. As we saw in the last chapter, we can use Git and GitHub
    to store components of the process, such as templates, scripts, requirements,
    and files, reliably. The code that makes up the infrastructure is version-controlled,
    collaborated, and accountable for changes. But how do we tie all the pieces together?
    In this chapter, we will look at a popular open source tool that can optimize
    the network-management pipeline, called Jenkins.
  prefs: []
  type: TYPE_NORMAL
- en: Traditional change-management process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For engineers who have worked in a large network environment, they know the
    impact of a network change gone wrong can be big. We can make hundreds of changes
    without any issues, but all it takes is one bad change that can cause the network
    to have a negative impact on the business.
  prefs: []
  type: TYPE_NORMAL
- en: There is no shortage of war stories about network outages causing business pain.
    One of the most visible and large-scale AWS EC2 outage in 2011 was caused by a
    network change that was part of our normal AWS scaling activities in the AWS US-East
    region. The change occurred at 00:47 PDT and caused a brown-out for various services
    for over 12 hours, losing millions of dollars for Amazon in the process. More
    importantly, the reputation of the relatively young service took a serious hit.
    IT decision makers will point to the outage as reasons to `NOT` migrate to AWS
    cloud. It took many years to rebuild its reputation. You can read more about the
    incident report at [https://aws.amazon.com/message/65648/](https://aws.amazon.com/message/65648/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Due to its potential impact and complexity, in many environments, the **Change-Advisory
    Board (CAB)** is implemented for networks. The typical CAB process is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The network engineer will design the change and write out the detail steps required
    of the change. This can include the reason for the change, the devices involved,
    the commands that will be applied or deleted, how to verify the output, and the
    expected outcome for each of the steps.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The network engineer is typically required to ask for a technical review from
    a peer first. Depending on the nature of the change, there can be different levels
    of peer review. The simple changes can require a single peer technical review;
    the complex change might require a senior designated engineer for approval.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The CAB meeting is generally scheduled for set times with emergency ad-hoc meetings
    available.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The engineer will present the change to the board. The board will ask the necessary
    questions, assess the impact, and either approve or deny the change request.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The change will be carried out, either by the original engineer or another engineer,
    at the scheduled change window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This process sounds reasonable and inclusive but proves to have a few challenges
    in practice:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Write-ups are time-consuming**: It typically takes a lot of time for the
    design engineer to write up the document, and sometimes the writing process takes
    longer than the time to apply the change. This is generally due to the fact that
    all network changes are potentially impactful and we need to document the process
    for both technical and non-technical CAB members.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Engineer expertise**: There are different levels of engineering expertise,
    some are more experienced, and they are typically the most sought-after resources.
    We should reserve their time for tackling the most complex network issues, not
    reviewing basic network changes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Meetings are time-consuming**: It takes a lot of effort to put together meetings
    and have each member show up. What happens if a required approval person is on
    vacation or sick? What if you need the network change to be made prior to the
    scheduled CAB time?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are just some of the bigger challenges of the human-based CAB process.
    Personally, I hate the CAB process with a passion. I do not dispute the need for
    peer review and prioritization; however, I think we need to minimize the potential
    overhead involved. Let's look at a potential pipeline that has been adopted in
    the software-engineering pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to continuous integration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Continuous Integration (CI)** in software development is a way to publish
    small changes to the code base quickly, in the context of tests and validation
    built-in. The keys are to classify the changes to be CI-compatible, that is, not
    overly complex, and small enough to be applied that they can be backed out easily.
    The tests and validation process is built in an automated way to gain a baseline
    of confidence that it will be applied without breaking the whole system.'
  prefs: []
  type: TYPE_NORMAL
- en: Before CI, changes to the software were often made in large batches and often
    required a long validation process. It can be months before developers see their
    changes in production, receive feedback loops, and correct any bugs. In short,
    the CI process aims to shorten the process from idea to change.
  prefs: []
  type: TYPE_NORMAL
- en: 'The general workflow typically involves the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: The first engineer takes a current copy of the code base and works on their
    change
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first engineer submits the change to the repository
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The repository can notify the necessary parties of a change in the repository
    to a group of engineers who can review the change. They can either approve or
    reject the change
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The continuous-integration system can continuously pull the repository for changes,
    or the repository can send a notification to the CI system when changes happen.
    Either way, the CI system will pull the latest version of the code
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The CI system will run automated tests to try to catch any breakage
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If there is no fault found, the CI system can choose to merge the change into
    the main code and optionally deploy to the production system
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is a generalized list of steps. The process can be different for each organization;
    for example, automated tests can be run as soon as the delta code is checked in
    instead of after code review. Sometimes, the organization might choose to have
    a human engineer involved for sanity checks in between the steps.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will illustrate the instructions to install Jenkins
    on an Ubuntu 16.04 system.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Jenkins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the examples we will use in this chapter, we can install Jenkins on the
    management host or a separate machine. My personal preference is to install it
    on a separate virtual machine. The virtual machine will have a similar network
    set up as the management host up to this point, with one interface for the internet
    connection and another interface for VMNet 2 connection to the VIRL management
    network.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Jenkins image and installation instruction per operating system can be
    found at [https://jenkins.io/download/](https://jenkins.io/download/). The following
    is the instructions I used for installing Jenkins on the Ubuntu 16.04 host:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: At the time of writing, we have to install Java separately because Jenkins does
    not work with Java 9; see [https://issues.jenkins-ci.org/browse/JENKINS-40689](https://issues.jenkins-ci.org/browse/JENKINS-40689) for
    more details. Hopefully, by the time you read this, the issue is resolved.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once Jenkins is installed, we can point the browser to the IP at port `8080`
    to continue the process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/d3769c61-58a4-44da-971f-7bc86ec69c20.png)'
  prefs: []
  type: TYPE_IMG
- en: Unlock Jenkins screen
  prefs: []
  type: TYPE_NORMAL
- en: 'As stated on the screen, get the admin password from `/var/lib/jenkins/secrets/initialAdminPassword` and
    paste the output in the screen. For the time being, we will choose the Install
    suggested plugins option:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/e2c7bdc2-7431-48ea-8b79-8388ba52f17a.png)'
  prefs: []
  type: TYPE_IMG
- en: Install suggested plugins
  prefs: []
  type: TYPE_NORMAL
- en: 'You will be redirected to create the admin user; once created, Jenkins will
    be ready. If you see the Jenkins dashboard, the installation was successful:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/251e88e1-8c3e-466f-928e-509f710bd880.png)'
  prefs: []
  type: TYPE_IMG
- en: Jenkins dashboard
  prefs: []
  type: TYPE_NORMAL
- en: We are now ready to use Jenkins to schedule our first job.
  prefs: []
  type: TYPE_NORMAL
- en: Jenkins example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will take a look at a few Jenkins examples and how they
    tie into the various technologies we have covered in this book. The reason Jenkins
    is one of the last chapters of this book is because it will leverage many of the
    other tools, such as our Python script, Ansible, Git, and GitHub. Feel free to
    refer back to [Chapters 11](85c09606-4a40-46f3-82b8-0b20550fd64d.xhtml), *Working
    with Git*, if needed.
  prefs: []
  type: TYPE_NORMAL
- en: In the examples, we will use the Jenkins master to execute our jobs. In production,
    it is recommended to add Jenkins nodes to handle the execution of jobs.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our lab, we will use a simple two-node topology with IOSv devices:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/6c297d94-b1ca-47c6-a287-058426b828d9.png)'
  prefs: []
  type: TYPE_IMG
- en: Chapter 12 lab topology
  prefs: []
  type: TYPE_NORMAL
- en: Let's build our first job.
  prefs: []
  type: TYPE_NORMAL
- en: First job for the Python script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For our first job, let''s use the Parmiko script that we built in [Chapter
    2](8cefc139-8dfa-4250-81bf-928231e20b22.xhtml), *Low-Level Network Device Interactions*,
    `chapter2_3.py`. If you recall, this is a script that uses `Paramiko` to `ssh`
    to the remote devices and grabs the `show run` and `show version` output of the
    devices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We will use the create new job link to create the job and pick the Freestyle
    project option:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/44832874-d06e-4afa-bfed-9389c6d67b28.png)'
  prefs: []
  type: TYPE_IMG
- en: Example 1 freestyle project
  prefs: []
  type: TYPE_NORMAL
- en: 'We will leave everything as default and unchecked; select Execute shell as
    the build option:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/d1bb4d78-f774-4400-8eb6-47f54d4c10c8.png)'
  prefs: []
  type: TYPE_IMG
- en: Example 1 build step
  prefs: []
  type: TYPE_NORMAL
- en: 'When the prompt appears, we will enter in the exact commands we use in the
    shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/11251fcf-41d1-4c61-974e-fb29d3557e4b.png)'
  prefs: []
  type: TYPE_IMG
- en: Example 1 shell command
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we save the job configuration, we will be redirected to the project dashboard.
    We can choose the Build Now option, and the job will appear under Build History:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/0127ca4d-f50f-4e23-9f6b-bf65a99f2d25.png)'
  prefs: []
  type: TYPE_IMG
- en: Example 1 build
  prefs: []
  type: TYPE_NORMAL
- en: 'You can check the status of the build by clicking on it and choosing the Console
    Output on the left panel:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/124a9350-e1b1-4f6e-b92f-a577a029c6b7.png)'
  prefs: []
  type: TYPE_IMG
- en: Example 1 console output
  prefs: []
  type: TYPE_NORMAL
- en: 'As an optional step, we can schedule this job at a regular interval, much like
    cron would do for us. The job can be scheduled under Build Triggers, choose to
    Build Periodically and entered the cron-like schedule. In this example, the script
    will run daily at 02:00 and 22:00:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/e62e60a1-3565-4665-8aa4-057ec7b5e2a8.png)'
  prefs: []
  type: TYPE_IMG
- en: Example 1 build trigger
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also configure the SMTP server on Jenkins to allow notification of the
    build results. First, we will need to configure the SMTP server settings under
    Manage Jenkins | Configure Systems from the main menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/445a095e-4b20-45df-a321-6d73b5152199.png)'
  prefs: []
  type: TYPE_IMG
- en: Example 1 configure system
  prefs: []
  type: TYPE_NORMAL
- en: 'We will see the SMTP server settings toward the bottom of the page. Click on
    the Advanced settings to configure the SMTP server settings as well as to send
    out a test email:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/9f77d424-47bc-45ef-bee1-b5afee81c341.png)'
  prefs: []
  type: TYPE_IMG
- en: Example 1 configure SMTP
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be able to configure email notifications as part of the post-build
    actions for our job:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/50afeec2-613d-41a8-9ba2-1a26f5f87d90.png)'
  prefs: []
  type: TYPE_IMG
- en: Example 1 email notification
  prefs: []
  type: TYPE_NORMAL
- en: 'Congratulations! We have just used Jenkins to create our first job. Functionally,
    this has not done anything more than what we could have achieved with our management
    host. However, there are several advantages of using Jenkins:'
  prefs: []
  type: TYPE_NORMAL
- en: We can utilize Jenkins' various database-authentication integrations, such as
    LDAP, to allow existing users to execute our script.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can use Jenkins' role-based authorization to limit users. For example, some
    users can only execute jobs without modification access while others can have
    full administrative access.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jenkins provides a web-based graphical interface that allows users to access,
    the scripts easily.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can use the Jenkins email and logging services to centralize our jobs and
    be notified of the results.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jenkins is a great tool by itself. Just like Python, it has a big third-party
    plugin ecosystem that can be used to expand its features and functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: Jenkins plugins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will install a simple schedule plugin as an example illustrating the plugin-installation
    process. The plugins are managed under Manage Jenkins | Manage Plugins:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/867ca9d1-9540-42a2-9a55-da6e7f887c5b.png)'
  prefs: []
  type: TYPE_IMG
- en: Jenkins plugin
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the search function to look for the Schedule Build plugin under
    the available tab:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/79da400f-bb21-4fa6-8695-4f576a64bc83.png)'
  prefs: []
  type: TYPE_IMG
- en: Jenkins plugin search
  prefs: []
  type: TYPE_NORMAL
- en: 'From there, we will just click on Install without restart, and we will be able
    to check the installation progress on the following page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/4cecebf1-d057-4bb2-a1b8-6bb21cdf1f30.png)'
  prefs: []
  type: TYPE_IMG
- en: Jenkins plugin installation
  prefs: []
  type: TYPE_NORMAL
- en: 'After the installation is completed, we will be able to see a new icon that
    allows us to schedule jobs more intuitively:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/d6b1fccc-091e-435a-9f7e-e24bcdafa7a3.png)'
  prefs: []
  type: TYPE_IMG
- en: Jenkins plugin result
  prefs: []
  type: TYPE_NORMAL
- en: It is one of the strengths of a popular open source project to have the ability
    to grow over time. For Jenkins, the plugins provide a way to customize the tool
    for different customer needs. In the coming section, we will look at how to integrate
    version control and the approval process into our workflow.
  prefs: []
  type: TYPE_NORMAL
- en: Network continuous integration example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, let's integrate our GitHub repository with Jenkins. By integrating
    the GitHub repository, we can take advantage of the GitHub code review and collaboration
    tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will create a new GitHub repository, I will call this repository
    `chapter12_example2`. We can clone this repository locally and add the files we
    wanted to the repository. In this case, I am adding an Ansible playbook that copies
    the output of the `show version` command to a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'By now, we should be pretty familiar with running an Ansible playbook. I will
    skip the output of `host_vars` and the inventory file. However, the most important
    thing is to verify that it runs on the local machine before committing to the
    GitHub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now push the playbook and associated files to our GitHub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ef05539d-35a8-4d2d-93e1-c394c8c672a9.png)'
  prefs: []
  type: TYPE_IMG
- en: Example 2 GitHub repository
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s log back into the Jenkins host to install `git` and Ansible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Some of the tools can be installed under Global Tool Configuration; Git is
    one of them. However, since we are installing Ansible, we can install Git in the
    same Command Prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/cbe499e5-4768-462b-8b9e-8ec7c4b341d1.png)'
  prefs: []
  type: TYPE_IMG
- en: Global tools configuration
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create a new freestyle project named `chapter12_example2`. Under the
    source-code management, we will specify the GitHub repository as the source:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/02120bae-0753-4b1b-96c0-395cbd62d7c7.png)'
  prefs: []
  type: TYPE_IMG
- en: Example 2 source-code management
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we move on to the next step, let''s save the project and run a build.
    In the build console output, we should be able to see the repository being cloned
    and the index value match what we see on GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/6e43af16-88fb-4710-9e71-65561a16403a.png)'
  prefs: []
  type: TYPE_IMG
- en: Example 2 console output 1
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now add the Ansible playbook command in the build section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/b0a9e905-9f58-4f88-92f0-1162b87d63d3.png)'
  prefs: []
  type: TYPE_IMG
- en: Example 2 build shell
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run the build again, we can see from the console output that Jenkins
    will fetch the code from GitHub before executing the Ansible playbook:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/7262af09-7d6c-4e5d-a11a-bc5cf0533bc1.png)'
  prefs: []
  type: TYPE_IMG
- en: Example 2 build console output 2
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the benefits of integrating GitHub with Jenkins is that we can see all
    the Git information on the same screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/6098f97c-31f5-4e7e-8ede-8b4375702f56.png)'
  prefs: []
  type: TYPE_IMG
- en: Example 2 Git build data
  prefs: []
  type: TYPE_NORMAL
- en: 'The results of the project, such as the output of the Ansible playbook, can
    be seen in the `workspace` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/484f53e1-38ab-4e6a-a79c-72ac8c79dddd.png)'
  prefs: []
  type: TYPE_IMG
- en: Example 2 workspace
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we can follow the same step as before to use periodic build
    as the build trigger. If the Jenkins host is publicly accessible, we can also
    use GitHub''s Jenkins plugin to notify Jenkins as a trigger for the build. This
    is a two-step process, the first step is to enable the plugin on your GitHub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/abaf72ff-5399-456e-8cf5-2e38279ae55d.png)'
  prefs: []
  type: TYPE_IMG
- en: Example 2 GitHub Jenkins service
  prefs: []
  type: TYPE_NORMAL
- en: 'The second step is to specify the GitHub hook trigger as the Build Triggers
    for our project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/34ffd332-eb02-4ab6-8ee4-0634823689b7.png)'
  prefs: []
  type: TYPE_IMG
- en: Example 2 Jenkins build trigger
  prefs: []
  type: TYPE_NORMAL
- en: Having the GitHub repository as the source allows for a brand new set of possibilities
    of treating infrastructure as code. We can now use GitHub's tool of a fork, pull
    requests, issue tracking, and project management to work together efficiently.
    Once the code is ready, Jenkins can automatically pull the code down and execute
    it on our behalf.
  prefs: []
  type: TYPE_NORMAL
- en: You will notice we did not mention anything about automated testing. We will
    go over testing in [Chapter 13](d1720d17-6ae3-4886-89e3-f9ded2c88706.xhtml), *Test-Driven
    Development for Networks*.
  prefs: []
  type: TYPE_NORMAL
- en: Jenkins is a full-featured system that can become complex. We have just scratched
    the surface of it with the two examples presented in this chapter. The Jenkins
    pipeline, environmental setup, multibranch pipeline, and so on, are all useful
    features that can accommodate the most complex automation projects. Hopefully,
    this chapter will serve as an interesting introduction for you to further explore
    the Jenkins tool.
  prefs: []
  type: TYPE_NORMAL
- en: Jenkins with Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Jenkins provides a full set of REST APIs for its functionalities: [https://wiki.jenkins.io/display/JENKINS/Remote+access+API](https://wiki.jenkins.io/display/JENKINS/Remote+access+API).
    There are also a number of Python wrappers that make the interaction even easier.
    Let''s take a look at the Python-Jenkins package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We can work with the management of the server, such as `plugins`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also manage the Jenkins jobs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Using Python-Jenkins allows us to have a way to interact with Jenkins in a programmatic
    way.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous integration for Networking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Continuous integration has been adopted in the software-development world for
    a while, but it is relatively new to network engineering. We are admittedly a
    bit behind in terms of using continuous integration in our network infrastructure.
    It is no doubt a bit of a challenge to think of our network in terms of code when
    we are still struggling to figure out how to stop using the CLI to manage our
    devices.
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of good examples of using Jenkins for network automation.
    One is by Tim Fairweather and Shea Stewart at AnsibleFest 2017 network track: [https://www.ansible.com/ansible-for-networks-beyond-static-config-templates](https://www.ansible.com/ansible-for-networks-beyond-static-config-templates).
    Another use case was shared by Carlos Vicente from Dyn at NANOG 63: [https://www.nanog.org/sites/default/files/monday_general_autobuild_vicente_63.28.pdf](https://www.nanog.org/sites/default/files/monday_general_autobuild_vicente_63.28.pdf).
  prefs: []
  type: TYPE_NORMAL
- en: Even though continuous integration might be an advanced topic for network engineers
    who are just beginning to learn coding and the toolsets, in my opinion, it is
    worth the effort to start learning and using continuous integration in production
    today. Even at the basic level, the experience will trigger more innovative ways
    for network automation that will no doubt help the industry move forward.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we examined the traditional change-management process and why
    it is not a good fit for today's rapidly changing environment. The network needs
    to evolve with the business to become more agile and adapt to change quickly and
    reliably.
  prefs: []
  type: TYPE_NORMAL
- en: We looked at the concept of continuous integration, in particular the open source
    Jenkins system. Jenkins is a full-featured, expandable, continuous-integration
    system that is widely used in software development. We installed and used Jenkins
    to execute our Python script based on `Paramiko` in a periodic interval with email
    notifications. We also saw how we can install plugins for Jenkins to expand its
    features.
  prefs: []
  type: TYPE_NORMAL
- en: We looked at how we can use Jenkins to integrate with our GitHub repository
    and trigger builds based on code-checking. By integrating Jenkins with GitHub,
    we can utilize the GitHub process of collaboration.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 13](d1720d17-6ae3-4886-89e3-f9ded2c88706.xhtml), *Test-Driven Development
    for Networks*, we will look at test-driven development with Python.
  prefs: []
  type: TYPE_NORMAL
