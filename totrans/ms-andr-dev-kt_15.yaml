- en: Migration to Kotlin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have a legacy project or an existing Java module that you want to migrate
    to Kotlin, migration should be easy. People who made it, thought about this. As
    you remember, Kotlin is interoperable. Because of that, some modules don't need
    full migration; instead, they can be included into a Kotlin project. It's up to
    you to decide. So, let's prepare our migration!
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the migration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refactoring and cleanup
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preparing the migration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we said, we need to make a decision whether we will completely rewrite our
    modules into Kotlin or continue writing our code in Kotlin but keep its legacy
    in pure Java. What will we do? In this chapter, we will demonstrate a little bit
    of each.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our current project, at this point, doesn''t have anything to migrate. So,
    we will create some code. If you don''t have the Java sources directory with the
    packages structure, create it. Now, add the following packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '`activity`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`model`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These packages are equivalent to the packages we already have in our Kotlin
    source code. In the `activity` package, add the following classes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `MigrationActivity.java` code is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '`MigrationActivity2.java`: Make sure it has exactly the same implementation
    as `MigrationActivity.java`. We just need some code base to present and migrate.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Register both activities in the Android `manifest` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the Java code stands together with the Kotlin code without
    any issue. Your Android project can use both! Now, think, do you really need to
    do any conversion at all or are you fine to keep the existing Java stuff? Let''s
    add classes in the `model` package:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Dummy.java` code is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Dummy2.java` code is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s check again if the Kotlin part of the project sees these classes. Create
    a new `.kt` file in the root of your Kotlin sources directory. Let''s call it
    `kotlin_calls_java.kt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, Kotlin doesn't have any problems using the Java code. So, if
    you still want to proceed with the migration, you can do it. No problem. We will
    do so in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Danger signs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Converting huge and complex Java classes into Kotlin is still an option to do.
    Anyway, provide proper unit or instrumentation tests so the functionality of these
    classes is retested after conversion. If any of your tests fails, double-check
    the causes of that failure.
  prefs: []
  type: TYPE_NORMAL
- en: 'The classes you want to migrate can migrate in the following two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Automatic conversion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rewriting by hand
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In case of huge and complex classes, both approaches can give us certain drawbacks.
    Fully automatic conversion can sometimes give you the code that is not the prettiest
    code to look at. So, after you do it, you should recheck and reformat something.
    The second option can take you a lot of time.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion--you can always use the original Java code. From the moment you switch
    to Kotlin as your primary language, you can write all new stuff in Kotlin.
  prefs: []
  type: TYPE_NORMAL
- en: Updating dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you switch 100% pure Java code of the Android project into Kotlin, you have
    to start from the bottom up. This means that your first migration effort will
    be to update your dependencies. You must change your `build.gradle` configuration
    so Kotlin is recognized and source code paths are available. We already explained
    how to do this in [Chapter 1](009df95a-c7b0-4537-adf0-f6c448eb2ade.xhtml), *Starting
    with Android*, in theSetting up Gradle section; so, if your project does not have
    Kotlin-related configuration in it, you have to provide it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s recapitulate our Gradle configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `build.gradle` root project represents the main `build.gradle` file, as
    shown here:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The main application `build.gradle` resolves all the dependencies of the application,
    as shown here:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: These are all the Kotlin-related dependencies you should fulfil. One of them
    is Kotson, providing Kotlin bindings for the `Gson` library.
  prefs: []
  type: TYPE_NORMAL
- en: Converting classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Finally, we will migrate our classes. We have two automatic options available.
    We will use both. Locate `MigrationActivity.java` and open it. Choose the Code
    | Convert Java file to theÂ `Kotlin` file. It takes a couple of seconds to convert.
    Now, drag and drop the file from the `Java` package into the `Kotlin` sources
    package. Observe the following source code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As we have mentioned, fully automatic conversion doesn't give the perfect code.
    In the next section, we will do a refactoring and clean up. The second way to
    do the same thing is by copying and pasting Java code into a `Kotlin` file. Copy
    all source code from `MigrationActivity2`. Create a new Kotlin class with the
    same name and paste the code. If asked, confirm that you wish to perform automatic
    conversion. After the code appears, remove the Java version of the class. Observe
    that the source code is the same as it is for the migrated `MigrationActivity`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Repeat both approaches for `Dummy` and `Dummy2` classes. The classes you get
    will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Dummy`, first `Dummy` class example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '`Dummy2`, the second `Dummy` class example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Dummy2` class has issues with conversion. In this situation, you must
    fix it by yourself. Fix the source code. The problem happened in the following
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Fix it by switching type from `Array<Dummy2> int Array<Dummy2?>` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Simple!
  prefs: []
  type: TYPE_NORMAL
- en: This is exactly the challenge you may face when doing the migration! It's noticeable
    that in both `Dummy` and `Dummy2` classes, we significantly reduced the code base
    by switching to Kotlin. Since there are no Java implementations anymore, we can
    do refactoring and cleanup.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring and cleanup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To have the best possible code after conversion, we must perform refactoring
    and cleanup. We will adapt our code base to conform Kotlin standards and idioms.
    For that purpose, you must read it whole. Only when this is done, we can consider
    our migration done!
  prefs: []
  type: TYPE_NORMAL
- en: 'Open your classes and read the code. There is a lot of space for improvements!
    After you do some work, you should get something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `MigrationActivity` code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, there is not too much work for `MigrationActivity` (and `MigrationActivity2`).
    Both classes are really small. A bigger effort is expected for classes such as
    `Dummy` and `Dummy2`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Dummy` class code is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Dummy2` class code is as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: These two class versions are now drastically improved after refactoring compared
    to their first Kotlin versions after the conversion. Try to compare the current
    versions with the original Java code we had. What do you think?
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discovered the secrets of migration to the Kotlin programming
    language. We demonstrated techniques and gave advice on how to do the migration
    and when. Luckily, for us, it appears that this is not something difficult after
    all! The next chapter will be our last, so, as you already know, it's time to
    publish our application to the world!
  prefs: []
  type: TYPE_NORMAL
