- en: Chapter 8. Reactive Extensions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter we will look at another interesting .NET library that helps
    us create asynchronous programs, the Reactive Extensions (or Rx). You will learn
    the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Converting a collection to asynchronous `Observable`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing custom `Observable`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `Subjects`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an `Observables` object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using LINQ queries against an `Observable` collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating asynchronous operations with Rx
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have already learned, there are several approaches to create asynchronous
    programs in .NET and C#. One of them is event-based asynchronous pattern, which
    was already mentioned in the previous chapters. The initial goal of introducing
    events was to simplify implementation of the `Observer` design pattern. This pattern
    is common for implementing notifications between objects.
  prefs: []
  type: TYPE_NORMAL
- en: When we discussed the Task Parallel Library, we noticed that the event's main
    shortcoming is their inability to be effectively composed with each other. The
    other drawback is that the Event-based Asynchronous Pattern is not supposed to
    be used to deal with the sequence of notifications. Imagine that we have `IEnumerable<string>`
    that gives us string values. However, when we iterate over it, we do not know
    how much time one iteration will take. It could be slow, and if we use the regular
    `foreach` or other synchronous iteration constructs, we will block our thread
    until we have the next value. This situation is called the **pull-based** approach
    when we as a client pull values from the producer.
  prefs: []
  type: TYPE_NORMAL
- en: The opposite approach is the **push-based** approach when the producer notifies
    the client about new values. This allows offloading the work to the producer,
    while the client is free to do anything else in the time it waits for another
    value. Therefore, the goal is to get something like the asynchronous version of
    `IEnumerable`, which produces a sequence of values and notifies the consumer about
    each item in the sequence, when the sequence completes, or when an exception has
    been thrown.
  prefs: []
  type: TYPE_NORMAL
- en: The .NET Framework starting from version 4.0 contains the definition of the
    interfaces `IObservable<out T>` and `IObserver<in T>` that together represent
    the asynchronous push-based collection and its client. They are coming from the
    library called Reactive Extensions (or simply Rx) that was created inside Microsoft
    to help effectively compose the sequence of events and actually all other types
    of asynchronous programs using the observable collections. The interfaces were
    included into the .Net Framework, but their implementations and all other mechanics
    are still distributed separately in the Rx library.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reactive Extensions is a cross-platform library in the first place. There are
    libraries for .NET 3.5, Silverlight, and Windows Phone. It is also available in
    JavaScript, Ruby, and Python. It is also open source; you can find Reactive extensions
    source code for .NET on the CodePlex website and other implementations on GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: The most amazing thing is that the observable collections are compatible with
    LINQ, and therefore, we are able to use declarative queries to transform and compose
    those collections in an asynchronous manner. This also makes it possible to use
    the extension methods to add functionality to the Rx programs the same way it
    is used in the usual LINQ providers. Reactive extensions also support transition
    from all asynchronous programming patterns (including the Asynchronous Programming
    Model, the Event-based Asynchronous Pattern, and the Task Parallel Library) to
    observable collections, and it supports its own way of running asynchronous operations,
    which is still quite similar to TPL.
  prefs: []
  type: TYPE_NORMAL
- en: The Reactive Extensions library is a very powerful and complex instrument, worthy
    of writing a separate book. In this chapter I would like to review the most useful
    scenario, that is, how to work with asynchronous event sequences effectively.
    We will observe key types of the Reactive Extensions framework, learn to create
    sequences and manipulate them in different ways, and finally, check how we could
    use Reactive Extensions to run asynchronous operations and manage their options.
  prefs: []
  type: TYPE_NORMAL
- en: Converting a collection to asynchronous Observable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe walks through how to create an observable collection from an `Enumerable`
    class and how to process it asynchronously.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To step through this recipe, you will need Visual Studio 2012\. No other prerequisites
    are required. The source code for this recipe can be found at `BookSamples\Chapter8\Recipe1`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To understand how to create an observable collection from an `Enumerable` class
    and process it asynchronously, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start Visual Studio 2012\. Create a new C# **Console Application** project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add reference to the **Reactive Extensions Main Library** NuGet package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the **References** folder in the project and select the **Manage
    NuGet Packages…** menu option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now add your preferred reference to the **Reactive Extensions - Main Library**
    NuGet package. You can use search in the **Manage NuGet Packages** dialog, as
    shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![How to do it...](img/7644OT_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the `Program.cs` file, add the following `using` directives:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code snippet below the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code snippet inside the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Run the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We simulate a slow enumerable collection with the `EnumerableEventSequence`
    method. Then we iterate it in the usual `foreach` cycle and we can see that it
    is actually slow; we wait for each iteration to complete.
  prefs: []
  type: TYPE_NORMAL
- en: We then convert this enumerable collection to `Observable` with the help of
    the `ToObservable` extension method from the Reactive Extensions library. Next,
    we subscribe to the updates of this observable collection, providing the `Console.Write`
    method as the action, which will be executed on each update of the collection.
    As a result we get exactly the same behavior as before; we wait for each iteration
    to complete, because we use the main thread to subscribe to the updates.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We wrap the subscription objects into using statements. Although it is not always
    necessary, disposing off the subscriptions is a good practice that will avoid
    you lifetime-related bugs.
  prefs: []
  type: TYPE_NORMAL
- en: To make the program asynchronous, we use the `SubscribeOn` method providing
    it with the TPL task pool scheduler. This scheduler will place the subscription
    to the TPL task pool, offloading the work from the main thread. This allows us
    to keep the UI responsive and do something else, while the collection updates.
    To check this behavior, you could remove the last `Console.ReadLine` call from
    the code. When doing so we finish our main thread immediately, which forces all
    background threads (including the TPL task pool worker threads) to end as well,
    and we will get no output from the asynchronous collection.
  prefs: []
  type: TYPE_NORMAL
- en: If we are using any UI framework, we have to interact with the UI controls only
    from within the UI thread. To achieve this, we should use the `ObserveOn` method
    with the corresponding scheduler. For Windows Presentation Foundation, we have
    the `DispatcherScheduler` class and the `ObserveOnDispatcher` extension method
    defined in a separate NuGet package named Rx-XAML, or Reactive Extensions XAML
    support library. For other platforms there are corresponding separate NuGet packages
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: Writing custom Observable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will describe how to implement the `IObservable<in T>` and `IObserver<out
    T>` interfaces to get the custom Observable sequence and properly consume it.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To step through this recipe, you will need Visual Studio 2012\. No other prerequisites
    are required. The source code for this recipe can be found at `BookSamples\Chapter8\Recipe2`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To understand implementing the `IObservable<in T>` and `IObserver<out T>` interfaces
    to get the custom Observable sequence and consume it, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start Visual Studio 2012\. Create a new C# **Console Application** project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add reference to the **Reactive Extensions Main Library** NuGet package. Refer
    to the *Converting a collection to asynchronous observable* recipe, for details
    on how to do this.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Program.cs` file, add the following `using` directives:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code snippet below the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code snippet inside the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Run the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here we implement our observer first, simply printing out to the console the
    information about the next item from the observable collection, error, or sequence
    completion. It is a very simple consumer code and there is nothing special about
    it.
  prefs: []
  type: TYPE_NORMAL
- en: The interesting part is our observable collection implementation. We accept
    an enumeration of numbers into a constructor, and do not check it for null on
    purpose. When we have a subscribing observer, we iterate over this collection
    and notify the observer about each item in the enumeration.
  prefs: []
  type: TYPE_NORMAL
- en: Then we demonstrate the actual subscription. As we can see, the asynchrony is
    achieved by calling the `SubscribeOn` method, which is an extension method to
    `IObservable` and contains asynchronous subscription logic. We do not care about
    asynchrony in our observable collection; we use standard implementation from the
    Reactive Extensions library.
  prefs: []
  type: TYPE_NORMAL
- en: When we subscribe to the normal observable collection, we just get all the items
    from it. It is now asynchronous, so we need to wait for some time for the asynchronous
    operation to complete, and only then print the message and wait for the user input.
  prefs: []
  type: TYPE_NORMAL
- en: Finally we try to subscribe to the next observable collection, where we are
    iterating over a null enumeration and therefore getting a null reference exception.
    We see that the exception has been properly handled and the `OnError` method was
    executed to print out the error details.
  prefs: []
  type: TYPE_NORMAL
- en: Using Subjects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe shows how to use the Subject type family from the Reactive Extensions
    library.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To step through this recipe, you will need Visual Studio 2012\. No other prerequisites
    are required. The source code for this recipe can be found at `BookSamples\Chapter8\Recipe3`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To understand the use of the Subject type family from the Reactive Extensions
    library, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start Visual Studio 2012\. Create a new C# **Console Application** project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add reference to **Reactive Extensions Main Library** NuGet package. Refer to
    the *Converting a collection to asynchronous observable* recipe for details on
    how to do this.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Program.cs` file, add the following `using` directives:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code snippet below the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code snippet inside the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Run the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this program we look through different variants of a Subject type family.
    Subject represents both the `IObservable` and `IObserver` implementations. This
    is useful in different proxy scenarios when we want to translate events from multiple
    sources to one stream, or vice versa, to broadcast event sequence to multiple
    subscribers. Subjects are also very convenient for experimenting with Reactive
    Extensions.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with the basic Subject type. It retranslates event sequence to subscribers
    as soon as they subscribe to it. In our case, the `A` string will not be printed
    out because the subscription happened after it was transmitted. Besides that,
    when we call the `OnCompleted`, or `OnError` methods on `Observable`, it stops
    further translation of event sequence, so the last string will also not be printed
    out.
  prefs: []
  type: TYPE_NORMAL
- en: The next type, `ReplaySubject`, is quite flexible and allows us to implement
    three additional scenarios. First, it can cache all the events from the beginning
    of their broadcasting, and if we subscribe later, we will get all the preceding
    events first. This behavior is illustrated in the second example. Here, we shall
    have all four strings on the console, because the first event will be cached and
    translated to the latter subscriber.
  prefs: []
  type: TYPE_NORMAL
- en: Then we can specify the buffer size and the time window size for `ReplaySubject`.
    In the next example, we set the subject to have a buffer for two events. If more
    events are broadcasted, only the last two will be retranslated to the subscriber.
    So here we will not see the first string, because we have `B` and `C` in the subject
    buffer when subscribing to it. The same is the case with a time window. We can
    specify that the Subject caches only events that happened less than a certain
    time ago, discarding the older ones. Therefore, in the fourth example, we shall
    see only the last two events; the older events did not fit into the time-window
    limit.
  prefs: []
  type: TYPE_NORMAL
- en: '`AsyncSubject` is something like a `Task` type from the Task Parallel Library.
    It represents a single asynchronous operation. If there are several events published,
    it waits for the event sequence completion and provides only the last event to
    the subscriber.'
  prefs: []
  type: TYPE_NORMAL
- en: '`BehaviorSubject` is quite similar to the `ReplaySubject` type, but it caches
    only one value and allows specifying a default value in case we did not send any
    notifications yet. In our last example, we shall see all the strings printed out,
    because we provided a default value, and all other events happened already after
    the subscription. If we move `behaviorSubject.OnNext("B");` line upwards below
    the `Default` event, it will replace the default value in the output.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating an Observable object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will describe different ways to create an `Observable` object.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To step through this recipe, you will need a running Visual Studio 2012\. No
    other prerequisites are required. The source code for this recipe could be found
    at `BookSamples\Chapter8\Recipe4`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To understand different ways of creating an `Observable` object, perform the
    following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start Visual Studio 2012\. Create a new C# **Console Application** project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add reference to the **Reactive Extensions Main Library** NuGet package. Refer
    to the *Converting a collection to asynchronous Observable* recipe for details
    on how to do this.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Program.cs` file, add the following `using` directives:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code snippet below the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code snippet inside the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Run the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here, we walk through different scenarios of creating `observables`. Most of
    this functionality is provided as static factory methods of the `Observable` type.
    The first two samples show how we can create an `Observable` method that produces
    a single value and one that produces no value. In the next example we use `Observable.Throw`
    to construct an `Observable` class that triggers the `OnError` handler of its
    observers.
  prefs: []
  type: TYPE_NORMAL
- en: The `Observable.Repeat` method represents an endless sequence. There are different
    overloads of this method; here, we constructed an endless sequence by repeating
    42 values. Then we use LINQ's `Take` method to take five elements from this sequence.
    `Observable.Range` represents a range of values, pretty much like `Enumerable.Range`.
  prefs: []
  type: TYPE_NORMAL
- en: The `Observable.Create` method supports more custom scenarios. There are a lot
    of overloads allowing us to use cancellation tokens and tasks, but let's look
    at the simplest one. It accepts a function, which accepts an instance of observer,
    and returns an `IDisposable` object representing a subscription. If we had any
    resources to cleanup, we would be able to provide the cleanup logic here, but
    we just return an empty disposable as we actually do not need it.
  prefs: []
  type: TYPE_NORMAL
- en: '`Observable.Generate` is another way to create a custom sequence. We must provide
    an initial value for a sequence, then a predicate that determines if we should
    generate more items, or complete the sequence. Then we provide an iteration logic,
    which is incrementing a counter in our case. The last parameter is a selector
    function, allowing us to customize the results.'
  prefs: []
  type: TYPE_NORMAL
- en: The last two methods deal with timers. `Observable.Interval` starts producing
    timer tick events with the `TimeSpan` period, and `Observable.Timer` specifies
    the startup time as well.
  prefs: []
  type: TYPE_NORMAL
- en: Using LINQ queries against the observable collection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe shows how to use LINQ to query an asynchronous sequence of events.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To step through this recipe, you will need Visual Studio 2012\. No other prerequisites
    are required. The source code for this recipe can be found at `BookSamples\Chapter8\Recipe5`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To understand using LINQ queries against the observable collection, perform
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start Visual Studio 2012\. Create a new C# **Console Application** project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add reference to **Reactive Extensions Main Library** NuGet package. Refer to
    the *Converting a collection to asynchronous observable* recipe for details on
    how to do this.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Program.cs` file, add the following `using` directives:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code snippet below the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code snippet inside the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Run the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The ability to use LINQ against the `Observable` event sequences is the main
    advantage of the Reactive Extensions framework. There are many different useful
    scenarios; unfortunately, it is impossible to show all of them here. I tried to
    provide a simple, yet very illustrative example, which does not have many complex
    details and shows the very essence of how a LINQ query could work when applied
    to asynchronous observable collections.
  prefs: []
  type: TYPE_NORMAL
- en: First, we create an `Observable` event that generates a sequence of numbers,
    one number every 50 milliseconds, and we start from the initial value of zero,
    taking twenty-one of those events. Then, we compose LINQ queries to this sequence.
    First, we select only the even numbers from the sequence, then only the odd numbers,
    and then we concatenate these two sequences.
  prefs: []
  type: TYPE_NORMAL
- en: The final query shows how to use a very useful method `Do`, which allows introducing
    side effects and, for example, logging each value from the resulting sequence.
    To run all queries, we create nested subscriptions, and because the sequences
    are initially asynchronous, we have to be very careful about the subscription's
    lifetime. The outer scope represents a subscription to the timer, the inner subscriptions
    deal with the combined sequence query and the side effects query, respectively.
    If we press *Enter* too early, we just unsubscribe from the timer and thus stop
    the demo.
  prefs: []
  type: TYPE_NORMAL
- en: When we run the demo, we see the actual process of how different queries interact
    in real time. We can see that our queries are lazy, and they start running only
    when we subscribe to their results. The timer events sequence is printed in the
    first column. When the even numbers query gets an even number, it prints it out
    as well using the `---` prefix to distinguish this sequence result from the first
    one. The final query results are printed to the right column.
  prefs: []
  type: TYPE_NORMAL
- en: When the program runs, we can see that the timer sequence, the even numbers
    sequence, and the side effect sequence are running in parallel. Only the concatenation
    waits until the even numbers sequence is complete. If we do not concatenate those
    sequences, we will have four parallel sequences of events interacting with each
    other in the most effective way! This shows the real power of Reactive Extensions,
    and could be a good start to learn this library in depth.
  prefs: []
  type: TYPE_NORMAL
- en: Creating asynchronous operations with Rx
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe shows how to create `Observable` from the asynchronous operations
    defined in other programming patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To step through this recipe, you will need Visual Studio 2012\. No other prerequisites
    are required. The source code for this recipe can be found at `BookSamples\Chapter8\Recipe6`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To understand how to create asynchronous operations with Rx, perform the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start Visual Studio 2012\. Create a new C# **Console Application** project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add reference to **Reactive Extensions Main Library** NuGet package. Refer to
    the *Converting a collection to asynchronous observable* recipe for details on
    how to do this.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Program.cs` file, add the following `using` directives:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code snippet below the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code snippet inside the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Run the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe shows how to convert different types of asynchronous operations
    to an `Observable` class. The first code snippet in step 5 uses the `Observable.Start`
    method, which is quite similar to `Task.Run` from TPL. It starts an asynchronous
    operation that gives out a string result and then completes.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I would strongly suggest using Task Parallel Library for asynchronous operations.
    Reactive Extensions supports this scenario as well, but to avoid ambiguity it
    is much better to stick with tasks when speaking about separate asynchronous operations
    and go with Rx only when we need to work with sequences of events. Another suggestion
    is to convert every type of separate asynchronous operation to tasks and only
    then convert a task to an `observable` class, if you need it.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we do the same with tasks and convert a task to an `Observable` method
    by simply calling the `ToObservable` extension method. The next code snippet shown
    in step 5 is about converting Asynchronous Programming Model pattern to `Observable`.
    Normally, you would convert APM to a task, and then a task to `Observable`. However,
    there is a direct conversion, and this example illustrates how to run an asynchronous
    delegate and wrap it into an `Observable` operation.
  prefs: []
  type: TYPE_NORMAL
- en: The next part of the code snippet in step 5 shows that we are able to `await`
    an `Observable` operation. As we are not able to use the `async` modifier on an
    entry method such as `Main`, we introduce a separate method that returns a task
    and waits for this resulting task to complete inside the `Main` method.
  prefs: []
  type: TYPE_NORMAL
- en: The last part of this code snippet in step 5 is the same, but now we convert
    Event-based Asynchronous Pattern directly to an `Observable` class. We create
    a timer and consume its events for 5 seconds. We then dispose the timer to clean
    up the resources.
  prefs: []
  type: TYPE_NORMAL
