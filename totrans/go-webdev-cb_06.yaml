- en: Writing Microservices in Go Using Micro – a Microservice Toolkit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating your first protocol buffer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spinning up a microservice discovery client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating your first microservice
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating your second microservice
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating your Micro API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interacting with microservices using a command-line interface and web UI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With organizations now moving toward DevOps, microservices have started gaining
    popularity as well. As these services are independent in nature and can be developed
    in any language it allows organizations to focus on their development. With knowledge
    of the concepts covered in this chapter, we will be able to write microservices using
    Go Micro in a fairly easy way.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will start by writing the protocol buffer. Then we will
    learn how we can spin up Consul, which is a Microservice discovery client, and
    eventually move on to create microservices and interact with them through the
    command line and web dashboard.
  prefs: []
  type: TYPE_NORMAL
- en: Creating your first protocol buffer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Protocol buffers are a flexible, efficient, and automated mechanism for encoding
    and serializing structured data supported by Go. In this recipe, we will learn
    how to write our first protocol buffer.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Verify whether `protoc` is installed by executing the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Install `protobuf` by way of the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create `hello.proto` inside the `proto` directory and define a `service` interface
    with the name `Say`, which has two datatypes—`Request` and `Response`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Compile `hello.proto` with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once the command has executed successfully, `hello.pb.go` will be created inside
    the `proto` directory, which will look like as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e6c3c506-21d5-499e-8258-e1c595f129fb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s understand the `.proto` file we have written:'
  prefs: []
  type: TYPE_NORMAL
- en: '`syntax = "proto3";`: Here we specify that we are using `proto3` syntax, which
    makes the compiler understand that the protocol buffer has to be compiled with
    version 3\. If we don''t specify the syntax explicitly then the compiler assumes
    we are using `proto2`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`service Say { rpc Hello(Request) returns (Response) {} }`: Here we defined
    an RPC service with the name `Say` and a `Hello` method that takes `Request` and
    returns a `Response`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`message Request { string name = 1; }`: Here we defined the `Request` data
    type that has a `name` field.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`message Response { string msg = 1; }`: Here we defined the `Response` data
    type that has a `msg` field.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spinning up a microservice discovery client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a microservices architecture where multiple services are deployed, the service
    discovery client helps the application to find out the services they are dependent
    on, which can be either through DNS or HTTP. When we talk about service discovery
    clients one of the most common and famous is `Consul` by HashiCorp, which we will
    be spinning up in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Verify whether `Consul` is installed by executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Start `consul agent` in server mode by executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once the command has executed successfully the Consul agent starts running
    in server mode, giving us the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a92cdd9a-1d8a-4f8c-9590-403457ed9e18.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can also list the members of the Consul cluster by executing the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This will give us the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/49a2e1e2-9503-4260-8d73-c53721654e1b.png)'
  prefs: []
  type: TYPE_IMG
- en: Because Consul can be run either in server or client mode with at least one
    server, to keep the setup at a bare minimum we have started our agent in server
    mode, though it is not recommended because there are chances of data loss in a
    failure scenario.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moreover, browsing to `http://localhost:8500/ui/` will display the Consul web
    UI where we can view all the services and nodes, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7204b5d2-47f8-41b7-a5eb-1f7bee423eec.png)'
  prefs: []
  type: TYPE_IMG
- en: Creating your first microservice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A microservice is just a piece of code that runs as a unique process and communicates
    through a well-defined, lightweight mechanism to serve a business goal, which
    we will be writing in this recipe using `https://github.com/micro/micro` though
    there are a number of libraries available such as `https://github.com/go-kit/kit` and `https://github.com/grpc/grpc-go`, which
    serve the same purpose.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Start `consul agent` by executing the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Install and run `micro` by executing the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create `first-greeting-service.go` inside the `services` directory by executing
    the command `$ mkdir services && cd services && touch first-greeting-service.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Copy the following content to `first-greeting-service.go`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'With everything in place, the directory structure should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ed19fcaf-f4ff-4c02-aab8-a6df9c1da93d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Move to the `services` directory and run the program with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once we run the program, the RPC server will start locally listening on port `8080`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, execute a `POST` request from the command line as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This will give us Hello followed by the name as a response from the server
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e40538e4-a0ce-4817-8c4e-24a2c9b8b33c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Looking at the logs of the `first-greeting-service.go` will show us that the
    request is served by the first greeting service, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f0b1e3d4-0295-44c0-a864-5fff2aec62b4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s look at the program we have written:'
  prefs: []
  type: TYPE_NORMAL
- en: Using `import ("log" "time" hello "../proto" "github.com/micro/go-micro" "golang.org/x/net/context")`,
    we imported `"hello "../proto"`, a directory that includes protocol buffer source
    code and compiled protocol buffer suffixed `.pb.go`. Additionally, we imported
    the `github.com/micro/go-micro` package, which consists of all the libraries required
    to write the microservice.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we defined a `main()` handler where we create a new service with the name `go.micro.service.greeter`
    using `micro.NewService()`, initialize it, register the handler with it, and finally
    start it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating your second microservice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will create another microservice using `go-micro`, which
    is a replica of the `first-greeting-service.go` except for the logger message
    printed on the console that demonstrates the concept of client-side load balancing
    between the two different instances of a service with the same name.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create `second-greeting-service.go` inside the `services` directory by executing
    the command `$ cd services && touch second-greeting-service.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Copy the following content to `second-greeting-service.go`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'With everything in place, the directory structure should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f9dc5e14-ac7d-451b-94a5-0ff6ec6eca55.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Move to the `services` directory and run the program with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once we run the program, the RPC server will start locally listening on port `8080`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, execute a `POST` request from the command line as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This will give us Hello followed by the name as a response from the server,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4575909c-9536-4bdb-b86e-cd1b65b10d01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Looking at the logs of the `second-greeting-service.go` will show us the request
    is served by the second greeting service:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ea73a7c0-7ec3-46ad-8bc9-e7743f1a47b4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, if we execute a `POST` request again then it will print the logs in the `first-greeting-service.go`
    console, which is because of the smart, client-side, load balancing of services
    built on discovery offered by Go Micro:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/054f15ff-427a-4a86-bd7e-b9b08c09b102.png)'
  prefs: []
  type: TYPE_IMG
- en: Creating your Micro API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have explicitly called a backend service by name and a method to
    access it. In this recipe, we will learn how we can access the services using
    Go Micro API, which implements an API gateway pattern to provide a single entry
    point to the microservices. The advantage of using Go Micro API is that it serves
    over HTTP and dynamically routes to the appropriate backend service using HTTP
    handlers.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Start `consul agent`, `micro API`, `first-greeting-service.go`, and `second-greeting-service.go` in
    separate terminals by executing the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create `greeting-api.go` inside the `api` directory by executing the command `$
    mkdir api && cd api && touch greeting-api.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Copy the following content to `greeting-api.go`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'With everything in place, the directory structure should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d5987017-7916-4937-b535-e7dc02a41da8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Move to the `api `directory and run the program with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once we run the program, the HTTP server will start locally listening on port `8080`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, browse to `http://localhost:8080/greeter/say/hello?name=Arpit+Aggarwal` as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3da80faa-0f64-491e-8b1c-f1783f6c1355.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This will give you the response Hello followed by the name received as an HTTP
    request variable. Moreover, looking at the logs of the `second-greeting-service.go` will
    show us the request is served by the second greeting service, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ffe18d8b-281f-4b8d-a22f-6a764c882ccb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, if we execute a `GET` request again then it will print the logs in the `first-greeting-service.go` console,
    which is because of the smart, client-side, load balancing of services built on
    discovery offered by Go Micro:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/41a961ff-1753-4825-bccf-869524273f25.png)'
  prefs: []
  type: TYPE_IMG
- en: Interacting with microservices using a command-line interface and web UI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have used the command line to execute `GET` and `POST` HTTP requests
    to access services. This can also be achieved by way of the Go Micro web user
    interface as well. All we need to do is start `micro web`, which we will be covering
    in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Install the `go get github.com/micro/micro` package using the `go get` command,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the web UI with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once a command has executed successfully, browsing to `http://localhost:8082/registry`
    will list all the registered services as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b2a878e4-9849-4592-83bc-120587f5a12b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Querying our `greeter` service using the web UI with the request `{"name" :
    "Arpit Aggarwal"}` will render you the response, `{"msg": "Hello Arpit Aggarwal"} `:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/900737b2-6989-4e39-b4d2-632c3494285c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Querying the same `greeter` service using a `CLI` command, `query go.micro.service.greeter
    Say.Hello {"name" : "Arpit Aggarwal"}` will render you the response, `{"msg":
    "Hello Arpit Aggarwal"}`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cb86a401-112a-4f99-8c58-88b27c501957.png)'
  prefs: []
  type: TYPE_IMG
