- en: Framebuffer Drivers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Video cards always have a certain amount of RAM. This RAM is where the bitmap
    of image data is buffered for display. From the software point of view, the framebuffer
    is a character device providing access to this RAM.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'That said, a framebuffer driver provides an interface for:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Display mode setting
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory access to the video buffer
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic 2D acceleration operations (for example, scrolling)
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To provide this interface, the framebuffer driver generally talks to the hardware
    directly. There are well-known framebuffer drivers such as:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: '**intelfb** , which is a framebuffer for various Intel 8xx/9xx compatible graphic
    devices'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**vesafb** , which is a framebuffer driver that uses the VESA standard interface
    to talk to the video hardware'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**mxcfb** , the framebuffer driver for i.MX6 chip series'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Framebuffer drivers are the simplest form of graphics drivers under Linux, not
    to confuse them with X.org drivers, which implement advanced features such as
    3D acceleration and so on, or Kernel mode setting (KMS) drivers, which expose
    both framebuffer and GPU functionalities (like X.org drivers do).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: i.MX6 X.org driver is a closed source and called **vivante.**
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: 'Back to our framebuffer drivers, they are very simple API drivers that expose
    video card functionalities by means of character devices, accessible from the
    user space through `/dev/fbX` entries. One can find more information on Linux
    graphical stack in the comprehensive talk *Linux Graphics Demystified* by Martin
    Fiedler: [http://keyj.emphy.de/files/linuxgraphics_en.pdf](http://keyj.emphy.de/files/linuxgraphics_en.pdf)
    .'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we cover the following topics:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Framebuffer driver data structures and methods, thus covering the whole driver
    architecture
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Framebuffer device operations, accelerated and non-accelerated
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing framebuffer from user space
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Driver data structures
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The framebuffer drivers depend heavily on four data structures, all defined
    in `include/linux/fb.h` , which is also the header you should include in your
    code in order to deal with framebuffer driver:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: These structures are `fb_var_screeninfo` , `fb_fix_screeninfo` , `fb_cmap` ,
    and `fb_info` . The first three are made available to and from user space code.
    Now let us describe the purpose of each structure, their meaning, and what they
    are used for.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: 'The kernel use an instance of `struct struct fb_var_screeninfo` to hold variable
    properties of the video card. These values are those defined by the user, such
    as resolution depth:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This can be summarized into a figure shown as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00043.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
- en: 'There are properties of video card that are fixed, either by the manufacturer,
    or applied when a mode is set, and can''t be changed otherwise. This is generally
    hardware information. A good example of this is the start of the framebuffer memory,
    which cannot change, even by user program. The kernel holds such information in
    an instance of `struct fb_fix_screeninfo` structure:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The struct `fb_cmap` structure specifies the color map, which is used to store
    the user''s definition of colors in a manner the kernel can understand, in order
    to send it to the underlying video hardware. One can use this structure to define
    the RGB ratio that you desire for different colors:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `struct fb_info` structure, which represents the framebuffer itself, is
    the main data structure of framebuffer drivers. Unlike other preceding structure
    discussed, `fb_info` exists only in the kernel, and is not part of the user space
    framebuffer API:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`struct fb_info` structure should always be allocated dynamically, using `framebuffer_alloc()`
    , which is a kernel (framebuffer core) helper functions to allocate memory for
    instance of framebuffer devices, along with their private data memory:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In this prototype, `size` represents the size of the private area as an argument
    and appends that to the end of the allocated `fb_info` . This private area can
    be referenced using the `.par` pointer in the `fb_info` structure. `framebuffer_release()`
    does the reverse operation:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Once set up, a framebuffer should be registered with the kernel using `register_framebuffer()`
    , which returns negative `errno` on error, or `zero` for success:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Once registered, one can unregister the framebuffer with the `unregister_framebuffer()`
    function, which also returns a negative `errno` on error, or `zero` for success:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Allocation and registering should be done during the device probing, whereas
    unregistering and deallocation (release) should be done from within the driver's
    `remove()` function.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Device methods
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the `struct fb_info` structure, there is a `.fbops` field, which is an instance
    of `struct fb_ops` structure. This structure contains a collection of functions
    that need to perform some operations on the framebuffer device. These are entry
    points for `fbdev` and `fbcon` tools. Some methods in that structure are mandatory,
    the minimum required for a framebuffer to work, whereas others are optional, and
    depend on the features the driver needs to expose, assuming the device itself
    supports those features.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the definition of the `struct fb_ops` structure:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Different callbacks can be set depending on what functionality one wishes to
    implement.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 4](http://character) , *Character Device Drivers* , we learned that
    character devices, by means of `struct file_operations` structure, can export
    a collection of file operations, which are entry points for file-related system
    calls such as `open()` , `close()` , `read()` , `write()` , `mmap()` , `ioctl()`
    , and so on.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: That being said, do not confuse `fb_ops` with `file_operations` structure. `fb_ops`
    offers an abstraction of low-level operations, while `file_operations` is for
    an upper-level system call interface. The kernel implements framebuffer file operations
    in `drivers/video/fbdev/core/fbmem.c` , which internally call methods we defined
    in `fb_ops` . In this manner, one can implement the low-level hardware operations
    according to the need of the system call interface, namely the `file_operations`
    structure. For example, when the user `open()` the device, the core's open file
    operation method will perform some core operations, and execute `fb_ops.fb_open()`
    method if set, same for `release` , `mmap` , and so on.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Framebuffer devices support some ioctl commands defined in `include/uapi/linux/fb.h`
    , that user programs can use to operate on hardware. These commands are all handled
    by the core's `fops.ioctl` method. For some of those commands, the core's ioctl
    method may internally execute methods defined in `fb_ops` structure.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: One may wonder what the `fb_ops.ffb_ioctl` is used for. The framebuffer core
    executes `fb_ops.fb_ioctl` only when the given ioctl command is not known to the
    kernel. In other words, `fb_ops.fb_ioctl` is executed in the default statement
    of the framebuffer core's `fops.ioctl` method.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: Driver methods
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Drivers methods consist of `probe()` and `remove()` functions. Prior to going
    further in these method descriptions, let us set up our `fb_ops` structure:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`Probe` : Driver `probe` function is in charge of initializing the hardware,
    creating the `struct fb_info` structure using `framebuffer_alloc()` function,
    and `register_framebuffer()` on it. The following sample assumes the device is
    memory mapped. Therefore, your nonmemory map can exist, such as screen sitting
    on SPI buses. In this case, bus specific routines should be used:'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`Remove` : The `remove()` function should release whatever was acquired in
    `probe()` , and call:'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Assuming you used the manager version for resource allocations, you'll just
    need to use `unregister_framebuffer()` and `framebuffer_release()` . Everything
    else will be done by the kernel.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detailed fb_ops
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let us describe some of the hooks declared in `fb_ops` structure. That being
    said, for an idea on writing framebuffer drivers, you can have a look at `drivers/video/fbdev/vfb.c`
    , which is a simple virtual framebuffer driver in the kernel. One can also have
    a look at other specific framebuffer drivers, like i.MX6 one, at `drivers/video/fbdev/imxfb.c`
    , or at the kernel documentation about framebuffer driver API at `Documentation/fb/api.txt`
    .
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: Checking information
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The hook `fb_ops->fb_check_var` is responsible for checking framebuffer parameters.
    Its prototype is as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This function should check framebuffer variable parameters and adjust to valid
    values. `var` represents the framebuffer variable parameters, which should be
    checked and adjusted:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The preceding code adjusts variable framebuffer properties according to the
    configuration chosen by user.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Set controller's parameters
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The hook `fp_ops->fb_set_par` is another hardware specific hook, responsible
    for sending parameters to the hardware. It programs the hardware based on user
    settings `(info->var` ):'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Screen blanking
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The hook `fb_ops->fb_blank` is a hardware specific hook, responsible for screen
    blanking. Its prototype is as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`blank_mode` parameter is always one of the following values:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The usual way of blank display is to do a `switch case` on the `blank_mode`
    parameter as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Blanking operation should disable the controller, stop its clocks and power
    it down. Unblanking should perform the reverse operations.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: Accelerated methods
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Users video operations such as blending, stretching, moving bitmaps, or dynamic
    gradient generation are all heavy-duty tasks. They require graphics acceleration
    to obtain acceptable performance. One can implement framebuffer accelerated methods
    using the following fields of `struct fp_ops` structure:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '`.fb_imageblit()` : This method draws an image on the display and is very useful'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.fb_copyarea()` : This method copies a rectangular area from one screen region
    to another'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.fb_fillrect():` This method fills in an optimized manner a rectangle with
    pixel lines'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Therefore, kernel developers thought of controllers that did not have hardware
    acceleration, and provided a software-optimized method. This makes acceleration
    implementation optional, since software fall-back exists. That said, if the framebuffer
    controller does not provide any acceleration mechanism, one must populate these
    methods using the kernel generic routines.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: 'These are respectively:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '`cfb_imageblit()` : This is a kernel-provided fallback for imageblit. The kernel
    uses it to output a logo to the screen during boot up.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cfb_copyarea()` : This is for area copy operations.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cfb_fillrect` (): This is the framebuffer core non-accelerated method to achieve
    operations of the same name.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Putting it all together
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, let us summarize things discussed in the preceding section.
    In order to write framebuffer driver, one has to:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: Fill a `struct fb_var_screeninfo` structure in order to provide information
    on framebuffer variable properties. Those properties can be changed by user space.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fill a `struct fb_fix_screeninfo` structure, to provide fixed parameters.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set up a `struct fb_ops` structure, providing necessary callback functions,
    which will used by the framebuffer subsystem in response to user actions.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Still in the `struct fb_ops` structure, one has to provide accelerated functions
    callback, if supported by the device.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set up a `struct fb_info` structure, feeding it with structures filled in previous
    steps, and call `register_framebuffer()` on it in order to have it registered
    with the kernel.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For an idea on writing a simple framebuffer driver, one can have a look at `drivers/video/fbdev/vfb.c`
    , which is a virtual framebuffer driver in kernel. One can enable this in the
    kernel by means of the `CONGIF_FB_VIRTUAL` option.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: Framebuffer from user space
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One usually accesses framebuffer memory by means of `mmap()` command in order
    to map the framebuffer memory to the part of system RAM, so that drawing pixels
    on the screen becomes a simple matter affecting memory value. Screen parameters
    (variable and fixed) are extracted by means of ioctl commands, especially `FBIOGET_VSCREENINFO`
    and `FBIOGET_FSCREENINFO` . The complete list is available at `include/uapi/linux/fb.h`
    in the kernel source.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 通常通过`mmap()`命令访问帧缓冲内存，以便将帧缓冲内存映射到系统RAM的某个部分，从而在屏幕上绘制像素变得简单，影响内存值。屏幕参数（可变和固定）是通过ioctl命令提取的，特别是`FBIOGET_VSCREENINFO`和`FBIOGET_FSCREENINFO`。完整列表可在内核源代码的`include/uapi/linux/fb.h`中找到。
- en: 'The following is a sample code to draw a 300*300 square on the framebuffer:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在帧缓冲上绘制300*300正方形的示例代码：
- en: '[PRE19]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'One can also dump the framebuffer memory into a raw image, using `cat` or `dd`
    command:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以使用`cat`或`dd`命令将帧缓冲内存转储为原始图像：
- en: '[PRE20]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Write it back using:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令将其写回：
- en: '[PRE21]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'It is possible to blank/unblank the screen through a special `/sys/class/graphics/fb<N>/blank
    sysfs` file, where `<N>` is the framebuffer index. Writing a 1 will blank the
    screen, whereas 0 will unblank it:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过特殊的`/sys/class/graphics/fb<N>/blank sysfs`文件来使屏幕变暗/恢复亮度，其中`<N>`是帧缓冲索引。写入1将使屏幕变暗，而0将使其恢复亮度：
- en: '[PRE22]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Summary
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: The framebuffer drivers are the simplest form of Linux graphics drivers, requiring
    little implementation work. They heavily abstract hardware. At this stage, you
    should be able to enhance either an existing driver (with graphical acceleration
    functions for example), or write a fresh one from scratch. However, it is recommended
    to rely on an existing driver whose hardware shares as many characteristics as
    possible with the one you need to write the driver for. Let us jump to the next
    and last chapter, dealing with network devices.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 帧缓冲驱动程序是Linux图形驱动程序的最简单形式，需要很少的实现工作。它们对硬件进行了很大的抽象。在这个阶段，您应该能够增强现有的驱动程序（例如具有图形加速功能），或者从头开始编写一个全新的驱动程序。但是，建议依赖于一个现有的驱动程序，其硬件与您需要编写驱动程序的硬件共享尽可能多的特征。让我们跳到下一个也是最后一个章节，处理网络设备。
