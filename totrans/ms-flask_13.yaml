- en: Chapter 13. Deploying Flask Apps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have reached the last chapter of the book and have a fully functioning
    web app made in Flask, the final step to take in our development is to make the
    app available for the world. There are many different approaches to host your
    Flask app, each of them with their own pros and cons. This chapter will cover
    the best solutions and guide you in what situations you should choose one over
    the other.
  prefs: []
  type: TYPE_NORMAL
- en: Note that, in this chapter, the term server is used to refer to the physical
    machine that is running the operating system. But, when the term web server is
    used, it refers to the program on the server that receives HTTP requests and sends
    responses.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying on your own server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most common way to deploy any web app is to run it on a server that you
    have control over. In this case, control means access to a terminal on the server
    with an administrator account. This type of deployment gives you the most amount
    of freedom out of the other choices as it allows you to install any program or
    tool you wish. This is in contrast to other hosting solutions where the web server
    and database are chosen for you. This type of deployment also happens to be the
    least expensive option.
  prefs: []
  type: TYPE_NORMAL
- en: The downside to this freedom is that you take the responsibility of keeping
    the server up, backing up user data, keeping the software on the server up to
    date to avoid security issues, and so on. All books have been written on good
    server management. So if this is not a responsibility that you believe you or
    your company can handle, it would be best if you choose one of the other deployment
    options.
  prefs: []
  type: TYPE_NORMAL
- en: This section will be based on a Debian Linux-based server, as Linux is far and
    away the most popular OS to run web servers and Debian is the most popular Linux
    distro (a particular combination of software and the Linux kernel released as
    a package). Any OS with bash and a program named SSH (which will be introduced
    in the next section) will work for this chapter. The only differences will be
    the command-line programs to install software on the server.
  prefs: []
  type: TYPE_NORMAL
- en: Each of these web servers will use a protocol named **Web Server Gateway Interface**
    (**WSGI**), which is a standard designed to allow Python web applications to easily
    communicate with web servers. We will never directly work with WSGI, but most
    of the web server interfaces we will be using will have WSGI in their name and
    it can be confusing if you don't know what it is.
  prefs: []
  type: TYPE_NORMAL
- en: Pushing code to your server with fabric
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To automate the process of setting up and pushing our application code to the
    server, we will use a Python tool named fabric. Fabric is a command-line program
    that reads and executes Python scripts on remote servers using a tool named SSH.
    SSH is a protocol that allows a user of one computer to remotely log in to another
    computer and execute commands on the command line, provided that the user has
    an account on the remote machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install `fabric`, we will use `pip` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '`fabric` commands are collections of command-line programs to be run on the
    remote machine''s shell, in this case, bash. We are going to make three different
    commands: one to run our unit tests, one to set up a brand new server to our specifications,
    and one to have the server update its copy of the application code with `git`.
    We will store these commands in a new file at the root of our project directory
    named `fabfile.py`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As it''s the easiest to create, let''s make the test command first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'To run this function from the command line, we can use `fabric` command-line
    interface by passing the name of the command to run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Fabric has three main commands: `local`, `run`, and `sudo`. The `local` function,
    as seen in the preceding function, `run` commands on the local computer. The `run`
    and `sudo` functions run commands on a remote machine, but `sudo` runs commands
    as an administrator. All of these functions notify fabric whether the command
    ran successfully or not. If the command didn''t run successfully, which means
    that, in this case, our tests failed, any other commands in the function will
    not be run. This is useful for our commands because it allows us to force ourselves
    not to push any code to the server that does not pass our tests.'
  prefs: []
  type: TYPE_NORMAL
- en: Now we need to create the command to set up a new server from scratch. What
    this command will do is install the software that our production environment needs
    as well as downloads the code from our centralized `git` repository. It will also
    create a new user that will act as the runner of the web server as well as the
    owner of the code repository.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Do not run your web server or have your code deployed by the root user. This
    opens your application to a whole host of security vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'This command will differ based on your operating system, and we will be adding
    this command in the rest of the chapter based on what server you choose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: There are two new fabric features in this script. The first is the `env.hosts`
    assignment, which tells fabric the user and IP address of the machine it should
    be logging in to. Second, there is the `cd` function used in conjunction with
    the with keyword, which executes any functions in the context of that directory
    instead of the home directory of the deploy user. The line that modifies the `git`
    configuration is there to tell `git` to remember your repository's username and
    password, so you do not have to enter it every time you wish to push code to the
    server. Also, before the server is set up, we make sure to update the server's
    software to keep the server up to date.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we have the function to push our new code to the server. In time, this
    command will also restart the web server and reload any configuration files that
    come from our code. But that depends on the server you choose, so this is filled
    out in the subsequent sections.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'So, if we were to begin working on a new server, all we would need to do to
    set it up is to run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Running your web server with supervisor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have automated our updating process, we need some program on the
    server to make sure that our web server, and database if you aren't using SQLite,
    is running. To do this, we will use a simple program called supervisor. All that
    supervisor does is automatically runs command-line programs in background processes
    and allows you to see the status of the running programs. Supervisor also monitors
    all of the processes it's running, and if the process dies, it tries to restart
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install `supervisor`, we need to add it to the setup command in our `fabfile.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: To tell `supervisor` what to do, we need to create a configuration file and
    then copy it to the `/etc/supervisor/conf.d/` directory of our server during the
    deploy `fabric` command. `Supervisor` will load all of the files in this directory
    when it starts and attempts to run them.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a new file in the root of our project directory named `supervisor.conf`,
    add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is the bare minimum configuration needed to get a web server up and running.
    But, supervisor has a lot more configuration options. To view all of the customizations,
    go to the supervisor documentation at [http://supervisord.org/](http://supervisord.org/).
  prefs: []
  type: TYPE_NORMAL
- en: This configuration tells `supervisor` to run a command in the context of `/home/deploy/webapp`
    under the `deploy` user. The right hand of the command value is empty because
    it depends on what server you are running and will be filled in for each section.
  prefs: []
  type: TYPE_NORMAL
- en: Now we need to add a `sudo` call in the deploy command to copy this configuration
    file to the `/etc/supervisor/conf.d/` directory as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: A lot of projects just create the files on the server and forget about them,
    but having the configuration file stored in our `git` repository and copied on
    every deployment gives several advantages. First, this means that it is easy to
    revert changes if something goes wrong using `git`. Second, it means that we don't
    have to log in to our server in order to make changes to the files.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Don't use the Flask development server in production. It not only fails to handle
    concurrent connections but also allows arbitrary Python code to be run on your
    server.
  prefs: []
  type: TYPE_NORMAL
- en: Gevent
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The simplest option to get a web server up and running is to use a Python library
    named gevent to host your application. Gevent is a Python library that adds an
    alternative way of doing concurrent programming outside the Python threading library
    called **co-routines**. Gevent has an interface to run WSGI applications that
    is both simple and has good performance. A simple gevent server can easily handle
    hundreds of concurrent users, which is 99% more than the users of websites on
    the Internet will ever have. The downside to this option is that its simplicity
    means a lack of configuration options. There is no way, for example, to add rate
    limiting to the server or to add HTTPS traffic. This deployment option is purely
    for sites that you don't expect to receive a huge amount of traffic. Remember
    YAGNI; only upgrade to a different web server if you really need to.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Co-routines are a bit outside of the scope of this book, so a good explanation
    can be found at [https://en.wikipedia.org/wiki/Coroutine](https://en.wikipedia.org/wiki/Coroutine).
  prefs: []
  type: TYPE_NORMAL
- en: 'To install `gevent`, we will use `pip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In a new file in the root of the project directory named `gserver.py`, add
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'To run the server with supervisor, just change the command value to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Now when you deploy, `gevent` will be automatically installed for you by running
    your `requirements.txt` on every deployment, that is, if you are properly pip
    freezing after every new dependency is added.
  prefs: []
  type: TYPE_NORMAL
- en: Tornado
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Tornado is another very simple way to deploy WSGI apps purely with Python. Tornado
    is a web server that is designed to handle thousands of simultaneous connections.
    If your application needs real-time data, Tornado also supports WebSockets for
    continuous, long-lived connections to the server.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Do not use Tornado in production on a Windows server. The Windows version of
    Tornado is not only much slower, but it is considered beta quality software.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use Tornado with our application, we will use Tornado''s `WSGIContainer`
    in order to wrap the application object to make it Tornado compatible. Then, Tornado
    will start to listen on port *80* for requests until the process is terminated.
    In a new file named `tserver.py`, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'To run the Tornado with supervisor, just change the command value to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Nginx and uWSGI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you need more performance or customization, the most popular way to deploy
    a Python web application is to use the web server Nginx as a frontend for the
    WSGI server uWSGI by using a reverse proxy. A reverse proxy is a program in networks
    that retrieves contents for a client from a server as if they returned from the
    proxy itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Nginx and uWSGI](img/B03929_13_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Nginx and uWSGI are used in this way because we get the power of the Nginx frontend
    while having the customization of uWSGI.
  prefs: []
  type: TYPE_NORMAL
- en: Nginx is a very powerful web server that became popular by providing the best
    combination of speed and customization. Nginx is consistently faster than other
    web severs such as Apache httpd and has native support for WSGI applications.
    The way it achieves this speed is several good architecture decisions as well
    as the decision early on that they were not going to try to cover a large amount
    of use cases like Apache does. Having a smaller feature set makes it much easier
    to maintain and optimize the code. From a programmer's perspective, it is also
    much easier to configure Nginx, as there is no giant default configuration file
    (`httpd.conf`) that needs to be overridden with `.htaccess` files in each of your
    project directories.
  prefs: []
  type: TYPE_NORMAL
- en: One downside is that Nginx has a much smaller community than Apache, so if you
    have an obscure problem, you are less likely to be able to find answers online.
    Also, it's possible that a feature that most programmers are used to in Apache
    isn't supported in Nginx.
  prefs: []
  type: TYPE_NORMAL
- en: uWSGI is a web server that supports several different types of server interfaces,
    including WSGI. uWSGI handles severing the application content as well as things
    such as load balancing traffic across several different processes and threads.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install uWSGI, we will use `pip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to run our application, uWSGI needs a file with an accessible WSGI
    application. In a new file named `wsgi.py` in the top level of the project directory,
    add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'To test uWSGI, we can run it from the command line with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: If you are running this on your server, you should be able to access port *8080*
    and see your app (if you don't have a firewall that is).
  prefs: []
  type: TYPE_NORMAL
- en: What this command does is load the app object from the `wsgi.py` file and makes
    it accessible from `localhost` on port *8080*. It also spawns four different processes
    with two threads each, which are automatically load balanced by a master process.
    This amount of processes is overkill for the vast, vast majority of websites.
    To start off, use a single process with two threads and scale up from there.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of adding all of the configuration options on the command line, we can
    create a text file to hold our configuration, which brings the same benefits for
    configuration that were listed in the section on supervisor.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a new file in the root of the project directory named `uwsgi.ini`, add the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: uWSGI supports hundreds of configuration options as well as several official
    and unofficial plugins. To leverage the full power of uWSGI, you can explore the
    documentation at [http://uwsgi-docs.readthedocs.org/](http://uwsgi-docs.readthedocs.org/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run the server now from supervisor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to install Nginx within the setup function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Because we are installing Nginx from the OS's package manager, the OS will handle
    running of Nginx for us.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'At the time of writing, the Nginx version in the official Debian package manager
    is several years old. To install the most recent version, follow the instructions
    here: [http://wiki.nginx.org/Install](http://wiki.nginx.org/Install).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to create an Nginx configuration file and then copy it to the
    `/etc/nginx/sites-available/ directory` when we push the code. In a new file in
    the root of the project directory named `nginx.conf`, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: What this configuration file does is it tells Nginx to listen for incoming requests
    on port *80*, and forwards all requests to the WSGI application that is listening
    on port *8080*. Also, it makes an exception for any requests for static files
    and instead sends those requests directly to the file system. Bypassing uWSGI
    for static files gives a great performance boost, as Nginx is really good at serving
    static files quickly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, in the `fabfile.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Apache and uWSGI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using Apache httpd with uWSGI has mostly the same setup. First off, we need
    an apache configuration file in a new file in the root of our project directory
    named `apache.conf`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This file just tells Apache to pass all requests on port *80* to the uWSGI
    web server listening on port *8080*. However, this functionality requires an extra
    Apache plugin from uWSGI named `mod-proxy-uwsgi`. We can install this as well
    as Apache in the set command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, in the `deploy` command, we need to copy our Apache configuration
    file into Apache''s configuration directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Deploying on Heroku
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Heroku is the first of the **Platform as a Service** (**PaaS**) providers that
    this chapter will cover. PaaS is a service given to web developers that allows
    them to host their websites on a platform that is controlled and maintained by
    someone else. At the cost of freedom, you gain assurances that your website will
    automatically scale with the number of users your site has with no extra work
    on your part. Using PaaS also tends to be more expensive than running your own
    servers.
  prefs: []
  type: TYPE_NORMAL
- en: Heroku is PaaS that aims to be easy to use for web developers by hooking into
    already existing tools and not requiring any large changes in the app. Heroku
    works by reading the file named `Procfile`, which contains commands that your
    Heroku dyno basically a virtual machine sitting on a server, will run. Before
    we begin, you will need a Heroku account. If you wish to just experiment, there
    is a free account available.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a new file named `Procfile` in the root of the directory, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This tells Heroku that we have a process named web, which will run the uWSGI
    command and pass the `uwsgi.ini` file. Heroku also needs a file named `runtime.txt`,
    which will tell it what Python runtime you wish to use, (at the time of writing,
    the latest Python release is 2.7.10):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to make some modifications to the `uwsgi.ini` file that we
    made earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We set the port at uWSGI listens to the environment variable port because Heroku
    does not directly expose the dyno to the Internet. Instead, it has a very complicated
    load balancer and reverse proxy system, so we need to have uWSGI listen on the
    port that Heroku needs us to listen on. Also, we set **die-on-term** to true so
    that uWSGI listens for a signal termination event from the OS correctly.
  prefs: []
  type: TYPE_NORMAL
- en: To work with Heroku's command-line tools, we first need to install them, which
    can be done from [https://toolbelt.heroku.com](https://toolbelt.heroku.com).
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, you need to log in to your account:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We can test our setup to make sure that it will work on Heroku before we deploy
    it by using the foreman command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Foreman command simulates the same production environment that Heroku uses run
    our app. To create the dyno, which will run the application on Heroku's servers,
    we will use the `create` command. Then, we can push to the remote branch Heroku
    on our `git` repository to have Heroku servers automatically pull down our changes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'If everything went well, you should have a working application on your new
    Heroku dyno. You can open a new tab to your new web application with the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: To see the app on a Heroku deployment in action, visit [https://mastering-flask.herokuapp.com/](https://mastering-flask.herokuapp.com/).
  prefs: []
  type: TYPE_NORMAL
- en: Using Heroku Postgres
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Maintaining a database properly is a full-time job. Thankfully, we can use
    one of Heroku''s built-in features in order to automate this process for us. Heroku
    Postgres is a Postgres database that is maintained and hosted entirely by Heroku.
    Because we are using SQLAlchemy, using Heroku Postgres is trivial. In your dyno''s
    dashboard, there is a link to your **Heroku Postgres** information. By clicking
    on it, you will be taken to a page as the one shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using Heroku Postgres](img/B03929_13_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: By clicking on the **URL** field, you will have an SQLAlchemy URL, which you
    can directly copy to your production configuration object.
  prefs: []
  type: TYPE_NORMAL
- en: Using Celery on Heroku
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have our production web server and database setup, but we still need to set
    up Celery. Using one of Heroku's many plugins, we can host a RabbitMQ instance
    in the cloud while running the Celery worker on the dyno.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to tell Heroku to run your celery worker in the `Procfile`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, to install the Heroku RabbitMQ plugin with the free plan (named the `lemur`
    plan), use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To get the full list of Heroku add-ons, go to [https://elements.heroku.com/addons](https://elements.heroku.com/addons).
  prefs: []
  type: TYPE_NORMAL
- en: 'At the same location on the dashboard where Heroku Postgres was listed, you
    will now find **CloudAMQP**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using Celery on Heroku](img/B03929_13_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Clicking on it will also give you a screen with a copiable URL, which you can
    paste into your production configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using Celery on Heroku](img/B03929_13_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Deploying on Amazon web services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Amazon Web Services** (**AWS**) is a collection of application platforms
    maintained by Amazon and built on top of the same infrastructure that runs [amazon.com](http://amazon.com).
    To deploy our Flask code, we will be using Amazon Elastic Beanstalk, while the
    database will be hosted on Amazon Relational Database Service, and our messaging
    queue for Celery will be hosted on Amazon Simple Queue Service.'
  prefs: []
  type: TYPE_NORMAL
- en: Using Flask on Amazon Elastic Beanstalk
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Elastic Beanstalk is a platform for web applications that offers many powerful
    features for developers, so web developers do not have to worry about maintaining
    servers.
  prefs: []
  type: TYPE_NORMAL
- en: For example, your Elastic Beanstalk application will automatically scale by
    utilizing more and more servers as the number of people using your app at once
    grows. For Python apps, Elastic Beanstalk uses Apache in combination with `mod_wsgi`
    to connect to WSGI applications, so there is no extra configuration needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we begin, you will need an [Amazon.com](http://Amazon.com) account and
    log in to [http://aws.amazon.com/elasticbeanstalk](http://aws.amazon.com/elasticbeanstalk).
    When you are logged in, you will see a screen like the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using Flask on Amazon Elastic Beanstalk](img/B03929_13_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on the dropdown to select Python, and if your application needs a specific
    Python version, be sure to click on **Change platform version** and select the
    Python version you need. You will be taken through a setup process, and finally
    your app will go through an initialization process on Amazon''s servers. While
    this is working, we can install the Elastic Beanstalk command-line tools. These
    tools will allow us to automatically deploy new versions of our application. To
    install them, use `pip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Before we can deploy the application, you will need an AWS Id and access key.
    To do this, click on the dropdown that displays your username at the top of the
    page and click on **Security Credentials**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Using Flask on Amazon Elastic Beanstalk](img/B03929_13_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, click on the gray box that says **Access Keys** to get your ID and key
    pair:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using Flask on Amazon Elastic Beanstalk](img/B03929_13_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once you have your key pair, do not share it with anyone because it will give
    anyone access to have a complete control over all of your platform instances on
    AWS. Now we can set up the command-line tools. In your project directory, run
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Select the application that you created earlier to tie this directory to that
    application. We can see what is running on the application instance now by running
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Right now, you should just see a placeholder application. Let''s change that
    by deploying our app. Elastic Beanstalk looks for a file named `application.py`
    in your project directory, and it expects a WSGI application named application
    in that file, so let''s create that file now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Once that file is created, we can finally deploy the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This is needed to run Flask on AWS. To see the book's application running on
    Elastic Beanstalk, go to [http://masteringflask.elasticbeanstalk.com](http://masteringflask.elasticbeanstalk.com).
  prefs: []
  type: TYPE_NORMAL
- en: Using Amazon Relational Database Service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Amazon Relational Database Service is a database hosting platform in the cloud
    that automatically manages several things, such as recovery on node failure and
    keeping several nodes in different locations in sync.
  prefs: []
  type: TYPE_NORMAL
- en: To use RDS, go to the services tab and click on Relational Database Service.
    To create your database, click on **Get Started**, which will take you though
    a simple setup process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once your database has been configured and created, you can use the **endpoint**
    variable listed on the RDS dashboard and the database name and password to create
    the SQLAlchemy URL in your production configuration object:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using Amazon Relational Database Service](img/B03929_13_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This's all that it takes to create a very resilient database on the cloud with
    Flask!
  prefs: []
  type: TYPE_NORMAL
- en: Using Celery with Amazon Simple Queue Service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to use Celery on AWS, we need to have our Elastic Beanstalk instance
    run our Celery worker in the background as well as set up **a Simple Queue Service**
    (**SQS**) messaging queue. For Celery to support SQS, it needs to install a helper
    library from `pip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Setting up a new messaging queue on SQS is very easy. Go to the services tab
    and click on **Simple Queue Servic**e in the applications tab and then click on
    **Create New Queue.** After a very short configuration screen, you should see
    a screen much like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using Celery with Amazon Simple Queue Service](img/B03929_13_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now we have to change our `CELERY_BROKER_URL` and `CELERY_BACKEND_URL` to the
    new URL, which takes the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This uses the key pair you created in the Elastic Beanstalk section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we need to tell Elastic Beanstalk to run a Celery worker in the background.
    We can do this with the `.conf` file in a new directory at the root of the project
    named `.ebextensions` (note the period at the start of the folder name). In a
    file in this new directory, it can be called whatever you wish, add the following
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Now whenever the instance reboots, this command will be run before the server
    is run.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As this chapter explained, there are many different options to hosting your
    application, each having their own pros and cons. Deciding on one depends on the
    amount of time and money you are willing to spend as well as the total number
    of users you expect.
  prefs: []
  type: TYPE_NORMAL
- en: Now we have reached the conclusion of the book. I hope that this book was helpful
    to build your understanding of Flask and how it can be used to create applications
    of any complexity with ease and with simple maintainability.
  prefs: []
  type: TYPE_NORMAL
