- en: 4\. Functions and Algebra with Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: 'Throughout the previous chapter, we discussed a plethora of statistics-related
    topics, including variables, descriptive statistics, and inference. In this chapter,
    we come back to the general topic of mathematics and examine two of its most fundamental
    components: functions and algebra. These topics will be introduced and theoretically
    discussed in parallel with their respective implementations in Python. Knowledge
    of these topics will allow you to tackle some of the most common real-life problems
    that can be solved using mathematics and programming, which we will see an example
    of in the final activity of this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have a firm grasp on the concept of mathematical
    functions and relevant notions such as domain, range, and graphing. Additionally,
    you will learn how to solve algebraic equations or systems of equations by hand
    as well as via Python programming.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While mathematics can be divided into multiple subfields, such as calculus,
    number theory, and geometry, there are certain fundamental concepts that every
    mathematics student must be familiar with. Two of these concepts are functions
    and algebra, which are the main topics of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: A function is a general mathematical process that describes a certain mapping
    from one object to another. A function can take in one number and produce another
    number. It can also take in an array or vector of numbers and return a single
    output, or even multiple outputs. Functions are so important that they are also
    widely used in other scientific fields, including physics, economics, and, as
    we have seen throughout this book, programming.
  prefs: []
  type: TYPE_NORMAL
- en: Our goal in this chapter is to establish a concrete foundational discussion
    on the concept of functions in a mathematical context. This discussion will be
    coupled with other related topics, such as the domain, the range, and the plot
    of a function. A solid understanding of these topics will allow you to explore
    more complex mathematical analyses in later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to functions, we will also consider algebra, one of the most important
    parts of mathematics. While the term generally denotes the analysis and manipulation
    of mathematical objects in the broadest sense, we will consider it in the context
    of algebraic equations and systems of equations. This will allow us to study its
    important role in mathematics while learning how to apply that knowledge to practical
    problems.
  prefs: []
  type: TYPE_NORMAL
- en: Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As previously explained, functions are mathematical objects that generally take
    in some input and produce a desired output. A function is therefore often considered
    as a mapping of one mathematical object to another. When a function receives an
    input and subsequently produces an output, the concept of *relation* can also
    be used, which emphasizes the relationship between the set of possible inputs
    and that of possible outputs that is established by the function itself.
  prefs: []
  type: TYPE_NORMAL
- en: A function is typically denoted by the lowercase letter *f* with parentheses,
    which surround an input that *f* takes in. This symbol, *f(x)*, also denotes the
    output that *f* produces when taking in *x* as input. For example, let's say the
    function *f* that outputs the square of its input; *f* can be denoted as *f(x)
    = x*2.
  prefs: []
  type: TYPE_NORMAL
- en: 'We see that the syntax for declaring a function in Python also follows this
    convention. For example, to declare the same squaring function in Python, the
    code would look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'And when we would like to obtain the value of *f* with a number as its input,
    we simply say that we call *f* on the input. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This code will print out `4` and `9`, respectively. As we also know, the value
    returned from a function can also be stored in a variable via assignment.
  prefs: []
  type: TYPE_NORMAL
- en: One of the most important characteristics of a function is the fact that no
    input can be mapped to different outputs. Once an input *x* has been associated
    with a corresponding output *f(x)*, that output is deterministic and cannot have
    more than one possible value. On the other hand, it is entirely possible that
    multiple inputs can be mapped to the same output. In other words, multiple values
    of *x* can cause *f(x)* to be a common value.
  prefs: []
  type: TYPE_NORMAL
- en: It is also possible that a function does not have to take in any input, nor
    does it necessarily need to produce any output. For instance, in the context of
    programming, a function whose job is to read and return the data included in a
    specific file does not need to take in any input. Another example would be a function
    that updates the value of a global variable, in which case it is not required
    to return anything. That said, these functions can be considered to belong to
    a specific subset of general functions, so our discussions will still revolve
    around functions with inputs and outputs.
  prefs: []
  type: TYPE_NORMAL
- en: In this upcoming subsection, let's consider a number of common types of functions
    in mathematics and programming.
  prefs: []
  type: TYPE_NORMAL
- en: Common Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While each function is unique in its own way, there are a number of special
    classifications, or *families*, of functions that we need to be aware of. These
    are constant, linear, polynomial, logarithmic, and exponential functions, which
    are summarized in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1: Table of special families of functions'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_04_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.1: Table of special families of functions'
  prefs: []
  type: TYPE_NORMAL
- en: Take a moment to consider the third column of our table, which contains the
    plots of sample functions belonging to each of the function families that are
    listed. We will go further into the theoretical details of the plot of a function
    later on in this section, but for now, we see that each family of functions gives
    us a unique style of graph; in fact, the identification of functions from their
    plots is the topic of our upcoming exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that constant and linear functions are actually subsets of the polynomial
    function family (when the coefficients for larger powers of *x* are all zeros).
    Another interesting fact you may have already noticed is that the input of a logarithmic
    function has to be positive, which is why its plot does not extend past the left
    side of the *y* axis. Conversely, the output of an exponential function (given
    that the constant is positive) is always positive; correspondingly, its graph
    stays above the *x* axis. These points directly transition us to our next topic:
    the domain and range of a function.'
  prefs: []
  type: TYPE_NORMAL
- en: Domain and Range
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The domain and the range are two essential concepts in the context of functions.
    The domain of a function denotes the set of all possible inputs that the function
    takes in, while the range specifies the set of all possible outputs.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the time, the domain and range of a given function can be identified
    by considering its formulaic expression. For example, a linear function, *f(x)
    = mx + c*, takes in any real-valued *x* to produce a real-valued *mx + c*, so
    both its domain and range are the set of real numbers, *R*. The quadratic function
    *f(x) = x*2, on the other hand, only produces non-negative outputs, so its range
    is the set of non-negative real numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The domain and range of a function can also be examined using its plot. Consider
    the plot of a function with a single input and a single output: its domain corresponds
    to the projection of the plot onto the *x* axis; similarly, the range is obtained
    when the plot is projected onto the *y* axis. This is why we can claim that the
    domain of the logarithmic function *f(x) = ln(x)*, whose plot is included in the
    table from the previous section, is the set of positive numbers. Conversely, the
    range of the exponential function *f(x) = e*x is the set of positive numbers as
    well.'
  prefs: []
  type: TYPE_NORMAL
- en: Overall, the domain and range of a function are dependent on the form of the
    function itself and can be highly informative regarding various behaviors of the
    function. One of these behaviors that is often of interest is the root of a function,
    which we will discuss in the next subsection.
  prefs: []
  type: TYPE_NORMAL
- en: Function Roots and Equations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A root of a function is a value belonging to its domain that makes the output
    equal to zero. Again, which value the root of a function takes is highly dependent
    on the function itself. Still using the examples that are included in the preceding
    table, *Figure 4.1*, we see that *f(x) = mx + c* accepts the unique root of *x
    = - c / m* if *m* is non-zero, while *f(x) = ln(x)* has the unique root of *x
    = 1*. Some functions might have more than one root: *f(x) = x*2 *- 3x + 2* has
    *x = 1* and *x = 2* as its roots, while *f(x) = 0* (whose plot corresponds to
    the *x* axis) accepts all values of *x* as its roots. Finally, if the range of
    a function does not include 0, then the function itself does not have any root;
    examples of this include *f(x) = e*x, *f(x) = x*2 *+ 1*, and *f(x) = 3*.'
  prefs: []
  type: TYPE_NORMAL
- en: The process of finding all roots of a function *f(x)* is equivalent to solving
    the equation *f(x) = 0*. The term *equation* here denotes the fact that we have
    two separate quantities, *f(x)* and *0*, that are equal to each other in the mathematical
    expression. Solving equations is arguably one of the most central tasks in mathematics,
    and there are multiple techniques for doing so that apply to specific equation
    types.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are only introducing the concept of equations here as part of the topic
    of functions, and we will come back to it later in this chapter. For now, we will
    move on to the last important component of a function: plots.'
  prefs: []
  type: TYPE_NORMAL
- en: The Plot of a Function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the earlier examples, the plot of a function is a visual representation of
    the behavior of the output, with respect to the input of the function. Specifically,
    with a function plot, we aim to examine how the output changes across the function
    range as the input of the function changes across its domain.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the context of programming, the plot of a function can be produced by connecting
    the scatter points corresponding to the individual values of a function over a
    set of fine-grained evenly spaced values on the *x* axis. For example, say we
    would like to visualize the plot of the function *f(x) = x + 1* between `-10`
    and `10`, we would first declare the corresponding evenly spaced values of `x`
    using NumPy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This NumPy function generates an array of 1,000 evenly spaced numbers between
    `-10` and `10`, which is illustrated by the output of `x`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2: Evenly spaced numbers from NumPy'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_04_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.2: Evenly spaced numbers from NumPy'
  prefs: []
  type: TYPE_NORMAL
- en: 'The plot can then be generated using the `plot()` function from Matplotlib:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Remember that due to vectorization, the expression `x + 1` will compute an array
    of the same size as `x`, whose elements are the elements of `x` with 1 added to
    each. This is a great feature of the Python language, or more specifically, the
    NumPy library, that allows us to quickly generate the points that make up the
    graph of a function.
  prefs: []
  type: TYPE_NORMAL
- en: 'This code should produce the following visualization:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3: Plot of f(x) = x + 1 in Python'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_04_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.3: Plot of f(x) = x + 1 in Python'
  prefs: []
  type: TYPE_NORMAL
- en: The same logic can be applied to different forms of functions. We will come
    back to this process during our next exercise. For now, let's return to our theoretical
    discussion.
  prefs: []
  type: TYPE_NORMAL
- en: The plot of a function is a direct visualization of its formulaic expression
    and contains all of the information we need to know about that function. In particular,
    we have already argued that a function plot can help us identify the domain and
    range of the function. Furthermore, given a graph, we can even determine whether
    that graph is a plot of a valid function. This is done with the vertical line
    test, which dictates the following.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given a graph on a two-dimensional plane, if, for every vertical line (every
    line that is parallel to the *y* axis), the graph has more than one intersection,
    then it is not the plot of a valid function. This is a direct corollary of the
    requirement of a function that we stated earlier: one single input cannot be mapped
    to more than one output. If a graph did have at least two intersections with a
    vertical line, that would mean a point on the *x* axis could be mapped to at least
    two points on the *y* axis, which would necessarily mean that this is not a plot
    of a function.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider the following graph of the unit circle (whose center
    is *O(0, 0)* and radius is equal to *1*), which fails the vertical line test,
    illustrated by the red line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4: The vertical line test for the unit circle'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_04_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.4: The vertical line test for the unit circle'
  prefs: []
  type: TYPE_NORMAL
- en: This is to say that the unit circle is, in fact, not the plot of a function
    with respect to the two-dimensional plane that we are considering.
  prefs: []
  type: TYPE_NORMAL
- en: This topic also marks the end of our introduction to the definition of functions.
    Before we move on to the next section, let's go through an exercise that aims
    to solidify all the concepts that we have learned so far.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 4.01: Function Identification from Plots'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we will practice the skill of analyzing the behavior of a
    function given its plot. This process will allow us to combine various topics
    that we have mentioned previously, as well as understand the connection between
    the behavior of a function and its plot.
  prefs: []
  type: TYPE_NORMAL
- en: 'For each of the following graphs:'
  prefs: []
  type: TYPE_NORMAL
- en: Determine whether it corresponds to a function and if so, go on to the next
    step.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Identify the domain, the range, and the formula of the function (hint: use
    the labeled ticks).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Determine whether the function has at least one root.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reproduce the plot using Python (the axes and their arrows are not necessary).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Horizontal line**:![Figure 4.5: Horizontal line'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/B15968_04_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.5: Horizontal line'
  prefs: []
  type: TYPE_NORMAL
- en: The graph does correspond to a function. The function is *f(x) = 2*, the domain
    is the set of real numbers, and the range is *{2}*. The function does not have
    any root.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code can be used to reproduce the plot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '**Rotated quadratic curve**:![Figure 4.6: Rotated quadratic curve'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/B15968_04_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.6: Rotated quadratic curve'
  prefs: []
  type: TYPE_NORMAL
- en: The graph does not correspond to a function since it fails the vertical line
    test.
  prefs: []
  type: TYPE_NORMAL
- en: '**Straight line**:![Figure 4.7: Straight line'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/B15968_04_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.7: Straight line'
  prefs: []
  type: TYPE_NORMAL
- en: 'The graph corresponds to the plot of the function *f(x) = x*. Both the domain
    and the range of this function are a set of real-valued numbers. The function
    has one root: *x = 0*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code can be used to reproduce the plot (using the same `x` variable
    as in the solution to *Horizontal line*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '**Quadratic curve**:![Figure 4.8: Quadratic curve'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/B15968_04_08.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.8: Quadratic curve'
  prefs: []
  type: TYPE_NORMAL
- en: 'The graph corresponds to the plot of the function *f(x) = x*2. The domain of
    the function is the set of all real numbers, while the range is the set of non-negative
    numbers. The function also has one root: *x = 0*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code can be used to reproduce the plot (thanks to vectorization
    for NumPy arrays):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Through this quick exercise, we have solidified our understanding of functions
    and a number of relevant concepts, including the domain, the range, the vertical
    line test, and the process of plotting a graph using Python.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to [https://packt.live/2YRMZhL](https://packt.live/2YRMZhL).
  prefs: []
  type: TYPE_NORMAL
- en: You can also run this example online at [https://packt.live/2YSBgj2](https://packt.live/2YSBgj2).
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will discuss the transformation of functions.
  prefs: []
  type: TYPE_NORMAL
- en: Function Transformations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Transformation is one of the most important concepts for mathematical functions.
    As suggested by the name of the term, a transformation of a function is the output
    we obtain after putting the returned value of a function through a specific transformation
    technique such as a shift or a scaling. In the most general sense, we can think
    of this process as a *composite function*: putting the output of one function
    through another function. However, there are specific types of functions that
    are commonly used as transformations due to their particular characteristics and
    usefulness, and we will go through them in the following subsections, starting
    with shifting.'
  prefs: []
  type: TYPE_NORMAL
- en: Since a transformation is most easily understood in the context of the changes
    that it applies to the plot of a function, we will also frame our following discussions
    accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Shifts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A shift of a function happens when the plot of a function is shifted by a specific
    amount along the *x* axis and/or the *y* axis. For example, in the following visualization,
    the blue curve is the graph of the function *f(x) = x*2, while the red curve is
    the same graph shifted vertically by *1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.9: Vertical shift of a function'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_04_09.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.9: Vertical shift of a function'
  prefs: []
  type: TYPE_NORMAL
- en: We see that every point *(x, y)* belonging to the graph of *f(x) = x*2 has been
    effectively translated to *(x, y + 1)*. Since *y = x*2 if *(x, y)* belongs to
    the graph of *f(x)*, the output of the shift is essentially the graph of the function
    *f(x) = x*2 *+ 1*.
  prefs: []
  type: TYPE_NORMAL
- en: 'This example allows us to generalize every case of a vertical shift: the output
    of the vertical shift of any given function *f(x)* by a constant *c* is the new
    function *f(x) + c*. In our example this is *c = 1*, corresponding to a horizontal
    shift up by *1*. However, *c* can also be a negative number, in which case the
    function is shifted down, or even zero, in which case the transformation is the
    identity transformation where the graph of the function does not change.'
  prefs: []
  type: TYPE_NORMAL
- en: We see that a vertical shift is done when a change is added to (or subtracted
    from) the output values of a function, or, in other words, the *y* coordinates
    of the points lying on the graph. In the same manner, a horizontal shift can be
    applied to a function by implementing a change in the input values of a function
    (when a number is added to the *x* coordinates of the points).
  prefs: []
  type: TYPE_NORMAL
- en: In general, when the graph of a function *f(x)* is shifted to the left of a
    two-dimensional plane by an amount *c*, the resulting graph is the plot of the
    function *f(x + c)*. Conversely, the graph of the function *f(x - c)* corresponds
    to a horizontal shift to the right by *c* of the function *f(x)*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Still using the example of the function *f(x) = x*2, the following graph visualizes
    the shift of the function to the right by *2*, or, in other words, the graph of
    the function *f(x) = (x - 2)*2:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.10: Horizontal shift of a function'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_04_10.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.10: Horizontal shift of a function'
  prefs: []
  type: TYPE_NORMAL
- en: It is also possible to combine both a vertical shift and a horizontal shift
    to transform a function so that the entire graph is moved in any given direction.
    For example, say we would like to shift the function *f(x) = x*2 in the North-East
    direction (up and right) by the amount vector (*2, 1*), then the transformed function
    will, as you can guess by now, be *f(x) = (x - 2)*2 *+ 1*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Overall, a shift as a transformation *moves* the graph of a function by a specific
    amount vertically and/or horizontally. For this reason, a shift is also an *affine
    transformation*, which is defined to be a transformation that moves all the points
    of a graph in the same direction and by a constant distance. However, a shift
    cannot change the size and scale of a graph. In the next section, we will discuss
    another method of transformation that can: scaling.'
  prefs: []
  type: TYPE_NORMAL
- en: Scaling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A scaling transformation stretches or shrinks the graph of a function by a
    specific amount, depending on the scaling factor. Consider in the following visualization
    the output of a scaling transformation when applied to our familiar function,
    *f(x) = x*2:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.11: Scaling of a function'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_04_11.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.11: Scaling of a function'
  prefs: []
  type: TYPE_NORMAL
- en: Through the preceding scaling transformation, every point *(x, y)* lying on
    the graph of the function is transformed to *(x, y / 2)*, effectively scaling
    the graph horizontally to be closer to the *x* axis. The transformed graph, which
    corresponds to the function *f(x) = x*2 */ 2*, is wider than the original graph,
    due to the fact that the curve is scaled to be closer to the *x* axis. To be more
    exact, aside from the origin (*0, 0*), any point from the original graph has been
    *pulled down* to be closer to the *x* axis. This would also make the overall slope
    of the graph less steep. Conversely, scaling transformations that would bring
    the transformed graph further away from the *x* axis might be *f(x) = 2x*2, or
    *f(x) = 3x*2, thereby making the slope of the transformed graph steeper.
  prefs: []
  type: TYPE_NORMAL
- en: In these transformations, we are multiplying the *y* coordinates of the graph
    by a constant, which gives us control of the scaling with respect to the *x* axis.
    In a similar manner, when a scaling is applied by multiplying the *x* coordinates
    of the graph of a function, a graph will be stretched or shrunk with respect to
    the *y* axis.
  prefs: []
  type: TYPE_NORMAL
- en: In general, the effect of a scaling transformation is controlled by the *scaling
    factor*—the constant that the *x*- or *y*-coordinates of a graph are multiplied
    by. A positive scaling factor does not change the relative location of the graph
    with respect to the axes.
  prefs: []
  type: TYPE_NORMAL
- en: When it is a vertical scaling (when the *y*-coordinates are scaled), a positive
    factor that is smaller than 1 will *pull* the graph to be closer to the *x* axis,
    while a large factor will *push* the graph away from the axis. The opposite is
    true for a horizontal scaling (when the *x* coordinates are scaled); a positive
    factor that is smaller than 1 will *push* the graph away from the *y* axis, and
    a large factor will *pull*.
  prefs: []
  type: TYPE_NORMAL
- en: 'While this *pulling/pushing* effect is also the same for negative scaling factors,
    when a function is scaled by a negative constant, its graph will be *flipped*
    along the corresponding axis:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.12: Negative scaling of a function'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_04_12.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.12: Negative scaling of a function'
  prefs: []
  type: TYPE_NORMAL
- en: Just as we have seen in the case of shifts, multiple scaling transformations
    can be applied to a function at the same time to obtain a combined effect.
  prefs: []
  type: TYPE_NORMAL
- en: In general, shifts and scaling constitute two of the most common methods of
    function transformation. In the next exercise, we will practice the skill of identifying
    these two transformations from their respective effect on function graphs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 4.02: Function Transformation Identification'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here, we aim to analyze the effect a specific transformation has on the graph
    of a function and identify the type as well as the characteristics of the transformation.
    This exercise will help us familiarize ourselves with how transformations can
    manipulate the behavior of functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following graph includes the plot of a cubic function, *f(x) = x*3 *- x*,
    and the plot of the sine function, *f(x) = sin(x)*, also commonly known as the
    sine wave due to its periodicity:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.13: Graph of a cubic function and a sine wave'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_04_13.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.13: Graph of a cubic function and a sine wave'
  prefs: []
  type: TYPE_NORMAL
- en: 'Each of the following graphs includes one of these two function plots as a
    blue curve and the result of a specific transformation from it as a red curve.
    For each of the graphs:'
  prefs: []
  type: TYPE_NORMAL
- en: Identify which transformation could have produced the effect.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If it is a shift, identify the value of the shift vector (that is, up/down by
    how much, left/right by how much).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If it is a scaling, identify whether the scaling factor is positive or negative
    and estimate its value (using the tick marks as a hint).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Verify your estimations by producing the same graph using Python (not including
    the axes and arrows).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s now have a look at the graphs:'
  prefs: []
  type: TYPE_NORMAL
- en: '**First transformation of a cubic curve**:![Figure 4.14: First transformation
    of a cubic curve'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/B15968_04_14.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.14: First transformation of a cubic curve'
  prefs: []
  type: TYPE_NORMAL
- en: The red curve is the result of a shift of the original sine wave. It is a horizontal
    shift to the left by `2`, so the shift is `-2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code can be used to reproduce the plot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '**Second transformation of a cubic curve**:![Figure 4.15: Second transformation
    of a cubic curve'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/B15968_04_15.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.15: Second transformation of a cubic curve'
  prefs: []
  type: TYPE_NORMAL
- en: The red curve results from a composite shift. It is a horizontal shift to the
    right by `2` combined with a vertical shift up by `2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code can be used to reproduce the plot (using the same variable,
    `x`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '**First transformation of a sine wave**:![Figure 4.16: First transformation
    of a sine wave'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/B15968_04_16.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.16: First transformation of a sine wave'
  prefs: []
  type: TYPE_NORMAL
- en: The red curve results from a scaling. It is a vertical scaling away from the
    *x* axis by a factor of `2`, so the scaling factor is `2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code can be used to reproduce the plot (using the same variable,
    `x`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '**Second transformation of a sine wave**:![Figure 4.17: Second transformation
    of a sine wave'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/B15968_04_17.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.17: Second transformation of a sine wave'
  prefs: []
  type: TYPE_NORMAL
- en: The red curve results from a scaling. It is a horizontal scaling that pulls
    the curve closer to the *y* axis by a factor of `2`, so the scaling factor is
    `2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code can be used to reproduce the plot (using the same variable,
    `x`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We have thus learned how to identify the transformation type and its degree
    of change by examining the effect a transformation has on the graph of a function.
    This exercise also concludes the topic of functions in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to [https://packt.live/2D2U7iR](https://packt.live/2D2U7iR).
  prefs: []
  type: TYPE_NORMAL
- en: You can also run this example online at [https://packt.live/2YPtHcJ](https://packt.live/2YPtHcJ).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next section, we will dive into a relevant concept that was briefly
    mentioned earlier: equations.'
  prefs: []
  type: TYPE_NORMAL
- en: Equations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Again, an equation is formed when a function is assigned the value 0 and we
    are asked to find the values of the function input, normally *x*, that satisfy
    the equation. These values are called the roots of the original function. The
    process of finding these values is called solving an equation, which is a rich
    topic in mathematics and, specifically, algebra.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will discuss two fundamental methods of solving equations
    by hand as well as examine the available computational tools in Python to facilitate
    the process of automatically solving equations. We will start with the first method,
    algebraic manipulations.
  prefs: []
  type: TYPE_NORMAL
- en: Algebraic Manipulations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While we are classifying this as a method, algebra is, in general, a technique
    to *translate* an equation to a simpler form so that solutions can be found easily.
    Some typical ways to translate an equation are adding/subtracting a constant to
    both sides of the equation, multiplying/dividing both sides by a non-zero constant,
    or moving all the terms of the equation to one side.
  prefs: []
  type: TYPE_NORMAL
- en: A simple example of this would be the *3x - 5 = 6* equation.
  prefs: []
  type: TYPE_NORMAL
- en: To solve for *x*, we first move the number *5* on the left-hand side to the
    right by adding *5* to both sides of the equation. This gives us *3x = 11*.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we multiply both sides by *1/3* so that we obtain the value of the
    variable *x*, which is *x = 11/3*.
  prefs: []
  type: TYPE_NORMAL
- en: 'This simple example illustrates the idea behind the whole process of manipulating
    an equation algebraically so that we can isolate the value of *x*. Let''s go through
    another example to nail down the point. Say we have an equation: *3x - 7 - 2(19x
    - 7) = (5x + 9) / 3 + 12*.'
  prefs: []
  type: TYPE_NORMAL
- en: While this equation seems significantly more complicated than the first, the
    process is actually the same. We first expand the terms inside the parentheses
    and gather the terms involving *x* into one group, and then gather the remaining
    terms into another.
  prefs: []
  type: TYPE_NORMAL
- en: 'This will give us the following algebraic transformations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.18: Substituting the values to find the value of x'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_04_18.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.18: Substituting the values to find the value of x'
  prefs: []
  type: TYPE_NORMAL
- en: We see that this process is, in general, quite simple, especially when we are
    only dealing with *linear* terms of *x*. The term *linear* denotes the quantities
    that are the variable *x* multiplied by a constant. Overall, the general term
    for the two equations seen here is **linear equations**, which only contain linear
    terms of *x*. Solving linear equations, as we have seen, is a straightforward
    process, even when we do it by hand.
  prefs: []
  type: TYPE_NORMAL
- en: In contrast, polynomial equations are equations with terms containing the variable
    *x* with degrees larger than *1*. Polynomial equations can be effectively solved
    using a specific technique, which will be discussed in the next subsection. For
    now, let's consider an example of a non-linear equation, *3e*x+2 *+ 3 = 2(e*x
    *+ 100)*, that can be solved simply using algebraic manipulations.
  prefs: []
  type: TYPE_NORMAL
- en: Note that *e* is the mathematical constant that is the base of the natural logarithmic
    function; it is approximately *2.71828*.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can find more information on this constant at [https://mathworld.wolfram.com/e.html](https://mathworld.wolfram.com/e.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this equation, we first expand the terms in this equation like so:
    *3e*x*e*2 *+ 3 = 2e*x *+ 200*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The transformation on the left-hand side is possible because of the identity
    *a*x + y *= a*x *a*y for all positive numbers of *a*, and real numbers *x* and
    *y*. Now, we see that even though there is no linear term of *x* in this equation,
    we can still employ our strategy of isolating the terms involving *x* and group
    them together:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.19: Substituting the values in the equation to find ex'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_04_19.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.19: Substituting the values in the equation to find ex'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, having the value for *e*x, we would like to extract out the *x* term.
    To do this, we will apply the natural logarithmic function, *f(x) = ln(x)*, to
    both sides of the equation. Since *ln( e*x *) = x* for all real values of *x*,
    this step will transform the left-hand side of the equation to simply *x*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.20: Substituting the values in the equation to find x'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_04_20.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.20: Substituting the values in the equation to find x'
  prefs: []
  type: TYPE_NORMAL
- en: 'Overall, the general idea behind using algebraic transformation to solve an
    equation is to group all the terms involving *x* together and manipulate them
    into a single term. Again, this strategy alone does not always work for any equation,
    as sometimes it is not possible to simplify all the *x* terms into one single
    term. This is the case for polynomial equations, which we will be discussing in
    the context of the next method of solving equations: factoring.'
  prefs: []
  type: TYPE_NORMAL
- en: Factoring
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While it technically belongs to the umbrella term of algebra, **factoring**
    specifically denotes the process of manipulating a given equation into the following
    form:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.21: Formula for factoring'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_04_21.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.21: Formula for factoring'
  prefs: []
  type: TYPE_NORMAL
- en: If the product of these terms is equal to zero, at least one of the terms must
    be equal to zero to satisfy the equation. In other words, solving the original
    equation is equivalent to solving each of the equations *f*1*(x) = 0*, *f*2*(x)
    = 0*, …, and *f*n*(x) = 0*. Ideally, we would want each of these *f*i*(x) = 0*
    equations to be easier to solve than the original.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider a starting example: x2 = 100'
  prefs: []
  type: TYPE_NORMAL
- en: Using the identity *x*2 *- y*2 *= (x - y) (x + y)* for all real *x* and *y*
    values, the equation is equivalent to *(x - 10) (x + 10) = 0*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since their product is zero, either *x - 10* or *x + 10* must also be zero.
    Solving these two equations gives us the solution for the original equation: *x
    = 10* or *x = -10*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'While this is a fairly simple example, it is able to illustrate a number of
    points. First, by factoring the equation into different terms multiplied together
    being equal to 0, the problem was converted into a set of simpler sub-problems.
    Additionally, with factoring, we can achieve something that the simple addition/multiplication
    of manipulations cannot: solving polynomial equations.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider our next example of an equation: *x*3 *- 7x*2 *+ 15x = 9*'
  prefs: []
  type: TYPE_NORMAL
- en: We see that even when all the terms involving *x* have already been grouped
    together, it is not clear how we should proceed with simple algebra.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, an insightful mathematics student may notice that this equation accepts
    *x = 1* or *x = 3* as solutions (since plugging in these values makes the left-hand
    side of the equation evaluate to 0). The fact that a polynomial equation accepts
    *x = c* as a solution not only means that by replacing *x* with *c* in the equation
    it will evaluate to zero, but it also means that the equation itself can be factored
    into the form *(x - c) g(x) = 0*, where *g(x)* is the other factored term of the
    equation. This technique also has another name, Ruffini''s rule, about which you
    can find more information at [https://mathworld.wolfram.com/RuffinisRule.html](https://mathworld.wolfram.com/RuffinisRule.html).
    With that in mind, we attempt to factor the given equation with respect to the
    term *(x - 1)* as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.22: Factoring the given equation'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_04_22.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.22: Factoring the given equation'
  prefs: []
  type: TYPE_NORMAL
- en: Keeping in mind that the equation also accepts *x = 3* as a solution, we continue
    to factor *(x*2 *- 6x + 9)* into *(x - 3)* multiplied by another term. If you
    are familiar with the quadratic formula, you might already be able to tell that
    the equation can be factored into *(x - 1) (x - 3)*2 *= 0*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the end, we have proven that the given equation does accept two solutions:
    *x = 1* and *x = 3*.'
  prefs: []
  type: TYPE_NORMAL
- en: A polynomial equation of degree *n* is one where the largest degree that *x*
    has is *n*. Overall, we would like to factor such an equation to *n* different
    factors. This is because it can be mathematically proven that a polynomial equation
    of degree *n* can only have, at most, *n* unique solutions.
  prefs: []
  type: TYPE_NORMAL
- en: 'In other words, if we can successfully transform an equation into *n* different
    factors, each of those factors is a linear term of *x*, which can be easily solved
    using the first method that we discussed above. For example, the equation *2x*3
    *- 7x*2 *+ 7x - 2 = 0* can be factored into *(x - 1) (x - 2) (2x - 1) = 0*, which
    gives us three solutions: *x = 1*, *x = 2*, and *x = 1 / 2*.'
  prefs: []
  type: TYPE_NORMAL
- en: Of course, there are situations in which a polynomial equation of degree *n*
    cannot be factored into *n* different linear terms of *x*. Consider the following
    example equation *x*3 *+ 4x - 5 = 0*.
  prefs: []
  type: TYPE_NORMAL
- en: 'This accepts a solution *x = 1*, and therefore has a factor of *(x - 1)*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.23: Factor for x = 1'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_04_23.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.23: Factor for x = 1'
  prefs: []
  type: TYPE_NORMAL
- en: Now, consider the term *x*2 *+ x + 5*. If we try plugging various values of
    *x* into the equation, we will see that none of the values can satisfy the equation.
    This suggests that this equation has no solution or, more specifically, *x*2 *+
    x + 5* is greater than 0 for all values of *x*, and we will prove that statement.
  prefs: []
  type: TYPE_NORMAL
- en: When we'd like to prove that a quadratic function of a variable is always greater
    than 0, we can utilize the fact that *(g(x))*2 is always non-negative, for all
    real values of *x* and for all functions *g* (this is because the square of any
    real number is non-negative). If we could then rewrite the term *x*2 *+ x + 5*
    into the form *(g(x))*2 *+ c*, where *c* is a positive constant, we can prove
    that the term is always positive.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we use the **completing the square technique** to group the *x* terms
    into a square. This technique involves using the identity *(a + b)*2 *= a*2 *+
    2ab + b*2 for all values of *a* and *b* to construct *(g(x))*2. Specifically,
    the term *x* can be rewritten as *2 x (1/2)*, since we need it to be in the form
    of 2 multiplied by *x* multiplied by another number. So, we have *x*2 and *2 x
    (1/2);* we therefore need *(1/2)*2 *= 1/4* to *complete* the sum of the three
    numbers as a square: *x*2 *+ x + 1/4 = x*2 *+ 2 x (1/2) + (1/2)*2 *= (x + 1/2)*2.'
  prefs: []
  type: TYPE_NORMAL
- en: The whole term can therefore be transformed as *x*2 *+ x + 5 = (x*2 *+ x + 1/4)
    + 19/4 = (x + 1/2)*2 *+ 19/4*.
  prefs: []
  type: TYPE_NORMAL
- en: '*(x + 1/2)*2 is non-negative for any real value of *x*, so the whole term *(x
    + 1/2)*2 *+ 19/4* is greater than or equal to *19/4*. This is to say that there
    is no real value of *x* that makes the term *x*2 *+ x + 5* equal to *0*; in other
    words, the equation *x*2 *+ x + 5 = 0* does not have any solution.'
  prefs: []
  type: TYPE_NORMAL
- en: And that is an overview of the factoring technique to solve polynomial equations.
    By way of a final point on the topic of equations, we will discuss the use of
    Python to automate the process of solving equations.
  prefs: []
  type: TYPE_NORMAL
- en: Using Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to the two methods of solving equations by hand, we also have the
    option of leveraging the computational power of Python to automatically solve
    any equation. In this section, we will look into this process in the context of
    the `SymPy` library.
  prefs: []
  type: TYPE_NORMAL
- en: Broadly speaking, SymPy is one of the best libraries in Python for symbolic
    mathematics, which is an umbrella term for algebraic computations involving symbols
    (such as *x*, *y*, and *f(x)*). While SymPy offers an extensive API that includes
    support for different mathematical subfields, including calculus, geometry, logic,
    and number theory, we will only be exploring its options for solving equations
    and (in the next section) systems of equations in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can find more information on the library on its official website at [https://docs.sympy.org/latest/index.html](https://docs.sympy.org/latest/index.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to install the library for our Python environment. This process,
    as always, can be done via `pip` and `conda`. Run either of the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Following a successful installation of the library, let''s explore the options
    that it offers using a specific example, an equation that we considered in the
    last section: *x*3 *- 7x*2 *+ 15x = 9*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Being a tool for symbolic mathematics, SymPy offers an easy API to declare
    variables and functions. To do this, we first import the `Symbol` class from the
    SymPy library and declare a variable named `x`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'When `x` is printed out in a Jupyter notebook, we will see that the letter
    is actually formatted as a mathematical symbol:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.24: SymPy symbols in Jupyter notebook'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_04_24.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.24: SymPy symbols in Jupyter notebook'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to solve the given equation, we import the `solve()` function from the
    `sympy.solvers` package. This `solve()` function takes in an expression containing
    a SymPy symbol (in this case, it is our variable `x`) and finds the values of
    `x` that make the expression evaluate to 0\. In other words, to solve for *x*3
    *- 7x*2 *+ 15x = 9*, we enter the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This code snippet returns a list of solutions for `x`, which, in this case,
    is `[1, 3]`. We see that this corresponds to the solution that we found earlier
    via factoring.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s examine another example that we have solved earlier: *3e*x + 2 *+ 3
    = 2(e*x *+ 100).* Remember that this equation has a root, *x = ln( 197 / (3e*2
    *- 2) )*, which is approximately 2.279\. Now, we enter this equation into the
    `solve()` function like so (after importing the constant `e` from the built-in
    `math` library):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This will give us the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This, as we can see, is the same solution obtained from our algebraic analysis.
    Overall, with the ability to declare variables and have a function of any form
    as input for the `solve()` function, SymPy offers us a flexible and convenient
    way to computationally solve equations in Python.
  prefs: []
  type: TYPE_NORMAL
- en: This topic also concludes our discussion on equations and methods of finding
    their solutions. Before we move on to the next topic in this chapter, let's go
    through an exercise to practice what we have learned in this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 4.03: Introduction to Break-Even Analysis'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Break-even analysis is a common practice in economics and financial engineering.
    The goal of a break-even analysis is to find the specific points in time where
    the revenue of a business balances its costs. Finding these points in time is
    therefore very important to business owners and stakeholders, who are interested
    in knowing if, and when, they will make a profit.
  prefs: []
  type: TYPE_NORMAL
- en: This scenario can be modeled fairly easily using mathematical variables and
    functions, which we will be doing in this exercise. Specifically, we aim to model
    a simple business and conduct a break-even analysis by solving for the break-even
    points. By the end, you will become more familiar with the process of representing
    real-life situations using mathematical models, functions, and variables.
  prefs: []
  type: TYPE_NORMAL
- en: '**Scenario**: A burger restaurant incurs a cost of $6.56 for the ingredients
    of every burger that it sells. It also incurs a fixed cost of $1,312.13 every
    month, which goes into the cooks'' wages, rent, utilities, and so on. The owner
    of the restaurant would like to perform a break-even analysis to determine if
    and when the revenue will cover the cost.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new Jupyter notebook and import NumPy, Matplotlib, and SymPy in the
    first code cell:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Say the restaurant sets the price of each of the burgers it sells at $8.99 and
    let *x* be a variable that represents the number of burgers that need to be sold
    each month so that the revenue made is equal to the cost. Write down the equation
    for *x* in this situation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With *x* being the number of burgers sold, *8.99x* is the revenue that the
    restaurant will make, while *6.56x + 1312.13* is the cost that the restaurant
    will incur. The equation for *x* will therefore be:'
  prefs: []
  type: TYPE_NORMAL
- en: '*8.99x = 6.56x + 1312.13*'
  prefs: []
  type: TYPE_NORMAL
- en: Solve for *x* by hand and verify the result using Python in the next cell of
    the Jupyter notebook. For testing purposes, store the list of solutions returned
    by SymPy to a variable named `sols`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using simple algebraic transformation, we can solve for *x* to be *x = 1312.13
    / (8.99 – 6.56) = 539.97*. So, the restaurant needs to sell roughly 540 burgers
    to break even.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code can be used to solve for *x* using SymPy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `sols` variable should have the value `[539.971193415638]`, which corresponds
    to our solution.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of solving for *x* to be the break-even point, construct a function
    of *x* that represents the total profit (revenue minus cost) of the restaurant
    every month.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The function should be *f(x) = 8.99x - 6.56x - 1312.13 = 2.43x - 1312.13*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next code cell of the Jupyter notebook, plot this function for the *x*
    values between 0 and 1000 using NumPy and Matplotlib, along with a horizontal
    line at 0, which should be colored black:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This should produce the following plot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.25: Visualization of a break-even analysis'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_04_25.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.25: Visualization of a break-even analysis'
  prefs: []
  type: TYPE_NORMAL
- en: The intersection of our profit curve and the horizontal line represents the
    break-even point. In this case, we see that it is roughly at the *x*-coordinate
    of `540`, which corresponds to the actual break-even point.
  prefs: []
  type: TYPE_NORMAL
- en: Say the restaurant on average sells 400 burgers every month and now let *x*
    be the price of a burger that the restaurant can set so that they can break even.
    Write down the equation for *x* in this situation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With *x* being the price of a burger, *400x* is the profit that the restaurant
    will make, while *(400) 6.56 + 1312.13 = 3936.13* (*$6.56* for each burger and
    a fixed amount of *$1312.13*) is the cost the restaurant will incur. The equation
    for *x* will therefore be *400x = 3936.13*.
  prefs: []
  type: TYPE_NORMAL
- en: Solve for *x* by hand and verify the result with SymPy in the Jupyter notebook.
    Store the list of solutions returned by SymPy in a variable named `sols1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The equation can be simply solved by dividing both sides by 400, which gives
    us *x = 9.84*. The Python code that solves the same equation is the following,
    which also produces the same result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In the next code cell, plot the function that represents the difference between
    profit and cost for the *x* values between `0` and `10`, together with the horizontal
    line at `0`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This should produce the following plot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.26: Visualization of a break-even analysis'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_04_26.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.26: Visualization of a break-even analysis'
  prefs: []
  type: TYPE_NORMAL
- en: Once again, the intersection of the two lines (which represents the break-even
    point) coincides with the actual solution that we have derived.
  prefs: []
  type: TYPE_NORMAL
- en: And that is the end of our exercise. In it, we have been introduced to the concept
    of break-even analysis by modeling a sample real-life business with mathematical
    functions and variables. We have learned how to find the number of products to
    be produced as well as the correct price to set to break even.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to [https://packt.live/3gn3JU3](https://packt.live/3gn3JU3).
  prefs: []
  type: TYPE_NORMAL
- en: You can also run this example online at [https://packt.live/3gkeA0V](https://packt.live/3gkeA0V).
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, a real-life business scenario is more complicated and has many more
    factors involved. We will come back to the task of break-even analysis in the
    activity at the end of the chapter, but before that, we need to discuss this chapter''s
    final section: systems of equations.'
  prefs: []
  type: TYPE_NORMAL
- en: Systems of Equations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An equation is an equality that we need to satisfy by solving for the values
    of a specific variable. In a system of equations, we have multiple equations involving
    multiple variables, and the goal is still the same: solving for the values of
    these variables so that each and every equation in the system is satisfied.'
  prefs: []
  type: TYPE_NORMAL
- en: Overall, there is no limit to the number of equations a system can have. However,
    it can be rigorously proven that when the number of equations a system has is
    not equal to the number of its variables, the system has either infinitely many
    solutions or no solutions. In this section, we will only be considering the case
    where these two numbers match.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, we will consider two different types of systems of equations:
    systems of linear equations and those of non-linear equations. We will consider
    the methods of solving each of these two types of systems of equations, both by
    hand and by using Python. First, let''s discuss the concept of systems of linear
    equations.'
  prefs: []
  type: TYPE_NORMAL
- en: Systems of Linear Equations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Similar to linear equations, which only contain constants and linear terms of
    their variables, a system of linear equations consists of linear equations, which
    also only contain linear combinations of its variables and constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple example of such a system is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.27: An example of a linear equation system'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_04_27.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.27: An example of a linear equation system'
  prefs: []
  type: TYPE_NORMAL
- en: 'As we can see, this system of equations has two variables: *x* and *y*. Each
    of the two equations contains those variables multiplied by constants (linear
    terms) as well as constants themselves.'
  prefs: []
  type: TYPE_NORMAL
- en: To solve this system of equations, you may have already noticed that if we were
    to add respective sides of the two equations together, we would obtain an extra
    equation, *3y = 8*, which we can then solve for *y = 8/3* and subsequently solve
    for *x = 5 - 8/3 = 7/3*.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, this method involves multiplying the equations provided to us by different
    constants and adding them together to sequentially eliminate variables. The goal
    is to obtain an equation that only has linear terms of a single variable left
    (and potentially constants), from which we can solve for that one variable. The
    solution value for this variable will then be plugged into the original equations,
    and the process continues for the rest of the variables.
  prefs: []
  type: TYPE_NORMAL
- en: While this process is straightforward when the number of variables/equations
    we have is relatively small, it can get quite messy as this number grows. In this
    subsection, we will consider a method called *row reduction*, or *Gaussian elimination*,
    that will help us formalize and then automate the process of solving the system
    of equations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Say we are asked to solve the following general system of linear equations
    with *n* variables and *n* equations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.28: System of linear equations with n variables and n equations'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_04_28.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.28: System of linear equations with n variables and n equations'
  prefs: []
  type: TYPE_NORMAL
- en: Here, *c*ij is the constant coefficient for variable *x*j in the *i*th equation.
    Again, these *c*ij values can take on any constant value, and this system of equation
    is the most general form of any system of linear equations.
  prefs: []
  type: TYPE_NORMAL
- en: 'To apply the row reduction method, we construct what is called an augmented
    matrix, which is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.29: An augmented matrix'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_04_29.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.29: An augmented matrix'
  prefs: []
  type: TYPE_NORMAL
- en: The left section of the matrix is an *n*-by-*n* submatrix whose elements correspond
    to the constant coefficients in the original system of equations; the right section
    of the matrix is a column with *n* values, which correspond to the constant values
    on the right-hand side of the equations in the original system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, from this augmented matrix, we can perform three types of transformation:'
  prefs: []
  type: TYPE_NORMAL
- en: Swap the locations of any given two rows.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiply a row by a non-zero constant.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a row to any other row (potentially multiplied by a non-zero constant as
    well).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The goal of the method is to transform the augmented matrix into *reduced row
    echelon form*, or, since we have a system of *n* equations and *n* variables,
    an identity matrix, where the *i*th element in the *i*th row is 1 and every other
    element in that row is *0*. Essentially, we would like to transform the augmented
    matrix into this matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.30: Matrix transformation'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_04_30.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.30: Matrix transformation'
  prefs: []
  type: TYPE_NORMAL
- en: Once this is done, the *c*i*'* values correspond to the values that make up
    the solution for the original system of equations. In other words, the solution
    would be *x*1 *= c*1*'*, *x*2 *= c*2*'*, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'While this mathematical generalization can seem intimidating, let''s demystify
    the process by considering a specific example. Let''s say we are to solve the
    following system of linear equations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.31: System of linear equations'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_04_31.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.31: System of linear equations'
  prefs: []
  type: TYPE_NORMAL
- en: 'We first construct the corresponding augmented matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.32: Corresponding augmented matrix'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_04_32.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.32: Corresponding augmented matrix'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we aim to transform this matrix into the identity form by using the three
    mentioned methods of transformation. We first subtract the second row by three
    times the first row and subsequently divide it by 4 to obtain:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.33: Step 1 to transform the matrix into an identity matrix'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_04_33.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.33: Step 1 to transform the matrix into an identity matrix'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, the goal is to create the structure of an identity matrix on the left-hand
    side, which can be done by forcing the non-diagonal elements to be zero. We have
    done this for the first element on the second row, so let''s now try to do the
    same for the third row by subtracting it by two times the first row:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.34: Step 2 to transform the matrix into an identity matrix'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_04_34.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.34: Step 2 to transform the matrix into an identity matrix'
  prefs: []
  type: TYPE_NORMAL
- en: 'The second element on the third row is to be transformed to 0, which can be
    done by subtracting the third row by two times the second row:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.35: Step 3 to transform the matrix into an identity matrix'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_04_35.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.35: Step 3 to transform the matrix into an identity matrix'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the last row is in the correct form, transforming the other rows is relatively
    easy as well. We now subtract the second row by three times the third row and
    multiply it by -1, which gives us:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.36: Step 4 to transform the matrix into an identity matrix'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_04_36.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.36: Step 4 to transform the matrix into an identity matrix'
  prefs: []
  type: TYPE_NORMAL
- en: 'As for the first row, we first add two times the third row to it to eliminate
    the last element:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.37: Step 5 to transform the matrix into an identity matrix'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_04_37.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.37: Step 5 to transform the matrix into an identity matrix'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we subtract it by three times the second row, which allows us to obtain
    the reduced row echelon form of our augmented matrix (with the identity matrix
    on the left):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.38: Identity matrix'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_04_38.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.38: Identity matrix'
  prefs: []
  type: TYPE_NORMAL
- en: This corresponds to the solution where *x = 1*, *y = 2*, and *z = 3*. We can
    ensure that our solution is indeed correct by plugging these values into the original
    system of equations, which shows that they do satisfy the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'And that is the process of using the row reduction method. As mentioned earlier,
    another method to solve a system of linear equations is the matrix solution. This
    involves representing a given system as a matrix equation. Specifically, from
    the general form of any system of linear equations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.39: System of linear equation'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_04_39.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.39: System of linear equation'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can rewrite it in matrix notation as *Ax = c*, where *A* is the *n*-by-*n*
    matrix containing the constant coefficients, *x* is the vector containing the
    variables that we have to solve for: *x*1, *x*2, …, *x*n, and *c* is similarly
    the vector containing the constant coefficients *c*1, *c*2, …, *c*n. Due to the
    definition of a product of a matrix and a vector, the equation *Ax = c* is indeed
    equivalent to the original system of equations.'
  prefs: []
  type: TYPE_NORMAL
- en: In this matrix notation, the vector *x* can be solved quite easily as *x = A*-1
    *c*, where *A*-1 is the *inverse matrix* of *A*. An inverse matrix, *M*-1, of
    any given matrix, *M*, is the matrix that satisfies the equation *A A*-1 *= I*,
    where *I* is the identity matrix.
  prefs: []
  type: TYPE_NORMAL
- en: This product between a matrix and a vector is called a **dot product**, which
    outputs another vector whose elements equal the sums of products of corresponding
    elements in the original matrix and vector. In our case, the dot product between
    *A*-1 and *c* will give us a vector that makes up the solution of the system.
  prefs: []
  type: TYPE_NORMAL
- en: There are matrices that do not have their corresponding inverse matrices; these
    matrices are called singular matrices. One of the signs we can use to tell that
    a matrix is singular is if one row of the matrix is exactly another row multiplied
    by a constant.
  prefs: []
  type: TYPE_NORMAL
- en: Theoretically speaking, this is analogous to the situation where the coefficients
    in one equation of a system are exact multiplications of the coefficients in another
    equation by a constant. If this is the case, we either have duplicate information
    (when the two equations have the same information, then the system has infinitely
    many solutions) or conflicting information (when the constants on the right-hand
    side of the two equations do not match up, then the system has no solution).
  prefs: []
  type: TYPE_NORMAL
- en: The theory behind this is not within the scope of this book. For now, we just
    need to know that if the corresponding coefficient matrix of a system of linear
    equations does not have an inverse matrix, the system does not have a definite
    solution.
  prefs: []
  type: TYPE_NORMAL
- en: So, not every matrix has its own inverse matrix, and even if a given matrix
    does, the process of computing the inverse matrix can be quite involved. Luckily,
    this can be done relatively easily in Python with NumPy, which we will see in
    the upcoming exercise. Specifically, the `linalg` (which stands for linear algebra)
    package in NumPy offers efficient implementation of many linear algebra-related
    algorithms. Here, we are interested in the `inv()` function, which takes in a
    two-dimensional NumPy array representing a matrix and returns the corresponding
    inverse matrix. We will see the effect of this function first-hand in the next
    exercise; more information about the package can also be found at [https://docs.scipy.org/doc/numpy/reference/routines.linalg.html](https://docs.scipy.org/doc/numpy/reference/routines.linalg.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 4.04: Matrix Solution with NumPy'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will write a program that takes in a system of linear
    equations and produces its solution using the matrix solution method. Again, this
    will be done by the computation of the inverse of the coefficient matrix using
    NumPy:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a Jupyter notebook. In its first cell, import NumPy and the `inv()`
    function from its `linalg` package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In the next code cell, declare a function named `solve_eq_sys()` (for testing
    purposes) that takes in two arguments: `coeff_matrix`, which stores the matrix
    of constant coefficients in a system of linear equations, and `c`, which stores
    a vector of the constant values on the right-hand side of the equations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: These two arguments completely define an instance of a system of linear equations,
    and the job of the `solve_eq_sys()` function is to compute its solution. We further
    assume that the arguments are both stored as NumPy arrays.
  prefs: []
  type: TYPE_NORMAL
- en: Recalling that the solution for the system is *x = A*-1 *c*, we simply return
    the product of the inverse matrix of `coeff_matrix` and `c`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The inverse matrix can be computed using the `inv()` function from NumPy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the solution can be computed using the `dot()` method, which calculates
    the dot product of a matrix and a vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Our function should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'In the next code cell, declare the corresponding coefficient matrix and `c`
    vector for the system of equations that we considered earlier and call the `solve_eq_sys()`
    function on them:![Figure 4.40: System of linear equations'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/B15968_04_40.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.40: System of linear equations'
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for this should be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This code should produce the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We see that this output exactly corresponds to the actual solution to the system
    of equations that we have derived using the row reduction method: *x = 1*, *y
    = 2*, and *z = 3*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we would like to take into account the case where our coefficient matrix
    is singular. We do this by testing our code on the following sample system of
    linear equations that has no solution:![Figure 4.41: Sample system of linear equations'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/B15968_04_41.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.41: Sample system of linear equations'
  prefs: []
  type: TYPE_NORMAL
- en: We see that if we multiply the first equation by `2`, the equation we obtain
    contradicts the third equation. In other words, there is no combination of values
    for variables *x*, *y*, and *z* that can satisfy the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next code cell, call the `inv()` function on this coefficient matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We will see that this code produces a `LinAlgError: Singular matrix` error,
    which we will fix in the next step.'
  prefs: []
  type: TYPE_NORMAL
- en: For testing purposes, uncomment out this cell.
  prefs: []
  type: TYPE_NORMAL
- en: 'Come back to our code and modify our current `solve_eq_sys()` function with
    a `try...except` block to handle this error, which will need to be imported from
    NumPy first:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the function should return `False` if the input matrix is singular. It
    should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'In the next code cell, call this function on the sample system of equations
    we used in *step 5*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This time, the function returns the value `False`, which is the behavior we
    desire.
  prefs: []
  type: TYPE_NORMAL
- en: Through this exercise, we have learned how to implement the matrix solution
    method to solve a system of linear equations using NumPy. This also concludes
    the topic of linear equation systems.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to [https://packt.live/2NPpQpK](https://packt.live/2NPpQpK).
  prefs: []
  type: TYPE_NORMAL
- en: You can also run this example online at [https://packt.live/2VBNg6w](https://packt.live/2VBNg6w).
  prefs: []
  type: TYPE_NORMAL
- en: In the next and final section of this chapter, we will consider systems of equations
    that are not completely linear.
  prefs: []
  type: TYPE_NORMAL
- en: Systems of Non-Linear Equations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When a system contains an equation that contains some non-linear terms of its
    variables, the methods that we discussed in the previous section do not apply.
    For example, consider the following system:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.42: An example system of non-linear equations'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_04_42.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.42: An example system of non-linear equations'
  prefs: []
  type: TYPE_NORMAL
- en: The problem arises with the non-linear term, *x*2, which complicates whatever
    transformations we want to apply to the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, we can still have a systematic approach to solving these types of
    systems. Specifically, notice that from either equation, we can solve for a variable
    in terms of the other variable. To do this, we algebraically transform each equation
    so that one variable can be represented purely in terms of the other. In particular,
    *y* can be represented as a function of *x* as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.43: Substituting the equations to find the values of y'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_04_43.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.43: Substituting the equations to find the values of y'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in order for the system to have a valid solution, the two values of *y*
    need to match up. In other words, we have the following equation that just contains
    *x*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.44: Substituting the value of y on both sides'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_04_44.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.44: Substituting the value of y on both sides'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is simply a polynomial equation for *x*, which, as we know, can be solved
    via factoring. Specifically, the equation can be factored to *(x - 2) (x - 1)
    = 0*, which obviously accepts *x = 1* and *x = 2* as solutions. Each of these
    values for *x* corresponds to a value for *y*, which can be found by plugging
    in 1 and 2 into the original system of equations. In the end, the system has two
    solutions: *(x = 1, y = 4)* and *(x = 2, y = 3)*.'
  prefs: []
  type: TYPE_NORMAL
- en: Overall, this method is called **substitution**, denoting the fact that we are
    able to solve for a variable in terms of another variable by transforming an equation.
    This solution is then substituted into another equation so that we obtain an equation
    of a single variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see another example of the application of this method with the following
    system of equations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.45: Example system of equations'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_04_45.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.45: Example system of equations'
  prefs: []
  type: TYPE_NORMAL
- en: While there are multiple ways of solving this, one clear way is to solve for
    *y* in the second equation, which leads to *y = (x*2 *- 1) / 2*, which can then
    be plugged into the first equation like *x*2 *- 2x - (x*2 *- 1)*2 */ 4 = -1*.
  prefs: []
  type: TYPE_NORMAL
- en: With some algebra, we can simplify the equation as *x*4 *-6x*2 *+ 8x -3 = 0*.
  prefs: []
  type: TYPE_NORMAL
- en: We now have an equation that only contains one variable, so we can apply the
    techniques that we have learned in the last section to solve for *x*. Once we
    have the solution for *x*, we can also solve for *y* using the preceding *y =
    (x*2 *- 1) / 2* substitution.
  prefs: []
  type: TYPE_NORMAL
- en: Here, factoring can be applied to find the values of *x* that satisfy this equation.
    Let's try plugging in a few values of *x* such as *-1*, *0*, *1*, or *2* to see
    which would evaluate the function to 0\. Noticing that *x = 1* is a valid solution,
    we first factor the equation with respect to *(x - 1)*, which leads to *(x - 1)
    (x*3 *+ x*2 *- 5x + 3) = 0*.
  prefs: []
  type: TYPE_NORMAL
- en: Once again, we notice that *x = 1* still satisfies the equation *x*3 *+ x*2
    *– 5x + 3 = 0*, thus taking another factoring step to *(x - 1)*2 *(x*2 *+ 2x -
    3) = 0*.
  prefs: []
  type: TYPE_NORMAL
- en: The quadratic function *x*2 *+ 2x - 3* can then be factored into *(x - 1) (x
    + 3)*. In the end, we have the following equation *(x - 1)*3 *(x + 3) = 0*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Two values of *x* satisfy the equation: *x = 1* and *x = -3*. By plugging them
    into the original system, we can then solve for *y* and obtain two solutions for
    the system: *(x = 1, y = 0)* and *(x = -3, y = 4)*.'
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, not all systems of non-linear equations allow us to employ the
    substitution method in such a straightforward manner. In many cases, subtle and
    ingenious techniques have to be used to solve complex systems of equations.
  prefs: []
  type: TYPE_NORMAL
- en: What if, then, we would like to automate the process of finding the solutions
    for such systems? This is where the symbolic computation ability offered by the
    `sympy` library comes in handy once again. We have seen that with SymPy, we can
    solve for any one-variable equation. The same idea can also apply to systems of
    non-linear equations, only in this case, we pass a list of symbolic functions
    to the `solve()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Say we want to use SymPy to solve the two systems of equations we have in this
    section; firstly:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.46: The first system of equation'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_04_46.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.46: The first system of equation'
  prefs: []
  type: TYPE_NORMAL
- en: 'And secondly:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.47: The second system of equation'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_04_47.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.47: The second system of equation'
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we first declare our variables as instances of the `Symbol` class
    from SymPy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then call the `solve()` function from SymPy to find solutions for the
    systems of equations we have. For the first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'This code will return `[(1, 4), (2, 3)]`, which is the list of valid solutions
    for *x* and *y*, as we derived earlier. As for the second system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This code returns `[(-3, 4), (1, 0)]`, which also corresponds to the solution
    we have derived. As we can see, SymPy offers a straightforward syntax for us to
    solve both equations and systems of equations effortlessly.
  prefs: []
  type: TYPE_NORMAL
- en: This example also marks the end of the material for this section. To end this
    chapter, we will consider an extension of the break-even analysis exercise that
    we worked on earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 4.01: Multi-Variable Break-Even Analysis'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we have mentioned at the end of the first break-even analysis exercise, a
    break-even analysis can become quite complex as the number of variables in our
    model grows. When there is more than one variable in a model, a system of equations
    needs to be used to find break-even points, which is what we will do in this activity.
  prefs: []
  type: TYPE_NORMAL
- en: Recall that in our example business model of a burger restaurant, we have a
    cost of $6.56 for each burger we produce as well as a fixed cost of $1,312.13
    each month for utilities, rent, and other expenses. In this activity, we will
    explore how the total profit of the business changes as a function of both the
    number of burgers we sell and the price of each burger.
  prefs: []
  type: TYPE_NORMAL
- en: One additional piece of information we need for this model is the demand for
    burgers from the people living in the area of the restaurant. Let's say, on average,
    the restaurant observes that their revenue is around $4,000 every month, so the
    demand for burgers is roughly 4,000 divided by the price of a burger.
  prefs: []
  type: TYPE_NORMAL
- en: 'To complete this activity, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Consider the number of burgers that the restaurant produces every month and
    the price of each burger as two variables for our model. Represent the monthly
    revenue, cost, and total profit of the restaurant in terms of these two variables.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Construct a system of equations that corresponds to the break-even point: when
    the number of burgers the restaurant makes satisfies demand and revenue equals
    costs.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Solve this system of equations by hand and verify the result using SymPy in
    a Jupyter notebook.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the same Jupyter notebook, write a Python function that takes in any given
    combination of the number of burgers produced and the price of each burger. The
    function is to return the total profit of the restaurant.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the next code cell, create a list of potential values for the number of burgers
    to be produced, ranging from 300 to 500 every month. Generate the list of corresponding
    profits using a fixed price of $9.76 per burger and store it in a variable named
    `profits_976` (for testing purposes). Plot this list of profits as a function
    of the number of burgers produced.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the next code cell, generate the same list of profits, this time with a fixed
    price of $9.99 per burger, and store it in a variable named `profits_999`. Create
    the same plot and interpret it in the context of break-even points.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the next cell, create a list of potential values for the number of burgers
    to be produced; it should be every even number between 300 and 500 (for example,
    300, 302, 304, …, 500). Additionally, create a NumPy array of 100 evenly spaced
    numbers between 5 and 10 as potential prices for each burger.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, generate a two-dimensional list where the item in the row indexed at
    *i* and the column indexed at *j* is the profit the restaurant will make, with
    the *i*th number in the first list as the number of burgers it will produce and
    the *j*th number in the second list (the NumPy array) as the price of each burger.
    Store this list in the variable named `profits` for testing purposes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a heatmap using Matplotlib to visualize the two-dimensional list of profits
    generated in the previous step as a function of the number of burgers produced
    (as the *y* axis) and the price of each burger (as the *x* axis).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution to this activity can be found on page 665.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter formally introduced the definition of functions and variables in
    the context of mathematics. Various topics relevant to functions, such as the
    domain, the range, and the plot of a function, were also discussed. In the second
    part of the chapter, we talked about the concept of equations and systems of equations,
    as well as special methods to find their solutions. During these discussions,
    the SymPy library and the function to compute the inverse of a matrix from NumPy
    were also examined. We concluded the chapter by completing a task that used algebra
    and functions to construct a multi-variable break-even analysis for a business.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we will continue with another important topic in mathematics:
    sequences and series.'
  prefs: []
  type: TYPE_NORMAL
- en: FKV27
  prefs: []
  type: TYPE_NORMAL
- en: GCH43
  prefs: []
  type: TYPE_NORMAL
