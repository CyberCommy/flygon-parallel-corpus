- en: Chapter 2. Using Variables and Mixins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you will study *Less* in more detail, where you will learn
    more about variables and mixins. **Variables** in *Less* can be reused anywhere
    in the code. Although they are often defined in a single place, they can also
    be overwritten elsewhere in the code. They are used to define commonly used values
    that can be edited only once at a single place. Based on the **Don't Repeat Yourself**
    (**DRY**) principle, commonly used values will help you build websites that are
    easier to maintain. **Mixins** are used to set the properties of a class. They
    bundle tasks in a single line of code and are also reusable. You will learn how
    to create, use, and reuse them in your project and write better CSS without code
    duplications.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Commenting on your code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Escaping values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using mixins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Comments make your code clear and readable for others. It is important that
    you are able to understand them clearly. That is why this chapter starts with
    some notes and examples of comments.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Don't be sparse with your comments when keeping the file size, download time,
    and performance in mind. In the process of compiling and minimizing your final
    CSS code, comments and other layout structures will be effectively removed. You
    can add comments for understanding and readability wherever needed.
  prefs: []
  type: TYPE_NORMAL
- en: In *Less*, you can add comments in the same way as you did while writing the
    CSS code. Comment lines are placed between `/* */`. *Less* also allows single-line
    comments that start with `//`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using *Less*, you will conserve these comments in the final style sheet apart
    from the single-line comments, which are not printed. **Minimizers** will remove
    these comments in your final **compiled style sheet**. An example of this can
    be seen in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Nested comments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Although *Less*, like PHP or JavaScript, doesn''t allow nested comments, single-line
    comments that start with `//` are allowed and can be mixed with the normal comment
    syntax. This is shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Special comments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Minimizers define a special comment syntax, sometimes to allow an important
    comment, such as a license notice, to be included in the minimized output as well.
    You can use this syntax to write some copyright notices at the top of your style
    sheet. Using clean CSS and the default minimizer of the `clean-css` command-line
    compiler of *Less*, you should place this important command between `/*! !*/`,
    as shown in the following example code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Variables in *Less* help you keep your files organized and easy to maintain.
    They allow you to specify widely-used values in a single place and then reuse
    them throughout your *Less* code. The properties of the final style sheet can
    be set with variables. So, imagine that you don't have to search for every declaration
    of a specific color or value in your style sheets any more. How does all of this
    work? Variables will start with `@` and have a name. Examples of such variables
    include `@color`, `@size`, and `@tree`. To write the name, you are allowed to
    use any alphanumeric character, underscores, and dashes. This means that `@this-is-variable-name-with-35-chars`
    is a valid variable name.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although alphanumeric characters, underscores, and dashes are used in variable
    names in this book, the specifications allow you to use any character, with a
    few exceptions. The specifications find their origin in the CSS grammar (which
    you can view at [http://www.w3.org/TR/CSS21/grammar.html](http://www.w3.org/TR/CSS21/grammar.html)).
    Names starting with a dash are reserved for vendor-specific rules, and a space
    is already used to separate class names from each other. It is possible and allowed
    to use escaping, which is very rare for (programming) languages. However, the
    escaping of white spaces is not possible. `NULL` is also not allowed.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, the use of `@` is ambiguous in *Less*. As you have seen in the
    first chapter, parameters used by mixins also start with `@`. That's not all.
    As valid CSS code is also valid *Less* code, there will be CSS media query declarations
    that also start with `@`. The context will make it clear when `@` is used to declare
    a variable. If the context is not clear enough, the meaning of the `@` will be
    explicitly mentioned in this book.
  prefs: []
  type: TYPE_NORMAL
- en: You can give a variable a value, which will be called a declaration. A value
    can contain anything that is a valid value for a CSS property.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use a colon (`:`) to assign a value to a variable. A declaration ends
    with a semicolon (`;`). The following examples will make this clear:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: After the declaration of a variable, you can use the variable anywhere in your
    code to reference its value. This quality makes variables extremely powerful when
    programming *Less* code. Take a look at the example code for this chapter from
    the downloadable code for this book to get a better understanding.
  prefs: []
  type: TYPE_NORMAL
- en: Organizing your files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you have seen, you only have to declare a variable once to use it anywhere
    in the code. So, to make changes to the variables, you also have to change them
    only once. The example code defines the variables in a separate file called `less/variables.less`.
    It is a great practice to organize your files. If you want to change something,
    you now know where to look.
  prefs: []
  type: TYPE_NORMAL
- en: 'Recalling **CSS reset** and **border-boxing** from the first chapter, your
    main *Less* file will now look like the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `@import` statement imports code from the file to the main *Less*
    file. Filenames are written between quotes and followed by a semicolon. Besides
    the *Less* files, you can also import plain CSS files, which will not be processed
    for the *Less* directives; this will be explained in more detail in [Chapter 5](ch05.html
    "Chapter 5. Integrate Less in Your Own Projects"), *Integrating Less in Your Own
    Projects*.
  prefs: []
  type: TYPE_NORMAL
- en: Now you should open `http://localhost/index.html` in your browser. You will
    see a straightforward website layout, which contains a header, content block,
    side menu, and three-columned footer, as shown in the following screenshot. All
    the layout items have blue accents. After this, open `less/variables.less` in
    your favorite text editor.
  prefs: []
  type: TYPE_NORMAL
- en: '![Organizing your files](img/1465OS-02-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A layout built with *Less*
  prefs: []
  type: TYPE_NORMAL
- en: Curious as you are, I bet you have also opened the other files. Don't be scared
    by the complexity of the code in them. This code and layout have been used to
    show the power of widely-used variables that have been defined in a single place.
    This can be better demonstrated with more realistic and complex examples than
    by just a few lines of code. Rest assured that all the other code will explain
    this to you soon. Before you know it, all this code will look very familiar to
    you.
  prefs: []
  type: TYPE_NORMAL
- en: 'Firstly, change `darkblue` to `darkgreen` in the `@darkcolor: darkgreen;` line
    in the `less/variables.less` file, which you opened earlier. After this, watch
    the results in your browser. Reload your browser if you still haven''t used the
    `#!watch` function.'
  prefs: []
  type: TYPE_NORMAL
- en: The layout will now be shown in green. If you weren't convinced earlier, you
    should be now. In practice, you won't change a complete website using a single
    line of code, but this example shows what *Less* can do to make your work easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine that you have finished your dark-green website''s job, and you show
    it to your boss. "Well done!", he says, but he also tells you, "I know I asked
    for green, but if you don''t mind, I prefer a red website". For now, you smile
    and simply change `darkgreen` to `darkred` in the `@darkcolor: darkgreen;` line
    in the `less/variables.less` file.'
  prefs: []
  type: TYPE_NORMAL
- en: As you have seen, your HTML is clean and straightforward, with no inline CSS
    or even class names. There is now a new concern; you will have to name, declare,
    and save your variables in a smart and proper fashion. When doing this, be consistent
    and clear as it is of high importance. When organizing your variables, follow
    the same strategy at all times, using name conventions and comments where the
    context isn't clear enough. Please keep in mind that someone should be able to
    take over your work without any further instructions at any moment. To achieve
    this, you will have to explore the variables at deeper levels.
  prefs: []
  type: TYPE_NORMAL
- en: Naming your variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You should always give your variables meaningful and descriptive names. Variable
    names such as `@a1` and `@a2` will get compiled but have not been chosen well.
    When the number of variables grows or when you have to change something quite
    deep in the code, you will not know or remember what `@a2` has been used for.
    You will have to look up its context to find its use in your *Less* files or even
    worse, inspect your HTML elements to find which CSS rules are applied on it in
    order to find the *Less* context. In this unfortunate case, you will be back to
    square one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Good examples of names include `@nav-tabs-active-link-hover-border-color` and
    `@dark-color`. These variables are meaningful and descriptive because their names
    try to describe their function or usage rather than their value. This process
    of naming will also be called **semantic naming**. So, in this case, `@dark-color`
    is a better choice than `@red`, and in some cases, you can be more specific by
    using `@brand-color`. `brand`. This could describe some house style color of a
    website, like in the previous case. If the house style color changes from dark
    red to light green, then `@brand-color: lightgreen;` still makes sense. However,
    `@dark-color: lightgreen;` or `@red: lightgreen;` just doesn''t quite say it.'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, hyphens are used to separate words in variable names. These
    names are called **hyphenated names**. You should use lower case letters. There
    aren't any strict rules to use hyphenated names; the so-called **CamelCase** is
    used and is familiar to many programmers as an acceptable alternative. In CamelCase,
    you will use something like `@navTabsActiveLinkHoverBorderColor` and `@darkColor`.
    Both hyphenated and CamelCase names improve readability.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When writing CSS and HTML code, you are using hyphenated two-word terms and
    lowercase class names, ID's, and font names, among other things. These rules are
    not always strict, and they are not followed by convention. This book follows
    this convention when writing *Less* code, and it therefore makes use of hyphenated
    names.
  prefs: []
  type: TYPE_NORMAL
- en: Whether you prefer CamelCase or hyphenated names doesn't matter greatly. When
    you have chosen either CamelCase or hyphenated names, it is important to be consistent
    and use the same way of naming throughout your *Less* files.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you perform calculations, a hyphenated name may cause some trouble. You
    will need some extra spacing to solve this. When you declare `@value` minus one,
    `@value-1` will be read as a single variable instead of `@value -1.`
  prefs: []
  type: TYPE_NORMAL
- en: Using a variable
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If your project grows, it will be impossible to add a variable for every CSS
    property value, so you will have to choose which values should be a variable or
    which should not. There are no strict rules for this process. You will find some
    clear guidance to make these choices in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: You should first try to find property values that are used more than once in
    your code. Repeated usage is suitable when creating variables. The `@dark-color`
    variable in the example code is a good example of such a property value.
  prefs: []
  type: TYPE_NORMAL
- en: Second, you can make variables of properties that are used for customization
    settings. The `@basic-width` variable in the example code is an example of such
    a property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you should consider creating variables for reusable components. Looking
    at our example, you could reuse the header in other projects. To make this possible,
    you should create a new `less/header.less` file and import this to your main file
    with the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Organizing variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To make components reusable, you can create *Less* files for each component
    or function and arrange the variables to suit these files. To demonstrate this,
    split the example code into `less/header.less`, `less/content.less` and `less/footer.less`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `less/header.less` file will now contain the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Notice that `@dark-color` has been renamed as `@header-dark-color`. Open `http://localhost/project.html`
    in your browser and the `less/project.less` file in the text editor to see all
    the changes and their effects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, include the `less/header.less` file in your `less/project.less` file using
    `@import "header.less";` and create a header section in the `less/variablesproject.less`
    file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The `@header-dark-color: @dark-color;` statement assigns the `@dark-color;`
    value to `@header-dark-color`. After this, you will do the same for `less/content.less`
    and `less/footer.less`. As you can see, `http://localhost/project.html` still
    looks the same after your changes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, open `less/variablesproject.less` in your text editor and change the footer
    section to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In your browser, you will now see the layout with a green footer.
  prefs: []
  type: TYPE_NORMAL
- en: The last declaration wins
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the first chapter, you read about **CSS cascade**, where the last rule said
    that the value declared last will win if the output of the other rules is equal.
    *Less* uses the same strategy, where the last declaration of a variable will be
    used in all the preceding code. In the following code, you will see that the property
    value is set to `2` in accordance with the last declaration wins rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In fact, *Less* first reads all of your code. When the value of a variable is
    used, it is only the last-assigned or last-read value that is actually used. The
    fact that the last declaration wins will only affect the declaration defined in
    the same scope.
  prefs: []
  type: TYPE_NORMAL
- en: In most programming languages, the scope is defined by a part of the code that
    the compiler can run independent of the other code. Functions and classes can
    have their own scope. In *Less*, mixins have their own scope. Mixins will be discussed
    in more detail later on in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows you that the property value is set to `3` in accordance
    with the value declared inside the scope of the mixin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code means you can't change variables during the compilation.
    This makes these variables theoretical **constants**. Compare this with a definition
    of the mathematical value of pi in your code, which is always the same. You will
    define `PI` only once, where `PI = 3.14` will be in your code and will remain
    constant when your code is run. For this reason, variables should be declared
    only once.
  prefs: []
  type: TYPE_NORMAL
- en: '**Redeclaration** of variables and the rule that the last declaration wins
    will be used in the customization of many *Less* projects and code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate redeclaration, create a new `less/customized.less` file and
    write the following code into it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Reference the `customized.less` file in the `customized.html` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now load the `customized.html` file in your browser. As you see, you have created
    a customized version of your layout with only three lines of code!
  prefs: []
  type: TYPE_NORMAL
- en: Variable declaration is not static
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Although variables act like constants, their **declaration** is not necessarily
    unchangeable or static. First, you can assign a value of one variable to another,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The value of `@var1` is now `3` and not `1`. Please understand that you don't
    need to create some kind of **reference** as the rule that the last declaration
    wins is applied here. The `@var1` variable will get the value of the last-declared
    `@var2` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the example code, you will also find the `@light-color: lighten(@dark-color,40%);`
    declaration. The `lighten()` function is a so-called built-in function of *Less*.
    [Chapter 3](ch03.html "Chapter 3. Nested Rules, Operations, and Built-in Functions"),
    *Nested Rules, Operations, and Built-in Functions*, will cover the built-in functions.
    The use of the `lighten()` function sets `@light-color` to a calculated color
    value based on `@dark-color`. You should also pay attention to the last declaration
    of `@dark-color`, as this is used for color calculation.'
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic declaration of variable values gives flexibility, but keep in mind that
    you should only declare a value once and you can't change it after the declaration.
  prefs: []
  type: TYPE_NORMAL
- en: Lazy loading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before you switch from variables to mixins, you should first know about **lazy
    loading**. In computer programming, this means to defer the initialization of
    an object until the point at which it is needed. Lazy loading is the opposite
    of eager loading. For *Less*, this means the variables are lazy loaded and do
    not have to be declared before they are actually used.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is all very well trying to understand the theoretical aspects, but now,
    it is time to understand how they work in practice through the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code gets compiled into the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Escaping values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Less* is an extension of CSS. This means that *Less* gives an error when it
    comes across invalid CSS or evaluates a valid CSS during compilation. Some browsers
    define properties with an invalid CSS. Well-known examples will include something
    such as `property: ms:somefunction()`. Some of these rules can be replaced by
    vendor-specific rules. It is important to note that invalid property values won''t
    get compiled in *Less*.'
  prefs: []
  type: TYPE_NORMAL
- en: A new function, `calc()`, in CSS3 is a native CSS way of doing simple math as
    a replacement for a value of any length.
  prefs: []
  type: TYPE_NORMAL
- en: In both cases, *Less* won't give us the right value when we compile or import.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code gets compiled into the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'From the preceding code, `@aside-width: 80px;` is the declaration of a variable
    with the name `aside-width`. This variable gets a value of 80 pixels. More information
    on variables will be covered in the following sections. However, more importantly,
    now the preceding result is wrong (or at least, not as expected) because the `calc()`
    function should be evaluated during the rendering time. During the render time,
    the `calc()` function has the ability to mix units, such as percentages and pixels.
    In the preceding code, `.content` is assigned a width of `100%` of the available
    space (in other words, all of the available space) minus `80px` (pixels).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Escaping** the values will prevent these problems. In *Less*, you can escape
    values by placing them between quotes (`""`) preceded by a tilde (`~)`. So, in
    this example, you should write `width: ~"calc(100% - @{aside-width})"`.'
  prefs: []
  type: TYPE_NORMAL
- en: Please note that the accolades are placed in aside-width's variable name, which
    is called **string interpolation**. In the escaped values, anything between quotes
    is used as it is, with almost no changes. The only exceptions here are the string
    **interpolated variables**.
  prefs: []
  type: TYPE_NORMAL
- en: Strings are sequences of characters. In *Less* and CSS, values between quotes
    are strings. Without escaping, *Less* compiles its strings into CSS strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, `width: "calc(100 – 80px)"` doesn''t make sense in CSS and neither
    does `width: calc(100% - @aside-width)` because `@aside-width` has no meaning.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, with escaping and string interpolation, you can start with the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will compile into the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the specific case of using the `calc()` function, the *Less* compiler has
    a **strict-math** option (used since Version 1.4). This is used with `–strict-math=on`
    in the command line or `strictMath: true` when using JavaScript. When the strict-math
    option is turned on, the width of `calc(100% - @aside-width);` will get compiled
    into `width: calc(100% - 80px);`. Notice that there have been many changes to
    this **strict-math** option during the development of versions 1.6, 1.7, and 2.0.'
  prefs: []
  type: TYPE_NORMAL
- en: Mixins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Mixins play an important role in *Less*. You saw mixins in the first chapter
    when the rounded-corners example was discussed. Mixins take their naming from
    object-oriented programming. They look like functions in functional programming
    but in fact act like C macros. Mixins in *Less* allow you to embed all the properties
    of a class into another class by simply including the class name as one of its
    properties, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will get compiled into the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In the final CSS code used on the website, every `<p>` paragraph tag will be
    styled with the properties defined in the `mixin()` function. The advantage will
    be that you can apply the same mixin on different classes. As seen in the rounded-corners
    example, you only have to declare the properties once.
  prefs: []
  type: TYPE_NORMAL
- en: Try opening `less/mixins.less` from the available downloadable files of this
    chapter. In the examples of this book, all mixins are saved to a single file.
    In this file, you can arrange your mixins based on their functions. Grouping them
    in a single file prevents us from breaking the code when removing or replacing
    other functional *Less* files. Your project contains an example in `sidebar.less`
    and `content.less`, where both files make use of the border-radius mixin. If we
    now replace `sidebar.less`, you won't break `content.less`. Of course, you also
    don't want to have the same kind of mixins twice in your code.
  prefs: []
  type: TYPE_NORMAL
- en: The box-sizing mixin in `less/boxsizing.less` will be handled as a specific
    case. The box-sizing mixin influences all elements, and you want to be able to
    replace the box-sizing model in its entirety.
  prefs: []
  type: TYPE_NORMAL
- en: The `less/mixins.less` file contains four mixins, which will be discussed in
    the following sections. The box-shadow and clearfix mixins also have complex structures
    such as **nesting**, but these mixins will be explained in further detail in the
    next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Basic mixins
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have seen the rounded-corners mixin already. A basic mixin looks like a
    class definition in CSS. Mixins are called inside classes and give these classes
    their properties.
  prefs: []
  type: TYPE_NORMAL
- en: In the example code in the `less/mixins.less` file, you will find the `.center-content`
    mixin which sets the value of the `margin` property to `0 auto`. This mixin is
    used to center align the header, content wrapper, and the footer.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that these center-content mixins are not the one and only solution. A general
    wrapper to center align the header, the content wrapper, and the footer at once
    will also work for this example layout. The name of this mixin can also be discussed.
    When you decide not to center the content anymore, the name of this mixin will
    not make any sense.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the `margin: 0 auto;` property, which in fact centers the content from
    the mixin. You should then reload `index.html` in your browser to see the effect.'
  prefs: []
  type: TYPE_NORMAL
- en: Parametric mixins
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As mentioned earlier, mixins act as functions in functional programming, and
    so, as functions, they can be parameterized. A parameter is a value used in combination
    with mixins, with the parameter''s name used as a reference to its value inside
    the mixin. The following code shows you an example of the usage of a parametric
    mixin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code gets compiled to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example shows how parameterization makes mixins very powerful.
    They can be used and reused to set properties depending on input values.
  prefs: []
  type: TYPE_NORMAL
- en: Default values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The parameters have an optional default value, which can be defined with `.mixins(@parameter:defaultvalue);`.
    To see how this works, you should consider the border-radius mixin in the `less/mixins.less`
    file, as seen in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Note that the default value here is `10px`.
  prefs: []
  type: TYPE_NORMAL
- en: Naming and calling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this book, mixins have meaningful and descriptive names, and just like variable
    names, these names are hyphenated. Using meaningful and descriptive names for
    your mixins makes your code more readable for others and easier to maintain. Parameters
    and variables both start with an `@` sign. The context should make it clear if
    it is a variable or mixin parameter that is being talked about.
  prefs: []
  type: TYPE_NORMAL
- en: 'To have a better understanding, consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This code can be compiled into the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Note that `@defaulvalue-parameter1` is a variable here.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code also illustrates the scope of a mixin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This code can be compiled into the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Here, the last declaration of `@parameter1` is outside the scope of the mixin,
    so the property is still set to `10`.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Multiple parameters for mixins can be separated by a comma or semicolon. Functional
    programmers often use a comma as a **separator.** In *Less*, a semicolon is preferred.
    A comma actually has an ambiguous role here, as they are not only used to separate
    parameters but also to separate list items in a **csv list**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `.mixin(a,b,c,d)` call calls the mixin with four parameters and similarly
    the `.mixin(a;b;c;d)` call does the same. Now, consider the case where you call
    the mixin with the`.mixin(a,b,c;d)` call. Only two parameters are used here, and
    the first parameter is a list of three items. If at least one semicolon is found
    in the parameter list, then the only separator considered will be the semicolon.
    The following code shows you the effect of adding an extra semicolon to the parameter
    list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This code can be compiled into the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Without this extra semicolon, you call a mixin with four parameters. In this
    case, the compiler throws an error: **RuntimeError: No matching definition was
    found for .mixin(a, b, c, d)**. What you actually need is a mixin containing `.mixin(@a,@b,@c,@d)`.'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, it has been made clear that mixins with the same name
    are allowed in *Less*. When finding different mixins with the same name, the compiler
    uses the mixins with the right number of parameters only or throws an error when
    no matching mixin is found. This form of parametric matching can be compared with
    **method overloading**, found in various programming languages.
  prefs: []
  type: TYPE_NORMAL
- en: 'If a mixin call matches more than one mixin, as shown in the following code,
    then all the matching mixins are used by the compiler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This code gets compiled into the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: More complex mixins for linear gradient backgrounds
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You now have enough theoretical knowledge to build more complex mixins. In this
    example, you will add directive **background gradients** of three colors to the
    footer columns of our layout.
  prefs: []
  type: TYPE_NORMAL
- en: 'The end result should look like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![More complex mixins for linear gradient backgrounds](img/1465OS-02-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Linear gradient backgrounds built with *Less*
  prefs: []
  type: TYPE_NORMAL
- en: These gradient backgrounds have been chosen because of their complexity and
    well-documented changes over time. The final result will be a complex mixin, which
    is definitely not perfect, but improves the result significantly. You can be sure
    that you will have to change your gradient mixin from time to time because of
    the drop in support for old browsers, new browsers, changing specifications, and
    new insights. Refer to [https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Using_CSS_gradients](https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Using_CSS_gradients)
    for some more examples.
  prefs: []
  type: TYPE_NORMAL
- en: You can't prevent these necessary changes, but you can minimize the time spent
    on keeping your mixins up to date. *Less* guarantees that all of your background
    gradients are based on the same mixin defined in a single place.
  prefs: []
  type: TYPE_NORMAL
- en: At a basic level, background gradients in CSS are defined as images. For this
    reason, they are applied on the **background-image property**.
  prefs: []
  type: TYPE_NORMAL
- en: In this book, gradients are set on the `background-image` property. Other examples
    (elsewhere and perhaps in other books) will set them on the `background` property.
    There is no difference in their definitions. CSS defines different properties
    for backgrounds such as `background-image`, `background-color`, `background-size`,and
    `background-position`. The `background` property is the shorthand for all of them
    together. When you define the first value of the `background` property as an image,
    or gradient in this case, all the other property values are set to their default
    value.
  prefs: []
  type: TYPE_NORMAL
- en: 'You start your mixin by making a list of the following **requirements**:'
  prefs: []
  type: TYPE_NORMAL
- en: You want a parameter to set the direction of your gradient, where you will use
    degrees
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your gradient will consist of three colors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After this, you define a list of browsers and the browser version you have to
    support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, you can define the first lines of your mixin as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '![More complex mixins for linear gradient backgrounds](img/1465OS-02-04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'One of the ways to illustrate how the gradient line of 45 degrees works. This
    was taken from: [http://dev.w3.org/csswg/css-images-3/](http://dev.w3.org/csswg/css-images-3/),
    Copyright 2013 W3C, 11 September 2013'
  prefs: []
  type: TYPE_NORMAL
- en: 'The background mixins have five parameters, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The first parameter describes the direction in degrees. The number of degrees
    gives the angle between the vertical and the gradient direction. The description
    of the direction starts at the bottom. At the bottom, the angle is 0 degrees and
    describes a gradient from bottom to top. Then the angle goes clockwise to 90 degrees
    point that describes a gradient from left to right, and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next three parameters are the three colors of your gradient, which are the
    default values set for it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fifth and last parameter defines where the middle color has its real value.
    The percentage here is a percentage of the width of the element that the gradient
    is applied on. The first and last color has 0 and 100 by default.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Modern browsers, such as IE version 11, Firefox version 16+, Opera version
    12.10+, Safari version 7+, and Chrome version 26+, support these background-image
    properties. For older browsers, vendor-specific rules have to be added. The first
    problem here is that vendor-specific rules use a different way to define the angle.
    To compensate for this, you can use a correction of 90 degrees using the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The `-ms background-image` property is used by IE10, as an older version of
    IE is unable to support a background image. Alternatively, you can add a filter
    to support a two-color gradient. There is no support for using this filter in
    combination with a fallback image, so you will have to choose webkit-based browsers,
    such as Chrome and Safari, that use `-webkit-linear-gradient`; however, if you
    have to support older versions of these browsers, you will have to use `-webkit-gradient`.
    Note that `-webkit-gradient` has an unusual syntax. For example, your final mixin
    could look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code shows that even when using *Less*, our code can still be
    complex. Unless this complexity can support different browsers, you can see the
    advantage of using *Less*, which allows you to handle this code only once and
    in a single place.
  prefs: []
  type: TYPE_NORMAL
- en: The code in the preceding example can be found in `directivebackgrounds.html`
    and `less/directivebackgrounds.less`. If you wonder why you should use a CSS background
    gradient at all after all of this, then please take a look at [http://lea.verou.me/css3patterns/](http://lea.verou.me/css3patterns/)
    and see what is possible.
  prefs: []
  type: TYPE_NORMAL
- en: Special variables – @arguments and @rest
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Less* defines two special variables. The `@arguments` variable is the first
    one and contains a list of all the arguments that are passed. The `@arguments`
    variable exists inside mixins. In *Less*, lists are defined separately with spaces,
    so you can use `@arguments` for properties that can be set by a list of values.
    Properties such as `margin` and `padding` accept lists in their shorthand notation,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'This code can be compiled into the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The second special variable is `@rest`. `@rest...`, which binds all odd arguments
    after the preceding arguments from the caller to a list. By doing this, `@rest...`
    gives the opportunity to call a mixin with an endless argument list. Please note
    that the three ending dots are part of the syntax. The following code shows how
    `@rest...` binds all the odd parameters after the `@a` variable to the `property2`
    property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'This code will get compiled into the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'You should also consider using `@rest...` as a csv list. To do this, you can
    rewrite the `.backgroundgradient` mixin from `less/mixinswithdirectivebackgrounds.less`
    to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the mixin will accept an endless list of colors, and you can use it with
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The following figure shows the result of the code using this background mixin:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Special variables – @arguments and @rest](img/1465OS-02-03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Return values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you are used to functional programming or even know a mathematical function,
    you expect mixins to have a **return value**. This simply means putting `x` into
    it and getting `y` back. Mixins don''t have a return value, but you can mimic
    this behavior using their scope. A variable defined in a mixin will be copied
    to the **scope of the caller**, unless the variable has been defined already in
    the caller''s scope. The following example will make this clear:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'This code will get compiled into the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'If you look at the preceding example, you can compare `property2: @par2;` with
    a function such as `property2 = returnmixin();`.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using the scope to mimic a return value can also be applied on mixins. A mixin
    defined in another mixin can be used in the scope of the caller. However, these
    are not protected by the scope like variables are! This process is called **unlocking**.
    For now, unlocking is outside the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the behavior of a mixin
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To make mixins more flexible, it will be useful to influence their output based
    on their input parameters. *Less* offers different mechanisms in order to do this.
  prefs: []
  type: TYPE_NORMAL
- en: Switches
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Imagine that you have a mixin, `color();` which should set the color property
    to white or black depending on the context. Set the context with a `@context:
    light;` declaration and declare two mixins with the same name, as shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Now you can use the `.color(@context);` mixinin your code which sets the `color`
    property of your class to white or black, depending on the value declared to `@context`.
    This may not seem useful now, but it will be useful within your growing project.
    Take a look at the Bootflat project at [http://www.flathemes.com/](http://www.flathemes.com/).
    This project provides color variants of Twitter's Bootstrap. **Twitter's Bootstrap**
    is a **CSS framework** based on *Less*. Bootflat defines two styles, where one
    style is based on the improved style of Bootstrap 3.0 and the other style is a
    Square UI style with the rounded corner removed. This project uses one switch
    to compile two different styles.
  prefs: []
  type: TYPE_NORMAL
- en: Argument matching
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Less* allows different mixins with the same name. If there are such mixins,
    every mixin which matches the caller''s parameter list is used. Refer to the following
    color mixins:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'With the color mixins defined in the preceding code, `.color(white)` compiles
    into `color: white;` and `.color(white,black)` will give you `color: gray;`. Note
    that the `.color(white);` call doesn''t match the `.color(@color1,@color2)` mixin,
    which needs two arguments, and so the compiler did not use it.'
  prefs: []
  type: TYPE_NORMAL
- en: Guarded mixins
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Mixins of the same name with the same number of arguments are also possible
    in *Less*. All the matches are used in this case, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'This code will be compiled into the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Please also note that *Less* converts the named color `white` to `#ffffff;`
    here.
  prefs: []
  type: TYPE_NORMAL
- en: Two declarations of `color` don't make sense in this case. *Less* doesn't filter
    out double declarations unless they are used in the exact same way.
  prefs: []
  type: TYPE_NORMAL
- en: '**Guards** can be used to prevent trouble with double-defined mixins. A guard
    is defined with a keyword when it is followed by a condition. When the condition
    is true, a mixin is used. The following example makes things clear:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'This code will be compiled to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Guards can be used as an *if* statement in programming. The comparison operators
    such as `>`, `>=`, `=`, `=<`, and `<` can be used. One or more conditions can
    be combined in the same way when separated with commas, which evaluates as true
    if one of them is true.
  prefs: []
  type: TYPE_NORMAL
- en: The keyword `and` can be used to evaluate as true only when both conditions
    are true, for instance, `when @a>1` `and` `@<5`. And finally, a condition can
    be negated with the keyword `not`, for instance, `when (not a = red)`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you have used CSS media queries earlier, then you must realize that guards
    act in the very same way that a media query does in CSS.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, guard conditions can also contain built-in functions. These functions
    will be discussed in the next chapter and act on all defined variables when they
    are not part of the argument list. The built-in functions of the guard conditions
    can be seen in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'This code can be compiled into the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'In the case of `@style: dark;` or `mixin(1);`, there was no match.'
  prefs: []
  type: TYPE_NORMAL
- en: Using guards and argument matching to construct loops
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When *Less* doesn''t find a **matching mixin**, it goes to the next evaluation
    and doesn''t break. This can be used in combination with guards and argument matching
    to construct loops. To show this, imagine 10 **classes**, each containing a numbered
    background image. The `.class1` class has the `background-image` property value
    set to `background-1.png`, the `.class2` class has set the value of the `background-image`
    property to `background-2.png`, and so on, as seen in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'This code can be compiled into the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The last mixin perhaps looks complex when you see it first, but if you try to
    evaluate the mixin yourself, you will see that it actually contains a lot of stuff
    you have learned before.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding code, the `setbackground` mixin calls itself. Programmers will
    call this a **recursion**. What happens here?
  prefs: []
  type: TYPE_NORMAL
- en: The `.setbackground(10);` call matches the `.setbackground(@number)` mixin when
    `@number>0`, so please make use of this. The first evaluation of `.setbackground(
    @number - 1 );` also matches the mixin. This means that the compiler runs the
    mixin again. This will repeat until `@number -1` is `0`; no matches can be found
    anymore. Now the compiler will read ahead of where it stopped in order to use
    the mixin.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last stop was at `@number = 1`, so it evaluates the `.class@{number} {
    background-image: ~"url(backgroundimage-@{number}.png)"; }` declaration for the
    `@numer = 1` condition. When it stopped before, it was at `@number = 2`. So, it
    evaluates the `.class@{number} { background-image: ~"url(backgroundimage-@{number}.png)";
    }` declaration for the `@numer = 2` condition, and so on. When we are back at
    `@numer = 10`, all the code has been compiled. So, the compiler stops.'
  prefs: []
  type: TYPE_NORMAL
- en: Besides guards and argument matching, the preceding example also contains an
    interpolated property in the `.class@{number}` class declaration, as well as an
    example string interpolation with escaping when declaring the `~"url(backgroundimage-@{number}.png)";`
    code. Mixins also show the need to use an additional space when performing calculations.
    So, `@number - 1` won't be evaluated as one `@number-1` variable.
  prefs: []
  type: TYPE_NORMAL
- en: The !important keyword
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The chapter ends with a note on the `!important` keyword in *Less*. Using `!important`
    in a declaration gives the declaration the highest precedence when two or more
    selectors match the same element. The `!important` keyword overrules inline styles,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code will show the text in green. As the example shows you, you
    can use `!important` to change the styles, which you cannot edit, of the source
    with inline CSS. It can also be used to make sure a style is always applied. Nevertheless,
    please use `!important` with care, as the only way to overrule `!important` is
    to use another `!important`. Any incorrect or unnecessary use of `!important`
    in *Less* will make your code messy and difficult to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Less*, you can not only use `!important` for properties, but you can also
    use it with mixins. When `!important` is set for a certain mixin, all the properties
    of this mixin will be declared with the `!important` keyword. This can be seen
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'This code will be compiled into the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about variables and mixins. You have seen how defining
    variables and mixins at a single place will reduce your code and make it easy
    to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn more about mixins and how to nest and extend
    them. You will also read about the built-in functions of *Less*. Built-in functions
    can be used to manipulate values in mixins and other parts of your code.
  prefs: []
  type: TYPE_NORMAL
