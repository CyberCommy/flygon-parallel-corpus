- en: Chapter 3. Troubleshooting a Web Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the first and second chapters of this book, we covered the troubleshooting
    process, common locations for information, and useful troubleshooting commands.
    In this chapter, we will run through an example problem that has been created
    in order to demonstrate multiple troubleshooting and remediation steps. In particular,
    we will look at the steps required to troubleshoot issues with web-based applications.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this chapter, I will go through each step of the troubleshooting
    process and explain the reasoning behind each step. While the problem that this
    chapter covers may not be an extremely common issue, it is important to look at
    the process and tools used. The process and tools used in this chapter can be
    applied to most web application issues.
  prefs: []
  type: TYPE_NORMAL
- en: A small back story
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Within each chapter of this book, you will find an example issue that covers
    the common troubleshooting topics. While the focus of this book is to show the
    commands and concepts necessary to resolve these types of issues, it is also important
    to show the process around resolving them. To do this, we will explore these issues
    as if we were a new systems administrator who recently joined a new company.
  prefs: []
  type: TYPE_NORMAL
- en: Each issue will be presented a little differently, but each one will start with
    an issue being reported.
  prefs: []
  type: TYPE_NORMAL
- en: The reported issue
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While starting our new role at a new company, we have been assigned to answer
    phone calls for the company's **Network Operations Center** (**NOC**). In this
    role, we will focus on resolving issues within the company's environment and are
    expected to do so very quickly. For our first issue, we have received a phone
    call; on the other end of this phone call is a business user who has an issue.
    *All of a sudden, our blog is showing an installation page and not our posts!*
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a reported issue, let's start working through the troubleshooting
    process.
  prefs: []
  type: TYPE_NORMAL
- en: Data gathering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we look back at [Chapter 1](part0014_split_000.html#DB7S1-8ae10833f0c4428b9e1482c7fee089b4
    "Chapter 1. Troubleshooting Best Practices"), *Troubleshooting Best Practices*,
    the first step in the troubleshooting process is to understand the problem statement.
    In this section, we are going to explore how the problem was reported and will
    try to collect any data that we can to find the root cause of the issue.
  prefs: []
  type: TYPE_NORMAL
- en: For this example, we were notified of the issue via a phone call. This is actually
    lucky as we have an end user on the phone and can ask questions to get more information
    from him/her.
  prefs: []
  type: TYPE_NORMAL
- en: Before asking the person reporting the issue for more information, let's first
    take a look at what was already answered. *All of a sudden, our blog is showing
    an installation page and not our posts!*
  prefs: []
  type: TYPE_NORMAL
- en: At first, you may feel that this problem statement is vague; this is because
    it is vague. However, there is still quite a bit of useful information in this
    single sentence. If we dissect the reported issue, we can gain a better understanding
    of the problem.
  prefs: []
  type: TYPE_NORMAL
- en: '"Our blog is showing an installation page"'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '"All of a sudden"'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '"not our posts!"'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'From these three segments, we can assume the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The blog is showing an unexpected page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This blog was previously showing posts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At some point, this changed and it seems that it was somewhat recently
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While the above is a pretty good start for determining whether there is an issue
    and what it is related to, it does not give us enough to create a hypothesis yet.
  prefs: []
  type: TYPE_NORMAL
- en: Asking questions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to formulate a hypothesis, we will need more information. One method
    of getting this information is to ask the person reporting the issue. In order
    to get more information, we will ask the business user the following questions:'
  prefs: []
  type: TYPE_NORMAL
- en: When was the last time you saw the blog working?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Last night.
  prefs: []
  type: TYPE_NORMAL
- en: What is the blog's address?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`http://blog.example.com`'
  prefs: []
  type: TYPE_NORMAL
- en: Did you receive any other errors?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: No.
  prefs: []
  type: TYPE_NORMAL
- en: While the above questions are not enough to identify the problem, they do give
    us a starting point of where to start looking.
  prefs: []
  type: TYPE_NORMAL
- en: Duplicating the issue
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As previously stated in [Chapter 1](part0014_split_000.html#DB7S1-8ae10833f0c4428b9e1482c7fee089b4
    "Chapter 1. Troubleshooting Best Practices"), *Troubleshooting Best Practices*
    one of the best methods of finding information is to duplicate the issue. In this
    case, it seems that we can duplicate the issue by simply going to the address
    provided.
  prefs: []
  type: TYPE_NORMAL
- en: '![Duplicating the issue](img/00002.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In the previous screenshot, we can see that the blog is performing just as the
    user described. When we went to the provided URL, we were presented with a default
    WordPress installation screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Does this give us any clue about what the cause of the issue is? No, not really,
    not unless we have seen this issue before. While this may not tell us the cause
    of the issue, it does confirm that the issue that the user has reported is reproducible.
    This step has also told us the name of the software that we are troubleshooting:
    WordPress.'
  prefs: []
  type: TYPE_NORMAL
- en: WordPress is one of the most popular open source blogging platforms. In this
    chapter, it is assumed that we have no experience managing WordPress and will
    need to find any information that we need around this web application through
    online sources.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the environment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since we are the new systems administrator, at this point, we know very little
    about this environment, which means that we have little knowledge of how this
    blog is deployed. In fact, we do not even know which server it runs from.
  prefs: []
  type: TYPE_NORMAL
- en: Where is this blog hosted?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One thing that we do know, however, is that all servers managed by our company
    have IPs within the 192.168.0.0/16 subnet. In order to determine whether this
    is an issue that we can resolve, we first need to determine whether the blog is
    on a server managed by our company. If this blog doesn't exist on a server managed
    by this company, our troubleshooting options may be limited.
  prefs: []
  type: TYPE_NORMAL
- en: One way to determine where the blog is hosted is to simply look up the IP address
    of the `blog.example.com` address.
  prefs: []
  type: TYPE_NORMAL
- en: Lookup IPs with nslookup
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There are many ways to look up the IP address of a DNS name; the command that
    we will discuss is the `nslookup` command. To use this command, simply execute
    `nslookup` followed by the DNS name to look up: `blog.example.com` for this example.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding output, the result may be a bit confusing for those unfamiliar
    with `nslookup`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We know that the preceding information is the result of the `nslookup` query.
    This block is saying that the `blog.example.com` domain's address is `192.168.33.11`.
    The first block of output from `nslookup` is simply telling us which DNS server
    was used to look up this information.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We can see from this block that the DNS server used was `192.0.2.1`.
  prefs: []
  type: TYPE_NORMAL
- en: What about ping, dig, or other tools?
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There are many commands that we could have used to look up the IP address of
    this domain. We could have used `dig`, `host`, or even `ping`. The reason that
    we chose the `nslookup` command is that for the most part, it is included with
    most operating systems. So, irrespective of whether you need to look up an IP
    address from a Windows, Mac, or Linux desktop, you can always use the `nslookup`
    command.
  prefs: []
  type: TYPE_NORMAL
- en: One caveat with the `nslookup` command, however, is that it specifically uses
    DNS to look up the address. It does not respect values in `/etc/hosts` or any
    other name service specified in `/etc/nsswitch.conf`. This is something that we
    will explore more in the later chapters; for now, we will assume that the IP address
    of `192.168.33.11` is the correct IP.
  prefs: []
  type: TYPE_NORMAL
- en: Ok, it's within our environment; now what?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since we are working with a Linux server, the most common way to manage that
    server is via **Secure Shell** (**SSH**). SSH is a secure network service that
    allows users to remotely access a server's shell. For this book, we are going
    to assume that you are already familiar with logging into a server via SSH. Whether
    you use the SSH command-line client or a desktop client like PuTTY, it is assumed
    that you are able to log into the server with SSH.
  prefs: []
  type: TYPE_NORMAL
- en: In this scenario, we use a laptop that has its own shell environment. To log
    into our server, we simply execute the `ssh` command from our terminal window.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Once logged in, the first information-gathering command that we execute is the
    `w` command.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In [Chapter 2](part0019_split_000.html#I3QM2-8ae10833f0c4428b9e1482c7fee089b4
    "Chapter 2. Troubleshooting Commands and Sources of Useful Information"), *Troubleshooting
    Commands and Sources of Useful Information*, we covered the `w` command and mentioned
    that it is the first command executed. We can see quite a bit of useful information
    in the output of the `w` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'From this output, we can determine the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Only 1 user is currently logged in (which is our login session)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The server in question has been up for 2 days
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The load average is low, which suggests normal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overall, at the first glance, the server seems to be performing normally. The
    fact that the issue started last night suggests that the issue did not start after
    the reboot 2 days ago. With the load average low, it is also safe at this point
    to assume that the issue is not related to the system load.
  prefs: []
  type: TYPE_NORMAL
- en: What services are installed and running?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since we have never logged into this server before, and are completely new to
    this environment, the first thing that we should do is find out what services
    are running on this server.
  prefs: []
  type: TYPE_NORMAL
- en: Since we know from the install page that the blog is a WordPress blog, we can
    search Google about the services that it requires. We can do this by using the
    search term "WordPress install requirements."
  prefs: []
  type: TYPE_NORMAL
- en: 'This search string returned with the following URL as the first result: [https://wordpress.org/about/requirements/](https://wordpress.org/about/requirements/).
    This page contains the installation requirements for WordPress and lists the following:'
  prefs: []
  type: TYPE_NORMAL
- en: PHP 5.2.4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MySQL 5.0 or higher
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Either Apache or Nginx web servers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From the fact that we can access the install page, we can assume that a web
    server and PHP are installed and somewhat working. However, it is always best
    to validate rather than assume.
  prefs: []
  type: TYPE_NORMAL
- en: Validate the web server
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Since WordPress recommends either the **Apache** or the **Nginx** web server,
    we first need to determine which is installed and, more importantly, identify
    which is in use for this WordPress application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are a few ways to identify which web servers are installed and
    running:'
  prefs: []
  type: TYPE_NORMAL
- en: We could use `rpm` to look at the packages installed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We could use `ps` to look at the processes running
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We could simply go to a non-existent page via a browser and see whether the
    error page says which web server is running
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can also go to `/var/logs` and look around to see what log files exist or
    don't exist
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of these methods are valid and have their own benefits. For this example,
    we will use a *5th* method (not mentioned earlier), which will answer two questions
    about the web server configuration on this server.
  prefs: []
  type: TYPE_NORMAL
- en: The first step of this method will be to determine which process is listening
    on port 80.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As discussed in [Chapter 2](part0019_split_000.html#I3QM2-8ae10833f0c4428b9e1482c7fee089b4
    "Chapter 2. Troubleshooting Commands and Sources of Useful Information"), *Troubleshooting
    Commands and Sources of Useful Information*, the `netstat` command can be used
    to determine which ports are in use with the `–na` flags. If we simply add the
    `–p` (port) flag to `netstat`, we can also see which process is listening on each
    port.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In order to identify which processes are listening on each port, the `netstat`
    command must be executed with **super user**-level permissions. As such, we use
    the `su` command to switch to the **root** user before executing `netstat`.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this book, any command preceded with `$` is run as an unprivileged
    user, while commands preceded with `#` are executed as the root user.
  prefs: []
  type: TYPE_NORMAL
- en: Port 80 is the default port for HTTP requests; as such, if we look back at the
    steps performed to duplicate the issue at hand, we can see that the address used
    was `http://blog.example.com`. Since this is an HTTP address and does not specify
    a different port, this means that the service that serves the WordPress installation
    page is listening on port 80.
  prefs: []
  type: TYPE_NORMAL
- en: From the output of the `netstat` command, we can see that process 952 is listening
    on port 80\. The `netstat` output also shows that process 952 is running the `httpd`
    binary. On RHEL systems, this `httpd` binary is most often Apache.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can validate whether this is the case with the `ps` command with the `–elf`
    flags discussed in [Chapter 2](part0019_split_000.html#I3QM2-8ae10833f0c4428b9e1482c7fee089b4
    "Chapter 2. Troubleshooting Commands and Sources of Useful Information"), *Troubleshooting
    Commands and Sources of Useful Information*. We will also search the output of
    the `ps` command with the `grep` command, searching for the string "952":'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: With the above output, we can see that process 952 and its child processes are
    running under the **apache** user. This confirms that the software in use is most
    likely Apache, but to be extra diligent, we can execute the `httpd` binary with
    the `–version` flag to print the version of the web server software.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The output of the `httpd` binary shows that it is in fact the Apache web server,
    which matches the WordPress requirements.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we have found out the following facts about the web server in
    use for this server:'
  prefs: []
  type: TYPE_NORMAL
- en: The web server is Apache
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Apache process is running
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Apache version is 2.4.6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Apache process is listening on port 80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is possible to identify the same information by using other methods such
    as `rpm`. The good part of this method is that if the server has two web server
    services installed, we know which of these services is listening on port 80\.
    This also tells us which service provides the WordPress install page.
  prefs: []
  type: TYPE_NORMAL
- en: Validating the database service
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A common WordPress implementation is to run the Apache, PHP, and MySQL services
    all on one server. Sometimes, however, the MySQL service will be run from another
    server or servers. To better understand the environment, we should check whether
    this environment runs MySQL locally or from another server.
  prefs: []
  type: TYPE_NORMAL
- en: 'To check this, we will once again use the `ps` command; this time, however,
    we will use `grep` to search for a process that matches the string "mysql":'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from the preceding output, there is in fact a MySQL process
    currently running. It is also important to note that the `ps` output shows that
    the `mysqld` process is using the following option: `–log-error=/var/log/mariadb/mariadb.log`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is important for two reasons: The first is that this is the location of
    the log file for the `mysqld` process, and the second is the fact that this log
    file is for **MariaDB**, which is different from MySQL.'
  prefs: []
  type: TYPE_NORMAL
- en: We can confirm whether MySQL or MariaDB is installed by using the `rpm` and
    `egrep` commands.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `egrep` command is similar to `grep`; however, it accepts search strings
    in the form of regular expressions. In the above command, we used `egrep` to search
    for either the string "`mariadb`" or the string "`mysql`." From the preceding
    output, we can see that this server does in fact have MariaDB installed but not
    MySQL.
  prefs: []
  type: TYPE_NORMAL
- en: With this information, we can make the assumption that the `mysqld` process
    that is running is in fact a MariaDB binary. We can verify this by using the `rpm`
    command with the `–q` (query) and `–l` (list all files) flags.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We can see from the `rpm` command's output that the running `/usr/libexec/mysqld`
    binary is deployed as part of the **mariadb-server** package. Showing that the
    running database process is in fact MariaDB and was installed via the mariadb-server
    package.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we have found the following facts about the database service
    running on this server:'
  prefs: []
  type: TYPE_NORMAL
- en: The database service is actually MariaDB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MariaDB is running
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The log files for this service are at `/var/log/mariadb/`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While MariaDB is a drop-in replacement for MySQL, the requirements for WordPress
    do not list it as the preferred database service. It is important to make note
    of this difference as it may determine the root cause of the reported issue.
  prefs: []
  type: TYPE_NORMAL
- en: Validating PHP
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Since we know that PHP is required for WordPress, we should also check whether
    it is installed. We can validate this by again using the `rpm` command.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: PHP by itself is not designed to run as a service such as Apache or MySQL, but
    rather as a web server module. However, it is possible to use a service such as
    `php-fpm` as an application server. This allows PHP to run as a service and to
    be called by an upstream web server.
  prefs: []
  type: TYPE_NORMAL
- en: To check whether this server runs `php-fpm` or any other service that frontends
    PHP, we can again use the `ps` and `grep` commands.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: By using the `ps` command, we do not see any specific PHP service; however,
    when going to the blog, we were able to see the install page. This suggests that
    PHP is configured to run via Apache directly. We can validate this by executing
    the `httpd` binary again with the `–M` (modules) flag.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `–M` flag will tell the `httpd` binary to list all of the loaded modules.
    Included in this list is `php5_module`, which means that this installation of
    Apache is able to run PHP applications via `php5_module`.
  prefs: []
  type: TYPE_NORMAL
- en: A summary of installed and running services
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'At this point, we have identified the following from our data collection:'
  prefs: []
  type: TYPE_NORMAL
- en: The WordPress requirement of Apache is installed and running
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The WordPress requirement of MySQL appears to be met by MariaDB, which is installed
    and running
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The WordPress requirement of PHP is installed and appears to be working
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It appears that WordPress is deployed in a single-server setup rather than a
    multi-server setup
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can assume for now that these facts mean that the issue is not caused by
    a missing WordPress requirement.
  prefs: []
  type: TYPE_NORMAL
- en: By gathering all of these data points, we have not only learned more about the
    environment that we are troubleshooting but also eliminated several possible causes
    of this issue.
  prefs: []
  type: TYPE_NORMAL
- en: Looking for error messages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that the installed and configured services have been identified, we know
    where to start looking for errors or helpful messages. In the next stage of data
    collection, we are going to look through the various log files of these services
    to try and to identify any errors that may indicate the cause of this issue.
  prefs: []
  type: TYPE_NORMAL
- en: Apache logs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since Apache calls PHP when web requests are made, the most likely log file
    to contain PHP-related errors is the Apache error log. The default log location
    for RHEL's `httpd` package is `/var/log/httpd/`. However, we don't know just yet
    whether the running `httpd` service is the RHEL packaged version.
  prefs: []
  type: TYPE_NORMAL
- en: Finding the location of Apache's logs
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Since we don't know the location of Apache's logs, we will need to find them.
    One way to find log files is to simply look in `/var/log` for any file or folder
    that matches the name of the service in question. This solution, however, is a
    bit too simple for our example.
  prefs: []
  type: TYPE_NORMAL
- en: To find the location of the `httpd` log files, we will use a method discussed
    in [Chapter 2](part0019_split_000.html#I3QM2-8ae10833f0c4428b9e1482c7fee089b4
    "Chapter 2. Troubleshooting Commands and Sources of Useful Information"), *Troubleshooting
    Commands and Sources of Useful Information* and search through the service's configuration
    files. The `/etc` folder is the default folder for system configuration files.
    It is also the standard location for service configurations. Therefore, it is
    fairly safe to assume that the `/etc/` folder will contain a configuration file
    or folder for the `httpd` service.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding commands, we can see that we can switch to the `/etc/httpd`
    folder, which contains several configuration files. Since we don't know which
    configuration file contains the logging configuration, we could spend quite a
    bit of time reading through each configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: To make this process faster, we can use the `grep` command to search through
    all of the files for the string "`log`." Since the `/etc/httpd/` folder contains
    subfolders, we can simply add the `–r` (recursive) flag to cause the `grep` command
    to search through files contained in these subfolders.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The defined logs use the relative path of `logs/`; this path is relative to
    the `httpd` services running folder. In this case, this means that the logs' folder
    is actually `/etc/httpd/logs`; however, this may not always be the case. To validate
    whether this is the case, we can simply perform a folder listing with the `ls`
    command in the `/etc/httpd` folder.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: From the `ls` command, we can see that `/etc/httpd/logs` exists; however, this
    is not a folder but a symbolic link to `/var/log/httpd/`. This means that the
    two log files, namely `access_log` and `error_log`, are actually located within
    the `/var/log/httpd/` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing the logs
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we know where the log files are located, we can search these log files
    for any useful information. To do this, we will use the `tail` command.
  prefs: []
  type: TYPE_NORMAL
- en: The `tail` command is a useful command that can be used to read the last part
    of a file or files. By default, when `tail` is executed without any flags, the
    command will print the last 10 lines of the specified file.
  prefs: []
  type: TYPE_NORMAL
- en: For our troubleshooting, we want to not only see the last 10 lines of data but
    also watch the file for any new data being appended. To do this, we can use the
    `–f` (follow) flag, which tells `tail` to follow the specified file or files.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The RHEL 7 implementation of the `tail` command can actually follow multiple
    files at the same time. To do this, simply specify all of the files that you wish
    to read or follow when executing the command. The above is an example of using
    `tail` to read two files at once.
  prefs: []
  type: TYPE_NORMAL
- en: While there are no immediate PHP errors caused by the last 10 lines of each
    file, this does not necessarily mean that these files will not show the errors
    that we need. As this is a web-based application, we may need to load the application
    in order to trigger any errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could simply open our browser and once again navigate to `http://blog.example.com`.
    However, for this example, we will utilize a very useful troubleshooting command:
    `curl`.'
  prefs: []
  type: TYPE_NORMAL
- en: Using curl to call our web application
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The `curl` command can be used as a client to access many different types of
    protocols, everything from FTP to SMTP. This command is particularly useful when
    troubleshooting a web application as it can be used as an HTTP client.
  prefs: []
  type: TYPE_NORMAL
- en: When troubleshooting a web application, you can use the `curl` command to make
    an `HTTP`, `GET`, or `POST` request to a specified URL, which when placed in the
    verbose mode with the `–v` (verbose) flag can produce quite a bit of interesting
    information.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The preceding output shows four key pieces of information that I want to highlight.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The preceding line shows us that when we addressed the page called `blog.example.com`,
    we did in fact go to the server at `192.168.33.11`. While we already identified
    that `blog.example.com` resolved to `192.168.33.11`, this line confirms that the
    output from this command produces data from the expected system.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The second key piece of information shows the HTTP status code that was provided
    by the web server.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the web server replied with a status code of `302`, which is used
    to indicate a temporary redirect. When a browser requests a page and the web server
    replies with a 302 status code, the browser knows to redirect the end user to
    another page.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The next page is determined by the **Location** HTTP header. This header, which
    is assigned by the web server, along with the HTTP status code of 302 will cause
    any browser to redirect the end user to the `/wp-admin/install.php` page.
  prefs: []
  type: TYPE_NORMAL
- en: This explains why we see an installation page when we navigate to `blog.example.com`
    as the web server simply responds with this 302 redirect.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The fourth key piece of information is the HTTP header **X-Powered-By**; this
    is an HTTP header added by PHP. This header is added by PHP when the requested
    page is processed as by PHP, which means that our curl request was actually processed
    by PHP.
  prefs: []
  type: TYPE_NORMAL
- en: More importantly, we can see that the version of PHP (5.4.16) meets our minimum
    requirements as outlined by WordPress.
  prefs: []
  type: TYPE_NORMAL
- en: Requesting a non-PHP page
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We can see when requesting a non-PHP page that no **X-Powered-By** header is
    added in the web server reply. We can do this by requesting an invalid URL.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: As we can see from the output obtained when requesting a non-PHP based page,
    the X-Powered-By header is not present. This indicates that the web server did
    not process this page as PHP.
  prefs: []
  type: TYPE_NORMAL
- en: The presence of the X-Powered-By header tells us that when we requested the
    `blog.example.com` page, it was processed by PHP. This also means that the HTTP
    status code of 302 was a response provided by WordPress. This information is important
    as it means that PHP is most likely processing pages without any issue, thereby
    eliminating PHP as a possible root cause of the reported issue, at least for now.
  prefs: []
  type: TYPE_NORMAL
- en: We can validate this further by reviewing any log entries generated from the
    abovementioned web requests.
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing generated log entries
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: When making the abovementioned requests with `curl`, we should have caused new
    log messages to be appended to the two `httpd` logs. Since we were using the `tail`
    command to continuously follow the log files, we can return to our terminal and
    review the new messages.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: After our HTTP request to the blog URL, the only entry in either log was the
    preceding one. However, this is only an informational log message and not an error
    that would explain the issue. However, the informational log message is also a
    key data point. If there were an issue with the PHP code or processing, an error
    message similar to the following would have been generated.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The absence of a PHP error actually confirms that PHP is working as expected.
    This when combined with the `curl` results leads us to confidently assume that
    PHP is not the root cause.
  prefs: []
  type: TYPE_NORMAL
- en: What we learned from httpd logs
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: While the `httpd` service logs may not have shown us an error that could answer
    why this issue is appearing, they have allowed us to eliminate a possible cause.
    While troubleshooting, you will often find yourself ruling out many possible causes
    before finding the exact cause of an issue. The troubleshooting steps mentioned
    earlier are exactly that, thereby eliminating possible causes.
  prefs: []
  type: TYPE_NORMAL
- en: Verifying the database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Earlier while checking what services were running, we found that the MariaDB
    service was running. We did not, however, validate that we can access the service
    or that the WordPress application can access this database service.
  prefs: []
  type: TYPE_NORMAL
- en: To validate that we can access the MariaDB service, we can simply use the `mysql`
    command.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The `mysql` command is actually a MariaDB client command. When run from the
    command line as the **root** user (as shown above), the `mysql` command by default
    will log into the MariaDB service as the MariaDB root user. While this is the
    default behavior, it is possible to configure the MariaDB service to disallow
    direct root login.
  prefs: []
  type: TYPE_NORMAL
- en: The abovementioned results imply that MariaDB allows direct root login, which
    shows that the MariaDB service itself is up and accepting connections. What they
    do not reveal is whether or not the WordPress application can access the database.
  prefs: []
  type: TYPE_NORMAL
- en: To determine this, we will need to log into the MariaDB service with the same
    username and password as the application.
  prefs: []
  type: TYPE_NORMAL
- en: Verifying the WordPress database
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In order to connect to the MariaDB service with the same credentials as WordPress,
    we need to obtain these credentials. We could ask the person who reported the
    issue for these details, but being a business user, they most likely would not
    know. Even if they worked with WordPress daily, in general, the database username
    and password are configured by one person and only used during installation.
  prefs: []
  type: TYPE_NORMAL
- en: This means that we must find this information for ourselves. One way to do this
    is to look through the configuration for WordPress as every web application that
    connects to a database has to obtain the login credentials from somewhere, and
    the most common way to do this is to store them within a configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: An interesting challenge to this approach is the fact that this chapter assumes
    that we have little-to-no knowledge of WordPress. Finding where WordPress stores
    its database credentials will be a bit tricky; this is particularly true since
    we also do not know offhand where the WordPress application is installed either.
  prefs: []
  type: TYPE_NORMAL
- en: Finding the installation path for WordPress
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: What we do know is that WordPress is a web application served by the `httpd`
    service. This means that the `httpd` service will have the installation path defined
    somewhere within its configuration files.
  prefs: []
  type: TYPE_NORMAL
- en: The default configuration for `httpd` is to serve a single domain from a default
    folder. The default folder can change from distribution to distribution, but in
    general, for RHEL systems, it is placed under `/var/www/html`.
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to configure `httpd` to serve multiple domains; this is done
    via a **Virtual Hosts** configuration. At this point, we do not know whether this
    system is configured to host multiple domains or one single domain.
  prefs: []
  type: TYPE_NORMAL
- en: Checking the default configuration
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: With the default single-domain configuration, any and all domains pointing to
    the server's IP would serve the same `.html` or `.php` files. With Virtual Hosts,
    you can configure Apache to serve specific `.html` or `.php` files depending on
    the domain that the request is being made to.
  prefs: []
  type: TYPE_NORMAL
- en: We can determine whether the `httpd` service is configured for Virtual Hosts
    or a single domain by executing a simple `grep` command.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Since the `/etc/httpd` folder has a multiple subfolder, we once again used the
    `–r` (recursive) flag for `grep`. The command searched the entire `/etc/httpd`
    folder structure for the **DocumentRoot** string.
  prefs: []
  type: TYPE_NORMAL
- en: DocumentRoot is the Apache configuration item that specifies the local folder
    that contains the `.html` or `.php` files for the specified domain. The `DocumentRoot`
    setting will be present multiple times for systems that are configured for multiple
    domains and only one time for single-domain configurations.
  prefs: []
  type: TYPE_NORMAL
- en: From the output above, we can see that on this server, `DocumentRoot` is only
    defined once and set to `/var/www/html`. As this is the default for RHEL systems,
    it is fairly safe to assume that the `httpd` service is configured in a single
    domain-based configuration.
  prefs: []
  type: TYPE_NORMAL
- en: To validate that this is the installation folder of WordPress, we can simply
    execute the `ls` command to list the files and folders within this path.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: From the `ls` command's output, we can see that WordPress is in fact installed
    in `/var/www/html/`. We can conclude this on the basis of the large number of
    `.php` files along with the "`wp-`" naming scheme of these files. This will be
    confirmed, however, by the next steps.
  prefs: []
  type: TYPE_NORMAL
- en: Finding the database credentials
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we have identified the installation folder, we simply need to find
    the database credentials within the WordPress application's configuration files.
    Unfortunately, we are not very familiar with WordPress and do not know which of
    these files hold the database credentials.
  prefs: []
  type: TYPE_NORMAL
- en: So, how are we going to find them? By googling it, of course.
  prefs: []
  type: TYPE_NORMAL
- en: As we covered in [Chapter 1](part0014_split_000.html#DB7S1-8ae10833f0c4428b9e1482c7fee089b4
    "Chapter 1. Troubleshooting Best Practices"), *Troubleshooting Best Practices*,
    Google can be a system administrator's best friend. Since WordPress is a common
    open source application, it is very likely that there will be online help documentation
    that covers how to configure or at least recover the database password.
  prefs: []
  type: TYPE_NORMAL
- en: To get started, we will simply search *WordPress database configuration* via
    Google. While searching Google, we find that one of the first results is linked
    to the WordPress forum where a user asked where to find the database details in
    WordPress. ([https://wordpress.org/support/topic/finding-the-database-settings-in-wordpress](https://wordpress.org/support/topic/finding-the-database-settings-in-wordpress)).
  prefs: []
  type: TYPE_NORMAL
- en: The first answer was to look through the `wp-config.php` file.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While googling this type of information is easy for popular open source projects,
    it can also be effective for closed source applications as well, as many times
    even closed source applications have their documentation online and indexed by
    Google.
  prefs: []
  type: TYPE_NORMAL
- en: To obtain the database details, we can read the `wp-config.php` file with the
    `less` command. The `less` command is a simple command that allows users to read
    files via the command line. This is particularly useful for large files as it
    buffers the output rather than simply dumping all contents to the screen as in
    the case of the `cat` command.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'By reading the configuration file, we can clearly see the database credentials,
    which are conveniently located towards the top of the file. The following is a
    list of the details that we could extract from this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '`NAME` (`wordpress`) of the database that WordPress is trying to use'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '`HOST` (`localhost`) that WordPress is attempting to connect to'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The `USER` (`wordpress`) database that WordPress is trying to authenticate with
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '`PASSWORD` (`password`) that it is using for authentication'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: With the above details, we can connect to the MariaDB services in the same way
    that the WordPress application does. This will be a critical step in our troubleshooting
    process.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting as the WordPress user
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Now that we have the database credentials, we can test the connectivity again
    with the `mysql` command. To connect to MariaDB with a specific username and password,
    we will need to use the `–u` (user) and `–p` (password) flags with the `mysql`
    command.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding command, we can see that we added the username after the `–u`
    flag but did not include the password after`–p`. Since we did not include the
    password, the `mysql` client simply asked for the password after we hit enter.
    While it is possible to include the password after`–p`, this is considered a bad
    practice from a security perspective. It is always better to let the `mysql` client
    ask for the password to reduce the chances of the password being compromised by
    those looking through the command history.
  prefs: []
  type: TYPE_NORMAL
- en: From the `mysql` client connection, we can see that by using the same credentials
    as WordPress, we were able to log into the MariaDB service. This is important
    as the inability to connect to the database service would impact the WordPress
    application and could have been a possible cause of the reported issue.
  prefs: []
  type: TYPE_NORMAL
- en: Validating the database structure
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Since we can connect to the MariaDB service by using the WordPress credentials,
    we should next validate whether the database structure exists and is intact.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, we will be executing **Structured Query Language** (**SQL**)
    statements from the MariaDB command-line interface. These statements are not shell
    commands but SQL queries.
  prefs: []
  type: TYPE_NORMAL
- en: SQL is the standard language for interacting with relational databases such
    as MySQL, MariaDB, Postgres, and Oracle. While SQL is not necessarily a language
    that every administrator needs to know, it is my advice that any systems administrator
    that supports a significant number of databases should at least know the basics
    of SQL.
  prefs: []
  type: TYPE_NORMAL
- en: This is particularly true if the environment you support does not have specific
    database administrators that manage the database and the database services.
  prefs: []
  type: TYPE_NORMAL
- en: The first item to validate is that the database itself is created and accessible.
    We can do this by using the `show databases` query.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: We can see that the WordPress database is in fact listed in this output, meaning
    that it exists. To validate that the WordPress database is accessible, we will
    use the `use` SQL statement.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: With the `Database changed` result, it seems that we have confirmed that the
    database itself is created and accessible. Now, what about the tables within this
    database? We can validate that the database tables have been created by using
    the `show tables` query.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: From the results, it appears that quite a few tables exist.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we are new to WordPress, it is possible that we may be missing a table
    and not even know it. As WordPress is documented online quite extensively, we
    are likely to find a list of tables by googling *WordPress list of database tables*,
    which returns a very useful database description from the WordPress documentation
    pages: ([https://codex.wordpress.org/Database_Description](https://codex.wordpress.org/Database_Description))'
  prefs: []
  type: TYPE_NORMAL
- en: After comparing the output of the `show tables` query and the Database Description
    page, we find that no tables are missing.
  prefs: []
  type: TYPE_NORMAL
- en: Since we know which tables exist, we should check whether these tables are accessible;
    we can do this by running a `select` query.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: At long last, we have found an error!
  prefs: []
  type: TYPE_NORMAL
- en: The error that we have found, however, is quite interesting as it is not an
    error that you would typically see from an SQL query. In fact, this error seems
    to indicate that there is an issue with a file that contains the table data.
  prefs: []
  type: TYPE_NORMAL
- en: What we learned from the database validation
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'At this point, after validating the database, we have learnt the following:'
  prefs: []
  type: TYPE_NORMAL
- en: MariaDB is accessible by both the root user and the WordPress application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The database being accessed is created and accessible by the WordPress user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An error is shown when querying one of the database tables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With this information, we can move to the next step of the troubleshooting process
    by establishing a hypothesis.
  prefs: []
  type: TYPE_NORMAL
- en: Establishing a hypothesis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this stage of the troubleshooting process, we will take all of the information
    that we have gathered and use it to establish an idea as to why the issue occurred
    and what can be done to resolve it.
  prefs: []
  type: TYPE_NORMAL
- en: To start, let's first review what we have learnt from the Data Gathering steps.
  prefs: []
  type: TYPE_NORMAL
- en: An established blog site is currently showing a page that is designed to only
    be shown during initial installation of the blog software
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The blog is using the open source software WordPress
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: WordPress is written in PHP and utilizes both Apache and MariaDB services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apache and PHP are working correctly and showing no errors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The WordPress installation is located at `/var/www/html`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The MariaDB service is up and accepting connections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The WordPress application is able to connect to the database service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When reading from the database tables, we receive an error that indicates an
    issue with the files that contain the database data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The hypothesis that we can formulate from all of these data points is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: At some point, the data files for MariaDB, and more specifically the WordPress
    database, are inaccessible to the MariaDB service. It appears that when WordPress
    connects to the database, it cannot query the tables; thus, it believes that the
    application has not been installed. Since WordPress does not believe that the
    application has been installed, it presents an installation page.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can formulate this hypothesis on the basis of the following key points of
    information:'
  prefs: []
  type: TYPE_NORMAL
- en: The only error we have seen is the error from MariaDB.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The error is not a typical SQL error, and the message itself indicates an issue
    with accessing the database files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There are no PHP errors in the Apache logs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Everything else about the WordPress environment seems to be correct.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now that we have formed a hypothesis, we need to validate that this is true
    by attempting to resolve the issue. This brings us to the third stage of the troubleshooting
    process: *Trial and Error*.'
  prefs: []
  type: TYPE_NORMAL
- en: Resolving the issue
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this stage, we will attempt to resolve the issue. To do this, let's take
    a look at what these data files are and what they are used for.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding database data files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most databases with the exception of in-memory-only databases have some sort
    of file that is used to store the data on a file system; this is often referred
    to as persistent storage. MariaDB and MySQL are no exception to this rule.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the database storage engine in use, there may be one big file or
    multiple files with different file extensions. Irrespective of the file type or
    where/how the files are stored, at the end of the day, if these files are not
    accessible, the database will have issues.
  prefs: []
  type: TYPE_NORMAL
- en: Finding the MariaDB data folder
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since we are new to this environment, we currently do not know where the MariaDB
    data files are stored. Identifying the location of these files will be the first
    step in correcting the issue. One way to identify the data folder is to look through
    the database services' configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: Since the `/etc` folder is home to most (but not all) configuration files, this
    is the first place we should look.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: To identify the proper configuration file, we can use the `ls` command to list
    the `/etc` folder and the `grep` command to search the results for anything with
    the string "`maria`." The abovementioned `grep` command uses the `–i` (insensitive)
    flag, which causes `grep` to search for both uppercase and lowercase strings.
    This can be helpful if the folder or file has a mixed case name.
  prefs: []
  type: TYPE_NORMAL
- en: Since our command printed no output, there is no folder or file with the string
    "`maria`" in its name. This means that the MariaDB services' configuration either
    is named something that we are not expecting or is not within the `/etc/` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Since MariaDB is supposed to be a drop-in replacement for MySQL, we should also
    check whether there is a `mysql`-named folder or file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: It appears that there is no folder or file matching this name either.
  prefs: []
  type: TYPE_NORMAL
- en: We could easily spend several hours trying to find configuration files for MariaDB
    by using the `ls` command. Fortunately, there is a faster way to find the configuration
    files.
  prefs: []
  type: TYPE_NORMAL
- en: Since MariaDB was installed via an RPM package, we can use the `rpm` command
    to list all files and folders deployed by the package. Earlier when checking how
    MariaDB was installed, the `rpm` command shows multiple packages for MariaDB.
    The package that we are interested in is the `mariadb-server` package. This package
    installs the MariaDB service as well as the default configuration files.
  prefs: []
  type: TYPE_NORMAL
- en: Earlier we used the `–q` and `–l` flags of `rpm` to list all files deployed
    by this package. If we wanted to limit our query to only configuration files,
    we could use the `–q` and `–c` flags.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: From the above, we can see that the `mariadb-server` package deploys three configuration
    files. The `mariadb.log` and `logrotate.d` files are not likely to contain the
    information that we are looking for as they are related to the logging process.
  prefs: []
  type: TYPE_NORMAL
- en: This leaves the `/etc/my.cnf.d/server.cnf` file. We can read this file by using
    the `cat` command.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Unfortunately, this file also does not contain the data folder details as we
    had hoped. This file does, however, give us a clue as to where to look next.
  prefs: []
  type: TYPE_NORMAL
- en: The parent folder of the `server.conf` file is the `/etc/my.cnf.d` folder. The
    `.d` at the end of the folder name is important, as this naming convention has
    a special purpose in Linux. The `.d` (dot D) folder types are designed to allow
    users to simply add a file or many files with custom configurations for the service.
    When the service is started, all files within this folder are read and the configurations
    are applied.
  prefs: []
  type: TYPE_NORMAL
- en: This allows users to configure a service without editing the default configuration
    files; they can simply drop in the configurations that they want to add by creating
    a new file in the `.d` folder.
  prefs: []
  type: TYPE_NORMAL
- en: It's important to note that this is a configuration scheme and not every service
    supports this scheme. It seems, however, that the MariaDB service does in fact
    support this scheme.
  prefs: []
  type: TYPE_NORMAL
- en: What is interesting, however, is the name of this `.d` folder. Typically, the
    naming convention for a `.d` configuration folder is the service name or folder
    purpose followed by `.d`. You can see this in practice with the `/etc/cron.d`
    or `/etc/http/conf.d` folder. The name of the MariaDB `.d` folder suggests that
    the main configuration file may be named `my.cnf`.
  prefs: []
  type: TYPE_NORMAL
- en: If we check whether such a file exists or not, we will see that it does.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: This file appears to be the main MariaDB configuration file, which will hopefully
    contain the data folder configuration. To find out, we can read this file with
    the `cat` command.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: As anticipated, this file does actually contain the data folder configuration.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Armed with this information, we can now troubleshoot the current state of the
    WordPress database's data files.
  prefs: []
  type: TYPE_NORMAL
- en: Resolving data file issues
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If we change to the `/var/lib/mysql` folder and use the `ls` command to list
    the folder contents, we can see quite a few database data files/folders.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: It appears that each database created on this server exists as a folder under
    `/var/lib/mysql/`. It also appears from the `ls` output that the folders are in
    a normal state. Since the issue is with the WordPress database, we will focus
    on this database by switching to the `wordpress` folder.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Right after executing the `ls` command, we can see that there is something unusual
    with the files within this folder.
  prefs: []
  type: TYPE_NORMAL
- en: The item that stands out is simply the fact that all the `.frm` files have a
    file mode of `000`. This means that neither the owner nor the group or other Linux
    users can read or write these files. This includes the user that MariaDB runs
    as.
  prefs: []
  type: TYPE_NORMAL
- en: If we look back at the error that we received from MariaDB, we find that the
    error seems to support the supposition that the invalid permissions are in fact
    causing an issue. To correct this error, we simply need to reset the permissions
    to the correct values.
  prefs: []
  type: TYPE_NORMAL
- en: Since we are new to MariaDB, we currently do not know exactly what these values
    should be.
  prefs: []
  type: TYPE_NORMAL
- en: 'Luckily, there is an easy way to figure out what the permissions should be:
    simply look at another database''s file permissions.'
  prefs: []
  type: TYPE_NORMAL
- en: If we look back at the output of the folder listing for `/var/lib/mysql`, we
    find that there were several folders. At least one of these other folders should
    also be a database's data folder. To determine what permissions our `.frm` files
    should have, we simply need to find other `.frm` files.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The `find` command is a very useful command for troubleshooting and can be used
    in many different situations. In our example, we use the `find` command to search
    for any file in the `/var/lib/mysql` folder that has a filename that ends with
    "`.frm`" via the `–name` flag. The `–ls` (folder listing) flag tells the `find`
    command to print any files that it finds in a long list format, which will show
    each file's permissions without having to run a second command.
  prefs: []
  type: TYPE_NORMAL
- en: From the `find` command's output, we can see that the permissions on the `.frm`
    files are set to `-rw-rw----`; the numeric representation of this is `660`. These
    permissions seem appropriate for our database table and allow the owner and group
    to read and write these files.
  prefs: []
  type: TYPE_NORMAL
- en: To reset the permissions on our WordPress data files, we will use the `chmod`
    command.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding command, the `–v` (verbose) flag was used with `chmod` so that
    we could see the changes in each file's permissions as the command executed.
  prefs: []
  type: TYPE_NORMAL
- en: Validating
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that the permissions have been set, we can yet again validate with an SQL
    `select` query.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: From the above query, we can see there is still an error with MariaDB accessing
    these files. This means that we must not have corrected all of the issues with
    the data files.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: By reviewing the `ls` command's output, we can see one more difference from
    the example `.frm` files.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The owner and group permissions for the files in the `wordpress` folder are
    set to `root`, whereas the other `.frm` files are owned and grouped as the `mysql`
    user.
  prefs: []
  type: TYPE_NORMAL
- en: The permissions of `660` mean that only the owner and group members of the file
    can access it. In the case of our WordPress files, this means that only the root
    user and any member of the root group can access these files.
  prefs: []
  type: TYPE_NORMAL
- en: Since MariaDB runs as the `mysql` user, the MariaDB service still cannot access
    these files. We can reset the ownership and group membership with the `chown`
    command.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Now that the ownership and the group membership of the files are `mysql`, we
    can rerun our query to see whether the issue is resolved.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: At long last, we have resolved the error by querying the WordPress database
    tables.
  prefs: []
  type: TYPE_NORMAL
- en: Final validation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since we have resolved the database error, and we did not find any other errors
    while troubleshooting, the next validation step is to see whether the blog is
    still showing the installation screen.
  prefs: []
  type: TYPE_NORMAL
- en: '![Final validation](img/00003.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: By navigating to `http://blog.example.com` from our browser, we can now see
    that we no longer receive the installation page, but rather the blog's front page.
    At this point, it seems that the issue has been resolved.
  prefs: []
  type: TYPE_NORMAL
- en: In general, when working on an issue reported by a person, it is a best practice
    to have the person who initially reported the problem to validate that everything
    has been restored to an expected state. I have seen many instances where an incident
    is caused by more than one issue, and while the more apparent issue is resolved
    quickly, the other issue(s) is(are) often overlooked. Having the user verify that
    we have fixed the entire problem will help to ensure that everything has been
    truly resolved.
  prefs: []
  type: TYPE_NORMAL
- en: For this scenario, when we asked the business user who reported the issue to
    check whether the issue has been resolved, he/she replied with *Everything looks
    fixed. Thank you!*
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we walked through the troubleshooting process by using an issue
    that can easily occur in the real world. We iterated through Steps 1, 2, and 3
    of the troubleshooting process to collect data, establish a hypothesis, and resolve
    the issue; these steps were covered in detail in [Chapter 1](part0014_split_000.html#DB7S1-8ae10833f0c4428b9e1482c7fee089b4
    "Chapter 1. Troubleshooting Best Practices"), *Troubleshooting Best Practices*.
    We then used several commands and log files that we learned about in [Chapter
    2](part0019_split_000.html#I3QM2-8ae10833f0c4428b9e1482c7fee089b4 "Chapter 2. Troubleshooting
    Commands and Sources of Useful Information"), *Troubleshooting Commands and Sources
    of Useful Information* as well as a few new ones.
  prefs: []
  type: TYPE_NORMAL
- en: While learning the commands used in this chapter is important for any systems
    administrator working with web applications, it is more important to look at the
    process that we followed. We started working on the problem with no prior knowledge
    of the environment or application, but with some basic data collection and trial
    and error, we could resolve the problem.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will use this same troubleshooting process and similar
    tools for troubleshooting performance issues.
  prefs: []
  type: TYPE_NORMAL
