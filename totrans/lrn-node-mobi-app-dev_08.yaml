- en: Chapter 8. Making Our App Interactive
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we gave you a gist of how to work with user interfaces
    in Ionic. While doing so, we also gave you a thorough introduction to AngularJS,
    the driving force behind Ionic apps, and explained how you can use it in order
    to let users interact with your app.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we will continue building on this while simultaneously exploring new features
    of Ionic, including the interaction with the native features of your device. We
    will put this all into practice by building a concrete app that will load and
    display the contacts from your phonebook. By doing so, you will also learn how
    to compile and run the Ionic apps on physical devices (such as iPhones and Android
    phones), rather than the emulator that we have used so far.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ionic comes with a powerful **Command Line Interface** (**CLI**), which quickly
    lets you create, modify, and extend Ionic projects. By automating chores such
    as module integration and scaffolding, it can drastically improve your productivity.
  prefs: []
  type: TYPE_NORMAL
- en: '''Let''s use the CLI to create a basic project for us to work with in this
    chapter. Go to your working directory and run the following in a terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This will create a blank app containing only the basic components for a bare-bones
    working app. This is suitable for us, since we want to build an app from the ground
    up and learn as we go.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `ionic start` command has several other basic templates as well. For example,
    the `tabs` template gives you a basic app with tabbed navigation that you can
    extend, while side menu creates a basic app with a side menu for navigation.
  prefs: []
  type: TYPE_NORMAL
- en: When this command finishes running, you will have a complete project to work
    with. No extra fiddling is required! Now, let's go ahead and add some content
    in it.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a basic MVC project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our goal in this chapter is to create an app that can pull information from
    the contacts storage of the local device and display it to the user (a phonebook,
    if you like). To do so, we need to do the following things:'
  prefs: []
  type: TYPE_NORMAL
- en: Define a **view** (template file) to display the contact list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define a **controller** in order to handle interactions with the list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide the necessary **model** logic in order to provide contacts' information.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You may recall that this workflow fits nicely with the overall architecture
    of AngularJS, which follows the MVC pattern. We will take care of each item in
    turn.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the view
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Go ahead and add the following folder to your projects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we will store all the view templates that we will use throughout our
    project. In this folder, let''s create our first view file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: If we need to add additional views to our app, we will do it in the same manner.
    Partitioning our views like this not only makes organization easier, but also
    boosts performance, since HTML will only be loaded on demand when it is needed,
    rather than all at once.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add some content in order to create an actual view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Don''t concern yourself with the list-related tags yet; we will get to what
    they do in a moment. For now, let''s look at the two outer ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ion-view`: This tag tells Ionic that this is a view that can be dynamically
    loaded from other parts of the application. We add the view-title attribute to
    it in order to create a label that can be used to refer to the view.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ion-content`: This tag designates a content area in the view, which is especially
    good at displaying scrolling data. Since we want to display a list of contacts
    of an unknown length, this is what we will want to wrap our list in.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the list view
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Lists are some of the most ubiquitous data structures in apps everywhere. So,
    it is no surprise that most frameworks provide powerful tools to work with them.
    Ionic is certainly no exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'Have a look at the code that we added earlier. Especially note the tags inside
    the `ion-content` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The following two tags encapsulate the majority of Ionic''s list rendering
    capabilities and are generally everything that you need in order to display the
    list:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ion-list`: This indicates that the wrapped content is a list'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ion-item`: This indicates a single data node, which can be rendered in a list'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since each item in our list will be a single contact, we will wrap each of them
    in an `ion-item` tag.
  prefs: []
  type: TYPE_NORMAL
- en: 'At present, our view does not really do much apart from displaying an empty
    list. We need to add some markup in order to show the details of the contact wrapped
    in each item. Let''s do something basic first, such as just showing the name and
    mobile number of the contact, if any:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Here, we defined two Angular expressions to render the name and number of a
    contact during runtime. The contact in this case is simply a **JavaScript Object
    Notation** (**JSON**) object holding information about a given person in our contact
    list. Next, we will see how to assign a concrete value to this JSON object; this
    will take place in the associated controller.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As of AngularJS 1.3, which is the version that is officially shipped with Ionic
    at the time of writing this book, it is possible to make expressions behave in
    a bind-once fashion. This means that they take on the values that they initially
    compute to, and the values are skipped by the AngularJS DOM update cycle after
    this, which improves performance. In our case, this works well, since we will
    only display our data once after fetching it, as we will see later. The downside
    of this method at this point in time is that updates to the data model will not
    be reflected in this view.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make your expressions bind-once, add two colons (`::`) before them, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Creating the controller
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You may recall that the controller is the *glue* between your view and model
    (that is, your business logic). Its primary responsibility is to handle interactions
    with your UI from the user and delegate the processing of an appropriate response
    to the model.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapter, the example controllers were located in a separate
    JavaScript file, where they were declared as part of a module. This is a good
    design practice, since it makes it much easier to structure your app.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that our blank project does not have such a file. So, let''s start by
    creating it. Add the following file to your project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In this file, let''s add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s recap in brief to see what the preceding code does:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We defined a module using the core `angular.module()` function, which takes
    the following parameters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first parameter is `phonebook.controllers`, which is the name of the module.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second parameter is an empty list, which indicates that this module has
    no external dependencies. If it did, we would list their names here so that the
    AngularJS dependency injection system can resolve them during runtime.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Having created a module, we attach a controller to it using the (aptly named)
    core function `controller()`. The following arguments are passed to this function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`ContactsCtrl`, which is the name of the controller, is the first argument.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second argument is a `function` that defines what the controller does. In
    this controller, we will define any and all the actions that are taking place
    in the segment of the app controlled by this controller. Note that this function
    takes the `$scope` parameter (we will get to what it does a bit later). Just like
    the dependency list in the module, this parameter and all the others passed to
    the function (there can be any number of parameters or none at all) denote a dependency
    of this controller, which will be resolved at runtime using the dependency injection
    system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For now, this is all we need in order to have a full-fledged controller. Next,
    we will need to connect it with our view.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting the view and controller
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have the following two choices if we need to bring our newly created view
    and controller together:'
  prefs: []
  type: TYPE_NORMAL
- en: We can use an inline view, where we put a reference to the view and controller
    directly in the `index.html` file or another template, which is in turn loaded
    from `index.html`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can use a router to associate the view and its controller with a certain
    path within the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Even though we only have one view for now, we will go for the second option.
    This might seem redundant, but it makes it much easier to structure the app in
    the event that we want to add new navigation states later on (spoiler—we will!)
  prefs: []
  type: TYPE_NORMAL
- en: 'Routing is normally configured in the `app.js` file. So, that is where we will
    go next. Open the file and make sure that it has the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Let's consider what is going on here, particularly in the `config` function.
    Here, we set up the core navigation settings for our app by configuring the routing
    module exposed by `$stateProvider` and `$urlRouterProvider`. By default, Ionic
    uses the `ui-router` (for more information, visit [https://github.com/angular-ui/ui-router](https://github.com/angular-ui/ui-router)).
    This router is state-oriented. That is, it lets you structure your app as a state
    machine, where each state can be connected to a path and a set of views and controllers.
    This setup makes it very easy to work with nested views, which is a frequent case
    when developing for mobile devices, where navigation elements like tabs, side
    menus, and the like are very common.
  prefs: []
  type: TYPE_NORMAL
- en: 'Knowing this, let''s consider what this code actually does:'
  prefs: []
  type: TYPE_NORMAL
- en: The `config` function itself takes two arguments, `$stateProvider` and `$urlRouterProvider`.
    Both are configuration interfaces belonging to `ui-router` and can be used to
    configure the router when the app bootstraps.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We use the `$stateProvider` argument in order to add the state contacts to
    our app. When the application is in this state, we make the following properties
    hold:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The current path within the app is root (`/`),that is, we are in this state
    whenever we are at the initial path of the app.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The template to be loaded for this state is `templates/contacts.html`, which
    is the same view template that we created earlier.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The controller associated with this view is `ContactsCtrl`, which was defined
    earlier as well. Since our `phonebook.controllers` module is loaded as a dependency
    for our app (see the first line of `app.js`), we only need to name the controller,
    and the dependency injection system will do the rest.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we configure a default route for our app. This is the route our navigation
    will resolve to if no other valid route is provided. In our case, we always default
    to the start screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'That''s all we need to get the routing going! Next, we need to make sure that
    the `index.html` file has the necessary content to load all the files that we
    configured so far, including the new contacts view. Open it, and make sure that
    it has the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Pay attention to the highlighted parts:'
  prefs: []
  type: TYPE_NORMAL
- en: The `script` tag simply imports the `phonebook.controllers` module.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ion-nav-bar` tag creates a standard navigation bar, which displays content
    specific to the current navigation context that the app is in.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you own an Android device, this will be similar to the action bar at the
    top, where you have your app logo, the name of the current view, and so on
  prefs: []
  type: TYPE_NORMAL
- en: Likewise, if you own an iPhone, this bar will be the bottom bar, which commonly
    holds the app's navigation tabs
  prefs: []
  type: TYPE_NORMAL
- en: The `ion-nav-back-button` tag creates a button to go backwards from the current
    navigation context to the previous one, much like a back button in a browser.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, `ion-nav-view` is a special tag, which tells AngularJS where the routing
    system should bind the templates. In our case, this is where the `templates/contacts.html`
    template will be rendered when our navigation context is the contacts state, as
    we defined in our router `config` earlier.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing the connection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is all we need for a basic setup of our app. To make sure it runs, let''s
    try it out in the emulator. From the root of your project folder, run the following
    in a terminal or command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following output of the preceding command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing the connection](img/B04653_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Depending on the browser you run your emulator in, you may not see the top or
    bottom bar. This is not generated by Ionic, but rather by a Chrome plugin, which
    automatically sets the size of the window to match that of an iPhone 6\. The plugin
    is called **Mobile/Responsive Web Design Tester**, and we recommend that you try
    it for your own projects.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We now have a working view and controller. Next, we need a model that can provide
    the data we need in response to user input.
  prefs: []
  type: TYPE_NORMAL
- en: Services
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In AngularJS, it is considered good design practice to keep as little logic
    in the controllers as possible. Remember that controllers should only be the *glue*
    between the view and the model. They should ideally not be responsible for doing
    any of the heavy fetching and crunching of data. For that, AngularJS provides
    the services.
  prefs: []
  type: TYPE_NORMAL
- en: Services are objects that are injected into other components of your app on
    demand by the dependency injection system. If you look back at the `app.js` code,
    you have seen some of them already; both the `$stateProvider` and `$urlRouterProvider`
    arguments fall in this category.
  prefs: []
  type: TYPE_NORMAL
- en: If you look at advanced AngularJS apps, you will start seeing services pretty
    much everywhere. They make up a large part of almost any app and can be used to
    contain almost any kind of functionality. For example, we can create a service
    that encapsulates access to a given REST API, allowing us to query it by a set
    of utility functions while the service itself handles connections to the server,
    security, and so on. Likewise, we can define a service that represents a set of
    mathematical operations, which can be fed simple data in order to get arithmetic
    results.
  prefs: []
  type: TYPE_NORMAL
- en: '**Services** are **singletons**, which means that only a single instance of
    each exists during runtime.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Implementing your business logic in this fashion is important for several reasons,
    some of which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: It provides modular interfaces to work with a certain aspect of your app's business
    logic. Your model can be built around several services, each providing a single,
    essential feature of your app's functionality.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is efficient, since you only have a single instance of each service available
    throughout your entire app.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It makes it easier to extend your app, as units of functionality can be defined
    and injected wherever they are needed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have established how awesome services are, the natural question
    is, how are we going to go about their creation?
  prefs: []
  type: TYPE_NORMAL
- en: Creating services
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'AngularJS provides several ways to create services. These ways are referred
    to as recipes. There are five of them in total—constants, values, providers, factories,
    and services. Each varies in complexity and the use cases that are suitable for
    them:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Constants**: The most simple service, this is used to define a single constant,
    which is available throughout the entire application. It varies from the other
    four in the sense that it is immediately instantiated when an app starts up, which
    means that it can be used during the configuration phase of the app''s lifecycle.
    Constants are often used to contain constant values such as base URLs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Values**: This is similar to constants, with the notable exception that it
    is not available during the configuration phase of the app. It may also be used
    in `decorators`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Factories**: Whereas constants and values are used to store simple values,
    factories begin making things much more interesting:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They provide factory functions, which can be used to define logic rather than
    just values. This means that a factory can provide multiple functions, which compute
    values based on input.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Factories can have dependencies, which means that you can construct them using
    other services.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Factories are lazily instantiated, which means that they are only instantiated
    when they are needed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For our app here this is the recipe that we will be using, and as such you will
    see its example soon. In fact, we contend that factories will fit most of the
    available use cases for most apps.
  prefs: []
  type: TYPE_NORMAL
- en: '**Services**: Services are very, very similar to factories. While there are
    some minor differences in semantics, their real contribution is to provide a concise
    syntax. Using a factory or service is almost always a matter of preference. Oh,
    and in case you are wondering about the name, the AngularJS developers themselves
    regret calling it *services*, likening it to naming your child *child*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Providers**: Finally, the most advanced recipe is the **provider**, which
    offers the full range of functionality offered by services (no, not the ones that
    we just mentioned; we are talking about the actual services—the naming was a pretty
    bad idea, wasn''t it?) In particular, Providers allow you to expose the service
    to configuration during the `config` phase of the app before the service is actually
    used during the `run` phase. It is worth while (and perhaps surprising) to note
    that the provider is actually the only recipe for services; the previous four
    are just syntactic sugar simplifying its use. Because it is so complex, it is
    an overkill for most cases, which is why there are other options to choose from
    depending on how complex your model logic is.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So much knowledge, so little space! Let's put what we have learned to good use
    by actually creating a factory to retrieve contacts.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a factory
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Like controllers, it is customary to place your service definitions in their
    own file (or files, if you prefer to have each service recipe in its own file.
    Here, we use a common file for all of them). In your project directory, create
    the following file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In this file, put the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s have a look at what we have done:'
  prefs: []
  type: TYPE_NORMAL
- en: We created a module named `phonebook.services` to host our services
  prefs: []
  type: TYPE_NORMAL
- en: We defined a basic `factory` service named `contactsFactory`
  prefs: []
  type: TYPE_NORMAL
- en: The service which exposes a single utility method is called `all`, which currently
    does not do anything (we will change this soon, don't worry).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to modify the `app.js` and `index.html` files in order to make
    the app aware of the new service. Make sure that the `app.js` file starts with
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This injects the services module into the main app. Now, we just need to import
    the file the module is located in. To do so, make sure that your JavaScript imports
    in `index.html` look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: That's it! We now have the groundwork of our app in place. However, if you run
    the emulator again, you will notice that not much has changed. We are still greeted
    by the same blank screen. Now, it is time to add some actual content to our app
    by loading the contact list.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing the device data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that the basics of our app are have been implemented, it is time to add
    some serious data to it. In our case, we want to load the contacts stored on the
    device that our app is running on so that we can show them in the list that we
    created earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing native services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You may recall that Ionic is built on top of the Cordova platform, which provides
    the core interaction with the underlying operating system and hardware. In order
    to access native services, such as the contact list, we will frequently have to
    make use of Cordova directly.
  prefs: []
  type: TYPE_NORMAL
- en: In this particular case, we are in a very easy spot; Cordova not only has a
    full-fledged plugin to interact with the contacts, but also sports a very convenient
    CLI method to install it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to your project directory and run the following from a terminal or command
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This will install the Cordova Contacts plugin, which will be placed in the
    following folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Feel free to inspect the files before we move on. Next, we need to integrate
    this plugin with Ionic so that we can use it in our app.
  prefs: []
  type: TYPE_NORMAL
- en: ngCordova
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Cordova itself knows nothing about either Ionic or AngularJS. So, accessing
    its services in an Angular fashion will often require wrapper code. Fortunately,
    there is already an extensive library for this exact end—**ngCordova**.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install it, go to the root of your project folder and run the following
    from a terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This will install everything we need. Next, let''s again import it into our
    app by modifying the `app.js` and `index.html` files. In `app.js`, make sure that
    your app dependencies now include `ngCordova`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Likewise, in `index.html`, make sure that we import the corresponding JS library,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Adding Cordova contacts to our factory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The last step here is to integrate the Cordova contacts with the `contactsFactory`
    service in order to let it serve the contacts available on the device. Open the
    `js/services.js` file and make sure that it contains the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The important parts are highlighted. Let''s figure out what is going on:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We inject the following dependencies for our factory:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$q`: This is the AngularJS service that is used to work with `promises`. This
    will allow us to create `deferred` functions, which resolve to a value at a later
    stage. At that point, something can be done with their results.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$cordovaContacts`: This is the Cordova contacts plugin itself that is wrapped
    by ngCordova.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since raw contact data is rather clunky, we define a utility method in order
    to process it into something more lightweight.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We create a `promise`, which is returned to whoever uses our service. The `promise`
    in this case is that at some point, we will deliver either a list of contacts,
    or an error indicating why we could not do so.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We invoke the `find()` function of `cordovaContacts`, which is very similar
    to the MongoDB function with the same name; it simply returns all the available
    contacts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we can get the list of contacts, we resolve the `promise` and hand over the
    list to the caller.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we cannot get the list of contacts, we reject the promise, indicating that
    we were not able to get what was requested. An error message created by `cordovaContacts`
    is returned to the user.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our service is now all configured and good to go. There is still one major hurdle
    though. Emulators have no contacts for us to display! In order to move on, we
    will first have to take a detour and see how to deploy the app on physical devices
    before we finally wrap up our app by showing the contacts to the user.
  prefs: []
  type: TYPE_NORMAL
- en: Building for native devices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, everything we have done in Ionic has been tested in emulators or remote
    services. Now that we have an app that uses real phone features, it is time we
    finally went all the way and built the ultimate end-product—a mobile app.
  prefs: []
  type: TYPE_NORMAL
- en: Building and deploying Ionic apps on physical devices is remarkably easy thanks
    to the Ionic CLI. We will demonstrate how to do so in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Android
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'From the root of your project folder, run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This will add all the files that are necessary to deploy your app on an Android
    device.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we have two options for the running of our app—an actual Android emulator
    or a physical device.
  prefs: []
  type: TYPE_NORMAL
- en: Emulator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To run the app in the emulator, first build the project by running the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, start the emulator and deploy the app by running the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: A physical device
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Running an app on a physical device is just as simple as running the app on
    the emulator. First, connect an Android device that can accept APK installations
    over USB (see [Chapter 1](ch01.html "Chapter 1. Setting Up Your Workspace"), *Setting
    Up Your Workspace*, for instructions on setting this up). Once this is done, run
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, run the following to install and run the APK on your connected device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Once the app is deployed, it will start automatically on your device.
  prefs: []
  type: TYPE_NORMAL
- en: The list view revisited
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will now add the finishing touches to our app, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Use logic to display the contacts that we pulled from the contact list
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the pull-to-refresh feature in order to enable users to dynamically refresh
    the list of users.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, let''s modify the `contacts.html` file in order to handle the rendering
    of the list itself. Open the file and make sure that it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Most things look the same, but we have highlighted some important changes:'
  prefs: []
  type: TYPE_NORMAL
- en: We added an `ion-refresher` tag, which creates a pull-to-refresh interface for
    our view. When the user swipes a finger downward over the screen, the text **Pull
    to refresh** will be shown. If the full gesture is then carried out (that is,
    swipe and drop), the `doRefresh()` function, which was defined in the scope of
    this view, will be called. We will define this function in just a bit.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We added a `collection-repeat` attribute to the `ion-item` tag. This is a variation
    of the `ng-repeat` AngularJS attribute, which means that one `ion-item` will be
    created for each contact number in the contacts collection. The contacts collection
    needs to be defined in the scope of the view, which will be done next.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Modify the `controllers.js` file to make it look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s consider what happened here:'
  prefs: []
  type: TYPE_NORMAL
- en: We created and bound the empty contacts list to the `scope` tag injected into
    this controller. This corresponds to the same contacts list that the `collection-repeat`
    directive in our view uses.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Likewise, we bound the `doRefresh` function, which we already saw in the view,
    to our scope. We made it do the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Call the `all()` method of the `contactsFactory` class. This gives us a promise
    that a list of contacts will be delivered at some point in the future.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the promise is fulfilled, we bind the resulting list to the scope. Angular
    will respond to this change by refreshing the view in order to accommodate this
    change in the model and populating the list with contact information using collection-repeat.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the promise fails, we display an error message.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Angular promises allow us to listen to progress notifications from promises.
    We do not use this feature here, but we simply catch such messages.
  prefs: []
  type: TYPE_NORMAL
- en: That's it! You should now be able to run your app and browse your contacts.
    Go through the build steps for native devices again and try it out!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we covered a lot of ground, going into great depth as regards
    AngularJS and learning more about the interaction of a model, view, and controller.
    We also saw how to use Cordova plugins and ngCordova in order to access native
    features (something that we will be doing a lot of in the future chapters). Finally,
    we saw how to create services and use them in order to serve data to our users.
  prefs: []
  type: TYPE_NORMAL
- en: We also recommend the usage of your favorite browser's inspect element tools,
    which can give you an insight into any display errors that you might run into
    when running the application.
  prefs: []
  type: TYPE_NORMAL
