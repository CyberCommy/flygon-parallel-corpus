- en: 09
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Working with Files, Streams, and Serialization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is about reading and writing to files and streams, text encoding,
    and serialization.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Managing the filesystem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading and writing with streams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encoding and decoding text
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serializing object graphs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling JSON processing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing the filesystem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Your applications will often need to perform input and output operations with
    files and directories in different environments. The `System` and `System.IO`
    namespaces contain classes forÂ this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: Handling cross-platform environments and filesystems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s explore how to handle cross-platform environments like the differences
    between Windows and Linux or macOS. Paths are different for Windows, macOS, and
    Linux, so we will start by exploring how .NET handles this:'
  prefs: []
  type: TYPE_NORMAL
- en: Use your preferred code editor to create a new solution/workspace named `Chapter09`
    .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a console app project, as defined in the following list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Project template: **Console Application** /`console`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Workspace/solution file and folder: `Chapter09`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Project file and folder: `WorkingWithFileSystems`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Program.cs` , add statements to statically import the `System.Console`
    , `System.IO.Directory` , `System.Environment` , and `System.IO.Path` types, as
    shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: static
  prefs: []
  type: TYPE_NORMAL
- en: System.Console;
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: static
  prefs: []
  type: TYPE_NORMAL
- en: System.IO.Directory;
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: static
  prefs: []
  type: TYPE_NORMAL
- en: System.IO.Path;
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: static
  prefs: []
  type: TYPE_NORMAL
- en: System.Environment;
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs` , create a static `OutputFileSystemInfo` method, and write
    statements in it to do the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Output the path and directory separation characters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Output the path of the current directory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Output some special paths for system files, temporary files, and documents.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: static
  prefs: []
  type: TYPE_NORMAL
- en: void
  prefs: []
  type: TYPE_NORMAL
- en: OutputFileSystemInfo
  prefs: []
  type: TYPE_NORMAL
- en: ()
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("{0,-33} {1}"
  prefs: []
  type: TYPE_NORMAL
- en: ', arg0: "Path.PathSeparator"'
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: 'arg1: PathSeparator);'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("{0,-33} {1}"
  prefs: []
  type: TYPE_NORMAL
- en: ', arg0: "Path.DirectorySeparatorChar"'
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: 'arg1: DirectorySeparatorChar);'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("{0,-33} {1}"
  prefs: []
  type: TYPE_NORMAL
- en: ', arg0: "Directory.GetCurrentDirectory()"'
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: 'arg1: GetCurrentDirectory());'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("{0,-33} {1}"
  prefs: []
  type: TYPE_NORMAL
- en: ', arg0: "Environment.CurrentDirectory"'
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: 'arg1: CurrentDirectory);'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("{0,-33} {1}"
  prefs: []
  type: TYPE_NORMAL
- en: ', arg0: "Environment.SystemDirectory"'
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: 'arg1: SystemDirectory);'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("{0,-33} {1}"
  prefs: []
  type: TYPE_NORMAL
- en: ', arg0: "Path.GetTempPath()"'
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: 'arg1: GetTempPath());'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("GetFolderPath(SpecialFolder"
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("{0,-33} {1}"
  prefs: []
  type: TYPE_NORMAL
- en: ', arg0: " .System)"'
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: 'arg1: GetFolderPath(SpecialFolder.System));'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("{0,-33} {1}"
  prefs: []
  type: TYPE_NORMAL
- en: ', arg0: " .ApplicationData)"'
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: 'arg1: GetFolderPath(SpecialFolder.ApplicationData));'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("{0,-33} {1}"
  prefs: []
  type: TYPE_NORMAL
- en: ', arg0: " .MyDocuments)"'
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: 'arg1: GetFolderPath(SpecialFolder.MyDocuments));'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("{0,-33} {1}"
  prefs: []
  type: TYPE_NORMAL
- en: ', arg0: " .Personal)"'
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: 'arg1: GetFolderPath(SpecialFolder.Personal));'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: The `Environment` type has many other useful members that we did not use in
    this code, including the `GetEnvironmentVariables` method and the `OSVersion`
    and `ProcessorCount` properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs` , above the function, call the `OutputFileSystemInfo` method,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: OutputFileSystemInfo();
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Run the code and view the result, as shown in *Figure 9.1* :![Text Description
    automatically generated](img/Image00086.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 9.1: Running your application to show filesystem information on Windows'
  prefs: []
  type: TYPE_NORMAL
- en: When running the console app using `dotnet run` with Visual Studio Code, the
    `CurrentDirectory` will be the project folder, not a folder inside `bin` .
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice** : Windows uses a backslash `\` for the directory separator
    character. macOS and Linux use a forward slash `/` for the directory separator
    character. Do not assume what character is used in your code when combining paths.'
  prefs: []
  type: TYPE_NORMAL
- en: Managing drives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To manage drives, use the `DriveInfo` type, which has a static method that returns
    information about all the drives connected to your computer. Each drive has a
    drive type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s explore drives:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `WorkWithDrives` method, and write statements to get all the drives
    and output their name, type, size, available free space, and format, but only
    if the drive is ready, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: static
  prefs: []
  type: TYPE_NORMAL
- en: void
  prefs: []
  type: TYPE_NORMAL
- en: WorkWithDrives
  prefs: []
  type: TYPE_NORMAL
- en: ()
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("{0,-30} | {1,-10} | {2,-7} | {3,18} | {4,18}"
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: '"NAME"'
  prefs: []
  type: TYPE_NORMAL
- en: ', "TYPE"'
  prefs: []
  type: TYPE_NORMAL
- en: ', "FORMAT"'
  prefs: []
  type: TYPE_NORMAL
- en: ', "SIZE (BYTES)"'
  prefs: []
  type: TYPE_NORMAL
- en: ', "FREE SPACE"'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: foreach
  prefs: []
  type: TYPE_NORMAL
- en: (DriveInfo drive in
  prefs: []
  type: TYPE_NORMAL
- en: DriveInfo.GetDrives())
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: if
  prefs: []
  type: TYPE_NORMAL
- en: (drive.IsReady)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine(
  prefs: []
  type: TYPE_NORMAL
- en: '"{0,-30} | {1,-10} | {2,-7} | {3,18:N0} | {4,18:N0}"'
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: drive.Name, drive.DriveType, drive.DriveFormat,
  prefs: []
  type: TYPE_NORMAL
- en: drive.TotalSize, drive.AvailableFreeSpace);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: else
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("{0,-30} | {1,-10}"
  prefs: []
  type: TYPE_NORMAL
- en: ', drive.Name, drive.DriveType);'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice** : Check that a drive is ready before reading properties such
    as `TotalSize` or you will see an exception thrown with removable drives.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs` , comment out the previous method call and add a call to `WorkWithDrives`
    , as shown highlighted in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: '**// OutputFileSystemInfo();**'
  prefs: []
  type: TYPE_NORMAL
- en: '**WorkWithDrives();**'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Run the code and view the result, as shown in *Figure 9.2* :![](img/Image00087.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 9.2: Showing drive information on Windows'
  prefs: []
  type: TYPE_NORMAL
- en: Managing directories
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To manage directories, use the `Directory` , `Path` , and `Environment` static
    classes. These types include many members for working with the filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: 'When constructing custom paths, you must be careful to write your code so that
    it makes no assumptions about the platform, for example, what to use for the directory
    separator character:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `WorkWithDirectories` method, and write statements to do the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define a custom path under the user's home directory by creating an array of
    strings for the directory names, and then properly combining them with the `Path`
    type's `Combine` method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check for the existence of the custom directory path using the `Exists` method
    of the `Directory` class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Create and then delete the directory, including files and subdirectories within
    it, using the `CreateDirectory` and `Delete` methods of the `Directory` class:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: static
  prefs: []
  type: TYPE_NORMAL
- en: void
  prefs: []
  type: TYPE_NORMAL
- en: WorkWithDirectories
  prefs: []
  type: TYPE_NORMAL
- en: ()
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: // define a directory path for a new folder
  prefs: []
  type: TYPE_NORMAL
- en: // starting in the user's folder
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: newFolder = Combine(
  prefs: []
  type: TYPE_NORMAL
- en: GetFolderPath(SpecialFolder.Personal),
  prefs: []
  type: TYPE_NORMAL
- en: '"Code"'
  prefs: []
  type: TYPE_NORMAL
- en: ', "Chapter09"'
  prefs: []
  type: TYPE_NORMAL
- en: ', "NewFolder"'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: 'WriteLine($"Working with:'
  prefs: []
  type: TYPE_NORMAL
- en: '{newFolder}'
  prefs: []
  type: TYPE_NORMAL
- en: '"'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: // check if it exists
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine($"Does it exist?
  prefs: []
  type: TYPE_NORMAL
- en: '{Exists(newFolder)}'
  prefs: []
  type: TYPE_NORMAL
- en: '"'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: // create directory
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("Creating it..."
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: CreateDirectory(newFolder);
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine($"Does it exist?
  prefs: []
  type: TYPE_NORMAL
- en: '{Exists(newFolder)}'
  prefs: []
  type: TYPE_NORMAL
- en: '"'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: 'Write("Confirm the directory exists, and then press ENTER: "'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: ReadLine();
  prefs: []
  type: TYPE_NORMAL
- en: // delete directory
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("Deleting it..."
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: 'Delete(newFolder, recursive: true'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine($"Does it exist?
  prefs: []
  type: TYPE_NORMAL
- en: '{Exists(newFolder)}'
  prefs: []
  type: TYPE_NORMAL
- en: '"'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: In `Program.cs` , comment out the previous method call, and add a call to `WorkWithDirectories`
    .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the code and view the result, and use your favorite file management tool
    to confirm that the directory has been created before pressing Enter to delete
    it, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: 'Working with: /Users/markjprice/Code/Chapter09/NewFolder Does it exist? False'
  prefs: []
  type: TYPE_NORMAL
- en: Creating it...
  prefs: []
  type: TYPE_NORMAL
- en: Does it exist? True
  prefs: []
  type: TYPE_NORMAL
- en: 'Confirm the directory exists, and then press ENTER:'
  prefs: []
  type: TYPE_NORMAL
- en: Deleting it...
  prefs: []
  type: TYPE_NORMAL
- en: Does it exist? False
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Managing files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When working with files, you could statically import the file type, just as
    we did for the directory type, but, for the next example, we will not, because
    it has some of the same methods as the directory type and they would conflict.
    The file type has a short enough name not to matter in this case. The steps are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `WorkWithFiles` method, and write statements to do the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check for the existence of a file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a text file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a line of text to the file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Close the file to release system resources and file locks (this would normally
    be done inside a `try-finally` statement block to ensure that the file is closed
    even if an exception occurs when writing to it).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the file to a backup.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete the original file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Read the backup file''s contents and then close it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: static
  prefs: []
  type: TYPE_NORMAL
- en: void
  prefs: []
  type: TYPE_NORMAL
- en: WorkWithFiles
  prefs: []
  type: TYPE_NORMAL
- en: ()
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: // define a directory path to output files
  prefs: []
  type: TYPE_NORMAL
- en: // starting in the user's folder
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: dir = Combine(
  prefs: []
  type: TYPE_NORMAL
- en: GetFolderPath(SpecialFolder.Personal),
  prefs: []
  type: TYPE_NORMAL
- en: '"Code"'
  prefs: []
  type: TYPE_NORMAL
- en: ', "Chapter09"'
  prefs: []
  type: TYPE_NORMAL
- en: ', "OutputFiles"'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: CreateDirectory(dir);
  prefs: []
  type: TYPE_NORMAL
- en: // define file paths
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: textFile = Combine(dir, "Dummy.txt"
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: backupFile = Combine(dir, "Dummy.bak"
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: 'WriteLine($"Working with:'
  prefs: []
  type: TYPE_NORMAL
- en: '{textFile}'
  prefs: []
  type: TYPE_NORMAL
- en: '"'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: // check if a file exists
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine($"Does it exist?
  prefs: []
  type: TYPE_NORMAL
- en: '{File.Exists(textFile)}'
  prefs: []
  type: TYPE_NORMAL
- en: '"'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: // create a new text file and write a line to it
  prefs: []
  type: TYPE_NORMAL
- en: StreamWriter textWriter = File.CreateText(textFile);
  prefs: []
  type: TYPE_NORMAL
- en: textWriter.WriteLine("Hello, C#!"
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: textWriter.Close(); // close file and release resources
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine($"Does it exist?
  prefs: []
  type: TYPE_NORMAL
- en: '{File.Exists(textFile)}'
  prefs: []
  type: TYPE_NORMAL
- en: '"'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: // copy the file, and overwrite if it already exists
  prefs: []
  type: TYPE_NORMAL
- en: 'File.Copy(sourceFileName: textFile,'
  prefs: []
  type: TYPE_NORMAL
- en: 'destFileName: backupFile, overwrite: true'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine(
  prefs: []
  type: TYPE_NORMAL
- en: $"Does
  prefs: []
  type: TYPE_NORMAL
- en: '{backupFile}'
  prefs: []
  type: TYPE_NORMAL
- en: exist?
  prefs: []
  type: TYPE_NORMAL
- en: '{File.Exists(backupFile)}'
  prefs: []
  type: TYPE_NORMAL
- en: '"'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: 'Write("Confirm the files exist, and then press ENTER: "'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: ReadLine();
  prefs: []
  type: TYPE_NORMAL
- en: // delete file
  prefs: []
  type: TYPE_NORMAL
- en: File.Delete(textFile);
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine($"Does it exist?
  prefs: []
  type: TYPE_NORMAL
- en: '{File.Exists(textFile)}'
  prefs: []
  type: TYPE_NORMAL
- en: '"'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: // read from the text file backup
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine($"Reading contents of
  prefs: []
  type: TYPE_NORMAL
- en: '{backupFile}'
  prefs: []
  type: TYPE_NORMAL
- en: :"
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: StreamReader textReader = File.OpenText(backupFile);
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine(textReader.ReadToEnd());
  prefs: []
  type: TYPE_NORMAL
- en: textReader.Close();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: In `Program.cs` , comment out the previous method call, and add a call to `WorkWithFiles`
    .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: 'Working with: /Users/markjprice/Code/Chapter09/OutputFiles/Dummy.txt'
  prefs: []
  type: TYPE_NORMAL
- en: Does it exist? False
  prefs: []
  type: TYPE_NORMAL
- en: Does it exist? True
  prefs: []
  type: TYPE_NORMAL
- en: Does /Users/markjprice/Code/Chapter09/OutputFiles/Dummy.bak exist? True
  prefs: []
  type: TYPE_NORMAL
- en: 'Confirm the files exist, and then press ENTER:'
  prefs: []
  type: TYPE_NORMAL
- en: Does it exist? False
  prefs: []
  type: TYPE_NORMAL
- en: 'Reading contents of /Users/markjprice/Code/Chapter09/OutputFiles/Dummy.bak:'
  prefs: []
  type: TYPE_NORMAL
- en: Hello, C#!
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Managing paths
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes, you need to work with parts of a path; for example, you might want
    to extract just the folder name, the filename, or the extension. Sometimes, you
    need to generate temporary folders and filenames. You can do this with static
    methods of the `Path` class:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following statements to the end of the `WorkWithFiles` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: // Managing paths
  prefs: []
  type: TYPE_NORMAL
- en: 'WriteLine($"Folder Name:'
  prefs: []
  type: TYPE_NORMAL
- en: '{GetDirectoryName(textFile)}'
  prefs: []
  type: TYPE_NORMAL
- en: '"'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: 'WriteLine($"File Name:'
  prefs: []
  type: TYPE_NORMAL
- en: '{GetFileName(textFile)}'
  prefs: []
  type: TYPE_NORMAL
- en: '"'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: 'WriteLine("File Name without Extension: {0}"'
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: GetFileNameWithoutExtension(textFile));
  prefs: []
  type: TYPE_NORMAL
- en: 'WriteLine($"File Extension:'
  prefs: []
  type: TYPE_NORMAL
- en: '{GetExtension(textFile)}'
  prefs: []
  type: TYPE_NORMAL
- en: '"'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: 'WriteLine($"Random File Name:'
  prefs: []
  type: TYPE_NORMAL
- en: '{GetRandomFileName()}'
  prefs: []
  type: TYPE_NORMAL
- en: '"'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: 'WriteLine($"Temporary File Name:'
  prefs: []
  type: TYPE_NORMAL
- en: '{GetTempFileName()}'
  prefs: []
  type: TYPE_NORMAL
- en: '"'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: 'Folder Name: /Users/markjprice/Code/Chapter09/OutputFiles'
  prefs: []
  type: TYPE_NORMAL
- en: 'File Name: Dummy.txt'
  prefs: []
  type: TYPE_NORMAL
- en: 'File Name without Extension: Dummy'
  prefs: []
  type: TYPE_NORMAL
- en: 'File Extension: .txt'
  prefs: []
  type: TYPE_NORMAL
- en: 'Random File Name: u45w1zki.co3'
  prefs: []
  type: TYPE_NORMAL
- en: 'Temporary File Name:'
  prefs: []
  type: TYPE_NORMAL
- en: /var/folders/tz/xx0y_wld5sx0nv0fjtq4tnpc0000gn/T/tmpyqrepP.tmp
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: '`GetTempFileName` creates a zero-byte file and returns its name, ready for
    you to use. `GetRandomFileName` just returns a filename; it doesn''t create the
    file.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting file information
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To get more information about a file or directory, for example, its size or
    when it was last accessed, you can create an instance of the `FileInfo` or `DirectoryInfo`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: '`FileInfo` and `DirectoryInfo` both inherit from `FileSystemInfo` , so they
    both have members such as `LastAccessTime` and `Delete` , as well as extra members
    specific to themselves, as shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Class | Members |'
  prefs: []
  type: TYPE_TB
- en: '| `FileSystemInfo` | Fields: `FullPath` , `OriginalPath`Properties: `Attributes`
    , `CreationTime` , `CreationTimeUtc` , `Exists` , `Extension` , `FullName` , `LastAccessTime`
    , `LastAccessTimeUtc` , `LastWriteTime` , `LastWriteTimeUtc` , `Name`Methods:
    `Delete` , `GetObjectData` , `Refresh` |'
  prefs: []
  type: TYPE_TB
- en: '| `DirectoryInfo` | Properties: `Parent` , `Root`Methods: `Create` , `CreateSubdirectory`
    , `EnumerateDirectories` , `EnumerateFiles` , `EnumerateFileSystemInfos` , `GetAccessControl`
    , `GetDirectories` , `GetFiles` , `GetFileSystemInfos` , `MoveTo` , `SetAccessControl`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `FileInfo` | Properties: `Directory` , `DirectoryName` , `IsReadOnly` , `Length`Methods:
    `AppendText` , `CopyTo` , `Create` , `CreateText` , `Decrypt` , `Encrypt` , `GetAccessControl`
    , `MoveTo` , `Open` , `OpenRead` , `OpenText` , `OpenWrite` , `Replace` , `SetAccessControl`
    |'
  prefs: []
  type: TYPE_TB
- en: 'Let''s write some code that uses a `FileInfo` instance for efficiently performing
    multiple actions on a file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add statements to the end of the `WorkWithFiles` method to create an instance
    of `FileInfo` for the backup file and write information about it to the console,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: FileInfo info = new
  prefs: []
  type: TYPE_NORMAL
- en: (backupFile);
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine($"
  prefs: []
  type: TYPE_NORMAL
- en: '{backupFile}'
  prefs: []
  type: TYPE_NORMAL
- en: :"
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine($"Contains
  prefs: []
  type: TYPE_NORMAL
- en: '{info.Length}'
  prefs: []
  type: TYPE_NORMAL
- en: bytes"
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine($"Last accessed
  prefs: []
  type: TYPE_NORMAL
- en: '{info.LastAccessTime}'
  prefs: []
  type: TYPE_NORMAL
- en: '"'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine($"Has readonly set to
  prefs: []
  type: TYPE_NORMAL
- en: '{info.IsReadOnly}'
  prefs: []
  type: TYPE_NORMAL
- en: '"'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: '/Users/markjprice/Code/Chapter09/OutputFiles/Dummy.bak:'
  prefs: []
  type: TYPE_NORMAL
- en: Contains 11 bytes
  prefs: []
  type: TYPE_NORMAL
- en: Last accessed 26/10/2021 09:08:26
  prefs: []
  type: TYPE_NORMAL
- en: Has readonly set to False
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: The number of bytes might be different on your operating system because operating
    systems can use different line endings.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling how you work with files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When working with files, you often need to control how they are opened. The
    `File.Open` method has overloads to specify additional options using `enum` values.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `enum` types are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`FileMode` : This controls what you want to do with the file, like `CreateNew`
    , `OpenOrCreate` , or `Truncate` .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FileAccess` : This controls what level of access you need, like `ReadWrite`
    .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FileShare` : This controls locks on the file to allow other processes the
    specified level of access, like `Read` .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You might want to open a file and read from it, and allow other processes to
    read it too, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: FileStream file = File.Open(pathToFile,
  prefs: []
  type: TYPE_NORMAL
- en: FileMode.Open, FileAccess.Read, FileShare.Read);
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is also an `enum` for attributes of a file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`FileAttributes` : This is to check a `FileSystemInfo` -derived types'' `Attributes`
    property for values like `Archive` and `Encrypted` .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You could check a file or directory''s attributes, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: FileInfo info = new
  prefs: []
  type: TYPE_NORMAL
- en: (backupFile);
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("Is the backup file compressed? {0}"
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: info.Attributes.HasFlag(FileAttributes.Compressed));
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Reading and writing with streams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **stream** is a sequence of bytes that can be read from and written to. Although
    files can be processed rather like arrays, with random access provided by knowing
    the position of a byte within the file, it can be useful to process files as a
    stream in which the bytes can be accessed in sequential order.
  prefs: []
  type: TYPE_NORMAL
- en: Streams can also be used to process terminal input and output and networking
    resources such as sockets and ports that do not provide random access and cannot
    seek (that is, move) to a position. You can write code to process some arbitrary
    bytes without knowing or caring where it comes from. Your code simply reads or
    writes to a stream, and another piece of code handles where the bytes are actually
    stored.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding abstract and concrete streams
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is an `abstract` class named `Stream` that represents any type of stream.
    Remember that an `abstract` class cannot be instantiated using `new` ; they can
    only be inherited.
  prefs: []
  type: TYPE_NORMAL
- en: There are many concrete classes that inherit from this base class, including
    `FileStream` , `MemoryStream` , `BufferedStream` , `GZipStream` , and `SslStream`
    , so they all work the same way. All streams implement `IDisposable` , so they
    have a `Dispose` method to release unmanaged resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the common members of the `Stream` class are described in the following
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Member | Description |'
  prefs: []
  type: TYPE_TB
- en: '| `CanRead` , `CanWrite` | These properties determine if you can read from
    and write to the stream. |'
  prefs: []
  type: TYPE_TB
- en: '| `Length` , `Position` | These properties determine the total number of bytes
    and the current position within the stream. These properties may throw an exception
    for some types of streams. |'
  prefs: []
  type: TYPE_TB
- en: '| `Dispose` | This method closes the stream and releases its resources. |'
  prefs: []
  type: TYPE_TB
- en: '| `Flush` | If the stream has a buffer, then this method writes the bytes in
    the buffer to the stream and the buffer is cleared. |'
  prefs: []
  type: TYPE_TB
- en: '| `CanSeek` | This property determines if the `Seek` method can be used. |'
  prefs: []
  type: TYPE_TB
- en: '| `Seek` | This method moves the current position to the one specified in its
    parameter. |'
  prefs: []
  type: TYPE_TB
- en: '| `Read` , `ReadAsync` | These methods read a specified number of bytes from
    the stream into a byte array and advance the position. |'
  prefs: []
  type: TYPE_TB
- en: '| `ReadByte` | This method reads the next byte from the stream and advances
    the position. |'
  prefs: []
  type: TYPE_TB
- en: '| `Write` , `WriteAsync` | These methods write the contents of a byte array
    into the stream. |'
  prefs: []
  type: TYPE_TB
- en: '| `WriteByte` | This method writes a byte to the stream. |'
  prefs: []
  type: TYPE_TB
- en: Understanding storage streams
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Some storage streams that represent a location where the bytes will be stored
    are described in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Namespace | Class | Description |'
  prefs: []
  type: TYPE_TB
- en: '| `System.IO` | `FileStream` | Bytes stored in the filesystem. |'
  prefs: []
  type: TYPE_TB
- en: '| `System.IO` | `MemoryStream` | Bytes stored in memory in the current process.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `System.Net.Sockets` | `NetworkStream` | Bytes stored at a network location.
    |'
  prefs: []
  type: TYPE_TB
- en: '`FileStream` has been re-written in .NET 6 to have much higher performance
    and reliability on Windows.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding function streams
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Some function streams that cannot exist on their own, but can only be "plugged
    onto" other streams to add functionality, are described in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Namespace | Class | Description |'
  prefs: []
  type: TYPE_TB
- en: '| `System.Security.Cryptography` | `CryptoStream` | This encrypts and decrypts
    the stream. |'
  prefs: []
  type: TYPE_TB
- en: '| `System.IO.Compression` | `GZipStream` , `DeflateStream` | These compress
    and decompress the stream. |'
  prefs: []
  type: TYPE_TB
- en: '| `System.Net.Security` | `AuthenticatedStream` | This sends credentials across
    the stream. |'
  prefs: []
  type: TYPE_TB
- en: Understanding stream helpers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although there will be occasions where you need to work with streams at a low
    level, most often, you can plug helper classes into the chain to make things easier.
    All the helper types for streams implement `IDisposable` , so they have a `Dispose`
    method to release unmanaged resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some helper classes to handle common scenarios are described in the following
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Namespace | Class | Description |'
  prefs: []
  type: TYPE_TB
- en: '| `System.IO` | `StreamReader` | This reads from the underlying stream as plain
    text. |'
  prefs: []
  type: TYPE_TB
- en: '| `System.IO` | `StreamWriter` | This writes to the underlying stream as plain
    text. |'
  prefs: []
  type: TYPE_TB
- en: '| `System.IO` | `BinaryReader` | This reads from streams as .NET types. For
    example, the `ReadDecimal` method reads the next 16 bytes from the underlying
    stream as a `decimal` value and the `ReadInt32` method reads the next 4 bytes
    as an `int` value. |'
  prefs: []
  type: TYPE_TB
- en: '| `System.IO` | `BinaryWriter` | This writes to streams as .NET types. For
    example, the `Write` method with a `decimal` parameter writes 16 bytes to the
    underlying stream and the `Write` method with an `int` parameter writes 4 bytes.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `System.Xml` | `XmlReader` | This reads from the underlying stream using
    XML format. |'
  prefs: []
  type: TYPE_TB
- en: '| `System.Xml` | `XmlWriter` | This writes to the underlying stream using XML
    format. |'
  prefs: []
  type: TYPE_TB
- en: Writing to text streams
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s type some code to write text to a stream:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use your preferred code editor to add a new console app named `WorkingWithStreams`
    to the `Chapter09` solution/workspace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Visual Studio, set the startup project for the solution to the current selection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Visual Studio Code, select `WorkingWithStreams` as the active OmniSharp project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `WorkingWithStreams` project, in `Program.cs` , import the `System.Xml`
    namespace and statically import the `System.Console` , `System.Environment` ,
    and `System.IO.Path` types.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the bottom of `Program.cs` , define a static class named `Viper` with a
    static array of `string` values named `Callsigns` , as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: static
  prefs: []
  type: TYPE_NORMAL
- en: class
  prefs: []
  type: TYPE_NORMAL
- en: Viper
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: // define an array of Viper pilot call signs
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: static
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: '[] Callsigns = new'
  prefs: []
  type: TYPE_NORMAL
- en: '[]'
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: '"Husker"'
  prefs: []
  type: TYPE_NORMAL
- en: ', "Starbuck"'
  prefs: []
  type: TYPE_NORMAL
- en: ', "Apollo"'
  prefs: []
  type: TYPE_NORMAL
- en: ', "Boomer"'
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: '"Bulldog"'
  prefs: []
  type: TYPE_NORMAL
- en: ', "Athena"'
  prefs: []
  type: TYPE_NORMAL
- en: ', "Helo"'
  prefs: []
  type: TYPE_NORMAL
- en: ', "Racetrack"'
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Above the `Viper` class, define a `WorkWithText` method that enumerates the
    Viper call signs, writing each one on its own line in a single text file, as shown
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: static
  prefs: []
  type: TYPE_NORMAL
- en: void
  prefs: []
  type: TYPE_NORMAL
- en: WorkWithText
  prefs: []
  type: TYPE_NORMAL
- en: ()
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: // define a file to write to
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: textFile = Combine(CurrentDirectory, "streams.txt"
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: // create a text file and return a helper writer
  prefs: []
  type: TYPE_NORMAL
- en: StreamWriter text = File.CreateText(textFile);
  prefs: []
  type: TYPE_NORMAL
- en: // enumerate the strings, writing each one
  prefs: []
  type: TYPE_NORMAL
- en: // to the stream on a separate line
  prefs: []
  type: TYPE_NORMAL
- en: foreach
  prefs: []
  type: TYPE_NORMAL
- en: (string
  prefs: []
  type: TYPE_NORMAL
- en: item in
  prefs: []
  type: TYPE_NORMAL
- en: Viper.Callsigns)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: text.WriteLine(item);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: text.Close(); // release resources
  prefs: []
  type: TYPE_NORMAL
- en: // output the contents of the file
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("{0} contains {1:N0} bytes."
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: 'arg0: textFile,'
  prefs: []
  type: TYPE_NORMAL
- en: 'arg1: new'
  prefs: []
  type: TYPE_NORMAL
- en: FileInfo(textFile).Length);
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine(File.ReadAllText(textFile));
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Below the namespace imports, call the `WorkWithText` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: /Users/markjprice/Code/Chapter09/WorkingWithStreams/streams.txt contains
  prefs: []
  type: TYPE_NORMAL
- en: 60 bytes.
  prefs: []
  type: TYPE_NORMAL
- en: Husker
  prefs: []
  type: TYPE_NORMAL
- en: Starbuck
  prefs: []
  type: TYPE_NORMAL
- en: Apollo
  prefs: []
  type: TYPE_NORMAL
- en: Boomer
  prefs: []
  type: TYPE_NORMAL
- en: Bulldog
  prefs: []
  type: TYPE_NORMAL
- en: Athena
  prefs: []
  type: TYPE_NORMAL
- en: Helo
  prefs: []
  type: TYPE_NORMAL
- en: Racetrack
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Open the file that was created and check that it contains the list of call signs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Writing to XML streams
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two ways to write an XML element, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`WriteStartElement` and `WriteEndElement` : Use this pair when an element might
    have child elements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WriteElementString` : Use this when an element does not have children.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let''s try storing the Viper pilot call signs array of `string` values
    in an XML file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `WorkWithXml` method that enumerates the call signs, writing each
    one as an element in a single XML file, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: static
  prefs: []
  type: TYPE_NORMAL
- en: void
  prefs: []
  type: TYPE_NORMAL
- en: WorkWithXml
  prefs: []
  type: TYPE_NORMAL
- en: ()
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: // define a file to write to
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: xmlFile = Combine(CurrentDirectory, "streams.xml"
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: // create a file stream
  prefs: []
  type: TYPE_NORMAL
- en: FileStream xmlFileStream = File.Create(xmlFile);
  prefs: []
  type: TYPE_NORMAL
- en: // wrap the file stream in an XML writer helper
  prefs: []
  type: TYPE_NORMAL
- en: // and automatically indent nested elements
  prefs: []
  type: TYPE_NORMAL
- en: XmlWriter xml = XmlWriter.Create(xmlFileStream,
  prefs: []
  type: TYPE_NORMAL
- en: new
  prefs: []
  type: TYPE_NORMAL
- en: XmlWriterSettings { Indent = true
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  prefs: []
  type: TYPE_NORMAL
- en: // write the XML declaration
  prefs: []
  type: TYPE_NORMAL
- en: xml.WriteStartDocument();
  prefs: []
  type: TYPE_NORMAL
- en: // write a root element
  prefs: []
  type: TYPE_NORMAL
- en: xml.WriteStartElement("callsigns"
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: // enumerate the strings writing each one to the stream
  prefs: []
  type: TYPE_NORMAL
- en: foreach
  prefs: []
  type: TYPE_NORMAL
- en: (string
  prefs: []
  type: TYPE_NORMAL
- en: item in
  prefs: []
  type: TYPE_NORMAL
- en: Viper.Callsigns)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: xml.WriteElementString("callsign"
  prefs: []
  type: TYPE_NORMAL
- en: ', item);'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: // write the close root element
  prefs: []
  type: TYPE_NORMAL
- en: xml.WriteEndElement();
  prefs: []
  type: TYPE_NORMAL
- en: // close helper and stream
  prefs: []
  type: TYPE_NORMAL
- en: xml.Close();
  prefs: []
  type: TYPE_NORMAL
- en: xmlFileStream.Close();
  prefs: []
  type: TYPE_NORMAL
- en: // output all the contents of the file
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("{0} contains {1:N0} bytes."
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: 'arg0: xmlFile,'
  prefs: []
  type: TYPE_NORMAL
- en: 'arg1: new'
  prefs: []
  type: TYPE_NORMAL
- en: FileInfo(xmlFile).Length);
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine(File.ReadAllText(xmlFile));
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: In `Program.cs` , comment out the previous method call, and add a call to the
    `WorkWithXml` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: /Users/markjprice/Code/Chapter09/WorkingWithStreams/streams.xml contains
  prefs: []
  type: TYPE_NORMAL
- en: 310 bytes.
  prefs: []
  type: TYPE_NORMAL
- en: <?xml version="1.0" encoding="utf-8"?>
  prefs: []
  type: TYPE_NORMAL
- en: <callsigns>
  prefs: []
  type: TYPE_NORMAL
- en: <callsign>Husker</callsign>
  prefs: []
  type: TYPE_NORMAL
- en: <callsign>Starbuck</callsign>
  prefs: []
  type: TYPE_NORMAL
- en: <callsign>Apollo</callsign>
  prefs: []
  type: TYPE_NORMAL
- en: <callsign>Boomer</callsign>
  prefs: []
  type: TYPE_NORMAL
- en: <callsign>Bulldog</callsign>
  prefs: []
  type: TYPE_NORMAL
- en: <callsign>Athena</callsign>
  prefs: []
  type: TYPE_NORMAL
- en: <callsign>Helo</callsign>
  prefs: []
  type: TYPE_NORMAL
- en: <callsign>Racetrack</callsign>
  prefs: []
  type: TYPE_NORMAL
- en: </callsigns>
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Disposing of file resources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you open a file to read or write to it, you are using resources outside
    of .NET. These are called **unmanaged resources** and must be disposed of when
    you are done working with them. To deterministically control when they are disposed
    of, we can call the `Dispose` method inside of a `finally` block.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s improve our previous code that works with XML to properly dispose of
    its unmanaged resources:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the `WorkWithXml` method, as shown highlighted in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: static
  prefs: []
  type: TYPE_NORMAL
- en: void
  prefs: []
  type: TYPE_NORMAL
- en: WorkWithXml
  prefs: []
  type: TYPE_NORMAL
- en: ()
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: '**FileStream? xmlFileStream =**'
  prefs: []
  type: TYPE_NORMAL
- en: '**null**'
  prefs: []
  type: TYPE_NORMAL
- en: '**;**'
  prefs: []
  type: TYPE_NORMAL
- en: '**XmlWriter? xml =**'
  prefs: []
  type: TYPE_NORMAL
- en: '**null**'
  prefs: []
  type: TYPE_NORMAL
- en: '**;**'
  prefs: []
  type: TYPE_NORMAL
- en: '**try**'
  prefs: []
  type: TYPE_NORMAL
- en: '**{**'
  prefs: []
  type: TYPE_NORMAL
- en: // define a file to write to
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: xmlFile = Combine(CurrentDirectory, "streams.xml"
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: // create a file stream
  prefs: []
  type: TYPE_NORMAL
- en: '**xmlFileStream = File.Create(xmlFile);**'
  prefs: []
  type: TYPE_NORMAL
- en: // wrap the file stream in an XML writer helper
  prefs: []
  type: TYPE_NORMAL
- en: // and automatically indent nested elements
  prefs: []
  type: TYPE_NORMAL
- en: '**xml = XmlWriter.Create(xmlFileStream,**'
  prefs: []
  type: TYPE_NORMAL
- en: '**new**'
  prefs: []
  type: TYPE_NORMAL
- en: '**XmlWriterSettings { Indent =**'
  prefs: []
  type: TYPE_NORMAL
- en: '**true**'
  prefs: []
  type: TYPE_NORMAL
- en: '**});**'
  prefs: []
  type: TYPE_NORMAL
- en: // write the XML declaration
  prefs: []
  type: TYPE_NORMAL
- en: xml.WriteStartDocument();
  prefs: []
  type: TYPE_NORMAL
- en: // write a root element
  prefs: []
  type: TYPE_NORMAL
- en: xml.WriteStartElement("callsigns"
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: // enumerate the strings writing each one to the stream
  prefs: []
  type: TYPE_NORMAL
- en: foreach
  prefs: []
  type: TYPE_NORMAL
- en: (string
  prefs: []
  type: TYPE_NORMAL
- en: item in
  prefs: []
  type: TYPE_NORMAL
- en: Viper.Callsigns)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: xml.WriteElementString("callsign"
  prefs: []
  type: TYPE_NORMAL
- en: ', item);'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: // write the close root element
  prefs: []
  type: TYPE_NORMAL
- en: xml.WriteEndElement();
  prefs: []
  type: TYPE_NORMAL
- en: // close helper and stream
  prefs: []
  type: TYPE_NORMAL
- en: xml.Close();
  prefs: []
  type: TYPE_NORMAL
- en: xmlFileStream.Close();
  prefs: []
  type: TYPE_NORMAL
- en: // output all the contents of the file
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine($"
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: contains
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: '1'
  prefs: []
  type: TYPE_NORMAL
- en: :N0}
  prefs: []
  type: TYPE_NORMAL
- en: bytes."
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: 'arg0: xmlFile,'
  prefs: []
  type: TYPE_NORMAL
- en: 'arg1: new'
  prefs: []
  type: TYPE_NORMAL
- en: FileInfo(xmlFile).Length);
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine(File.ReadAllText(xmlFile));
  prefs: []
  type: TYPE_NORMAL
- en: '**}**'
  prefs: []
  type: TYPE_NORMAL
- en: '**catch (Exception ex)**'
  prefs: []
  type: TYPE_NORMAL
- en: '**{**'
  prefs: []
  type: TYPE_NORMAL
- en: '**// if the path doesn''t exist the exception will be caught**'
  prefs: []
  type: TYPE_NORMAL
- en: '**WriteLine(**'
  prefs: []
  type: TYPE_NORMAL
- en: '**$"**'
  prefs: []
  type: TYPE_NORMAL
- en: '**{ex.GetType()}**'
  prefs: []
  type: TYPE_NORMAL
- en: '**says**'
  prefs: []
  type: TYPE_NORMAL
- en: '**{ex.Message}**'
  prefs: []
  type: TYPE_NORMAL
- en: '**"**'
  prefs: []
  type: TYPE_NORMAL
- en: '**);**'
  prefs: []
  type: TYPE_NORMAL
- en: '**}**'
  prefs: []
  type: TYPE_NORMAL
- en: '**finally**'
  prefs: []
  type: TYPE_NORMAL
- en: '**{**'
  prefs: []
  type: TYPE_NORMAL
- en: '**if**'
  prefs: []
  type: TYPE_NORMAL
- en: '**(xml !=**'
  prefs: []
  type: TYPE_NORMAL
- en: '**null**'
  prefs: []
  type: TYPE_NORMAL
- en: '**)**'
  prefs: []
  type: TYPE_NORMAL
- en: '**{**'
  prefs: []
  type: TYPE_NORMAL
- en: '**xml.Dispose();**'
  prefs: []
  type: TYPE_NORMAL
- en: '**WriteLine(**'
  prefs: []
  type: TYPE_NORMAL
- en: '**"The XML writer''s unmanaged resources have been disposed."**'
  prefs: []
  type: TYPE_NORMAL
- en: '**);**'
  prefs: []
  type: TYPE_NORMAL
- en: '**if**'
  prefs: []
  type: TYPE_NORMAL
- en: '**(xmlFileStream !=**'
  prefs: []
  type: TYPE_NORMAL
- en: '**null**'
  prefs: []
  type: TYPE_NORMAL
- en: '**)**'
  prefs: []
  type: TYPE_NORMAL
- en: '**{**'
  prefs: []
  type: TYPE_NORMAL
- en: '**xmlFileStream.Dispose();**'
  prefs: []
  type: TYPE_NORMAL
- en: '**WriteLine(**'
  prefs: []
  type: TYPE_NORMAL
- en: '**"The file stream''s unmanaged resources have been disposed."**'
  prefs: []
  type: TYPE_NORMAL
- en: '**);**'
  prefs: []
  type: TYPE_NORMAL
- en: '**}**'
  prefs: []
  type: TYPE_NORMAL
- en: '**}**'
  prefs: []
  type: TYPE_NORMAL
- en: '**}**'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: You could also go back and modify the other methods you previously created but
    I will leave that as an optional exercise for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: The XML writer's unmanaged resources have been disposed.
  prefs: []
  type: TYPE_NORMAL
- en: The file stream's unmanaged resources have been disposed.
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice** : Before calling the `Dispose` method, check that the object
    is not null.'
  prefs: []
  type: TYPE_NORMAL
- en: Simplifying disposal by using the using statement
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can simplify the code that needs to check for a `null` object and then call
    its `Dispose` method by using the `using` statement. Generally, I would recommend
    using `using` rather than manually calling `Dispose` unless you need a greater
    level of control.
  prefs: []
  type: TYPE_NORMAL
- en: 'Confusingly, there are two uses for the `using` keyword: importing a namespace
    and generating a `finally` statement that calls `Dispose` on an object that implements
    `IDisposable` .'
  prefs: []
  type: TYPE_NORMAL
- en: 'The compiler changes a `using` statement block into a `try` -`finally` statement
    without a `catch` statement. You can use nested `try` statements; so, if you do
    want to catch any exceptions, you can, as shown in the following code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: (FileStream file2 = File.OpenWrite(
  prefs: []
  type: TYPE_NORMAL
- en: Path.Combine(path, "file2.txt"
  prefs: []
  type: TYPE_NORMAL
- en: )))
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: (StreamWriter writer2 = new
  prefs: []
  type: TYPE_NORMAL
- en: StreamWriter(file2))
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: try
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: writer2.WriteLine("Welcome, .NET!"
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: catch(Exception ex)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine($"
  prefs: []
  type: TYPE_NORMAL
- en: '{ex.GetType()}'
  prefs: []
  type: TYPE_NORMAL
- en: says
  prefs: []
  type: TYPE_NORMAL
- en: '{ex.Message}'
  prefs: []
  type: TYPE_NORMAL
- en: '"'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '} // automatically calls Dispose if the object is not null'
  prefs: []
  type: TYPE_NORMAL
- en: '} // automatically calls Dispose if the object is not null'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even simplify the code further by not explicitly specifying the braces
    and indentation for the `using` statements, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: FileStream file2 = File.OpenWrite(
  prefs: []
  type: TYPE_NORMAL
- en: Path.Combine(path, "file2.txt"
  prefs: []
  type: TYPE_NORMAL
- en: ));
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: StreamWriter writer2 = new
  prefs: []
  type: TYPE_NORMAL
- en: (file2);
  prefs: []
  type: TYPE_NORMAL
- en: try
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: writer2.WriteLine("Welcome, .NET!"
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: catch(Exception ex)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine($"
  prefs: []
  type: TYPE_NORMAL
- en: '{ex.GetType()}'
  prefs: []
  type: TYPE_NORMAL
- en: says
  prefs: []
  type: TYPE_NORMAL
- en: '{ex.Message}'
  prefs: []
  type: TYPE_NORMAL
- en: '"'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Compressing streams
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'XML is relatively verbose, so it takes up more space in bytes than plain text.
    Let''s see how we can squeeze the XML using a common compression algorithm known
    as GZIP:'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the top of `Program.cs` , import the namespace for working with compression,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: System.IO.Compression; // BrotliStream, GZipStream, CompressionMode
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a `WorkWithCompression` method, which uses instances of `GZipStream` to
    create a compressed file containing the same XML elements as before and then decompresses
    it while reading it and outputting to the console, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: static
  prefs: []
  type: TYPE_NORMAL
- en: void
  prefs: []
  type: TYPE_NORMAL
- en: WorkWithCompression
  prefs: []
  type: TYPE_NORMAL
- en: ()
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: fileExt = "gzip"
  prefs: []
  type: TYPE_NORMAL
- en: ;
  prefs: []
  type: TYPE_NORMAL
- en: // compress the XML output
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: filePath = Combine(
  prefs: []
  type: TYPE_NORMAL
- en: CurrentDirectory, $"streams.
  prefs: []
  type: TYPE_NORMAL
- en: '**{fileExt}**'
  prefs: []
  type: TYPE_NORMAL
- en: '"'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: FileStream file = File.Create(filePath);
  prefs: []
  type: TYPE_NORMAL
- en: Stream compressor = new
  prefs: []
  type: TYPE_NORMAL
- en: GZipStream(file, CompressionMode.Compress);
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: (compressor)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: (XmlWriter xml = XmlWriter.Create(compressor))
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: xml.WriteStartDocument();
  prefs: []
  type: TYPE_NORMAL
- en: xml.WriteStartElement("callsigns"
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: foreach
  prefs: []
  type: TYPE_NORMAL
- en: (string
  prefs: []
  type: TYPE_NORMAL
- en: item in
  prefs: []
  type: TYPE_NORMAL
- en: Viper.Callsigns)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: xml.WriteElementString("callsign"
  prefs: []
  type: TYPE_NORMAL
- en: ', item);'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: // the normal call to WriteEndElement is not necessary
  prefs: []
  type: TYPE_NORMAL
- en: // because when the XmlWriter disposes, it will
  prefs: []
  type: TYPE_NORMAL
- en: // automatically end any elements of any depth
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '} // also closes the underlying stream'
  prefs: []
  type: TYPE_NORMAL
- en: // output all the contents of the compressed file
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("{0} contains {1:N0} bytes."
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: filePath, new
  prefs: []
  type: TYPE_NORMAL
- en: FileInfo(filePath).Length);
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine($"The compressed contents:"
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine(File.ReadAllText(filePath));
  prefs: []
  type: TYPE_NORMAL
- en: // read a compressed file
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("Reading the compressed XML file:"
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: file = File.Open(filePath, FileMode.Open);
  prefs: []
  type: TYPE_NORMAL
- en: Stream decompressor = new
  prefs: []
  type: TYPE_NORMAL
- en: GZipStream(file,
  prefs: []
  type: TYPE_NORMAL
- en: CompressionMode.Decompress);
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: (decompressor)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: (XmlReader reader = XmlReader.Create(decompressor))
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: while
  prefs: []
  type: TYPE_NORMAL
- en: (reader.Read()) // read the next XML node
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: // check if we are on an element node named callsign
  prefs: []
  type: TYPE_NORMAL
- en: if
  prefs: []
  type: TYPE_NORMAL
- en: ((reader.NodeType == XmlNodeType.Element)
  prefs: []
  type: TYPE_NORMAL
- en: '&& (reader.Name == "callsign"'
  prefs: []
  type: TYPE_NORMAL
- en: ))
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: reader.Read(); // move to the text inside element
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine($"
  prefs: []
  type: TYPE_NORMAL
- en: '{reader.Value}'
  prefs: []
  type: TYPE_NORMAL
- en: '"'
  prefs: []
  type: TYPE_NORMAL
- en: ); // read its value
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs` , leave the call to `WorkWithXml` , and add a call to `WorkWithCompression`
    , as shown highlighted in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: // WorkWithText();
  prefs: []
  type: TYPE_NORMAL
- en: '**WorkWithXml();**'
  prefs: []
  type: TYPE_NORMAL
- en: '**WorkWithCompression();**'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code and compare the sizes of the XML file and the compressed XML file.
    It is less than half the size of the same XML without compression, as shown in
    the following edited output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: /Users/markjprice/Code/Chapter09/WorkingWithStreams/streams.xml contains 310
    bytes.
  prefs: []
  type: TYPE_NORMAL
- en: /Users/markjprice/Code/Chapter09/WorkingWithStreams/streams.gzip contains 150
    bytes.
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Compressing with the Brotli algorithm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In .NET Core 2.1, Microsoft introduced an implementation of the Brotli compression
    algorithm. In performance, Brotli is like the algorithm used in DEFLATE and GZIP,
    but the output is about 20% denser. The steps are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the `WorkWithCompression` method to have an optional parameter to indicate
    if Brotli should be used and to use Brotli by default, as shown highlighted in
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: static
  prefs: []
  type: TYPE_NORMAL
- en: void
  prefs: []
  type: TYPE_NORMAL
- en: WorkWithCompression
  prefs: []
  type: TYPE_NORMAL
- en: (
  prefs: []
  type: TYPE_NORMAL
- en: '**bool**'
  prefs: []
  type: TYPE_NORMAL
- en: '**useBrotli =**'
  prefs: []
  type: TYPE_NORMAL
- en: '**true**'
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: fileExt =
  prefs: []
  type: TYPE_NORMAL
- en: '**useBrotli ?**'
  prefs: []
  type: TYPE_NORMAL
- en: '**"brotli"**'
  prefs: []
  type: TYPE_NORMAL
- en: '**:**'
  prefs: []
  type: TYPE_NORMAL
- en: '**"gzip"**'
  prefs: []
  type: TYPE_NORMAL
- en: '**;**'
  prefs: []
  type: TYPE_NORMAL
- en: // compress the XML output
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: filePath = Combine(
  prefs: []
  type: TYPE_NORMAL
- en: CurrentDirectory, $"streams.
  prefs: []
  type: TYPE_NORMAL
- en: '{fileExt}'
  prefs: []
  type: TYPE_NORMAL
- en: '"'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: FileStream file = File.Create(filePath);
  prefs: []
  type: TYPE_NORMAL
- en: '**Stream compressor;**'
  prefs: []
  type: TYPE_NORMAL
- en: '**if**'
  prefs: []
  type: TYPE_NORMAL
- en: '**(useBrotli)**'
  prefs: []
  type: TYPE_NORMAL
- en: '**{**'
  prefs: []
  type: TYPE_NORMAL
- en: '**compressor =**'
  prefs: []
  type: TYPE_NORMAL
- en: '**new**'
  prefs: []
  type: TYPE_NORMAL
- en: '**BrotliStream(file, CompressionMode.Compress);**'
  prefs: []
  type: TYPE_NORMAL
- en: '**}**'
  prefs: []
  type: TYPE_NORMAL
- en: '**else**'
  prefs: []
  type: TYPE_NORMAL
- en: '**{**'
  prefs: []
  type: TYPE_NORMAL
- en: '**compressor =**'
  prefs: []
  type: TYPE_NORMAL
- en: '**new**'
  prefs: []
  type: TYPE_NORMAL
- en: '**GZipStream(file, CompressionMode.Compress);**'
  prefs: []
  type: TYPE_NORMAL
- en: '**}**'
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: (compressor)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: (XmlWriter xml = XmlWriter.Create(compressor))
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: xml.WriteStartDocument();
  prefs: []
  type: TYPE_NORMAL
- en: xml.WriteStartElement("callsigns"
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: foreach
  prefs: []
  type: TYPE_NORMAL
- en: (string
  prefs: []
  type: TYPE_NORMAL
- en: item in
  prefs: []
  type: TYPE_NORMAL
- en: Viper.Callsigns)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: xml.WriteElementString("callsign"
  prefs: []
  type: TYPE_NORMAL
- en: ', item);'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '} // also closes the underlying stream'
  prefs: []
  type: TYPE_NORMAL
- en: // output all the contents of the compressed file
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("{0} contains {1:N0} bytes."
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: filePath, new
  prefs: []
  type: TYPE_NORMAL
- en: FileInfo(filePath).Length);
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine($"The compressed contents:"
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine(File.ReadAllText(filePath));
  prefs: []
  type: TYPE_NORMAL
- en: // read a compressed file
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("Reading the compressed XML file:"
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: file = File.Open(filePath, FileMode.Open);
  prefs: []
  type: TYPE_NORMAL
- en: '**Stream decompressor;**'
  prefs: []
  type: TYPE_NORMAL
- en: '**if**'
  prefs: []
  type: TYPE_NORMAL
- en: '**(useBrotli)**'
  prefs: []
  type: TYPE_NORMAL
- en: '**{**'
  prefs: []
  type: TYPE_NORMAL
- en: '**decompressor =**'
  prefs: []
  type: TYPE_NORMAL
- en: '**new**'
  prefs: []
  type: TYPE_NORMAL
- en: '**BrotliStream(**'
  prefs: []
  type: TYPE_NORMAL
- en: '**file, CompressionMode.Decompress);**'
  prefs: []
  type: TYPE_NORMAL
- en: '**}**'
  prefs: []
  type: TYPE_NORMAL
- en: '**else**'
  prefs: []
  type: TYPE_NORMAL
- en: '**{**'
  prefs: []
  type: TYPE_NORMAL
- en: '**decompressor =**'
  prefs: []
  type: TYPE_NORMAL
- en: '**new**'
  prefs: []
  type: TYPE_NORMAL
- en: '**GZipStream(**'
  prefs: []
  type: TYPE_NORMAL
- en: '**file, CompressionMode.Decompress);**'
  prefs: []
  type: TYPE_NORMAL
- en: '**}**'
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: (decompressor)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: (XmlReader reader = XmlReader.Create(decompressor))
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: while
  prefs: []
  type: TYPE_NORMAL
- en: (reader.Read())
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: // check if we are on an element node named callsign
  prefs: []
  type: TYPE_NORMAL
- en: if
  prefs: []
  type: TYPE_NORMAL
- en: ((reader.NodeType == XmlNodeType.Element)
  prefs: []
  type: TYPE_NORMAL
- en: '&& (reader.Name == "callsign"'
  prefs: []
  type: TYPE_NORMAL
- en: ))
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: reader.Read(); // move to the text inside element
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine($"
  prefs: []
  type: TYPE_NORMAL
- en: '{reader.Value}'
  prefs: []
  type: TYPE_NORMAL
- en: '"'
  prefs: []
  type: TYPE_NORMAL
- en: ); // read its value
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Near the top of `Program.cs` , call `WorkWithCompression` twice, once with
    the default using Brotli and once with GZIP, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: WorkWithCompression();
  prefs: []
  type: TYPE_NORMAL
- en: 'WorkWithCompression(useBrotli: false'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code and compare the sizes of the two compressed XML files. Brotli
    is more than 21% denser, as shown in the following edited output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: /Users/markjprice/Code/Chapter09/WorkingWithStreams/streams.brotli contains
    118 bytes.
  prefs: []
  type: TYPE_NORMAL
- en: /Users/markjprice/Code/Chapter09/WorkingWithStreams/streams.gzip contains 150
    bytes.
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Encoding and decoding text
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Text characters can be represented in different ways. For example, the alphabet
    can be encoded using Morse code into a series of dots and dashes for transmission
    over a telegraph line.
  prefs: []
  type: TYPE_NORMAL
- en: In a similar way, text inside a computer is stored as bits (ones and zeros)
    representing a code point within a code space. Most code points represent a single
    character, but they can also have other meanings like formatting.
  prefs: []
  type: TYPE_NORMAL
- en: For example, ASCII has a code space with 128 code points. .NET uses a standard
    called **Unicode** to encode text internally. Unicode has more than one million
    code points.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, you will need to move text outside .NET for use by systems that do
    not use Unicode or use a variation of Unicode, so it is important to learn how
    to convert between encodings.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table lists some alternative text encodings commonly used by
    computers:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Encoding | Description |'
  prefs: []
  type: TYPE_TB
- en: '| ASCII | This encodes a limited range of characters using the lower seven
    bits of a byte. |'
  prefs: []
  type: TYPE_TB
- en: '| UTF-8 | This represents each Unicode code point as a sequence of one to four
    bytes. |'
  prefs: []
  type: TYPE_TB
- en: '| UTF-7 | This is designed to be more efficient over 7-bit channels than UTF-8
    but it has security and robustness issues, so UTF-8 is recommended over UTF-7.
    |'
  prefs: []
  type: TYPE_TB
- en: '| UTF-16 | This represents each Unicode code point as a sequence of one or
    two 16-bit integers. |'
  prefs: []
  type: TYPE_TB
- en: '| UTF-32 | This represents each Unicode code point as a 32-bit integer and
    is therefore a fixed-length encoding unlike the other Unicode encodings, which
    are all variable-length encodings. |'
  prefs: []
  type: TYPE_TB
- en: '| ANSI/ISO encodings | This provides support for a variety of code pages that
    are used to support a specific language or group of languages. |'
  prefs: []
  type: TYPE_TB
- en: '**Good Practice** : In most cases today, UTF-8 is a good default, which is
    why it is literally the default encoding, that is, `Encoding.Default` .'
  prefs: []
  type: TYPE_NORMAL
- en: Encoding strings as byte arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s explore text encodings:'
  prefs: []
  type: TYPE_NORMAL
- en: Use your preferred code editor to add a new console app named `WorkingWithEncodings`
    to the `Chapter09` solution/workspace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Visual Studio Code, select `WorkingWithEncodings` as the active OmniSharp
    project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `Program.cs` , import the `System.Text` namespace and statically import the
    `Console` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add statements to encode a `string` using an encoding chosen by the user, loop
    through each byte, and then decode it back into a `string` and output it, as shown
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("Encodings"
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("[1] ASCII"
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("[2] UTF-7"
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("[3] UTF-8"
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("[4] UTF-16 (Unicode)"
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("[5] UTF-32"
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("[any other key] Default"
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: // choose an encoding
  prefs: []
  type: TYPE_NORMAL
- en: 'Write("Press a number to choose an encoding: "'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: 'ConsoleKey number = ReadKey(intercept: false'
  prefs: []
  type: TYPE_NORMAL
- en: ).Key;
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine();
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine();
  prefs: []
  type: TYPE_NORMAL
- en: Encoding encoder = number switch
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: ConsoleKey.D1 => Encoding.ASCII,
  prefs: []
  type: TYPE_NORMAL
- en: ConsoleKey.D2 => Encoding.UTF7,
  prefs: []
  type: TYPE_NORMAL
- en: ConsoleKey.D3 => Encoding.UTF8,
  prefs: []
  type: TYPE_NORMAL
- en: ConsoleKey.D4 => Encoding.Unicode,
  prefs: []
  type: TYPE_NORMAL
- en: ConsoleKey.D5 => Encoding.UTF32,
  prefs: []
  type: TYPE_NORMAL
- en: _             => Encoding.Default
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: // define a string to encode
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: 'message = "CafÃ© cost: Â£4.39"'
  prefs: []
  type: TYPE_NORMAL
- en: ;
  prefs: []
  type: TYPE_NORMAL
- en: // encode the string into a byte array
  prefs: []
  type: TYPE_NORMAL
- en: byte
  prefs: []
  type: TYPE_NORMAL
- en: '[] encoded = encoder.GetBytes(message);'
  prefs: []
  type: TYPE_NORMAL
- en: // check how many bytes the encoding needed
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("{0} uses {1:N0} bytes."
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: encoder.GetType().Name, encoded.Length);
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine();
  prefs: []
  type: TYPE_NORMAL
- en: // enumerate each byte
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine($"BYTE HEX CHAR"
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: foreach
  prefs: []
  type: TYPE_NORMAL
- en: (byte
  prefs: []
  type: TYPE_NORMAL
- en: b in
  prefs: []
  type: TYPE_NORMAL
- en: encoded)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine($"
  prefs: []
  type: TYPE_NORMAL
- en: '{b,'
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '{b.ToString('
  prefs: []
  type: TYPE_NORMAL
- en: '"X"'
  prefs: []
  type: TYPE_NORMAL
- en: ),
  prefs: []
  type: TYPE_NORMAL
- en: '4'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '{('
  prefs: []
  type: TYPE_NORMAL
- en: char
  prefs: []
  type: TYPE_NORMAL
- en: )b,
  prefs: []
  type: TYPE_NORMAL
- en: '5'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '"'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: // decode the byte array back into a string and display it
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: decoded = encoder.GetString(encoded);
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine(decoded);
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Run the code and note the warning to avoid using `Encoding.UTF7` because it
    is insecure. Of course, if you need to generate text using that encoding for compatibility
    with another system, it needs to remain an option in .NET.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press 1 to choose ASCII and note that when outputting the bytes, the pound sign
    (Â£) and accented e (Ã©) cannot be represented in ASCII, so it uses a question mark
    instead.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: BYTE  HEX  CHAR
  prefs: []
  type: TYPE_NORMAL
- en: 67   43     C
  prefs: []
  type: TYPE_NORMAL
- en: 97   61     a
  prefs: []
  type: TYPE_NORMAL
- en: 102   66     f
  prefs: []
  type: TYPE_NORMAL
- en: 63   3F     ?
  prefs: []
  type: TYPE_NORMAL
- en: 32   20
  prefs: []
  type: TYPE_NORMAL
- en: 111   6F     o
  prefs: []
  type: TYPE_NORMAL
- en: 115   73     s
  prefs: []
  type: TYPE_NORMAL
- en: 116   74     t
  prefs: []
  type: TYPE_NORMAL
- en: '58   3A     :'
  prefs: []
  type: TYPE_NORMAL
- en: 32   20
  prefs: []
  type: TYPE_NORMAL
- en: 63   3F     ?
  prefs: []
  type: TYPE_NORMAL
- en: 52   34     4
  prefs: []
  type: TYPE_NORMAL
- en: 46   2E     .
  prefs: []
  type: TYPE_NORMAL
- en: 51   33     3
  prefs: []
  type: TYPE_NORMAL
- en: 57   39     9
  prefs: []
  type: TYPE_NORMAL
- en: 'Caf? cost: ?4.39'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Rerun the code and press 3 to choose UTF-8 and note that UTF-8 requires two
    extra bytes for the two characters that need 2 bytes each (18 bytes instead of
    16 bytes total) but it can encode and decode the Ã© and Â£ characters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: UTF8EncodingSealed uses 18 bytes.
  prefs: []
  type: TYPE_NORMAL
- en: BYTE  HEX  CHAR
  prefs: []
  type: TYPE_NORMAL
- en: 67   43     C
  prefs: []
  type: TYPE_NORMAL
- en: 97   61     a
  prefs: []
  type: TYPE_NORMAL
- en: 102   66     f
  prefs: []
  type: TYPE_NORMAL
- en: 195   C3     Ã
  prefs: []
  type: TYPE_NORMAL
- en: 169   A9     Â©
  prefs: []
  type: TYPE_NORMAL
- en: 32   20
  prefs: []
  type: TYPE_NORMAL
- en: 111   6F     o
  prefs: []
  type: TYPE_NORMAL
- en: 115   73     s
  prefs: []
  type: TYPE_NORMAL
- en: 116   74     t
  prefs: []
  type: TYPE_NORMAL
- en: '58   3A     :'
  prefs: []
  type: TYPE_NORMAL
- en: 32   20
  prefs: []
  type: TYPE_NORMAL
- en: 194   C2     Ã
  prefs: []
  type: TYPE_NORMAL
- en: 163   A3     Â£
  prefs: []
  type: TYPE_NORMAL
- en: 52   34     4
  prefs: []
  type: TYPE_NORMAL
- en: 46   2E     .
  prefs: []
  type: TYPE_NORMAL
- en: 51   33     3
  prefs: []
  type: TYPE_NORMAL
- en: 57   39     9
  prefs: []
  type: TYPE_NORMAL
- en: 'CafÃ© cost: Â£4.39'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Rerun the code and press 4 to choose Unicode (UTF-16) and note that UTF-16 requires
    two bytes for every character, so 32 bytes in total, and it can encode and decode
    the Ã© and Â£ characters. This encoding is used internally by .NET to store `char`
    and `string` values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Encoding and decoding text in files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When using stream helper classes, such as `StreamReader` and `StreamWriter`
    , you can specify the encoding you want to use. As you write to the helper, the
    text will automatically be encoded, and as you read from the helper, the bytes
    will be automatically decoded.
  prefs: []
  type: TYPE_NORMAL
- en: 'To specify an encoding, pass the encoding as a second parameter to the helper
    type''s constructor, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: StreamReader reader = new
  prefs: []
  type: TYPE_NORMAL
- en: (stream, Encoding.UTF8);
  prefs: []
  type: TYPE_NORMAL
- en: StreamWriter writer = new
  prefs: []
  type: TYPE_NORMAL
- en: (stream, Encoding.UTF8);
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice** : Often, you won''t have the choice of which encoding to
    use, because you will be generating a file for use by another system. However,
    if you do, pick one that uses the least number of bytes, but can store every character
    you need.'
  prefs: []
  type: TYPE_NORMAL
- en: Serializing object graphs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Serialization** is the process of converting a live object into a sequence
    of bytes using a specified format. **Deserialization** is the reverse process.
    You would do this to save the current state of a live object so that you can recreate
    it in the future. For example, saving the current state of a game so that you
    can continue at the same place tomorrow. Serialized objects are usually stored
    in a file or database.'
  prefs: []
  type: TYPE_NORMAL
- en: There are dozens of formats you can specify, but the two most common ones are
    **eXtensible Markup Language** (**XML** ) and **JavaScript Object Notation** (**JSON**
    ).
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice** : JSON is more compact and is best for web and mobile applications.
    XML is more verbose but is better supported in more legacy systems. Use JSON to
    minimize the size of serialized object graphs. JSON is also a good choice when
    sending object graphs to web applications and mobile applications because JSON
    is the native serialization format for JavaScript and mobile apps often make calls
    over limited bandwidth, so the number of bytes is important.'
  prefs: []
  type: TYPE_NORMAL
- en: .NET has multiple classes that will serialize to and from XML and JSON. We will
    start by looking at `XmlSerializer` and `JsonSerializer` .
  prefs: []
  type: TYPE_NORMAL
- en: Serializing as XML
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start by looking at XML, probably the world''s most used serialization
    format (for now). To show a typical example, we will define a custom class to
    store information about a person and then create an object graph using a list
    of `Person` instances with nesting:'
  prefs: []
  type: TYPE_NORMAL
- en: Use your preferred code editor to add a new console app named `WorkingWithSerialization`
    to the `Chapter09` solution/workspace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Visual Studio Code, select `WorkingWithSerialization` as the active OmniSharp
    project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a class named `Person` with a `Salary` property that is `protected` , meaning
    it is only accessible to itself and derived classes. To populate the salary, the
    class has a constructor with a single parameter to set the initial salary, as
    shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: namespace
  prefs: []
  type: TYPE_NORMAL
- en: Packt.Shared
  prefs: []
  type: TYPE_NORMAL
- en: ;
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: class
  prefs: []
  type: TYPE_NORMAL
- en: Person
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: Person
  prefs: []
  type: TYPE_NORMAL
- en: (
  prefs: []
  type: TYPE_NORMAL
- en: decimal
  prefs: []
  type: TYPE_NORMAL
- en: initialSalary
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: Salary = initialSalary;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: '? FirstName { get'
  prefs: []
  type: TYPE_NORMAL
- en: ; set
  prefs: []
  type: TYPE_NORMAL
- en: ; }
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: '? LastName { get'
  prefs: []
  type: TYPE_NORMAL
- en: ; set
  prefs: []
  type: TYPE_NORMAL
- en: ; }
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: DateTime DateOfBirth { get
  prefs: []
  type: TYPE_NORMAL
- en: ; set
  prefs: []
  type: TYPE_NORMAL
- en: ; }
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: HashSet<Person>? Children { get
  prefs: []
  type: TYPE_NORMAL
- en: ; set
  prefs: []
  type: TYPE_NORMAL
- en: ; }
  prefs: []
  type: TYPE_NORMAL
- en: protected
  prefs: []
  type: TYPE_NORMAL
- en: decimal
  prefs: []
  type: TYPE_NORMAL
- en: Salary { get
  prefs: []
  type: TYPE_NORMAL
- en: ; set
  prefs: []
  type: TYPE_NORMAL
- en: ; }
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs` , import namespaces for working with XML serialization and
    statically import the `Console` , `Environment` , and `Path` classes, as shown
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: System.Xml.Serialization; // XmlSerializer
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: Packt.Shared; // Person
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: static
  prefs: []
  type: TYPE_NORMAL
- en: System.Console;
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: static
  prefs: []
  type: TYPE_NORMAL
- en: System.Environment;
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: static
  prefs: []
  type: TYPE_NORMAL
- en: System.IO.Path;
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add statements to create an object graph of `Person` instances, as shown in
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: // create an object graph
  prefs: []
  type: TYPE_NORMAL
- en: List<Person> people = new
  prefs: []
  type: TYPE_NORMAL
- en: ()
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: new
  prefs: []
  type: TYPE_NORMAL
- en: (30000
  prefs: []
  type: TYPE_NORMAL
- en: M)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: FirstName = "Alice"
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: LastName = "Smith"
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: DateOfBirth = new
  prefs: []
  type: TYPE_NORMAL
- en: (1974
  prefs: []
  type: TYPE_NORMAL
- en: ', 3'
  prefs: []
  type: TYPE_NORMAL
- en: ', 14'
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '},'
  prefs: []
  type: TYPE_NORMAL
- en: new
  prefs: []
  type: TYPE_NORMAL
- en: (40000
  prefs: []
  type: TYPE_NORMAL
- en: M)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: FirstName = "Bob"
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: LastName = "Jones"
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: DateOfBirth = new
  prefs: []
  type: TYPE_NORMAL
- en: (1969
  prefs: []
  type: TYPE_NORMAL
- en: ', 11'
  prefs: []
  type: TYPE_NORMAL
- en: ', 23'
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '},'
  prefs: []
  type: TYPE_NORMAL
- en: new
  prefs: []
  type: TYPE_NORMAL
- en: (20000
  prefs: []
  type: TYPE_NORMAL
- en: M)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: FirstName = "Charlie"
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: LastName = "Cox"
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: DateOfBirth = new
  prefs: []
  type: TYPE_NORMAL
- en: (1984
  prefs: []
  type: TYPE_NORMAL
- en: ', 5'
  prefs: []
  type: TYPE_NORMAL
- en: ', 4'
  prefs: []
  type: TYPE_NORMAL
- en: ),
  prefs: []
  type: TYPE_NORMAL
- en: Children = new
  prefs: []
  type: TYPE_NORMAL
- en: ()
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: new
  prefs: []
  type: TYPE_NORMAL
- en: (0
  prefs: []
  type: TYPE_NORMAL
- en: M)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: FirstName = "Sally"
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: LastName = "Cox"
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: DateOfBirth = new
  prefs: []
  type: TYPE_NORMAL
- en: (2000
  prefs: []
  type: TYPE_NORMAL
- en: ', 7'
  prefs: []
  type: TYPE_NORMAL
- en: ', 12'
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: // create object that will format a List of Persons as XML
  prefs: []
  type: TYPE_NORMAL
- en: XmlSerializer xs = new
  prefs: []
  type: TYPE_NORMAL
- en: (people.GetType());
  prefs: []
  type: TYPE_NORMAL
- en: // create a file to write to
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: path = Combine(CurrentDirectory, "people.xml"
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: (FileStream stream = File.Create(path))
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: // serialize the object graph to the stream
  prefs: []
  type: TYPE_NORMAL
- en: xs.Serialize(stream, people);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("Written {0:N0} bytes of XML to {1}"
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: 'arg0: new'
  prefs: []
  type: TYPE_NORMAL
- en: FileInfo(path).Length,
  prefs: []
  type: TYPE_NORMAL
- en: 'arg1: path);'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine();
  prefs: []
  type: TYPE_NORMAL
- en: // Display the serialized object graph
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine(File.ReadAllText(path));
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code, view the result, and note that an exception is thrown, as shown
    in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: 'Unhandled Exception: System.InvalidOperationException: Packt.Shared.Person
    cannot be serialized because it does not have a parameterless constructor.'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Person` , add a statement to define a parameterless constructor, as shown
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: Person
  prefs: []
  type: TYPE_NORMAL
- en: ()
  prefs: []
  type: TYPE_NORMAL
- en: '{ }'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: The constructor does not need to do anything, but it must exist so that the
    `XmlSerializer` can call it to instantiate new `Person` instances during the deserialization
    process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rerun the code and view the result, and note that the object graph is serialized
    as XML elements like `<FirstName>Bob</FirstName>` and that the `Salary` property
    is not included because it is not a `public` property, as shown in the following
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: Written 752 bytes of XML to
  prefs: []
  type: TYPE_NORMAL
- en: /Users/markjprice/Code/Chapter09/WorkingWithSerialization/people.xml
  prefs: []
  type: TYPE_NORMAL
- en: <?xml version="1.0"?>
  prefs: []
  type: TYPE_NORMAL
- en: <ArrayOfPerson  >
  prefs: []
  type: TYPE_NORMAL
- en: <Person>
  prefs: []
  type: TYPE_NORMAL
- en: <FirstName>Alice</FirstName>
  prefs: []
  type: TYPE_NORMAL
- en: <LastName>Smith</LastName>
  prefs: []
  type: TYPE_NORMAL
- en: <DateOfBirth>1974-03-14T00:00:00</DateOfBirth>
  prefs: []
  type: TYPE_NORMAL
- en: </Person>
  prefs: []
  type: TYPE_NORMAL
- en: <Person>
  prefs: []
  type: TYPE_NORMAL
- en: <FirstName>Bob</FirstName>
  prefs: []
  type: TYPE_NORMAL
- en: <LastName>Jones</LastName>
  prefs: []
  type: TYPE_NORMAL
- en: <DateOfBirth>1969-11-23T00:00:00</DateOfBirth>
  prefs: []
  type: TYPE_NORMAL
- en: </Person>
  prefs: []
  type: TYPE_NORMAL
- en: <Person>
  prefs: []
  type: TYPE_NORMAL
- en: <FirstName>Charlie</FirstName>
  prefs: []
  type: TYPE_NORMAL
- en: <LastName>Cox</LastName>
  prefs: []
  type: TYPE_NORMAL
- en: <DateOfBirth>1984-05-04T00:00:00</DateOfBirth>
  prefs: []
  type: TYPE_NORMAL
- en: <Children>
  prefs: []
  type: TYPE_NORMAL
- en: <Person>
  prefs: []
  type: TYPE_NORMAL
- en: <FirstName>Sally</FirstName>
  prefs: []
  type: TYPE_NORMAL
- en: <LastName>Cox</LastName>
  prefs: []
  type: TYPE_NORMAL
- en: <DateOfBirth>2000-07-12T00:00:00</DateOfBirth>
  prefs: []
  type: TYPE_NORMAL
- en: </Person>
  prefs: []
  type: TYPE_NORMAL
- en: </Children>
  prefs: []
  type: TYPE_NORMAL
- en: </Person>
  prefs: []
  type: TYPE_NORMAL
- en: </ArrayOfPerson>
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Generating compact XML
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We could make the XML more compact using attributes instead of elements for
    some fields:'
  prefs: []
  type: TYPE_NORMAL
- en: In `Person` , import the `System.Xml.Serialization` namespace so that you can
    decorate some properties with the `[XmlAttribute]` attribute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Decorate the first name, last name, and date of birth properties with the `[XmlAttribute]`
    attribute, and set a short name for each property, as shown highlighted in the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: '**[**'
  prefs: []
  type: TYPE_NORMAL
- en: '**XmlAttribute(**'
  prefs: []
  type: TYPE_NORMAL
- en: '**"fname"**'
  prefs: []
  type: TYPE_NORMAL
- en: '**)**'
  prefs: []
  type: TYPE_NORMAL
- en: '**]**'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: FirstName { get
  prefs: []
  type: TYPE_NORMAL
- en: ; set
  prefs: []
  type: TYPE_NORMAL
- en: ; }
  prefs: []
  type: TYPE_NORMAL
- en: '**[**'
  prefs: []
  type: TYPE_NORMAL
- en: '**XmlAttribute(**'
  prefs: []
  type: TYPE_NORMAL
- en: '**"lname"**'
  prefs: []
  type: TYPE_NORMAL
- en: '**)**'
  prefs: []
  type: TYPE_NORMAL
- en: '**]**'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: LastName { get
  prefs: []
  type: TYPE_NORMAL
- en: ; set
  prefs: []
  type: TYPE_NORMAL
- en: ; }
  prefs: []
  type: TYPE_NORMAL
- en: '**[**'
  prefs: []
  type: TYPE_NORMAL
- en: '**XmlAttribute(**'
  prefs: []
  type: TYPE_NORMAL
- en: '**"dob"**'
  prefs: []
  type: TYPE_NORMAL
- en: '**)**'
  prefs: []
  type: TYPE_NORMAL
- en: '**]**'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: DateTime DateOfBirth { get
  prefs: []
  type: TYPE_NORMAL
- en: ; set
  prefs: []
  type: TYPE_NORMAL
- en: ; }
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code and note that the size of the file has been reduced from 752 to
    462 bytes, a space-saving of more than a third, by outputting property values
    as XML attributes, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: Written 462 bytes of XML to /Users/markjprice/Code/Chapter09/ WorkingWithSerialization/people.xml
  prefs: []
  type: TYPE_NORMAL
- en: <?xml version="1.0"?>
  prefs: []
  type: TYPE_NORMAL
- en: <ArrayOfPerson  >
  prefs: []
  type: TYPE_NORMAL
- en: <Person fname="Alice" lname="Smith" dob="1974-03-14T00:00:00" />
  prefs: []
  type: TYPE_NORMAL
- en: <Person fname="Bob" lname="Jones" dob="1969-11-23T00:00:00" />
  prefs: []
  type: TYPE_NORMAL
- en: <Person fname="Charlie" lname="Cox" dob="1984-05-04T00:00:00">
  prefs: []
  type: TYPE_NORMAL
- en: <Children>
  prefs: []
  type: TYPE_NORMAL
- en: <Person fname="Sally" lname="Cox" dob="2000-07-12T00:00:00" />
  prefs: []
  type: TYPE_NORMAL
- en: </Children>
  prefs: []
  type: TYPE_NORMAL
- en: </Person>
  prefs: []
  type: TYPE_NORMAL
- en: </ArrayOfPerson>
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Deserializing XML files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now let''s try deserializing the XML file back into live objects in memory:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add statements to open the XML file and then deserialize it, as shown in the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: (FileStream xmlLoad = File.Open(path, FileMode.Open))
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: // deserialize and cast the object graph into a List of Person
  prefs: []
  type: TYPE_NORMAL
- en: List<Person>? loadedPeople =
  prefs: []
  type: TYPE_NORMAL
- en: xs.Deserialize(xmlLoad) as
  prefs: []
  type: TYPE_NORMAL
- en: List<Person>;
  prefs: []
  type: TYPE_NORMAL
- en: if
  prefs: []
  type: TYPE_NORMAL
- en: (loadedPeople is
  prefs: []
  type: TYPE_NORMAL
- en: not
  prefs: []
  type: TYPE_NORMAL
- en: 'null'
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: foreach
  prefs: []
  type: TYPE_NORMAL
- en: (Person p in
  prefs: []
  type: TYPE_NORMAL
- en: loadedPeople)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("{0} has {1} children."
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: p.LastName, p.Children?.Count ?? 0
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code and note that the people are loaded successfully from the XML
    file and then enumerated, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: Smith has 0 children.
  prefs: []
  type: TYPE_NORMAL
- en: Jones has 0 children.
  prefs: []
  type: TYPE_NORMAL
- en: Cox has 1 children.
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: There are many other attributes that can be used to control the XML generated.
  prefs: []
  type: TYPE_NORMAL
- en: If you don't use any annotations, `XmlSerializer` performs a case-insensitive
    match using the property name when deserializing.
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice** : When using `XmlSerializer` , remember that only the public
    fields and properties are included, and the type must have a parameterless constructor.
    You can customize the output with attributes.'
  prefs: []
  type: TYPE_NORMAL
- en: Serializing with JSON
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the most popular .NET libraries for working with the JSON serialization
    format is Newtonsoft.Json, known as Json.NET. It is mature and powerful. Let''s
    see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `WorkingWithSerialization` project, add a package reference for the
    latest version of `Newtonsoft.Json` , as shown in the following markup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: <ItemGroup>
  prefs: []
  type: TYPE_NORMAL
- en: <PackageReference Include="Newtonsoft.Json"
  prefs: []
  type: TYPE_NORMAL
- en: Version="13.0.1"
  prefs: []
  type: TYPE_NORMAL
- en: />
  prefs: []
  type: TYPE_NORMAL
- en: </ItemGroup>
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Build the `WorkingWithSerialization` project to restore packages.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Program.cs` , add statements to create a text file and then serialize the
    people into the file as JSON, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: // create a file to write to
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: jsonPath = Combine(CurrentDirectory, "people.json"
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: (StreamWriter jsonStream = File.CreateText(jsonPath))
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: // create an object that will format as JSON
  prefs: []
  type: TYPE_NORMAL
- en: Newtonsoft.Json.JsonSerializer jss = new
  prefs: []
  type: TYPE_NORMAL
- en: ();
  prefs: []
  type: TYPE_NORMAL
- en: // serialize the object graph into a string
  prefs: []
  type: TYPE_NORMAL
- en: jss.Serialize(jsonStream, people);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine();
  prefs: []
  type: TYPE_NORMAL
- en: 'WriteLine("Written {0:N0} bytes of JSON to: {1}"'
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: 'arg0: new'
  prefs: []
  type: TYPE_NORMAL
- en: FileInfo(jsonPath).Length,
  prefs: []
  type: TYPE_NORMAL
- en: 'arg1: jsonPath);'
  prefs: []
  type: TYPE_NORMAL
- en: // Display the serialized object graph
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine(File.ReadAllText(jsonPath));
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code and note that JSON requires less than half the number of bytes
    compared to XML with elements. It''s even smaller than the XML file, which uses
    attributes, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: 'Written 366 bytes of JSON to: /Users/markjprice/Code/Chapter09/ WorkingWithSerialization/people.json
    [{"FirstName":"Alice","LastName":"Smith","DateOfBirth":"1974-03-'
  prefs: []
  type: TYPE_NORMAL
- en: 14T00:00:00","Children":null},{"FirstName":"Bob","LastName":"Jones","Date
  prefs: []
  type: TYPE_NORMAL
- en: OfBirth":"1969-11-23T00:00:00","Children":null},{"FirstName":"Charlie","L astName":"Cox","DateOfBirth":"1984-05-04T00:00:00","Children":[{"FirstNam
    e":"Sally","LastName":"Cox","DateOfBirth":"2000-07-12T00:00:00","Children ":null}]}]
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: High-performance JSON processing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: .NET Core 3.0 introduced a new namespace for working with JSON, `System.Text.Json`
    , which is optimized for performance by leveraging APIs like `Span<T>` .
  prefs: []
  type: TYPE_NORMAL
- en: Also, older libraries like Json.NET are implemented by reading UTF-16\. It would
    be more performant to read and write JSON documents using UTF-8 because most network
    protocols, including HTTP, use UTF-8 and you can avoid transcoding UTF-8 to and
    from Json.NET's Unicode `string` values.
  prefs: []
  type: TYPE_NORMAL
- en: With the new API, Microsoft achieved between 1.3x and 5x improvement, depending
    on the scenario.
  prefs: []
  type: TYPE_NORMAL
- en: 'The original author of Json.NET, James Newton-King, joined Microsoft and has
    been working with them to develop their new JSON types. As he says in a comment
    discussing the new JSON APIs, "Json.NET isn''t going away," as shown in *Figure
    9.3* :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application, email Description automatically
    generated](img/Image00088.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.3: A comment by the original author of Json.NET'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how to use the new JSON APIs to deserialize a JSON file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `WorkingWithSerialization` project, in `Program.cs` , import the new
    JSON class for performing serialization using an alias to avoid conflicting names
    with the Json.NET one we used before, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: NewJson = System.Text.Json.JsonSerializer;
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add statements to open the JSON file, deserialize it, and output the names
    and counts of the children of the people, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: (FileStream jsonLoad = File.Open(jsonPath, FileMode.Open))
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: // deserialize object graph into a List of Person
  prefs: []
  type: TYPE_NORMAL
- en: List<Person>? loadedPeople =
  prefs: []
  type: TYPE_NORMAL
- en: await
  prefs: []
  type: TYPE_NORMAL
- en: 'NewJson.DeserializeAsync(utf8Json: jsonLoad,'
  prefs: []
  type: TYPE_NORMAL
- en: 'returnType: typeof'
  prefs: []
  type: TYPE_NORMAL
- en: (List<Person>)) as
  prefs: []
  type: TYPE_NORMAL
- en: List<Person>;
  prefs: []
  type: TYPE_NORMAL
- en: if
  prefs: []
  type: TYPE_NORMAL
- en: (loadedPeople is
  prefs: []
  type: TYPE_NORMAL
- en: not
  prefs: []
  type: TYPE_NORMAL
- en: 'null'
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: foreach
  prefs: []
  type: TYPE_NORMAL
- en: (Person p in
  prefs: []
  type: TYPE_NORMAL
- en: loadedPeople)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("{0} has {1} children."
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: p.LastName, p.Children?.Count ?? 0
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: Smith has 0 children.
  prefs: []
  type: TYPE_NORMAL
- en: Jones has 0 children.
  prefs: []
  type: TYPE_NORMAL
- en: Cox has 1 children.
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice** : Choose Json.NET for developer productivity and a large
    feature set or `System.Text.Json` for performance.'
  prefs: []
  type: TYPE_NORMAL
- en: Controlling JSON processing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are many options for taking control of how JSON is processed, as shown
    in the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: Including and excluding fields.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting a casing policy.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selecting a case-sensitivity policy.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choosing between compact and prettified whitespace.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s see some in action:'
  prefs: []
  type: TYPE_NORMAL
- en: Use your preferred code editor to add a new console app named `WorkingWithJson`
    to the `Chapter09` solution/workspace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Visual Studio Code, select `WorkingWithJson` as the active OmniSharp project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `WorkingWithJson` project, in `Program.cs` , delete the existing code,
    import the two main namespaces for working with JSON, and then statically import
    the `System.Console` , `System.Environment` , and `System.IO.Path` types, as shown
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: System.Text.Json; // JsonSerializer
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: System.Text.Json.Serialization; // [JsonInclude]
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: static
  prefs: []
  type: TYPE_NORMAL
- en: System.Console;
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: static
  prefs: []
  type: TYPE_NORMAL
- en: System.Environment;
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: static
  prefs: []
  type: TYPE_NORMAL
- en: System.IO.Path;
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the bottom of `Program.cs` , define a class named `Book` , as shown in the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: class
  prefs: []
  type: TYPE_NORMAL
- en: Book
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: // constructor to set non-nullable property
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: Book
  prefs: []
  type: TYPE_NORMAL
- en: (
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: title
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: Title = title;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: // properties
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: Title { get
  prefs: []
  type: TYPE_NORMAL
- en: ; set
  prefs: []
  type: TYPE_NORMAL
- en: ; }
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: '? Author { get'
  prefs: []
  type: TYPE_NORMAL
- en: ; set
  prefs: []
  type: TYPE_NORMAL
- en: ; }
  prefs: []
  type: TYPE_NORMAL
- en: // fields
  prefs: []
  type: TYPE_NORMAL
- en: '[JsonInclude'
  prefs: []
  type: TYPE_NORMAL
- en: '] // include this field'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: DateOnly PublishDate;
  prefs: []
  type: TYPE_NORMAL
- en: '[JsonInclude'
  prefs: []
  type: TYPE_NORMAL
- en: '] // include this field'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: DateTimeOffset Created;
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: ushort
  prefs: []
  type: TYPE_NORMAL
- en: Pages;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Above the `Book` class, add statements to create an instance of the `Book`
    class and serialize it to JSON, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: Book csharp10 = new
  prefs: []
  type: TYPE_NORMAL
- en: '(title:'
  prefs: []
  type: TYPE_NORMAL
- en: '"C# 10 and .NET 6 - Modern Cross-platform Development"'
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: Author = "Mark J Price"
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: PublishDate = new
  prefs: []
  type: TYPE_NORMAL
- en: '(year: 2021'
  prefs: []
  type: TYPE_NORMAL
- en: ', month: 11'
  prefs: []
  type: TYPE_NORMAL
- en: ', day: 9'
  prefs: []
  type: TYPE_NORMAL
- en: ),
  prefs: []
  type: TYPE_NORMAL
- en: Pages = 823
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: Created = DateTimeOffset.UtcNow,
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: JsonSerializerOptions options = new
  prefs: []
  type: TYPE_NORMAL
- en: ()
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: IncludeFields = true
  prefs: []
  type: TYPE_NORMAL
- en: ', // includes all fields'
  prefs: []
  type: TYPE_NORMAL
- en: PropertyNameCaseInsensitive = true
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: WriteIndented = true
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: filePath = Combine(CurrentDirectory, "book.json"
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: (Stream fileStream = File.Create(filePath))
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: JsonSerializer.Serialize<Book>(
  prefs: []
  type: TYPE_NORMAL
- en: 'utf8Json: fileStream, value'
  prefs: []
  type: TYPE_NORMAL
- en: ': csharp10, options);'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("Written {0:N0} bytes of JSON to {1}"
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: 'arg0: new'
  prefs: []
  type: TYPE_NORMAL
- en: FileInfo(filePath).Length,
  prefs: []
  type: TYPE_NORMAL
- en: 'arg1: filePath);'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine();
  prefs: []
  type: TYPE_NORMAL
- en: // Display the serialized object graph
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine(File.ReadAllText(filePath));
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: Written 315 bytes of JSON to C:\Code\Chapter09\WorkingWithJson\bin\Debug\net6.0\book.json
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: '"title": "C# 10 and .NET 6 - Modern Cross-platform Development",'
  prefs: []
  type: TYPE_NORMAL
- en: '"author": "Mark J Price",'
  prefs: []
  type: TYPE_NORMAL
- en: '"publishDate": {'
  prefs: []
  type: TYPE_NORMAL
- en: '"year": 2021,'
  prefs: []
  type: TYPE_NORMAL
- en: '"month": 11,'
  prefs: []
  type: TYPE_NORMAL
- en: '"day": 9,'
  prefs: []
  type: TYPE_NORMAL
- en: '"dayOfWeek": 2,'
  prefs: []
  type: TYPE_NORMAL
- en: '"dayOfYear": 313,'
  prefs: []
  type: TYPE_NORMAL
- en: '"dayNumber": 738102'
  prefs: []
  type: TYPE_NORMAL
- en: '},'
  prefs: []
  type: TYPE_NORMAL
- en: '"created": "2021-08-20T08:07:02.3191648+00:00",'
  prefs: []
  type: TYPE_NORMAL
- en: '"pages": 823'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The JSON file is 315 bytes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The member names use camelCasing, for example, `publishDate` . This is best
    for subsequent processing in a browser with JavaScript.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All fields are included due to the options set, including `pages` .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JSON is prettified for easier human legibility.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DateTimeOffset` values are stored as a single standard string format.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DateOnly` values are stored as an object with sub-properties for date parts
    like `year` and `month` .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In `Program.cs` , when setting the `JsonSerializerOptions` , comment out the
    setting of casing policy, write indented, and include fields.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: Written 230 bytes of JSON to C:\Code\Chapter09\WorkingWithJson\bin\Debug\net6.0\book.json
  prefs: []
  type: TYPE_NORMAL
- en: '{"Title":"C# 10 and .NET 6 - Modern Cross-platform Development","Author":"Mark
    J Price","PublishDate":{"Year":2021,"Month":11,"Day":9,"DayOfWeek":2,"DayOfYear":313,"DayNumber":738102},"Created":"2021-08-20T08:12:31.6852484+00:00"}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The JSON file is 230 bytes, a more than 25% reduction.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The member names use normal casing, for example, `PublishDate` .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Pages` field is missing. The other fields are included due to the `[JsonInclude]`
    attribute on `PublishDate` and `Created` field.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JSON is compact with minimal whitespace to save bandwidth for transmission or
    storage.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New JSON extension methods for working with HTTP responses
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In .NET 5, Microsoft added refinements to the types in the `System.Text.Json`
    namespace like extension methods for `HttpResponse` , which you will see in *Chapter
    16* , *Building and Consuming Web Services* .
  prefs: []
  type: TYPE_NORMAL
- en: Migrating from Newtonsoft to new JSON
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you have existing code that uses the Newtonsoft Json.NET library and you
    want to migrate to the new `System.Text.Json` namespace, then Microsoft has specific
    documentation for that, which you will find at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/dotnet/standard/serialization/system-text-json-migrate-from-newtonsoft-how-to](https://docs.microsoft.com/en-us/dotnet/standard/serialization/system-text-json-migrate-from-newtonsoft-how-to)'
  prefs: []
  type: TYPE_NORMAL
- en: Practicing and exploring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Test your knowledge and understanding by answering some questions, get some
    hands-on practice, and explore this chapter's topics with more in-depth research.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 9.1 â Test your knowledge
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Answer the following questions:'
  prefs: []
  type: TYPE_NORMAL
- en: What is the difference between using the `File` class and the `FileInfo` class?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between the `ReadByte` method and the `Read` method of
    a stream?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When would you use the `StringReader` , `TextReader` , and `StreamReader` classes?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does the `DeflateStream` type do?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How many bytes per character does UTF-8 encoding use?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is an object graph?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the best serialization format to choose for minimizing space requirements?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the best serialization format to choose for cross-platform compatibility?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is it bad to use a `string` value like `"\Code\Chapter01"` to represent
    a path, and what should you do instead?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Where can you find information about NuGet packages and their dependencies?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Exercise 9.2 â Practice serializing as XML
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the `Chapter09` solution/workspace, create a console application named `Exercise02`
    that creates a list of shapes, uses serialization to save it to the filesystem
    using XML, and then deserializes it back:'
  prefs: []
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: // create a list of Shapes to serialize
  prefs: []
  type: TYPE_NORMAL
- en: List<Shape> listOfShapes = new
  prefs: []
  type: TYPE_NORMAL
- en: ()
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: new
  prefs: []
  type: TYPE_NORMAL
- en: Circle { Colour = "Red"
  prefs: []
  type: TYPE_NORMAL
- en: ', Radius = 2.5'
  prefs: []
  type: TYPE_NORMAL
- en: '},'
  prefs: []
  type: TYPE_NORMAL
- en: new
  prefs: []
  type: TYPE_NORMAL
- en: Rectangle { Colour = "Blue"
  prefs: []
  type: TYPE_NORMAL
- en: ', Height = 20.0'
  prefs: []
  type: TYPE_NORMAL
- en: ', Width = 10.0'
  prefs: []
  type: TYPE_NORMAL
- en: '},'
  prefs: []
  type: TYPE_NORMAL
- en: new
  prefs: []
  type: TYPE_NORMAL
- en: Circle { Colour = "Green"
  prefs: []
  type: TYPE_NORMAL
- en: ', Radius = 8.0'
  prefs: []
  type: TYPE_NORMAL
- en: '},'
  prefs: []
  type: TYPE_NORMAL
- en: new
  prefs: []
  type: TYPE_NORMAL
- en: Circle { Colour = "Purple"
  prefs: []
  type: TYPE_NORMAL
- en: ', Radius = 12.3'
  prefs: []
  type: TYPE_NORMAL
- en: '},'
  prefs: []
  type: TYPE_NORMAL
- en: new
  prefs: []
  type: TYPE_NORMAL
- en: Rectangle { Colour = "Blue"
  prefs: []
  type: TYPE_NORMAL
- en: ', Height = 45.0'
  prefs: []
  type: TYPE_NORMAL
- en: ', Width = 18.0'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Shapes should have a read-only property named `Area` so that when you deserialize,
    you can output a list of shapes, including their areas, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: List<Shape> loadedShapesXml =
  prefs: []
  type: TYPE_NORMAL
- en: serializerXml.Deserialize(fileXml) as
  prefs: []
  type: TYPE_NORMAL
- en: List<Shape>;
  prefs: []
  type: TYPE_NORMAL
- en: foreach
  prefs: []
  type: TYPE_NORMAL
- en: (Shape item in
  prefs: []
  type: TYPE_NORMAL
- en: loadedShapesXml)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("{0} is {1} and has an area of {2:N2}"
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: item.GetType().Name, item.Colour, item.Area);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what your output should look like when you run your console application:'
  prefs: []
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: 'Loading shapes from XML:'
  prefs: []
  type: TYPE_NORMAL
- en: Circle is Red and has an area of 19.63
  prefs: []
  type: TYPE_NORMAL
- en: Rectangle is Blue and has an area of 200.00
  prefs: []
  type: TYPE_NORMAL
- en: Circle is Green and has an area of 201.06
  prefs: []
  type: TYPE_NORMAL
- en: Circle is Purple and has an area of 475.29
  prefs: []
  type: TYPE_NORMAL
- en: Rectangle is Blue and has an area of 810.00
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 9.3 â Explore topics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the links on the following page to learn more detail about the topics covered
    in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/markjprice/cs10dotnet6/blob/main/book-links.md#chapter-9---working-with-files-streams-and-serialization](https://github.com/markjprice/cs10dotnet6/blob/main/book-links.md#chapter-9---working-with-files-streams-and-serialization)'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to read from and write to text files and XML
    files, how to compress and decompress files, how to encode and decode text, and
    how to serialize an object into JSON and XML (and deserialize it back again).
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn how to work with databases using Entity
    Framework Core.
  prefs: []
  type: TYPE_NORMAL
