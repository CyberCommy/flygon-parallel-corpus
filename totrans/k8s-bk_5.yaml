- en: '5: Kubernetes Deployments'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we’ll see how *Deployments* bring self-healing, scalability,
    rolling updates, and rollbacks to Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll split the chapter up as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Deployment theory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create a Deployment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to perform a rolling update
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to perform a rollback
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deployment theory
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At a high level, we start with application code. That gets packaged as a container
    and wrapped in a Pod so it can run on Kubernetes. However, Pods don’t self-heal,
    they don’t scale, and they don’t allow for easy updates.
  prefs: []
  type: TYPE_NORMAL
- en: Deployments do all of those things - *self-heal, scale, and rolling updates*
    . As a result, we almost always deploy Pods via Deployments. See Figure 5.1.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1](Image00030.gif)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.1
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to know that a Deployment only manages a set of identical Pods.
    For example, if you have an application with a Pod for the front-end and another
    Pod for the back-end, you’ll need two Deployments.
  prefs: []
  type: TYPE_NORMAL
- en: The next thing to know, is that Deployments are fully-fledged objects in the
    Kubernetes API. This means we define them in manifest files that we `POST` to
    the API server.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing to note, is that behind-the-scenes, Deployments leverage another
    object called a ReplicaSet. We don’t directly manage ReplicaSets, but it’s important
    to understand them as it will help explain the mechanics of some of the operations
    we’re about to describe.
  prefs: []
  type: TYPE_NORMAL
- en: Keeping it high-level, Deployments use ReplicaSets to provide the self-healing
    and scalability bits. See Figure 5.2.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2](Image00031.gif)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.2
  prefs: []
  type: TYPE_NORMAL
- en: In summary; *Deployments* manage *ReplicaSets* , and *ReplicaSets* manage *Pods*
    . Put them all together, and we’ve got a great way to deploy and manage applications
    on Kubernetes!
  prefs: []
  type: TYPE_NORMAL
- en: Self-healing and scalability
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Pods are great. They augment containers by allowing co-location of containers,
    sharing of volumes, sharing of memory, simplified networking, and a lot more.
    But they offer nothing in the way of self-healing and scalability.
  prefs: []
  type: TYPE_NORMAL
- en: Enter Deployments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Deployments augment Pods by adding things like self-healing and scalability.
    This means:'
  prefs: []
  type: TYPE_NORMAL
- en: If a Pod being managed by a Deployment fails, it will be replaced - *self-healing*
    .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a Pod being managed by a Deployment sees increased load, you can easily add
    more of the same Pod to deal with the load - *scaling* .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, behind-the-scenes, Deployments use an object called a ReplicaSet to
    bring self-healing and scalability. However, ReplicaSets operate in the background
    and we always manage them via Deployments. For this reason, we’ll focus mainly
    on the Deployment side of things.
  prefs: []
  type: TYPE_NORMAL
- en: It’s all about the *state*
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Before going any further, it’s critical to understand three concepts that are
    fundamental to everything about Kubernetes:'
  prefs: []
  type: TYPE_NORMAL
- en: Desired state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Current state (sometimes called *actual state* or *observed state* )
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Declarative model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Desired state* is what you **want** . *Current state* is what you **have**
    . If the two match, everybody’s happy.'
  prefs: []
  type: TYPE_NORMAL
- en: A *declarative model* is a way of telling Kubernetes what our *desired state*
    is, without getting into the detail of *how* to implement it.
  prefs: []
  type: TYPE_NORMAL
- en: The declarative model
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: There are two competing models. The *declarative model* and the *imperative
    model* .
  prefs: []
  type: TYPE_NORMAL
- en: Declarative models are all about describing the end-goal - telling Kubernetes
    what you want. Imperative models are all about lists of commands to achieve an
    end-goal - telling Kubernetes **how** to do something.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: Assume you’ve got an application with two services - front-end and back-end.
    You’ve configured things so that you have a Pod for the front-end service, and
    a separate Pod for the back-end service. To meet expected demand, you always need
    5 instances of the front-end Pod, and 2 instances of the back-end Pod.
  prefs: []
  type: TYPE_NORMAL
- en: Taking the declarative approach, you create a configuration file that tells
    Kubernetes what your front-end and back-end Pods should look like - things like
    what images to use and what ports to expose. In the same file you also tell Kubernetes
    that you want 5 replicas of the front-end Pods and 2 of the back-end Pods. That’s
    your *desired state* . You then give that file to Kubernetes and sit back while
    Kubernetes does the hard work of implementing it. But it doesn’t stop there… Kubernetes
    implements watch loops that are constantly checking that what is on the cluster
    matches what you’ve asked for (does current state match desired state).
  prefs: []
  type: TYPE_NORMAL
- en: It’s great!
  prefs: []
  type: TYPE_NORMAL
- en: The opposite of the declarative model is the imperative model. In the imperative
    model, there’s no concept of desired state. Instead, you write a bunch of scripts
    with the all the commands required to build what you want. And you have to care
    about implementation details. For example, the commands to start `containerd`
    containers are different from the commands to start `rkt` containers. This ends
    up being more work, prone to more errors, and because it’s not declaring a desired
    state, there’s no self-healing.
  prefs: []
  type: TYPE_NORMAL
- en: It’s not so great :-(
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes supports both models, but strongly prefers the declarative model.
  prefs: []
  type: TYPE_NORMAL
- en: Reconciliation loops
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Fundamental to desired state is the concept of background reconciliation loops.
  prefs: []
  type: TYPE_NORMAL
- en: For example, ReplicaSets implement a background reconciliation loop that is
    constantly checking whether the right number of Pod replicas are present on the
    cluster. If there aren’t enough, it adds more. If there are too many, it terminates
    some.
  prefs: []
  type: TYPE_NORMAL
- en: To be crystal clear - **Kubernetes is constantly checking whether *current state*
    matches *desired state!***
  prefs: []
  type: TYPE_NORMAL
- en: If they don’t match - may be desired state is 10 replicas, but only 8 are running
    - Kubernetes switches to red-alert, orders the control plane to battle-stations,
    and brings up two more replicas. And the best part… it does all of this without
    calling you at 4:20 in the morning!
  prefs: []
  type: TYPE_NORMAL
- en: But it’s not just failure scenarios. These very-same reconciliation loops enable
    scaling!
  prefs: []
  type: TYPE_NORMAL
- en: For example, if you `POST` an update to your application config that takes replica
    count from 3 to 5\. The new value of 5 will be registered as the application’s
    new *desired state* , and the next time the reconciliation loop runs, it will
    notice the discrepancy and follow the same process - sounding the claxon horn
    for red alert, and spinning up two more replicas.
  prefs: []
  type: TYPE_NORMAL
- en: It’s a beautiful thing!
  prefs: []
  type: TYPE_NORMAL
- en: Rolling updates with Deployments
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As well as self-healing and scaling, Deployments also give us zero-downtime
    rolling-updates.
  prefs: []
  type: TYPE_NORMAL
- en: As previously mentioned. Deployments use ReplicaSets for some of the background
    legwork. In fact, every time we create a Deployment, we automatically get a ReplicaSet
    that manages the Deployment’s Pods.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note:** You should not directly manage ReplicaSets that are created as part
    of a Deployment. You should perform all actions against the Deployment object
    and leave the Deployment to manage its own ReplicaSets.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'It works like this. We design our application with each discrete service as
    a Pod. For convenience - self-healing, scaling, rolling updates and more - we
    wrap Pods in a Deployment. This means creating a YAML configuration file describing
    all of the folllowing:'
  prefs: []
  type: TYPE_NORMAL
- en: How many Pod replicas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What image to use for the Pod’s container(s)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What network ports to use
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Details about how to perform rolling updates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You `POST` that YAML file to the API server, and Kubernetes does all of the
    hard work to implement it.
  prefs: []
  type: TYPE_NORMAL
- en: Once it’s implemented, Kubernetes sets up a watch loop to make sure observed
    state matches desired state.
  prefs: []
  type: TYPE_NORMAL
- en: All good so far.
  prefs: []
  type: TYPE_NORMAL
- en: Now, assume you want to update the version of the image the Pods are using.
    To do that, you update the **same Deployment YAML file** with the new image version,
    and re-POST it to the API server. This registers a new desired state on the cluster
    requesting the same number of Pods, but all running the new version of the image.
    To achieve this, Kubernetes creates a new ReplicaSet for the Pods with the new
    image. We now have two ReplicaSets - one for the Pods with the old version of
    the image, and another for Pods with the new version. As Kubernetes increases
    the number of Pods in the new ReplicaSet (with the new version of the image) it
    decreases the number of Pods in the old ReplicaSet (with the old version of the
    image). Net result, we get a smooth rolling update with zero downtime. And we
    can rinse and repeat the process for future updates - just keep updating that
    manifest file (which should be stored in a version control system).
  prefs: []
  type: TYPE_NORMAL
- en: Brilliant!
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.3 shows a Deployment that has been updated once. The initial deployment
    created the ReplicaSet on the left, and the update created the ReplicaSet on the
    right. We can see that the ReplicaSet for the initial deployment has been wound
    down and no longer has any Pods. The ReplicaSet associated with the update is
    active and owns all of the Pods.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3](Image00032.gif)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.3
  prefs: []
  type: TYPE_NORMAL
- en: Rollbacks
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As we’ve seen in Figure 5.3, old ReplicaSets stick around and don’t get deleted.
    They’ve been wound down, so aren’t managing any Pods, but they still exist. This
    makes them a great option for reverting back to previous versions.
  prefs: []
  type: TYPE_NORMAL
- en: The process of rolling back is essentially the opposite of a rolling update
    - wind one of the old ReplicaSets up, and wind the current one down. Simple!
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.4 shows the same app rolled back to the initial revision.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.4](Image00033.gif)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.4
  prefs: []
  type: TYPE_NORMAL
- en: That’s not the end though! There’s built-in intelligence that lets us say things
    like *“wait X number of seconds after each Pod comes up before we mark it as healthy…“*
    . There’s also readiness probes and all kinds of things. All-in-all, Deployments
    are excellent for performing rolling updates and versioned rollbacks.
  prefs: []
  type: TYPE_NORMAL
- en: With all that in mind, let’s get our hands dirty and create a Deployment.
  prefs: []
  type: TYPE_NORMAL
- en: How to create a Deployment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, we’ll create a brand-new Kubernetes Deployment from a YAML
    file. We can do the same thing imperatively using the `kubectl run` command, but
    we shouldn’t! The right way is the declarative way!
  prefs: []
  type: TYPE_NORMAL
- en: The following code snippet is the Deployment manifest file that we’ll use, and
    the examples assume it’s called `deploy.yml` .
  prefs: []
  type: TYPE_NORMAL
- en: If you’re using an older version of Kubernetes you should use the `apps/v1beta1`
    API.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '**Warning:** The images used in this book are not maintained and will be full
    of vulnerabilities and other security issues.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Let’s step through the file and explain some of the important parts.
  prefs: []
  type: TYPE_NORMAL
- en: Right at the very top, we’re specifying the API version to use. Assuming that
    you’re using an up-to-date version of Kubernetes, Deployment objects are in the
    `apps/v1` API group. If you’re using an older version, you can try `apps/v1beta1`
    or `extensions/v1beta2` .
  prefs: []
  type: TYPE_NORMAL
- en: Next, the `.kind` field tells Kubernetes we’re defining a Deployment - this
    is how Kubernetes knows to send this to the Deployments controller on the control
    plane.
  prefs: []
  type: TYPE_NORMAL
- en: The `.metadata` section is where we give the Deployment a name and labels.
  prefs: []
  type: TYPE_NORMAL
- en: The `.spec` section is where most of the action happens. `.spec.replicas` tells
    Kubernetes how may Pod replicas for this Deployment. `spec.selector` is a list
    of labels that Pods must have in order for the Deployment to manage them. And
    `.spec.strategy` tells Kubernetes how to perform updates to the Deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Use `kubectl apply` to implement it on the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note:** `kubectl apply` POSTs the YAML file to the Kubernetes API server.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The Deployment is instantiated on the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Inspecting Deployments
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We can use the usual `kubectl get` and `kubectl describe` commands to see details
    of the Deployment.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The command outputs have been trimmed for readability. Your outputs will show
    more information.
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned earlier, Deployments automatically create associated ReplicaSets.
    Use the following `kubectl` command to confirm this.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Right now, we only have one ReplicaSet. This is because we’ve only performed
    the initial rollout of the Deployment. However, we can see it gets the same name
    as the Deployment, with a hash of the Pod template section of the YAML manifest
    file appended to the end.
  prefs: []
  type: TYPE_NORMAL
- en: We can get more detailed information about the ReplicaSet with the usual `kubectl
    describe` command.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing the app
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In order to access the application from a stable name or IP address, or even
    from outside the cluster, we need a Kubernetes Service object (more on these in
    the next chapter). For now, all you need to know is that Kubernetes Services provide
    a stable DNS name and IP address for a set of Pods.
  prefs: []
  type: TYPE_NORMAL
- en: The following YAML defines a Service that will work with the Pods previously
    deployed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Deploy it with the following command (the command assumes the manifest file
    is called `svc.yml` ).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that the Service is deployed, you can access it via either of the following
    ways:'
  prefs: []
  type: TYPE_NORMAL
- en: From inside the cluster using the DNS name `hello-svc` on port `8080` .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From outside the cluster by hitting any of the cluster nodes on port `30001`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 5.5 shows the Service being accessed from outside of the cluster via
    a node called `node1` on port `30001` . It assumes that `node1` is resolvable,
    and that port `30001` is allowed by any intervening firewalls.
  prefs: []
  type: TYPE_NORMAL
- en: If you are using Minikube, you should append port `30001` to the end of the
    Minikube IP address. Use the `minikube ip` command to get the IP address of your
    Minikube.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.5](Image00034.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.5
  prefs: []
  type: TYPE_NORMAL
- en: Performing a rolling update
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, we’ll see how to perform a rolling update on the app we’ve
    just deployed. We’ll assume the new version of the app has already been created
    and containerized as a Docker image with the `edge` tag. All that is left to do
    is use Kubernetes to push the update to production. For this example, we’ll be
    ignoring real-world CI/CD workflows and version control tools.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we need to do is update the image tag used in the Deployment’s
    manifest file. The initial version of the app that we deployed used an image tagged
    as `nigelpoulton/k8sbook:latest` . We’ll update the `.spec.template.spec.containers`
    section of the Deployment manifest to reference the new `nigelpoulton/k8sbook:edge`
    image. This will ensure that next time the manifest is POSTed to the API server,
    all Pods in the Deployment will be updated to run the new `edge` image.
  prefs: []
  type: TYPE_NORMAL
- en: The following is the updated `deploy.yml` manifest file - the only change is
    to `.spec.template.spec.containers.image` indicated by the commented line.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '**Warning:** The images used in this book are not maintained and will be full
    of vulnerabilities and other security issues.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Let’s take a look at the settings governing how the Deployment is updated.
  prefs: []
  type: TYPE_NORMAL
- en: The `.spec` section of the manifest contains all of the settings relating to
    how updates will be performed. The first value of interest is `.spec.minReadySeconds`
    . We’ve got this set to `10` , telling Kubernetes to wait for 10 seconds after
    updating each Pod before moving on and updating the next. This is useful for throttling
    the rate at which updates occur - longer waits give us a chance to spot problems
    and avoid situations where we update all Pods to faulty Pods.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also have a nested `.spec.strategy` map that tells Kubernetes we want this
    Deployment to:'
  prefs: []
  type: TYPE_NORMAL
- en: Update using the `RollingUpdate` strategy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Never go more than one Pod below desired state (`maxUnavailable: 1` )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Never go more than one Pod above desired state (`maxSurge: 1` )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As the desired state of the app demands 10 replicas, `maxSurge: 1` means we
    will never have more than 11 Pods during the update process, and `maxUnavailable:
    1` means we’ll never have less than 9.'
  prefs: []
  type: TYPE_NORMAL
- en: With the updated manifest ready, we can initiate the update by re-POSTing the
    updated YAML file to the API server.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The update may take some time to complete. This is because it will iterate one
    Pod at a time, pull down the new image on each node, start the new Pod, and wait
    10 seconds before moving on to the next Pod.
  prefs: []
  type: TYPE_NORMAL
- en: We can monitor the progress of the update with `kubectl rollout status` .
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: If you press `Ctrl+C` to stop watching the progress of the update, you can run
    `kubectl get deploy` commands while the update is in process. This lets us see
    the effect of some of the update-related settings in the manifest. For example,
    the following command shows that 5 of the replicas have been updated and we currently
    have 11\. 11 is 1 more than the desired state of 10\. This is a result of the
    `maxSurge=1` value in the manifest.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Once the update is complete, we can verify with `kubectl get deploy` .
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The output shows the update as complete - 10 Pods are up to date. You can get
    more detailed information about the state of the Deployment with the `kubectl
    describe deploy` command - this will include the new version of the image in the
    `Pod Template` section of the output.
  prefs: []
  type: TYPE_NORMAL
- en: If you’ve been following along with the examples you’ll be able to hit `refresh`
    in your browser and see the updated app (Figure 5.6).
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.6](Image00035.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.6
  prefs: []
  type: TYPE_NORMAL
- en: The old version of the apps displayed “Kubernetes Rocks!”, the new version displays
    “The Kubernetes Book!!!”.
  prefs: []
  type: TYPE_NORMAL
- en: How to perform a rollback
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A moment ago, we used `kubectl apply` to perform the rolling update on a Deployment.
    We used the `--record` flag so that Kubernetes would maintain a revision history
    of the Deployment. The following `kubectl rollout history` command shows the Deployment
    with two revisions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Revision `1` was the initial deployment that used the `latest` image tag. Revision
    `2` is the rolling update that we just performed, and we can see that the command
    we used to invoke the update has been recorded in the object’s history. This is
    only there because we used the `--record` flag as part of the command to invoke
    the update. This might be a good reason for you to use the `--record` flag.
  prefs: []
  type: TYPE_NORMAL
- en: Earlier in the chapter we said that updating a Deployment creates a new ReplicaSet,
    and that previous ReplicaSets are not deleted. We can verify this with a `kubectl
    get rs` .
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The output shows that the ReplicaSet for the initial revision still exists (`hello-deploy-7bbd...`
    ) but that it has been wound down and is not managing any replicas. The `hello-deploy-6bc8...`
    ReplicaSet is the one from the latest revision, and is active with 10 replicas
    under management. However, the fact that the previous version still exists makes
    rollbacks extremely simple.
  prefs: []
  type: TYPE_NORMAL
- en: It’s worth running a `kubectl describe rs` against the old ReplicaSet to prove
    that its configuration still exists.
  prefs: []
  type: TYPE_NORMAL
- en: The following example uses the `kubectl rollout` command to roll the application
    back to revision 1\. This is an imperative operation and not recommended. However,
    it can be convenient for quick rollbacks, just remember to update your source
    YAML files to reflect the imperative changes you’ve made to the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Although it might look like the rollback operation is instantaneous, it’s not.
    Rollbacks follow the same rules set out in the Deployment manifest - `minReadySeconds:
    10` , `maxUnavailable: 1` , and `maxSurge: 1` . You can verify this and track
    the progress with the following `kubectl get deploy` and `kubectl rollout` commands.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Congratulations. You’ve performed a rolling update and a successful rollback.
  prefs: []
  type: TYPE_NORMAL
- en: Use `kubectl delete -f deploy.yml` to delete the Deployment used in the examples.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we learned that *Deployments* are a great way to manage Kubernetes
    apps. They build on top of Pods by adding self-healing, scalability, rolling updates,
    and rollbacks. Behind-the-scenes, they leverage ReplicaSets for the self-healing
    and scalability parts.
  prefs: []
  type: TYPE_NORMAL
- en: Like Pods, Deployments are objects in the Kubernetes API and we should work
    with them declaratively.
  prefs: []
  type: TYPE_NORMAL
- en: When we perform updates with the `kubectl apply` command, older versions of
    ReplicaSets get wound down, but they stick around making it easy to perform rollbacks.
  prefs: []
  type: TYPE_NORMAL
