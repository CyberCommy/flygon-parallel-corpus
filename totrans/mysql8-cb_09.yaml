- en: Replication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up replication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up master-master replication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up multi-source replication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up replication filters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Switching a slave from master-slave to chain replication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Switching a slave from chain replication to master-slave
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up delayed replication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up GTID replication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up semi-synchronous replication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As explained in [Chapter 6](part0223.html#6KLDE0-faa69fe6f4c04957afca3568dcd9cd83), *Binary
    Logging*, replication enables data from one MySQL database server (the master)
    to be copied to one or more MySQL database servers (the slaves). Replication is
    asynchronous by default; slaves do not need to be permanently  connected  to receive
    updates from the master. You can configure to replicate all databases, selected
    databases, or even selected tables within a database.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn how to set up traditional replication; replicate
    selected databases and tables; and set up multi-source replication, chain replication,
    delayed replication, and semi-synchronous replication.
  prefs: []
  type: TYPE_NORMAL
- en: 'On a high level, replication works like this: all DDL and DML statements executed
    on a server (**master**) are logged into binary logs, which are pulled by the
    servers connecting to it (called **slaves**). The binary logs are simply copied
    to the slaves and are saved as relay logs. This process is taken care of by a
    thread called **IO thread**. There is one more thread called **SQL thread**, that
    executes the statements in the relay log sequentially.'
  prefs: []
  type: TYPE_NORMAL
- en: 'How replication works is very clearly explained in this blog:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.percona.com/blog/2013/01/09/how-does-mysql-replication-really-work/](https://www.percona.com/blog/2013/01/09/how-does-mysql-replication-really-work/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The advantages of replication are (taken from the manual, at [https://dev.mysql.com/doc/refman/8.0/en/replication.html](https://dev.mysql.com/doc/refman/8.0/en/replication.html)):'
  prefs: []
  type: TYPE_NORMAL
- en: '**Scale-out solutions**: Spreading the load among multiple slaves to improve
    performance. In this environment, all writes and updates must take place on the
    master server. Reads, however, may take place on one or more slaves. This model
    can improve the performance of writes (since the master is dedicated to updates),
    while dramatically increasing read speed across an increasing number of slaves.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data security**: Because data is replicated to the slave and the slave can
    pause the replication process, it is possible to run backup services on the slave
    without corrupting the corresponding master data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Analytics**: Live data can be created on the master, while the analysis of
    the information can take place on the slave without affecting the performance
    of the master.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Long-distance data distribution**: You can use replication to create a local
    copy of data for a remote site to use without permanent access to the master.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up replication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many replication topologies. Some of them are the traditional master-slave
    replication, chain replication, master-master replication, multi-source replication,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: '**Traditional replication** involves a single master and multiple slaves.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00005.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '**Chain replication** means one server replicates from another, which in turn
    replicates from another. The middle server is referred to as the relay master
    (master ---> relay master ---> slave).'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00006.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This is mainly used when you want to set up replication between two data centers.
    The primary master and its slaves will be in one data center. The secondary master
    (relay) replicates from the primary master in the other data center. All the slaves
    of the other data center are replicated from the secondary master.
  prefs: []
  type: TYPE_NORMAL
- en: '**Master-master replication**: In this topology, both the masters accept writes
    and replicate between each other.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00007.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '**Multi-source replication**: In this topology, a slave will replicate from
    multiple masters instead of one.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00008.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: If you want to set up chain replication, you can follow the same steps mentioned
    here, replacing the master with the relay master.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, setting up of single slave is explained. The same principles
    can be applied to set up chain replication. Usually the backups are taken from
    the slave when setting up another slave.
  prefs: []
  type: TYPE_NORMAL
- en: 'Outline:'
  prefs: []
  type: TYPE_NORMAL
- en: Enable binary logging on the master
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a replication user on the master
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the unique `server_id` on the slave
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Take backup from the master
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Restore the backup on the slave
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Execute the `CHANGE MASTER TO` command
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start the replication
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '**On master**: Enable binary logging on the master and set `SERVER_ID`. Refer
    to [Chapter 6](part0223.html#6KLDE0-faa69fe6f4c04957afca3568dcd9cd83), *Binary
    Logging*, to learn how to enable binary logging.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**On master**: Create a replication user. The slave connects to the master
    using this account:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '**On slave**: Set the unique `SERVER_ID` option (it should be different from
    what you have set on master):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '**On slave**: Take backup from the master by remotely connecting. You can use either `mysqldump`
    or `mydumper`. `mysqlpump` cannot be used because the binary log positions won''t
    be consistent.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`mysqldump`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'You have to pass the `--slave-dump` option when taking backup from another
    slave.`mydumper`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '**On slave**: After the backup completes, restore the backup. Refer to [Chapter
    8](part0296.html#8Q96G0-faa69fe6f4c04957afca3568dcd9cd83), *Restoring Data*, for
    the restoration methods.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`mysqldump`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '`mydumper`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '**On slave**: After restoring the backup, you have to execute the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '`mysqldump`: `<log_file_name>` and `<position>` are included in the backup
    dump file. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '`mydumper`: `<log_file_name>` and `<position>` are stored in the metadata file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: If you are taking backup from a slave or master to set up another slave, you
    have to use positions from `SHOW SLAVE STATUS`. If you want to set up the chain
    replication, you can use the positions from `SHOW MASTER STATUS`.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the slave, execute the `START SLAVE` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'You can check the status of replication by executing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: You should look for `Seconds_Behind_Master`, which shows the replication lag.
    If it is `0`, it means the slave is in sync with the master; any non-zero value
    indicates the number of seconds of lag, and if it is `NULL`, it means replication
    is not happening.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up master-master replication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will interest many people since many of us try doing this. Let's
    get into the details of it.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Assume that the masters are `master1` and `master2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Set up replication between `master1` and `master2` as described in Chapter 9,
    *Replication*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Make `master2` read-only:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: On `master2`, check the current binary log coordinate.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: From the preceding output, you can start the replication on `master1` from `server1.000017`
    and position `473`.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the positions taken from the preceding step, execute the `CHANGE MASTER
    TO` command on `master1`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Start the slave on `master1`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Finally, you can make `master2` read-write, and applications can start writing
    to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Setting up multi-source replication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MySQL multi-source replication enables a replication slave to receive transactions
    from multiple sources simultaneously. Multi-source replication can be used to
    back up multiple servers to a single server, merge table shards, and consolidate
    data from multiple servers to a single server. Multi-source replication does not
    implement any conflict detection or resolution when applying transactions, and
    those tasks are left to the application if required. In a multi-source replication
    topology, a slave creates a replication channel for each master that it should
    receive transactions from.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you will learn how to set up a slave with multiple masters.
    This method is the same as setting up traditional replication over the channels.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Assume that you are setting up `server3` as a slave of `server1` and `server2`.
    You need to create traditional replication from `server1` to `server3` over a
    channel and from `server2` to `server3` over another channel. To ensure that data
    is consistent on the slave, make sure that different sets of databases are replicated
    or the application takes care of the conflicts.
  prefs: []
  type: TYPE_NORMAL
- en: Before you begin, take a backup from server1 and restore on `server3`; similarly
    take a backup from `server2` and restore on `server3`, as described in Chapter
    9, *Replication*.
  prefs: []
  type: TYPE_NORMAL
- en: 'On `server3`, modify the replication repositories to `TABLE` from `FILE`. You
    can change it dynamically by running the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Also make the changes in the configuration file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'On `server3`, execute the `CHANGE MASTER TO` command to make it a slave of
    `server1` over a channel named `master-1`. You can name it anything:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'On `server3`, execute the `CHANGE MASTER TO` command to make it a slave of
    `server2` over channel `master-2`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the `START SLAVE FOR CHANNEL` statement for each channel as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Verify the slave status by executing the `SHOW SLAVE STATUS` statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'To get the slave status for a particular channel, execute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the other way you can use a performance schema to monitor the metrics:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'You can specify all the slave-related commands for a channel by appending `FOR
    CHANNEL ''channel_name''`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Setting up replication filters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can control which tables or databases are to be replicated. On the master,
    you can control which databases to log changes for by using the `--binlog-do-db`
    and `--binlog-ignore-db` options to control binary logging, as mentioned in Chapter
    6, *Binary Logging*. The better way is to control on the slave side. You can execute
    or ignore statements received from the master by using `--replicate-*` options
    or dynamically by creating replication filters.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To create a filter, you need to execute the `CHANGE REPLICATION FILTER` statement.
  prefs: []
  type: TYPE_NORMAL
- en: Replicate a database only
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Assume that you want to replicate `db1` and `db2` only. Use the following statement
    to create the replication filter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Note that you should specify all the databases inside parentheses.
  prefs: []
  type: TYPE_NORMAL
- en: Replicate specific tables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can specify the tables you want to be replicated using `REPLICATE_DO_TABLE`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Suppose that you want to use regex for tables; you can use the `REPLICATE_WILD_DO_TABLE`
    option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: You can mention some databases or tables with regex using various `IGNORE` options.
  prefs: []
  type: TYPE_NORMAL
- en: Ignore a database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Just like you can choose to replicate a database, you can ignore a database
    from replication using `REPLICATE_IGNORE_DB`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Ignore specific tables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can ignore certain tables using the `REPLICATE_IGNORE_TABLE` and `REPLICATE_WILD_IGNORE_TABLE`
    options. The `REPLICATE_WILD_IGNORE_TABLE` option allows wildcard characters,
    where as `REPLICATE_IGNORE_TABLE` only accepts full table names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also set filters for a channel by specifying the channel name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Refer to [https://dev.mysql.com/doc/refman/8.0/en/change-replication-filter.html](https://dev.mysql.com/doc/refman/8.0/en/change-replication-filter.html)
    for more details on replication filters. If you are using more than one filter,
    refer to [https://dev.mysql.com/doc/refman/8.0/en/replication-rules.html](https://dev.mysql.com/doc/refman/8.0/en/replication-rules.html)
    to know more about how MySQL evaluates filters.
  prefs: []
  type: TYPE_NORMAL
- en: Switching slave from master-slave to chain replication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you have a master-slave replication set up, Servers B and C replicating
    from Server A: Server A --> (Server B, Server C) and you wish to make Server C
    a slave of Server B, you have to stop replication on both Server B and Server
    C. Then bring them to the same master log position using the `START SLAVE UNTIL`
    command. After that, you can get the master log coordinates from Server B and
    execute the `CHANGE MASTER TO` command on Server C.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**On Server C**: Stop slave and note the `Relay_Master_Log_File` and `Exec_Master_Log_Pos`
    positions in the `SHOW SLAVE STATUS\G` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '**On Server B**: Stop slave and note the `Relay_Master_Log_File` and `Exec_Master_Log_Pos`
    positions in the `SHOW SLAVE STATUS\G` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Compare the Server B log positions with Server C and find out which is the
    latest sync with Server A. Usually, since you have stopped the slave on Server
    C first, Server B will be ahead. In our case, the log positions are:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Server C: (`server_A-bin.000023`, `2604`)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Server B: (`server_A-bin.000023`, `8250241`)'
  prefs: []
  type: TYPE_NORMAL
- en: Server B is ahead, so we have to bring Server C to the position of Server B.
  prefs: []
  type: TYPE_NORMAL
- en: '**On Server C**: Use the `START SLAVE UNTIL` statement to sync up to the position
    of server B:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '**On Server C**: Wait for server C to catch up by checking `Exec_Master_Log_Pos`
    and `Until_Log_Pos` (both should be the same) in the output of `SHOW SLAVE STATUS`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '**On Server B**: Find out the master status, start the slave, and make sure
    it is replicating:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '**On Server C**: Stop the slave, execute the `CHANGE MASTER TO` command, and
    point to server B. You have to use the positions that you have got from the preceding
    step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '**On Server C**: Start replication and verify the slave status:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Switching the slave from chain replication to master-slave
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have a chain replication setup (such as server A --> sever B --> server
    C) and you wish to make server C a direct slave of server A, you have to stop
    replication on server B, let server C catch up with server B, and then find the
    coordinates of server A  corresponding to the position where server B stopped.
    Using those coordinates, you can execute a `CHANGE MASTER TO` command on server
    C and make it a slave of server A.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**On server B**: Stop the slave and note down the master status:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '**On server C**: Make sure that the slave delay is caught up.  `Relay_Master_Log_File`
    and `Exec_Master_Log_Pos` should be equal to the output of the master status on
    server B. Once the delay is caught up, stop the slave:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '**On server B**: Get the coordinates of server A from the `SHOW SLAVE STATUS`
    output (note down `Relay_Master_Log_File` and `Exec_Master_Log_Pos`) and start
    the slave:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '**On server C**: Stop the slave and execute `CHANGE MASTER TO COMMAND` to point
    to server A. Use the positions noted down from the preceding step (`server_A-bin.000023` and `16497695`).
    Finally start the slave and verify the slave status:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Setting up delayed replication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, you need a delayed slave for disaster recovery purpose. Suppose a
    disastrous statement (such as a `DROP DATABASE` command) was executed on the master.
    You have to use *point-in-time recovery* from backups to restore the database.
    It will lead to a huge downtime depending on the size of the database. To avoid
    that situation, you can use a delayed slave, which will be always delayed from
    the master by a configured amount of time. If a disaster occurs and that statement
    is not applied by the delayed slave, you can stop the slave and start until the
    disastrous statement, so that the disastrous statement won't be executed. Then
    promote it to master.
  prefs: []
  type: TYPE_NORMAL
- en: The procedure is exactly the same as setting up normal replication, except that
    you specify `MASTER_DELAY` in the `CHANGE MASTER TO` command.
  prefs: []
  type: TYPE_NORMAL
- en: '**How is the delay measured?**'
  prefs: []
  type: TYPE_NORMAL
- en: In versions earlier than MySQL 8.0, the delay is measured based on the `Seconds_Behind_Master`
    value. In MySQL 8.0, it is measured based on `original_commit_timestamp` and `immediate_commit_timestamp`,
    which are written to the binary log.
  prefs: []
  type: TYPE_NORMAL
- en: '`original_commit_timestamp` is the number of microseconds since the epoch when
    the transaction was written (committed) to the binary log of the original master.'
  prefs: []
  type: TYPE_NORMAL
- en: '`immediate_commit_timestamp` is the number of microseconds since the epoch
    when the transaction was written (committed) to the binary log of the immediate
    master.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Stop the slave:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute `CHANGE MASTER TO MASTER_DELAY =` and start the slave. Suppose you
    want a 1-hour delay, you can set `MASTER_DELAY` to `3600` seconds:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Check for the following in the slave status:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`SQL_Delay`: Number of seconds by which the slave must lag the master.'
  prefs: []
  type: TYPE_NORMAL
- en: '`SQL_Remaining_Delay`: Number of seconds left of the delay. This is NULL when
    there is delay is maintained.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Slave_SQL_Running_State`: The state of the SQL thread.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Note that `Seconds_Behind_Master` will be shown as `0` once the delay is maintained.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up GTID replication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **global transaction identifier** (**GTID**) is a unique identifier created
    and associated with each transaction committed on the server of origin (master).
    This identifier is unique, not only to the server on which it originated, but
    also across all servers in a given replication setup. There is a one-to-one mapping
    between all transactions and all GTIDs.
  prefs: []
  type: TYPE_NORMAL
- en: 'A GTID is represented as a pair of coordinates, separated by a colon character
    (`:`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The `source_id` option identifies the originating server. Normally, the server's
    `server_uuid` option is used for this purpose. The `transaction_id` option is
    a sequence number determined by the order in which the transaction was committed
    on this server. For example, the first transaction to be committed has `1` as
    its `transaction_id`, and the tenth transaction to be committed on the same originating
    server is assigned a `transaction_id` of `10`.
  prefs: []
  type: TYPE_NORMAL
- en: As you have seen in previous methods, you have to mention the binary log file
    and position as the starting point for replication. If you are switching a slave
    from one master to another, especially during a failover, you have to get the
    positions from the new master to sync the slave, which can be painful. To avoid
    these, you can use GTID-based replication, where MySQL automatically detects binary
    log positions using GTIDs.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If the replication is already set up between the servers, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Enable GTIDs in `my.cnf`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Set the master as read-only and make sure that all the slaves catch up with
    the master. This is very important because there should not be any data inconsistency
    between master and slaves:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Restart all the slaves to put GTID into effect. Since the `skip_slave_start`
    is given in the configuration file, the slave won''t start until you specify the
    `START SLAVE` command. If you start the slave, it will fail with this error—`The
    replication receiver thread cannot start because the master has GTID_MODE = OFF
    and this server has GTID_MODE = ON`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Restart the master. When you restart the master, it begins in read-write mode
    and starts accepting writes in GTID mode:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the `CHANGE MASTER TO` command to set up GTID replication:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: You can observe that the binary log file and positions are not given; instead,
    `MASTER_AUTO_POSITION` is given, which automatically finds the GTIDs executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute `START SLAVE` on all slaves:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Verify that the slave is replicating:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: To know more about GTID, refer to [https://dev.mysql.com/doc/refman/5.6/en/replication-gtids-concepts.html](https://dev.mysql.com/doc/refman/5.6/en/replication-gtids-concepts.html).
  prefs: []
  type: TYPE_NORMAL
- en: Setting up semi-synchronous replication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Replication is asynchronous by default. The master is not aware of whether the
    writes have reached the slaves or not. If there is a delay between master and
    slave, and if the master crashes, you will lose the data that has not reached
    the slave. To overcome this situation, you can use semi-synchronous replication.
  prefs: []
  type: TYPE_NORMAL
- en: In semi-synchronous replication, the master waits until at least one slave has
    received the writes. By default, the value of `rpl_semi_sync_master_wait_point`
    is `AFTER_SYNC`; this means that the master syncs the transaction to the binary
    log, which is consumed by the slave.
  prefs: []
  type: TYPE_NORMAL
- en: After that, the slave sends an acknowledgement to the master, then the master
    commits the transaction and returns the result to the client. So, it is enough
    if the writes have reached the relay log; the slave need not commit the transaction.
    You can change this behavior by changing the variable `rpl_semi_sync_master_wait_point`
    to `AFTER_COMMIT`. In this, the master commits the transaction to the storage
    engine but does not return the result to the client. Once the transaction is committed
    on the slave, the master receives an acknowledgment of transaction and then returns
    a result to the client.
  prefs: []
  type: TYPE_NORMAL
- en: If you want the transaction to be acknowledged on more slaves, you can increase
    the value of the dynamic variable `rpl_semi_sync_master_wait_for_slave_count`.
    You can also set how many milliseconds the master has to wait for to get the acknowledgement
    from the slave through the dynamic variable `rpl_semi_sync_master_timeout`; the
    default is `10` seconds.
  prefs: []
  type: TYPE_NORMAL
- en: In fully synchronous replication, the master waits until all the slaves have
    committed the transaction. To implement this, you have to use Galera Cluster.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'On a high level, you need to install and enable semi-synchronous plugins on
    both the master and all slaves where you want semi-synchronous replication. You
    have to restart the slave IO thread to bring the changes into effect. You can
    adjust the value of `rpl_semi_sync_master_timeout` according to your network and
    application. A value of `1` second is a good start:'
  prefs: []
  type: TYPE_NORMAL
- en: 'On the master, install the `rpl_semi_sync_master` plugin:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Verify that the plugin is activated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'On the master, enable semi-synchronous replication and adjust the timeout (say
    1 second):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'On the slave, install the `rpl_semi_sync_slave` plugin:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'On the slave, enable semi-synchronous replication and restart the slave IO
    thread:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'You can monitor the status of the semi-synchronous replication through the
    following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To find the number of clients connected as semi-sync—on master, execute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The master switches between asynchronous and semi-synchronous replication when
    the timeout occurs and the slaves catch up. To check what type of replication
    the master is using, check the status of `Rpl_semi_sync_master_status` (on means
    semi-sync and off means async):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'You can verify the semi-synchronous replication using this method:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Stop the slave:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'On the master, execute any statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'You will notice that the master has switched to asynchronous replication since
    it did not get any acknowledgement from the slave even after 1 second (the value
    of `rpl_semi_sync_master_timeout`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Start the slave:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'On the master, you will notice that the master switched back to semi-synchronous
    replication:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
