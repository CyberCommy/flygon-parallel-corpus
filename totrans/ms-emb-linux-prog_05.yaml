- en: Chapter 5. Building a Root Filesystem
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。构建根文件系统
- en: The root filesystem is the fourth and final element of embedded Linux. Once
    you have read this chapter, you will be able build, boot, and run a simple embedded
    Linux system.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 根文件系统是嵌入式Linux的第四个也是最后一个元素。阅读完本章后，您将能够构建、引导和运行一个简单的嵌入式Linux系统。
- en: This chapter explores the fundamental concepts behind the root filesystem by
    building one from scratch. The main aim is to provide the background information
    that you need to understand and make best use of build systems like Buildroot
    and the Yocto Project, which I will cover in [Chapter 6](ch06.html "Chapter 6. Selecting
    a Build System"), *Selecting a Build System*.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章探讨了通过从头开始构建根文件系统来探索根文件系统背后的基本概念。主要目的是提供您理解和充分利用Buildroot和Yocto Project等构建系统所需的背景信息，我将在[第6章](ch06.html
    "第6章。选择构建系统")*选择构建系统*中进行介绍。
- en: 'The techniques I will describe here are broadly known as **roll your own**
    or **RYO**. Back in the earlier days of embedded Linux, it was the only way to
    create a root filesystem. There are still some use cases where an RYO root filesystem
    is applicable, for example, when the amount of RAM or storage is very limited,
    for quick demonstrations, or for any case in which your requirements are not (easily)
    covered by the standard build system tools. Nevertheless, these cases are quite
    rare. Let me emphasize that the purpose of this chapter is educational, it is
    not meant to be a recipe for building everyday embedded systems: use the tools
    described in the next chapter for that.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在这里描述的技术通常被称为**自定义**或**RYO**。在嵌入式Linux的早期，这是创建根文件系统的唯一方法。仍然有一些用例适用于RYO根文件系统，例如当RAM或存储量非常有限时，用于快速演示，或者用于任何标准构建系统工具（容易）无法满足您的要求的情况。然而，这些情况非常罕见。让我强调一下，本章的目的是教育性的，而不是为了构建日常嵌入式系统的配方：请使用下一章中描述的工具。
- en: The first objective is to create a minimal root filesystem that will give us
    a shell prompt. Then, using that as a base, we will add scripts to start up other
    programs and configure a network interface and user permissions. Knowing how to
    build the root filesystem from scratch is a useful skill and it will help you
    to understand what is going on when we look at more complex examples in later
    chapters.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个目标是创建一个最小的根文件系统，以便给我们一个shell提示符。然后，以此为基础，我们将添加脚本来启动其他程序，并配置网络接口和用户权限。了解如何从头开始构建根文件系统是一项有用的技能，它将帮助您理解我们在后面章节中看到的更复杂的示例时发生了什么。
- en: What should be in the root filesystem?
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 根文件系统中应该包含什么？
- en: The kernel will get a root filesystem, either as a ramdisk, passed as a pointer
    from the bootloader, or by mounting the block device given on the kernel command
    line by the `root=` parameter. Once it has a root filesystem, the kernel will
    execute the first program, by default named `init`, as described in the section
    *Early Userspace* in [Chapter 4](ch04.html "Chapter 4. Porting and Configuring
    the Kernel"), *Porting and Configuring the Kernel*. Then, as far as the kernel
    is concerned, its job is complete. It is up to the `init` program to begin processing
    scripts, start other programs, and so on, by calling system functions in the C
    library, which translate into kernel system calls.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 内核将获得一个根文件系统，可以是ramdisk，从引导加载程序传递的指针，或者通过`root=`参数在内核命令行上挂载的块设备。一旦有了根文件系统，内核将执行第一个程序，默认情况下命名为`init`，如[第4章](ch04.html
    "第4章。移植和配置内核")*移植和配置内核*中的*早期用户空间*部分所述。然后，就内核而言，它的工作就完成了。由`init`程序开始处理脚本，启动其他程序等，调用C库中的系统函数，这些函数转换为内核系统调用。
- en: 'To make a useful system, you need these components as a minimum:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个有用的系统，您至少需要以下组件：
- en: '**init**: The program that starts everything off, usually by running a series
    of scripts.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**init**:通常通过运行一系列脚本来启动一切的程序。'
- en: '**shell**: Needed to give you a command prompt but, more importantly, to run
    the shell scripts called by `init` and other programs.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**shell**:需要为您提供命令提示符，但更重要的是运行`init`和其他程序调用的shell脚本。'
- en: '**daemons**: Various server programs, started by `init`.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**守护进程**:由`init`启动的各种服务器程序。'
- en: '**libraries**: Usually, the programs mentioned so far are linked with shared
    libraries which must be present in the root filesystem.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**库**:通常，到目前为止提到的程序都链接到必须存在于根文件系统中的共享库。'
- en: '**Configuration files**: The configuration for `init` and other daemons is
    stored in a series of ASCII text files, usually in the `/etc` directory.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配置文件**: `init`和其他守护程序的配置存储在一系列ASCII文本文件中，通常位于`/etc`目录中。'
- en: '**Device nodes**: The special files that give access to various device drivers.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设备节点**:特殊文件，提供对各种设备驱动程序的访问。'
- en: '**/proc and /sys**: Two pseudo filesystems that represent kernel data structures
    as a hierarchy of directories and files. Many programs and library functions read
    these files.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**/proc和/sys**:代表内核数据结构的两个伪文件系统，以目录和文件的层次结构表示。许多程序和库函数读取这些文件。'
- en: '**kernel modules**: If you have configured some parts of your kernel to be
    modules, they will be here, usually in `/lib/modules/[kernel version]`.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内核模块**:如果您已经配置了内核的某些部分为模块，它们通常会在`/lib/modules/[kernel version]`中。'
- en: In addition, there are the system application or applications that make the
    device do the job it is intended for, and the runtime end user data that they
    collect.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有系统应用程序或应用程序，使设备能够完成其预期工作，并收集它们所收集的运行时最终用户数据。
- en: 'As an aside, it is possible to condense all of the above into a single program.
    You could create a statically linked program that is started instead of `init`
    and runs no others. I have come across such a configuration only once. For example,
    if your program was named `/myprog`, you would put the following command in the
    kernel command line:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，也有可能将上述所有内容压缩成一个单独的程序。您可以创建一个静态链接的程序，它会在`init`之外启动并且不运行其他程序。我只遇到过这样的配置一次。例如，如果您的程序命名为`/myprog`，您可以将以下命令放在内核命令行中：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Or, if the root filesystem was loaded as a ramdisk, you would put the following
    command:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果根文件系统被加载为ramdisk，你可以输入以下命令：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The downside of this approach is that you can't make use of the many tools that
    normally go into an embedded system; you have to do everything yourself.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的缺点是你无法使用通常用于嵌入式系统的许多工具；你必须自己做一切。
- en: Directory layout
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目录布局
- en: 'Interestingly, Linux does not care about the layout of files and directories
    beyond the existence of the program named by `init=` or `rdinit=`, so you are
    free to put things wherever you like. As an example, compare the file layout of
    a device running Android to that of a desktop Linux distribution: they are almost
    completely different.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，Linux并不关心文件和目录的布局，只要存在由`init=`或`rdinit=`命名的程序，你可以自由地将东西放在任何你喜欢的地方。例如，比较运行安卓的设备的文件布局和桌面Linux发行版的文件布局：它们几乎完全不同。
- en: 'However, many programs expect certain files to be in certain places, and it
    helps us developers if devices use a similar layout, Android aside. The basic
    layout of a Linux system is defined in the **Filesystem Hierarchy Standard** (**FHS**),
    see the reference at the end of this chapter. The FHS covers all implementations
    of Linux operating systems from the largest to the smallest. Embedded devices
    have a sub-set based on need but it usually includes the following:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，许多程序希望某些文件在特定位置，如果设备使用类似的布局，对开发人员有所帮助，除了安卓。Linux系统的基本布局在**文件系统层次结构标准**（**FHS**）中定义，参见本章末尾的参考资料。FHS涵盖了从最大到最小的所有Linux操作系统的实现。嵌入式设备根据需要有一个子集，但通常包括以下内容：
- en: '`/bin`: programs essential for all users'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/bin`：所有用户必需的程序'
- en: '`/dev`: device nodes and other special files'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/dev`：设备节点和其他特殊文件'
- en: '`/etc`: system configuration'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/etc`：系统配置'
- en: '`/lib`: essential shared libraries, for example, those that make up the C library'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/lib`：必需的共享库，例如组成C库的那些库'
- en: '`/proc`: the `proc` filesystem'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/proc`：`proc`文件系统'
- en: '`/sbin`: programs essential to the system administrator'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/sbin`：对系统管理员至关重要的程序'
- en: '`/sys`: the `sysfs` filesystem'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/sys`：`sysfs`文件系统'
- en: '`/tmp`: a place to put temporary or volatile files'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/tmp`：放置临时或易失性文件的地方'
- en: '`/usr`: as a minimum, this should contain the directories `/usr/bin`, `/usr/lib`
    and `/usr/sbin,` which contain additional programs, libraries, and system administrator
    utilities'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/usr`：至少应包含目录`/usr/bin`、`/usr/lib`和`/usr/sbin`，其中包含额外的程序、库和系统管理员实用程序'
- en: '`/var`: a hierarchy of files and directories that may be modified at runtime,
    for example, log messages, some of which must be retained after boot'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/var`：可能在运行时被修改的文件和目录的层次结构，例如日志消息，其中一些必须在引导后保留'
- en: 'There are some subtle distinctions here. The difference between `/bin` and
    `/sbin` is simply that `/sbin` need not be included in the search path for non-root
    users. Users of Red Hat-derived distributions will be familiar with this. The
    significance of `/usr` is that it may be in a separate partition from the root
    filesystem so it cannot contain anything that is needed to boot the system up.
    That is what essential means in the preceding description: it contains files that
    are needed at boot time and so must be part of the root filesystem.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些微妙的区别。`/bin`和`/sbin`之间的区别仅仅是`/sbin`不需要包含在非root用户的搜索路径中。使用Red Hat衍生的发行版的用户会熟悉这一点。`/usr`的重要性在于它可能在与根文件系统不同的分区中，因此它不能包含任何引导系统所需的内容。这就是前面描述中所说的“必需”的含义：它包含了在引导时需要的文件，因此必须是根文件系统的一部分。
- en: Tip
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: While it might seem like overkill to have four directories to store programs,
    a counter argument would be that it does no harm, and it may even do some good
    because it allows you to store `/usr` in a different filesystem.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然似乎在四个目录中存储程序有些多余，但反驳的观点是这并没有什么坏处，甚至可能有些好处，因为它允许你将`/usr`存储在不同的文件系统中。
- en: Staging directory
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 暂存目录
- en: 'You should begin by creating a staging directory on your host computer where
    you can assemble the files that will eventually be transferred to the target.
    In the following examples, I have used `~/rootfs`. You need to create a skeleton
    directory structure in that, for example:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该首先在主机计算机上创建一个暂存目录，在那里你可以组装最终将传输到目标设备的文件。在下面的示例中，我使用了`~/rootfs`。你需要在其中创建一个骨架目录结构，例如：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To see the directory hierarchy more clearly you can use the handy `tree` command,
    used in the following example with the `-d` option to show only directories:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更清晰地看到目录层次结构，你可以使用方便的`tree`命令，下面的示例中使用了`-d`选项只显示目录：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: POSIX file access permissions
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: POSIX文件访问权限
- en: Every process which, in the context of this discussion, means every running
    program, belongs to a user and one or more groups. The user is represented by
    a 32-bit number called the **user ID** or **UID**. Information about users, including
    the mapping from a UID to a name, is kept in `/etc/passwd`. Likewise, groups are
    represented by a **group ID** or **GID**, with information kept in `/etc/group`.
    There is always a root user with a UID of 0 and a root group with a GID of 0\.
    The root user is also called the super-user because, in a default configuration,
    it bypasses most permission checks and can access all the resources in the system.
    Security in Linux-based systems is mainly about restricting access to the root
    account.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里讨论的上下文中，每个进程，也就是每个正在运行的程序，都属于一个用户和一个或多个组。用户由一个称为**用户ID**或**UID**的32位数字表示。关于用户的信息，包括从UID到名称的映射，保存在`/etc/passwd`中。同样，组由**组ID**或**GID**表示，信息保存在`/etc/group`中。始终存在一个UID为0的root用户和一个GID为0的root组。root用户也被称为超级用户，因为在默认配置中，它可以绕过大多数权限检查，并且可以访问系统中的所有资源。基于Linux的系统中的安全性主要是关于限制对root账户的访问。
- en: 'Each file and directory also has an owner and belongs to exactly one group.
    The level of access a process has to a file or directory is controlled by a set
    of access permission flags, called the mode of the file. There are three collections
    of three bits: the first collection applies to the owner of the file, the second
    to members of the same group as the file, and the last to everyone else, the rest
    of the world. The bits are for read (r), write (w), and execute (x) permissions
    on the file. Since three bits fit neatly into an octal digit, they are usually
    represented in octal, as shown in the following figure:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '![POSIX file access permissions](img/B03982_05_01.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
- en: 'There is a further group of three bits that have special meanings:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '**SUID (4)**: If the file is an executable, change the effective UID of the
    process to that of the owner of the file.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SGID (2)**: If the file is an executable, change the effective GID of the
    process to that of the group of the file.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sticky (1)**: In a directory, restrict deletion so that one user cannot delete
    files that are owned by another user. This is usually set on `/tmp` and `/var/tmp`.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The SUID bit is probably the most often used. It gives non-root users a temporary
    privilege escalation to super-user to perform a task. A good example is the `ping`
    program: `ping` opens a raw socket which is a privileged operation. In order for
    normal users to use `ping`, it is normally owned by the root and has the SUID
    bit set so that, when you run `ping`, it executes with UID 0 regardless of your
    UID.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: 'To set these bits, use the octal numbers, 4, 2, 1, with the `chmod` command.
    For example, to set SUID on `/bin/ping` in your staging root directory, you could
    use the following:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Note the `s` in the last file listing: that is the indication that SUID is
    set.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: File ownership permissions in the staging directory
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For security and stability reasons, it is vitally important to pay attention
    to the ownership and permissions of the files that will be placed on the target
    device. Generally speaking, you want to restrict sensitive resources to be accessible
    only by the root and to run as many of the programs using non-root users so that,
    if they are compromised by an outside attack, they offer as few system resources
    to the attacker as possible. For example, the device node `/dev/mem` gives access
    to system memory, which is necessary in some programs. But, if it is readable
    and writeable by everyone, then there is no security because everyone can access
    everything. So `/dev/mem` should be owned by root, belong to the root group and
    have a mode of 600, which denies read and write access to all but the owner.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a problem with the staging directory though. The files you create
    there will be owned by you but, when they are installed on the device, they should
    belong to specific owners and groups, mostly the root user. An obvious fix is
    to change the ownership at this stage with the command shown here:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The problem is that you need root privileges to run that command and, from that
    point onward, you will need to be root to modify any files in the staging directory.
    Before you know it, you are doing all your development logged on as root, which
    is not a good idea. This is a problem that we will come back to later.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: Programs for the root filesystem
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, it is time to start populating the root filesystem with the essential programs
    and the supporting libraries, configuration, and data files that it needs to operate,
    beginning with an overview of the types of program you will need.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: The init program
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You have seen in the previous chapter that `init` is the first program to be
    run and so has PID 1\. It runs as the root user and so has maximum access to system
    resources. Usually, it runs shell scripts which start daemons: a daemon is a program
    that runs in the background with no connection to a terminal, in other places
    it would be called a server program.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Shell
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We need a shell to run scripts and to give us a command-line prompt so that
    we can interact with the system. An interactive shell is probably not necessary
    in a production device, but it is useful for development, debugging, and maintenance.
    There are various shells in common use in embedded systems:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个shell来运行脚本，并给我们一个命令行提示符，以便我们可以与系统交互。在生产设备中可能不需要交互式shell，但它对开发、调试和维护非常有用。嵌入式系统中常用的各种shell有：
- en: '`bash`: is the big beast that we all know and love from desktop Linux. It is
    a superset of the Unix Bourne shell, with many extensions or *bashisms*.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bash`：是我们从桌面Linux中熟悉和喜爱的大型工具。它是Unix Bourne shell的超集，具有许多扩展或*bashisms*。'
- en: '`ash`: also based on the Bourne shell, and has a long history with the BSD
    variants of Unix. Busybox has a version of ash which has been extended to make
    it more compatible with `bash`. It is much smaller than `bash` and hence is a
    very popular choice for embedded systems.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ash`：也基于Bourne shell，并且在Unix的BSD变体中有着悠久的历史。Busybox有一个ash的版本，已经扩展以使其与`bash`更兼容。它比`bash`小得多，因此是嵌入式系统的非常受欢迎的选择。'
- en: '`hush`: is a very small shell that we briefly looked at in the chapter on bootloaders.
    It is useful on devices with very little memory. There is a version in BusyBox.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hush`：是一个非常小的shell，在引导加载程序章节中我们简要介绍过。它在内存非常少的设备上非常有用。BusyBox中有一个版本。'
- en: Tip
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you are using `ash` or `hush` as the shell on the target, make sure that
    you test your shell scripts on the target. It is very tempting to test them only
    on the host, using `bash`, and then be surprised that they don't work when you
    copy them to the target.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在目标上使用`ash`或`hush`作为shell，请确保在目标上测试您的shell脚本。很容易只在主机上测试它们，使用`bash`，然后当您将它们复制到目标时发现它们无法工作。
- en: Utilities
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实用程序
- en: The shell is just a way of launching other programs and a shell script is little
    more than a list of programs to run, with some flow control and a means of passing
    information between programs. To make a shell useful, you need the utility programs
    that the Unix command-line is based on. Even for a basic root filesystem, there
    are approximately 50 utilities, which presents two problems. Firstly, tracking
    down the source code for each and cross compiling it would be quite a big job.
    Secondly, the resulting collection of programs would take up several tens of megabytes,
    which was a real problem in the early days of embedded Linux when a few megabytes
    was all you had. To solve this problem, BusyBox was born.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: shell只是启动其他程序的一种方式，shell脚本只不过是要运行的程序列表，带有一些流程控制和在程序之间传递信息的手段。要使shell有用，您需要基于Unix命令行的实用程序。即使对于基本的根文件系统，也有大约50个实用程序，这带来了两个问题。首先，追踪每个程序的源代码并进行交叉编译将是一项相当大的工作。其次，由此产生的程序集将占用数十兆字节的空间，在嵌入式Linux的早期阶段，几兆字节就是一个真正的问题。为了解决这个问题，BusyBox诞生了。
- en: BusyBox to the rescue!
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: BusyBox来拯救！
- en: The genesis of BusyBox had nothing to do with embedded Linux. The project was
    instigated in 1996 by Bruce Perens for the Debian installer so that he could boot
    Linux from a 1.44 MB floppy disk. Coincidentally, that was about the size of the
    storage on contemporary devices and so the embedded Linux community quickly took
    it up. BusyBox has been at the heart of embedded Linux ever since.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: BusyBox的起源与嵌入式Linux无关。该项目是由Bruce Perens于1996年发起的，用于Debian安装程序，以便他可以从1.44 MB软盘启动Linux。巧合的是，当时的设备存储容量大约是这个大小，因此嵌入式Linux社区迅速接受了它。从那时起，BusyBox一直是嵌入式Linux的核心。
- en: 'BusyBox was written from scratch to perform the essential functions of those
    essential Linux utilities. The developers took advantage of the 80:20 rule: the
    most useful 80% of a program is implemented in 20% of the code. Hence, BusyBox
    tools implement a subset of the functions of the desktop equivalents, but they
    do enough to be useful in the majority of cases.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: BusyBox是从头开始编写的，以执行这些基本Linux实用程序的基本功能。开发人员利用了80:20规则：程序最有用的80%在代码的20%中实现。因此，BusyBox工具实现了桌面等效工具功能的子集，但它们足够在大多数情况下使用。
- en: 'Another trick BusyBox employs is to combine all the tools together into a single
    binary, making it easy to share code between them. It works like this: BusyBox
    is a collection of applets, each of which exports its main function in the form
    `[applet]_main`. For example, the `cat` command is implemented in `coreutils/cat.c`
    and exports `cat_main`. The main function of BusyBox itself dispatches the call
    to the correct applet based on the command-line arguments.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: BusyBox采用的另一个技巧是将所有工具合并到一个单一的二进制文件中，这样可以很容易地在它们之间共享代码。它的工作原理是这样的：BusyBox是一组小工具，每个小工具都以`[applet]_main`的形式导出其主要函数。例如，`cat`命令是在`coreutils/cat.c`中实现的，并导出`cat_main`。BusyBox本身的主函数根据命令行参数将调用分派到正确的小工具。
- en: 'So, to read a file, you can launch `busybox` with the name of the applet you
    want to run, followed by any arguments the applet expects, as shown here:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，要读取文件，您可以启动`busybox`，后面跟上您想要运行的小工具的名称，以及小工具期望的任何参数，如下所示：
- en: '[PRE6]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You can also run `busybox` with no arguments to get a list of all the applets
    that have been compiled.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以运行`busybox`而不带任何参数，以获取已编译的所有小工具的列表。
- en: 'Using BusyBox in this way is rather clumsy. A better way to get BusyBox to
    run the `cat` applet is to create a symbolic link from `/bin/cat` to `/bin/busybox`:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式使用BusyBox相当笨拙。让BusyBox运行`cat`小工具的更好方法是创建一个从`/bin/cat`到`/bin/busybox`的符号链接。
- en: '[PRE7]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'When you type `cat` at the command line, `busybox` is the program that actually
    runs. BusyBox only has to check the command tail passed in `argv[0]`, which will
    be `/bin/cat`, extract the application name, `cat`, and do a table look-up to
    match `cat` with `cat_main`. All this is in `libbb/appletlib.c` in this section
    of code (slightly simplified):'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在命令行输入`cat`时，实际运行的程序是`busybox`。BusyBox只需要检查传递给`argv[0]`的命令尾部，它将是`/bin/cat`，提取应用程序名称`cat`，并进行表查找以匹配`cat`与`cat_main`。所有这些都在`libbb/appletlib.c`中的这段代码中（稍微简化）：
- en: '[PRE8]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: BusyBox has over three hundred applets including an `init` program, several
    shells of varying levels of complexity, and utilities for most admin tasks. There
    is even a simple version of the `vi` editor so you can change text files on your
    device.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: BusyBox有300多个小程序，包括一个`init`程序，几个不同复杂级别的shell，以及大多数管理任务的实用程序。甚至还有一个简化版的`vi`编辑器，这样你就可以在设备上更改文本文件。
- en: To summarize, a typical installation of BusyBox consists of a single program
    with a symbolic link for each applet, but which behaves exactly as if it were
    a collection of individual applications.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，BusyBox的典型安装包括一个程序和每个小程序的符号链接，但它的行为就像是一个独立应用程序的集合。
- en: Building BusyBox
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建BusyBox
- en: 'BusyBox uses the same `Kconfig` and `Kbuild` system of the kernel, so cross
    compiling is straightforward. You can get the source by cloning the git archive
    and checking out the version you want (1_24_1 was the latest at the time of writing),
    like this:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: BusyBox使用与内核相同的`Kconfig`和`Kbuild`系统，因此交叉编译很简单。你可以通过克隆git存档并检出你想要的版本（写作时最新的是1_24_1）来获取源代码，就像这样：
- en: '[PRE9]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You can also download the corresponding `tarball` file from [http://busybox.net/downloads](http://busybox.net/downloads).
    Then, configure BusyBox, starting in this case with the default configuration,
    which enables pretty much all of the features of BusyBox:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以从[http://busybox.net/downloads](http://busybox.net/downloads)下载相应的`tarball`文件。然后，配置BusyBox，从默认配置开始，这样可以启用几乎所有BusyBox的功能：
- en: '[PRE10]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'At this point, you probably want to run `make menuconfig` to fine tune the
    configuration. You almost certainly want to set the install path in **Busybox
    Settings** | **Installation Options** (`CONFIG_PREFIX`) to point to the staging
    directory. Then, you can cross compile in the usual way:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，你可能想要运行`make menuconfig`来微调配置。你几乎肯定想要在**Busybox Settings** | **Installation
    Options** (`CONFIG_PREFIX`)中设置安装路径，指向暂存目录。然后，你可以像通常一样进行交叉编译：
- en: '[PRE11]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The result is the executable, `busybox`. For a `defconfig` build for ARM v7a,
    it comes out at about 900 KiB. If that is too big for you, you can slim it down
    by configuring out the utilities you don't need.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是可执行文件`busybox`。对于ARM v7a的`defconfig`构建，它的大小约为900 KiB。如果这对你来说太大了，你可以通过配置掉你不需要的实用程序来减小它。
- en: 'To install BusyBox, use the following command:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装BusyBox，请使用以下命令：
- en: '[PRE12]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This will copy the binary to the directory configured in `CONFIG_PREFIX` and
    create all the symbolic links to it.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把二进制文件复制到`CONFIG_PREFIX`配置的目录，并创建所有的符号链接。
- en: ToyBox – an alternative to BusyBox
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ToyBox - BusyBox的替代品
- en: BusyBox is not the only game in town. For example, Android has an equivalent
    named Toolbox, but it is more tuned to the needs of Android and not useful in
    a general purpose embedded environment. A more useful option is ToyBox, a project
    started and maintained by Rob Landley, who was previously a maintainer of BusyBox.
    ToyBox has the same aim as BusyBox, but with more emphasis on complying with standards,
    especially POSIX-2008 and LSB 4.1, and less on compatibility with GNU extensions
    to those standards. ToyBox is smaller than BusyBox, partly because it implements
    fewer applets.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: BusyBox并不是唯一的选择。例如，Android有一个名为Toolbox的等效工具，但它更适合Android的需求，对于一般嵌入式环境没有用。一个更有用的选择是ToyBox，这是一个由Rob
    Landley发起和维护的项目，他以前是BusyBox的维护者。ToyBox的目标与BusyBox相同，但更注重遵守标准，特别是POSIX-2008和LSB
    4.1，而不是与GNU对这些标准的扩展的兼容性。ToyBox比BusyBox小，部分原因是它实现的小程序更少。
- en: However, the main difference is the license, BSD rather than GPL v2, which makes
    it license-compatible with operating systems with a BSD-licensed user space, such
    as Android itself.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，主要的区别是许可证，是BSD而不是GPL v2，这使它与具有BSD许可的用户空间的操作系统兼容，比如Android本身。
- en: Libraries for the root filesystem
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 根文件系统的库
- en: Programs are linked with libraries. You could link them all statically, in which
    case, there would be no libraries on the target device. But, that takes up an
    unnecessarily large amount of storage if you have more than two or three programs.
    So, you need to copy shared libraries from the toolchain to the staging directory.
    How do you know which libraries?
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 程序与库链接。你可以将它们全部静态链接，这样目标设备上就不会有库了。但是，如果你有两三个以上的程序，这将占用不必要的大量存储空间。所以，你需要将共享库从工具链复制到暂存目录。你怎么知道哪些库？
- en: One option is to copy all of them since they must be of some use, otherwise
    they wouldn't exist! That is certainly logical and, if you are creating a platform
    to be used by others for a range of applications, that would be the correct approach.
    Be aware, though, that a full `glibc` is quite large. In the case of a CrossTool-NG
    build of `glibc` 2.19, the space taken by `/lib` and `/usr/lib` is 33 MiB. Of
    course, you could cut down on that considerably by using uClibc or Musel `libc`
    libraries.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 一个选择是将它们全部复制，因为它们肯定有些用处，否则它们就不会存在！这当然是合乎逻辑的，如果你正在为他人用于各种应用程序的平台创建一个平台，那么这将是正确的方法。但要注意，一个完整的`glibc`相当大。在CrossTool-NG构建的`glibc`
    2.19的情况下，`/lib`和`/usr/lib`占用的空间为33 MiB。当然，你可以通过使用uClibc或Musel `libc`库大大减少这个空间。
- en: 'Another option is to cherry pick only those libraries that you require, for
    which you need a means of discovering library dependencies. Using some of our
    knowledge from [Chapter 2](ch02.html "Chapter 2. Learning About Toolchains"),
    *Learning About Toolchains* libraries, you can use `readelf` for that task:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选择是只挑选你需要的那些库，为此你需要一种发现库依赖关系的方法。使用我们从[第2章](ch02.html "第2章。了解工具链")中的一些知识，*了解工具链*库，你可以使用`readelf`来完成这个任务：
- en: '[PRE13]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now you need to find these files in the toolchain and copy them to the staging
    directory. Remember that you can find `sysroot` like this:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你需要在工具链中找到这些文件，并将它们复制到暂存目录。记住你可以这样找到`sysroot`：
- en: '[PRE14]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To reduce the amount of typing, I am going to keep a copy of that in a shell
    variable:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减少输入量，我将把它保存在一个shell变量中：
- en: '[PRE15]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If you look at `/lib/ld-linux-armhf.so.3,` in `sysroot`, you will see that,
    it is, in fact, a symbolic link:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在`sysroot`中查看`/lib/ld-linux-armhf.so.3`，你会发现，它实际上是一个符号链接：
- en: '[PRE16]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Repeat the exercise for `libc.so.6` and `libm.so.6` and you will end up with
    a list of three files and three symbolic links. Copy them using `cp -a`, which
    will preserve the symbolic link:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 对`libc.so.6`和`libm.so.6`重复此操作，您将得到三个文件和三个符号链接的列表。使用`cp -a`进行复制，这将保留符号链接：
- en: '[PRE17]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Repeat this procedure for each program.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 对每个程序重复此过程。
- en: Tip
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: It is only worth doing this to get the very smallest embedded footprint possible.
    There is a danger that you will miss libraries that are loaded through `dlopen(3)`
    calls - plugins mostly. We will look at an example with the NSS libraries when
    we come to configure network interfaces later on in this chapter.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做只有在获取最小的嵌入式占用空间时才值得。有可能会错过通过`dlopen(3)`调用加载的库，主要是插件。我们将在本章后面配置网络接口时，通过NSS库的示例来说明。
- en: Reducing size by stripping
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过剥离来减小尺寸
- en: 'Libraries and programs are often compiled with a symbol table information built
    in, more so if you have compiled with the debug switch, `-g`. You seldom need
    these on the target. A quick and easy way to save space is to strip them. This
    example shows `libc` before and after stripping:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，库和程序都会编译时内置符号表信息，如果使用了调试开关`-g`，则更多。您很少需要这些信息。节省空间的一种快速简单的方法是剥离它们。此示例显示了剥离前后的`libc`：
- en: '[PRE18]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In this case, we saved 321,347 bytes, which was about 20%.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们节省了321,347字节，大约为20%。
- en: 'When stripping kernel modules, use the following command:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在剥离内核模块时，使用以下命令：
- en: '[PRE19]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Otherwise, you will strip out the symbols needed to relocate the module code
    and it will fail to load.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，您将剥离重定位模块代码所需的符号，导致加载失败。
- en: Device nodes
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设备节点
- en: Most devices in Linux are represented by device nodes, in accordance with the
    Unix philosophy that *everything is a file* (except network interfaces, which
    are sockets). A device node may refer to a block device or a character device.
    Block devices are mass storage devices such as SD cards or hard drives. A character
    device is pretty much anything else, once again with the exception of network
    interfaces. The conventional location for device nodes is the directory `/dev`.
    For example, a serial port may be represented by the device node `/dev/ttyS0`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Linux中的大多数设备都由设备节点表示，符合Unix哲学的*一切皆文件*（除了网络接口，它们是套接字）。设备节点可能是块设备或字符设备。块设备是诸如SD卡或硬盘等大容量存储设备。字符设备基本上是其他任何东西，再次除了网络接口。设备节点的传统位置是目录`/dev`。例如，串行端口可以由设备节点`/dev/ttyS0`表示。
- en: 'Device nodes are created using the program `mknod` (short for make node):'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 使用程序`mknod`（缩写为make node）创建设备节点：
- en: '[PRE20]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '`name` is the name of the device node that you want to create, `type` is either,
    `c` for character devices, and `b` for block. They each have a major number and
    a minor number which is used by the kernel to route file requests to the appropriate
    device driver code. There is a list of standard major and minor numbers in the
    kernel source in `Documentation/devices.txt`.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`name`是您要创建的设备节点的名称，`type`可以是`c`表示字符设备，`b`表示块设备。它们各自有一个主要号和次要号，内核使用这些号码将文件请求路由到适当的设备驱动程序代码。内核源代码中有一个标准主要和次要号的列表，位于`Documentation/devices.txt`中。'
- en: You will need to create device nodes for all the devices you want to access
    on your system. You can do that manually by using the `mknod` command as I will
    illustrate here, or you can use one of the device managers mentioned later to
    create them automatically, at runtime.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要为系统上要访问的所有设备创建设备节点。您可以手动使用`mknod`命令来执行此操作，就像我在这里所示的那样，或者您可以使用稍后提到的设备管理器之一来在运行时自动创建它们。
- en: 'You need just two nodes to boot with BusyBox: `console` and `null`. The console
    only needs to be accessible to root, the owner of the device node, so the access
    permissions are 600\. The null device should be readable and writable by everyone,
    so the mode is 666\. You can use the `-m` option to `mknod` to set the mode when
    creating the node. You need to be root to create a device node:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 使用BusyBox启动只需要两个节点：`console`和`null`。控制台只需要对root可访问，设备节点的所有者，因此访问权限为600。空设备应该对所有人可读可写，因此模式为666。您可以使用`mknod`的`-m`选项在创建节点时设置模式。您需要是root才能创建设备节点：
- en: '[PRE21]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'You delete device nodes by using the standard `rm` command: there is no `rmnod`
    command because, once created, they are just files.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用标准的`rm`命令删除设备节点：没有`rmnod`命令，因为一旦创建，它们就是普通文件。
- en: The proc and sysfs filesystems
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: proc和sysfs文件系统
- en: '`proc` and `sysfs` are two pseudo filesystems that give a window onto the inner
    workings of the kernel. They both represent kernel data as files in a hierarchy
    of directories: when you read one of the files, the contents you see do not come
    from disk storage, it has been formatted on-the-fly by a function in the kernel.
    Some files are also writable, meaning that a kernel function is called with the
    new data you have written and, if it is of the correct format and you have sufficient
    permissions, it will modify the value stored in the kernel''s memory. In other
    works, `proc` and `sysfs` provide another way to interact with device drivers
    and other kernel code.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`proc`和`sysfs`是两个伪文件系统，它们提供了内核内部工作的窗口。它们都将内核数据表示为目录层次结构中的文件：当您读取其中一个文件时，您看到的内容并不来自磁盘存储，而是由内核中的一个函数即时格式化的。一些文件也是可写的，这意味着将调用内核函数并使用您写入的新数据，如果格式正确且您有足够的权限，它将修改内核内存中存储的值。换句话说，`proc`和`sysfs`提供了另一种与设备驱动程序和其他内核代码交互的方式。'
- en: '`proc` and `sysfs` should be mounted on the directories `/proc` and `/sys`:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`proc`和`sysfs`应该挂载在目录`/proc`和`/sys`上：'
- en: '[PRE22]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Although they are very similar in concept, they perform different functions.
    `proc` has been part of Linux since the early days. Its original purpose was to
    expose information about processes to user space, hence the name. To this end,
    there is a directory for each process named `/proc/<PID>` which contains information
    about its state. The process list command, `ps`, reads these files to generate
    its output. In addition, there are files that give information about other parts
    of the kernel, for example, `/proc/cpuinfo` tells you about the CPU, `/proc/interrupts`
    has information about interrupts, and so on. Finally, in `/proc/sys`, there are
    files that display and control the state and behavior of kernel sub-systems, especially
    scheduling, memory management, and networking. The best reference for the files
    you will find in `proc` is man page `proc(5)`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它们在概念上非常相似，但它们执行不同的功能。`proc`从Linux的早期就存在。它的最初目的是向用户空间公开有关进程的信息，因此得名。为此，有一个名为`/proc/<PID>`的目录，其中包含有关其状态的信息。进程列表命令`ps`读取这些文件以生成其输出。此外，还有一些文件提供有关内核其他部分的信息，例如`/proc/cpuinfo`告诉您有关CPU的信息，`/proc/interrupts`包含有关中断的信息，等等。最后，在`/proc/sys`中，有一些文件显示和控制内核子系统的状态和行为，特别是调度、内存管理和网络。有关您将在`proc`中找到的文件的最佳参考是`proc(5)`手册页。
- en: In fact, over time, the number of files in `proc` and their layout has become
    rather chaotic. In Linux 2.6, `sysfs` was introduced to export a subset of the
    data in an ordered way.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，随着时间的推移，`proc`中的文件数量及其布局变得相当混乱。在Linux 2.6中，`sysfs`被引入以有序方式导出数据的子集。
- en: In contrast, `sysfs` exports a very ordered hierarchy of files relating to devices
    and the way they are connected to each other.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，`sysfs`导出了一个与设备及其相互连接方式相关的文件的有序层次结构。
- en: Mounting filesystems
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 挂载文件系统
- en: 'The `mount` command allows us to attach one filesystem to a directory within
    another, forming a hierarchy of filesystems. The one at the top, which was mounted
    by the kernel when it booted, is called the root filesystem. The format of the
    `mount` command is as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`mount`命令允许我们将一个文件系统附加到另一个文件系统中的目录，形成文件系统的层次结构。在顶部被内核挂载时，称为根文件系统。`mount`命令的格式如下：'
- en: '[PRE23]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You need to specify the type of the filesystem, `vfstype`, the block device
    node it resides on, and the directory you want to mount it to. There are various
    options you can give after the `-o`, have a look at the manual for more information.
    As an example, if you want to mount an SD card containing an `ext4` filesystem
    in the first partition onto directory `/mnt`, you would type the following:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要指定文件系统的类型`vfstype`，它所在的块设备节点，以及您要将其挂载到的目录。在`-o`之后，您可以给出各种选项，更多信息请参阅手册。例如，如果您想要将包含`ext4`文件系统的SD卡的第一个分区挂载到目录`/mnt`，您可以输入以下内容：
- en: '[PRE24]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Assuming the mount succeeds, you would be able to see the files stored on the
    SD card in the directory `/mnt`. In some cases, you can leave out the filesystem
    type and let the kernel probe the device to find out what is stored there.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 假设挂载成功，您将能够在目录`/mnt`中看到存储在SD卡上的文件。在某些情况下，您可以省略文件系统类型，让内核探测设备以找出存储的内容。
- en: 'Looking at the example of mounting the `proc` filesystem, there is something
    odd: there is no device node, `/dev/proc`, since it is a pseudo filesystem, not
    a real one. But the `mount` command requires a device as a parameter. Consequently
    we have to give a string where the device should go, but it does not matter much
    what that string is. These two commands achieve exactly the same result:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 看看挂载`proc`文件系统的例子，有一些奇怪的地方：没有设备节点`/dev/proc`，因为它是一个伪文件系统，而不是一个真正的文件系统。但`mount`命令需要一个设备作为参数。因此，我们必须提供一个字符串来代替设备，但这个字符串是什么并不重要。这两个命令实现了完全相同的结果：
- en: '[PRE25]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: It is fairly common to use the filesystem type in the place of the device when
    mounting pseudo filesystems.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在挂载伪文件系统时，通常在设备的位置使用文件系统类型。
- en: Kernel modules
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内核模块
- en: If you have kernel modules, they need to be installed into the root filesystem,
    using the kernel `make modules_install` target, as we saw in the last chapter.
    This will copy them into the directory `/lib/modules/<kernel version>` together
    with the configuration files needed by the `modprobe` command.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有内核模块，它们需要安装到根文件系统中，使用内核`make modules_install`目标，就像我们在上一章中看到的那样。这将把它们复制到目录`/lib/modules/<kernel
    version>`中，以及`modprobe`命令所需的配置文件。
- en: Be aware that you have just created a dependency between the kernel and the
    root filesystem. If you update one, you will have to update the other.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，您刚刚在内核和根文件系统之间创建了一个依赖关系。如果您更新其中一个，您将不得不更新另一个。
- en: Transfering the root filesystem to the target
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将根文件系统传输到目标位置
- en: 'Having created a skeleton root filesystem in your staging directory, the next
    task is to transfer it to the target. In the sections that follow, I will describe
    three possibilities:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在暂存目录中创建了一个骨架根文件系统后，下一个任务是将其传输到目标位置。在接下来的章节中，我将描述三种可能性：
- en: '**ramdisk**: a filesystem image that is loaded into RAM by the bootloader.
    Ramdisks are easy to create and have no dependencies on mass storage drivers.
    They can be used in fall-back maintenance mode when the main root filesystem needs
    updating. They can even be used as the main root filesystem in small embedded
    devices and, of course, as the early user space in mainstream Linux distributions.
    A compressed ramdisk uses the minimum amount of storage but still consumes RAM.
    The contents are volatile so you need another storage type to store permanent
    data such as configuration parameters.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ramdisk**：由引导加载到RAM中的文件系统映像。Ramdisks易于创建，并且不依赖于大容量存储驱动程序。当主根文件系统需要更新时，它们可以用于后备维护模式。它们甚至可以用作小型嵌入式设备的主根文件系统，当然也可以用作主流Linux发行版中的早期用户空间。压缩的ramdisk使用最少的存储空间，但仍然消耗RAM。内容是易失性的，因此您需要另一种存储类型来存储永久数据，例如配置参数。'
- en: '**disk image**: a copy of the root filesystem formatted and ready to be loaded
    onto a mass storage device on the target. For example, it could be an image in
    `ext4` format ready to be copied onto an SD card, or it could be in `jffs2` format
    ready to be loaded into flash memory via the bootloader. Creating a disk image
    is probably the most common option. There is more information about the different
    types of mass storage in [Chapter 7](ch07.html "Chapter 7. Creating a Storage
    Strategy"), *Creating a Storage Strategy*.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**磁盘映像**：根文件系统的副本，格式化并准备好加载到目标设备的大容量存储设备上。例如，它可以是一个`ext4`格式的映像，准备好复制到SD卡上，或者它可以是一个`jffs2`格式的映像，准备好通过引导加载到闪存中。创建磁盘映像可能是最常见的选项。有关不同类型的大容量存储的更多信息，请参阅[第7章](ch07.html
    "第7章 创建存储策略")，“创建存储策略”。'
- en: '**network filesystem**: the staging directory can be exported to the network
    via an NFS server and mounted by the target at boot-time. This is often done during
    the development phase in preference to repeated cycles of creating a disk image
    and reloading it onto the mass storage device, which is quite a slow process.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络文件系统**：暂存目录可以通过NFS服务器导出到网络，并在启动时由目标设备挂载。在开发阶段通常会这样做，而不是重复创建磁盘映像并重新加载到大容量存储设备上，这是一个相当慢的过程。'
- en: I will start with ramdisk and use it to illustrate a few refinements to the
    root filesystem, like adding user names and a device manager to create device
    nodes automatically. Then, I will show you how to create a disk image and, finally,
    how to use NFS to mount the root filesystem over a network.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我将从ramdisk开始，并用它来说明对根文件系统的一些改进，比如添加用户名和设备管理器以自动创建设备节点。然后，我将向您展示如何创建磁盘映像，最后，如何使用NFS在网络上挂载根文件系统。
- en: Creating a boot ramdisk
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建引导ramdisk
- en: A Linux boot ramdisk, strictly speaking, an **initial RAM filesystem** or **initramfs**,
    is a compressed `cpio` archive. `cpio` is an old Unix archive format, similar
    to TAR and ZIP but easier to decode and so requiring less code in the kernel.
    You need to configure your kernel with `CONFIG_BLK_DEV_INITRD` to support `initramfs`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Linux引导ramdisk，严格来说，是一个**初始RAM文件系统**或**initramfs**，是一个压缩的`cpio`存档。`cpio`是一个古老的Unix存档格式，类似于TAR和ZIP，但更容易解码，因此在内核中需要更少的代码。您需要配置内核以支持`initramfs`的`CONFIG_BLK_DEV_INITRD`。
- en: 'In fact, there are three different ways to create a boot ramdisk: as a standalone
    `cpio` archive, as a `cpio` archive embedded in the kernel image, and as a device
    table which the kernel build system processes as part of the build. The first
    option gives the most flexibility because we can mix and match kernels and ramdisks
    to our hearts content. However, it means that you have two files to deal with
    instead of one and not all bootloaders have the facility to load a separate ramdisk.
    I will show you how to build one into the kernel later.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，有三种不同的方法可以创建引导ramdisk：作为一个独立的`cpio`存档，作为嵌入在内核映像中的`cpio`存档，以及作为内核构建系统在构建过程中处理的设备表。第一种选项提供了最大的灵活性，因为我们可以随心所欲地混合和匹配内核和ramdisk。但是，这意味着您需要处理两个文件而不是一个，并且并非所有的引导加载程序都具有加载单独ramdisk的功能。稍后我将向您展示如何将其构建到内核中。
- en: Standalone ramdisk
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 独立的ramdisk
- en: 'The following sequence of instructions creates the archive, compresses it and
    adds a U-Boot header ready for loading onto the target:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 以下一系列指令创建存档，对其进行压缩，并添加一个U-Boot标头，以便加载到目标设备上：
- en: '[PRE26]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note that we ran `cpio` with the option `--owner root:root`. This is a quick
    fix for the file ownership problem mentioned earlier, making everything in the
    `cpio` file UID and GID 0.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们使用了`cpio`选项`--owner root:root`。这是对前面提到的文件所有权问题的一个快速修复，使`cpio`文件中的所有内容的UID和GID都为0。
- en: 'The final size of the `uRamdisk` file is ~ 2.9 MiB, with no kernel modules.
    Add to that 4.4 MiB for the kernel `zImage` file, and 440 KiB for U-Boot and this
    gives a total of 7.7 MiB of storage needed to boot this board. We are a little
    way off the 1.44 MiB floppy that started it all off. If size was a real problem,
    you could use one of these options:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`uRamdisk`文件的最终大小约为2.9 MiB，没有内核模块。再加上内核`zImage`文件的4.4 MiB，以及U-Boot的440 KiB，总共需要7.7
    MiB的存储空间来引导此板。我们离最初的1.44 MiB软盘还有一段距离。如果大小是一个真正的问题，您可以使用以下选项之一：'
- en: Make the kernel smaller by leaving out drivers and functions you don't need
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过留出您不需要的驱动程序和功能，使内核变得更小
- en: Make BusyBox smaller by leaving out utilities you don't need
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过留出您不需要的实用程序，使BusyBox变得更小
- en: Use uClibc or musl libc in place of glibc
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用uClibc或musl libc代替glibc
- en: Compile BusyBox statically
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态编译BusyBox
- en: Booting the ramdisk
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引导ramdisk
- en: The simplest thing we can do is to run a shell on the console so that we can
    interact with the device. We can do that by adding `rdinit=/bin/sh` to the kernel
    command line. Now, you can boot the device.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以做的最简单的事情是在控制台上运行一个shell，以便与设备进行交互。我们可以通过将`rdinit=/bin/sh`添加到内核命令行来实现这一点。现在，您可以引导设备。
- en: Booting with QEMU
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用QEMU引导
- en: 'QEMU has the option `-initrd` to load `initframfs` into memory, so the full
    command is now as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: QEMU有`-initrd`选项，可以将`initframfs`加载到内存中，因此完整的命令现在如下所示：
- en: '[PRE27]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Booting the BeagleBone Black
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 引导BeagleBone Black
- en: 'To boot the BeagleBone Black, boot to the U-Boot prompt and enter these commands:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动BeagleBone Black，请引导到U-Boot提示符，并输入以下命令：
- en: '[PRE28]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: If all goes well, you will get a root shell prompt on the console.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，您将在控制台上获得一个根shell提示符。
- en: Mounting proc
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 挂载proc
- en: 'Note that the `ps` command doesn''t work: that is because the `proc` filesystem
    has not been mounted yet. Try mounting it and run `ps` again.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`ps`命令不起作用：这是因为`proc`文件系统尚未被挂载。尝试挂载它，然后再次运行`ps`。
- en: 'A refinement to this setup is to write a shell script that contains things
    that need to be done at boot-up and give that as the parameter to `rdinit=`. The
    script would look like the following snippet:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 对此设置的一个改进是编写一个包含需要在启动时执行的内容的shell脚本，并将其作为`rdinit=`的参数。脚本将类似于以下代码片段：
- en: '[PRE29]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Using a shell as `init` in this way is very handy for quick hacks, for example,
    when you want to rescue a system with a broken `init` program. However, in most
    cases, you would use an `init` program, which we will cover further down.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式使用shell作为`init`对于快速修补非常方便，例如，当您想要修复带有损坏`init`程序的系统时。但是，在大多数情况下，您将使用一个`init`程序，我们将在后面进一步介绍。
- en: Building a ramdisk cpio into the kernel image
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将ramdisk cpio构建到内核映像中
- en: In some cases, it is preferable to build the ramdisk into the kernel image,
    for example, if the bootloader cannot handle a ramdisk file. To do this, change
    the kernel configuration and set `CONFIG_INITRAMFS_SOURCE` to the full path of
    the `cpio` archive you created earlier. If you are using `menuconfig`, it is in
    **General setup** | **Initramfs source file(s)**. Note that it has to be the uncompressed
    `cpio` file ending in `.cpio`; not the gzipped version. Then, build the kernel.
    You should see that it is larger than before.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，最好将ramdisk构建到内核映像中，例如，如果引导加载程序无法处理ramdisk文件。要做到这一点，更改内核配置并将`CONFIG_INITRAMFS_SOURCE`设置为您之前创建的`cpio`存档的完整路径。如果您使用`menuconfig`，它在**常规设置**
    | **Initramfs源文件**中。请注意，它必须是以`.cpio`结尾的未压缩`cpio`文件；而不是经过gzip压缩的版本。然后，构建内核。您应该看到它比以前大。
- en: 'Booting is the same as before, except that there is no ramdisk file. For QEMU,
    the command is like this:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 引导与以前相同，只是没有ramdisk文件。对于QEMU，命令如下：
- en: '[PRE30]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'For the BeagleBone Black, enter these commands into U-Boot:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 对于BeagleBone Black，将这些命令输入U-Boot：
- en: '[PRE31]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Of course, you must remember to rebuild the kernel each time you change the
    contents of the ramdisk and regenerate the `.cpio` file.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您必须记住每次更改ramdisk的内容并重新生成`.cpio`文件时都要重新构建内核。
- en: Another way to build a kernel with ramdisk
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 另一种构建带有ramdisk的内核的方法
- en: An interesting way to build the ramdisk into the kernel image is by using a
    **device table** to generate a `cpio` archive. A `device table` is a text file
    which lists the files, directories, device nodes, and links that go into the archive.
    The overwhelming advantage is that you can create entries in the `cpio` file that
    are owned by root, or any other UID, without having root privileges yourself.
    You can even create device nodes. All this is possible because the archive is
    just a data file. It is only when it is expanded by Linux at boot time that real
    files and directories get created, using the attributes you have specified.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 将ramdisk构建到内核映像中的一个有趣的方法是使用**设备表**生成`cpio`存档。`设备表`是一个文本文件，列出了存档中包含的文件、目录、设备节点和链接。压倒性的优势在于，您可以在`cpio`文件中创建属于root或任何其他UID的条目，而无需自己拥有root权限。您甚至可以创建设备节点。所有这些都是可能的，因为存档只是一个数据文件。只有在Linux在引导时扩展它时，才会使用您指定的属性创建真实的文件和目录。
- en: 'Here is a device table for our simple `rootfs`, but missing most of the symbolic
    links to `busybox` to make it manageable:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们简单的`rootfs`的设备表，但缺少大部分到`busybox`的符号链接，以便更易管理：
- en: '[PRE32]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The syntax is fairly obvious:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 语法相当明显：
- en: '`dir <name> <mode> <uid> <gid>`'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dir <name> <mode> <uid> <gid>`'
- en: '`file <name> <location> <mode> <uid> <gid>`'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`file <name> <location> <mode> <uid> <gid>`'
- en: '`nod <name> <mode> <uid> <gid> <dev_type> <maj> <min>`'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nod <name> <mode> <uid> <gid> <dev_type> <maj> <min>`'
- en: '`slink <name> <target> <mode> <uid> <gid>`'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`slink <name> <target> <mode> <uid> <gid>`'
- en: The kernel provides a tool that reads this file and creates a `cpio` archive.
    The source is in `usr/gen_init_cpio.c`. There is a handy script in `scripts/gen_initramfs_list.sh`
    that creates a device table from a given directory, which saves a lot of typing.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 内核提供了一个工具，读取此文件并创建`cpio`存档。源代码在`usr/gen_init_cpio.c`中。`scripts/gen_initramfs_list.sh`中有一个方便的脚本，它从给定目录创建设备表，这样可以节省很多输入。
- en: To complete, the task, you need to set `CONFIG_INITRAMFS_SOURCE` to point to
    the device table file and then build the kernel. Everything else is the same as
    before.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成任务，您需要将`CONFIG_INITRAMFS_SOURCE`设置为指向设备表文件，然后构建内核。其他一切都和以前一样。
- en: The old initrd format
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 旧的initrd格式
- en: There is an older format for a Linux ramdisk, known as `initrd`. It was the
    only format available before Linux 2.6 and is still needed if you are using the
    mmu-less variant of Linux, uCLinux. It is pretty obscure and I will not cover
    it here. There is more information in the kernel source, in `Documentation/initrd.txt`.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: Linux ramdisk的旧格式称为`initrd`。在Linux 2.6之前，这是唯一可用的格式，并且如果您使用Linux的无mmu变体uCLinux，则仍然需要它。它相当晦涩，我在这里不会涉及。内核源代码中有更多信息，在`Documentation/initrd.txt`中。
- en: The init program
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: init程序
- en: Running a shell, or even a shell script, at boot time is fine for simple cases,
    but really you need something more flexible. Normally, Unix systems run a program
    called `init` that starts up and monitors other programs. Over the years, there
    have been many `init` programs, some of which I will describe in [Chapter 9](ch09.html
    "Chapter 9. Starting up - the init Program"), *Starting up - the init Program*.
    For now, I will briefly introduce the `init` from BusyBox.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在引导时运行shell，甚至是shell脚本，对于简单情况来说是可以的，但实际上您需要更灵活的东西。通常，Unix系统运行一个名为`init`的程序，它启动并监视其他程序。多年来，已经有许多`init`程序，其中一些我将在[第9章](ch09.html
    "第9章。启动 - init程序")中描述，*启动 - init程序*。现在，我将简要介绍BusyBox中的`init`。
- en: '`init` begins by reading the configuration file, `/etc/inittab`. Here is a
    simple example which is adequate for our needs:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`init`开始读取配置文件`/etc/inittab`。这是一个对我们的需求足够简单的示例：'
- en: '[PRE33]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The first line runs a shell script, `rcS`, when `init` is started. The second
    line prints the message **Please press Enter to activate this console** to the
    console, and starts a shell when you press *Enter*. The leading `-` before `/bin/ash`
    means that it will be a login shell, which sources `/etc/profile` and `$HOME/.profile`
    before giving the shell prompt. One of the advantages of launching the shell like
    this is that job control is enabled. The most immediate effect is that you can
    use *Ctrl* + *C* to terminate the current program. Maybe you didn't notice it
    before but, wait until you run the `ping` program and find you can't stop it!
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: BusyBox `init` provides a default `inittab` if none is present in the root filesystem.
    It is a little more extensive than the preceding one.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: 'The script `/etc/init.d/rcS` is the place to put initialization commands that
    need to be performed at boot, for example, mounting the `proc` and `sysfs` filesystems:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Make sure that you make `rcS` executable, like this:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'You can try it out on QEMU by changing the `-append` parameter, like this:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'To achieve the same on the BeagelBone Black, you need to change the `bootargs`
    variable in U-Boot as shown:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Configuring user accounts
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As I have hinted already, it is not good practice to run all programs as root
    since, if one is compromised by an outside attack, then the whole system is at
    risk and a misbehaving program can do more damage if it is running as root. It
    is preferable to create unprivileged user accounts and use them where full root
    is not necessary.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: 'User names are configured in `/etc/passwd`. There is one line per user, with
    seven fields of information separated by colons:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: The login name
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A hash code used to verify the password , or more usually an `x` to indicate
    that the password is stored in `/etc/shadow`
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: UID
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GID
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A comment field, often left blank
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The user's home directory
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (Optional) the shell this user will use
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, this creates users `root` with UID 0 and `daemon` with UID 1:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Setting the shell for user daemon to `/bin/false` ensures that any attempt to
    log on with that name will fail.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Various programs have to read `/etc/passwd` so as to be able to look up UIDs
    and names, and so it has to be word-readable. That is a problem if the password
    hashes are stored in there because a malicious program would be able to take a
    copy and discover the actual passwords using a variety of cracker programs. Therefore,
    to reduce the exposure of this sensitive information, the passwords are stored
    in `/etc/shadow` and an `x` is placed in the password field to indicate that this
    is the case. `/etc/shadow` is only accessible as `root`, and, so as long as the
    `root` user is restricted, the passwords are safe.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: 'The shadow password file consists of one entry per user, made up of nine fields.
    Here is an example that mirrors the `passwd` file shown in the preceding paragraph:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The first two fields are the username and the password hash. The remaining seven
    are related to password aging, which is not usually an issue on embedded devices.
    If you are curious about the full details, refer to the manual page *shadow(5)*.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: In the example, the password for `root` is empty, meaning that `root` can log
    on without giving a password, which is useful during development, but not for
    production! You can generate a password hash by using the command `mkpasswd` or
    by running the `passwd` command on the target and copy and pasting the hash field
    from `/etc/shadow` on the target into the default shadow file in the staging directory.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: The password for daemon is `*`, which will not match any logon password, once
    again ensuring that the daemon cannot be used as a regular user account.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: 'Group names are stored in a similar way in `/etc/group`. The format is as follows:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: The name of the group
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The group password, usually an `x` character, indicating that there is no group
    password
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The GID
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An optional list of users who belong to this group, separated by commas.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is an example:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Adding user accounts to the root filesystem
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Firstly, you have to add to your staging directory `etc/passwd`, `etc/shadow`,
    and `etc/group`, as shown in the preceding section. Make sure that the permissions
    of shadow are 0600.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: 'The login procedure is started by a program called `getty`, which is part of
    BusyBox. You launch it from `inittab` using the keyword `respawn`, which restarts
    `getty` when a login shell is terminated, so `inittab` should read like this:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Then rebuild the ramdisk and try it out using QEMU or BeagelBone Black as before.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: Starting a daemon process
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Typically, you would want to run certain background processes at start up. Let's
    take the log daemon, `syslogd`, as an example. The purpose of `syslogd` is to
    accumulate log messages from other programs, mostly other daemons. Naturally,
    BusyBox has an applet for that!
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: 'Starting the daemon is as simple as adding a line like this to `etc/inittab`:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '`respawn` means that, if the program terminates, it will be automatically restarted;
    `-n` means that it should run as a foreground process. The log is written to `/var/log/messages`.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You may also want to start `klogd` in the same way: `klogd` sends kernel log
    messages to `syslogd` so that they can be logged to permanent storage.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: As an aside, I should mention that, in the case of a typical embedded Linux
    system, writing log files to flash memory is not such a good idea as it will wear
    it out. I will cover the options for logging in [Chapter 7](ch07.html "Chapter 7. Creating
    a Storage Strategy"), *Creating a Storage Strategy*.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: A better way of managing device nodes
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Creating device nodes statically with `mknod` is quite hard work and inflexible.
    There are other ways to create device nodes automatically on demand:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '`devtmpfs`: This is a pseudo filesystem that you mount over `/dev` at boot
    time. The kernel populates it with device nodes for all the devices that the kernel
    currently knows about and creates nodes for new devices as they are detected at
    runtime. The nodes are owned by `root` and have default permissions of 0600\.
    Some well-known device nodes, such as `/dev/null` and `/dev/random`, override
    the default to 0666 (see `struct` `memdev` in `drivers/char/mem.c`).'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mdev`: This is a BusyBox applet that is used to populate a directory with
    device nodes and to create new nodes as needed. There is a configuration file,
    `/etc/mdev.conf`, which contains rules for ownership and the mode of the nodes.'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`udev`: This is now part of `systemd` and is the solution you will find on
    desktop Linux and some embedded devices. It is very flexible and a good choice
    for higher end embedded devices.'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  id: totrans-263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although both `mdev` and `udev` create the device nodes themselves, it is more
    usual to let `devtmpfs` do that job and use `mdev/udev` as a layer on top to implement
    the policy for setting ownership and permissions.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: An example using devtmpfs
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you have booted up one of the earlier ramdisk examples, trying out `devtmpfs`
    is as simple as entering this command:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'You should see that `/dev` is full of device nodes. For a permanent fix, add
    this to `/etc/init.d/rcS`:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In point of fact, kernel initialization does this automatically unless you have
    supplied an `initramfs` ramdisk as we have done! To see the code, look in the
    `init/do_mounts.c`, function `prepare_namespace()`.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: An example using mdev
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While `mdev` is a bit more complex to set up, it does allow you to modify the
    permissions of device nodes as they are created. Firstly, there is a startup phase,
    selected by the `-s` option, when `mdev` scans the `/sys` directory looking for
    information about current devices and populates the `/dev` directory with the
    corresponding nodes.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to keep track of new devices coming on line and create nodes for
    them as well, you need to make `mdev` a hotplug client by writing to `/proc/sys/kernel/hotplug`.
    These additions to `/etc/init.d/rcS` will achieve all of that:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The default mode is 660 and ownership is `root:root`. You can change that by
    adding rules in `/etc/mdev.conf`. For example, to give the `null`, `random`, and
    `urandom` devices their correct modes, you would add this to `/etc/mdev.conf`:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The format is documented in the BusyBox source code in `docs/mdev.txt` and there
    are more examples in the directory named `examples`.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: Are static device nodes so bad after all?
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Statically created device nodes do have one advantage: they don''t take any
    time during boot to create, whereas the other methods do. If minimizing boot time
    is a priority, using statically-created device nodes will save a measurable amount
    of time.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the network
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Next, let's look at some basic network configurations so that we can communicate
    with the outside world. I am assuming that there is an Ethernet interface, `eth0`,
    and that we only need a simple IP v4 configuration.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: 'These examples use the network utilities that are part of BusyBox, and are
    sufficient for a simple use case, using the `old-but-reliable ifup` and `ifdown`
    programs. You can read the man pages on both for more details. The main network
    configuration is stored in `/etc/network/interfaces`. You will need to create
    these directories in the staging directory:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'For a static IP address, `etc/network/interfaces` would look like this:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'For a dynamic IP address allocated using DHCP, `etc/network/interfaces` would
    look like this:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: You will also have to configure a DHCP client program. BusyBox has one named
    `udchpcd`. It needs a shell script that should go in `/usr/share/udhcpc/default.script`.
    There is a suitable default in the BusyBox source code in the directory `examples//udhcp/simple.script`.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: Network components for glibc
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`glibc` uses a mechanism known as the **name service switch** (**NSS**) to
    control the way that names are resolved to numbers for networking and users. User
    names, for example, may be resolved to UIDs via the file `/etc/passwd`; network
    services such as HTTP can be resolved to the service port number via `/etc/services`,
    and so on. All this is configured by `/etc/nsswitch.conf`, see the manual page,
    *nss(5)* for full details. Here is a simple example that will suffice for most
    embedded Linux implementations:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Everything is resolved by the correspondingly named file in `/etc`, except for
    the host names, which may additionally be resolved by a DNS lookup.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: 'To make this work, you need to populate `/etc` with those files. Networks,
    protocols, and services are the same across all Linux systems, so they can be
    copied from `/etc` in your development PC. `/etc/hosts` should, at least contain,
    the loopback address:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: We will come to the others, `passwd`, `group`, and `shadow`, later.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: 'The last piece of the jigsaw is the libraries that perform the name resolution.
    They are plugins that are loaded as needed based on the contents of `nsswitch.conf`,
    meaning that they do not show up as dependencies if you use `readelf` or similar.
    You will simply have to copy them from the toolchain''s `sysroot`:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Creating filesystem images with device tables
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The kernel has a utility, `gen_init_cpio`, that creates a `cpio` file based
    on format instructions set out in a text file, called a `device table`, which
    allows a non-root user to create device nodes and to allocate arbitrary UID and
    GID values to any file or directory.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: 'The same concept has been applied to tools that create other filesystem image
    formats:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '`jffs2`: `mkfs.jffs2`'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ubifs`: `mkfs.ubifs`'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ext2`: `genext2fs`'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will look at `jffs2` and `ubifs` in [Chapter 7](ch07.html "Chapter 7. Creating
    a Storage Strategy"), *Creating a Storage Strategy*, when we look at filesystems
    for flash memory. The third, `ext2`, is a fairly old format for hard drives.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: 'They each take a device table file with the format `<name> <type> <mode> <uid>
    <gid> <major> <minor> <start> <inc> <count>` in which the following applies:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '`name`: Filename'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`type`: One of the following:'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`f`: A regular file'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`d`: A directory'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`c`: A character special device file'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`b`: A block special device file'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`p`: A FIFO (named pipe)'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`uid` The UID of the file'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gid`: The GID of the file'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`major` and `minor`: the device numbers (device nodes only)'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`start`, `inc`, and `count`: (device nodes only) allow you to create a group
    of device nodes starting from the `minor` number in `start`'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You do not have to specify every file, as with `gen_init_cpio`: you just have
    to point them at a directory – the staging directory – and list the changes and
    exceptions you need to make in the final filesystem image.'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple example which populates static device nodes for us is as follows:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Then, use `genext2fs` to generate a filesystem image of 4 MiB (that is 4,096
    blocks of the default size, 1,024 bytes):'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Now, you can copy the resulting image, `rootfs.ext`, to an SD card or similar.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: Putting the root filesytem onto an SD card
  id: totrans-323
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is an example of mounting a filesystem from a normal block device, such
    as an SD card. The same principles apply to other filesystem types and we will
    look at them in more detail in [Chapter 7](ch07.html "Chapter 7. Creating a Storage
    Strategy"), *Creating a Storage Strategy*.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming that you have a device with an SD card, and that the first partition
    is used for the boot files, `MLO` and `u-boot.img` – as on a BeagleBone Black.
    Assume also that you have used `genext2fs` to create a filesystem image. To copy
    it to the SD card, insert the card and identify the block device it has been assigned:
    typically `/dev/sd` or `/dev/mmcblk0`. If it is the latter, copy the filesystem
    image to the second partition:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Then, slot the SD card into the device, and set the kernel command line to
    `root=/dev/mmcblk0p2`. The complete boot sequence is as follows:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Mounting the root filesystem using NFS
  id: totrans-329
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If your device has a network interface, it is best to mount the root filesystem
    over the network during development. It gives you access to almost unlimited storage
    so you can add in debug tools and executables with large symbol tables. As an
    added bonus, updates made to the root filesystem hosted on the development machine
    are made available on the target immediately. You also have a copy of log files.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: 'For this to work, your kernel has to be configured with `CONFIG_ROOT_NFS`.
    Then, you can configure Linux to do the mount at boot time by adding the following
    to the kernel command line:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Give the details of the NFS export as follows:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Configure the network interface that connects to the NFS server so that it
    is available at boot time, before the `init` program runs by using this command:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: There is more information about NFS root mounts in the kernel source in `Documentation/filesystems/nfs/nfsroot.txt`.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: 'You also need to install and configure an NFS server on your host which, for
    Ubuntu, you can do with this command:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The NFS server needs to be told which directories are being exported to the
    network, which is controlled by `/etc/exports`. Add a line like this one to that
    file:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Then, restart the server to pick up the change which, for Ubuntu, is:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Testing with QEMU
  id: totrans-344
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following script creates a virtual network between the network device `tap0`
    on the host and `eth0` on the target using a pair of static IPv4 addresses and
    then launches QEMU with the parameters to use `tap0` as the emulated interface.
    You will need to change the path to the root filesystem to be the full path to
    your staging directory, and maybe the IP addresses if they conflict with your
    network configuration:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The script is available as `run-qemu-nfs.sh`.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: It should boot up as before, but now using the staging directory directly via
    the NFS export. Any files that you create in that directory will be immediately
    visible to the target device and any files created in the device will be visible
    to the development PC.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: Testing with BeagleBone Black
  id: totrans-349
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In a similar way, you can enter these commands at the U-Boot prompt of the
    BeagleBone Black:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Then; to boot it, load the kernel and `dtb` from `sdcard,` as before:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Problems with file permissions
  id: totrans-354
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The files that were already in the staging directory are owned by you and will
    show up on the target when you run `ls -l` with whatever your UID is, typically
    1,000\. Any files created by the target device will be owned by root. The whole
    thing is a mess.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, there is no simple way out. The best advice is to make a copy
    of the staging directory and change ownership to `root:root` (using `sudo chown
    -R 0:0 *`) and export this directory as the NFS mount. It reduces the inconvenience
    of having just one copy of the root filesystem shared between development and
    target systems.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: Using TFTP to load the kernel
  id: totrans-357
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When working with real hardware such as the BeagleBone Black, it is best to
    load the kernel over the network, especially when the root filesystem is mounted
    via NFS. In this way, you are not using any local storage on the device. It saves
    time if you don't have to keep re-flashing the memory and means that you can get
    work done while the flash storage drivers are still being developed (it happens).
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: U-Boot has supported the **Trivial File Transfer Protocol** (**TFTP**) for many
    years. Firstly, you need to install a `tftp` daemon on your development machine.
    On Ubuntu, you would install the `tftpd-hpa` package, which grants read access
    to files in the directory `/var/lib/tftpboot` to `tftp` clients like U-Boot.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming that you have copied `zImage` and `am335x-boneblack.dtb` into `/var/lib/tftpboot`,
    enter these commands into U-Boot to load and boot:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'It is fairly common for the response to `tftpboot` to look like this:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The row of `T` characters on the last line indicate that there is something
    wrong and the TFTP requests are timing out. The most common reasons are as follows:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: Incorrect IP address for server.
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TFTP daemon not running on server.
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Firewall on server is blocking the TFTP protocol. Most firewalls do indeed block
    the TFTP port, 69, by default.
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this case, the tftp daemon was not running, so I started it with the following
    command:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Additional reading
  id: totrans-370
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Filesystem Hierarchy Standard*, currently at version 3.0 available at [http://refspecs.linuxfoundation.org/fhs.shtml](http://refspecs.linuxfoundation.org/fhs.shtml).'
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*ramfs, rootfs and initramfs , Rob Landley*, October 17, 2005, which is part
    of the Linux source code available at `Documentation/filesystems/ramfs-rootfs-initramfs.txt`.'
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  id: totrans-373
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the strengths of Linux is that it can support a wide range of root filesystems
    which allow it to be tailored to suit a wide range of needs. We have seen that
    it is possible to construct a simple root filesystem manually with a small number
    of components, and that BusyBox is especially useful in this regard. By going
    through the process one step at a time, it has given us insight into some of the
    basic workings of Linux systems, including network configuration and user accounts.
    However, the task rapidly becomes unmanageable as devices get more complex. And,
    there is the ever-present worry that there may be a security hole in the implementation
    which we have not noticed. In the next chapter, we will look at using embedded
    build systems to help us out.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
