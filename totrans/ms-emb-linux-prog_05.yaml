- en: Chapter 5. Building a Root Filesystem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The root filesystem is the fourth and final element of embedded Linux. Once
    you have read this chapter, you will be able build, boot, and run a simple embedded
    Linux system.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter explores the fundamental concepts behind the root filesystem by
    building one from scratch. The main aim is to provide the background information
    that you need to understand and make best use of build systems like Buildroot
    and the Yocto Project, which I will cover in [Chapter 6](ch06.html "Chapter 6. Selecting
    a Build System"), *Selecting a Build System*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The techniques I will describe here are broadly known as **roll your own**
    or **RYO**. Back in the earlier days of embedded Linux, it was the only way to
    create a root filesystem. There are still some use cases where an RYO root filesystem
    is applicable, for example, when the amount of RAM or storage is very limited,
    for quick demonstrations, or for any case in which your requirements are not (easily)
    covered by the standard build system tools. Nevertheless, these cases are quite
    rare. Let me emphasize that the purpose of this chapter is educational, it is
    not meant to be a recipe for building everyday embedded systems: use the tools
    described in the next chapter for that.'
  prefs: []
  type: TYPE_NORMAL
- en: The first objective is to create a minimal root filesystem that will give us
    a shell prompt. Then, using that as a base, we will add scripts to start up other
    programs and configure a network interface and user permissions. Knowing how to
    build the root filesystem from scratch is a useful skill and it will help you
    to understand what is going on when we look at more complex examples in later
    chapters.
  prefs: []
  type: TYPE_NORMAL
- en: What should be in the root filesystem?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The kernel will get a root filesystem, either as a ramdisk, passed as a pointer
    from the bootloader, or by mounting the block device given on the kernel command
    line by the `root=` parameter. Once it has a root filesystem, the kernel will
    execute the first program, by default named `init`, as described in the section
    *Early Userspace* in [Chapter 4](ch04.html "Chapter 4. Porting and Configuring
    the Kernel"), *Porting and Configuring the Kernel*. Then, as far as the kernel
    is concerned, its job is complete. It is up to the `init` program to begin processing
    scripts, start other programs, and so on, by calling system functions in the C
    library, which translate into kernel system calls.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make a useful system, you need these components as a minimum:'
  prefs: []
  type: TYPE_NORMAL
- en: '**init**: The program that starts everything off, usually by running a series
    of scripts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**shell**: Needed to give you a command prompt but, more importantly, to run
    the shell scripts called by `init` and other programs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**daemons**: Various server programs, started by `init`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**libraries**: Usually, the programs mentioned so far are linked with shared
    libraries which must be present in the root filesystem.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Configuration files**: The configuration for `init` and other daemons is
    stored in a series of ASCII text files, usually in the `/etc` directory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Device nodes**: The special files that give access to various device drivers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**/proc and /sys**: Two pseudo filesystems that represent kernel data structures
    as a hierarchy of directories and files. Many programs and library functions read
    these files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**kernel modules**: If you have configured some parts of your kernel to be
    modules, they will be here, usually in `/lib/modules/[kernel version]`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition, there are the system application or applications that make the
    device do the job it is intended for, and the runtime end user data that they
    collect.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an aside, it is possible to condense all of the above into a single program.
    You could create a statically linked program that is started instead of `init`
    and runs no others. I have come across such a configuration only once. For example,
    if your program was named `/myprog`, you would put the following command in the
    kernel command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, if the root filesystem was loaded as a ramdisk, you would put the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The downside of this approach is that you can't make use of the many tools that
    normally go into an embedded system; you have to do everything yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Directory layout
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Interestingly, Linux does not care about the layout of files and directories
    beyond the existence of the program named by `init=` or `rdinit=`, so you are
    free to put things wherever you like. As an example, compare the file layout of
    a device running Android to that of a desktop Linux distribution: they are almost
    completely different.'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, many programs expect certain files to be in certain places, and it
    helps us developers if devices use a similar layout, Android aside. The basic
    layout of a Linux system is defined in the **Filesystem Hierarchy Standard** (**FHS**),
    see the reference at the end of this chapter. The FHS covers all implementations
    of Linux operating systems from the largest to the smallest. Embedded devices
    have a sub-set based on need but it usually includes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/bin`: programs essential for all users'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/dev`: device nodes and other special files'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/etc`: system configuration'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/lib`: essential shared libraries, for example, those that make up the C library'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/proc`: the `proc` filesystem'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/sbin`: programs essential to the system administrator'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/sys`: the `sysfs` filesystem'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/tmp`: a place to put temporary or volatile files'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/usr`: as a minimum, this should contain the directories `/usr/bin`, `/usr/lib`
    and `/usr/sbin,` which contain additional programs, libraries, and system administrator
    utilities'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/var`: a hierarchy of files and directories that may be modified at runtime,
    for example, log messages, some of which must be retained after boot'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are some subtle distinctions here. The difference between `/bin` and
    `/sbin` is simply that `/sbin` need not be included in the search path for non-root
    users. Users of Red Hat-derived distributions will be familiar with this. The
    significance of `/usr` is that it may be in a separate partition from the root
    filesystem so it cannot contain anything that is needed to boot the system up.
    That is what essential means in the preceding description: it contains files that
    are needed at boot time and so must be part of the root filesystem.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While it might seem like overkill to have four directories to store programs,
    a counter argument would be that it does no harm, and it may even do some good
    because it allows you to store `/usr` in a different filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: Staging directory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You should begin by creating a staging directory on your host computer where
    you can assemble the files that will eventually be transferred to the target.
    In the following examples, I have used `~/rootfs`. You need to create a skeleton
    directory structure in that, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'To see the directory hierarchy more clearly you can use the handy `tree` command,
    used in the following example with the `-d` option to show only directories:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: POSIX file access permissions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Every process which, in the context of this discussion, means every running
    program, belongs to a user and one or more groups. The user is represented by
    a 32-bit number called the **user ID** or **UID**. Information about users, including
    the mapping from a UID to a name, is kept in `/etc/passwd`. Likewise, groups are
    represented by a **group ID** or **GID**, with information kept in `/etc/group`.
    There is always a root user with a UID of 0 and a root group with a GID of 0\.
    The root user is also called the super-user because, in a default configuration,
    it bypasses most permission checks and can access all the resources in the system.
    Security in Linux-based systems is mainly about restricting access to the root
    account.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each file and directory also has an owner and belongs to exactly one group.
    The level of access a process has to a file or directory is controlled by a set
    of access permission flags, called the mode of the file. There are three collections
    of three bits: the first collection applies to the owner of the file, the second
    to members of the same group as the file, and the last to everyone else, the rest
    of the world. The bits are for read (r), write (w), and execute (x) permissions
    on the file. Since three bits fit neatly into an octal digit, they are usually
    represented in octal, as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![POSIX file access permissions](img/B03982_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'There is a further group of three bits that have special meanings:'
  prefs: []
  type: TYPE_NORMAL
- en: '**SUID (4)**: If the file is an executable, change the effective UID of the
    process to that of the owner of the file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SGID (2)**: If the file is an executable, change the effective GID of the
    process to that of the group of the file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sticky (1)**: In a directory, restrict deletion so that one user cannot delete
    files that are owned by another user. This is usually set on `/tmp` and `/var/tmp`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The SUID bit is probably the most often used. It gives non-root users a temporary
    privilege escalation to super-user to perform a task. A good example is the `ping`
    program: `ping` opens a raw socket which is a privileged operation. In order for
    normal users to use `ping`, it is normally owned by the root and has the SUID
    bit set so that, when you run `ping`, it executes with UID 0 regardless of your
    UID.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To set these bits, use the octal numbers, 4, 2, 1, with the `chmod` command.
    For example, to set SUID on `/bin/ping` in your staging root directory, you could
    use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Note the `s` in the last file listing: that is the indication that SUID is
    set.'
  prefs: []
  type: TYPE_NORMAL
- en: File ownership permissions in the staging directory
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For security and stability reasons, it is vitally important to pay attention
    to the ownership and permissions of the files that will be placed on the target
    device. Generally speaking, you want to restrict sensitive resources to be accessible
    only by the root and to run as many of the programs using non-root users so that,
    if they are compromised by an outside attack, they offer as few system resources
    to the attacker as possible. For example, the device node `/dev/mem` gives access
    to system memory, which is necessary in some programs. But, if it is readable
    and writeable by everyone, then there is no security because everyone can access
    everything. So `/dev/mem` should be owned by root, belong to the root group and
    have a mode of 600, which denies read and write access to all but the owner.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a problem with the staging directory though. The files you create
    there will be owned by you but, when they are installed on the device, they should
    belong to specific owners and groups, mostly the root user. An obvious fix is
    to change the ownership at this stage with the command shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The problem is that you need root privileges to run that command and, from that
    point onward, you will need to be root to modify any files in the staging directory.
    Before you know it, you are doing all your development logged on as root, which
    is not a good idea. This is a problem that we will come back to later.
  prefs: []
  type: TYPE_NORMAL
- en: Programs for the root filesystem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, it is time to start populating the root filesystem with the essential programs
    and the supporting libraries, configuration, and data files that it needs to operate,
    beginning with an overview of the types of program you will need.
  prefs: []
  type: TYPE_NORMAL
- en: The init program
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You have seen in the previous chapter that `init` is the first program to be
    run and so has PID 1\. It runs as the root user and so has maximum access to system
    resources. Usually, it runs shell scripts which start daemons: a daemon is a program
    that runs in the background with no connection to a terminal, in other places
    it would be called a server program.'
  prefs: []
  type: TYPE_NORMAL
- en: Shell
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We need a shell to run scripts and to give us a command-line prompt so that
    we can interact with the system. An interactive shell is probably not necessary
    in a production device, but it is useful for development, debugging, and maintenance.
    There are various shells in common use in embedded systems:'
  prefs: []
  type: TYPE_NORMAL
- en: '`bash`: is the big beast that we all know and love from desktop Linux. It is
    a superset of the Unix Bourne shell, with many extensions or *bashisms*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ash`: also based on the Bourne shell, and has a long history with the BSD
    variants of Unix. Busybox has a version of ash which has been extended to make
    it more compatible with `bash`. It is much smaller than `bash` and hence is a
    very popular choice for embedded systems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hush`: is a very small shell that we briefly looked at in the chapter on bootloaders.
    It is useful on devices with very little memory. There is a version in BusyBox.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are using `ash` or `hush` as the shell on the target, make sure that
    you test your shell scripts on the target. It is very tempting to test them only
    on the host, using `bash`, and then be surprised that they don't work when you
    copy them to the target.
  prefs: []
  type: TYPE_NORMAL
- en: Utilities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The shell is just a way of launching other programs and a shell script is little
    more than a list of programs to run, with some flow control and a means of passing
    information between programs. To make a shell useful, you need the utility programs
    that the Unix command-line is based on. Even for a basic root filesystem, there
    are approximately 50 utilities, which presents two problems. Firstly, tracking
    down the source code for each and cross compiling it would be quite a big job.
    Secondly, the resulting collection of programs would take up several tens of megabytes,
    which was a real problem in the early days of embedded Linux when a few megabytes
    was all you had. To solve this problem, BusyBox was born.
  prefs: []
  type: TYPE_NORMAL
- en: BusyBox to the rescue!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The genesis of BusyBox had nothing to do with embedded Linux. The project was
    instigated in 1996 by Bruce Perens for the Debian installer so that he could boot
    Linux from a 1.44 MB floppy disk. Coincidentally, that was about the size of the
    storage on contemporary devices and so the embedded Linux community quickly took
    it up. BusyBox has been at the heart of embedded Linux ever since.
  prefs: []
  type: TYPE_NORMAL
- en: 'BusyBox was written from scratch to perform the essential functions of those
    essential Linux utilities. The developers took advantage of the 80:20 rule: the
    most useful 80% of a program is implemented in 20% of the code. Hence, BusyBox
    tools implement a subset of the functions of the desktop equivalents, but they
    do enough to be useful in the majority of cases.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another trick BusyBox employs is to combine all the tools together into a single
    binary, making it easy to share code between them. It works like this: BusyBox
    is a collection of applets, each of which exports its main function in the form
    `[applet]_main`. For example, the `cat` command is implemented in `coreutils/cat.c`
    and exports `cat_main`. The main function of BusyBox itself dispatches the call
    to the correct applet based on the command-line arguments.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, to read a file, you can launch `busybox` with the name of the applet you
    want to run, followed by any arguments the applet expects, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: You can also run `busybox` with no arguments to get a list of all the applets
    that have been compiled.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using BusyBox in this way is rather clumsy. A better way to get BusyBox to
    run the `cat` applet is to create a symbolic link from `/bin/cat` to `/bin/busybox`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'When you type `cat` at the command line, `busybox` is the program that actually
    runs. BusyBox only has to check the command tail passed in `argv[0]`, which will
    be `/bin/cat`, extract the application name, `cat`, and do a table look-up to
    match `cat` with `cat_main`. All this is in `libbb/appletlib.c` in this section
    of code (slightly simplified):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: BusyBox has over three hundred applets including an `init` program, several
    shells of varying levels of complexity, and utilities for most admin tasks. There
    is even a simple version of the `vi` editor so you can change text files on your
    device.
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, a typical installation of BusyBox consists of a single program
    with a symbolic link for each applet, but which behaves exactly as if it were
    a collection of individual applications.
  prefs: []
  type: TYPE_NORMAL
- en: Building BusyBox
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'BusyBox uses the same `Kconfig` and `Kbuild` system of the kernel, so cross
    compiling is straightforward. You can get the source by cloning the git archive
    and checking out the version you want (1_24_1 was the latest at the time of writing),
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also download the corresponding `tarball` file from [http://busybox.net/downloads](http://busybox.net/downloads).
    Then, configure BusyBox, starting in this case with the default configuration,
    which enables pretty much all of the features of BusyBox:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, you probably want to run `make menuconfig` to fine tune the
    configuration. You almost certainly want to set the install path in **Busybox
    Settings** | **Installation Options** (`CONFIG_PREFIX`) to point to the staging
    directory. Then, you can cross compile in the usual way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The result is the executable, `busybox`. For a `defconfig` build for ARM v7a,
    it comes out at about 900 KiB. If that is too big for you, you can slim it down
    by configuring out the utilities you don't need.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install BusyBox, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This will copy the binary to the directory configured in `CONFIG_PREFIX` and
    create all the symbolic links to it.
  prefs: []
  type: TYPE_NORMAL
- en: ToyBox – an alternative to BusyBox
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: BusyBox is not the only game in town. For example, Android has an equivalent
    named Toolbox, but it is more tuned to the needs of Android and not useful in
    a general purpose embedded environment. A more useful option is ToyBox, a project
    started and maintained by Rob Landley, who was previously a maintainer of BusyBox.
    ToyBox has the same aim as BusyBox, but with more emphasis on complying with standards,
    especially POSIX-2008 and LSB 4.1, and less on compatibility with GNU extensions
    to those standards. ToyBox is smaller than BusyBox, partly because it implements
    fewer applets.
  prefs: []
  type: TYPE_NORMAL
- en: However, the main difference is the license, BSD rather than GPL v2, which makes
    it license-compatible with operating systems with a BSD-licensed user space, such
    as Android itself.
  prefs: []
  type: TYPE_NORMAL
- en: Libraries for the root filesystem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Programs are linked with libraries. You could link them all statically, in which
    case, there would be no libraries on the target device. But, that takes up an
    unnecessarily large amount of storage if you have more than two or three programs.
    So, you need to copy shared libraries from the toolchain to the staging directory.
    How do you know which libraries?
  prefs: []
  type: TYPE_NORMAL
- en: One option is to copy all of them since they must be of some use, otherwise
    they wouldn't exist! That is certainly logical and, if you are creating a platform
    to be used by others for a range of applications, that would be the correct approach.
    Be aware, though, that a full `glibc` is quite large. In the case of a CrossTool-NG
    build of `glibc` 2.19, the space taken by `/lib` and `/usr/lib` is 33 MiB. Of
    course, you could cut down on that considerably by using uClibc or Musel `libc`
    libraries.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another option is to cherry pick only those libraries that you require, for
    which you need a means of discovering library dependencies. Using some of our
    knowledge from [Chapter 2](ch02.html "Chapter 2. Learning About Toolchains"),
    *Learning About Toolchains* libraries, you can use `readelf` for that task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you need to find these files in the toolchain and copy them to the staging
    directory. Remember that you can find `sysroot` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'To reduce the amount of typing, I am going to keep a copy of that in a shell
    variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'If you look at `/lib/ld-linux-armhf.so.3,` in `sysroot`, you will see that,
    it is, in fact, a symbolic link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Repeat the exercise for `libc.so.6` and `libm.so.6` and you will end up with
    a list of three files and three symbolic links. Copy them using `cp -a`, which
    will preserve the symbolic link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Repeat this procedure for each program.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is only worth doing this to get the very smallest embedded footprint possible.
    There is a danger that you will miss libraries that are loaded through `dlopen(3)`
    calls - plugins mostly. We will look at an example with the NSS libraries when
    we come to configure network interfaces later on in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Reducing size by stripping
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Libraries and programs are often compiled with a symbol table information built
    in, more so if you have compiled with the debug switch, `-g`. You seldom need
    these on the target. A quick and easy way to save space is to strip them. This
    example shows `libc` before and after stripping:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we saved 321,347 bytes, which was about 20%.
  prefs: []
  type: TYPE_NORMAL
- en: 'When stripping kernel modules, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Otherwise, you will strip out the symbols needed to relocate the module code
    and it will fail to load.
  prefs: []
  type: TYPE_NORMAL
- en: Device nodes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most devices in Linux are represented by device nodes, in accordance with the
    Unix philosophy that *everything is a file* (except network interfaces, which
    are sockets). A device node may refer to a block device or a character device.
    Block devices are mass storage devices such as SD cards or hard drives. A character
    device is pretty much anything else, once again with the exception of network
    interfaces. The conventional location for device nodes is the directory `/dev`.
    For example, a serial port may be represented by the device node `/dev/ttyS0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Device nodes are created using the program `mknod` (short for make node):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '`name` is the name of the device node that you want to create, `type` is either,
    `c` for character devices, and `b` for block. They each have a major number and
    a minor number which is used by the kernel to route file requests to the appropriate
    device driver code. There is a list of standard major and minor numbers in the
    kernel source in `Documentation/devices.txt`.'
  prefs: []
  type: TYPE_NORMAL
- en: You will need to create device nodes for all the devices you want to access
    on your system. You can do that manually by using the `mknod` command as I will
    illustrate here, or you can use one of the device managers mentioned later to
    create them automatically, at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'You need just two nodes to boot with BusyBox: `console` and `null`. The console
    only needs to be accessible to root, the owner of the device node, so the access
    permissions are 600\. The null device should be readable and writable by everyone,
    so the mode is 666\. You can use the `-m` option to `mknod` to set the mode when
    creating the node. You need to be root to create a device node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'You delete device nodes by using the standard `rm` command: there is no `rmnod`
    command because, once created, they are just files.'
  prefs: []
  type: TYPE_NORMAL
- en: The proc and sysfs filesystems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`proc` and `sysfs` are two pseudo filesystems that give a window onto the inner
    workings of the kernel. They both represent kernel data as files in a hierarchy
    of directories: when you read one of the files, the contents you see do not come
    from disk storage, it has been formatted on-the-fly by a function in the kernel.
    Some files are also writable, meaning that a kernel function is called with the
    new data you have written and, if it is of the correct format and you have sufficient
    permissions, it will modify the value stored in the kernel''s memory. In other
    works, `proc` and `sysfs` provide another way to interact with device drivers
    and other kernel code.'
  prefs: []
  type: TYPE_NORMAL
- en: '`proc` and `sysfs` should be mounted on the directories `/proc` and `/sys`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Although they are very similar in concept, they perform different functions.
    `proc` has been part of Linux since the early days. Its original purpose was to
    expose information about processes to user space, hence the name. To this end,
    there is a directory for each process named `/proc/<PID>` which contains information
    about its state. The process list command, `ps`, reads these files to generate
    its output. In addition, there are files that give information about other parts
    of the kernel, for example, `/proc/cpuinfo` tells you about the CPU, `/proc/interrupts`
    has information about interrupts, and so on. Finally, in `/proc/sys`, there are
    files that display and control the state and behavior of kernel sub-systems, especially
    scheduling, memory management, and networking. The best reference for the files
    you will find in `proc` is man page `proc(5)`.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, over time, the number of files in `proc` and their layout has become
    rather chaotic. In Linux 2.6, `sysfs` was introduced to export a subset of the
    data in an ordered way.
  prefs: []
  type: TYPE_NORMAL
- en: In contrast, `sysfs` exports a very ordered hierarchy of files relating to devices
    and the way they are connected to each other.
  prefs: []
  type: TYPE_NORMAL
- en: Mounting filesystems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `mount` command allows us to attach one filesystem to a directory within
    another, forming a hierarchy of filesystems. The one at the top, which was mounted
    by the kernel when it booted, is called the root filesystem. The format of the
    `mount` command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'You need to specify the type of the filesystem, `vfstype`, the block device
    node it resides on, and the directory you want to mount it to. There are various
    options you can give after the `-o`, have a look at the manual for more information.
    As an example, if you want to mount an SD card containing an `ext4` filesystem
    in the first partition onto directory `/mnt`, you would type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Assuming the mount succeeds, you would be able to see the files stored on the
    SD card in the directory `/mnt`. In some cases, you can leave out the filesystem
    type and let the kernel probe the device to find out what is stored there.
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking at the example of mounting the `proc` filesystem, there is something
    odd: there is no device node, `/dev/proc`, since it is a pseudo filesystem, not
    a real one. But the `mount` command requires a device as a parameter. Consequently
    we have to give a string where the device should go, but it does not matter much
    what that string is. These two commands achieve exactly the same result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: It is fairly common to use the filesystem type in the place of the device when
    mounting pseudo filesystems.
  prefs: []
  type: TYPE_NORMAL
- en: Kernel modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have kernel modules, they need to be installed into the root filesystem,
    using the kernel `make modules_install` target, as we saw in the last chapter.
    This will copy them into the directory `/lib/modules/<kernel version>` together
    with the configuration files needed by the `modprobe` command.
  prefs: []
  type: TYPE_NORMAL
- en: Be aware that you have just created a dependency between the kernel and the
    root filesystem. If you update one, you will have to update the other.
  prefs: []
  type: TYPE_NORMAL
- en: Transfering the root filesystem to the target
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Having created a skeleton root filesystem in your staging directory, the next
    task is to transfer it to the target. In the sections that follow, I will describe
    three possibilities:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ramdisk**: a filesystem image that is loaded into RAM by the bootloader.
    Ramdisks are easy to create and have no dependencies on mass storage drivers.
    They can be used in fall-back maintenance mode when the main root filesystem needs
    updating. They can even be used as the main root filesystem in small embedded
    devices and, of course, as the early user space in mainstream Linux distributions.
    A compressed ramdisk uses the minimum amount of storage but still consumes RAM.
    The contents are volatile so you need another storage type to store permanent
    data such as configuration parameters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**disk image**: a copy of the root filesystem formatted and ready to be loaded
    onto a mass storage device on the target. For example, it could be an image in
    `ext4` format ready to be copied onto an SD card, or it could be in `jffs2` format
    ready to be loaded into flash memory via the bootloader. Creating a disk image
    is probably the most common option. There is more information about the different
    types of mass storage in [Chapter 7](ch07.html "Chapter 7. Creating a Storage
    Strategy"), *Creating a Storage Strategy*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**network filesystem**: the staging directory can be exported to the network
    via an NFS server and mounted by the target at boot-time. This is often done during
    the development phase in preference to repeated cycles of creating a disk image
    and reloading it onto the mass storage device, which is quite a slow process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I will start with ramdisk and use it to illustrate a few refinements to the
    root filesystem, like adding user names and a device manager to create device
    nodes automatically. Then, I will show you how to create a disk image and, finally,
    how to use NFS to mount the root filesystem over a network.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a boot ramdisk
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Linux boot ramdisk, strictly speaking, an **initial RAM filesystem** or **initramfs**,
    is a compressed `cpio` archive. `cpio` is an old Unix archive format, similar
    to TAR and ZIP but easier to decode and so requiring less code in the kernel.
    You need to configure your kernel with `CONFIG_BLK_DEV_INITRD` to support `initramfs`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In fact, there are three different ways to create a boot ramdisk: as a standalone
    `cpio` archive, as a `cpio` archive embedded in the kernel image, and as a device
    table which the kernel build system processes as part of the build. The first
    option gives the most flexibility because we can mix and match kernels and ramdisks
    to our hearts content. However, it means that you have two files to deal with
    instead of one and not all bootloaders have the facility to load a separate ramdisk.
    I will show you how to build one into the kernel later.'
  prefs: []
  type: TYPE_NORMAL
- en: Standalone ramdisk
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following sequence of instructions creates the archive, compresses it and
    adds a U-Boot header ready for loading onto the target:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Note that we ran `cpio` with the option `--owner root:root`. This is a quick
    fix for the file ownership problem mentioned earlier, making everything in the
    `cpio` file UID and GID 0.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final size of the `uRamdisk` file is ~ 2.9 MiB, with no kernel modules.
    Add to that 4.4 MiB for the kernel `zImage` file, and 440 KiB for U-Boot and this
    gives a total of 7.7 MiB of storage needed to boot this board. We are a little
    way off the 1.44 MiB floppy that started it all off. If size was a real problem,
    you could use one of these options:'
  prefs: []
  type: TYPE_NORMAL
- en: Make the kernel smaller by leaving out drivers and functions you don't need
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make BusyBox smaller by leaving out utilities you don't need
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use uClibc or musl libc in place of glibc
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compile BusyBox statically
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Booting the ramdisk
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The simplest thing we can do is to run a shell on the console so that we can
    interact with the device. We can do that by adding `rdinit=/bin/sh` to the kernel
    command line. Now, you can boot the device.
  prefs: []
  type: TYPE_NORMAL
- en: Booting with QEMU
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'QEMU has the option `-initrd` to load `initframfs` into memory, so the full
    command is now as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Booting the BeagleBone Black
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To boot the BeagleBone Black, boot to the U-Boot prompt and enter these commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: If all goes well, you will get a root shell prompt on the console.
  prefs: []
  type: TYPE_NORMAL
- en: Mounting proc
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Note that the `ps` command doesn''t work: that is because the `proc` filesystem
    has not been mounted yet. Try mounting it and run `ps` again.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A refinement to this setup is to write a shell script that contains things
    that need to be done at boot-up and give that as the parameter to `rdinit=`. The
    script would look like the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Using a shell as `init` in this way is very handy for quick hacks, for example,
    when you want to rescue a system with a broken `init` program. However, in most
    cases, you would use an `init` program, which we will cover further down.
  prefs: []
  type: TYPE_NORMAL
- en: Building a ramdisk cpio into the kernel image
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In some cases, it is preferable to build the ramdisk into the kernel image,
    for example, if the bootloader cannot handle a ramdisk file. To do this, change
    the kernel configuration and set `CONFIG_INITRAMFS_SOURCE` to the full path of
    the `cpio` archive you created earlier. If you are using `menuconfig`, it is in
    **General setup** | **Initramfs source file(s)**. Note that it has to be the uncompressed
    `cpio` file ending in `.cpio`; not the gzipped version. Then, build the kernel.
    You should see that it is larger than before.
  prefs: []
  type: TYPE_NORMAL
- en: 'Booting is the same as before, except that there is no ramdisk file. For QEMU,
    the command is like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'For the BeagleBone Black, enter these commands into U-Boot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Of course, you must remember to rebuild the kernel each time you change the
    contents of the ramdisk and regenerate the `.cpio` file.
  prefs: []
  type: TYPE_NORMAL
- en: Another way to build a kernel with ramdisk
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An interesting way to build the ramdisk into the kernel image is by using a
    **device table** to generate a `cpio` archive. A `device table` is a text file
    which lists the files, directories, device nodes, and links that go into the archive.
    The overwhelming advantage is that you can create entries in the `cpio` file that
    are owned by root, or any other UID, without having root privileges yourself.
    You can even create device nodes. All this is possible because the archive is
    just a data file. It is only when it is expanded by Linux at boot time that real
    files and directories get created, using the attributes you have specified.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a device table for our simple `rootfs`, but missing most of the symbolic
    links to `busybox` to make it manageable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The syntax is fairly obvious:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dir <name> <mode> <uid> <gid>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`file <name> <location> <mode> <uid> <gid>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nod <name> <mode> <uid> <gid> <dev_type> <maj> <min>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`slink <name> <target> <mode> <uid> <gid>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The kernel provides a tool that reads this file and creates a `cpio` archive.
    The source is in `usr/gen_init_cpio.c`. There is a handy script in `scripts/gen_initramfs_list.sh`
    that creates a device table from a given directory, which saves a lot of typing.
  prefs: []
  type: TYPE_NORMAL
- en: To complete, the task, you need to set `CONFIG_INITRAMFS_SOURCE` to point to
    the device table file and then build the kernel. Everything else is the same as
    before.
  prefs: []
  type: TYPE_NORMAL
- en: The old initrd format
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is an older format for a Linux ramdisk, known as `initrd`. It was the
    only format available before Linux 2.6 and is still needed if you are using the
    mmu-less variant of Linux, uCLinux. It is pretty obscure and I will not cover
    it here. There is more information in the kernel source, in `Documentation/initrd.txt`.
  prefs: []
  type: TYPE_NORMAL
- en: The init program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Running a shell, or even a shell script, at boot time is fine for simple cases,
    but really you need something more flexible. Normally, Unix systems run a program
    called `init` that starts up and monitors other programs. Over the years, there
    have been many `init` programs, some of which I will describe in [Chapter 9](ch09.html
    "Chapter 9. Starting up - the init Program"), *Starting up - the init Program*.
    For now, I will briefly introduce the `init` from BusyBox.
  prefs: []
  type: TYPE_NORMAL
- en: '`init` begins by reading the configuration file, `/etc/inittab`. Here is a
    simple example which is adequate for our needs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The first line runs a shell script, `rcS`, when `init` is started. The second
    line prints the message **Please press Enter to activate this console** to the
    console, and starts a shell when you press *Enter*. The leading `-` before `/bin/ash`
    means that it will be a login shell, which sources `/etc/profile` and `$HOME/.profile`
    before giving the shell prompt. One of the advantages of launching the shell like
    this is that job control is enabled. The most immediate effect is that you can
    use *Ctrl* + *C* to terminate the current program. Maybe you didn't notice it
    before but, wait until you run the `ping` program and find you can't stop it!
  prefs: []
  type: TYPE_NORMAL
- en: BusyBox `init` provides a default `inittab` if none is present in the root filesystem.
    It is a little more extensive than the preceding one.
  prefs: []
  type: TYPE_NORMAL
- en: 'The script `/etc/init.d/rcS` is the place to put initialization commands that
    need to be performed at boot, for example, mounting the `proc` and `sysfs` filesystems:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Make sure that you make `rcS` executable, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'You can try it out on QEMU by changing the `-append` parameter, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'To achieve the same on the BeagelBone Black, you need to change the `bootargs`
    variable in U-Boot as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Configuring user accounts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As I have hinted already, it is not good practice to run all programs as root
    since, if one is compromised by an outside attack, then the whole system is at
    risk and a misbehaving program can do more damage if it is running as root. It
    is preferable to create unprivileged user accounts and use them where full root
    is not necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'User names are configured in `/etc/passwd`. There is one line per user, with
    seven fields of information separated by colons:'
  prefs: []
  type: TYPE_NORMAL
- en: The login name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A hash code used to verify the password , or more usually an `x` to indicate
    that the password is stored in `/etc/shadow`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: UID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A comment field, often left blank
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The user's home directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (Optional) the shell this user will use
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, this creates users `root` with UID 0 and `daemon` with UID 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Setting the shell for user daemon to `/bin/false` ensures that any attempt to
    log on with that name will fail.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Various programs have to read `/etc/passwd` so as to be able to look up UIDs
    and names, and so it has to be word-readable. That is a problem if the password
    hashes are stored in there because a malicious program would be able to take a
    copy and discover the actual passwords using a variety of cracker programs. Therefore,
    to reduce the exposure of this sensitive information, the passwords are stored
    in `/etc/shadow` and an `x` is placed in the password field to indicate that this
    is the case. `/etc/shadow` is only accessible as `root`, and, so as long as the
    `root` user is restricted, the passwords are safe.
  prefs: []
  type: TYPE_NORMAL
- en: 'The shadow password file consists of one entry per user, made up of nine fields.
    Here is an example that mirrors the `passwd` file shown in the preceding paragraph:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The first two fields are the username and the password hash. The remaining seven
    are related to password aging, which is not usually an issue on embedded devices.
    If you are curious about the full details, refer to the manual page *shadow(5)*.
  prefs: []
  type: TYPE_NORMAL
- en: In the example, the password for `root` is empty, meaning that `root` can log
    on without giving a password, which is useful during development, but not for
    production! You can generate a password hash by using the command `mkpasswd` or
    by running the `passwd` command on the target and copy and pasting the hash field
    from `/etc/shadow` on the target into the default shadow file in the staging directory.
  prefs: []
  type: TYPE_NORMAL
- en: The password for daemon is `*`, which will not match any logon password, once
    again ensuring that the daemon cannot be used as a regular user account.
  prefs: []
  type: TYPE_NORMAL
- en: 'Group names are stored in a similar way in `/etc/group`. The format is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The name of the group
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The group password, usually an `x` character, indicating that there is no group
    password
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The GID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An optional list of users who belong to this group, separated by commas.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Adding user accounts to the root filesystem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Firstly, you have to add to your staging directory `etc/passwd`, `etc/shadow`,
    and `etc/group`, as shown in the preceding section. Make sure that the permissions
    of shadow are 0600.
  prefs: []
  type: TYPE_NORMAL
- en: 'The login procedure is started by a program called `getty`, which is part of
    BusyBox. You launch it from `inittab` using the keyword `respawn`, which restarts
    `getty` when a login shell is terminated, so `inittab` should read like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Then rebuild the ramdisk and try it out using QEMU or BeagelBone Black as before.
  prefs: []
  type: TYPE_NORMAL
- en: Starting a daemon process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Typically, you would want to run certain background processes at start up. Let's
    take the log daemon, `syslogd`, as an example. The purpose of `syslogd` is to
    accumulate log messages from other programs, mostly other daemons. Naturally,
    BusyBox has an applet for that!
  prefs: []
  type: TYPE_NORMAL
- en: 'Starting the daemon is as simple as adding a line like this to `etc/inittab`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '`respawn` means that, if the program terminates, it will be automatically restarted;
    `-n` means that it should run as a foreground process. The log is written to `/var/log/messages`.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You may also want to start `klogd` in the same way: `klogd` sends kernel log
    messages to `syslogd` so that they can be logged to permanent storage.'
  prefs: []
  type: TYPE_NORMAL
- en: As an aside, I should mention that, in the case of a typical embedded Linux
    system, writing log files to flash memory is not such a good idea as it will wear
    it out. I will cover the options for logging in [Chapter 7](ch07.html "Chapter 7. Creating
    a Storage Strategy"), *Creating a Storage Strategy*.
  prefs: []
  type: TYPE_NORMAL
- en: A better way of managing device nodes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Creating device nodes statically with `mknod` is quite hard work and inflexible.
    There are other ways to create device nodes automatically on demand:'
  prefs: []
  type: TYPE_NORMAL
- en: '`devtmpfs`: This is a pseudo filesystem that you mount over `/dev` at boot
    time. The kernel populates it with device nodes for all the devices that the kernel
    currently knows about and creates nodes for new devices as they are detected at
    runtime. The nodes are owned by `root` and have default permissions of 0600\.
    Some well-known device nodes, such as `/dev/null` and `/dev/random`, override
    the default to 0666 (see `struct` `memdev` in `drivers/char/mem.c`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mdev`: This is a BusyBox applet that is used to populate a directory with
    device nodes and to create new nodes as needed. There is a configuration file,
    `/etc/mdev.conf`, which contains rules for ownership and the mode of the nodes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`udev`: This is now part of `systemd` and is the solution you will find on
    desktop Linux and some embedded devices. It is very flexible and a good choice
    for higher end embedded devices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although both `mdev` and `udev` create the device nodes themselves, it is more
    usual to let `devtmpfs` do that job and use `mdev/udev` as a layer on top to implement
    the policy for setting ownership and permissions.
  prefs: []
  type: TYPE_NORMAL
- en: An example using devtmpfs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you have booted up one of the earlier ramdisk examples, trying out `devtmpfs`
    is as simple as entering this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see that `/dev` is full of device nodes. For a permanent fix, add
    this to `/etc/init.d/rcS`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: In point of fact, kernel initialization does this automatically unless you have
    supplied an `initramfs` ramdisk as we have done! To see the code, look in the
    `init/do_mounts.c`, function `prepare_namespace()`.
  prefs: []
  type: TYPE_NORMAL
- en: An example using mdev
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While `mdev` is a bit more complex to set up, it does allow you to modify the
    permissions of device nodes as they are created. Firstly, there is a startup phase,
    selected by the `-s` option, when `mdev` scans the `/sys` directory looking for
    information about current devices and populates the `/dev` directory with the
    corresponding nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to keep track of new devices coming on line and create nodes for
    them as well, you need to make `mdev` a hotplug client by writing to `/proc/sys/kernel/hotplug`.
    These additions to `/etc/init.d/rcS` will achieve all of that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The default mode is 660 and ownership is `root:root`. You can change that by
    adding rules in `/etc/mdev.conf`. For example, to give the `null`, `random`, and
    `urandom` devices their correct modes, you would add this to `/etc/mdev.conf`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The format is documented in the BusyBox source code in `docs/mdev.txt` and there
    are more examples in the directory named `examples`.
  prefs: []
  type: TYPE_NORMAL
- en: Are static device nodes so bad after all?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Statically created device nodes do have one advantage: they don''t take any
    time during boot to create, whereas the other methods do. If minimizing boot time
    is a priority, using statically-created device nodes will save a measurable amount
    of time.'
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the network
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Next, let's look at some basic network configurations so that we can communicate
    with the outside world. I am assuming that there is an Ethernet interface, `eth0`,
    and that we only need a simple IP v4 configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'These examples use the network utilities that are part of BusyBox, and are
    sufficient for a simple use case, using the `old-but-reliable ifup` and `ifdown`
    programs. You can read the man pages on both for more details. The main network
    configuration is stored in `/etc/network/interfaces`. You will need to create
    these directories in the staging directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'For a static IP address, `etc/network/interfaces` would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'For a dynamic IP address allocated using DHCP, `etc/network/interfaces` would
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: You will also have to configure a DHCP client program. BusyBox has one named
    `udchpcd`. It needs a shell script that should go in `/usr/share/udhcpc/default.script`.
    There is a suitable default in the BusyBox source code in the directory `examples//udhcp/simple.script`.
  prefs: []
  type: TYPE_NORMAL
- en: Network components for glibc
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`glibc` uses a mechanism known as the **name service switch** (**NSS**) to
    control the way that names are resolved to numbers for networking and users. User
    names, for example, may be resolved to UIDs via the file `/etc/passwd`; network
    services such as HTTP can be resolved to the service port number via `/etc/services`,
    and so on. All this is configured by `/etc/nsswitch.conf`, see the manual page,
    *nss(5)* for full details. Here is a simple example that will suffice for most
    embedded Linux implementations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Everything is resolved by the correspondingly named file in `/etc`, except for
    the host names, which may additionally be resolved by a DNS lookup.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make this work, you need to populate `/etc` with those files. Networks,
    protocols, and services are the same across all Linux systems, so they can be
    copied from `/etc` in your development PC. `/etc/hosts` should, at least contain,
    the loopback address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: We will come to the others, `passwd`, `group`, and `shadow`, later.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last piece of the jigsaw is the libraries that perform the name resolution.
    They are plugins that are loaded as needed based on the contents of `nsswitch.conf`,
    meaning that they do not show up as dependencies if you use `readelf` or similar.
    You will simply have to copy them from the toolchain''s `sysroot`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Creating filesystem images with device tables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The kernel has a utility, `gen_init_cpio`, that creates a `cpio` file based
    on format instructions set out in a text file, called a `device table`, which
    allows a non-root user to create device nodes and to allocate arbitrary UID and
    GID values to any file or directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same concept has been applied to tools that create other filesystem image
    formats:'
  prefs: []
  type: TYPE_NORMAL
- en: '`jffs2`: `mkfs.jffs2`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ubifs`: `mkfs.ubifs`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ext2`: `genext2fs`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will look at `jffs2` and `ubifs` in [Chapter 7](ch07.html "Chapter 7. Creating
    a Storage Strategy"), *Creating a Storage Strategy*, when we look at filesystems
    for flash memory. The third, `ext2`, is a fairly old format for hard drives.
  prefs: []
  type: TYPE_NORMAL
- en: 'They each take a device table file with the format `<name> <type> <mode> <uid>
    <gid> <major> <minor> <start> <inc> <count>` in which the following applies:'
  prefs: []
  type: TYPE_NORMAL
- en: '`name`: Filename'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`type`: One of the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`f`: A regular file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`d`: A directory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`c`: A character special device file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`b`: A block special device file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`p`: A FIFO (named pipe)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`uid` The UID of the file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gid`: The GID of the file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`major` and `minor`: the device numbers (device nodes only)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`start`, `inc`, and `count`: (device nodes only) allow you to create a group
    of device nodes starting from the `minor` number in `start`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You do not have to specify every file, as with `gen_init_cpio`: you just have
    to point them at a directory – the staging directory – and list the changes and
    exceptions you need to make in the final filesystem image.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple example which populates static device nodes for us is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, use `genext2fs` to generate a filesystem image of 4 MiB (that is 4,096
    blocks of the default size, 1,024 bytes):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Now, you can copy the resulting image, `rootfs.ext`, to an SD card or similar.
  prefs: []
  type: TYPE_NORMAL
- en: Putting the root filesytem onto an SD card
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is an example of mounting a filesystem from a normal block device, such
    as an SD card. The same principles apply to other filesystem types and we will
    look at them in more detail in [Chapter 7](ch07.html "Chapter 7. Creating a Storage
    Strategy"), *Creating a Storage Strategy*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming that you have a device with an SD card, and that the first partition
    is used for the boot files, `MLO` and `u-boot.img` – as on a BeagleBone Black.
    Assume also that you have used `genext2fs` to create a filesystem image. To copy
    it to the SD card, insert the card and identify the block device it has been assigned:
    typically `/dev/sd` or `/dev/mmcblk0`. If it is the latter, copy the filesystem
    image to the second partition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, slot the SD card into the device, and set the kernel command line to
    `root=/dev/mmcblk0p2`. The complete boot sequence is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Mounting the root filesystem using NFS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If your device has a network interface, it is best to mount the root filesystem
    over the network during development. It gives you access to almost unlimited storage
    so you can add in debug tools and executables with large symbol tables. As an
    added bonus, updates made to the root filesystem hosted on the development machine
    are made available on the target immediately. You also have a copy of log files.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this to work, your kernel has to be configured with `CONFIG_ROOT_NFS`.
    Then, you can configure Linux to do the mount at boot time by adding the following
    to the kernel command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Give the details of the NFS export as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Configure the network interface that connects to the NFS server so that it
    is available at boot time, before the `init` program runs by using this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: There is more information about NFS root mounts in the kernel source in `Documentation/filesystems/nfs/nfsroot.txt`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You also need to install and configure an NFS server on your host which, for
    Ubuntu, you can do with this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The NFS server needs to be told which directories are being exported to the
    network, which is controlled by `/etc/exports`. Add a line like this one to that
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, restart the server to pick up the change which, for Ubuntu, is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Testing with QEMU
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following script creates a virtual network between the network device `tap0`
    on the host and `eth0` on the target using a pair of static IPv4 addresses and
    then launches QEMU with the parameters to use `tap0` as the emulated interface.
    You will need to change the path to the root filesystem to be the full path to
    your staging directory, and maybe the IP addresses if they conflict with your
    network configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: The script is available as `run-qemu-nfs.sh`.
  prefs: []
  type: TYPE_NORMAL
- en: It should boot up as before, but now using the staging directory directly via
    the NFS export. Any files that you create in that directory will be immediately
    visible to the target device and any files created in the device will be visible
    to the development PC.
  prefs: []
  type: TYPE_NORMAL
- en: Testing with BeagleBone Black
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In a similar way, you can enter these commands at the U-Boot prompt of the
    BeagleBone Black:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Then; to boot it, load the kernel and `dtb` from `sdcard,` as before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Problems with file permissions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The files that were already in the staging directory are owned by you and will
    show up on the target when you run `ls -l` with whatever your UID is, typically
    1,000\. Any files created by the target device will be owned by root. The whole
    thing is a mess.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, there is no simple way out. The best advice is to make a copy
    of the staging directory and change ownership to `root:root` (using `sudo chown
    -R 0:0 *`) and export this directory as the NFS mount. It reduces the inconvenience
    of having just one copy of the root filesystem shared between development and
    target systems.
  prefs: []
  type: TYPE_NORMAL
- en: Using TFTP to load the kernel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When working with real hardware such as the BeagleBone Black, it is best to
    load the kernel over the network, especially when the root filesystem is mounted
    via NFS. In this way, you are not using any local storage on the device. It saves
    time if you don't have to keep re-flashing the memory and means that you can get
    work done while the flash storage drivers are still being developed (it happens).
  prefs: []
  type: TYPE_NORMAL
- en: U-Boot has supported the **Trivial File Transfer Protocol** (**TFTP**) for many
    years. Firstly, you need to install a `tftp` daemon on your development machine.
    On Ubuntu, you would install the `tftpd-hpa` package, which grants read access
    to files in the directory `/var/lib/tftpboot` to `tftp` clients like U-Boot.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming that you have copied `zImage` and `am335x-boneblack.dtb` into `/var/lib/tftpboot`,
    enter these commands into U-Boot to load and boot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'It is fairly common for the response to `tftpboot` to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'The row of `T` characters on the last line indicate that there is something
    wrong and the TFTP requests are timing out. The most common reasons are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Incorrect IP address for server.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TFTP daemon not running on server.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Firewall on server is blocking the TFTP protocol. Most firewalls do indeed block
    the TFTP port, 69, by default.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this case, the tftp daemon was not running, so I started it with the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Additional reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Filesystem Hierarchy Standard*, currently at version 3.0 available at [http://refspecs.linuxfoundation.org/fhs.shtml](http://refspecs.linuxfoundation.org/fhs.shtml).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*ramfs, rootfs and initramfs , Rob Landley*, October 17, 2005, which is part
    of the Linux source code available at `Documentation/filesystems/ramfs-rootfs-initramfs.txt`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the strengths of Linux is that it can support a wide range of root filesystems
    which allow it to be tailored to suit a wide range of needs. We have seen that
    it is possible to construct a simple root filesystem manually with a small number
    of components, and that BusyBox is especially useful in this regard. By going
    through the process one step at a time, it has given us insight into some of the
    basic workings of Linux systems, including network configuration and user accounts.
    However, the task rapidly becomes unmanageable as devices get more complex. And,
    there is the ever-present worry that there may be a security hole in the implementation
    which we have not noticed. In the next chapter, we will look at using embedded
    build systems to help us out.
  prefs: []
  type: TYPE_NORMAL
