- en: Advanced Go Features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, you learned how to compile Go code, how to get input
    from the user and print the output on the screen, how to create your own Go functions,
    the data structures that Go supports, and how to process command-line arguments.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will discuss many fascinating things, so you better prepare yourselves
    for lots of interesting and practical Go code that will help you perform many
    different yet really important tasks, starting with error handling and ending
    with how to avoid some common Go mistakes. If you are familiar with Go, you can
    skip what you already know, but please do not skip the proposed exercises.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, this chapter will talk about some advanced Go features, including:'
  prefs: []
  type: TYPE_NORMAL
- en: Error handling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Error logging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pattern matching and regular expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reflection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use the `strace(1)` and `dtrace(1)` tools to watch the system calls of
    Go executable files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to detect unreachable Go code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to avoid various common Go mistakes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Error handling in Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Errors happen all the time, so it is our job to both catch and handle them,
    especially when writing code that deals with sensitive system information and
    files. The good news is that Go has a special data type called `error` that helps
    signify erroneous states; if an `error` variable has a `nil` value, then there
    is no error situation.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you saw in the `addCLA.go` program that was developed in the previous chapter,
    you can ignore the `error` variable that is returned by most Go functions using
    the `_` character:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: However, this is not considered good practice and should be avoided, especially
    on systems software and other kinds of critical software, such as server processes.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you will see in [Chapter 6](7debeee1-e431-4d30-a868-6cc59c73adb8.xhtml),
    *File Input and Output*, even **End of File** (**EOF**) is a type of error that
    is returned when there is nothing left to read from a file. As `EOF` is defined
    in the `io` package, you can handle it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: However, the most important task to learn is how to develop functions that return
    `error` variables and how to handle them, which is explained next.
  prefs: []
  type: TYPE_NORMAL
- en: Functions can return error variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Go functions can return `error` variables, which means that an error condition
    can be handled inside a function, outside of a function, or both inside and outside
    the function; the latter situation does not happen very often. So, this subsection
    will develop a function that returns error messages. The relevant Go code can
    be found in `funErr.go` and will be presented in three parts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part contains the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Apart from the expected preamble, the preceding code defines a new function
    named `division()`, which returns an integer and two `error` variables. If you
    remember from your Math classes, when you divide two integer numbers, the division
    operation is not always perfect, which means that you might get a remainder that
    is not zero. The `errors.New()` function from the `errors` Go package that you
    see in `funErr.go` creates a new `error` variable, using the provided string as
    the error message.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second part of `funErr.go` has the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: It is a very common Go practice to compare an `error` variable with `nil` to
    quickly find out whether there is an error condition or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part of `funErr.go` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This part showcases two erroneous conditions. The first one is an integer division
    that has a remainder, whereas the second one is an invalid division because you
    cannot divide a number by zero. As the name `log.Fatal()` implies, this logging
    function should be used for critical errors only because when called, it automatically
    terminates your program. However, as you will see in the next subsection, there
    exist other, more gentle, ways to log your error messages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Executing `funErr.go` generates the next output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The last line is automatically generated by the `log.Fatal()` function, just
    before terminating the program. It is important to understand that any Go code
    after the call to `log.Fatal()` will not be executed.
  prefs: []
  type: TYPE_NORMAL
- en: About error logging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Go offers functions that can help you log your error messages in various ways.
    You already saw `log.Fatal()` in `funErr.go`, which is a somewhat cruel way to
    deal with simple errors. Put simply, you should have a very good reason to use
    `log.Fatal()` in your code. Generally speaking, `log.Fatal()` should be used instead
    of the `os.Exit()` function because it allows you to print an error message and
    exit your program using just one function call.
  prefs: []
  type: TYPE_NORMAL
- en: Go offers additional error logging functions in the `log` standard package that
    behave more gently depending on the situation, which includes `log.Printf()`,
    `log.Print()`, `log.Println()`, `log.Fatalf()`, `log.Fatalln()`, `log.Panic()`,
    `log.Panicln()`, and `log.Panicf()`. Please note that logging functions can be
    handy for debugging purposes so do not underestimate their power.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `logging.go` program illustrates two of the mentioned logging functions
    using the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, `logging.go` does not need the `fmt` package because it has
    its own functions for printing the output. Executing `logging.go` will produce
    the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Although the `log.Printf()` function works in the same way as `fmt.Printf()`,
    it automatically prints the date and time the log message was printed, just like
    the `log.Fatal()` function did in `funErr.go`. Additionally, the `log.Panicf()`
    function works in a similar way to `log.Fatal()`--they both terminate the current
    program. However, `log.Panicf()` prints some additional information, useful for
    debugging purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Go also offers the `log/syslog` package that is a simple interface to the system
    log service running on your Unix machine. [Chapter 7](a013a7ab-3736-4ea0-a8e7-ec72eb01b0c5.xhtml),
    *Working with System Files*, will talk more about the `log/syslog` package.
  prefs: []
  type: TYPE_NORMAL
- en: The addCLA.go program revisited
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This subsection will present an improved version of the `addCLA.go` program
    we developed in the previous chapter, to make it able to handle any kind of user
    input. The new program will be called `addCLAImproved.go`, but instead of presenting
    its full Go code, you will only see the differences between `addCLAImproved.go`
    and `addCLA.go` using the `diff(1)` command-line utility:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: What this output basically tells us is that the last two lines of code, which
    can be found in `addCLA.go` and begin with the `>` character, were replaced by
    the lines of code that begin with the `<` character in `addCLAImproved.go`. The
    remaining code of both files is exactly the same.
  prefs: []
  type: TYPE_NORMAL
- en: The `diff(1)` utility compares text files line by line and is a handy way of
    spotting code differences between different versions of the same file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Executing `addCLAImproved.go` will generate the following kind of output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: So, the new and improved version works as expected, behaves reliably, and allows
    us to differentiate between valid and invalid input.
  prefs: []
  type: TYPE_NORMAL
- en: Pattern matching and regular expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Pattern matching**, which plays a key role in Go, is a technique for searching
    a string for a set of characters based on a specific search pattern that is based
    on **regular expressions**. If pattern matching is successful, it allows you to
    extract the desired data from the string or replace or delete it. **Grammar**
    is a set of production rules for strings in a formal language. The production
    rules describe how to create strings from the alphabet of the language that are
    valid according to the syntax of the language. Grammar does not describe the meaning
    of a string or what can be done with it in whatever context, only its form. What
    is important is to realize that grammar is at the heart of regular expressions
    because without it, you cannot define or use a regular expression.'
  prefs: []
  type: TYPE_NORMAL
- en: Regular expressions and pattern matching are not a panacea, so you should not
    try to solve every problem using regular expressions since they are not suitable
    for every kind of problem you may come up against. Furthermore, they might introduce
    unnecessary complexity to your software.
  prefs: []
  type: TYPE_NORMAL
- en: The Go package responsible for the pattern matching capabilities of Go is called
    `regexp`, which you can see in action in `regExp.go`. The code of `regExp.go`
    will be presented in four parts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part is the expected preamble:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The second part is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Both calls to `regexp.MatchString()` try to find a static string, which is the
    first parameter, in a given string, which is the second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The third part contains a single, yet crucial, line of Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `regexp.Compile()` function reads the provided regular expression and tries
    to parse it. If the parsing of the regular expressing is successful, then `regexp.Compile()`
    returns a value of the `regexp.Regexp` variable type that you can use afterward.
    The `[Mm]` expression in the `regexp.Compile()` function means that what you are
    looking for can begin with an uppercase `M` or a lowercase `m`. Both `[` and `]`
    are special characters that are not part of the regular expression. So, the provided
    grammar is naive and only matches the words `Mihalis` and `mihalis`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part uses the previous regular expression that is stored in the `parse`
    variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Running `regExp.go` generates the next output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: So, the first call to `regexp.MatchString()` was a match, but the second was
    not because pattern matching is case-sensitive and `Tsoukalos` does not match
    `tsoukalos`. The `parse.ReplaceAllString()` function at the end searches the string
    that is given as an input (`"mihalis Mihalis"`) and replaces each match with the
    string that is given as its second parameter (`"MIHALIS"`).
  prefs: []
  type: TYPE_NORMAL
- en: The rest of this section will present various examples using static text because
    you do not know how to read text files yet. However, as the static text will be
    stored in an array and processed line by line, the presented code can be easily
    modified to support getting your input from external text files.
  prefs: []
  type: TYPE_NORMAL
- en: Printing all the values from a given column of a line
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is a very common scenario, as you often will need to get all the data from
    a given column of a structured text file in order to analyze it afterward. The
    code of `readColumn.go`, which prints values in the third column, will be presented
    in two parts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Here, you import the required Go packages and define a string with three lines
    using an array with three elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second part contains the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: First, you define the column that interests you. Then, you start iterating over
    the strings stored in the array. This is similar to reading a text file line by
    line. The Go code inside the `for` loop splits the fields of the input line, stores
    them in the `data` array, verifies that the value from the desired column is present,
    and prints it on your screen. All of the hard work is done by the handy `strings.Fields()`
    function that splits a string based on whitespace characters, as defined in `unicode.IsSpace()`,
    and returns a slice of strings. Although `readColumn.go` does not use the `regexp.Compile()`
    function, the logic behind its implementation with the use of `strings.Fields()`
    is still based on the principles of regular expressions.
  prefs: []
  type: TYPE_NORMAL
- en: An important thing to remember is that you should never trust your data. Put
    simply, always verify that the data you expect to grab is there.
  prefs: []
  type: TYPE_NORMAL
- en: 'Executing `readColumn.go` will generate the following kind of output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[Chapter 6](7debeee1-e431-4d30-a868-6cc59c73adb8.xhtml), *File Input and Output*,
    will show an improved version of `readColumn.go` that you can use as a starting
    point in case you want to modify the rest of the examples shown.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating summaries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will develop a program that adds all the values of a given
    column of text with multiple lines. To make things even more interesting, the
    column number will be given as a parameter in the program. The main difference
    between the program of this subsection and `readColumn.go` from the previous subsection
    is that you will need to convert each value into an integer number.
  prefs: []
  type: TYPE_NORMAL
- en: The name of the program that will be developed is `summary.go` and can be divided
    into three parts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The second part has the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The previous code reads the index of the column that interests you. If you want
    to make `summary.go` even better, you can check for negative values in the `column`
    variable and print the appropriate error message.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part of `summary.go` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, most of the Go code in `summary.go` is about dealing with exceptions
    and potential errors. The core functionality of `summary.go` is implemented in
    a few lines of Go code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Executing `summary.go` will give you the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Finding the number of occurrences
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A very common programming problem is finding out the number of times an IP address
    appears in a log file. So, the example in this subsection will show you how to
    do this using a handy map structure. The `occurrences.go` program will be presented
    in three parts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The second part is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Here, we use the knowledge from the previous chapter to create a map named `counts`
    and populate it with the desired data using two `for` loops.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part is pretty small as it just prints the contents of the `counts`
    map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Executing `occurrences.go` and using the `sort(1)` command-line utility to
    sort the output of `occurrences.go` will generate the following kind of output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, traditional Unix tools are still useful.
  prefs: []
  type: TYPE_NORMAL
- en: Find and replace
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The example in this subsection will search the provided text for two variations
    of a given string and replace it with another string. The program will be named
    `findReplace.go` and will actually use Go regular expressions. The main reason
    for using the `regexp.Compile()` function, in this case, is that it greatly simplifies
    things and allows you to access your text only once.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part of the `findReplace.go` program is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The next part is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The previous Go code will find every occurrence of an uppercase `B` or a lowercase
    `b` (`[bB]`). Note that there is also `regexp.MustCompile()` that works like `regexp.Compile()`.
    However, `regexp.MustCompile()` does not return an `error` variable; it just panics
    if the given expression is erroneous and cannot be parsed. As a result, `regexp.Compile()`
    is a better choice.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Here you replace each match with an uppercase C using `parse.ReplaceAllString()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Executing `findReplace.go` generates the expected output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The `awk(1)` and `sed(1)` command-line tools can do most of the previous tasks
    more easily, but `sed(1)` and `awk(1)` are not general-purpose programming languages.
  prefs: []
  type: TYPE_NORMAL
- en: Reflection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reflection is an advanced Go feature that allows you to dynamically learn the
    type of an arbitrary object as well as information about its structure. You should
    recall that the `dataStructures.go` program from [Chapter 2](69bfa048-8113-4a6d-929a-b5addf9b6505.xhtml),
    *Writing Programs in Go*, used reflection to find out the fields of a data structure
    as well as the type of each fields. All of this happened with the help of the
    `reflect` Go package and the `reflect.TypeOf()` function that returns a `Type`
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: Reflection is illustrated in the `reflection.go` Go program that will be presented
    in four parts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first one is the preamble of the Go program and has the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The second part is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Here, you create two new types, named `t1` and `t2`, that are both `int` and
    three variables, named `x1`, `x2`, and `x3`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The third part has the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Here, you find the type of the `x1`, `x2`, and `x3` variables using `reflect.ValueOf()`
    and `Type()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part of `reflection.go` deals with a `struct` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: There exist some laws that govern reflection in Go, but talking about them is
    beyond the scope of this book. What you should remember is that your programs
    can examine their own structure using reflection, which is a very powerful capability.
  prefs: []
  type: TYPE_NORMAL
- en: 'Executing `reflection.go` prints the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The first two lines of the output show that Go does not consider the types `t1`
    and `t2` as equal, even though both `t1` and `t2` are aliases of the `int` type.
  prefs: []
  type: TYPE_NORMAL
- en: Old habits die hard!
  prefs: []
  type: TYPE_NORMAL
- en: Despite the fact that Go tries to be a safe programming language, sometimes
    it is forced to forget about safety and allows the programmer to do whatever he/she
    wants.
  prefs: []
  type: TYPE_NORMAL
- en: Calling C code from Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Go allows you to call C code because there are times when the only way to perform
    some tasks, such as communicating with a hardware device or a database server,
    is by using C. Nevertheless, if you find yourself using this capability many times
    in the same project, you might need to reconsider your approach and your choice
    of programming language.
  prefs: []
  type: TYPE_NORMAL
- en: Talking more about this capability in Go is beyond the scope of this book. What
    you should remember is that most likely, you will never need to call C code from
    your Go program. Nevertheless, should you wish to explore this Go feature, you
    can start by visiting the documentation of the `cgo` tool at [https://golang.org/cmd/cgo/](https://golang.org/cmd/cgo/)
    as well as by looking at the code found at [https://github.com/golang/go/blob/master/misc/cgo/gmp/gmp.go](https://github.com/golang/go/blob/master/misc/cgo/gmp/gmp.go).
  prefs: []
  type: TYPE_NORMAL
- en: Unsafe code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unsafe code is Go code that bypasses the type safety and memory security of
    Go and requires the use of the `unsafe` package. You will most likely never need
    to use unsafe code in your Go programs but if for some strange reason you ever
    need to, it will probably have to do with pointers.
  prefs: []
  type: TYPE_NORMAL
- en: Using unsafe code can be dangerous for your programs, so only use it when it
    is absolutely necessary. If you are not completely sure that you need it, then
    do not use it.
  prefs: []
  type: TYPE_NORMAL
- en: The example code in this subsection is saved as `unsafe.go` and will be presented
    in two parts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: You first create a new `int64` variable that is named `value`. Then, you create
    a pointer to it named `p1`. Next, you create another pointer that points to `p1`.
    However, the `p2` pointer that points to `p1` is a pointer to an `int32` integer,
    despite the fact that `p1` points to an `int64` variable. Although this is not
    permitted by Go rules, the `unsafe.Pointer()` function makes this possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second part is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Executing `unsafe.go` will create the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The output shows how dangerous an unsafe pointer can be. When the value of the
    `value` variable fits into an `int32` memory space (`5` and `31212132`), then
    `p2` works fine and shows the correct result. However, when the `value` variable
    holds a value (`312121321321213212`) that does not fit into an `int32` memory
    space, then `p2` shows an erroneous result (`606940444`), without giving you a
    warning or an error message.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing Go to other programming languages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Go is not perfect, but neither are the rest of the programming languages. This
    section will briefly discuss other programming languages and compare them to Go
    in order to give you a better understanding of the choices you have. So, the list
    of programming languages that can be compared to Go includes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**C**: C is the most popular programming language for developing systems software
    because the portable part of each Unix operating system is written in C. However,
    it has some critical drawbacks, including the fact that C pointers, which are
    great and fast, can lead to difficult-to-detect bugs and memory leaks. Additionally,
    C does not offer garbage collection; back when C was created, garbage collection
    was a luxury that had the ability slow down computers. However, nowadays computers
    are pretty fast and garbage collection does not slow things down anymore. Moreover,
    C programs require more code for developing a given task than other systems programming
    languages. Lastly, C is an old programming language that does not support modern
    programming paradigms, such as object-oriented and functional programming.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**C++**: As previously mention, I do not like C++ anymore. If you think that
    you should use C++, then you may want to consider using C instead. However, the
    main advantage of C++ over Go is that if needed, C++ can be used as if it were
    C. However, neither C nor C++ have good support for concurrent programming.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rust**: Rust is a new systems programming language that tries to avoid unpleasant
    bugs caused by unsafe code. Currently, the syntax of Rust is changing too fast,
    but this will end in the near feature. If for some reason you do not like Go,
    you should try Rust.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Swift**: In its current status, Swift is more suitable for developing systems
    software for macOS systems. However, I am sure that in the near feature, Swift
    will be more popular on Linux machines, so you should keep an eye on it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Python**: Python is a scripting language, which is its main disadvantage.
    This is because usually, you do not want to make the source of your systems software
    available to everyone.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Perl**: What was said about Python can be also said about Perl. However,
    both programming languages have a plethora of modules that will make your life
    a lot easier and your code a lot smaller.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you ask my opinion, I think that Go is a modern, portable, mature, and safe
    programming language for writing systems software. You should try Go before looking
    for any alternatives. However, if you are a Go programmer and want to try something
    else, I suggest that you pick Rust or Swift. Yet, if you need to write reliable
    concurrent programs, Go should be your first choice.
  prefs: []
  type: TYPE_NORMAL
- en: If you cannot choose between Go and Rust, then just try C. Learning the basics
    of systems programming is more important than the programming language you select.
  prefs: []
  type: TYPE_NORMAL
- en: Despite their disadvantages, bear in mind that all scripting programming languages
    are perfect for writing prototypes and have the advantage that they allow you
    to create graphical interfaces for your software. Still, delivering systems software
    in a scripting language is rarely accepted, unless there is a really good reason
    to do so.
  prefs: []
  type: TYPE_NORMAL
- en: Analysing software
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are times that a program fails for some unknown reason or does not perform
    well, and you want to find out why without having to rewrite your code and add
    a plethora of debugging statements. So, this section will talk about `strace(1)`
    and `dtrace(1)` , which allow you to see what is going on behind the scenes when
    you execute a program on a Unix machine. Although both tools can work with the
    `go run` command, you will get less unrelated output if you first create an executable
    file using `go build` and use this file. This mainly occurs because `go run` makes
    temporary files before actually running your Go code, and you want to debug the
    actual program, not the compiler used to build the program.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that although `dtrace(1)` is more powerful than `strace(1)` and has
    its own programming language, `strace(1)` is more versatile for watching the system
    calls a program makes.
  prefs: []
  type: TYPE_NORMAL
- en: Using the strace(1) command-line utility
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `strace(1)` command-line utility allows you to trace system calls and signals.
    As `strace(1)` is not available on Mac machines, this section will use a Linux
    machine to showcase `strace(1)`. However, as you will see in a later, macOS machines
    have the `dtrace(1)` command-line utility that can do many more things.
  prefs: []
  type: TYPE_NORMAL
- en: The number after the name of a program refers to the section of the manual its
    page belongs to. Although most of the names can be found only once, which means
    that putting the section number is not necessary, there are names that can be
    located in multiple sections because they have multiple meanings, such as `crontab(1)`
    and `crontab(5)`. Therefore, if you try to retrieve such a page without specifically
    stating the section number, you will get the entry in the section of the manual
    that has the smallest section number.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get a good sense of the output generated by `strace(1)`, look at the following
    figure where `strace(1)` is used to examine the executable of `addCLAImproved.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6c0c5c81-3946-433a-bc90-4dafd085d3a0.png)'
  prefs: []
  type: TYPE_IMG
- en: Using the strace(1) command on a Linux machine
  prefs: []
  type: TYPE_NORMAL
- en: 'The really interesting part of the `strace(1)` output is the following line,
    which cannot be seen in the preceding figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: We used the `grep(1)` command-line utility to extract the lines that contain
    the C system call that interests us, which in this case is `write(2)`. This is
    because we already know that `write(2)` is used for printing output. So, you learned
    that in this case, a single `write(2)` C system call is used for printing all
    of the output on the screen; its first parameter is the file descriptor, and its
    second parameter is the text you want to print.
  prefs: []
  type: TYPE_NORMAL
- en: Note that you might want to use `strace(1)` with the `-f` option in order to
    also trace any child processes that might get created during the execution of
    a program.
  prefs: []
  type: TYPE_NORMAL
- en: Bear in mind that there exist two more variations of `write(2)`, named `pwrite(2)`
    and `writev(2)`, which offer the same core functionality as `write(2)` but in
    a slightly different way.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following variation of the previous command requires more calls to `write(2)`
    because it generates more output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Unix uses file descriptors, which are positive integer values, as an internal
    representation for accessing all its files. By default, all Unix systems support
    three special and standard filenames: `/dev/stdin`, `/dev/stdout`, and `/dev/stderr`.
    They can also be accessed using file descriptors 0, 1, and 2, respectively. These
    three file descriptors are also called standard input, standard output, and standard
    error, respectively. Additionally, the file descriptor 0 can be accessed as `/dev/fd/0`
    on a Mac machine and as `/dev/pts/0` on a Debian Linux machine because everything
    in Unix is a file.'
  prefs: []
  type: TYPE_NORMAL
- en: So, the reason for needing to put `2>&1` at the end of the command is to redirect
    all of the output, from standard error (file descriptor 2) to standard output
    (file descriptor 1), in order to be able to search it using the `grep(1)` command,
    which searches standard output only. Note that there exist many variations of
    `grep(1)`, including `zegrep(1)`, `fgrep(1)`, and `fgrep(1)`, that might work
    faster when they have to deal with large or huge text files.
  prefs: []
  type: TYPE_NORMAL
- en: What you can see here is that even if you are writing in Go, the generated executable
    uses C system calls and functions because apart from using machine language, C
    is the only way to communicate with the Unix kernel.
  prefs: []
  type: TYPE_NORMAL
- en: The DTrace utility
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although debugging utilities, such as `strace(1)` and `truss(1)`, which work
    on FreeBSD, can trace system calls produced by a process, they can be slow and
    therefore not appropriate for solving performance problems on busy Unix systems.
    Another tool named `dtrace(1)`, which uses the **DTrace** facility, allows you
    to see what happens behind the scenes on a system-wide basis without the need
    to modify or recompile anything. It also allows you to work on production systems
    and watch running programs or server processes dynamically without introducing
    a big overhead.
  prefs: []
  type: TYPE_NORMAL
- en: 'This subsection will use the `dtruss(1)` command-line utility, which is just
    a `dtrace(1)` script, that shows the system calls of a process. The output that
    `dtruss(1)` generates when examining the `addCLAImproved.go` executable on a macOS
    machine looks similar to the one that you can see in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f596ddbd-3b87-454d-8eda-478318fd1014.png)'
  prefs: []
  type: TYPE_IMG
- en: Using the dtruss(1) command on a macOS machine
  prefs: []
  type: TYPE_NORMAL
- en: 'Once again, the following part of the output verifies that at the end of the
    day, everything on Unix machines is translated into C system calls and functions
    because this is the only way to communicate with the Unix kernel. You can display
    all the calls to the `write(2)` system call as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: However, this time you are going to get lots of output because the macOS executable
    uses `write(2)` multiple times instead of just once to print the same output.
  prefs: []
  type: TYPE_NORMAL
- en: Starting to realize that not all Unix systems work the same way, despite their
    numerous similarities, is marvelous. But this also means that you should not make
    any assumptions about the way a Unix system works behind the scenes.
  prefs: []
  type: TYPE_NORMAL
- en: 'What is really interesting is the last part of the output of the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The reason you get this output is the `-c` option that tells `dtruss(1)` to
    count all system calls and print a summary of them, which in this case shows that
    `write(2)` has been called 83 times and `stat64(2)` 41 times.
  prefs: []
  type: TYPE_NORMAL
- en: The `dtrace(1)` utility is much more powerful than `strace(1)` and has its own
    programming language but is more difficult to learn. Additionally, even though
    there is a Linux version of `dtrace(1)`, `strace(1)` is more mature on Linux systems
    and does the job of tracing system calls in a simpler way.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can learn more about the `dtrace(1)` utility by reading *DTrace: Dynamic
    Tracing in Oracle Solaris, Mac OS X, and FreeBSD* by Brendan Gregg and Jim Mauro
    and by visiting [http://dtrace.org/](http://dtrace.org/).'
  prefs: []
  type: TYPE_NORMAL
- en: Disabling System Integrity Protection on macOS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is a big chance that you will have trouble running `dtrace(1)` and `dtruss(1)`
    on your Mac OS X machine the first time you try them and get the following error
    message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: In this case you might need to disable the DTrace restrictions but still keep
    System Integrity Protection active for everything else. You can learn more about
    System Integrity Protection by visiting [https://support.apple.com/en-us/HT204899](https://support.apple.com/en-us/HT204899).
  prefs: []
  type: TYPE_NORMAL
- en: Unreachable code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unreachable code is code that can never be executed and is a logical kind of
    error. As the Go compiler itself cannot catch such logical errors, you will need
    to use the `go tool vet` command to help.
  prefs: []
  type: TYPE_NORMAL
- en: You should not confuse unreachable code with code that never gets executed intentionally,
    such as the code of a function that is not needed and is therefore not called
    in a program.
  prefs: []
  type: TYPE_NORMAL
- en: The example code in this section is saved as `cannotReach.go` and can be divided
    into two parts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part has the following Go code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The second part is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the unreachable code is in the first part. Both `x()` and `y()`
    functions have unreachable code because their `return` statements were put at
    the wrong place. However, we are not done yet because we will have to let the
    `go tool vet` tool discover the unreachable code. The process is simple and includes
    the execution of the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Additionally, you can see that `go tool vet` detects unreachable code even if
    the surrounding function is not going to be executed at all, as happens with `y()`.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding common Go mistakes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This section will briefly talk about some common Go mistakes so that you can
    avoid them in your programs:'
  prefs: []
  type: TYPE_NORMAL
- en: If you have an error in a Go function, either log it or return it; do not do
    both unless you have a really good reason to do so.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Go interfaces define behaviors, not data and data structures.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the `io.Reader` and `io.Writer` interfaces because they make your code more
    extensible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make sure that you pass a pointer to a variable to a function only when needed.
    The rest of the time, just pass the value of the variable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Error variables are not strings; they are `error` values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are afraid of making mistakes, you will most likely end up doing nothing
    useful. So experiment as much as you can.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following are general pieces of advice that can be applied in every programming
    language:'
  prefs: []
  type: TYPE_NORMAL
- en: Test your Go code and functions in small and autonomous Go programs to make
    sure that they behave the way you think they should
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you do not really know a Go feature, test it before using it for the first
    time, especially if you are developing a systems utility
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do not test systems software on production machines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you deploy your systems software on a production machine, do it when the
    production machine is not busy and make sure that you have a backup plan
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Find and visit the documentation page of the `log` package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use `strace(1)` to examine `hw.go` from the previous chapter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you are on a Mac, try to examine the `hw.go` executable using `dtruss(1)`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a program that gets input from the user and examine its executable file
    using either `strace(1)` or `dtruss(1)`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Visit the website of Rust at [https://www.rust-lang.org/](https://www.rust-lang.org/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Visit the website of Swift at [https://swift.org/](https://swift.org/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Visit the documentation page of the `io` package at [https://golang.org/pkg/io/](https://golang.org/pkg/io/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `diff(1)` command-line utility on your own in order to learn how to
    interpret its output better.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Visit and read the main page of `write(2)`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Visit the main page of `grep(1)`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Play with reflection on your own by examining your own structures.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write an improved version of `occurrences.go` that will only display frequencies
    that are above a known numeric threshold, which will be given as a command-line
    argument.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter taught you some advanced Go features, including error handling,
    pattern matching and regular expressions, reflection, and unsafe code. Also, it
    talked about the `strace(1)` and `dtrace(1)` tools.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will cover many interesting things, including the use of the
    new `sort.slice()` Go function, which is available in the latest Go version (1.8),
    as well as the big O notation, sorting algorithms, Go packages, and garbage collection.
  prefs: []
  type: TYPE_NORMAL
