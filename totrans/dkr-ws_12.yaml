- en: 12\. Best Practices
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn some of the best practices to use when working
    with Docker and your container images. This will enable you to monitor and manage
    the resources used by your container and limit their effect on your host system.
    You will analyze Docker's best practices and learn why it's important to only
    be running one service per container, ensuring that your containers are scalable
    and immutable and making sure that your underlying applications start in a short
    amount of time. This chapter will help you to enforce these best practices by
    linting your `Dockerfiles` and `docker-compose.yml` files before your applications
    and containers are running with the help of `hadolint's` `FROM:latest` command
    and `dcvalidator`.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous chapter on security covered some best practices for Docker images
    and services that have adhered to these best practices. We made sure that our
    images and services were secure and that they limited what could be achieved if
    an attacker was able to access the image. This chapter will not only take you
    through the best practices in creating and running our Docker images, but will
    also focus on container performance, configuring our services, and ensuring that
    the services running on them are running as efficiently as possible.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: We will start this chapter with an in-depth look at how you can both monitor
    and configure the resources being used by your services, such as memory and CPU
    usage. We will then take you through some important practices that you can implement
    in your projects, looking at how you create your Docker images and the applications
    that are running on them. Lastly, this chapter will give you some practical tools
    to use to test your `Dockerfiles` and `docker-compose.yml` files, which will serve
    as a way to ensure that you are following the mentioned practices.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: This chapter shows how you can ensure that you optimize your services and containers
    as much as possible to make sure that they run without issues from your development
    environment through to production. The goal of this chapter is to make sure that
    your services are starting up as quickly as possible and are processing as efficiently
    as they can. The practices mentioned in this chapter also ensure reusability (that
    is, they make sure that anyone who wants to reuse your images or code can do so
    and can understand specifically what is happening at all times). To begin with,
    the following section discusses how to work with container resources.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章展示了如何确保尽可能优化您的服务和容器，以确保它们从开发环境到生产环境都能无故障地运行。本章的目标是确保您的服务尽快启动，并尽可能高效地处理。本章提到的实践还确保了可重用性（也就是说，他们确保任何想要重用您的镜像或代码的人都可以这样做，并且可以随时了解具体发生了什么）。首先，以下部分讨论了如何使用容器资源。
- en: Working with Container Resources
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用容器资源
- en: One of the main benefits of moving to Docker from a traditional server environment
    is that it enables us to heavily reduce the footprint of our services and applications,
    even when moving to production. This doesn't mean we can simply run anything on
    our container, expecting all the processes to simply complete their execution,
    however. Just as we would need resources with a service running on a standalone
    server, we need to ensure that the resources (such as CPU, memory, and disk input
    and output) that are being used by our containers do not cause our production
    environments or any other containers to crash. By monitoring the resources used
    in our development system, we can help optimize processes and ensure that the
    end-user is experiencing seamless operation when we move it into production.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 从传统服务器环境迁移到Docker的主要好处之一是，即使在转移到生产环境时，它使我们能够大大减少服务和应用程序的占用空间。然而，这并不意味着我们可以简单地在容器上运行任何东西，期望所有进程都能顺利完成执行。就像在独立服务器上运行服务时一样，我们需要确保我们的容器使用的资源（如CPU、内存和磁盘输入输出）不会导致我们的生产环境或任何其他容器崩溃。通过监控开发系统中使用的资源，我们可以帮助优化流程，并确保最终用户在将其移入生产环境时体验到无缝操作。
- en: By testing our services and monitoring resource usage, we will be able to understand
    the resources required by the running applications and ensure that the hosts running
    our Docker images have adequate resources to run our service. Lastly, as you will
    see in the upcoming sections, we can also limit the amount of CPU and memory resources
    the container can have access to. When developing our services running on Docker,
    we need to be testing these services on our development system to know exactly
    what will happen when they are moved into test and production environments.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 通过测试我们的服务并监控资源使用情况，我们将能够了解运行应用程序所需的资源，并确保运行我们Docker镜像的主机具有足够的资源来运行我们的服务。最后，正如您将在接下来的章节中看到的，我们还可以限制容器可以访问的CPU和内存资源的数量。在开发运行在Docker上的服务时，我们需要在开发系统上测试这些服务，以确切了解它们在移入测试和生产环境时会发生什么。
- en: When we bring a number of different services (such as a database, web server,
    and API gateway) together to create an application, some services are more important
    than others, and in some circumstances, these services may need to have more resources
    allocated to them. However, in Docker, the running container does not have a real
    limit on the resources it can use by default.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将多种不同的服务（如数据库、Web服务器和API网关）组合在一起创建一个应用程序时，有些服务比其他服务更重要，在某些情况下，这些服务可能需要分配更多资源。然而，在Docker中，运行的容器默认情况下并没有真正的资源限制。
- en: In previous chapters, we learned about orchestration using Swarm and Kubernetes,
    which helps in distributing resources across your system, but this part of the
    chapter will teach you about some basic tools to test and monitor your resources
    with. We will also look at the ways in which you can configure your containers
    to no longer use the default resources available.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，我们学习了使用Swarm和Kubernetes进行编排，这有助于在系统中分配资源，但本章的这一部分将教您一些基本工具来测试和监视您的资源。我们还将看看您可以如何配置您的容器，以不再使用默认可用的资源。
- en: To help us in this part of the chapter, we are going to create a new image that
    will only serve the purpose of demonstrating resource usage in our system. In
    the first part of this section, we will create an image that will add an application
    called stress. The main function of the stress application is to impose a heavy
    load on our system. The image will allow us to view the resources being used on
    our host system and then allow us to use different options when running the Docker
    image to limit the resources being used.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助我们在本章的这一部分，我们将创建一个新的镜像，该镜像将仅用于演示我们系统中的资源使用情况。在本节的第一部分中，我们将创建一个将添加一个名为stress的应用程序的镜像。stress应用程序的主要功能是对我们的系统施加重负载。该镜像将允许我们查看在我们的主机系统上使用的资源，然后允许我们在运行Docker镜像时使用不同的选项来限制使用的资源。
- en: Note
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This section of the chapter will give you some brief guidelines on monitoring
    the resources of our running Docker containers. This chapter will only cover some
    simple concepts as we are going to be dedicating an entire chapter of this book
    to providing in-depth details on monitoring your container metrics.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的这一部分将为您提供有关监视我们正在运行的Docker容器资源的简要指南。本章将仅涵盖一些简单的概念，因为我们将在本书的另一章节中专门提供有关监视容器指标的深入细节。
- en: 'To help us view the resources being consumed by our running containers, Docker
    provides the `stats` command as a live stream of resources being consumed by our
    running containers. If you wish to limit the data presented by the stream, especially
    if you have a large number of containers running, you can specify to only provide
    certain containers by specifying the name of the container or its ID:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助我们查看正在运行的容器消耗的资源，Docker提供了`stats`命令，作为我们正在运行的容器消耗资源的实时流。如果您希望限制流所呈现的数据，特别是如果您有大量正在运行的容器，您可以通过指定容器的名称或其ID来指定只提供某些容器：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The default output of the `docker` `stats` command will provide you with the
    name and ID of the container, the percentage of host CPU and memory that the container
    is using, the data that the container is sending and receiving, and the amount
    of data both read and written from the host''s storage:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker` `stats`命令的默认输出将为您提供容器的名称和ID，容器正在使用的主机CPU和内存的百分比，容器正在发送和接收的数据，以及从主机存储中读取和写入的数据量：'
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The following section will highlight how we can use the `docker stats` command
    to monitor our resources. We will also provide format controls to the `stats`
    command to provide only the information we need.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分将重点介绍如何使用`docker stats`命令来监视我们的资源。我们还将向`stats`命令提供格式控制，以提供我们需要的信息。
- en: Managing Container CPU Resources
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理容器CPU资源
- en: This section of the chapter will show you how to set limits on the amount of
    CPU being used by the container, as a container running without limits can use
    up all the available CPU resources on a host server. We will be looking at optimizing
    our running Docker container, but the actual issue with a large amount of CPU
    being used usually lies with the underlying infrastructure or the applications
    running on the container.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的这一部分将向您展示如何设置容器使用的CPU数量限制，因为没有限制的容器可能会占用主机服务器上所有可用的CPU资源。我们将着眼于优化我们正在运行的Docker容器，但实际上大量使用CPU的问题通常出现在基础设施或容器中运行的应用程序上。
- en: When we discuss CPU resources, we usually refer to a single physical computer
    chip. These days, a CPU will most likely have more than one core, with more cores
    meaning more processes. But this doesn't mean we have unlimited resources. When
    we display the CPU percentage being used, unless you have a system that only has
    one CPU with one core, you will most likely see more than 100% of the CPU being
    used. For example, if you have four cores in the CPU of your system, and your
    container is utilizing all of the CPU, you will see a value of 400%
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们讨论CPU资源时，通常是指单个物理计算机芯片。如今，CPU很可能有多个核心，更多的核心意味着更多的进程。但这并不意味着我们拥有无限的资源。当我们显示正在使用的CPU百分比时，除非您的系统只有一个CPU和一个核心，否则您很可能会看到超过100%的CPU使用率。例如，如果您的系统的CPU中有四个核心，而您的容器正在利用所有的CPU，您将看到400%的值。
- en: 'We can modify the `docker stats` command running on our system to only provide
    the CPU usage details by providing the `--format` option. This option allows us
    to specify the output format we require, as we may only require one or two of
    the metrics provided by the `stats` command. The following example configures
    the output of the `stats` command to be displayed in a `table` format, only presenting
    the container''s name, its ID, and the percentage of CPU being used:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以修改在我们的系统上运行的`docker stats`命令，通过提供`--format`选项来仅提供CPU使用情况的详细信息。这个选项允许我们指定我们需要的输出格式，因为我们可能只需要`stats`命令提供的一两个指标。以下示例配置了`stats`命令的输出以以`table`格式显示，只呈现容器的名称、ID和正在使用的CPU百分比：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This command, if we have no Docker images running, will provide a table with
    the following three columns:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有运行Docker镜像，这个命令将提供一个包含以下三列的表格：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To control the number of cores being used on the CPU by our running container,
    we can use the `--cpus` option with our `docker run` command. The following syntax
    shows us running the image, but limiting the number of cores the image will have
    access to by using the `--cpus` option:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为了控制我们正在运行的容器使用的CPU核心数量，我们可以在`docker run`命令中使用`--cpus`选项。以下语法向我们展示了运行镜像，但通过使用`--cpus`选项限制了镜像可以访问的核心数量：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: A better option is not to set the number of cores a container can use, but instead
    how much of the total it can share. Docker provides the `--cpushares`, or `-c`,
    option to set a priority to how much of the processing power a container can use.
    By using this option, it means we don't need to know how many cores the host machine
    has before running the container. It also means that we can transfer the running
    container to different host systems without needing to change the command the
    image is run with.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的选择不是设置容器可以使用的核心数量，而是设置它可以共享的总量。Docker提供了`--cpushares`或`-c`选项来设置容器可以使用的处理能力的优先级。通过使用这个选项，这意味着在运行容器之前我们不需要知道主机机器有多少个核心。这也意味着我们可以将正在运行的容器转移到不同的主机系统，而不需要更改运行镜像的命令。
- en: 'By default, Docker will allocate 1,024 shares to every running container. If
    you set the `--cpushares` value to `256`, it would have a quarter of the processing
    shares of other running containers:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Docker将为每个运行的容器分配1,024份份额。如果您将`--cpushares`值设置为`256`，它将拥有其他运行容器的四分之一的处理份额：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If no other containers are running on your system, even if you have set the
    `--cpushares` value to `256`, the container will then be allowed to use up the
    remaining processing power.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果系统上没有运行其他容器，即使您已将`--cpushares`值设置为`256`，容器也将被允许使用剩余的处理能力。
- en: Even though your application may be running fine, it's always good practice
    to see how it will work when you reduce the amount of CPU it has available to
    it, as well as seeing how much it will consume while it is running normally.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 即使您的应用程序可能正在正常运行，查看减少其可用CPU量以及在正常运行时消耗多少的做法总是一个好习惯。
- en: In the next exercise, we will use the `stress` application to monitor the resource
    usage on the system.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个练习中，我们将使用`stress`应用程序来监视系统上的资源使用情况。
- en: Note
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Please use `touch` command to create files and `vim` command to work on the
    file using vim editor.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 请使用`touch`命令创建文件，并使用`vim`命令使用vim编辑器处理文件。
- en: 'Exercise 12.01: Understanding CPU Resources on Your Docker Image'
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习12.01：了解Docker镜像上的CPU资源
- en: 'In this exercise, you will first create a new Docker image that will help you
    generate some resources on your system. We will demonstrate how to use the `stress`
    application installed on the image. The application will allow you to start monitoring
    resource usage on your system, as well as allowing you to change the number of
    CPU resources being used by the image:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您将首先创建一个新的Docker镜像，这将帮助您在系统上生成一些资源。我们将演示如何在镜像上使用已安装的`stress`应用程序。该应用程序将允许您开始监视系统上的资源使用情况，以及允许您更改镜像使用的CPU资源数量：
- en: 'Create a new `Dockerfile` and open your favorite text editor to enter the following
    details. You will be creating the image using Ubuntu as a base because the `stress`
    application is not yet provided as a package to be easily installed on an Alpine
    base image:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`Dockerfile`并打开您喜欢的文本编辑器输入以下细节。您将使用Ubuntu作为基础来创建镜像，因为`stress`应用程序尚未作为易于在Alpine基础镜像上安装的软件包提供：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Build the new image and tag it as `docker-stress` using the `-t` option of
    the `docker build` command:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`docker build`命令的`-t`选项构建新镜像并将其标记为`docker-stress`：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Stop and remove all the other containers first before running the new `docker-stress`
    image to make sure that the results are not confused by other containers running
    on our system:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在运行新的`docker-stress`镜像之前，请先停止并删除所有其他容器，以确保结果不会被系统上运行的其他容器混淆：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'On *line 3* of the `Dockerfile`, you''ll notice that the `CMD` instruction
    is running the stress application following the `$var` variable. This will allow
    you to add command-line options directly to the stress application running on
    the container via environment variables, without having to build a new image every
    time you want to change the functionality. Test this out by running your image
    and using the `-e` option to add environment variables. Add `var="--cpu 4 --timeout
    20"` as a command-line option to the `stress` command:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Dockerfile`的*第3行*上，您会注意到`CMD`指令正在运行stress应用程序，后面跟着`$var`变量。这将允许您通过环境变量直接向容器上运行的stress应用程序添加命令行选项，而无需每次想要更改功能时都构建新镜像。通过运行您的镜像并使用`-e`选项添加环境变量来测试这一点。将`var="--cpu
    4 --timeout 20"`作为`stress`命令的命令行选项添加：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `docker run` command has added the `var="--cpu 4 --timeout 20"` variable,
    which will specifically run the `stress` command with these command-line options.
    The `--cpu` option is stating that four CPUs or cores of the system will be used,
    and the `--timeout` option will allow the stress test to run for the designated
    number of seconds specified – in this case, `20`:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker run`命令已添加了`var="--cpu 4 --timeout 20"`变量，这将特别使用这些命令行选项运行`stress`命令。`--cpu`选项表示将使用系统的四个CPU或核心，`--timeout`选项将允许压力测试运行指定的秒数
    - 在本例中为`20`：'
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If we need to run the `stress` command continuously without stopping, we will
    simply not include the `--timeout` option. Our examples all include the `timeout`
    option as we don't want to forget and continuously use resources on a running
    host system.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要连续运行`stress`命令而不停止，我们将简单地不包括`--timeout`选项。我们的示例都包括`timeout`选项，因为我们不想忘记并持续使用运行主机系统的资源。
- en: 'Run the `docker stats` command to see what effect this has on your host system.
    Limit the output provided to only give CPU usage by using the `--format` option:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`docker stats`命令，查看这对主机系统的影响。使用`--format`选项限制所提供的输出，只提供CPU使用情况：
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Unless you have a container running on your system, you should only see the
    table headings, similar to the output provided here:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 除非您的系统上运行着一个容器，否则您应该只看到表头，类似于此处提供的输出：
- en: '[PRE12]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'While the `stats` command is running, move into a new terminal window and run
    the `docker-stress` container again, as in *step 4* of this exercise. Use the
    `--name` option to make sure you are viewing the correct image when using the
    `docker stress` command:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在运行`stats`命令的同时，进入一个新的终端窗口，并再次运行`docker-stress`容器，就像本练习的*步骤4*中一样。使用`--name`选项确保在使用`docker
    stress`命令时查看正确的镜像：
- en: '[PRE13]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Move back to the terminal running `docker stats`. You should now see some output
    presented on your table. Your output will be different from the following as you
    may have a different number of cores running on your system. The following output
    is showing that 400% of our CPU percentage is being used. The system on which
    the command is run has six cores. It shows that the stress application is using
    100% of four of the cores available:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到运行`docker stats`的终端。现在您应该看到一些输出呈现在您的表上。您的输出将与以下内容不同，因为您的系统上可能运行着不同数量的核心。以下输出显示我们的CPU百分比使用了400%。运行该命令的系统有六个核心。它显示stress应用程序正在使用四个可用核心中的100%：
- en: '[PRE14]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Once again, run the `docker-stress` container, this time with `8` set for the
    `--cpu` option:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行`docker-stress`容器，这次将`--cpu`选项设置为`8`：
- en: '[PRE15]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'As you can see in the following stats output, we have hit the limit where your
    Docker container is using almost 100% of all six cores on our system, leaving
    a small amount for processing power for minor processes on our system:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在以下统计输出中所见，我们已经达到了Docker容器几乎使用系统上所有六个核心的极限，为我们的系统上的次要进程留下了一小部分处理能力：
- en: '[PRE16]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Manage the number of cores that your `docker-stress` image can have access
    to by using the `--cpus` option and specifying the number of cores you want to
    allow the image to use. In the following command, `2` is set as the number of
    cores our container is allowed to use:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用`--cpus`选项并指定要允许镜像使用的核心数量，来管理您的`docker-stress`镜像可以访问的核心数量。在以下命令中，将`2`设置为我们的容器被允许使用的核心数量：
- en: '[PRE17]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Move back to the terminal running `docker stats`. You will see that the CPU
    percentage being used does not exceed much more than 200%, showing that Docker
    is restricting resource usage to only two of the cores available on our system:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到运行`docker stats`的终端。您将看到正在使用的CPU百分比不会超过200%，显示Docker将资源使用限制在我们系统上仅有的两个核心：
- en: '[PRE18]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: So far, you have only been running one container on our system at a time. The
    next section of this exercise will allow you to run two containers in detached
    mode. Here, you will test using the `--cpu-shares` option on one of your running
    containers to limit the number of cores it can use.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您只能一次在我们的系统上运行一个容器。这个练习的下一部分将允许您以分离模式运行两个容器。在这里，您将测试在运行的一个容器上使用`--cpu-shares`选项来限制它可以使用的核心数量。
- en: 'If you don''t have `docker stats` running in a terminal window, do so by starting
    it up as you have done previously to allow us to monitor the processes that are
    running:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您没有在终端窗口中运行`docker stats`，请像之前一样启动它，以便我们监视正在运行的进程：
- en: '[PRE19]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Access another terminal window and start up two `docker-stress` containers
    – `docker-stress1` and `docker-stress2`. The first will use a `--timeout` value
    of `60` to have the stress application running for 60 seconds, but here, limit
    the `--cpu-shares` value to `512`:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问另一个终端窗口，并启动两个`docker-stress`容器 - `docker-stress1`和`docker-stress2`。第一个将使用`--timeout`值为`60`，让压力应用程序运行60秒，但在这里，将`--cpu-shares`值限制为`512`：
- en: '[PRE20]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The container''s ID will be returned as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 容器的ID将返回如下：
- en: '[PRE21]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The second container will not be limited but will have a `--timeout` value
    of only `30`, so it should complete first:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个容器将不受限制，但`--timeout`值只有`30`，所以它应该先完成：
- en: '[PRE22]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The container''s ID will be returned as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 容器的ID将返回如下：
- en: '[PRE23]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Move back to our terminal running `docker stats`. You''ll see two containers
    running. In the following output, we can see the containers named `docker-stress1`
    and `docker-stress2`. The `docker-stress1` container has been set to have only
    `512` CPU shares while other containers are running. It can also be observed that
    it is only using half the amount of CPU resources as our second container named
    `docker-stress2`:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到运行`docker stats`的终端。您会看到两个容器正在运行。在以下输出中，我们可以看到名为`docker-stress1`和`docker-stress2`的容器。`docker-stress1`容器被设置为只有`512`
    CPU份额，而其他容器正在运行。还可以观察到它只使用了第二个名为`docker-stress2`的容器的一半CPU资源：
- en: '[PRE24]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'When your second container completes the CPU percentage for the `docker-stress1`
    container, it is then allowed to move up to using almost all six cores available
    on the running system:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当第二个容器完成后，`docker-stress1`容器的CPU百分比将被允许使用运行系统上几乎所有六个可用的核心：
- en: '[PRE25]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: CPU resources play an important part in making sure that your applications are
    running at their best. This exercise has shown you how easy it is to monitor and
    configure your container's processing power while it is still on your system before
    deploying it into a production environment. The next section will move on to performing
    similar monitoring and configuration changes on our container's memory.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: CPU资源在确保应用程序以最佳状态运行方面起着重要作用。这个练习向您展示了在将容器部署到生产环境之前，监视和配置容器的处理能力有多么容易。接下来的部分将继续对容器的内存执行类似的监视和配置更改。
- en: Managing Container Memory Resources
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理容器内存资源
- en: Just as we can monitor and control the CPU resources our container is using
    on our system, we can also do the same with the memory being used. As with CPU,
    the running container is able to use all of the host's memory with the default
    settings provided by Docker, and in some cases can cause the system to become
    unstable if it is not limited. If the host systems kernel detects that there is
    not enough memory available, it will show an **out-of-memory exception** and start
    to kill off the processes on the system to help free up memory.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们可以监视和控制容器在系统上使用的CPU资源一样，我们也可以对内存的使用情况进行相同的操作。与CPU一样，默认情况下，运行的容器可以使用主机的所有内存，并且在某些情况下，如果没有限制，可能会导致系统变得不稳定。如果主机系统内核检测到没有足够的内存可用，它将显示**内存不足异常**并开始终止系统上的进程以释放内存。
- en: The good news is that the Docker daemon has a high priority on your system,
    so the kernel will first kill off running containers before it stops the Docker
    daemon from running. This means that your system should be able to recover if
    the high memory usage is being caused by a container application.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，Docker守护程序在您的系统上具有高优先级，因此内核将首先终止运行的容器，然后才会停止Docker守护程序的运行。这意味着如果高内存使用是由容器应用程序引起的，您的系统应该能够恢复。
- en: Note
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If your running containers are being shut down, you will also need to make sure
    you have tested your application to ensure that you are limiting the impact it
    is having on your running processes.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的运行容器正在被关闭，您还需要确保已经测试了您的应用程序，以确保它对正在运行的进程的影响是有限的。
- en: 'Once again, the `docker stats` command gives us quite a bit of information
    on memory usage. It will output the percentage of the memory the container is
    using as well as the current memory being used compared with the total amount
    of memory it is able to use. As we did previously, we can restrict the output
    presented with the `--format` option. In the following command, we are reducing
    the output provided by only displaying the container name and ID, as well as the
    memory percentage and memory usage, via the `.Name`, `.Container`, `.MemPerc`,
    and `.MemUsage` attributes, respectively:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，`docker stats`命令为我们提供了关于内存使用情况的大量信息。它将输出容器正在使用的内存百分比，以及当前内存使用量与其能够使用的总内存量的比较。与之前一样，我们可以通过`--format`选项限制所呈现的输出。在以下命令中，我们通过`.Name`、`.Container`、`.MemPerc`和`.MemUsage`属性，仅显示容器名称和ID，以及内存百分比和内存使用量：
- en: '[PRE26]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'With no containers running, the preceding command will show the following output:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 没有运行的容器，上述命令将显示以下输出：
- en: '[PRE27]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If we want to limit or control the amount of memory being used by our running
    container, there are a few options available to us. One of the options available
    is the `--memory`, or `-m`, option, which will set a limit for the amount of memory
    a running container can use. In the following example, we have used a syntax of
    `--memory 512MB` to limit the amount of memory available to the image to `512MB`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要限制或控制运行容器使用的内存量，我们有一些选项可供选择。其中一个可用的选项是`--memory`或`-m`选项，它将设置运行容器可以使用的内存量的限制。在以下示例中，我们使用了`--memory
    512MB`的语法来限制可用于镜像的内存量为`512MB`：
- en: '[PRE28]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If the host system that the container is running on is also using swap space
    as part of its available memory, you can also assign memory from that container
    to be run as swap. This is simply done by using the `--memory-swap` option. This
    can only be used in conjunction with the `--memory` option, as we have demonstrated
    in the following example. We have set the `--memory-swap` option as `1024MB`,
    which is the total amount of memory available to the container of both memory
    and swap memory. So, in our example, there will be a further `512MB` available
    in the swap:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: You need to remember, though, that swap memory will be assigned to disk, so
    as a consequence, it will be slower and less responsive than RAM.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: The `--memory-swap` option needs to be set to a number higher than the `--memory`
    option. If it is set to the same number, you will not be able to assign any memory
    from that running container to swap.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: 'Another option available, and only to be used if you need to ensure the availability
    of the running container at all times, is the `--oom-kill-disable` option. This
    option stops the kernel from killing the running container if the host system
    runs too low on memory. This should only be used together with the `--memory`
    option to ensure that you set a limit to the memory available to the container.
    Without a limit, the `--oom-kill-disable` option could easily use all the memory
    on the host system:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Even though your applications will be well designed, the preceding configurations
    give you some options to control the amount of memory being used by your running containers.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: The next section will provide you with hands-on experience in analyzing the
    memory resources on your Docker image.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 12.02: Analyzing Memory Resources on Your Docker Image'
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This exercise will help you analyze how memory is used by your active containers
    while running on your host system. Once again, you will be using the `docker-stress`
    image created earlier, but this time with options to only use memory on the running
    container. This command will allow us to implement some of the memory-limiting
    options available to ensure our running containers do not bring down our running
    host system:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the `docker stats` command to display the relevant information you need
    for the percentage memory and memory usage values:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This command will provide an output like the following:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Open a new terminal window to run the `stress` command again. Your `docker-stress`
    image will only utilize CPU when you use the `--cpu` option. Use the `--vm` option
    in the following command to start up the number of workers you wish to spawn to
    consume memory. By default, each of them will consume `256MB`:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'When you move back to monitor the running container, the memory used only reached
    about 20% of the limit. This may be different for different systems. As only two
    workers are running to consume 256 MB each, you should only see it reach around
    500 MB of memory usage:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The stress application also has the `--vm-bytes` option to control the number
    of bytes that each worker being spawned up will consume. Enter the following command,
    which has set each worker to `128MB`. It should show a lower usage when you monitor
    it:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'As you can see, the stress application struggles to push the memory usage up
    very far at all. If you wanted to use all 8 GB of RAM you have available on your
    system, you could use `--vm 8 --vm-bytes` of 1,024 MB:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Reduce the amount of memory available to the `docker-stress` image with the
    `--memory` option. In the following command, you will see that we have set the
    available memory of the running container to be limited to `512MB`:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Move back to the terminal running `docker stats`, and you will see that the
    percentage of memory used spikes to almost 100%. This isn''t a bad thing as it
    is only a small percentage of the memory allocated to your running container.
    In this instance, it is 512 MB, which is only a quarter of what it was previously:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Run more than one container at a time and see how our `stats` command responds.
    Use the `-d` option as part of the `docker run` commands to run the container
    as a daemon in the background of your host system. Both of the `docker-stress`
    containers are now going to use six workers each, but our first image, which we
    will name `docker-stress1`, is limited to `512MB` of memory, while our second
    image, named `docker-stress2`, which is only running for 20 seconds, will have
    an unlimited amount of memory:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Move back to the terminal running `docker stats`. You can see that only one
    container, the `docker-stress1` container, is limited to 512 MB, while the `docker-stress2`
    image is allowed to run on a lot more memory:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'If you wait a few moments, the `docker-stress1` image will be left to run on
    its own:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Note
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: One option we haven't covered here is the `--memory-reservation` option. This
    is also used with the `--memory` option and needs to be set lower than the memory
    option. It is a soft limit that is activated when the memory on the host system
    is running low, but it is not guaranteed that the limit will be enforced.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: This part of the chapter has helped to identify how you can run your containers
    and monitor usage so that when they are moved into production, they are not stopping
    the host system by using up all the available memory. You should now be able to
    identify how much memory your image is using and also limit the amount available
    if there are issues with long-running or memory-intensive processes. In the next
    section, we will look at how our container consumes the device's read and write
    resources on our host system disks.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: Managing the Container Disk's Read and Write Resources
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The CPU and memory consumed by a running container are usually the biggest culprits
    for an environment running poorly, but there could also be an issue with your
    running containers trying to read or write too much to the host's disk drive.
    This would most likely have less impact than CPU or memory issues, but if there
    was a large amount of data being transferred to the host system's drives, it could
    still cause contention and slow your services down.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, Docker also provides us with a way to control the amount of reading
    and writing that our running containers can perform. Just as we've seen previously,
    we can use a number of options with our `docker run` command to limit the amount
    of data we are either reading or writing to our device disks.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: 'The `docker stats` command also allows us to see the data being transferred
    to and from our running container. It has a dedicated column that can be added
    to our table using the `BlockIO` value in our `docker stats` command, which represents
    the read and writes to our host disk drive or directories:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'If we don''t have any running containers on our system, the preceding command
    should provide us with the following output:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'If we ever need to limit the amount of data that a running container can move
    to our host system''s disk storage, we can start by using the `--blkio-weight`
    option with our `docker run` command. This option stands for **Block Input Output
    Weight** and allows us to set a relative weight for the container to be between
    `10` and `1000` and is relative to all the other containers running on your system.
    All containers will be set with the same proportion of bandwidth, which is 500\.
    If a value of 0 is provided to any container, this option will be switched off:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The next option we have available to use is `--device-write-bps`, which will
    limit the specific write bandwidth available to the device specified with a bytes-per-second
    value. The specific device is relative to the device the container is using on
    the host system. This option also has an `iops (Input/Output) per seconds` option
    that can also be used. The following syntax provides the basic usage of the option
    where the limit value is a numeric value set as MB:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Just as there is a way to limit write processes to the host system''s disk,
    there is also an option to limit the read throughput available. Once again, it
    also has an `iops (Input/Output) per seconds` option that can be used and will
    limit the amount of data that can be read from your running container. The following
    example uses the `--device-read-bps` option as part of the `docker run` command:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: If you're adhering to container best practices, overconsumption of disk input
    or output should not be too much of an issue. There is no reason to assume that
    this will not cause you any problems, though. Just as you have worked with both
    CPU and memory, your disk input and output should be tested on your running containers
    before your services are implemented in production.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 12.03: Understanding Disk Read and Write'
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This exercise will allow you to become familiar with viewing the disk read
    and write of your running container. It will allow you to start running your containers
    by configuring limits for the disk usage speeds with the options available at
    runtime:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a new terminal window and run the following command:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The `docker stats` command with the `BlockIO` option helps us monitor the levels
    of input and output moving from our container to the host system's disk.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: 'Start the container to access it from the bash command line. Perform some tests
    directly on a running `docker-stress` image. The stress application does give
    you some options to manipulate the disk utilization on your container and the
    host system, but it is limited to the only disk writes:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Unlike the CPU and memory usage, the block input and output show the total
    amount used by the container, so it will not be dynamic and change as the running
    container performs more changes. Move back to your terminal running `docker stats`.
    You should see `0B` for both input and output:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'You will be using the bash shell in this instance as it gives access to the
    `time` command to see how long each of these processes take. Use the `dd` command,
    which is a Unix command used to make copies of filesystems and backups. In the
    following option, create a copy of our `/dev/zero` directory, using the `if` (input
    file) option, and output it to the `disk.out` file with the `of` (output file)
    option. The `bs` option is the block size or the amount of data it should read
    at a time and `count` is the total amount of blocks to read. Finally, set the
    `oflag` value to `direct`, which means the copy will avoid the buffer cache, so
    you are seeing a true value of disk reads and writes:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Move back into the terminal running your `docker stats` command. You will see
    just over 10 MB of data sent to the host system''s disk. Unlike CPU and memory,
    you do not see this data value go down after the transfer has occurred:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: You'll also notice that the command in *step 4* was almost instantly completed,
    with the `time` command showing it took only `0.01s` in real-time to complete.
    You will see what happens if you restrict the amount of data that can be written
    to disk, but first, exit out of the running container so that it no longer exists
    on our system.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: 'To start our `docker-stress` container up again, set the `--device-write-bps`
    option to `1MB` per second on the `/dev/sda` device drive:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Run the `dd` command again, preceded by the `time` command, to test how long
    it takes. You should see that the command takes a lot longer than what it did
    in *step 4*. The `dd` command is once again set to copy `1MB` blocks, `10` times:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Because the container is limited to only write 1 MB per second, this command
    takes 10 seconds, as displayed in the following output:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: We've been able to easily see how our running container can affect the underlying
    host system, specifically when using disk read and write. We have also been able
    to see how we can easily limit the amount of data that can be written to our device,
    so there is less contention between running containers. In the next section, we
    are going to quickly answer the question of what you need to do if you are using
    `docker-compose` and look at limiting the number of resources being used by your
    containers.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: Container Resources and Docker Compose
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Orchestrators such as Kubernetes and Swarm go a long way in controlling and
    running your resources and spinning up new hosts if there are extra resources
    needed. But what do you do if you are running `docker-compose` in your system
    or a test environment? Fortunately, the previously mentioned resource configurations
    work nicely with `docker-compose` as well.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: Within our `docker-compose.yml` file, under our service, we can use the `resources`
    option under the `deploy` configurations and specify our resource limits for our
    service. Just as we have been using options such as `--cpus`, `--cpu_shares`,
    and `--memory`, we would use the same options in our `docker-compose.yml` file
    as `cpus`, `cpu_shares`, and `memory`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: 'The example `compose` file in the following code block is deploying the `docker-stress`
    image we have been using in this chapter. If we look at *line 8*, we can see the
    `deploy` statement, followed by the `resources` statement. This is where we can
    set our limits for our container. Just as we have in the previous section, we
    have set `cpus` to `2` on *line 11* and `memory` to `256MB` on *line 12*:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Even though we have only just touched on this subject, the previous sections
    covering resource usage should guide you on how you should be allocating resources
    in your `docker-compose.yml` files. This brings us to the end of this section
    on resource usage of our Docker containers. From here, we will move on to look
    at the best practices for creating our `Dockerfiles` and how we can start to use
    different applications to ensure that we are adhering to these best practices.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: Best Practices in Docker
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As our containers and services grow in size and complexity, it is important
    to make sure we are keeping true to the best practices when creating our Docker
    images. This is also true for the applications we run on our Docker images. Later
    in this chapter, we will look to lint our `Dockerfiles` and `docker-compose.yml`
    files, which will analyze our files for errors and best practices, and this will
    give you a clearer understanding. In the meantime, let's look into some of the
    more important best practices to keep in mind when you are creating your Docker
    images and how your applications should be working with them.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: This chapter may cover some points from previous chapters, but we will be able
    to give you more information and clarity on why we are using these practices.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, we will run through some of the more common best practices
    you should be following when creating your services and containers.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: Running One Service per Container
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In modern microservice architecture, we need to remember that only one service
    should be installed in each container. The container's main process is set by
    the `ENTRYPOINT` or `CMD` instruction at the end of the `Dockerfile`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: The service you have installed in your container could quite easily run multiple
    processes of itself, but to get the full benefit of Docker and microservices,
    you should only be running one service per container. To break this down further,
    your container should only have a single responsibility, and if it is responsible
    for doing more than one thing, then it should be broken out into different services.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: By limiting what each container can do, we effectively reduce the resources
    being used by the image and potentially reduce the size of the image. As we saw
    in the previous chapter, this will also reduce the chances of an attacker being
    able to perform anything they shouldn't if they gain access to a running container.
    It also means that if the container stops working for some reason, there is a
    limited effect on the rest of the applications running on the environment and
    the service will have an easier time recovering.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Base Images
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we start with a base image for our container, one of the first things we
    need to do is to make sure we are starting with an up-to-date image. Do a little
    research as well to make sure you are not using an image that has a lot of extra
    applications installed that are not needed. You may find that a base image supported
    by a specific language that your application uses or a specific focus will limit
    the size of the image needed, limiting what you need to install when you are creating
    your image.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: This is why we are using a PostgreSQL-supported Docker image instead of installing
    the application on the image during build time. The PostgreSQL-supported image
    ensures that it is secure and running at the latest version and makes sure we
    are not running applications on the image that are not needed.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: When specifying our base image for our `Dockerfile`, we need to make sure we
    are also specifying a specific version and not letting Docker simply use the `latest`
    image. Also, make sure you are not pulling an image from a repository or registry
    that is not from a reputable or trusted provider.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: 'If you''ve been working with Docker for a little while, you may have come across
    the `MAINTAINER` instruction where you specify the author of the generated image.
    This has now been deprecated, but you can still provide these details using a
    `LABEL` directive instead, as we have in the following syntax:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Installing Applications and Languages
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you are installing applications on your images, always remember that there
    is no need to be performing `apt-get update` or `dist-upgrade`. You should be
    looking at a different image if you need to be upgrading the image version this
    way. If you are installing applications using `apt-get` or `apk`, make sure you
    are specifying the specific version you need as you don't want to install a version
    that is new or untested.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: When you are installing packages, make sure you are using the `-y` switch to
    make sure the build does not stop and ask for a user prompt. Alternatively, you
    should also use `--no-install-recommends` as you don't want to install a large
    group of applications that your package manager has recommended and that you won't
    need. Also, if you using a Debian-based container, make sure that you are using
    `apt-get` or `apt-cache`, as the `apt` command has been specifically made for
    user interaction and not for a scripted installation.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: If you are installing applications from other forms, such as building the application
    from code, make sure you are cleaning up the installation files to once again
    reduce the size of the image you are creating. Again, if you are using `apt-get`,
    you should also remove the lists in `/var/lib/apt/lists/` to clean up installation
    files and reduce the size of your container image.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: Running Commands and Performing Tasks
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As our image is being created, we usually need to perform some tasks within
    our `Dockerfile` to set up the environment ready for our services to be run. Always
    make sure you are not using the `sudo` command as this could cause some unexpected
    results. If you need to be running commands as root, your base image will most
    likely be running as the root user; just make sure you create a separate user
    to run your application and services and that the container has changed to the
    required user before it has completed building.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Make sure you are moving to different directories using `WORKDIR`, instead of
    running instructions that specify a long path, as this could be hard for users
    to read. Use `JSON` notation for the `CMD` and `ENTRYPOINT` arguments and always
    make sure you only have one `CMD` or `ENTRYPOINT` instruction.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: Containers Need to Be Immutable and Stateless
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We need to ensure that our containers and the services running on them are immutable.
    We must not treat containers like traditional servers, especially a server where
    you would update applications on a running container. You should be able to update
    your container from code and deploy it without needing to access it at all.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: When we say immutable, we mean the container will not be modified at all during
    its life, with no updates, patches, or config changes being made. Any changes
    to your code or updates should be implemented by building the new image and then
    deploying it into your environment. This makes deployments safer as if you have
    any issues with your upgrade, you simply redeploy the old version of the image.
    It also means you have the same image running across all of your environments,
    making sure your environments are as identical as possible.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: When we talk about a container needing to be stateless, this means that any
    data needed to run the container should be running outside of the container. File
    stores should also be outside the container, possibly on cloud storage or using
    a mounted volume. Removing data from the container means the container can be
    cleanly shut down and destroyed at any time, without fearing data loss. When a
    new container is created to replace the old one, it simply connects to the original
    data store.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: Designing Applications to Be Highly Available and Scalable
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using containers in a microservices architecture is designed to allow your application
    to scale to multiple instances. So, when developing your applications on your
    Docker container, you should expect that there could be situations where many
    instances of your application could be deployed concurrently, scaling both up
    and down when needed. There should also be no issue with your services running
    and completing when there is a heavier-than-normal load on the container.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: When your services need to scale due to increased requests, how much time your
    applications need to start becomes an important issue. Before deploying your services
    into a production environment, you need to make sure the startup time is quick
    to make sure the system will be able to scale more efficiently without causing
    any delay in service to your users. To ensure that your services adhere to the
    industry's best practices, your services should be starting in less than 10 seconds,
    but less than 20 seconds is also acceptable.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: As we saw in the previous section, improving the application startup time is
    not simply a matter of providing more CPU and memory resources. We need to make
    sure that the applications on our containers run efficiently and, once again,
    if they are taking too long to start and run specific processes, you may be performing
    too many tasks in one application.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: Images and Containers Need to Be Tagged Appropriately
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We covered this topic in detail in *Chapter 3*, *Managing Your Docker Images*,
    and made it clear that we need to think about how we name and tag our images,
    especially when we start working with larger development teams. To allow all users
    the ability to understand what the image does and gain an understanding of what
    version is deployed into an environment, a relevant tagging and naming strategy
    needs to be decided and agreed upon before the bulk of the work is started by
    your team.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Image and container names need to be relevant to the applications they are running,
    as ambiguous names can cause confusion. An agreed standard for versioning must
    also be put in place to make sure any user can identify what version is running
    in a certain environment and what version is the most recent and stable release.
    As we mentioned in *Chapter 3*, *Managing Your Docker Images*, try not to use
    `latest`, and instead opt for either a semantic versioning system or Git repository
    `commit` hash, where users can then refer to either documentation or a build environment
    to ensure that they have the most up-to-date version of their image.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: Configurations and Secrets
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Environment variables and secrets should never be built into your Docker image.
    By doing this, you are going against the rule of reusable images. Building images
    with your secret credentials is also a security risk because they will be stored
    in one of the image layers, and so anyone able to pull the image will be able
    to see the credentials.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: When setting up the configuration for your application, it may need to change
    from environment to environment, so it is important to remember that you will
    need to be able to dynamically change these configurations when needed. This could
    include specific configurations for the language your application is written in
    or even the database that the application needs to connect to. We mentioned earlier
    that if you are configuring your application as part of your `Dockerfile`, this
    will then make it difficult to change and you may need to create a specific `Dockerfile`
    for each environment you wish to deploy your image to.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: 'One way to configure your images, as we have seen with the `docker-stress`
    image, is to use an environment variable that is set on the command line when
    we run the image. The entry point or command should contain default values if
    variables have not been provided. This will mean the container will still start
    up and run even if the extra variables have not been provided:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: By doing this, we have made our configuration more dynamic, but this could limit
    your configuration when you have a larger or more complex configuration. The environment
    variables can easily be transferred from your `docker run` command to `docker-compose`
    to then be used in Swarm or Kubernetes.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: For larger configurations, you may want to mount a configuration file via a
    Docker volume. This can mean you will be able to set up a configuration file and
    run it on your system to test easily, and then if you need to move to an orchestration
    system such as Kubernetes or Swarm, or an external configuration management solution,
    you will be able to easily convert this into a configuration map.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: 'If we wanted to implement this with the `docker-stress` image we have been
    using in this chapter, it could be modified to use a configuration file to mount
    the values we would like to run. In the following example, we have modified the
    `Dockerfile` to set up *line 3* to run a script that will instead run the `stress`
    command for us:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'This means we can build the Docker image and have it ready and available for
    us to use whenever we need it. We would just need a script that we would mount
    in the `/tmp` directory to be run. We could use the following example:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'This illustrates the idea of moving our values from environment variables to
    a file. To run both the container and the stress application, we would then perform
    the following, knowing that if we wanted to change the variables being used by
    the `stress` command, we would only need to make a minor change to the file we
    are mounting:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Note
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: The first thing you are going to think when you read through this list of best
    practices is that we have gone against a lot of this, but please remember that
    we have done this in a lot of instances to demonstrate a process or idea.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: Making Your Images Minimal and Small
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Chapter 3*, *Managing Your Docker Images*, also saw us do some work on making
    our images as small as we possibly could. We saw that by reducing the size of
    our images, the images can be built faster. They can also then be pulled faster
    and run on our systems. Any unnecessary software or applications installed on
    our containers can take up extra space and resources on our host system and could
    slow our services down as a result.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: Using an application such as Anchore Engine as we did in *Chapter 11*, *Docker
    Security*, showed that we can audit our images to view their contents, as well
    as the applications installed on them. This is an easy way to make sure we are
    reducing the sizes of our images and making them as minimal as possible.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: You now have an idea of the best practices you should be using in your container
    images and services. The following section of this chapter will help you enforce
    some of these best practices by using applications to verify that your `Dockerfiles`
    and `docker-compose.yml` are created as they should be.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: Enforcing Docker Best Practices in Your Code
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just as we look to make our coding easier when we are developing applications,
    we can use external service and tests to make sure our Docker images are adhering
    to the best practices. In the following sections of this chapter, we are going
    to use three tools to make sure that our `Dockerfiles` and `docker-compose.yml`
    files are adhering to the best practices, as well as making sure we are not introducing
    potential issues when our Docker images are built.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: The tools included will be straightforward to use and provide powerful functionality.
    We will start by using `hadolint` to lint our `Dockerfiles` directly on our system,
    which will run as a separate Docker image that we feed our `Dockerfiles` into.
    We then take a look at `FROM:latest`, which is an online service that provides
    some basic functionality in helping us pinpoint issues with our `Dockerfiles`.
    Lastly, we then look at **Docker Compose Validator** (**DCValidator**), which
    will perform a similar function, but in this case, we will lint our `docker-compose.yml`
    files to help pinpoint potential issues.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: By using these tools before we build and deploy our images, we hope to reduce
    our build times for our Docker images, reduce the number of errors we introduce,
    potentially reduce the size of our Docker images, and help us learn more about
    and enforce Docker best practices.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: Using Docker Linter for Your Images
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The GitHub repository containing all the code for this book also includes tests
    that will compare against the built Docker image. A linter, on the other hand,
    will analyze your code and look for potential errors before the image is built.
    In this section of the chapter, we are looking for potential issues with our `Dockerfiles`,
    specifically using an application called `hadolint`.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: The name `hadolint` is short for **Haskell Dockerfile Linter** and comes with
    its own Docker image that allows you to pull the image and then send your `Dockerfile`
    to the running image for it to be tested. Even if your `Dockerfile` is relatively
    small and builds and runs without any issues, `hadolint` will usually offer a
    lot of suggestions and point out flaws in your `Dockerfile`, as well as potential
    issues that might break in the future.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: 'To run `hadolint` over your `Dockerfiles`, you need to have the `hadolint`
    Docker image on your system. As you know by now, this is simply a matter of running
    the `docker pull` command with the name and repository of the required image.
    In this instance, both the repository and image are called `hadolint`:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'To then use the application, you simply run the `hadolint` image and point
    your `Dockerfile` to it using the less than (`<`) symbol, as we''ve done in the
    following example:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'If you are lucky enough to not have any issues with your `Dockerfile`, you
    should not see any output from the preceding command. If there is ever a situation
    where you need to ignore a specific warning, you can do so by using the `--ignore`
    option, followed by the specific rule ID that has been triggering the warning:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'If you need to have a few warnings ignored, it may get a little complicated
    trying to implement this in the command line, so `hadolint` also has the option
    to set up a configuration file. The `hadolint` configuration file is limited to
    ignoring warnings and providing a list of trusted repositories. You can also set
    up a configuration file with a list of your ignored warnings listed in the YAML
    format. `hadolint` will then need to have this file mounted on the running image
    for it to be used by the application as it will look for a `.hadolint.yml` configuration
    file location in the application''s home directory:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '`hadolint` is one of the better applications for linting your `Dockerfiles`
    and can easily be automated as part of a build and deployment pipelines. As an
    alternative, we are also going to look at an online application called `FROM:latest`.
    This application is a web-based service that does not provide the same functionality
    as `hadolint` but does allow you to easily copy and paste your `Dockerfile` code
    into the online editor and receive feedback on whether the `Dockerfile` adheres
    to the best practices.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 12.04: Linting Your Dockerfiles'
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This exercise will help you understand how to access and run `hadolint` on
    your system to help you enforce best practices on your `Dockerfiles`. We will
    also use an online `Dockerfile` linter called `FROM:latest` to compare the warnings
    we receive:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: 'Pull the image from the `hadolint` repository with the following `docker pull` command:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'You have a `Dockerfile` ready to go with the `docker-stress` image you used
    to test and manage your resources earlier in this chapter. Run the `hadolint`
    image to lint this `Dockerfile`, or any other `Dockerfile`, and send it to the
    `Dockerfile` using the less than (`<`) symbol, as in the following command:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'As you can see from the following output, even though our `docker-stress` image
    was relatively small, `hadolint` has given quite a few different ways where we
    can improve the performance and help our image adhere to the best practices:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Note
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: If your `Dockerfile` runs successfully through `hadolint` and there are no issues
    found, there will be no output presented to the user on the command line.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '`hadolint` also gives you the option to suppress different checks with the
    `--ignore` option. In the following command, we have chosen to ignore the `DL3008`
    warning, where it is suggesting that you pin the applications you are installing
    to a specific version number. Execute the `docker run` command to suppress the
    `DL3008` warning. Note that you need to provide the full `hadolint` command after
    specifying the image name you are running, as well as an extra dash (`-`) before
    you provide the `Dockerfile`:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'You should get output like the following:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '`hadolint` also allows you to create a configuration file to add any warnings
    to be ignored, as well as specifying them on the command line. Create a file named
    `.hadolint.yml` using the `touch` command:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Open the configuration file with your text editor and enter in and any of the
    warnings you wish to ignore that you have received under the `ignored` field.
    As you can see, you can also add in a `trustedRegistries` field, where you can
    list all the registries you will be pulling images from. Note that `hadolint`
    will provide an extra warning if your image is not from one of the registries
    listed in the configuration file:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '`hadolint` will look for your configuration file in the user''s home directory.
    As you are running `hadolint` as a Docker image, mount the file from the current
    location onto the home directory on the running image when we execute the `docker
    run` command with the `-v` option:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The command will give an output as follows:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Note
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: The source code repository for `hadolint` provides a list of all the warnings
    as well as details on how to resolve them in your `Dockerfile`. If you have not
    done so already, feel free to look through the Hadolint wiki page at [https://github.com/hadolint/hadolint/wiki](https://github.com/hadolint/hadolint/wiki).
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, `hadolint` also allows you the option to output the results of your
    check in JSON format. Once again, we need to add some extra values to the command
    line. In the command line, add the extra command-line options of `hadolint -f
    json` just before you have added and parsed your `Dockerfile` across to `hadolint`.
    In the following command, you will also need to have the `jq` package installed:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'You should get output like the following:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Note
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '`hadolint` can easily be integrated into your build pipelines to have your
    `Dockerfiles` linted before they are built. If you are interested in installing
    the `hadolint` application directly onto your system instead of using the Docker
    image, you can do so by cloning the following GitHub repository [https://github.com/hadolint/hadolint](https://github.com/hadolint/hadolint).'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '`hadolint` is not the only application that you can use to ensure your `Dockerfiles`
    are adhering to best practices. The next steps in this exercise will look at an
    online service named `FROM:latest` to also help enforce best practices on your
    `Dockerfiles`.'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: 'To use `FROM:latest`, open your favorite web browser and enter the following URL:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'When the web page loads, you should see a page similar to the one in the following
    screenshot. On the left-hand side of the web page, you should see a sample `Dockerfile`
    entered, and on the right-hand side of the web page, you should see a list of
    potential issues or ways to optimize your `Dockerfile`. Each of the items listed
    on the right-hand side has a dropdown to provide more details to the user:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.1: A screenshot of the FROM:latest website with a sample Dockerfile
    entered'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15021_12_01.jpg)'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.1: A screenshot of the FROM:latest website with a sample Dockerfile
    entered'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: 'As in the previous part of this exercise, we will use the `Dockerfile` from
    our `docker-stress` image. To use this with `FROM:latest`, copy the following
    lines of code into the left-hand side of the web page over the sample `Dockerfile`
    provided by the site:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'As soon as you post the `Dockerfile` code into the web page, the page will
    start to analyze the commands. As you can see from the following screenshot, it
    will provide details on how to resolve potential issues and optimize the `Dockerfile`
    to have the image build quicker:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.2: The Dockerfile entered for our docker-stress image'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15021_12_02.jpg)'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.2: The Dockerfile entered for our docker-stress image'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: Both `hadolint` and `FROM latest` provide easy-to-use options to help you make
    sure your `Dockerfiles` are adhering to best practices. The next exercise will
    look at a similar way to check your `docker-compose.yml` files to make sure that
    they will also run without issues and are not introducing any bad practices.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 12.05: Validating Your docker-compose.yml File'
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Docker already has a tool to validate your `docker-compose.yml` files, but the
    built-in validator does not pick up all issues in your `docker-compose` files,
    including typos, the same ports being assigned to different services, or duplicate
    keys. We can use `dcvalidator` to look for issues such as typos, duplicate keys,
    and ports assigned to numbers services.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: 'To perform the following exercise, you will need to have both Git and a recent
    version of Python 3 installed on your system. You won''t be walked through how
    to perform the installation, but these items are required before starting:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started with the `dcvalidator`, clone the GitHub repository for the
    project. If you have not done so already, you will need to run the following command
    to clone the repository:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The command-line application only needs Python 3 to run, but you will need
    to make sure all the dependencies are installed first, so change to the `dcvalidator`
    directory of the repository you have just cloned:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Installing the dependencies for the `dcvalidator` is easy, and your system
    will most likely have most of them installed on it already. To install the dependencies,
    run the `pip3 install` command from the `dcvalidator` directory using the `-r`
    option to use the `requirments.txt` file in the server directory:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Create a `docker-compose` file from scratch that will use some of the images
    you have already created in this chapter. Create a `docker-compose.yml` file by
    using the `touch` command:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Open your favorite text editor to edit the `docker-compose` file. Make sure
    you also include the mistakes we have purposely added to the file to make sure
    the `dcvalidator` picks up these errors, and we will use the `docker-stress` image
    we created earlier in this chapter. Make sure you copy this file word for word
    as we are trying to make sure we force some errors in our `docker-compose.yml`
    file:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Run the `validator-cli.py` script with the `-f` option to parse the specific
    file we want to validate – in the following command line, the `docker-compose.yml`
    file. The `-fi` option then allows you to specify the filters available to validate
    over our `compose` file. In the following code, we are using all the filters available
    at this point for `validator-cli`:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'You should get output like the following:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: As expected, there are quite a few errors that `validator-cli.py` has been able
    to find. It has shown that you have duplicate ports assigned in your app service,
    and the DNS you have set up is also incorrect. `App2` is showing some spelling
    mistakes and suggesting we could use a different value instead.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you need to specify the filters you would like your `docker-compose.yml`
    file to be validated against, but this will change with the coming releases.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: 'You''ll remember that we used a `docker-compose` file to install the Anchore
    image scanner. When you have the URL location of the `compose` file, use the `-u`
    option to pass the URL for the file to be validated. In this instance, it is on
    the Packt GitHub account:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'As you can see in the following code block, `dcvalidator` does not pick up
    any errors in the `docker-compose.yml` file:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: As you can see, the Docker Compose validator is fairly basic, but it can pick
    up a few errors in our `docker-compose.yml` file that we may have missed. This
    could especially be the case if we have a larger file; there is a possibility
    that we could have missed a few minor errors before trying to deploy our environment.
    This has brought us to the end of this part of the chapter where we have been
    using some automated processes and applications to validate and lint our `Dockerfiles`
    and `docker-compose.yml` file.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's move on to the activities, which will help you test your understanding
    of the chapter. In the following activity, you will view the resources used by
    one of the services running on the Panoramic Trekking App.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 12.01: Viewing the Resources Used by the Panoramic Trekking App'
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Earlier in this chapter, we looked at how our running container consumed resources
    on our host system. In this activity, you will choose one of the services running
    on the Panoramic Trekking App, run the container with its default configurations,
    and see what CPU and memory resources it uses. Then, run the container again with
    changes to the CPU and memory configurations to see how this affects the resource
    usage:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: 'The general set of steps you''ll need to complete this activity runs as follows:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: Decide on a service in the Panoramic Trekking App that you would like to test.
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a set of tests that you can use to then measure the resource usage of
    the service.
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start your service and monitor the resource usage using the tests you created
    in the previous step.
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Stop your service from running and run it again, this time with changes to the
    CPU and memory configurations.
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Monitor the resource usage again using the tests you created in *step 2* and
    compare the changes in resource usage.
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: The solution for this activity can be found via [this link](B15021_Solution_Final_SMP.xhtml#_idTextAnchor350).
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: The next activity will help you use `hadolint` on your `Dockerfiles` to improve
    the best practices.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 12.02: Using hadolint to Improve the Best Practices on Dockerfiles'
  id: totrans-321
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`hadolint` provides a great way to enforce best practices when you are creating
    your Docker images. In this activity, you will once again use the `Dockerfile`
    from the `docker-stress` image to see whether you can use the recommendations
    from `hadolint` to improve the `Dockerfile` so that it adheres to best practices
    as much as possible.'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: 'The steps you''ll need to complete this activity are as follows:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: Ensure you have the `hadolint` image available and running on your system.
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the `hadolint` image over the `Dockerfile` for the `docker-stress` image
    and record the results.
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make the recommended changes to the `Dockerfile` from the previous step.
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Test the `Dockerfile` again.
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You should get the following output on the successful completion of the activity:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.3: Expected output of Activity 12.02'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15021_12_03.jpg)'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.3: Expected output of Activity 12.02'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: The solution for this activity can be found via [this link](B15021_Solution_Final_SMP.xhtml#_idTextAnchor351).
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter has seen us go through a lot of theory as well as some in-depth
    work on exercises. We started the chapter by looking at how our running Docker
    containers utilize the host system's CPU, memory, and disk resources. We looked
    at the ways in which we can monitor how these resources are consumed by our containers
    and configure our running containers to reduce the number of resources used.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: We then looked at the Docker best practices, working through a number of different
    topics, including utilizing base images, installing programs and cleanup, developing
    your underlying application for scalability, and configuring your applications
    and images. We then introduced some tools to help you enforce these best practices,
    including `hadolint` and `FROM:latest` to help you lint your `Dockerfiles`, and
    `dcvalidator` to check over your `docker-compose.yml` files.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter takes our monitoring skills up another level as we introduce
    using Prometheus to monitor our container metrics and resources.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
