- en: Chapter 3. Classes and Instances
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will start working with examples on how to code classes
    and customize the initialization of instances in Java 9\. We will understand how
    classes work as blueprints to generate instances and dive deeply into the garbage
    collection mechanism. We will:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Understand classes and instances in Java 9
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Work with object initialization and its customization
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn about an object's lifecycle
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduce garbage collection
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Declare classes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customize constructors and initialization
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand how garbage collection works
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create instances of classes and understand their scope
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding classes and instances in Java 9
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned some of the basics of the object-oriented
    paradigm, including classes and objects. We started working on the backend for
    a Web Service related to 2D shapes. We ended up creating a UML diagram with the
    structure of many classes, including their hierarchy, fields, and methods. It
    is time to take advantage of JShell to start coding a basic class and work with
    its instances in JShell.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: In Java 9, a class is always the type and blueprint. The object is the working
    instance of the class, and therefore, objects are also known as **instances**.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Classes are first-class citizens in Java 9 and they will be the main building
    blocks of our object-oriented solutions.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: 'One or more variables can hold a reference to an instance. For example, consider
    that we have the following three variables of the `Rectangle` type:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '`rectangle1`'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rectangle2`'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rectangle10`'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rectangle2``0`'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's consider that the `rectangle1` variable holds a reference to an instance
    of the `Rectangle` class with its `width` set to `36` and its `height` set to
    `20`. The `rectangle10` variable holds a reference to the same instance referenced
    by `rectangle1`. Thus, we have two variables that hold a reference to the same
    `Rectangle` object.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: The `rectangle2` variable holds a reference to an instance of the `Rectangle`
    class with its `width` set to `22` and its `height` set to `41`. The `rectangle20`
    variable holds a reference to the same instance referenced by `rectangle2`. We
    have another two variables that hold a reference to the same `Rectangle` object.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: The following picture illustrates the situation where many variables of the
    `Rectangle` type that hold a reference to a single instance. The variable names
    are at the left-hand side and the rectangles with their width and height values
    represent a specific instance of the `Rectangle` class.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding classes and instances in Java 9](img/00033.jpeg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
- en: We will work with many variables that hold a reference to a single instance
    in JShell later in this chapter.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Working with object initialization and its customization
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you ask Java to create an instance of a specific class, something happens
    under the hood. Java creates a new instance of the specified type, the **JVM**
    (**Java Virtual Machine**) allocates the necessary memory, and then executes the
    code specified in the constructor.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: When Java executes the code within the constructor, there is already a live
    instance of the class. Thus, the code in the constructor has access to the fields
    and methods defined in the class. Obviously, we must be careful in the code we
    put within the constructor because we might end up generating huge delays when
    we create instances of the class.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Constructors are extremely useful to execute setup code and properly initialize
    a new instance.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Let's forget about the hierarchy structure in which we were working for the
    classes that represent 2D shapes. Imagine that we have to code the `Circle` class
    as a standalone class that doesn't inherit from any other class. Before we can
    call either the `calculateArea` or `calculatePerimeter` methods, we want the `radius`
    field for each new `Circle` instance to have a value initialized to the appropriate
    value that represents the circle. We don't want new `Circle` instances to be created
    without specifying an appropriate value for the `radius` field.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Constructors are extremely useful when we want to define the values for the
    fields of the instances of a class right after their creation and before we can
    access the variables that reference the created instances. In fact, the only way
    to create instances of a specific class is to use the constructors we provide.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Whenever we need specific arguments to be available at the time we create an
    instance, we can declare many different constructors with the necessary arguments
    and use them to create instances of a class. Constructors allow us to make sure
    that there is no way of creating specific classes without using the provided constructors
    that make the necessary arguments required. Thus, if the provided constructor
    requires a `radius` argument, we won't be able to create an instance of the class
    without specifying a value for the `radius` argument.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: Imagine that we have to code the `Rectangle` class as a standalone class that
    doesn't inherit from any other class. Before we can call either the `calculateArea`
    or `calculatePerimeter` methods, we want both the `width` and `height` fields
    for each new `Rectangle` instance to have their values initialized to the appropriate
    values that represent each rectangle. We don't want new `Rectangle` instances
    to be created without specifying an appropriate value for the `width` and `height`
    fields. Thus, we will declare a constructor for this class that requires values
    for `width` and `height`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: Introducing garbage collection
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At some specific time, your application won't require to work with an instance
    anymore. For example, once you have calculated the perimeter of a circle and you
    have returned the necessary data in the Web Service response, you don't need to
    continue working with the specific `Circle` instance anymore. Some programming
    languages require you to be careful about leaving live instances alive and you
    have to explicitly destroy them and deallocate the memory that it was consuming.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Java provides automatic memory management. The JVM runtime uses a garbage collection
    mechanism that automatically deallocates memory used by instances that aren't
    referenced anymore. The garbage collection process is extremely complicated, there
    are many different algorithms with their advantages and disadvantages, and the
    JVM has specific considerations that should be taken into account to avoid unnecessary
    huge memory pressure. However, we will keep our focus on the object's life cycle.
    In Java 9, when the JVM runtime detects you aren't referencing an instance anymore
    or the last variable that holds a reference to a specific instance has run out
    of scope, it makes the instance ready to be part of the next garbage collection
    cycle.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: For example, let's consider our previous example where we had four variables
    that hold references to two instances of the `Rectangle` class. Consider that
    both the `rectangle1` and the `rectangle2` variables run out of scope. The instance
    that was referenced by `rectangle1` is still being referenced by `rectangle10`,
    and the instance that was referenced by `rectangle2` is still being referenced
    by `rectangle20`. Thus, none of the instances can be removed from memory, as they
    are still being referenced. The following picture illustrates the situation. The
    variables that are out of scope have a NO sign at the right-hand side.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '![Introducing garbage collection](img/00034.jpeg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
- en: After `rectangle10` runs out of scope, the instance that it referenced becomes
    disposable, and therefore, it can be safely added to the list of objects that
    can be removed from memory. The following picture illustrates the situation. The
    instance that is ready to be removed from memory has a recycle symbol.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '![Introducing garbage collection](img/00035.jpeg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
- en: After `rectangle20` runs out of scope, the instance that it referenced becomes
    disposable, and therefore, it can be safely added to the list of objects that
    can be removed from memory. The following picture illustrates the situation. The
    two instances are ready to be removed from memory and both of them have a recycle
    symbol.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '![Introducing garbage collection](img/00036.jpeg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
- en: Note
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The JVM automatically runs the garbage collection process in the background
    and automatically claims back the memory consumed by the instances that were ready
    for garbage collection and aren't referenced anymore. We don't know when the garbage
    collection process will occur for specific instances and we shouldn't interfere
    in the process. The garbage collection algorithm has been improved in Java 9.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: Imagine that we have to distribute the items that we store in a box. After we
    distribute all the items, we must throw the box in a recycle bin. We cannot throw
    the box to the recycle bin when we still have one or more items in it. We definitely
    don't want to lose the items we have to distribute because they are very expensive.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: 'The problem has a very easy solution: we just need to count the number of items
    that remain in the box. When the number of items in the box reaches zero, we can
    get rid of the box, that is, we can throw it to the recycle bin. Then, the garbage
    collection process will remove all the items that have been thrown to the recycle
    bin.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Luckily, we don't have to worry about throwing instances to a recycle bin. Java
    does it automatically for us. It is completely transparent for us.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: One or more variables can hold a reference to a single instance of a class.
    Thus, it is necessary to take into account the number of references to an instance
    before Java can put an instance into the garbage collection ready list. When the
    number of references to a specific instance reaches zero, it is considered safe
    to remove the instance from memory and claim back the memory consumed by the instance
    because nobody needs this specific instance anymore. At this time, the instance
    is ready to be removed by the garbage collection process.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: For example, we can create an instance of a class and assign it to a variable.
    Java will know that there is one reference to this instance. Then, we can assign
    the same instance to another variable. Java will know there are two references
    to this single instance.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: After the first variable runs out of scope, the second variable that holds a
    reference to the instance will still be accessible. Java will know there is still
    another variable that holds a reference to this instance, and therefore, the instance
    won't be ready for garbage collection. At this point, the instance must still
    be available, that is, we need it alive.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: After the second variable runs out of scope, there are no more variables that
    hold a reference to the instance. At this point, Java will mark the instance as
    ready for garbage collection because there are no more variables holding a reference
    to the instance and it can be safely removed from memory.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: Declaring classes
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following lines declare a new minimal `Rectangle` class in Java. The code
    file for the sample is included in the `java_9_oop_chapter_03_01` folder, in the
    `example03_01.java` file.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `class` keyword, followed by the class name (`Rectangle`), composes the
    header of the class definition. In this case, we don't specify a parent class
    or superclass for the `Rectangle` class. A pair of curly braces (`{}`) encloses
    the class body after the class header. In the forthcoming chapters, we will declare
    classes that inherit from another class, and therefore, they will have a superclass.
    In this case, the class body is empty. The `Rectangle` class is the simplest possible
    class we can declare in Java 9.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Any new class you create that doesn't specify a superclass will be a subclass
    of the `java.lang.Object` class. Thus, the `Rectangle` class is a subclass of
    `java.lang.Object`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: The following lines represent an equivalent way of creating the `Rectangle`
    class. However, we don't need to specify that the class inherits from `java.lang.Object`
    because it adds unnecessary boilerplate code. The code file for the sample is
    included in the `java_9_oop_chapter_03_01` folder, in the `example03_02.java`
    file.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Customizing constructors and initialization
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We want to initialize instances of the `Rectangle` class with the width and
    height values for the new rectangle. In order to do so, we can take advantage
    of the previously introduced constructors. Constructors are special class methods
    that are automatically executed when we create an instance of a given type. Java
    runs the code within the constructor before any other code within a class.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: We can define a constructor that receives both the width and height values as
    arguments, and use it to initialize the fields with the same names. We can define
    as many constructors as we want to, and therefore, we can provide many different
    ways of initializing a class. In this case, we just need one constructor.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: The following lines create a `Rectangle` class and define a constructor within
    the class body. At this time, we aren't using access modifiers at all because
    we want to keep the class declaration as simple as possible. We will work with
    them later. The code file for the sample is included in the `java_9_oop_chapter_03_01`
    folder, in the `example03_03.java` file.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The constructor is a class method that uses the same name as the class: `Rectangle`.
    In our sample `Rectangle` class, the constructor receives two arguments of the
    `double` type: `width` and `height`. The code within the constructor prints a
    message indicating that the code is initializing a new `Rectangle` instance and
    prints the values for the `width` and `height`. This way, we will understand when
    the code within the constructor is executed. Because the constructor has an argument,
    it is known as a **parameterized constructor**.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Then, the following line assigns the `width` double value received as an argument
    to the `width` double field. We use `this.width` to access the `width` field for
    the instance and `width` to reference the argument. The `this` keyword provides
    access to the instance that has been created and we want to initialize, that is,
    the object that is being built. We use `this.height` to access the `height` field
    for the instance and `height` to reference the argument.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: The two lines before the constructor declare the `width` and `height` double
    field. These two fields are member variables that we can access without restrictions
    after the constructor finishes its execution.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: The following lines create four instances of the `Rectangle` class named `rectangle1`,
    `rectangle2`, `rectangle3`, and `rectangle4`. The code file for the sample is
    included in the `java_9_oop_chapter_03_01` folder, in the `example03_04.java`
    file.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Each line that creates an instance specifies the type for the new variable (`Rectangle`)
    followed by the variable name that will hold the reference to the new instance
    (`rectangle1`, `rectangle2`, `rectangle3`, or `rectangle4`). Then each line assigns
    the result of using the `new` keyword followed by the desired value for the `width`
    and `height` arguments separated by a comma and enclosed in parentheses.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Java 9, we have to specify the type for the variable in which we want to
    hold the reference to an instance. In this case, we declare each variable with
    the `Rectangle` type. In case you have experience with other programming languages
    that provide a keyword to generate implicitly typed local variables such as the
    `var` keyword in C#, you must know there is no equivalent in Java 9.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: 'After we enter all the lines that declare the class and create the four instances
    in JShell, we will see four messages that say `"Initializing a new Rectangle instance"`
    followed by the width and height values specified in the call to the constructor
    of each instance. The following screenshot shows the results of executing the
    code in JShell:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '![Customizing constructors and initialization](img/00037.jpeg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
- en: After we execute the previous lines, we can check the values for the `width`
    and `height` fields for each of the instances we have created. The following lines
    show expressions that JShell can evaluate to display the values for each field.
    The code file for the sample is included in the `java_9_oop_chapter_03_01` folder,
    in the `example03_05.java` file.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The following screenshot shows the results of evaluating the previous expressions
    in JShell.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '![Customizing constructors and initialization](img/00038.jpeg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
- en: Enter the following expression in JShell. The code file for the sample is included
    in the `java_9_oop_chapter_03_01` folder, in the `example03_06.java` file.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: JShell will display `true` as a result of the evaluation of the previous expression
    because `rectangle1` is an instance of the `Rectangle` class. The `instanceof`
    keyword allows us to test whether an object is of the specified type. With this
    keyword, we can determine whether an object is a `Rectangle` object.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: As previously explained, `Rectangle` is a subclass of the `java.lang.Object`
    class. JShell already imported all the types from `java.lang`, and therefore,
    we can just reference this class as `Object`. Enter the following expression in
    JShell. The code file for the sample is included in the `java_9_oop_chapter_03_01`
    folder, in the `example03_07.java` file.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: JShell will display `true` as a result of the evaluation of the previous expression
    because `rectangle1` is also an instance of the `java.lang.Object` class.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: Enter the following expression in JShell. The code file for the sample is included
    in the `java_9_oop_chapter_03_01` folder, in the `example03_08.java` file.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: JShell will display `"Rectangle"` as a result for the previous line because
    the `rectangle1` variable holds an instance of the `Rectangle` class. The `getClass`
    method allows us to retrieve the runtime class of an object. The method is inherited
    from the `java.lang.Object` class. The `getName` method converts the runtime type
    to a string.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will try to create an instance of `Rectangle` without providing arguments.
    The following line won't allow Java to compile the code and will display a build
    error in JShell because the compiler cannot find a parameterless constructor declared
    in the `Rectangle` class. The only constructor declared for this class requires
    two `double` arguments, and therefore, Java doesn't allow `Rectangle` instances
    to be created without specifying the values for `width` and `height`. The code
    file for the sample is included in the `java_9_oop_chapter_03_01` folder, in the
    `example03_09.java` file.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The next screenshot shows the detailed error message:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '![Customizing constructors and initialization](img/00039.jpeg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
- en: Understanding how garbage collection works
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The following lines show the new complete code for the `Rectangle` class. The
    new lines are highlighted. The code file for the sample is included in the `java_9_oop_chapter_03_01`
    folder, in the `example03_10.java` file.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The new lines declare a `finalize` method that overrides the inherited method
    from `java.lang.Object` and prints a message indicating that it is finalizing
    a `Rectangle` instance and displays the width and height values for the instance.
    Don't worry about the pieces of the code that you don't understand yet because
    we will learn them in the forthcoming chapters. The goal for the new piece of
    code included in the class is to let us know when the garbage collection process
    is going to remove the object from memory.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Avoid writing code that overrides the `finalize` method. Java 9 doesn't promote
    the usage of the `finalize` method to perform cleanup operations.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: The following lines create two instances of the `Rectangle` class named `rectangleToCollect1`
    and `rectangleToCollect2`. Then, the next lines assign `null` to both variables,
    and therefore, the reference count for both objects reaches zero and they become
    ready for garbage collection. The two instances can be safely removed from memory
    because there are no more variables in scope holding a reference to them. The
    code file for the sample is included in the `java_9_oop_chapter_03_01` folder,
    in the `example03_11.java` file.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The following screenshot shows the results of executing the previous lines
    in JShell:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding how garbage collection works](img/00040.jpeg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
- en: The two rectangle instances can be safely removed from memory but we don't see
    the messages indicating that the `finalize` method has been executed for each
    of these instances. Remember that we don't know when the garbage collection process
    will determine that it is necessary to claim back the memory used by these instances.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: In order to understand how the garbage collection process works, we will force
    a garbage collection. However, it is very important to understand that we should
    never force a garbage collection in real-life applications. We must leave the
    JVM select the most appropriate time to perform a collection.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: The next line shows the code that calls the `System.gc` method to force the
    JVM to perform a garbage collection. The code file for the sample is included
    in the `java_9_oop_chapter_03_01` folder, in the `example03_12.java` file.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The following screenshot shows the results of executing the previous line in
    JShell. We will see the messages that indicate that the `finalize` method for
    the two instances has been called.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding how garbage collection works](img/00041.jpeg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
- en: The following lines create an instance of the `Rectangle` class named `rectangle5`
    and then assign a reference to this object to the `referenceToRectangle5` variable.
    This way, the reference count to the object increases to two. The next line assigns
    `null` to `rectangle5` and makes the reference count for the object to go down
    from two to one. The `referenceToRectangle5` variable stills holds a reference
    to the `Rectangle` instance, and therefore, the next line that forces a garbage
    collection won't remove the instance from memory and we won't see the results
    of the execution of the code in the `finalize` method. There is still one variable
    on scope that holds a reference to the instance. The code file for the sample
    is included in the `java_9_oop_chapter_03_01` folder, in the `example03_13.java`
    file.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The following screenshot shows the results of executing the previous lines
    in JShell:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding how garbage collection works](img/00042.jpeg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
- en: Now, we will execute a line that assigns `null` to `referenceToRectangle5` to
    force the reference count to reach zero for the referenced instance and we will
    force the garbage collection process to run in the next line. The code file for
    the sample is included in the `java_9_oop_chapter_03_01` folder, in the `example03_14.java`
    file.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The following screenshot shows the results of executing the previous lines in
    JShell. We will see the messages that indicate that the `finalize` method for
    the instance has been called.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding how garbage collection works](img/00043.jpeg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
- en: Tip
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is very important to know that you don't need to assign `null` to a reference
    to force the JVM to claim back the memory from objects. In the previous examples,
    we wanted to understand how the garbage collection worked. Java will automatically
    destroy the objects when they aren't referenced anymore in a transparent way.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: Creating instances of classes and understanding their scope
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will write a few lines of code that create an instance of the `Rectangle`
    class named `rectangle` within the scope of a `getGeneratedRectangleHeight` method.
    The code within the method uses the created instance to access and return the
    value of its `height` field. In this case, the code uses the `final` keyword as
    a prefix to the `Rectangle` type to declare an **immutable reference** to the
    `Rectangle` instance named `rectangle`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An immutable reference is also known as a constant reference because we cannot
    replace the reference held by the `rectangle` constant with another instance of
    `Rectangle`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: After we define the new method, we will call it and we will force a garbage
    collection. The code file for the sample is included in the `java_9_oop_chapter_03_01`
    folder, in the `example03_15.java` file.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The following screenshot shows the results of executing the previous lines in
    JShell. We will see the messages that indicate that the `finalize` method for
    the instance has been called after the call to the `getGeneratedRectangleHeight`
    method and the next call to force the garbage collection. When the method returns
    a value, rectangle becomes out of scope because its reference count goes down
    from one to zero.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: The instanced reference by immutable variable is safe for garbage collection.
    Thus, when we force the garbage collection, we see the message displayed by the
    `finalize` method.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating instances of classes and understanding their scope](img/00044.jpeg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
- en: Exercises
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you understand an object's life cycle, it is time to spend some time
    in JShell creating new classes and instances.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 1
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new `Student` class with a constructor that requires two `String`
    arguments: `firstName` and `lastName`. Use the arguments to initialize fields
    with the same names as the arguments. Display a message with the values for `firstName`
    and `lastName` when an instance of the class is created.'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an instance of the `Student` class and assign it to a variable. Check
    the messages printed in JShell.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an instance of the `Student` class and assign it to a variable. Check
    the messages printed in JShell.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Exercise 2
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a function that receives two `String` arguments: `firstName` and `lastName`.
    Create an instance of the previously defined `Student` class with the received
    arguments as parameters for the creation of the instance. Use the instance properties
    to print a message with the first name followed by a space and the last name.
    You will be able to create a method and add it to the `Student` class later to
    perform the same task. However, we will learn more about this in the forthcoming
    chapters.'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call the previously created function with the necessary arguments. Check the
    message printed in JShell.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Test your knowledge
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When Java executes the code within a constructor:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We cannot access any members defined in the class.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There is already a live instance of the class. We can access methods defined
    in the class but we cannot access its fields.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There is already a live instance of the class and we can access its members.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Constructors are extremely useful to:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Execute setup code and properly initialize a new instance.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Execute cleanup code before the instance is destroyed.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Declare methods that will be accessible to all the instances of the class.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Java 9 uses one of the following mechanisms to automatically deallocate the
    memory used by instances that aren''t referenced anymore:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Java 9 使用以下机制之一来自动释放不再被引用的实例使用的内存：
- en: Instance map reduce.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实例映射减少。
- en: Garbage compression.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 垃圾压缩。
- en: Garbage collection.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 垃圾收集。
- en: 'Java 9 allows us to define:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Java 9允许我们定义：
- en: A main constructor and two optional secondary constructors.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个主构造函数和两个可选的次要构造函数。
- en: Many constructors with different arguments.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 许多具有不同参数的构造函数。
- en: Only one constructor per class.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个类只有一个构造函数。
- en: 'Any new class we create that doesn''t specify a superclass will be a subclass
    of:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建的任何不指定超类的新类都将是一个子类：
- en: '`java.lang.Base`'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`java.lang.Base`'
- en: '`java.lang.Object`'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`java.lang.Object`'
- en: '`java.object.BaseClass`'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`java.object.BaseClass`'
- en: 'Which of the following lines create an instance of the `Rectangle` class and
    assign its reference to the `rectangle` variable:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪行创建了`Rectangle`类的一个实例并将其引用分配给`rectangle`变量：
- en: '`var rectangle = new Rectangle(50, 20);`'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`var rectangle = new Rectangle(50, 20);`'
- en: '`auto rectangle = new Rectangle(50, 20);`'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`auto rectangle = new Rectangle(50, 20);`'
- en: '`Rectangle rectangle = new Rectangle(50, 20);`'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Rectangle rectangle = new Rectangle(50, 20);`'
- en: 'Which of the following lines access the `width` field for the `rectangle` instance:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪行访问了`rectangle`实例的`width`字段：
- en: '`rectangle.field`'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`rectangle.field`'
- en: '`rectangle..field`'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`rectangle..field`'
- en: '`rectangle->field`'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`rectangle->field`'
- en: Summary
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned about an object's life cycle. You also learned
    how object constructors work. We declared our first simple class to generate a
    blueprint for objects. We understood how types, variables, classes, constructors,
    instances, and garbage collection work with live examples in JShell.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您了解了对象的生命周期。您还了解了对象构造函数的工作原理。我们声明了我们的第一个简单类来生成对象的蓝图。我们了解了类型、变量、类、构造函数、实例和垃圾收集是如何在JShell中的实时示例中工作的。
- en: Now that you have learned to start creating classes and instances, we are ready
    to share, protect, use, and hide data with the data encapsulation features included
    in Java 9, which is what we are going to discuss in the next chapter.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经学会了开始创建类和实例，我们准备在Java 9中包含的数据封装功能中分享、保护、使用和隐藏数据，这是我们将在下一章讨论的内容。
