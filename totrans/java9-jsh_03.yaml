- en: Chapter 3. Classes and Instances
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will start working with examples on how to code classes
    and customize the initialization of instances in Java 9\. We will understand how
    classes work as blueprints to generate instances and dive deeply into the garbage
    collection mechanism. We will:'
  prefs: []
  type: TYPE_NORMAL
- en: Understand classes and instances in Java 9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Work with object initialization and its customization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn about an object's lifecycle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduce garbage collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Declare classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customize constructors and initialization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand how garbage collection works
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create instances of classes and understand their scope
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding classes and instances in Java 9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned some of the basics of the object-oriented
    paradigm, including classes and objects. We started working on the backend for
    a Web Service related to 2D shapes. We ended up creating a UML diagram with the
    structure of many classes, including their hierarchy, fields, and methods. It
    is time to take advantage of JShell to start coding a basic class and work with
    its instances in JShell.
  prefs: []
  type: TYPE_NORMAL
- en: In Java 9, a class is always the type and blueprint. The object is the working
    instance of the class, and therefore, objects are also known as **instances**.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Classes are first-class citizens in Java 9 and they will be the main building
    blocks of our object-oriented solutions.
  prefs: []
  type: TYPE_NORMAL
- en: 'One or more variables can hold a reference to an instance. For example, consider
    that we have the following three variables of the `Rectangle` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '`rectangle1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rectangle2`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rectangle10`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rectangle2``0`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's consider that the `rectangle1` variable holds a reference to an instance
    of the `Rectangle` class with its `width` set to `36` and its `height` set to
    `20`. The `rectangle10` variable holds a reference to the same instance referenced
    by `rectangle1`. Thus, we have two variables that hold a reference to the same
    `Rectangle` object.
  prefs: []
  type: TYPE_NORMAL
- en: The `rectangle2` variable holds a reference to an instance of the `Rectangle`
    class with its `width` set to `22` and its `height` set to `41`. The `rectangle20`
    variable holds a reference to the same instance referenced by `rectangle2`. We
    have another two variables that hold a reference to the same `Rectangle` object.
  prefs: []
  type: TYPE_NORMAL
- en: The following picture illustrates the situation where many variables of the
    `Rectangle` type that hold a reference to a single instance. The variable names
    are at the left-hand side and the rectangles with their width and height values
    represent a specific instance of the `Rectangle` class.
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding classes and instances in Java 9](img/00033.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We will work with many variables that hold a reference to a single instance
    in JShell later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Working with object initialization and its customization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you ask Java to create an instance of a specific class, something happens
    under the hood. Java creates a new instance of the specified type, the **JVM**
    (**Java Virtual Machine**) allocates the necessary memory, and then executes the
    code specified in the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: When Java executes the code within the constructor, there is already a live
    instance of the class. Thus, the code in the constructor has access to the fields
    and methods defined in the class. Obviously, we must be careful in the code we
    put within the constructor because we might end up generating huge delays when
    we create instances of the class.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Constructors are extremely useful to execute setup code and properly initialize
    a new instance.
  prefs: []
  type: TYPE_NORMAL
- en: Let's forget about the hierarchy structure in which we were working for the
    classes that represent 2D shapes. Imagine that we have to code the `Circle` class
    as a standalone class that doesn't inherit from any other class. Before we can
    call either the `calculateArea` or `calculatePerimeter` methods, we want the `radius`
    field for each new `Circle` instance to have a value initialized to the appropriate
    value that represents the circle. We don't want new `Circle` instances to be created
    without specifying an appropriate value for the `radius` field.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Constructors are extremely useful when we want to define the values for the
    fields of the instances of a class right after their creation and before we can
    access the variables that reference the created instances. In fact, the only way
    to create instances of a specific class is to use the constructors we provide.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever we need specific arguments to be available at the time we create an
    instance, we can declare many different constructors with the necessary arguments
    and use them to create instances of a class. Constructors allow us to make sure
    that there is no way of creating specific classes without using the provided constructors
    that make the necessary arguments required. Thus, if the provided constructor
    requires a `radius` argument, we won't be able to create an instance of the class
    without specifying a value for the `radius` argument.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine that we have to code the `Rectangle` class as a standalone class that
    doesn't inherit from any other class. Before we can call either the `calculateArea`
    or `calculatePerimeter` methods, we want both the `width` and `height` fields
    for each new `Rectangle` instance to have their values initialized to the appropriate
    values that represent each rectangle. We don't want new `Rectangle` instances
    to be created without specifying an appropriate value for the `width` and `height`
    fields. Thus, we will declare a constructor for this class that requires values
    for `width` and `height`.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing garbage collection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At some specific time, your application won't require to work with an instance
    anymore. For example, once you have calculated the perimeter of a circle and you
    have returned the necessary data in the Web Service response, you don't need to
    continue working with the specific `Circle` instance anymore. Some programming
    languages require you to be careful about leaving live instances alive and you
    have to explicitly destroy them and deallocate the memory that it was consuming.
  prefs: []
  type: TYPE_NORMAL
- en: Java provides automatic memory management. The JVM runtime uses a garbage collection
    mechanism that automatically deallocates memory used by instances that aren't
    referenced anymore. The garbage collection process is extremely complicated, there
    are many different algorithms with their advantages and disadvantages, and the
    JVM has specific considerations that should be taken into account to avoid unnecessary
    huge memory pressure. However, we will keep our focus on the object's life cycle.
    In Java 9, when the JVM runtime detects you aren't referencing an instance anymore
    or the last variable that holds a reference to a specific instance has run out
    of scope, it makes the instance ready to be part of the next garbage collection
    cycle.
  prefs: []
  type: TYPE_NORMAL
- en: For example, let's consider our previous example where we had four variables
    that hold references to two instances of the `Rectangle` class. Consider that
    both the `rectangle1` and the `rectangle2` variables run out of scope. The instance
    that was referenced by `rectangle1` is still being referenced by `rectangle10`,
    and the instance that was referenced by `rectangle2` is still being referenced
    by `rectangle20`. Thus, none of the instances can be removed from memory, as they
    are still being referenced. The following picture illustrates the situation. The
    variables that are out of scope have a NO sign at the right-hand side.
  prefs: []
  type: TYPE_NORMAL
- en: '![Introducing garbage collection](img/00034.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: After `rectangle10` runs out of scope, the instance that it referenced becomes
    disposable, and therefore, it can be safely added to the list of objects that
    can be removed from memory. The following picture illustrates the situation. The
    instance that is ready to be removed from memory has a recycle symbol.
  prefs: []
  type: TYPE_NORMAL
- en: '![Introducing garbage collection](img/00035.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: After `rectangle20` runs out of scope, the instance that it referenced becomes
    disposable, and therefore, it can be safely added to the list of objects that
    can be removed from memory. The following picture illustrates the situation. The
    two instances are ready to be removed from memory and both of them have a recycle
    symbol.
  prefs: []
  type: TYPE_NORMAL
- en: '![Introducing garbage collection](img/00036.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The JVM automatically runs the garbage collection process in the background
    and automatically claims back the memory consumed by the instances that were ready
    for garbage collection and aren't referenced anymore. We don't know when the garbage
    collection process will occur for specific instances and we shouldn't interfere
    in the process. The garbage collection algorithm has been improved in Java 9.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine that we have to distribute the items that we store in a box. After we
    distribute all the items, we must throw the box in a recycle bin. We cannot throw
    the box to the recycle bin when we still have one or more items in it. We definitely
    don't want to lose the items we have to distribute because they are very expensive.
  prefs: []
  type: TYPE_NORMAL
- en: 'The problem has a very easy solution: we just need to count the number of items
    that remain in the box. When the number of items in the box reaches zero, we can
    get rid of the box, that is, we can throw it to the recycle bin. Then, the garbage
    collection process will remove all the items that have been thrown to the recycle
    bin.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Luckily, we don't have to worry about throwing instances to a recycle bin. Java
    does it automatically for us. It is completely transparent for us.
  prefs: []
  type: TYPE_NORMAL
- en: One or more variables can hold a reference to a single instance of a class.
    Thus, it is necessary to take into account the number of references to an instance
    before Java can put an instance into the garbage collection ready list. When the
    number of references to a specific instance reaches zero, it is considered safe
    to remove the instance from memory and claim back the memory consumed by the instance
    because nobody needs this specific instance anymore. At this time, the instance
    is ready to be removed by the garbage collection process.
  prefs: []
  type: TYPE_NORMAL
- en: For example, we can create an instance of a class and assign it to a variable.
    Java will know that there is one reference to this instance. Then, we can assign
    the same instance to another variable. Java will know there are two references
    to this single instance.
  prefs: []
  type: TYPE_NORMAL
- en: After the first variable runs out of scope, the second variable that holds a
    reference to the instance will still be accessible. Java will know there is still
    another variable that holds a reference to this instance, and therefore, the instance
    won't be ready for garbage collection. At this point, the instance must still
    be available, that is, we need it alive.
  prefs: []
  type: TYPE_NORMAL
- en: After the second variable runs out of scope, there are no more variables that
    hold a reference to the instance. At this point, Java will mark the instance as
    ready for garbage collection because there are no more variables holding a reference
    to the instance and it can be safely removed from memory.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following lines declare a new minimal `Rectangle` class in Java. The code
    file for the sample is included in the `java_9_oop_chapter_03_01` folder, in the
    `example03_01.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `class` keyword, followed by the class name (`Rectangle`), composes the
    header of the class definition. In this case, we don't specify a parent class
    or superclass for the `Rectangle` class. A pair of curly braces (`{}`) encloses
    the class body after the class header. In the forthcoming chapters, we will declare
    classes that inherit from another class, and therefore, they will have a superclass.
    In this case, the class body is empty. The `Rectangle` class is the simplest possible
    class we can declare in Java 9.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Any new class you create that doesn't specify a superclass will be a subclass
    of the `java.lang.Object` class. Thus, the `Rectangle` class is a subclass of
    `java.lang.Object`.
  prefs: []
  type: TYPE_NORMAL
- en: The following lines represent an equivalent way of creating the `Rectangle`
    class. However, we don't need to specify that the class inherits from `java.lang.Object`
    because it adds unnecessary boilerplate code. The code file for the sample is
    included in the `java_9_oop_chapter_03_01` folder, in the `example03_02.java`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Customizing constructors and initialization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We want to initialize instances of the `Rectangle` class with the width and
    height values for the new rectangle. In order to do so, we can take advantage
    of the previously introduced constructors. Constructors are special class methods
    that are automatically executed when we create an instance of a given type. Java
    runs the code within the constructor before any other code within a class.
  prefs: []
  type: TYPE_NORMAL
- en: We can define a constructor that receives both the width and height values as
    arguments, and use it to initialize the fields with the same names. We can define
    as many constructors as we want to, and therefore, we can provide many different
    ways of initializing a class. In this case, we just need one constructor.
  prefs: []
  type: TYPE_NORMAL
- en: The following lines create a `Rectangle` class and define a constructor within
    the class body. At this time, we aren't using access modifiers at all because
    we want to keep the class declaration as simple as possible. We will work with
    them later. The code file for the sample is included in the `java_9_oop_chapter_03_01`
    folder, in the `example03_03.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The constructor is a class method that uses the same name as the class: `Rectangle`.
    In our sample `Rectangle` class, the constructor receives two arguments of the
    `double` type: `width` and `height`. The code within the constructor prints a
    message indicating that the code is initializing a new `Rectangle` instance and
    prints the values for the `width` and `height`. This way, we will understand when
    the code within the constructor is executed. Because the constructor has an argument,
    it is known as a **parameterized constructor**.'
  prefs: []
  type: TYPE_NORMAL
- en: Then, the following line assigns the `width` double value received as an argument
    to the `width` double field. We use `this.width` to access the `width` field for
    the instance and `width` to reference the argument. The `this` keyword provides
    access to the instance that has been created and we want to initialize, that is,
    the object that is being built. We use `this.height` to access the `height` field
    for the instance and `height` to reference the argument.
  prefs: []
  type: TYPE_NORMAL
- en: The two lines before the constructor declare the `width` and `height` double
    field. These two fields are member variables that we can access without restrictions
    after the constructor finishes its execution.
  prefs: []
  type: TYPE_NORMAL
- en: The following lines create four instances of the `Rectangle` class named `rectangle1`,
    `rectangle2`, `rectangle3`, and `rectangle4`. The code file for the sample is
    included in the `java_9_oop_chapter_03_01` folder, in the `example03_04.java`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Each line that creates an instance specifies the type for the new variable (`Rectangle`)
    followed by the variable name that will hold the reference to the new instance
    (`rectangle1`, `rectangle2`, `rectangle3`, or `rectangle4`). Then each line assigns
    the result of using the `new` keyword followed by the desired value for the `width`
    and `height` arguments separated by a comma and enclosed in parentheses.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Java 9, we have to specify the type for the variable in which we want to
    hold the reference to an instance. In this case, we declare each variable with
    the `Rectangle` type. In case you have experience with other programming languages
    that provide a keyword to generate implicitly typed local variables such as the
    `var` keyword in C#, you must know there is no equivalent in Java 9.
  prefs: []
  type: TYPE_NORMAL
- en: 'After we enter all the lines that declare the class and create the four instances
    in JShell, we will see four messages that say `"Initializing a new Rectangle instance"`
    followed by the width and height values specified in the call to the constructor
    of each instance. The following screenshot shows the results of executing the
    code in JShell:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Customizing constructors and initialization](img/00037.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: After we execute the previous lines, we can check the values for the `width`
    and `height` fields for each of the instances we have created. The following lines
    show expressions that JShell can evaluate to display the values for each field.
    The code file for the sample is included in the `java_9_oop_chapter_03_01` folder,
    in the `example03_05.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The following screenshot shows the results of evaluating the previous expressions
    in JShell.
  prefs: []
  type: TYPE_NORMAL
- en: '![Customizing constructors and initialization](img/00038.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Enter the following expression in JShell. The code file for the sample is included
    in the `java_9_oop_chapter_03_01` folder, in the `example03_06.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: JShell will display `true` as a result of the evaluation of the previous expression
    because `rectangle1` is an instance of the `Rectangle` class. The `instanceof`
    keyword allows us to test whether an object is of the specified type. With this
    keyword, we can determine whether an object is a `Rectangle` object.
  prefs: []
  type: TYPE_NORMAL
- en: As previously explained, `Rectangle` is a subclass of the `java.lang.Object`
    class. JShell already imported all the types from `java.lang`, and therefore,
    we can just reference this class as `Object`. Enter the following expression in
    JShell. The code file for the sample is included in the `java_9_oop_chapter_03_01`
    folder, in the `example03_07.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: JShell will display `true` as a result of the evaluation of the previous expression
    because `rectangle1` is also an instance of the `java.lang.Object` class.
  prefs: []
  type: TYPE_NORMAL
- en: Enter the following expression in JShell. The code file for the sample is included
    in the `java_9_oop_chapter_03_01` folder, in the `example03_08.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: JShell will display `"Rectangle"` as a result for the previous line because
    the `rectangle1` variable holds an instance of the `Rectangle` class. The `getClass`
    method allows us to retrieve the runtime class of an object. The method is inherited
    from the `java.lang.Object` class. The `getName` method converts the runtime type
    to a string.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will try to create an instance of `Rectangle` without providing arguments.
    The following line won't allow Java to compile the code and will display a build
    error in JShell because the compiler cannot find a parameterless constructor declared
    in the `Rectangle` class. The only constructor declared for this class requires
    two `double` arguments, and therefore, Java doesn't allow `Rectangle` instances
    to be created without specifying the values for `width` and `height`. The code
    file for the sample is included in the `java_9_oop_chapter_03_01` folder, in the
    `example03_09.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The next screenshot shows the detailed error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Customizing constructors and initialization](img/00039.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Understanding how garbage collection works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The following lines show the new complete code for the `Rectangle` class. The
    new lines are highlighted. The code file for the sample is included in the `java_9_oop_chapter_03_01`
    folder, in the `example03_10.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The new lines declare a `finalize` method that overrides the inherited method
    from `java.lang.Object` and prints a message indicating that it is finalizing
    a `Rectangle` instance and displays the width and height values for the instance.
    Don't worry about the pieces of the code that you don't understand yet because
    we will learn them in the forthcoming chapters. The goal for the new piece of
    code included in the class is to let us know when the garbage collection process
    is going to remove the object from memory.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Avoid writing code that overrides the `finalize` method. Java 9 doesn't promote
    the usage of the `finalize` method to perform cleanup operations.
  prefs: []
  type: TYPE_NORMAL
- en: The following lines create two instances of the `Rectangle` class named `rectangleToCollect1`
    and `rectangleToCollect2`. Then, the next lines assign `null` to both variables,
    and therefore, the reference count for both objects reaches zero and they become
    ready for garbage collection. The two instances can be safely removed from memory
    because there are no more variables in scope holding a reference to them. The
    code file for the sample is included in the `java_9_oop_chapter_03_01` folder,
    in the `example03_11.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the results of executing the previous lines
    in JShell:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding how garbage collection works](img/00040.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The two rectangle instances can be safely removed from memory but we don't see
    the messages indicating that the `finalize` method has been executed for each
    of these instances. Remember that we don't know when the garbage collection process
    will determine that it is necessary to claim back the memory used by these instances.
  prefs: []
  type: TYPE_NORMAL
- en: In order to understand how the garbage collection process works, we will force
    a garbage collection. However, it is very important to understand that we should
    never force a garbage collection in real-life applications. We must leave the
    JVM select the most appropriate time to perform a collection.
  prefs: []
  type: TYPE_NORMAL
- en: The next line shows the code that calls the `System.gc` method to force the
    JVM to perform a garbage collection. The code file for the sample is included
    in the `java_9_oop_chapter_03_01` folder, in the `example03_12.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The following screenshot shows the results of executing the previous line in
    JShell. We will see the messages that indicate that the `finalize` method for
    the two instances has been called.
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding how garbage collection works](img/00041.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The following lines create an instance of the `Rectangle` class named `rectangle5`
    and then assign a reference to this object to the `referenceToRectangle5` variable.
    This way, the reference count to the object increases to two. The next line assigns
    `null` to `rectangle5` and makes the reference count for the object to go down
    from two to one. The `referenceToRectangle5` variable stills holds a reference
    to the `Rectangle` instance, and therefore, the next line that forces a garbage
    collection won't remove the instance from memory and we won't see the results
    of the execution of the code in the `finalize` method. There is still one variable
    on scope that holds a reference to the instance. The code file for the sample
    is included in the `java_9_oop_chapter_03_01` folder, in the `example03_13.java`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the results of executing the previous lines
    in JShell:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding how garbage collection works](img/00042.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now, we will execute a line that assigns `null` to `referenceToRectangle5` to
    force the reference count to reach zero for the referenced instance and we will
    force the garbage collection process to run in the next line. The code file for
    the sample is included in the `java_9_oop_chapter_03_01` folder, in the `example03_14.java`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The following screenshot shows the results of executing the previous lines in
    JShell. We will see the messages that indicate that the `finalize` method for
    the instance has been called.
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding how garbage collection works](img/00043.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is very important to know that you don't need to assign `null` to a reference
    to force the JVM to claim back the memory from objects. In the previous examples,
    we wanted to understand how the garbage collection worked. Java will automatically
    destroy the objects when they aren't referenced anymore in a transparent way.
  prefs: []
  type: TYPE_NORMAL
- en: Creating instances of classes and understanding their scope
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will write a few lines of code that create an instance of the `Rectangle`
    class named `rectangle` within the scope of a `getGeneratedRectangleHeight` method.
    The code within the method uses the created instance to access and return the
    value of its `height` field. In this case, the code uses the `final` keyword as
    a prefix to the `Rectangle` type to declare an **immutable reference** to the
    `Rectangle` instance named `rectangle`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An immutable reference is also known as a constant reference because we cannot
    replace the reference held by the `rectangle` constant with another instance of
    `Rectangle`.
  prefs: []
  type: TYPE_NORMAL
- en: After we define the new method, we will call it and we will force a garbage
    collection. The code file for the sample is included in the `java_9_oop_chapter_03_01`
    folder, in the `example03_15.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The following screenshot shows the results of executing the previous lines in
    JShell. We will see the messages that indicate that the `finalize` method for
    the instance has been called after the call to the `getGeneratedRectangleHeight`
    method and the next call to force the garbage collection. When the method returns
    a value, rectangle becomes out of scope because its reference count goes down
    from one to zero.
  prefs: []
  type: TYPE_NORMAL
- en: The instanced reference by immutable variable is safe for garbage collection.
    Thus, when we force the garbage collection, we see the message displayed by the
    `finalize` method.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating instances of classes and understanding their scope](img/00044.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you understand an object's life cycle, it is time to spend some time
    in JShell creating new classes and instances.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new `Student` class with a constructor that requires two `String`
    arguments: `firstName` and `lastName`. Use the arguments to initialize fields
    with the same names as the arguments. Display a message with the values for `firstName`
    and `lastName` when an instance of the class is created.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an instance of the `Student` class and assign it to a variable. Check
    the messages printed in JShell.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an instance of the `Student` class and assign it to a variable. Check
    the messages printed in JShell.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Exercise 2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a function that receives two `String` arguments: `firstName` and `lastName`.
    Create an instance of the previously defined `Student` class with the received
    arguments as parameters for the creation of the instance. Use the instance properties
    to print a message with the first name followed by a space and the last name.
    You will be able to create a method and add it to the `Student` class later to
    perform the same task. However, we will learn more about this in the forthcoming
    chapters.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call the previously created function with the necessary arguments. Check the
    message printed in JShell.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Test your knowledge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When Java executes the code within a constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We cannot access any members defined in the class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There is already a live instance of the class. We can access methods defined
    in the class but we cannot access its fields.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There is already a live instance of the class and we can access its members.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Constructors are extremely useful to:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Execute setup code and properly initialize a new instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Execute cleanup code before the instance is destroyed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Declare methods that will be accessible to all the instances of the class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Java 9 uses one of the following mechanisms to automatically deallocate the
    memory used by instances that aren''t referenced anymore:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Instance map reduce.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Garbage compression.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Garbage collection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Java 9 allows us to define:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A main constructor and two optional secondary constructors.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Many constructors with different arguments.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Only one constructor per class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Any new class we create that doesn''t specify a superclass will be a subclass
    of:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`java.lang.Base`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`java.lang.Object`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`java.object.BaseClass`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Which of the following lines create an instance of the `Rectangle` class and
    assign its reference to the `rectangle` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`var rectangle = new Rectangle(50, 20);`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`auto rectangle = new Rectangle(50, 20);`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Rectangle rectangle = new Rectangle(50, 20);`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Which of the following lines access the `width` field for the `rectangle` instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`rectangle.field`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`rectangle..field`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`rectangle->field`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about an object's life cycle. You also learned
    how object constructors work. We declared our first simple class to generate a
    blueprint for objects. We understood how types, variables, classes, constructors,
    instances, and garbage collection work with live examples in JShell.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have learned to start creating classes and instances, we are ready
    to share, protect, use, and hide data with the data encapsulation features included
    in Java 9, which is what we are going to discuss in the next chapter.
  prefs: []
  type: TYPE_NORMAL
