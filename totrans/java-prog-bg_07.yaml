- en: More Object-Oriented Java
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we're going to explore the topic of inheritance in Java by
    creating a superclass and subclass and understanding the relationship of "is-a"
    between them, using concepts such as overriding, data structures, the abstract
    method, and the protected method. We'll also delve into the concept of an Abstract
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll cover the following concepts in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Abstract
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rather than starting with a high-level description, I think it'll be best if
    we jump right into a problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get us started, I''ve created a basic Java program, which we can access
    from the given code files. In this program, we declare two Java classes: a `Book`
    class and a `Poem` class. Both the `Book` and `Poem` classes store a number of
    attributes; for example, Book can have a title, an author, a publisher, and a
    genre. It takes all these attributes as constructor input and provides a single
    `public` method; we can use the `Print` method in our main program to print out
    information about any books we create.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Poem method does something very similar. It has a couple of attributes
    and a `Print` method, and we set its attributes through its constructor. I''ve
    whipped up a really quick main function to utilize the `Book` and `Poem` classes.
    This function creates a new book and poem and then prints them out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The preceding program works fine, but it's much more complicated than it needs
    to be.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we take a look at our `Book` and `Poem` classes side by side and just look
    at their member variables, we''ll see that both `Book` and `Poem` share two member
    variables, namely `title` and `author`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b9086a15-f8b6-4599-808e-fdf716624758.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The actions they take with the member variables, namely printing them to the
    screen, are performed and achieved in a very similar manner in both classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4816972c-9adc-4bb7-91d4-3ca04ae260cd.png)'
  prefs: []
  type: TYPE_IMG
- en: It's a good sign that `Book` and `Poem` inherit from one common class. This
    becomes easy for us to see when we think about books and poems as the physical
    objects that they represent. We can make the statement that both books and poems
    are forms of literature.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a superclass
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once we''ve come to the conclusion that books and poems share certain fundamental
    attributes, the attributes of all literature, we can start breaking down these
    classes into component parts. Our `Book` class, for example, has two real variables.
    It has a `title` variable and an `author` variable, which are attributes we associate
    with all literature. It also has a `publisher` variable and a `genre` variable,
    which may not be unique only to books and which we don''t necessarily consider
    all forms of literature to have. So how can we exploit this knowledge? Well, we
    can build our `Book` and `Poem` classes so that they share their nature as pieces
    of literature at a fundamental level. But to make this happen, we''re first going
    to have to teach our program what a piece of literature is. The following is a
    step-by-step procedure for doing this:'
  prefs: []
  type: TYPE_NORMAL
- en: We'll create a brand new class and call it `Literature`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We''ll assign to this class the attributes that the pieces of literature share,
    which we''ve so far declared. In our case, books and poems are already declared
    as pieces, with shared titles and authors. It makes some logical sense to make
    a statement that all pieces of literature will have a title and an author:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'From here, we''ll flesh out our `Literature` class like we would any other.
    We''ll give it a constructor; in this case, our constructor will take two variables:
    `title` and `author`. Then, we''ll assign them to the fields, much like we did
    with our `Poem` and `Book` classes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'While we''re at it, let''s give `Literature` a similar `Print` method, as the
    one we assigned to the `Book` and `Poem` classes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now if we wanted to, we could go to our `main` method and declare an object
    of the `Literature` class, but that's not the point. This is not the reason we've
    created the `Literature` class. Rather, our goal is to make use of this `Literature`
    class as a base that we'll build on to declare more specific types of literature,
    such as poems or books. To make use of our `Literature` class, let's see how it
    applies to the existing `Poem` class.
  prefs: []
  type: TYPE_NORMAL
- en: The is-a relationship
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our `Literature` class contains the declarations and all of the functionality
    needed to manage a piece of literature''s title and author. If we let Java know
    that there is an inheritance relationship between `Poem` and `Literature`, we
    should be able to remove all the real references from the title and author of
    the following `Poem` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'First, let''s talk about the declaration of the `Poem` class that we''ve modified.
    When we say that one class extends another, we''re saying that there is an is-a
    relationship between them such that I can logically make the statement, "A poem
    is a piece of literature." In more Java terms, we''re saying that the `Poem` subclass
     extends or inherits from the `Literature` class. This means that when we create
    a `Poem` object, it will have all the members and functionality of the class that
    it extends:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In our case, two of these members are `title` and `author`. The `Literature`
    class declares these members and does a good job of managing them throughout the
    class''s functionality. So, we can remove these members from our `Poem` class
    and we''ll still be able to access them within the `Poem` class''s methods. This
    is because the `Poem` class simply inherits its declaration from `Literature`.
    We do need to make a slight modification to get this `Poem` class working as intended,
    though. When we construct an object of a class that inherits from another class,
    by default the constructor of the subclass, as in the preceding screenshot, will
    begin by calling the constructor of the superclass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This confuses Java as we have it set up right now because the `Poem` constructor
    takes three variables as input whereas the `Literature` constructor is only expecting
    two. To solve this, explicitly call the `Literature` constructor within the `Poem`
    constructor, using the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'When we''re in a subclass, we can call the methods of our superclass using
    the `super` keyword. So in this case, we''re going to begin our `Poem` constructor
    by simply calling the `super` constructor, or the `Literature` constructor, and
    passing to it the attributes that we''d like it to know about:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We can do something very similar in our `Print` method because our `Literature`
    class, our superclass, knows how to print out a title and author already. There''s
    no reason for the `Poem` class to implement this functionality:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We'll get the same behavior from our `Print` method if we begin it by calling
    `super.Print`, instead of the original explicit printing lines shown in the preceding
    screenshot. Now, when the Poem's `Print` method runs, it will begin by calling
    the superclass's, that is, the `Literature.java` class's `Print` method. It will
    finally print out the `Poem` class's style, which is not shared across all pieces
    of literature.
  prefs: []
  type: TYPE_NORMAL
- en: While our `Poem` constructor and `Literature` constructor have different names
    and even different styles of input, the two `Print` methods shared between `Poem`
    and `Literature` are exactly the same. We'll talk about this a little more later,
    but for now you should know that we've made use of a technique called **overriding**
    here.
  prefs: []
  type: TYPE_NORMAL
- en: Overriding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we declare that a subclass has a method that''s identical to one of its
    superclass methods, we''ve overridden the superclass method. When we do this,
    it''s a good idea to use the Java `Override` indicator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This is an indicator to future coders and some more arcane elements of our compiling
    suite that this particular method, given in the preceding screenshot, is hiding
    a method beneath it. When we actually run our code, Java gives preference to the
    lowest or subclassed version of a method.
  prefs: []
  type: TYPE_NORMAL
- en: 'So let''s see whether we''ve declared our `Poem` and `Literature` relationship
    successfully. Let''s go back to the `main` method of our program in the `Inheritence.java`
    class and see whether the poem portion of this program executes as it did before:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a8018c55-7173-4c5e-aa28-0bf9b697cc82.png)'
  prefs: []
  type: TYPE_IMG
- en: When we run this program, we get the exact same output as we did previously,
    which is a great sign that we've set up our `Poem` class to inherit from `Literature`
    in a logical manner.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can jump to our `Book` class. We''ll set it up as an is-a relationship
    between the `Book` and `Literature` class using the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll declare that `Book` extends the `Literature` class; then, we''ll
    remove references to title and author in our `Book` class because now the `Literature`
    class, the superclass, will take care of this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'As with the `Poem` class, we''re going to need to explicitly call the `Literature`
    class''s constructor and pass `title` and `author` to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can make use of our superclass''s `Print` method to simplify the printing
    of our `Book` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Once again, let's jump back to our `main` method and run it to make sure that
    we've done this successfully:![](img/269c7dd3-0d67-4a9f-99cd-9bdae0783358.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'There we go: `The Lord of the Rings` output, just as we saw it before. Style-wise,
    this change is really great. By adding the `Literature` class and then subclassing
    it to create `Book` and `Poem` classes, we''ve made our `Book` and `Poem` classes
    much more bite-sized and easier for a programmer to go through and figure out
    what''s going on.'
  prefs: []
  type: TYPE_NORMAL
- en: However, this change is not purely stylistic. By declaring an is-a relationship
    between the `Book`, `Poem`, and `Literature` classes, where `Book` and `Poem`
    inherit from the `Literature` class, we've given ourselves actual functionality
    that we didn't have before. Let's take a look at this in action. If we go back
    to our `main` method, let's pretend that, rather than dealing with a single `Book`
    and `Poem` class, we're dealing with a vast network that we need to store in some
    sort of a data structure. With our original implementation, this would be a real
    challenge.
  prefs: []
  type: TYPE_NORMAL
- en: Data structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There''s no easily accessible data structure that will happily store both books
    and poems. We''d probably have to use two data structures or break strong typing,
    which is the whole point of Java:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'However, with our new implementation, where `Book` and `Poem` both inherit
    from `Literature`, we can store them in the same data structure. This is because
    inheritance is an is-a relationship, meaning that we can, once we''ve inherited
    from something, make claims such as book is literature and poem is a literature
    too. If that''s true, then an array of `Literature` objects should be able to
    store both `Book` and `Poem` within it. Let''s go through the following steps
    to illustrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an array of `Literature` objects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The fact that we get no compile errors when we build this project is a really
    good sign that we're doing something legal.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the sake of our demonstration, let''s flesh out our array here to contain
    the number of books and poems:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll modify our `main` method to print out directly from the array. Now,
    when we utilize our subclasses as though they were objects of their superclass,
    we do have to be aware that we''re now referencing them as objects of that superclass.
    For example, when we go through and acquire an element from our `Literature` array,
    irrespective of whether that element is a `Book` class, we will still not be able
    to access things such as its `genre` field even if this field is `public`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This is because the `Literature` class that we're now using as an object (as
    given in the preceding screenshot) does not have a `genre` member variable. But
    what we can do is call methods from our superclass that are overridden by the
    subclasses.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can call the `Literature` class''s `Print` method within our `for` loop.
    Java will prioritize the `Print` methods of our subclasses:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This means that, when we run this program, we''ll still get the specially formatted
    output that we have attributed to `Book` and `Poem`, not the simplified version
    that we stored in our `Literature` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The abstract method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We may sometimes see methods that exist only to be overloaded by subclasses.
    These methods don''t do anything, and we can tag them with the `abstract` keyword,
    that is, `public abstract void Print()`, in the superclass (`Literature.java`).
    Of course, if a class has methods declared `abstract`, it''s probably a good sign
    that an instance of such a class should never be explicitly created. If our `Literature`
    class''s `Print` method is abstract, we should never declare objects that are
    only Literature. We should only use objects that are one of the subclasses of
    `Literature`. If we''re going to go down this route, we should declare `Literature`
    to be an `abstract` class as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: If we did this, of course, we'd have to get rid of the references to the Literature
    class's super method, so let's undo these changes for now.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at a minor mistake we made when building this program initially.
    When creating our Literature class, we declared that title and author were `public`
    member variables. As you may know, generally we do not declare member variables
    public if we don't have a good reason to. It doesn't make a lot of sense for a
    piece of literature to change its author after it's been declared already, so
    `author` and `title` should be `private` member variables that are set in the
    `Literature` class's constructor whose values should never change. Unfortunately,
    if we make this change to our Literature class, we're going to limit the functionality
    of our Poem and Book classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say, for example, that we wanted to modify the `Print` function of our
    `Poem` class so that it wouldn''t have to explicitly call the `Print` function
    of the `Literature` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Maybe we want to start it by telling it that we''re declaring a `Poem` class
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Unfortunately, because we've made `title` and `author` private to the `Literature`
    class, the `Poem` class, even though it is a subclass of `Literature`, will not
    be able to access these member variables in its explicit code. This is kind of
    annoying, and it seems like there is some sort of protection setting between `private`
    and `public` where it's private for every class, except for the subclasses of
    the class. In fact, there is a protection setting available.
  prefs: []
  type: TYPE_NORMAL
- en: The protected method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `protected` method is the protected protection setting. If we declare that
    member variables are `protected`, it implies they''re private and not accessible
    by anyone, except the class and it''s subclasses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Just to reassure ourselves, everything we've been doing here is legitimate.
    Let's run our program again and make sure the output looks good, which is the
    case. After this, we should have a pretty good grasp of inheritance. We can develop
    a lot of systems that really mimic their real-world counterparts, and we can write
    very elegant and functional code using inheritance and small classes that don't
    do a lot of complicated things in and of themselves.
  prefs: []
  type: TYPE_NORMAL
- en: Abstract
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll take a quick look at an important idea that relates to
    inheritance in Java. To wrap our heads around what we're going to talk about,
    I think it's best if we start an existing project in the system. So let's take
    a look at the code we have in the code files.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, we''ve done the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The `main` method of our program creates a list of objects. These objects are
    either of the type `Book` or `Poem`, but we've placed them in a list of `Literature`
    objects, leading us to believe that the `Book` and `Poem` classes must inherit
    from or extend the `Literature` class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once we've built this array, we simply iterate through it using a `for` loop
    and call the `Print` method of this `for` loop on each object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At this point, we're dealing with objects as `Literature` objects, not the Books
    or Poems that they are at the lowest level. This leads us to believe that the
    `Literature` class itself must implement a `Print` method; if we jump into the
    class, we'll see that this is true indeed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'However, if we run our program, we will quickly see that Books and Poems execute
    their `Print` method slightly differently, displaying different information for
    each of them. This is explained when we look at the `Book` and `Poem` classes,
    which do indeed extend the `Literature` class, but each of these classes overrides
    the `Literature` class''s `Print` method to provide its own functionality. This
    is all well and good and is a pretty elegant solution, but there''s an interesting
    case that we should take a look at and discuss. Because `Literature` is itself
    a class, it''s perfectly valid for us to declare a new `Literature` object, just
    as we could for `Book` or `Poem`. The `Literature` class''s constructor first
    expects the `title` of the piece of literature and then the `author`. Once we''ve
    created a new instance of the `Literature` class, we could put that instance into
    our list of `Literature` classes, just like we''ve been doing with instances of
    the `Book` and `Poem` classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'When we do this and run our program, we''ll see the `Literature` class''s `Print`
    method get executed, and the new `Literature` object we have created will display
    alongside our list of books and poems:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a451f7d1-909e-45b3-a3bc-52665ed6e47b.png)'
  prefs: []
  type: TYPE_IMG
- en: So what's the problem here? Well, depending on the true nature of the software
    we're trying to design, this may or may not make a lot of sense. Let's say we're
    doing this as part of a library system, providing someone with just the information
    that something called Java was written by some guy called Zach, without telling
    them whether it's a book or a poem or any other information that we've decided
    to associate with specific types of literature. This may simply not be useful
    at all and is something that should never be done.
  prefs: []
  type: TYPE_NORMAL
- en: 'If this is the case, Java provides us with a system to create classes that
    we can use for inheritance purposes, but we will never be able to legally instantiate
    them on their own, as we''ve done before. If we want to mark a class to be of
    that type, we''re going to call it an `abstract` class, and in the class''s declaration,
    we simply use the `abstract` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Once we've marked a class `abstract`, it's no longer a legal operation to instantiate
    this class. At face value, this is a really simple thing and primarily a "protect
    our code from ourselves and other programmers" kind of deal, but that's not entirely
    true; rather, it is true but it's not the only purpose of declaring a class as `abstract`.
  prefs: []
  type: TYPE_NORMAL
- en: Once we've told Java that we can never create an instance of just `Literature`,
    of classes that use `Literature` as their superclass, we're no longer as restricted
    when setting up the `Literature` class. Because we've declared `Literature` to
    be an abstract class, we and Java will know that `Literature` will never be instantiated
    on its own, only when it is a superclass of a class being instantiated. When this
    is the case, we can get away without having portions of this class that most Java
    classes have to have. For example, we don't need to actually declare a constructor
    for `Literature`. If `Literature` was a standard Java class, Java would not be
    okay with this because if we did try to instantiate `Literature`, it would have
    no idea of what to do. There would be no constructor to call. But because `Literature`
    is abstract, we can be confident that Literature's subclasses will have constructors
    of their own. Of course, if we do make this change, we're going to have to get
    rid of the references to the `Literature` constructor in our subclasses, that
    is, by deleting the `super` method from the subclasses. Therefore, there's definitely
    a trade-off associated with this change. It requires more code in our subclasses
    to have less code in our `Literature` superclass. In this particular instance,
    this trade-off probably isn't worth it because we're duplicating code between
    our `Book` and `Poem` constructors, but if the constructors for `Literature` subclasses
    could be assumed to do very different things, not declaring a common base constructor
    would make a lot of sense.
  prefs: []
  type: TYPE_NORMAL
- en: So, in a nutshell, when we architect our program, or a larger solution, so that
    we have classes that make a lot of sense for architecture purposes but should
    never be created all on their own, we should declare those classes as `abstract`.
    Sometimes, we'll really know we've come across a class like this when certain
    common class functionalities, such as having a constructor, just don't make sense
    for this class.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we got to know some intricacies of object-oriented programming,
    using the concept of inheritance precisely by creating something called a superclass
    and subclass and establishing an "is-a" relationship between them. We also discussed
    the usage of some key aspects, such as overriding a subclass and superclass, data
    structures, and the `protected` method. We also got to know how an `abstract`
    method works in detail.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you'll learn about useful Java classes.
  prefs: []
  type: TYPE_NORMAL
