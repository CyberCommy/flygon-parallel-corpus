- en: Debugging Components in the Browser
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you're developing a React web application, you need browser-based tooling
    to help you see what's happening on the page from the perspective of a React developer.
    Web browsers today have amazing developer tools installed by default. These are
    essential if you're doing any kind of web development because they expose what's
    really going on in terms of DOM, styles, performance, network requests, you name
    it.
  prefs: []
  type: TYPE_NORMAL
- en: With React, you still need all of this tooling, but you need more than that.
    The core tenet of React is declarative markup within JavaScript components. If
    this abstraction isn't present in the web browser tooling that developers rely
    on for everything else, life is more difficult than it needs to be.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you''ll learn:'
  prefs: []
  type: TYPE_NORMAL
- en: Installing the React Developer Tools browser add-on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Locating and selecting React components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manipulating component props and state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Profiling component performance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing the React Developer Tools add-on
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first step to getting started with React tooling is to install the React
    Developer Tools browser extension. I'll be using Chrome in the examples throughout
    this chapter as this is a popular choice. React Developer Tools is also available
    as an extension for Firefox ([https://addons.mozilla.org/en-US/firefox/addon/react-devtools/](https://addons.mozilla.org/en-US/firefox/addon/react-devtools/)).
  prefs: []
  type: TYPE_NORMAL
- en: 'To get the extension installed in Chrome, visit [https://chrome.google.com/webstore/category/extensions](https://chrome.google.com/webstore/category/extensions)
    and search for `react developer tools`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/f09d7cd6-acf2-4485-aca6-fb03a882cdbc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The first result should be the extension that you want. Click on the ADD TO
    CHROME button to install it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/0f971519-8b9b-45f2-bd83-272180ee40c2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Chrome might warn you that it can change data on websites that you visit. Don''t
    worry, the extension is only activated when you visit React apps:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/86b0a040-1848-4226-80bf-bbddd1756d1b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once you click on the Add extension button, the extension is marked as installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/4238f215-8429-4760-834c-d10920df4224.png)'
  prefs: []
  type: TYPE_IMG
- en: You're all set! With the React Developer Tools Chrome extension installed and
    enabled, you're ready to start inspecting React components on the page, just like
    you would with regular DOM elements.
  prefs: []
  type: TYPE_NORMAL
- en: Working with React elements in React Developer Tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once you''ve installed React Developer Tools in Chrome, you''ll see a button
    in the toolbar located to the right of the browser address bar. Here''s what mine
    looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/cb811ae0-6b77-4acd-a83a-cf6576de8c47.png)'
  prefs: []
  type: TYPE_IMG
- en: 'I have several buttons for browser extensions here. You can see the React Developer
    Tools button at the far right—the one with the React logo. When the button is
    greyed-out like this, it means that you''re not currently on a page running a
    React application. Go ahead and try clicking on it while you''re on some random
    page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/06aecb5f-f488-491a-9e82-e955b70ae8fe.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now let''s use `create-react-app` to create a new application, the same process
    you''ve been following throughout this book:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now fire up the development server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This should take you directly to the browser page with your React application
    loaded up in a new tab. Now the React Developer Tools button should look different:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/2ffa9251-6af2-41c0-8aad-0490faaccb6f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'There you go. Since you''re on a page that''s running a React application,
    the React Developer Tools button comes alive to let you know that it''s available.
    Try clicking on it now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/258cf495-5c39-4494-b6e6-51149bdafc05.png)'
  prefs: []
  type: TYPE_IMG
- en: Awesome! The React Developer Tools can detect that this is a development build
    of the React library. This could come in handy in case you ever find yourself
    in a situation where you accidentally deploy the development build of React to
    a production environment. Admittedly, this is more difficult to do today with
    tools like `create-react-app` where you have the tooling in place to build production
    versions for free.
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, so now that you have your React browser tooling in place, what else can
    it do for you other than detect the type of React build that''s being used by
    a given app? Let''s open up the developer tools pane within Chrome and find out:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/c1240c93-ff99-4812-ae3f-e92b0f059b2d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can see all of the regular sections that you normally see in the developer
    tools pane: Elements, Console, and so on. But there''s nothing about React? I
    happen to have my developer tools pane docked to the right-hand side of my browser
    window, so you can''t see every section. If you''re seeing the same thing, you
    just have to click on the arrow button next to Performance:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/a19e461d-bb35-4dd2-b858-0e2f5c6bf504.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Select React from the menu and you''ll be taken to the React section of the
    developer tools panel. Once it loads, you should see the root React component
    displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/4556b196-8ec0-4819-8939-18845b62d6f6.png)'
  prefs: []
  type: TYPE_IMG
- en: If you've used the DOM inspector tool in any browser, this interface should
    feel familiar. In the main section to the left, you have your React element tree.
    This should closely resemble your JSX source. To the right of this tree, you have
    details of the currently-selected element, in this case it's `App`, and it doesn't
    define any properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you expand `App`, you''ll see its child HTML markup and other React elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/7e88c0de-1ee6-4e1d-8132-7cb0e1b39a06.png)'
  prefs: []
  type: TYPE_IMG
- en: This is the default source code after running `create-react-app`, so there isn't
    very much of interest under the `App` element. To further explore React Developer
    Tools, you'll have to introduce some more components and render more React elements
    on the page.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting React elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are actually two ways to select a React element using React Developer
    tools. When you open the React section of the developer tools pane, the root element
    of the React app is automatically selected in the element tree. However, you can
    expand this element to reveal child elements and select them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s put together a simple app that will help you explore the rendered React
    elements on the page using React Developer Tools. Starting from the top level,
    here''s the `App` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'By looking at this source, you can take a glimpse at the overall structure
    of the React elements when they''re rendered on the page. Next, let''s look at
    the `MyContainer` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This component renders some header text and whatever children are passed to
    it. In this application, you''re passing it a `MyChild` element, so let''s look
    at this component next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now when you run `npm start`, you should see the following content rendered:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/36566035-9d1c-41c1-b546-2f4856a88f05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Not much to look at, but you know that everything is working as expected. The
    app is small enough that you can see every JSX element within the tree view of
    the React Developer Tools pane:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/65e61109-c368-404f-be29-d81778caa0d1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'There is a visual distinction between React elements and other element types,
    so that they''re easier to spot in this tree view. For example, the `<MyContainer>`
    element is in one color while the `<section>` element is in a different color.
    Let''s select the `<MyContainer>` element and see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/7fb9bbf7-602d-41a1-9766-118e5869d1b0.png)'
  prefs: []
  type: TYPE_IMG
- en: Up until this point, you've only had the `<App>` element selected, so there
    wasn't anything to show about this element—it has no props or state. The `<MyContainer>`
    element, on the other hand, does have properties to show. In this case, it has
    a `children` property because a `<MyChild>` element was rendered as a child element
    of `<MyContainer>`. Don't worry about the specifics displayed to the right of
    the selected element just yet—we'll go into more detail in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s activate the selection tool. It''s the button above element tree
    that has a target icon in it. When you click on the icon, it changes to blue to
    let you know that it''s active:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/b2795945-0e0b-496f-bd11-8a322ac6cddd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The idea of this tool is to allow you to click elements on the page and have
    the corresponding React component selected in the developer tools pane. You''ll
    notice that when the tool is active, elements are highlighted as you move over
    them, letting you know what they are:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/59a7ce26-351f-4e28-b001-3189828643cc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, the mouse pointer is over the `<p>` element on the page, as the little
    box indicates. If you click on the element, the selection tool will select the
    appropriate element in the developer tools pane and then deactivate itself. Here''s
    what the `<p>` element looks like when selected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/760c5a8d-f00a-4bcf-bc36-dad8b9efc6c0.png)'
  prefs: []
  type: TYPE_IMG
- en: Even though the `<p>` element is selected here, you're seeing props from the
    React element that rendered it—`<MyChild>`. If you're working with page elements
    and you're not exactly sure which React element rendered them, using the selection
    tool in React Developer Tools is a quick way to find out.
  prefs: []
  type: TYPE_NORMAL
- en: Searching for React elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When your application gets bigger, traversing elements on the page or in the
    element tree in the React Developer Tools panel doesn''t work so well. You need
    a way to search for React elements. Luckily, there''s a search box located right
    above the element tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/70d8b0fe-d6ad-433f-a0e8-f0f2b2f869ef.png)'
  prefs: []
  type: TYPE_IMG
- en: As you type in the search box, elements are filtered in the element tree below.
    As you can see, the matching text is also highlighted. The search only matches
    against the name of the element, which means that searching will not help you
    if you need to filter down from 100 of the same type of element. However, even
    in these cases, searching can remove everything else in the app, so that you have
    a smaller list to manually go through.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you select the Highlight Search checkbox, searching will highlight React
    elements in the main browser window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/9b9e7899-1658-4852-a904-d1aa21cb1f28.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Both React elements (`<MyContainer>` and `<MyChild>`) on this page are highlighted
    because they both match the search criteria, `my`. Let''s see what happens when
    you search for `child` instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/b4810a54-a129-4f5c-811b-b576283bf1d9.png)'
  prefs: []
  type: TYPE_IMG
- en: This time, you can see the only React element that matches your search. It's
    highlighted in the main browser window and in the element tree. By searching like
    this, you know exactly what element on the screen you're working with when you
    select it in the element tree.
  prefs: []
  type: TYPE_NORMAL
- en: Inspecting component properties and state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'React follows a declarative paradigm so it helps to have tooling in place like
    React Developer Tools that lets you see your JSX markup in the browser. This is
    only the static aspect of your React app—you declare the elements of your UI and
    let data control the rest. Using the same tool, you can watch props and state
    as they flow through your app. To demonstrate this, let''s create a simple list
    that fills itself up once mounted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s a rough breakdown of everything that this component does:'
  prefs: []
  type: TYPE_NORMAL
- en: '`timer` and `state`: These properties are initialized. The main state of this
    component is an `items` array.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`componentDidMount()`: Sets up an interval timer that adds a new value to the
    `items` array every three seconds. Once there are ten items, the interval is cleared.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`componentWillUnmount()`: Makes sure the `timer` property is forcefully cleared.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onItemClick()`: Takes an `index` argument and returns an event handler for
    the index. When the handler is called, the `strikethrough` state is toggled.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`render()`: Renders a `<ul>` list of `<MyItem>` elements, passing it relevant
    props.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The idea here is to slowly build the list so that you can watch the state changes
    happen in the browser tooling. Then, with the `MyList` elements, you can watch
    the props that are passed to it. Here''s what this component looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: It's a simple list item. The `textDecoration` style changes based on the value
    of the `strikethrough` prop. When this is true, the text will appear to be striked
    out.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s load up this app in your browser and watch the state of `MyList` change
    as the interval handler is called. Once the app loads, make sure you have the
    React Developer Tools pane open and ready to go. Then, expand the `<App>` element
    and select `<MyList>`. You''ll see the state of the element to the right:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/0f159b9e-8a29-4305-8f89-0f2f1fae98b0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The rendered content to the left matches the state displayed to the right for
    the selected `<MyList>` element. There''s an array of 5 items, and a list of 5
    items is rendered on the page. This example uses an interval timer to update the
    state over time (until it reaches 10 items). If you watch closely, you can see
    that the state value to the right changes in sync with the rendered content, as
    new list items are added. You can also expand individual items in the state to
    see their values:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/795ca4e2-6827-4504-b900-bb0066593c4a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you expand the `<MyList>` element, you''ll see all of the `<MyItem>` elements
    rendered as a result of items being added to the `items` array state. From there,
    you can select `<MyItem>` elements to view its props and state. In this example,
    the `<MyItem>` elements only have props—no state:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/09385fb8-63fe-4620-92cb-f6bf5d364426.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can see the props passed to a given element in the tree view to the left.
    This is a little difficult to read though, compared to the values you can see
    to the right that show you the prop values of the selected element. The following
    props are passed to `<MyItem>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`label`: The text to be rendered'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onClick`: The function that''s called when the item is clicked'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`strikethrough`: If `true`, the text is rendered with a `strikethrough` style'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can watch the values of properties change as elements are re-rendered.
    In the case of this app, when you click on a list item, the handler function will
    change the state of the items list in the `<MyList>` element. Specifically, the
    index of the item clicked will toggle its `strikethrough` value. This in turn
    will cause the `<MyItem>` element to re-render itself with the new prop value.
    If you keep the element that you''re about to click on selected in the developer
    tools pane, you can keep an eye on props as they change:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/9b6e0451-9f61-4f6d-8d69-9f173c567d36.png)'
  prefs: []
  type: TYPE_IMG
- en: The text for the first item is rendered with the `strikethrough` style. This
    is because the `strikethrough` property is `true`. If you look closely at the
    prop values to the right of the element tree in the developer tools pane, you
    can see individual props flash yellow when they change—a visual cue that's handy
    for debugging your components.
  prefs: []
  type: TYPE_NORMAL
- en: Manipulating element state values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: React Developer Tools lets you inspect the current state of elements that you
    select. You can also monitor state changes as they happen, as was demonstrated
    in the preceding section where you had set up an interval timer that changed the
    state of your element over time. The state of an element can also be manipulated
    in limited ways.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this next example, let''s modify the `MyList` component to remove the interval
    timer and simply populate the state when it''s constructed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now when you run this app, you''ll see the 10 items rendered immediately. Other
    than this, there are no other changes. You can still click on individual items
    to toggle their `strikethrough` state. Once you have this app up and running,
    make sure the React Developer Tools browser pane is open so that you can select
    the `<MyList>` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/5d3028cd-16ff-4ef1-b0e6-7e6605fc6e38.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To the right, you can see the state of the selected element. You can actually
    expand one of the objects in the `items` array and change its property values:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/2c94a3b4-a5d5-4de6-8050-4e1d551c34fd.png)'
  prefs: []
  type: TYPE_IMG
- en: The `label` and `strikethrough` properties of the first object in the `items`
    array state were changed. This caused the `<MyList>` and the first `<MyItem>`
    elements to be re-rendered. As expected, the changed state is reflected in the
    rendered output to the left. This is handy when you need to troubleshoot components
    that aren't updating their rendered content as they should be. Rather than having
    to orchestrate some test code within the component, you can simply reach directly
    into the rendered element's state and manipulate it within the browser.
  prefs: []
  type: TYPE_NORMAL
- en: The one caveat with editing state like this using React Developer Tools is that
    you can't add or remove items from collections. For example, I can't add a new
    item to the `items` array, nor can I add a new property to one of the objects
    in the array. For this, you need to orchestrate your state in the code, as you
    did in the example prior to this one.
  prefs: []
  type: TYPE_NORMAL
- en: Profiling component performance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Profiling the performance of your React components is made easier by React Developer
    Tools. It makes it easier to spot updates that cause elements to re-render when
    no re-render is actually necessary. It also makes it easier to collect the amount
    of CPU time that a given component spends, and where it spends it during its lifespan.
  prefs: []
  type: TYPE_NORMAL
- en: Although React Developer Tools does not include any memory profile tooling,
    we'll look at how you can use the existing memory developer tool to specifically
    profile for React elements.
  prefs: []
  type: TYPE_NORMAL
- en: Removing reconciliation work
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reconciliation is what happens when a React element is rendered. It first computes
    the virtual DOM tree that will render the element's current state and props. Then,
    this tree is compared to the existing tree for the element, assuming it has been
    rendered at least once already. The reason that React does this is because reconciling
    changes like this in JavaScript, before interacting with the DOM, is more performant.
    DOM interactions are relatively expensive compared to simple JavaScript code.
    Additionally, there are a number of common cases that the React reconciler has
    heuristics for.
  prefs: []
  type: TYPE_NORMAL
- en: React handles all of this for you—you just need to think about writing declarative
    React components. This doesn't mean that you'll never run into performance issues.
    Just because reconciliation in JavaScript often performs better than directly
    manipulating the DOM doesn't mean that it's cheap. So let's put together an application
    that highlights some potential issues with reconciliation and then let's fix them
    with the help of React Developer Tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll create an app that renders groups and members of each group. It''ll
    have controls that change the number of groups and the number of members in each
    group. Lastly, each rendered group will have a button for adding a new group.
    Let''s start with `index.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This is almost like any `index.js` that you would see from `create-react-app`.
    The difference is that there's an `update()` function that's called in an interval
    using `setInterval()`. You wouldn't randomly throw an interval timer that re-renders
    your app every five seconds into your app. I'm adding this here just as a simple
    means to illustrate repetitive re-rendering and what the reconciliation consequences
    of this are. You'll likely find similar behavior in a real app where you update
    components to keep their state fresh—this is an approximation of this behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, you have the main `App` component. This is where all of the application
    state lives, and most of the functionality for that matter. Let''s take a look
    at the file in its entirety, then I''ll break it down for you:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s start with the initial state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The state that this component manages is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`groupCount`: How many groups to render'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`memberCount`: How many members to render in each group'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`groups`: An array of group objects'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Each of these values is stored as state because they can be changed. Next,
    let''s look at the `refreshGroups()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Don''t worry about the implementation specifics too much here. The purpose
    of this function is to populate the state as the number of groups and the number
    of group members change. For example, once called, you''d have state that looks
    something like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The reason that this is defined in its own function is because you''ll end
    up calling it in several places. For example, in `componentWillMount()` it is
    called so that the component has initial state before it''s rendered for the first
    time. Next, let''s look at the event handler functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'These do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`onGroupCountChange()`: Updates the groups state by calling `refreshGroups()`
    with the new number of groups'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onMemberCountChange()`: Updates every member object in the groups state with
    the new number of members.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onAddMemberClick()`: Updates the groups state by adding a new member object
    at the given index'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally, let''s have a look at the JSX that''s rendered by this component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This component renders two slider controls: one that controls the number of
    groups and one that controls the number of members in each group. Next, the list
    of groups is rendered. For this, there''s a `Group` component, which looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This will render the name of the group, followed by a button that adds a new
    member, and then, by the list of members. When you first load the page, you''ll
    see output that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/1cc3abc1-8e70-4e4e-a114-ff7253f52975.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Only a portion of the output is shown here—there are more members in Group
    1 and there are more groups that follow, rendered using the same pattern. Before
    using any of the controls on this page open up React Developer Tools. Then, look
    for the Highlight Updates checkbox:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/69cc8fd5-15bf-4eda-98a2-b083ae7b1cb7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once you''ve checked this box, your rendered elements will be visually augmented
    when their state is updated. Recall that you set up the `App` component to re-render
    every five seconds. Every time, it''s calling `setState()`, which results in output
    that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/a4dfa551-27c4-4e87-88de-f088df5b408d.png)'
  prefs: []
  type: TYPE_IMG
- en: The blue border briefly flashes around the element that's just been updated.
    Although you can't see everything that `<App>` renders in this screenshot, the
    blue border is surrounding all `<Group>` elements because it's indicating that
    the `<App>` component was just updated. If you watch your screen for a few moments,
    you'll notice that the blue border shows up every 5 seconds. This indicates that
    even though nothing has changed with the state of your element, it's still performing
    reconciliation. It's traversing potentially hundreds or thousands of tree nodes
    to find any differences and make the appropriate DOM updates.
  prefs: []
  type: TYPE_NORMAL
- en: While you can't notice a difference in this app, the cumulative effect of a
    more complex React application might become a problem. In this specific case,
    it's a potential problem because of the update frequency.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s make an addition to `App` that looks for a shortcut to performing full
    reconciliation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: If a React component class has the `shouldComponentUpdate()` method and it returns
    false, reconciliation is completely avoided and no re-render takes place. You
    can see the change immediately in your browser by making sure that the Highlight
    Updates checkbox is checked. If you sit and watch for a few more moments, you'll
    see that no more blue borders show up.
  prefs: []
  type: TYPE_NORMAL
- en: There are different colors for the update borders. The blue that you're seeing
    represents infrequent updates. These range all the way to red, depending on the
    frequency of update. For example, if you slide the groups or members sliders aggressively
    back and forth, you should be able to produce the red border.
  prefs: []
  type: TYPE_NORMAL
- en: Note, however, that you can't always avoid reconciliation. What's important
    is that you macro-optimize for this. For example, the solution that you've just
    added to the `App` component addresses re-rendering a huge component with lots
    of children when it clearly isn't necessary. This is valuable compared to micro-optimizing
    the `Group` component—it's small enough that you don't save much by avoiding reconciliation
    here.
  prefs: []
  type: TYPE_NORMAL
- en: Your goal should be to keep it high level, and to keep `shouldComponentUpdate()`
    simple. This is an entry point for bugs to slip into your components. In fact,
    you've already introduced a bug. Try clicking on one of the Add Member buttons
    for a group—they no longer work. This is because the criteria you're using in
    `shouldComponentUpdate()` only takes into consideration the `groupCount` and `memberCount`
    states. It doesn't take into consideration adding new members to groups.
  prefs: []
  type: TYPE_NORMAL
- en: 'To fix this problem, you have to use the same approach as you have with the
    `groupCount` and `memberState` states in `shouldComponentUpdate()`. If the total
    number of members across all groups changes, then you know that your app needs
    to re-render. Let''s make this change in `shouldComponentUpdate()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The `totalMembers()` function takes a component state as an argument and returns
    the total number of group members. Using this, you can add another condition that
    uses this function to compare the number of members in the current state to the
    number of members in the new state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Now if you try clicking on the Add Member button again, it will add the member
    as expected, because the component can detect that something about the state change.
    Once again, you're trading off the cost of summing the lengths of member arrays
    and comparing the two, with the cost of performing reconciliation in the React
    DOM tree.
  prefs: []
  type: TYPE_NORMAL
- en: Finding CPU intensive components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `shouldComponentUpdate()` life cycle method enables macro-optimization of
    your component performance. If there's clearly no need to re-render the element,
    then let's sidestep the reconciliation process entirely. Other times, reconciliation
    simply cannot be avoided—the element state is changing frequently, and these changes
    need to be reflected in the DOM for the user to see.
  prefs: []
  type: TYPE_NORMAL
- en: The development version of React 16 has some handy performance tooling built
    into it. It calls the relevant browser dev tool APIs in order to record relevant
    metrics while a profile is being recorded. Note that this isn't related to the
    React Developer Tools browser extension that you installed earlier; this is simply
    React interacting with the browser when in development mode.
  prefs: []
  type: TYPE_NORMAL
- en: The aim is to produce React-specific timing data so that you don't have to mentally
    map 20 other browser performance metrics to your component and figure out what
    they all mean. Everything is there for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate this functionality, you can use the same code from the previous
    section with a couple of minor adjustments. First, let''s make more members available
    in each group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The reason we''ve increased this number is so that the performance of the app
    degrades as you fiddle with controls—it''s this performance degradation that you
    want to capture using performance dev tools. Next, let''s increase the maximum
    slider value for the members field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s it. Now when you view this app in your browser, it should look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/d94284d1-cb45-41aa-9581-48035d414df0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Before changing any of these slider values, make sure that your developer tools
    pane is open and that the Performance tab is selected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/6c402524-13d2-4263-b2f4-207eb195edd9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, click on the circle icon to the left to start recording a performance
    profile. The button will change to red and you''ll see a status dialog appear,
    indicating that profiling has started:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/1deafabf-f16c-473c-912a-a928c7235061.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that you''re recording, slide the Groups slider all the way to the right.
    As you get closer to the right, you might notice some lag in the UI, which is
    a good thing since this is what you''re trying to engineer. Once you reach the
    right side of the slider, stop the recording by clicking on the red circle that
    you clicked on to start the recording. You should see something similar to the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/8a141de3-4c30-4c9a-94e2-2be50a38a43f.png)'
  prefs: []
  type: TYPE_IMG
- en: I've expanded the User Timing label on the left because this is where all of
    the React-specific timings are displayed. Time flows from left to right in this
    graph. The wider something is, the longer it took to happen. You might notice
    that the performance worsens as you near the right-hand side of the slider (and
    this might also coincide with the lag you noticed in the slider control).
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s explore what some of this data means. We''ll look at data on the
    far right since this is where performance really dropped off:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/1d20af25-e877-45b5-bebb-b1a522feceb2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This label tells you that the React Tree Reconciliation took 78 milliseconds
    to perform. Not terribly slow, but slow enough that it had a tangible impact on
    user experience. As you move your way down through these labels, you should be
    able to get a better idea of why the reconciliation process takes as long as it
    does. Let''s look at the next one:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/fb5e831e-1891-4aac-8cad-7ecfac962b94.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This is interesting: the App [update] label is telling you that a state update
    in the `App` component took 78 milliseconds. At this point, you know that a state
    update in `App` caused the React reconciliation process to take 78 milliseconds.
    Let''s jump down to the next level. At this level, there are two colors. Let''s
    see what the yellow represents:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/0ee7953c-f898-4e19-b24c-1cc5e0c397dc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'By hovering over one of the yellow slices, you can see that Group [update]
    took 7.7 milliseconds to update a `Group` component. This is a tiny amount of
    time that probably can''t be improved upon in any meaningful way. However, take
    a look at the number of yellow slices representing `Group` updates. All of these
    slices of single-digit timings add up to a significant portion of the overall
    reconciliation time. Lastly, let''s look at the brown color:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/942e8e87-2081-4841-8f72-8360e6901a41.png)'
  prefs: []
  type: TYPE_IMG
- en: This label, Group [mount], indicates that it took 6.5 milliseconds to mount
    a new `Group` component. Once again, this is a small number, but there are several
    slices of them.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you've drilled all the way down to the bottom of the component
    hierarchy to examine what's causing your performance issues. What's the takeaway
    here? You determined that the bulk of the time taken by React to perform reconciliation
    is happening in the `Group` component. Each time it renders a `Group` component,
    it only takes single-digit milliseconds to complete, but there are a lot of groups.
  prefs: []
  type: TYPE_NORMAL
- en: Thanks to the performance graph in the browser developer tools, you now know
    that there's nothing to gain by changing your code—you're not going to improve
    on single-digit millisecond times in any meaningful way. In this app, the only
    way to fix the lag that you felt as you moved the slider toward the right is to
    somehow reduce the number of elements that get rendered on the page. On the other
    hand, you might notice that some of these React performance metrics have 50 milliseconds,
    or hundreds of milliseconds in some cases. You can easily fix your code to provide
    a better user experience. The key is that you'll never know what actually makes
    a difference without a performance dev tool like the one you've worked with in
    this section.
  prefs: []
  type: TYPE_NORMAL
- en: You can often feel the performance issues when you interact with your application
    as a user. But another way to verify that your components have performance woes
    is to look at the frame rate that is displayed just above the React metrics in
    green. It shows you how long frames took to render during the corresponding React
    code below. This example that you've just built starts off at 40 frames per second
    when the slider is to the left but ends at 10 frames per second when the slider
    makes it all the way to the right.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about React tooling that is available directly
    through the web browser. The tool of choice here is a Chrome/Firefox extension
    called React Developer Tools. This extension adds React-specific capabilities
    to the browsers native developer tools. After you installed the extension, you
    learned how to select React elements and how to search for React elements by tag
    name.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you looked at the properties and state values of the selected React component
    in React Developer Tools. These values are kept up to date automatically, as they're
    changed by your application. You then learned how to directly manipulate element
    state directly within the browser. The limitation here being that you can't add
    or remove values from collections.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you learned how to profile your React component performance within
    the browser. This isn't a React Developer Tools feature, but something the develop
    build of React 16 does automatically. Using profiles like these allows you to
    make sure that you're addressing the right things when you're experiencing performance
    issues. The example that you looked at in this chapter showed that there wasn't
    actually anything wrong with the code—it was a problem of rendering too many elements
    on the screen at once.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you'll build a Redux-based React application and use Redux
    DevTools to instrument the state of your application.
  prefs: []
  type: TYPE_NORMAL
