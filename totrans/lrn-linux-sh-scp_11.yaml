- en: Conditional Testing and Scripting Loops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will begin with a recap on `if-then-else`, before presenting advanced
    uses of `if-then-else` conditionals. We will introduce scripting loops in the
    form of `while` and `for`, and we will show how we can control these loops with
    `exit`, `break`, and `continue`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following commands will be introduced in this chapter: `elif`, `help`,  `while`,
    `sleep`, `for`, `basename`, `break`, and `continue`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Advanced `if-then-else`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `while` loop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `for` loop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `loop` control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All scripts for this chapter can be found on GitHub: [https://github.com/PacktPublishing/Learn-Linux-Shell-Scripting-Fundamentals-of-Bash-4.4/tree/master/Chapter11](https://github.com/PacktPublishing/Learn-Linux-Shell-Scripting-Fundamentals-of-Bash-4.4/tree/master/Chapter11).
    All other tools are still valid, both on your host machine as well as on your
    Ubuntu virtual machine. For the break-x.sh, for-globbing.sh, square-number.sh, while-interactive.sh
    scripts only the final version is found online. Be sure to verify the script version
    in the header before executing it on your system.'
  prefs: []
  type: TYPE_NORMAL
- en: Advanced if-then-else
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is dedicated to everything to do with conditional testing and scripting
    loops, which are two concepts that are often intertwined. We have already seen
    the `if-then-else` loop in [Chapter 9](125f46ad-bffc-4bf6-86e7-ae6a2ca47bb6.xhtml),
    *Error Checking and Handling*, which focused on error checking and handling. We'll
    present a small recap of the things we've described regarding `if-then-else`,
    before moving on to advanced concepts.
  prefs: []
  type: TYPE_NORMAL
- en: A recap on if-then-else
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`If-then-else` logic does almost exactly what the name implies: **if** *something-is-the-case*,
    **then** *do-something* or **else** *do-something-else*. In practice, this could
    be **if** *the disk is full*, **then** *delete some files* or **else** *report
    that the disk space looks great*. In a script, this could look something like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If a file exists, we print the contents. Otherwise (so, if the file does not
    exist), we give the user feedback in the form of the error message, then we exit
    the script with an exit status of `1`. Remember, any exit code that is not 0 signifies
    a *script failure*.
  prefs: []
  type: TYPE_NORMAL
- en: Using regular expressions in tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A chapter after introducing `if-then-else`, we learned all about regular expressions.
    That chapter, however, was mostly theoretical and only contained a single script!
    Now, as you might realize, regular expressions are mostly supporting constructs
    that are to be used with other scripting tools. In the case of the tests we have
    described, we can use both globbing and regular expressions within the `[[...]]`
    blocks! Let''s look at this in more depth, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We first check if the user supplied the correct number of arguments (which is
    what we should always do). Next, we use the `=~` operator within the test `[[..]]`
    block. This allows us to **evaluate using regular expressions**. In this case,
    it simply allows us to verify that the user input is a number, and not anything
    else.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if we call this script, we will see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that both of our input checks work. If we call this script without
    exactly one argument (`$# -ne 1`), it fails. This is true for both `0` and `2`
    arguments. Next, if we call the script with a letter instead of a number, we get
    to the second check and the consequent error message: `wrong type of argument`.
    Finally, to prove that the script actually does what we want, we will try it with
    single number: `3` and `11`. The returns of `9` and `121` are the squares of these
    numbers, so it seems we achieved our goal!'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, not everything is always as it seems. This is a common pitfall when
    using regular expressions, as the following code should illustrate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'How did this happen? We checked to see if the user input was a number, did
    we not? Actually, contrary to what you might think, we actually checked if the
    user input *matched positively against a number*. To say this in simpler terms,
    if the input contains a number, the check succeeds. What we really want to check
    is if the input is a number *from the beginning to the end*. Perhaps this sounds
    familiar, but it definitely smells like line anchors! The following code applies
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We made two changes: the search pattern we''re matching against is no longer
    just `[[:digit:]]`, but `^[[:digit:]]$`, and we updated the version number (something
    we haven''t done too much up until now). Because we are now anchoring the digit
    to both the beginning and the end of the line, we can no longer inject a letter
    in a random spot. Run the script with incorrect input to verify this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'I would love to tell you that we''re now perfectly safe. But, alas, as it often
    is with regular expressions, it''s not that simple. The script now works great
    for a single number (0–9), but if you try it with a double-digit number, it fails
    with `wrong type of argument error` (try it out!). We need one final tweak to
    make sure it does exactly what we want: we need to make sure that the digit also
    accepts multiple sequential digits. The *one or more* construct in regular expressions
    is the + sign, which we can just append to `[[:digit:]]`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We changed the pattern, upped the version number, and ran the script with different
    inputs. The final pattern of `^[[:digit:]]+$` can be read as *one or more digits
    from the start to the end of the line*, which, in this case, means *a number,
    and nothing else*!
  prefs: []
  type: TYPE_NORMAL
- en: The lesson here is that you really need to test your regular expressions thoroughly.
    As you know by now, search patterns are greedy, and as soon as a little bit matches,
    it considers the result a success. As seen in the previous example, this was not
    specific enough. The only way to implement (and learn!) this is by trying to break
    your own scripts. Try wrong input, weird input, very specific input, and so on.
    Unless you try a lot, you can't be sure that it will *probably* work.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use all regular expression search patterns in test syntax. Other examples
    that we will not flesh out, but should definitely be considered, are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The variable should start with a `/` (for a fully qualified path)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The variable cannot contain whitespace (using the `[[:blank:]]` search pattern)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The variable should contain only lowercase letters (achievable with the `^[[:lower:]]+$`
    pattern)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The variable should contain a file name with an extension (can match on `[[:alnum:]]\.[[:alpha:]]`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The elif condition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the scenarios we''ve seen up until now, there was only ever the need to
    check for one *if* *condition*. But as you might expect, sometimes, there are
    multiple things that you want to check for, each with their own sets of following
    actions (*then* *block*). You could solve this by using two full `if-then-else`
    statements, but at the very least you''d have a duplicate *else* *block*. Even
    worse, if you have three or more conditions you want to check for, you''ll have
    more and more duplicate code! Luckily for us, we can solve this by using the `elif`
    command, which is part of the `if-then-else` logic. As you''ve probably guessed,
    `elif` is short for `else-if`. It allows us to do something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: IF condition1, THEN do thing1, ELIF condition2, THEN do thing2, ELSE do final-thing
  prefs: []
  type: TYPE_NORMAL
- en: 'You can chain as many `elif` commands after the initial `if` command as you
    want, but there is one important thing to consider: as soon as any condition is
    true, only that `then` statement is executed; all others are skipped.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you''re thinking of a situation in which multiple conditions can be true,
    and their `then` statements should be executed, you need to use multiple `if-then-else`
    blocks. Let''s look at a simple example that first checks if the argument given
    by the user is a file. If it is, we print the file using `cat`. If this is not
    the case, we check if it is a directory. Should this be the case, we list the
    directory with `ls`. If this is also not the case, we''ll print an error message
    and exit with a non-zero exit status. Look at the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, when we''re dealing with file input by users, we need extra
    sanitation. We make sure to set the current working directory in the script with
    `cd $(dirname $0)`, and we assume that every command can fail, so we handle these
    failures with the || construct, as explained in [Chapter 9](125f46ad-bffc-4bf6-86e7-ae6a2ca47bb6.xhtml),* Error
    Checking and Handling*. Let''s try and see if we can find most of the paths that
    this logic can take:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In order, we''ve seen the following scenarios for our script:'
  prefs: []
  type: TYPE_NORMAL
- en: '**No argument**: `Incorrect usage` error'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**File argument /etc/passwd**: File content printed'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**File argument on non-readable file /etc/shadow**: `Cannot print file` error'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Directory argument /tmp/**: List of directory printed'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Directory argument on non-listable directory /root/**: `Cannot list directory`
    error'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Special file (block device) argument /dev/zero**: `Path is neither a file
    nor a directory` error'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: These six input scenarios represent all of the possible paths our script can
    take. While you might have considered all of the error handling for a (seemingly
    simple) script a bit over the top, these arguments should validate why we actually
    need all of this error handling.
  prefs: []
  type: TYPE_NORMAL
- en: While `elif` greatly enhances the possibilities of an `if-then-else` statement,
    too much `if-elif-elif-elif-`.......`-then-else` will make your script really
    hard to read. There is another construct (which is outside the scope of this book),
    called `case`. This deals with many different, unique conditions. Look at the
    further reading section at the end of this chapter for a good resource on `case`!
  prefs: []
  type: TYPE_NORMAL
- en: Nesting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another concept that is very interesting is nesting. In essence, nesting is
    really simple: it is placing another `if-then-else` statement within either the
    `then` or `else` of the *outer* `if-then-else`. This allows us to, for example,
    first determine if a file is readable, before determining what type of file it
    is. By using nested `if-then-else` statements, we can rewrite the previous code
    in such a way that we no longer need the || construct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Try the preceding script with the same input as the previous example. In this
    case, you''ll see much nicer output in the error scenarios, since we now control
    those (instead of the default output of `cat: /etc/shadow: Permission denied`
    from `cat`, for example). Functionally, however, nothing has changed! We think
    that this script, which uses nesting, is more readable than the previous example,
    because we handle the error scenarios ourselves now instead of relying on the
    system commands to do it for us.'
  prefs: []
  type: TYPE_NORMAL
- en: We've discussed indentation before, but in our opinion, scripts like this one
    are where it truly shines. By indenting the inner `if-then-else` statement, it
    is much more clear that the second `else` belongs to the outer `if-then-else`
    statement. If you're using multiple levels of indentation (because, in theory,
    you can nest as often as you'd like), it really helps everyone working on the
    script to follow this logic.
  prefs: []
  type: TYPE_NORMAL
- en: Nesting is not just reserved for `if-then-else`. The two loops that we will
    introduce later in this chapter, `for` and `while`, can also be nested. And, what's
    even more practical, you can nest all of them within all of the others (from a
    technical perspective; it should make sense from a logical perspective as well,
    of course!). You will see examples of this when we explain `while` and `for` later.
  prefs: []
  type: TYPE_NORMAL
- en: Getting help
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By now, you''re probably afraid that you''ll never remember all this. While
    we''re sure that in time, given enough practice, you most certainly will, we understand
    that it is a lot to take in when you''re not as experienced. To make this easier,
    there is another helpful command besides the `man` pages. As you might have found
    (and failed when you tried), `man if`, or `man [[`, do not work. If you check
    these commands with `type if` and `type [[`, you''ll actually see that they are
    not commands but *shell keywords*. For most of the shell builtins and shell keywords,
    you can use the `help` command to print some information on what they do and how
    to use them! Using `help` is as simple as `help if`, `help [[`, `help while`,
    and so on. For `if-then-else` statements, only `help if` works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'So, overall, there are three ways to get Linux to print some helpful information
    for you:'
  prefs: []
  type: TYPE_NORMAL
- en: Man pages with the `man` command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Help information with the `help` command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Command native help print (often as `flag -h`, `--help`, or `-help`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Depending on the type of command (binary or shell builtin/keyword), you'll use
    either `man`, `help`, or the `--help` flag. Remember, by checking which type of
    command you're dealing with (so that you can make a more educated guess about
    which method of help you can try first), use `type -a <command>`.
  prefs: []
  type: TYPE_NORMAL
- en: The while loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we''ve got the `if-then-else` recap and advanced usage out of the
    way, it is time to discuss the first scripting loop: `while`. Look at the following
    definition, which should seem familiar after `if-then-else`:'
  prefs: []
  type: TYPE_NORMAL
- en: WHILE condition-is-true DO thing-to-do DONE
  prefs: []
  type: TYPE_NORMAL
- en: 'The biggest difference between `if` and `while` is that while will perform
    the action many times, so long as the condition specified is still true. Because
    it is often not needed to have an unending loop, the action will regularly mutate
    something related at the condition. This basically means that the action in *do*
    will eventually cause the while condition to be false instead of true. Let''s
    look at a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This example is the most basic form of while: an unending loop (because the
    condition is simply `true`) that prints a message and then sleeps for one second.
    This new command, `sleep`, is often used within loops (both `while` and `for`)
    to wait for a specified time. In this case, we run `sleep 1`, which waits a single
    second before going back to the top of the loop and printing `Hello!` again. Be
    sure to try it out and notice how it will never stop (*Ctrl* + *C* will, however,
    kill the process, since it''s interactive).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we''ll create a script that will end at certain time. To do this, we''ll
    define a variable outside of the `while` loop, which we will use as a counter.
    This counter will be incremented at each run of the `while` loop, until the threshold
    defined in the condition is reached. Take a look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This script should be self-explanatory because of the comments we''ve added.
    `counter` is added outside the `while` loop, because otherwise every run of the
    loop would start with `counter=0`, which would reset the progress. As long as
    the counter is less than 10, we''ll keep running the loop. After 10 runs, this
    is no longer the case, and instead of going back in the loop, we''re going to
    the next instruction in the script, which is printing the goodbye message. Go
    ahead and run this script. Edit the number after sleep (hint: it also accepts
    values smaller than a second), or remove sleep altogether.'
  prefs: []
  type: TYPE_NORMAL
- en: The until loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While has a twin: `until`. An `until` loop does exactly what while does, with
    only one difference: the loop only runs as long as the condition is **false**.
    As soon as the condition becomes **true**, the loop no longer runs. We''ll make
    some minor changes to the previous script and we''ll see how `until` works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the changes to this script are very minimal (but important,
    nonetheless). We replaced `while` with `until`, `-lt` with `-gt`, and `10` with
    `9`. Now, it reads `run the loop until the counter is greater than 9` as opposed
    to `run the loop as long as the counter is lower than 10`. Because we are using
    lower than and greater than, we have to change the number, otherwise we're going
    to experience the famous *off-by-one* error (which, in this case, means that we'll
    loop 11 times, should we not have changed the `10` to a `9`; try it!).
  prefs: []
  type: TYPE_NORMAL
- en: 'In essence, the `while` and `until` loops are exactly the same. You will use
    a `while` loop more often than an until loop: since you can just negate the condition,
    a `while` loop will always work. However, sometimes, an `until` loop might *feel*
    more justified. In any case, use the one that is easiest to comprehend for the
    situation! When in doubt, just using `while` will hardly ever be wrong, as long
    as you get the condition right.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating an interactive while loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In reality, you will not use a `while` loop that often. In most scenarios,
    a `for` loop is better (as we will see later on in this chapter). There is, however,
    one situation where a `while` loop is excellent: dealing with user input. If you
    use the `while true` construct with an if-then-else block nesting within it, you
    can keep asking the user for input until you get the answer you''re looking for.
    The following example, which is a simple riddle, should clarify matters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In this script, we use `read -p` to ask the user a question, and we store the
    reply in the `answer` variable. We then use a nested if-then-else block to check
    if the user gave the correct answer. We use a simple regular expression if-condition,
    `${answer} =~ [Kk]eyboard`, which gives a little flexibility to the user with
    regards to capitals and perhaps the word `a` in front. For every incorrect answer,
    the *else* statement prints an error and the loop starts back at `read -p`. If
    the answer is correct, the *then* block is executed, which ends with `exit 0`
    to signify the end of the script. As long as the correct answer isn't given, the
    loop will go on forever.
  prefs: []
  type: TYPE_NORMAL
- en: You might see a problem with this script. If we wanted to do anything after
    the `while` loop, we'd need to *break* out of it without exiting the script. We
    will see how we can achieve this with the – wait for it – `break` keyword! But
    first, we'll check out the `for` loop.
  prefs: []
  type: TYPE_NORMAL
- en: The for loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `for` loop can be considered the more powerful loop in Bash scripting. In
    practice, `for` and `while` are interchangeable, but `for` has better shorthand
    syntax. This means that to write a loop in `for` often requires much less code
    than an equivalent `while` loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `for` loop has two different syntaxes: a C-style syntax and the `regular` Bash
    syntax. We''ll first look at the Bash syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: FOR value IN list-of-values DO thing-with-value DONE
  prefs: []
  type: TYPE_NORMAL
- en: 'A `for` loop allows us to *iterate* over a list of things. Each loop will use
    a different item in that list, in a sequential order. This very simple example
    should illustrate this behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, `for` takes a list (in this case, a string delimited by whitespace),
    and for each value it finds it performs the `echo` action. We've added some extra
    text there so that you can see that it actually goes into the loop four times
    and does not just print the list with extra new lines. The main thing to notice
    here is that in the echo we use the `${word}` variable, which we defined as the
    second word in the `for` definition. This means that for every run of the `for`
    loop, the value of the `${word}` variable is different (which is very much using
    a variable as it is intended, with a *variable* content!). You can name this anything,
    but we prefer to give semantically logical names; since we called our list *words*,
    an item in that list would be a *word*.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to do the same thing with `while`, things are going to get a lot
    more complicated. It's definitely possible by using a counter and a command such
    as `cut` (which allows you to cut out different parts of a string), but since
    the `for` loop does it in this simple manner, why bother?
  prefs: []
  type: TYPE_NORMAL
- en: 'The second syntax that we can use with for will be more recognizable for those
    experienced with other scripting programming languages. This C-style syntax uses
    a counter that increments until a certain point, not unlike the example we saw
    when we looked at `while`. The syntax is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Seems pretty similar right? Check out this example script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Again, due to the nature of off-by-one errors, we have to use slightly different
    numbers. Since the counter is incremented *at the end of the loop*, we need to
    start it at 1 instead of 0 (or we could have done the same in the while loop).
    In C-style syntax, **<=** means *smaller than or equal to*, and ++ means *increment
    by 1*. So, we have a counter that starts at 1, continues until it reaches 10,
    and is incremented by 1 for each run of the loop. We find this `for` loop preferable
    to the equivalent while loop; it needs less code and is more common in other scripting/programming
    languages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even better, there is a way to iterate over a number range (as we did for 1–10
    previously), with the for loop Bash syntax as well. Because a number range is
    nothing more than a *list of numbers*, we can use almost the same syntax as we
    did in the first example, in which we iterated over a *list of words*. Take a
    look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'So, the syntax for `<variable>` in `<list>` works with a list of `{1..10}`.
    This is called **brace expansion** and was added in Bash version 4\. The syntax
    for brace expansion is quite simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Brace expansion can be used in many ways, but printing lists of numbers or
    characters is the most well-known:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The brace expansion `{1..5}` returns the string `1 2 3 4 5`, which is a whitespace
    delimited list of values and can thus be used in the Bash-style `for` loop! Alternatively,
    `{a..f}` prints the string `a b c d e f`. The range is actually determined by
    ASCII hexadecimal codes; this allows us to do the following as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: It might seem weird that you'll see some special characters printed halfway,
    but those are in-between the uppercase and lowercase Latin alphabet characters.
    Note that this syntax is very similar to getting the value of a variable with
    `${variable}` (however, that is parameter expansion and not brace expansion).
  prefs: []
  type: TYPE_NORMAL
- en: 'The brace expansion has one other interesting piece of functionality: it allows
    us to define the increment! Simply put, this allows us to tell Bash how many steps
    to skip each time we increment. The syntax for this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, the increment value is 1\. If this is the desired functionality,
    we can omit the increment value, as we previously saw. If we do set it, however,
    we''ll see something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Now, the increment is done in steps of 10\. As you can see in the previous example,
    the `<ending value>` is considered *inclusive*. This means that values that are
    *lower or equal* will be printed, but others will not. The next value in the first
    brace expansion in the preceding example. `{1..100..10}`, would have been 101;
    since this is not lower or equal to 100, the value is not printed and the expansion
    is terminated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, since we promised that anything we could do with `while` we could
    also do with `for`, we''d like to end this part of the chapter by showing you
    how you would create an infinite loop with `for`. This is the most common reason
    to choose `while` over `for`, because the `for` syntax is a little weird:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We use the C-style syntax, but we omit the initialization, comparison, and
    incrementing of the counter. Therefore, it reads as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: for ((<nothing>;<no-comparison>;<no-increment>)); do
  prefs: []
  type: TYPE_NORMAL
- en: This ends up as `((;;));`, which only makes sense if you put it in the context
    of the normal syntax, as we did in the previous example. We could also just omit
    either the increment or the comparison to the same effect, but that would do the
    same thing with more code. Often, shorter is better, since it will be clearer.
  prefs: []
  type: TYPE_NORMAL
- en: Try to replicate the infinite `for` loop, but only by omitting a single value
    from the `for` clause. If you get that working, you'll be a step closer to understanding
    why you have now made it unending. If you need a little nudge, perhaps you'd want
    to echo the value of `counter` in the loop so that you can see what is happening.
    Or you could always run it with `bash -x`, of course!
  prefs: []
  type: TYPE_NORMAL
- en: Globbing and the for loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s look at a few more practical examples. Most things you will do
    on Linux will deal with files (remember why?). Imagine that you have a bunch of
    log files sitting on the server and you''d like to perform some actions on them.
    If it is just a single action with a single command, you can most probably use
    a globbing pattern with that command (such as with `grep -i ''error'' *.log`).
    However, imagine a situation where you want to collect log files that contain
    a certain phrase, or perhaps only the lines from those files. In this case, using
    a globbing pattern in combination with a `for` loop will allow us to perform many
    commands on many files, which we can find dynamically! Let''s give it a go. Because
    this script will combine many of the lessons we''ve covered so far, we''ll begin
    simple and expand it gradually:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'By using the `$(ls /var/log/*.log)` construct, we can create a list of all
    files that end in `.log` that are found in the `/var/log/` directory. If you manually
    run the `ls /var/log/*.log` command, you will notice that the format is the same
    as the others we''ve seen when used in the Bash-style for syntax: single words,
    whitespace delimited. Because of this, we can now manipulate all of the files
    we found in order! Let''s see what happens if we try to grep in these files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we changed the content of the script, we''ve upped the version from `v1.0.0`
    to `v1.1.0`. If you run this script now, you''ll see that some of files return
    a positive match on the grep, while others do not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Great, so now we''ve accomplished the same thing with a complicated for loop
    that we could have also done directly with `grep`! Now, let''s get our money''s
    worth and do something with the files after we''ve determined that they contain
    the word `error`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The next version, `v1.2.0`, does a quiet `grep` (no output, since we just want
    the exit status of 0 when something is found). Directly after the `grep`, we use
    a nested `if-then` to copy the files to an archive directory that we defined at
    the beginning of the script. When we run the script now, we can see the same files
    that generated output in the previous version of the script, but now it copies
    the entire file. At this point, the `for` loop is proving its value: we''re now
    doing multiple operations on a single file that was found with the globbing pattern.
    Let''s take this one step further and remove all of the lines that do not contain
    an error from the archived files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Version v1.3.0! To keep it a little readable, we have not included error checking
    on the `cp` and `mkdir` commands. However, due to the nature of this script (creating
    a subdirectory in `/tmp/` and copying files there), the chance of issues there
    is very slim. We added two new interesting things: a new variable called `file_new_location`
    with the file name of the new location and `sed`, which ensures only the error
    lines remain in the archived files.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s consider `file_new_location=${ERROR_DIRECTORY}$(basename ${file})`.
    What we''re doing is pasting together two strings: first, the archive directory,
    followed by the *basename of the processed file.* The `basename` command strips
    the fully qualified path of a file, and only leaves the file name at the leaf
    of the path intact. If we were to look at the steps that Bash will undertake to
    resolve this new variable, it would probably look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`file_new_location=${ERROR_DIRECTORY}$(basename ${file})`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-> resolve ${file}`'
  prefs: []
  type: TYPE_NORMAL
- en: '`file_new_location=${ERROR_DIRECTORY}$(basename /var/log/bootstrap.log)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-> resolve $(basename /var/log/bootstrap.log)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`file_new_location=${ERROR_DIRECTORY}bootstrap.log`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-> resolve ${ERROR_DIRECTORY}`'
  prefs: []
  type: TYPE_NORMAL
- en: '`file_new_location=/tmp/error_logfiles/bootstrap.log`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-> done, final value of variable!`'
  prefs: []
  type: TYPE_NORMAL
- en: 'With that out of the way, we can now run `sed` on that new file. The `sed --quiet
    --in-place ''/[Ee]rror/p'' ${file_new_location}` command simply replaces the content
    of the file with all lines that match the regular expression search pattern of
    `[Ee]rror`, which is (almost) what we initially grepped for. Remember, we need `--quiet`
    because, by default, `sed` prints all lines. If we were to omit this, we would
    end up with all of the lines in the file, but all of the error files would be
    duplicated: once from the non-quiet output of `sed`, and once from the search
    pattern match. However, with --quiet active, `sed` only prints the matching lines
    and writes those to the files. Let''s see this in practice and verify the outcome:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the three lines at the top of each file all contain the `error`
    or `Error` string. Actually, all of the lines in all of those files contained
    either of those strings; be sure to verify this on your own system since the content
    will undoubtedly be different.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''ve finished this example, we have a few challenges for the reader,
    should you like to take them on:'
  prefs: []
  type: TYPE_NORMAL
- en: Make this script accept input. This could be the archive directory, the path
    glob, the search pattern, or even all three!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make this script more robust by adding exception handling to commands that *could*
    fail.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Invert the functionality of this script, by using the `sed ''/xxx/d''` syntax
    (hint: you''ll probably need redirection for this).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While this example should illustrate a lot of things, we realize that just searching
    on the word `error` does not actually only return errors. Actually, most of what
    we saw being returned was related to an installed package, `liberror`! In practice,
    you might be working with log files that have a predefined structure when it comes
    to errors. In this case, it is much easier to determine a search pattern that
    only logs real errors.
  prefs: []
  type: TYPE_NORMAL
- en: Loop control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At this point, you should feel comfortable with using `while` and `for` loops.
    There is one more, rather important, topic to discuss with regards to loops: **loop
    control**. Loop control is a generic term, for anything that you do to, well,
    control the loop! However, there are two *keywords* that we''ll need if we want
    to unleash the full power of loops: `break` and `continue`. We''ll start with
    `break`.'
  prefs: []
  type: TYPE_NORMAL
- en: Breaking the loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For some scripting logic, it will prove necessary to break out of the loop.
    You might imagine that, in one of your scripts, you are waiting for something
    to finish. As soon as that happens, you want to *do something*. Waiting and periodically
    checking inside a `while true` loop could be an option for this, but if you recall
    in the `while-interactive.sh` script, we exited on the successful answer to the
    riddle. On an exit, we cannot run any more commands that are outside of the `while`
    loop! This is where `break` comes into play. It allows us to exit the *loop*,
    but continue the *script*. First, let''s update `while-interactive.sh` to make
    use of this loop control keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We made three changes:'
  prefs: []
  type: TYPE_NORMAL
- en: Adopted a higher version number
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Replaced `exit 0` with `break`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added a simple `echo` after the while loop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When we still had `exit 0` in place, the final `echo` would never have run
    (but don''t trust us, be sure to verify this yourself!). Now, run it with `break`
    and watch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: There we go, code execution after a broken `while` loop. Often, after an infinite
    loop, there is definitely other code that needs to be executed, and this is the
    way to do it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use `break` not only in a `while` loop, but most certainly in a `for`
    loop. The following example shows how we can use `break` in a `for` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'At the top of this script''s functionality, a random number between 1 and 10
    is determined (don''t worry about the syntax). Next, we iterate over the numbers
    1 through 10 and for each number, we''ll check if it''s equal to the randomly
    generated number. If it is, we print a success message *and we break the loop*.
    Otherwise, we''re going outside of the `if-then` block and printing the failure
    message. If we did not include the break statement, the output would look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Not only do we see the number printed as both matching and non-matching (which
    is a logical error, of course), but the script also continues checking all other
    numbers when we''re certain that those will not match. Now, if we used exit instead
    of break, the final statement will never be printed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Only by using `break` will we get exactly the amount of output we need; nothing
    more and nothing less. You might have seen that we could have also used an `else`
    clause for the `Number does not match:` message. Still, nothing would be stopping
    the program. So even if the random number was found on the first try (which will
    happen, eventually), it will still compare all of the values in the list until
    it reaches the end of that list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Not only is this a waste of time and resources, but imagine the output if the
    random number was somewhere between 1 and 1,000,000! Just remember: if you''re
    done with the loop, **break out of it.**'
  prefs: []
  type: TYPE_NORMAL
- en: The continue keyword
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As with most things in Bash (and life), there is a Yang to the Yin that is
    `break`: the `continue`  keyword. If you use continue, you''re telling the loop
    to stop the current loop, but *continue* with the next run. So, instead of stopping
    the entire loop, you''ll just stop the current iteration. Let''s see if another
    example can make this clear:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, all of the numbers that can be divided cleanly by 5 are considered
    unlucky and should not be processed. This is achieved by the `[[ $((${number}%5))
    -eq 0 ]]` condition:'
  prefs: []
  type: TYPE_NORMAL
- en: '**[[** $((${number}%5)) **-eq 0 ]]** -> test syntax'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[[ **$((**${number}%5**))** -eq 0 ]] -> arithmetic syntax'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[[ $((**${number}%5**)) -eq 0 ]] -> modulo 5 of the variable **number**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If the number passes this test (and is thus cleanly divisible by 5, such as
    5, 10, 15, 20, and so on), `continue` is executed. When this happens, the next
    iteration of the loop is run (and `echo` is **NOT** executed!), as can be seen
    when running this script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'As the list should imply, the numbers `5`, `10`, and `15` are processed, but
    we do not see them in `echo`. We can also see everything after, which would not
    have happened with `break`. Verify if this is actually happening with `bash -x`
    (warning: loads of output!) and check what happens if you replace `continue` with
    `break` or even `exit`.'
  prefs: []
  type: TYPE_NORMAL
- en: Loop control and nesting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For the final part of this chapter, we''d like to show you how you can influence
    `nested` loops with loop control as well. Both break and continue will take an
    extra argument: a number that specified which loop to break out of. By default,
    if this argument is omitted, it is assumed to be `1`. So, the `break` command
    is equal to `break 1`, and `continue 1` is the same as `continue`. As stated before,
    we can theoretically nest our loops as deep as we want; you''re likely to hit
    logical issues a lot earlier than problems with the technical capabilities of
    your modern system! We''ll look at a simple example that shows us how we can use
    a `break 2` to not only break out of a `for` loop, but out of the outer `while`
    loop as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'This first version of the script does not contain `break`. When we run this,
    we never see the final message and we get an endless repeating pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s break the inner loop when the iteration hits `2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run the script now, we still get infinite loops, but we''re cutting
    the inner for loop short after two iterations instead of three:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s instruct the inner loop to break out of the outer loop by using
    the `break 2` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Behold, an inner loop breaking out of an outer loop successfully:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: There we go, full control over our loops, even when we nest as many as we need
    for our scripting needs. The same theory applies to `continue` as well. If, in
    this example, we use `continue 2` instead of `break 2`, we would still get an
    infinite loop (since while true never ends). However, if your other loop was also
    a `for` or a non-infinite `while` loop (which, in our experience, is more common
    but does not make for a great simple example), `continue 2` could allow you to
    execute exactly the logic that the situation desires.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter was dedicated to conditional testing and scripting loops. Since
    we had already discussed the `if-then-else` statements, we recapped on this information
    before going on to showing more advanced uses of the conditional testing toolkit.
    This advanced information included using regular expressions, which we learned
    about in the previous chapter, within a conditional testing scenario to allow
    for more flexible tests. We also showed you how multiple conditions can be tested
    sequentially, using `elif` (short for `else if`). We explained how multiple `if-then-else`
    statements can be nested to create advanced logic.
  prefs: []
  type: TYPE_NORMAL
- en: In the second part of this chapter, we introduced the `while` loop. We showed
    you how we can use this to create a script that will run indefinitely, or how
    we can use conditions to stop the loop when a certain criteria has been met. We
    presented the `until` keyword, which has the same functionality as `while` but
    allows for negative checking instead of positive for `while`. We ended the explanation
    on `while` by showing you how an interactive script can be created in an unending
    `while` loop (using our old friend `read`).
  prefs: []
  type: TYPE_NORMAL
- en: After `while`, we introduced the more powerful `for` loop. This loop can do
    the same things `while` can, but often the shorter syntax allows us to write less
    code (and more readable code, which is still a very important aspect in scripting!).
    We showed you how `for` can iterate over a list, and how we can create a list
    of numbers using *brace expansion*. We ended our discussion on `for` loops by
    giving a practical example of combining `for` with file globbing patterns to allow
    us to dynamically find, grab, and process files.
  prefs: []
  type: TYPE_NORMAL
- en: We ended this chapter by explaining loop control, which is achieved in Bash
    with the `break` and `continue` keywords. These keywords allows us to *break*
    out of a loop (even from nested loops, as far back outside as we need), and also
    allow us to stop the current iteration of the loop and *continue* to the next
    iteration.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following commands/keywords were introduced in this chapter: `elif`, `help`, `while`,
    `sleep`, `for`, `basename`, `break`, and `continue`.'
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How does an `if-then`(`-else`) statement end?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can we use regular expression search patterns in a conditional evaluation?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why do we need the `elif` keyword?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is *nesting*?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can we get information about how to use shell builtins and keywords?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the opposite keyword of `while`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why would we choose the for loop over the `while` loop?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is brace expansion and on which characters can we use it?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which two keywords allow us to have more granular control over loops?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If we are nesting loops, how can we employ loop control to influence outer loops
    from an inner loop?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following resources might be interesting if you''d like to go deeper into
    the subjects of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The case** **statement**: [http://tldp.org/LDP/Bash-Beginners-Guide/html/sect_07_03.html](http://tldp.org/LDP/Bash-Beginners-Guide/html/sect_07_03.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Brace expansions**: [http://wiki.bash-hackers.org/syntax/expansion/brace](http://wiki.bash-hackers.org/syntax/expansion/brace)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The Linux Documentation Project on loops**: [http://www.tldp.org/LDP/abs/html/loops1.html](http://www.tldp.org/LDP/abs/html/loops1.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
