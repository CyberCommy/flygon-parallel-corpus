- en: Botnet Detection with Machine Learning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nowadays, connected devices play an important role in modern life. From smart
    home appliances, computers, coffee machines, and cameras, to connected cars, this
    huge shift in our lifestyles has made our lives easier. Unfortunately, these exposed
    devices could be attacked and accessed by attackers and cyber criminals who could
    use them later to enable larger-scale attacks. Security vendors provide many solutions
    and products to defend against botnets, but in this chapter, as we did in previous
    chapters, we are going to learn how to build novel botnet detection systems with
    Python and machine learning techniques.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will see:'
  prefs: []
  type: TYPE_NORMAL
- en: An overview of botnets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to build a botnet detector with different machine learning algorithms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to build a Twitter bot detector
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will find all the code discussed, in addition to some other useful scripts,
    in the following repository: [https://github.com/PacktPublishing/Mastering-Machine-Learning-for-Penetration-Testing/tree/master/Chapter5](https://github.com/PacktPublishing/Mastering-Machine-Learning-for-Penetration-Testing/tree/master/Chapter5).
  prefs: []
  type: TYPE_NORMAL
- en: Botnet overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Botnet is a combination of the two terms **bot** and **net**. The bot part
    represents the fact that this malware automates things and tasks like a robot.
    The second part refers to a network, in other words, a network of compromised
    devices. So, by definition, a botnet is a form of malware that attacks computers
    on the internet and controls them with command and control servers to perform
    a wide variety of automated tasks, including sending spam emails and performing **Distributed
    Denial of Service** (**DDoS**) attacks. Attacked machines join an immense network
    of compromised machines. One of the most notable botnets in previous years was
    the *Mirai botnet*. Mirai means *the future* in Japanese. This botnet hit millions
    of online devices, especially **Internet of Things** (**IoT**) appliances, by
    scanning and identifying vulnerable machines, taking advantage of the fact that
    most of them are accessed using default login credentials. Some of the tasks performed
    by botnets are:'
  prefs: []
  type: TYPE_NORMAL
- en: Advertising fraud and sending spam emails
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cryptocurrency mining
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stealing personal data and sensitive information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing DDoS attacks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing brute force attacks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram describes the different actors of a botnet ecosystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00116.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Hacking is a methodological task. Criminals and cyber attackers usually use
    the same defined steps. As you are penetration testers and information security
    professionals, you are aware of the hacking phases, which are information gathering,
    or what we call reconnaissance; scanning; gaining access; maintaining access;
    and finally clearing tracks. Thus, botnets usually respect some defined steps.
    Botnets work based on four different phases:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Infection**: In this phase, the attackers infect the targeted machines by
    sending the malware.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Connection**: In this phase, the botnet initiates an internet connection
    with the control and command server to receive the commands and automated tasks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Control**: In this phase, the attack occurs, for example, sending spam emails.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Multiplication**: In this phase, the botnet will try to compromise more machine
    to join them in the network and become what we call **zombies**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/00117.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Building a botnet detector model with multiple machine learning techniques
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to learn how to build different botnet detection
    systems with many machine learning algorithms. As a start to a first practical
    lab, let's start by building a machine learning-based botnet detector using different
    classifiers. By now, I hope you have acquired a clear understanding about the
    major steps of building machine learning systems. So, I believe that you already
    know that, as a first step, we need to look for a dataset. Many educational institutions
    and organizations are given a set of collected datasets from internal laboratories.
    One of the most well known botnet datasets is called the **CTU-13** dataset. It
    is a labeled dataset with botnet, normal, and background traffic delivered by
    CTU University, Czech Republic. During their work, they tried to capture real
    botnet traffic mixed with normal traffic and background traffic. To download the
    dataset and check out more information about it, you can visit the following link: [https://mcfp.weebly.com/the-ctu-13-dataset-a-labeled-dataset-with-botnet-normal-and-background-traffic.html](https://mcfp.weebly.com/the-ctu-13-dataset-a-labeled-dataset-with-botnet-normal-and-background-traffic.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'The dataset is bidirectional NetFlow files. But what are bidirectional NetFlow
    files? Netflow is an internet protocol developed by Cisco. The goal of this protocol
    is to collect IP traffic information and monitor network traffic in order to have
    a clearer view about the network traffic flow. The main components of a NetFlow
    architecture are a **NetFlow Exporter**, a **Netflow collector**, and a **Flow
    Storage**. The following diagram illustrates the different components of a NetFlow
    infrastructure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00118.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'When it comes to NetFlow generally, when host A sends an information to **host
    B** and from **host B** to **host A** as a reply, the operation is named unidirectional
    NetFlow. The sending and the reply are considered different operations. In bidirectional
    NetFlow, we consider the flows from **host A** and **host B** as one flow. Let''s
    download the dataset by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00119.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Extract the downloaded `tar.bz2` file by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00120.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The file contains all the datasets, with the different scenarios. For the demonstration,
    we are going to use dataset 8 (scenario 8). You can select any scenario or you
    can use your own collected data, or any other `.binetflow` files delivered by
    other institutions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00121.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Load the data using pandas as usual:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Exploring the data is essential in any data-centric project. For example, you
    can start by checking the names of the features or the columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The command results in the columns of the dataset: `StartTime`, `Dur`, `Proto`,
    `SrcAddr`, `Sport`, `Dir`, `DstAddr`, `Dport`, `State`, `sTos`, `dTos`, `TotPkts`,
    `TotBytes`, `SrcBytes`, and `Label`. The columns represent the features used in
    the dataset; for example, `Dur` represents duration, `Sport` represent the source
    port, and so on. You can find the full list of features in the chapter''s GitHub
    repository.'
  prefs: []
  type: TYPE_NORMAL
- en: Before training the model, we need to build some scripts to prepare the data.
    This time, we are going to build a separate Python script to prepare data, and
    later we can just import it into the main script.
  prefs: []
  type: TYPE_NORMAL
- en: 'I will call the first script `DataPreparation.py`. There are many proposals
    done to help extract the features and prepare data to build botnet detectors using
    machine learning. In our case, I customized two new scripts inspired by the data
    loading scripts built by *NagabhushanS*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'After importing the required Python packages, we created a class called `Prepare`
    to select training and testing data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The second script is called `LoadData.py`. You can find it on GitHub and use
    it directly in your projects to load data from `.binetflow` files and generate
    a `pickle` file.
  prefs: []
  type: TYPE_NORMAL
- en: Let's use what we developed previously to train the models. After building the
    data loader and preparing the machine learning algorithms that we are going to
    use, it is time to train and test the models.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, load the data from the `pickle` file, which is why we need to import
    the `pickle` Python library. Don''t forget to import the previous scripts using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Select the data sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00122.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'As machine learning classifiers, we are going to try many different algorithms
    so later we can select the best algorithm for our model. Import the required modules
    to use four machine learning algorithms from `sklearn`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Prepare the data by using the previous module build. Don''t forget to import
    `DataPreparation` by typing `import DataPreparation`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can train the models; and to do that, we are going to train the model
    with different techniques so later we can select the most suitable machine learning
    technique for our project. The steps are like what we learned in previous projects:
    after preparing the data and selecting the features, define the machine learning
    algorithm, fit the model, and print out the score after defining its variable.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As machine learning classifiers, we are going to test many of them. Let''s
    start with a decision tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Decision tree model**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00123.gif)'
  prefs: []
  type: TYPE_IMG
- en: The score of the decision tree classifier is 99%
  prefs: []
  type: TYPE_NORMAL
- en: '**Logistic regression model**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00124.gif)'
  prefs: []
  type: TYPE_IMG
- en: The score of the logistic regression classifier is 96%
  prefs: []
  type: TYPE_NORMAL
- en: '**Gaussian Naive Bayes model**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00125.gif)'
  prefs: []
  type: TYPE_IMG
- en: The score of the Gaussian Naive Bayes classifier is 72%
  prefs: []
  type: TYPE_NORMAL
- en: '**k-Nearest Neighbors model**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00126.gif)'
  prefs: []
  type: TYPE_IMG
- en: The score of the k-Nearest Neighbors classifier is 96%
  prefs: []
  type: TYPE_NORMAL
- en: '**Neural network model**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To build a Neural network Model use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: With this code, we imported the required Keras modules, we built the layers,
    we compiled the model with an SGD optimizer, we fit the model, and we printed
    out the score of the model.
  prefs: []
  type: TYPE_NORMAL
- en: How to build a Twitter bot detector
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous sections, we saw how to build a machine learning-based botnet
    detector. In this new project, we are going to deal with a different problem instead
    of defending against botnet malware. We are going to detect Twitter bots because
    they are also dangerous and can perform malicious actions. For the model, we are
    going to use the *NYU Tandon Spring 2017 Machine Learning Competition: Twitter
    Bot classification* dataset. You can download it from this link: [https://www.kaggle.com/c/twitter-bot-classification/data](https://www.kaggle.com/c/twitter-bot-classification/data). Import
    the required Python packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s load the data using pandas and highlight the bot and non-bot data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00127.gif)'
  prefs: []
  type: TYPE_IMG
- en: Visualization with seaborn
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In every project, I want to help you discover new data visualization Python
    libraries because, as you saw, data engineering and visualization are essential
    to every modern data-centric project. This time, I chose seaborn to visualize
    the data and explore it before starting the training phase. Seaborn is a Python
    library for making statistical visualizations. The following is an example of
    generating a plot with seaborn:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00128.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'For example, in our case, if we want to identify the missing data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00129.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The previous two code snippets were some examples to learn how to visualize
    data. Visualization helps data scientists to explore and learn more about the
    data. Now, let's go back and continue building our model.
  prefs: []
  type: TYPE_NORMAL
- en: 'Identify the bag of words by selecting some bad words used by Twitter bots.
    The following is an example of bad words used by a bot. Of course, you can add
    more words:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, it is time to identify training features:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Feature extraction: Let''s select `features` to use in our model:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, train the model with a decision tree classifier:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We import some previously discussed modules:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We define the classifier:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We split the classifier:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We fit the model:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We print out the accuracy scores:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Our model detects Twitter bots with an 88% detection rate, which is a good accuracy
    rate.
  prefs: []
  type: TYPE_NORMAL
- en: This technique is not the only possible way to detect botnets. Researchers have
    proposed many other models based on different machine learning algorithms, such
    as Linear SVM and decision trees. All these techniques have an accuracy of 90%.
    Most studies showed that feature engineering was a key contributor to improving
    machine learning models.
  prefs: []
  type: TYPE_NORMAL
- en: To study a real-world case, check out a paper called *What we learn from learning
    - Understanding capabilities and limitations of machine learning in botnet attacks*
    ([https://arxiv.org/pdf/1805.01333.pdf](https://arxiv.org/pdf/1805.01333.pdf)),
    conducted by David Santana, Shan Suthaharan, and Somya Mohanty.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter was a lightweight guide to learning about botnet fundamentals and
    how to build a machine learning-based detector using different techniques. Also,
    we discussed how to identify Twitter bots. The next chapter will dive deep into
    anomalies and how to build many projects to identify anomalies using novel approaches.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we do after every chapter, we are going to give you the opportunity to practice
    what you learned and evaluate your skills. This chapter''s GitHub repository contains
    a link to a botnet traffic dataset in the `Practice` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: Download the dataset and load it with the pandas library
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select suitable features
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Identify the training and testing sets, then export them into a pickle file
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Load the pickle file
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import a support vector machine classifier and fit the model
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Train the SVM model
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Print out the accuracy of the model built
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To learn more about botnets and how to detect them with machine learning, I
    highly recommend you check out these useful external links:'
  prefs: []
  type: TYPE_NORMAL
- en: '**How botnets expand and how to protect against them:** [https://bitninja.io/blog/2016/01/11/how-botnets-expand-and-how-protect-against-them](https://bitninja.io/blog/2016/01/11/how-botnets-expand-and-how-protect-against-them)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Botnet basics – don''t become a zombie!**: [https://blog.trendmicro.com/botnet-basics/](https://blog.trendmicro.com/botnet-basics/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deep neural networks for bot detection**: [https://arxiv.org/abs/1802.04289](https://arxiv.org/abs/1802.04289)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Network-based Detection of IoT Botnet Attacks (N-BaIoT) using deep autoencoders**: [https://arxiv.org/abs/1805.03409](https://arxiv.org/abs/1805.03409)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A Hybrid Spectral Clustering and Deep Neural Network Ensemble Algorithm for
    Intrusion Detection in Sensor Networks** ([http://www.covert.io/research-papers/deep-learning-security/A%20Hybrid%20Spectral%20Clustering%20and%20Deep%20Neural%20Network%20Ensemble%20Algorithm%20for%20Intrusion%20Detection%20in%20Sensor%20Networks.pdf](http://www.covert.io/research-papers/deep-learning-security/A%20Hybrid%20Spectral%20Clustering%20and%20Deep%20Neural%20Network%20Ensemble%20Algorithm%20for%20Intrusion%20Detection%20in%20Sensor%20Networks.pdf)
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**An Analysis of Recurrent Neural Networks for Botnet Detection Behavior**
    ([http://www.covert.io/research-papers/deep-learning-security/An%20Analysis%20of%20Recurrent%20Neural%20Networks%20for%20Botnet%20Detection%20Behavior.pdf](http://www.covert.io/research-papers/deep-learning-security/An%20Analysis%20of%20Recurrent%20Neural%20Networks%20for%20Botnet%20Detection%20Behavior.pdf))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
