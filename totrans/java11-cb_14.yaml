- en: Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter shows how to test your application—how to capture and automate
    the testing of use cases, how to unit test your APIs before they are integrated
    with other components, and how to integrate all of the units. We will introduce
    you to **Behavior-Driven Development** (**BDD**) and show how it can become the
    starting point of your application development. We will also demonstrate how JUnit
    framework can be used for unit testing. Sometimes, during unit testing, we would
    have to stub dependencies with some dummy data, and this can be done by mocking
    the dependencies. We will show you how to do this using a mocking library. We
    will also show you how to write fixtures to populate test data and then how you
    can test the behavior of your application by integrating different APIs and testing
    them together. We will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Behavioral testing using Cucumber
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit testing of an API using JUnit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit testing by mocking dependencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using fixtures to populate data for testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integration testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Well-tested code provides peace of mind to the developer. If you get a feeling
    that writing a test for the new method you are developing is too much of an overhead,
    then you usually don't get it right the first time. You have to test your method
    anyway, and it is less time-consuming in the long run to set up or write a unit
    test than to build and start up the application many times—every time the code
    changes and for every logical pass through.
  prefs: []
  type: TYPE_NORMAL
- en: One of the reasons we often feel pressed for time is that we do not include
    in our estimates the time needed for writing the test. One reason is that we sometimes
    just forget to do it. Another reason is that we shy away from giving a higher
    estimate because we do not want to be perceived as not skilled enough. Whatever
    the reason, it happens. Only after years of experience, we learn to include tests
    in our estimates and earn enough respect and clout to be able to assert publicly
    that doing things right requires more time up front, but saves much more time
    in the long run. Besides, doing it right leads to a robust code with far less
    stress, which means a better quality of life overall.
  prefs: []
  type: TYPE_NORMAL
- en: Another advantage of testing early—before the main code is completed—is that
    the code weaknesses are discovered during the phase when fixing it is easy. If
    need be, you can even restructure code for better testability.
  prefs: []
  type: TYPE_NORMAL
- en: If you are still not convinced, make note of the date when you read this and
    check back every year until this advice becomes obvious to you. Then, please share
    your experiences with others. This is how humanity makes progress—by passing knowledge
    from one generation to the next.
  prefs: []
  type: TYPE_NORMAL
- en: Methodologically, the content of this chapter is applicable to other languages
    and professions too, but the examples are written primarily for Java developers.
  prefs: []
  type: TYPE_NORMAL
- en: Behavioral testing using Cucumber
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are three recurring complaints of programmers:'
  prefs: []
  type: TYPE_NORMAL
- en: Lack of requirements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ambiguity of requirements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Requirements are changing all the time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are quite a few recommendations and processes that help alleviate these
    problems, but none of them were able to eliminate them completely. The most successful,
    in our opinion, was an agile process methodology in conjunction with BDD, using
    Cucumber or another similar framework. Short iterations allow quick adjustment
    and coordination between businesses (customers) and programmers, while BDD with
    Cucumber captures the requirements in a formal language called Gherkin, but without
    the overhead of maintaining extensive documentation.
  prefs: []
  type: TYPE_NORMAL
- en: The requirements written in Gherkin have to be broken into **features**. Each
    feature is stored in a file with a `.feature` extension and consists of one or
    more **scenarios** that describe different aspects of the feature. Each scenario
    consists of steps that describe user actions or just input data and how the application
    responds to it.
  prefs: []
  type: TYPE_NORMAL
- en: A programmer implements the necessary application functionality and then uses
    it to implement the scenarios in one or many `.java` files. Each step is implemented
    in a method.
  prefs: []
  type: TYPE_NORMAL
- en: After their implementation, the scenarios become a suite of tests that can be
    as fine-grained as a unit test or as high-level as an integration test, and anything
    in between. It all depends on who writes the scenario and how the application
    code is structured. If the authors of the scenarios are business folk, the scenarios
    tend to be higher-level use cases. But if the application is structured so that
    each scenario (with possibly multiple permutations of input data) is implemented
    as a method, then it serves effectively as a unit test. Alternatively, if a scenario spans
    several methods or even subsystems, it can serve as an integration test, while
    programmers may complement it with finer-grained (more unit test-like) scenarios. Later,
    after the code is delivered, all the scenarios can serve as regression tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'The price you pay is an overhead of the scenarios, maintenance, but the reward
    is the formal system that captures the requirements and provides an assurance
    that the application does exactly what is required. That said, one qualification
    is in order: capturing scenarios for the UI layer is usually more problematic
    because the UI tends to change more often, especially at the beginning of application
    development. Yet, as soon as UI has stabilized, the requirements to it can also
    be captured in Cucumber scenarios using Selenium or a similar framework.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Install Cucumber. The Cucumber installation is nothing more than adding the
    framework to the project as a Maven dependency. Since we are going to add several
    Cucumber JAR files and all of them have to be of the same version, it makes sense
    to add the `cucumber.version` property in `pom.xml` first:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can add the Cucumber main JAR file in `pom.xml` as a dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, if you prefer a fluent stream-based style of coding, you can
    add a different Cucumber main JAR file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If your project does not have JUnit set up as a dependency yet, you may add
    it as follows along with another `cucumber-junit` JAR file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The above is necessary if you plan to take advantage of JUnit assertions. Note
    that, at the time of writing, Cucumber does not support JUnit 5.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, you can use assertions from TestNG ([https://testng.org](https://testng.org)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, in this case, you need to add the `cucumber-testng` JAR file instead
    of the `cucumber-junit` JAR file. TestNG offers a rich variety of assertion methods,
    including deep collections and other object comparisons.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run Cucumber. The `cucumber-junit` JAR file also provides an `@RunWith` annotation
    that designates a class as a test runner:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Execution of the preceding class will execute all scenarios in the same package
    where the runner is located. Cucumber reads each `.feature` file and the scenarios
    in it. For each step of each scenario, it tries to find its implementation in
    the same package as the runner and the `.feature` file. It executes each implemented
    step in the sequence they are listed in a scenario.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `.feature` file. As we have mentioned already, a `.feature` file contains
    one or more scenarios. The name of the file does not mean anything for Cucumber.
    The content of the file starts with the `Feature` keyword (with the colon `:` after
    it). The following text describes the feature and, similar to the filename, does
    not mean anything to Cucumber. The feature description ends when the `Scenario` keyword
    (with the colon `:` after it) starts a new line. That is when the first scenario
    description begins. Here is an example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The scenario description ends when one of the following keywords starts a new
    line: `Given`, `When`, `Then`, `And`, or `But`. Each of these keywords, when it
    starts a new line, indicates the beginning of a step definition. For Cucumber,
    such a keyword means nothing except the beginning of the step definition. But
    for humans, it is easier to read if the scenario starts with the keyword  `Given`—the
    step that describes the initial state of the system—prerequisite. Several other
    steps (prerequisites) may follow; each step starts with a new line and the keyword
    `And` or `But`, for example, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, the group of steps describes the actions or events. For human readability,
    the group typically starts with the `When` keyword at a new line. Other actions
    or events follow, and each starts with a new line and the `And` or `But` keyword.
    It is recommended to keep the number of steps in this group to a minimum, so each
    scenario is well focused, for example, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The last group of steps in a scenario starts with the `Then` keyword in the
    new line. They describe the expected results. As in the previous two groups of
    steps, each subsequent step in this group starts with a new line and the `And` or `But` keyword
    too, for example, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'To summarize the previous, the feature looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We put it in the `CalculateSpeed.feature` file in the following folder: `src/test/resources/com/packt/cookbook/Chapter14_testing`,'
  prefs: []
  type: TYPE_NORMAL
- en: Note that, it has to be in the `test/resources` folder and the path to it has
    to match the package name where the `RunScenariosTest` test runner belongs.
  prefs: []
  type: TYPE_NORMAL
- en: The test runner is executed as any JUnit test, using the `mvn test` command,
    for example, or just by running it in JDE. When executed, it looks for all `.feature`
    files in the same package (Maven copies them from the `resources` folder to the
    `target/classes` folder, hence setting them on the classpath). It then reads the
    steps of each scenario sequentially and tries to find the implementation of each
    step in the same package.
  prefs: []
  type: TYPE_NORMAL
- en: As we have mentioned already, names of the file do not have any meaning for
    Cucumber. It looks for the `.feature` extension first, then finds the first step
    and, in the same directory, tries to find a class that has a method in it annotated
    by the same wording as the step.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate what it means, let''s run the created feature by executing the
    test runner. The results are going to be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, Cucumber not only tells us which and how many features and scenarios
    are `undefined`, it even provides a possible way to implement them. Please note
    how Cucumber allows passing in parameters using a type in curly braces. The following
    are built-in types: `int`, `float`, `word`, `string`, `biginteger`, `bigdecimal`,
    `byte`, `short`, `long`, and `double`. The difference between `word` and `string`
    is that the latter allows spaces. But Cucumber also allows us to define custom
    types.
  prefs: []
  type: TYPE_NORMAL
- en: Write and run step definitions. Cucumber's term `undefined` may be confusing
    because we did define the feature and scenarios. We just did not implement them.
    So, the `undefined` in the Cucumber message actually means `not implemented`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To start the implementation, we first create a class, `CalculateSpeedSteps`, in
    the same directory with the test runner. The class name has no meaning for Cucumber,
    so you can name it any other way you prefer. Then, we copy the three methods suggested previously
    with annotations and put them in that class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If we execute the test runner again, the output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The runner stopped executing at the first `PendingException`, so the other two
    steps were skipped. If BDD methodology is applied systematically, then the feature
    is written first—before any code of the application is written. So, every feature
    produces the previous result.
  prefs: []
  type: TYPE_NORMAL
- en: As the application gets developed, each new feature is implemented and does
    not fail anymore.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Immediately after the requirements are expressed as features, the application
    gets implemented feature by feature. For example, we could start by creating the `Vehicle` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Then the steps of the first feature shown previously can be implemented as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: If we run the test runner in the `com.packt.cookbook.ch16_testing` package again,
    the steps will be executed successfully.
  prefs: []
  type: TYPE_NORMAL
- en: Now, if the requirements change and the `.feature` file is modified correspondingly,
    the test will fail, unless the application code is changed too and matches the
    requirements. That is the power of BDD. It keeps requirements in sync with the
    code. It also allows the Cucumber tests to serve as regression tests. If the code
    changes violate the requirements, the test fails.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing of an API using JUnit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: According to Wikipedia, more than 30% of the projects hosted on GitHub include
    JUnit—one of a family of unit testing frameworks collectively known as xUnit that
    originated with SUnit. It is linked as a JAR at compile time and resides (since
    JUnit 4) in the `org.junit` package.
  prefs: []
  type: TYPE_NORMAL
- en: In object-oriented programming, a unit can be an entire class but could be an
    individual method. We've found the last part—a unit as an individual method—the
    most useful in practice. It serves as the basis for the examples of the recipes
    of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At the time of writing, the latest stable version of JUnit is 4.12, which can
    be used by adding the following Maven dependency to the `pom.xml` project level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'After this, you can write your first JUnit test. Let''s assume you have the `Vehicle` class
    created in the `src/main/java/com/packt/cookbook.ch02_oop.a_classes` folder (this
    is the code we discussed in  [Chapter 2](db468cc9-60fa-4966-890a-872bef36ff01.xhtml), *Fast
    Track to OOP - Classes and Interfaces*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can create the `src/test/java/com/packt/cookbook.ch02_oop.a_classes` folder
    and a new file in it called `VehicleTest.java`, which contains the `VehicleTest`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Run it using your favorite IDE or just with the `mvn test` command. You will
    see output that will include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3ae6e5f2-a622-4f77-b934-2867786402f4.png)'
  prefs: []
  type: TYPE_IMG
- en: Congratulations! You have created your first test class. It does not test anything
    yet, but it is an important setup—the overhead that is necessary for doing things
    the right way. In the next section, we will start with the actual testing.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s look at the `Vehicle` class closer. Testing the getters would be of
    little value, but we can still do it, making sure that the value passed to the
    constructor is returned by the corresponding getter. The exception in the constructor
    belongs to the must-test features as well as the `getSpeedMph()` method. There
    is also an object of the `Engine` class that has the `getHorsePower()` method.
    Can it return `null`? To answer this question, let''s look at the `Engine` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `getHorsePower()` method cannot return `null`. The `horsePower` field will
    be initiated to the value zero by default if not set explicitly by the `setHorsePower()` method.
    But returning a negative value is a definite possibility, which in turn can cause
    problems for the `Math.sqrt()` function of the `getSpeedMph()` method. Should
    we make sure that the horsepower value will never be negative? It depends on how
    limited the method's usage is and the source of the input data for it.
  prefs: []
  type: TYPE_NORMAL
- en: Similar considerations are applicable to the value of the `weightPounds` field
    of the `Vehicle` class. It can stop the application with `ArithmeticException`
    caused by the division by zero in the `getSpeedMph()` method.
  prefs: []
  type: TYPE_NORMAL
- en: However, in practice, there is little chance that the values of an engine's
    horsepower and vehicle weight will be negative or close to zero, so we will assume
    this and will not add these checks to the code.
  prefs: []
  type: TYPE_NORMAL
- en: Such analysis is the daily routine and the background thoughts of every developer,
    and that is the first step in the right direction. The second step is to capture
    all these thoughts and doubts in the unit tests and verify the assumptions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go back to the test class we have created. As you may have noticed,
    the `@Test` annotation makes a certain method a test method. This means it will
    be run by your IDE or Maven every time you issue a command to run tests. The method
    can be named any way you like, but a best practice advises to indicate which method
    (of the `Vehicle` class, in this case) you are testing. So, the format usually
    looks like `test<methodname><scenario>`, where `scenario` indicates a particular
    test case: a happy path, a failure, or some other condition you would like to
    test. In the first example, though we do not use the suffix, just to keep the
    code simple. We will show examples of methods that test other scenarios later.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In a test, you can call the application method you are testing, provide it
    with the data, and assert the result. You can create your own assertions (methods
    that compare the actual results with the expected ones) or you can use assertions
    provided by JUnit. To do the latter, just add the `static` import:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'If you use a modern IDE, you can type `import static org.junit.Assert` and
    see how many different assertions are available (or go to JUnit''s API documentation
    and see it there). There are a dozen or more overloaded methods available: `assertArrayEquals()`,
    `assertEquals()`, `assertNotEquals()`, `assertNull()`, `assertNotNull()`, `assertSame()`,
    `assertNotSame()`, `assertFalse()`, `assertTrue()`, `assertThat()`, and `fail()`.
    It would be helpful if you spend a few minutes reading what these methods do.
    You can also guess their purpose by their name. Here is an example of the usage
    of the `assertEquals()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We compare the actual length of the word `Hello` and the expected length of `4`.
    We know that the correct number would be `5`, but we would like the test to fail
    to demonstrate the failing behavior. If you run the preceding test, you''ll get
    the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e1062cd4-ecc4-430c-ab74-b23fe96f171d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, the last line tells you what went wrong: the expected value
    was `4`, while the actual was `5`. Say you switch the order of the parameters
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The result will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/264588c3-e7e2-41ef-a779-f2450921c91e.png)'
  prefs: []
  type: TYPE_IMG
- en: The last message is misleading now.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to remember that, in each of the asserting methods, the parameter
    with the expected value is located (in the signature of an assertion) **before**
    the actual one.
  prefs: []
  type: TYPE_NORMAL
- en: After the test is written, you will do something else, and months later, you
    will probably forget what each assertion actually evaluated. But it may well be
    that one day the test will fail (because the application code was changed). You
    will see the test method name, expected value, and the actual value, but you will
    have to dig through the code to figure out which of the assertions failed (there
    are often several of them in each test method). You will probably be forced to
    add a debug statement and run the test several times in order to figure it out.
  prefs: []
  type: TYPE_NORMAL
- en: 'To help you avoid this extra digging, each of the JUnit assertions allows you
    to add a message that describes the particular assertion. For example, run this
    version of the test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'If you do this, the result will be much more readable:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/240214a0-c228-4e70-a98e-c153f7a27484.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To complete this demonstration, we change the expected value to `5`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the test results show no failures:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/88e0720a-1f8b-4fdd-a58a-754ace2cc9aa.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Equipped with the basic understanding of the usage of the JUnit framework,
    we can now write a real test method for the main case of the calculation of the
    speed of a vehicle with a certain weight and an engine of certain horsepower to
    determine. We take the formula we use for the speed calculations and calculate
    the expected value manually first. For example, if the vehicle has an engine of
    246 hp and weight of 4,000 lb, then in 10 seconds, its speed can reach 117 mph.
    Since the speed is of the `double` type, we will use the assertion with some delta.
    Otherwise, two `double` values may never be equal due to the way a `double` value
    is represented in the computer. Here is the assertion method of the `org.junit.Assert`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The `delta` value is allowable precision. The resultant implementation of the
    `test` method will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we have decided that one-tenth of one percent of the value
    is a good enough precision for our purposes. If we run the preceding test, the
    output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c294b3f1-8103-4030-8038-af6f531c11b1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To make sure the test is working, we can set the expected value to 119 mph
    (more than one percent different from the actual one) and run the test again.
    The result will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f79b70e9-475a-488a-8edc-f53d54f8b2b9.png)'
  prefs: []
  type: TYPE_IMG
- en: We change the expected value back to 117 and continue writing other test cases
    we discussed while analyzing the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s make sure that the exception is thrown when expected. To do that, we
    add another import:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can write the code that tests the case when the value passed in the
    constructor of the `Vehicle` class is null (so the exception should be thrown):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This test runs successfully, which means that the `Vehicle` constructor had
    thrown an exception and the code has never reached the line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'To make sure that the test works correctly, we temporarily pass a non-null
    value into the `Vehicle` constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we observe the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e2efee35-c323-40dd-8a33-0dfb9df40e43.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This way, we get a level of confidence that our test works as expected. Alternatively,
    we can create another test that fails when an exception is thrown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The best way to write such tests is in the process of writing application code,
    so you can test the code as it grows in complexity. Otherwise, especially in more
    complex code, you might have problems debugging it after all of the code is written
    already.
  prefs: []
  type: TYPE_NORMAL
- en: There are quite a few other annotations and JUnit features that can be helpful
    to you, so please refer to the JUnit documentation for a more in-depth understanding
    of all the framework capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing by mocking dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Writing a unit test requires controlling all the input data. In case a method
    receives its input from other objects, there arises a need to limit the depth
    of testing so that each layer can be tested in isolation as a unit. This is when
    the need for mocking the lower level comes into focus.
  prefs: []
  type: TYPE_NORMAL
- en: Mocking can be done not only vertically, but also horizontally at the same level.
    If a method is big and complicated, you might consider breaking it into several
    smaller methods so you can test only one of them while mocking the others. This
    is another advantage of unit testing code along with its development; it is easier
    to redesign code for better testability at the earlier stages of its development.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mocking other methods and classes is straightforward. Coding to an interface
    (as described in [Chapter 2](db468cc9-60fa-4966-890a-872bef36ff01.xhtml), *Fast
    Track to OOP - Classes and Interfaces*) makes it much easier, although there are
    mocking frameworks that allow you to mock classes that do not implement any interface
    (we will see examples of such framework usage in the next section of this recipe).
    Also, using object and method factories helps you create test-specific implementations
    of such factories so they can generate objects with methods that return the expected
    hardcoded values.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, in [Chapter 4](69c0640b-9b2e-4515-bda6-8a481206da19.xhtml), *Going
    Functional*, we introduced `FactoryTraffic`, which produced one or many objects
    of `TrafficUnit`. In a real system, this factory would draw data from some external
    system. Using the real system as the source could complicate the code setup. As
    you could see, to get around this problem, we mocked the data by generating it
    according to the distribution that somewhat resembles the real one: a bit more
    cars than trucks, the weight of the vehicle depending on the type of the car,
    the number of passengers and weight of the payload, and similar. What is important
    for such a simulation is that the range of values (minimum and maximum) should
    reflect those coming from the real system, so the application would be tested
    on the full range of possible real data.'
  prefs: []
  type: TYPE_NORMAL
- en: The important constraint for mocking code is that it should not be too complicated.
    Otherwise, its maintenance would require an overhead that would either decrease
    the team productivity or decrease the test coverage.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The mock of `FactoryTraffic` may look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'It assembles a collection of `TrafficUnit` objects. In a real system, these
    objects would be created from the rows of the result of some database query, for
    example. But in our case, we just hardcode the values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we used a random number generator to pick up the value from
    a range for each of the parameters. The range is in line with the ranges of the
    real data. This code is very simple and it does not require much maintenance,
    but it provides the application with the flow of data similar to the real one.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use another technique. For example, let''s revisit the `VechicleTest`
    class. Instead of creating a real `Engine` object, we can mock it using one of
    the mocking frameworks. In this case, we use Mockito. Here is the Maven dependency
    for it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The test method now looks like this (the two lines that were changed are highlighted):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we instruct the `mock` object to return a fixed value when
    the `getHorsePower()` method is called. We can even go as far as creating a mock
    object for the method we want to test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'So, it always returns the same value:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8d517f9e-a80c-4179-abb1-a42149aed65b.png)'
  prefs: []
  type: TYPE_IMG
- en: However, this would defeat the purpose of testing because we would like to test
    the code that calculates the speed, not to mock it.
  prefs: []
  type: TYPE_NORMAL
- en: 'For testing a stream''s pipeline methods, yet another technique can be used.
    Let''s assume we need to test the `trafficByLane()` method in the `TrafficDensity1`
    class (we are going to have  `TrafficDensity2` and `TrafficDensity3`, too):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'It uses two support classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'It also uses the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: We demonstrated the use of such support classes in Chapter 3, *Modular* *Programming*,
    while talking about streams. Now we realize that testing this class might not
    be easy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because the `SpeedModel` object is an input parameter for the `trafficByLane()` method,
    we could test its `getSpeedMph()` method in isolation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Refer to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the current implementation of `FactorySpeedModel` requires
    the `TrafficUnit` object in order to get the traction value. To get around this
    problem, we can modify the preceding code and remove the `SpeedModel` dependency
    on `TrafficUnit`. We can do it by moving the traction application to the `calcSpeed()`
    method. The new version of `FactorySpeedModel` can look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The test method can now be implemented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'However, the `calcSpeed()` method in `TrafficUnitWrapper` remains untested.
    We could test the `trafficByLane()` method as a whole:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'But this would require creating a stream of objects of `TrafficUnit` with fixed
    data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Such a solution does not provide a variety of test data for different vehicle
    types and other parameters. We need to revisit the design of the `trafficByLane()` method.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you look closely at the `trafficByLane()` method, you will notice that the
    problem is caused by the location of the calculation—inside the private class, `TrafficUnitWrapper`.
    We can move it out of there and create a new method, `calcSpeed()`, in the `TrafficDensity` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can change its signature and include the `Vehicle` object and `traction`
    coefficient as parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s also add two methods to the `TrafficUnitWrapper` class (you will see
    in a moment why we need them):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding changes allow us to rewrite the stream pipeline as follows (the
    changed line is in bold):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'By making the `calcSpeed()` method protected and assuming that the `Vehicle`
    class is tested in its own test class, `VehicleTest`, we can now write the `testCalcSpeed()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The remaining functionality can be tested by mocking the `calcSpeed()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This experience has made us aware that using an inner private class can make
    the functionality untestable in isolation. Let''s try to get rid of the `private`
    class, `CountByLane`. This leads us to the third version of the `TrafficDensity3`
    class (the changed code is highlighted):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'This change allows us to extend the class in our test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'It also allows us to change the `calcLaneNumber()` test method in isolation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Using fixtures to populate data for testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In more complex applications (that use a database, for example), there is often
    the need to set up the data before each test and clean it up after the test is
    completed. Some parts of the data need to be set before each test method and/or
    cleaned after each test method has completed. Other data may need to be set up
    before any test method of the test class was run and/or cleaned up after the last
    test method of the test class has completed.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To accomplish this, you add an `@Before` annotation in front of it, which indicates
    that this method has to run before every test method. The corresponding cleaning
    method is identified by the `@After` annotation. Similarly, the class-level setup
    methods are annotated by `@BeforeClass` and `@AfterClass`, which means these setup
    methods are going to be executed only once—before any test method of this class
    is executed (`@BeforeClass`) and after the last test method of this class has
    been executed (`@AfterClass`). Here is a quick demo of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run the tests now, you''ll get the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5c124906-d843-4d1d-8a75-ba87f6e17401.png)'
  prefs: []
  type: TYPE_IMG
- en: Such methods that *fix* the test context are called **fixtures**. Note that
    they have to be public, and the class-level setup/cleanup fixtures have to be
    static. The upcoming JUnit version 5 plans to lift these constraints, though.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A typical example of such a usage would be creating necessary tables before
    the first test method is run and removing them after the last method of the test
    class is finished. The setup/cleanup methods can also be used to create/close
    a database connection unless your code does it in the try-with-resources construct
    (refer to [Chapter 11](d8d77bf4-a30b-4474-95ca-0a166aef48c0.xhtml), *Memory Management
    and Debugging*).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of the usage of fixtures (refer to [Chapter 6](4d5627d7-8aa3-4ad8-912f-7525f77143b9.xhtml),
    *Database Programming*, for more on *how to set up a database for running it,*
    section). Let''s assume we need to test the `DbRelatedMethods` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'We would like to make sure that the previous method, `updateAllTextRecordsTo()`,
    always updates all the records of the `text` table with the provided value. Our
    first test, `updateAllTextRecordsTo1()`, is to update one existing record:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: This means that the table has to exist in the test database and should have
    one record in it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our second test, `updateAllTextRecordsTo2()`, makes sure that two records are
    updated even if each record contains a different value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Both the preceding tests use the same table, that is, `text`. Therefore, there
    is no need to drop the table after each test. This is why we create and drop it
    at the class level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'This means that all we need to do is populate the table before each test and
    clean it up after each test is completed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, since we can use the same object, `dbRelatedMethods`, for all the tests,
    let''s create it on the class level too (as the test class''s property), so it''s
    created only once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run all the tests of the `test` class now, the output will look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/05dd11a5-0699-4dfe-98cd-0ed6cbeb4627.png)'
  prefs: []
  type: TYPE_IMG
- en: The printed messages allow you to trace the sequence of all the method calls
    and see that they are executed as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Integration testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have read all the chapters and have looked at the code examples, you
    may have noticed that, by now, we have discussed and built all the components
    necessary for a typical distributed application. It is the time to put all the
    components together and see whether they cooperate as expected. This process is
    called **integration**.
  prefs: []
  type: TYPE_NORMAL
- en: While doing this, we will look closely at assessing whether the application
    behaves according to the requirements. In cases where functional requirements
    are presented in an executable form (using the Cucumber framework, for example),
    we can run them and check whether all the checks pass. Many software companies
    follow a Behavior-Driven Development process and perform testing very early, sometimes
    even before any substantial amount of code is written (such tests fail, of course,
    but succeed as soon as the expected functionality is implemented). As mentioned
    already, early testing can be very helpful for writing a focused, clear, and well-testable
    code.
  prefs: []
  type: TYPE_NORMAL
- en: However, even without strict adherence to the *test-first* process, the integration
    phase naturally includes some kind of behavioral testing too. In this recipe,
    we will see several possible approaches and specific examples related to this.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You might have noticed that, in the course of this book, we have built several
    classes that compose an application that analyzes and models traffic. For your
    convenience, we have included all of them in the `com.packt.cookbook.ch16_testing` 
    package.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the earlier chapters, you''re already familiar with the five interfaces
    in the `api` folder—`Car`, `SpeedModel`, `TrafficUnit`, `Truck`, and `Vehicle`.
    Their implementations are encapsulated inside classes called **factories** in
    the folder with the same name: `FactorySpeedModel`, `FactoryTraffic`, and `FactoryVehicle`.
    These factories produce input for the functionality of the `AverageSpeed` class
    ([Chapter 7](cf1c5e81-eb66-4623-b141-a5fb7552ce49.xhtml), *Concurrent and Multithreaded
    Programming*) and the `TrafficDensity` class (based on [Chapter 5](eaa70333-8e9d-453d-a9b6-063152fcc1e1.xhtml),
    *Streams and Pipelines,* but created and discussed in this chapter)—the core classes
    of our demo application. They produce the values that motivated the development
    of this particular application in the first place.'
  prefs: []
  type: TYPE_NORMAL
- en: The main functionality of the application is straightforward. For a given number
    of lanes and speed limit for each lane, `AverageSpeed` calculates (estimates)
    the actual speed of each lane (assuming all the drivers are behaving rationally,
    taking the lane according to their speed), while `TrafficDensity` calculates the number
    of vehicles in each lane after 10 seconds (assuming all the cars start at the
    same time after the traffic light). The calculations are done based on the data
    from the `numberOfTrafficUnits` vehicles collected at a certain location and time
    of the year. It does not mean that all the 1,000 vehicles were racing at the same
    time. These 1,000 measuring points have been collected over 50 years for approximately
    20 vehicles that drove at the specified intersection during the specified hour
    (which means one vehicle every three minutes, on average).
  prefs: []
  type: TYPE_NORMAL
- en: 'The overall infrastructure of the application is supported by the classes in
    the `process` folder: `Dispatcher`, `Processor`, and `Subscription`. We discussed
    their functionality and demonstrated them in [Chapter 7](cf1c5e81-eb66-4623-b141-a5fb7552ce49.xhtml),
    *Concurrent and Multithreaded Programming*. These classes allow distributing the
    processing.'
  prefs: []
  type: TYPE_NORMAL
- en: The `Dispatcher` class sends a request for processing to the population of `Processors`
    in a pool, using the `Subscription` class. Each `Processor` class performs the
    task according to the request (using the `AverageSpeed` and `TraffciDensity` classes)
    and stores the results in the database (using the `DbUtil` class in the `utils`
    folder, based on the functionality discussed in [Chapter 6](4d5627d7-8aa3-4ad8-912f-7525f77143b9.xhtml),
    *Database Programming*).
  prefs: []
  type: TYPE_NORMAL
- en: We have tested most of these classes as units. Now we are going to integrate
    them and test the application as a whole for correct behavior.
  prefs: []
  type: TYPE_NORMAL
- en: The requirements were made up just for demonstrative purposes. The goal of the
    demonstration was to show something well motivated (resembling real data) and
    at the same time simple enough to understand without special knowledge of traffic
    analysis and modeling.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are several levels of integration. We need to integrate the classes and
    subsystems of the application and also integrate our application with the external
    system (the source of the traffic data developed and maintained by a third party).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of class-level integration using the `demo1_class_level_integration()`
    method in the `Chapter14Testing` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we integrated each of the two main classes, namely `AverageSpeed`
    and `TrafficDensity`, with factories and implementations of their interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'The results are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/30015170-2ee5-4be1-8ace-87c4e98f8982.png)'
  prefs: []
  type: TYPE_IMG
- en: Note that the results are slightly different from one run to another. This is
    because the data produced by `FactoryTraffic` varies from one request to another.
    But, at this stage, we just have to make sure that everything works together and
    produces some more or less accurate-looking results. We have tested the code by
    units and have a level of confidence that each unit is doing what it is supposed
    to do. We will get back to the results' validation during the actual integration
    *testing* process, not during integration.
  prefs: []
  type: TYPE_NORMAL
- en: 'After finishing the integration at the class level, see how the subsystems
    work together using the `demo1_subsystem_level_integration()` method in the `Chapter14Testing`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code, we used `DBUtil` to create the necessary table that holds the
    input data and the results produced and recorded by `Processor`. The `Dispatcher`
    class sends a request and inputs data to the objects of the `Processor` class,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Subscription` class is used to send/get the message (refer to [Chapter
    7](cf1c5e81-eb66-4623-b141-a5fb7552ce49.xhtml), *Concurrent and Multithreaded
    Programming*, for a description of this functionality):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'The processors are doing their job; we just need to wait for a few seconds
    (you might adjust this time if the computer you are using requires more time to
    finish the job) before we get the results. We use `DBUtil` for reading the results
    from the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e2e9ca71-45f0-42b1-955e-071d82ab264d.png)'
  prefs: []
  type: TYPE_IMG
- en: The names of the `Process` enum class point to the corresponding records in
    the `result` table in the database. Again, at this stage, we are primarily looking
    for getting any results at all, not at how correct the values are.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the successful integration between the subsystems of our application
    based on the generated data from `FactoryTraffic`, we can try to connect to the
    external system that provides real traffic data. Inside `FactoryTraffic`, we would
    now switch from generating `TrafficUnit` objects to getting data from a real system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: The switch can be implemented as a `Boolean` property in the class (as seen
    in the preceding code) or the project configuration property. We leave out the
    details of the connection to a particular source of real traffic data as this
    is not relevant to the purpose of this book.
  prefs: []
  type: TYPE_NORMAL
- en: The main focus at this stage has to be the performance and having a smooth data
    flow between the external source of real data and our application. After we have
    made sure that everything works and produces realistic results with satisfactory
    performance, we can turn to integration *testing* with the actual results' assertion.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For testing, we need to set the expected values, which we can compare with the
    actual values produced by the application that processes real data. But real data
    changes slightly from run to run, and an attempt to predict the resultant values
    either makes the test fragile or forces the introduction of a huge margin of error,
    which may effectively defeat the purpose of testing.
  prefs: []
  type: TYPE_NORMAL
- en: We cannot even mock the generated data (as we did in the case of unit testing)
    because we are at the integration stage and have to use the real data.
  prefs: []
  type: TYPE_NORMAL
- en: One possible solution would be to store the incoming real data and the result
    our application produced in the database. Then, a domain specialist can walk through
    each record and assert whether the results are as expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'To accomplish this, we introduced a `boolean` switch in the `TrafficDensity` class,
    so it records the input along with each unit of the calculations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: We also introduced a static property to keep the same database connection across
    all the class instances. Otherwise, the connection pool should be very big because,
    as you may recall from [Chapter 7](cf1c5e81-eb66-4623-b141-a5fb7552ce49.xhtml), *Concurrent
    and Multithreaded Programming*, the number of workers that execute the task in
    parallel grows as the amount of work to do increases.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you look at `DbUtils`, you will see a new method that creates the `data` table
    designed to hold `TrafficUnits` coming from `FactoryTraffic` and the `data_common` table
    that keeps the main parameters used for data requests and calculations: requested
    numbers of traffic units, the date and geolocation of the traffic data, the time
    in seconds (the point when the speed is calculated), and the speed limit for each
    lane (its size defines how many lanes we plan to use while modeling the traffic).
    Here is the code that we configure to do the recording:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: After the recording is completed, we can turn the data over to a domain specialist
    who can assert the correctness of the application behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'The verified data can now be used for integration testing. We can add another
    switch to `FactoryTrafficUnit` and force it to read the recorded data instead
    of the unpredictable real data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'As you may have noticed, we have also added the `isEnoughData()` method which
    checks whether there is enough recorded data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: This will help avoid the unnecessary frustration of debugging the test problem,
    especially in the case of testing a more complex system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we control not only the input values but also the expected results that
    we can use to assert the application behavior. Both are now included in the `TrafficUnit`
    object. To be able to do this, we took advantage of the new Java interface feature
    discussed in [Chapter 2](db468cc9-60fa-4966-890a-872bef36ff01.xhtml), *Fast Track
    to OOP - Classes and Interfaces*, which is the interface default method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'So, we can attach the result to the input data. See the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'We can attach the result to the `DbUtil` class and the `TrafficUnitImpl` class inside `DbUtil`
    too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: And we can attach it inside the `DbUtil` class too.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding changes allow us to write an integration test. First, we will
    test the speed model using the recorded data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: A similar test can be written for testing the speed calculation of the `AverageSpeed`
    class with real data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we can write an integration test for the class level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Similar code can be written for the class-level testing of the `TrafficDensity` class
    too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can write the integration test for the subsystem level as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: All of the preceding tests are run successfully now and may be used for application
    regression testing any time later.
  prefs: []
  type: TYPE_NORMAL
- en: An automated integration test between our application and the source of the
    real traffic data can be created only if the latter has a test mode from where
    the same flow of data can be sent our way so we can use it in the same manner
    we use recorded data (which is essentially the same thing).
  prefs: []
  type: TYPE_NORMAL
- en: One parting thought—all of this integration testing is possible when the amount
    of processing data is statistically significant. This is because we do not have
    full control over the number of workers and how the JVM decides to split the load.
    It is quite possible that, on a particular occasion, the code demonstrated in
    this chapter would not work. In such a case, try to increase the number of requested
    traffic units. This will ensure more space for the load-distributing logic.
  prefs: []
  type: TYPE_NORMAL
