- en: Concurrency in Android
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will explain concurrency in Android. We will give examples
    and advice and apply concurrency to our Journaler application. We already touched
    on some basics by demonstrating the use of the `AsyncTask` class, but now we will
    dig deeper.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Handlers and threads
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AsyncTask`'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Android Looper
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Delayed execution
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to Android concurrency
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A default execution for our application is performed on the main application
    thread. This execution must be performant! If it happens that something is performing
    too long, then we get ANR--an Android application not responding message. To avoid
    ANRs, we run our code in the background. Android provides mechanisms so we can
    do that efficiently. Running operations asynchronously gives not just good performance,
    but great user experience.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: Main thread
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All user interface updates are performed from one thread. This is the main thread.
    All events are collected in a queue and processed by the `Looper` class instance.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: 'The following image explains the relationship between classes involved:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1b186908-463f-4a05-9454-c76fdb4bdde7.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
- en: It is important to note that the main thread updates are all the UI you see.
    However, it can be done from other threads as well. Doing this directly from some
    other thread will cause an exception and your application can crash. To avoid
    this, execute all thread-related code on the main thread by calling the `runOnUiThread()`
    method from your current activity context.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Handlers and threads
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Android, threading can be performed in the standard way by using threads.
    It is not recommended to just fire naked threads without any control. So, for
    this purpose, you can use the `ThreadPools` and `Executor` classes.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate this, we will update our application. Create a new package called
    `execution` with a class called `TaskExecutor`. Make sure it looks like this:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We extended the `ThreadPoolExecutor` class and `companion` object with the
    member method for executor instantiation. Let''s apply it to our existing code.
    We will switch from the `AsyncTask` class we used to `TaskExecutor`. Open the
    `NoteActivity` class and update it as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you can see, we replaced `AsyncTask` with the executor. Our executor will
    handle only one thread at a time.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: 'Other than the standard thread approach, Android also provides Handlers as
    one of the options for developers. Handlers are not a replacement for threads,
    but an addition! A Handler instance registers itself with its parent thread. It
    represents a mechanism to send data to that particular thread. We can send instances
    of the `Message` or `Runnable` class. Let''s illustrate its use with an example.
    We will update the Notes screen with an indicator that will be green if everything
    is performed correctly. If database persisting fails, it will be red. Its default
    color will be grey. Open the `activity_note.xml` file and extend it with the indicator.
    The indicator will be plain view, as shown here:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, when we add the indicator, it will change its color depending on the database
    insertion result. Update your `NoteActivity` class source code like this:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Build your application and run it. Create a new note. You will notice that the
    indicator changed color to green after you entered a title and the message content.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: 'We will make some more changes and do the same thing with the `Message` class
    instance. Update your code according to this example:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Pay attention to the Handler instantiation and the `sendMessage()` method. We
    obtained the `Message` instance using the `obtainMessage()` method from our `Handler`
    class. As the message argument, we passed an integer datatype. Depending on its
    value, we will update the indicator color.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: AsyncTask
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you have may have noticed, we are already using the `AsyncTask` class in
    our application. Now, we will go one step forward with it--we will run it on the
    executor. Why would we do that?
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: First of all, by default, all `AsyncTasks` are executed in sequence by Android.
    To execute it in parallel, we need to execute it on the executor.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Wait! There is more. Now, when we execute tasks in parallel, imagine you executed
    a few of them. Let's say we start with two. That's fine. They will perform their
    operations and report us when completed. Then, imagine we run four of them. They
    will work too, in most cases, if the operations they execute are not too heavy.
    However, at some point, we run fifty `AsyncTasks` in parallel.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, your application is slowing down! Everything will slow down because there
    is no control over the execution of tasks. We must manage tasks so the performance
    is preserved. So, let''s do that! We will continue on the same class we were updating
    so far. Change your `NoteActivity` as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Since this is not actually something we will keep in the Journaler application,
    do not commit this code. Create it as a separate branch if you wish. We created
    a new instance of `ThreadPoolExecutor`. The constructor takes several arguments,
    as shown here:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '`corePoolSize`: This represents a minimal number of threads to keep in the
    pool.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`maximumPoolSize`: This represents a maximal number of threads allowed in the
    pool.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`keepAliveTime`: If the number of threads is greater than the core, the noncore
    threads will wait for a new tasks, and if they don''t get one within the time
    defined by this parameter, they will terminate.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Unit`: This represents the time unit for `keepAliveTime`.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WorkQueue`: This represents the queue instance that will be used to hold the
    tasks.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will run our tasks on this executor. `AsyncTask` concretization will log
    all events during its life cycle. In the `main` method, we will wait for 5 seconds.
    Run the application and try to add a new note with `Android` as the title. Observe
    your Logcat output:'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let''s filter logs by the methods we execute in our tasks. Let''s look at the
    filter for the `onPreExecute` method first:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Do the same for each method and focus on the times when the methods were executed.
    To give more challenge to your code, change the `doInBackground()` method implementation
    to do some more serious and intensive work. Then, fire more tasks by typing a
    longer title, for example, the entire sentence. Filter and analyze your log.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Android Looper
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's explain the `Looper` class. We used it in previous examples but we did
    not explain it in details.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '`Looper` represents a class that is used to execute `messages` or `runnable`
    instances in a queue. Ordinary threads do not have any queue like the `Looper`
    class has.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: Where we can use the `Looper` class? For the execution of multiple `messages`
    or `runnable` instances, `Looper` is needed! One example of use can be adding
    new tasks to the queue while, at the same time, the operation of task processing
    is running.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the Looper
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To use the `Looper` class, we must first call the `prepare()` method. When
    `Looper` is prepared, we can use the `loop()` method. This method is used to create
    a `message` loop in the current thread. We will give you one short example:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this example, we demonstrated basic steps to program a `Looper` class. Do
    not forget to `prepare()` your `Looper` class or you will get an exception and
    your application can crash!
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: Delayed execution
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There''s one more important thing left to show you in this chapter. We will
    show you some delayed execution in Android. We will give you some examples of
    delayed operation applied to our UI. Open your `ItemsFragment` and make these
    changes:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'After three seconds, if we don''t close this screen, the background color will
    be changed to a slightly darker grey tone. Run your application and see for yourself.
    Now, let''s do the same thing in a different way:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This time, we used the `Handler` class to perform delayed modification.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you were introduced to Android concurrency. We explained and
    provided you with examples for each of the segments. This is a nice introduction
    for you before diving into the depths of Android services. Android services are
    the most powerful concurrency feature Android has to offer, and, as you will see,
    it can be used as the brain for your application.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们向您介绍了Android并发性。我们为每个部分进行了解释，并为您提供了示例。在深入了解Android服务之前，这是一个很好的介绍。Android服务是Android提供的最强大的并发特性，正如您将看到的，它可以被用作应用程序的大脑。
