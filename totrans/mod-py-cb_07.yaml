- en: Chapter 7. More Advanced Class Design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll look at the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Choosing between inheritance and extension – the is-a question
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Separating concerns via multiple inheritance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leveraging Python's duck typing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing global and singleton objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using more complex structures – maps of lists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a class that has orderable objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining an ordered collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deleting from a list of mappings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 6](text00070.html#page "Chapter 6. Basics of Classes and Objects")
    , *Basics of Classes and Objects* , we looked at some recipes that cover the basics
    of class design. In this chapter, we'll dive a little more deeply into Python
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: In the *Designing classes with lots of processing* and *Using properties for
    lazy attributes* recipes in [Chapter 6](text00070.html#page "Chapter 6. Basics
    of Classes and Objects") , *Basics of Classes and Objects* , we identified a design
    choice that's central to object-oriented programming, the wrap versus extend choice.
    It's possible to add features to a class via extension and it's also possible
    to create a new class that wraps an existing class to add new features. There
    are a number of extension techniques available in Python, providing a lot of alternatives.
  prefs: []
  type: TYPE_NORMAL
- en: A Python class can inherit features from more than one superclass. This can
    lead to confusion, but a simple design pattern, the **mixin** , can prevent problems.
  prefs: []
  type: TYPE_NORMAL
- en: A larger application may require some global data that's widely shared by many
    classes or modules. This can be challenging to manage. We can, however, use a
    module to manage a global object and create a simple solution.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 4](text00048.html#page "Chapter 4. Built-in Data Structures – list,
    set, dict") , *Built-in Data Structures – list, set, dict* , we looked at the
    core built-in data structures. It's time to combine some features to create more
    sophisticated objects. This can also include extending built-in data structures
    to add sophistication.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing between inheritance and extension – the is-a question
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the *Using cmd for creating command-line applications*  recipe in [Chapter
    5](text00063.html#page "Chapter 5. User Inputs and Outputs") , *User Inputs and
    Outputs* , and the  *Extending a collection – a list that does statistics* recipe
    in [Chapter 6](text00070.html#page "Chapter 6. Basics of Classes and Objects")
    , *Basics of Classes and Objects* , we looked at extending a class. In both cases,
    our class was a subclass of a built-in class.
  prefs: []
  type: TYPE_NORMAL
- en: The idea of extension is sometimes called the generalization-specialization
    relationship. It's sometimes also called the **is-a relationship** .
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s an important semantic issue here that we can also summarize as the
    **wrap versus extend problem** :'
  prefs: []
  type: TYPE_NORMAL
- en: Do we really mean that the subclass is an example of the superclass? This is
    the is-a relationship. An example in Python is the built-in `Counter` , which
    extends the base class `dict` .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Or do we mean something else? Perhaps there's an association, sometimes called
    the **has-a relationship** . An example of this is in the *Designing classes with
    lots of processing* recipe in [Chapter 6](text00070.html#page "Chapter 6. Basics
    of Classes and Objects") , *Basics of Classes and Objects* , where `CounterStatistics`
    wraps a `Counter` object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What's a good way to distinguish between these two techniques?
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The question is a bit of metaphysical philosophy, specifically focused on the
    ideas of an **ontology** . An ontology is a way to define categories of being.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we extend an object, we have to ask the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"Is this a new class of objects, or a mixture of existing classes of objects?"*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'We''ll look at two ways to model a deck of playing cards:'
  prefs: []
  type: TYPE_NORMAL
- en: As a new class of objects that extends the built-in `list` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a wrapper that combines the built-in `list` class with some other features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A deck is a collection of cards. The core ingredient, then, is the underlying
    `Card` object. We''ll define this very simply using `namedtuple()` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We've created the class definition, `Card` , using `namedtuple()` . This creates
    a simple class with two attributes—`rank` and `suit` .
  prefs: []
  type: TYPE_NORMAL
- en: We also defined the various suits, `SUITS` , as a string of Unicode characters.
    To make it easier, to create cards of a specific suit, we also decomposed the
    string into four individual one character substrings. If your interactive environment
    doesn't properly display Unicode characters, you may have trouble with this. It
    might be necessary to change the OS environment variable, `PYTHONIOENCODING` ,
    to `UTF-8,` so that proper encoding is done.
  prefs: []
  type: TYPE_NORMAL
- en: The `\u2660` string is a single Unicode character. You can confirm this with
    `len(SUITS) == 4` . If the length isn't 4, check for extraneous spaces.
  prefs: []
  type: TYPE_NORMAL
- en: We'll use this `Card` class in the rest of this recipe. In some card games,
    a single 52-card deck is used. In other games, a dealing shoe is used. A shoe
    is a box that allows a dealer to shuffle together multiple decks and deal conveniently.
  prefs: []
  type: TYPE_NORMAL
- en: What's important is that the various kinds of collection—deck, shoe, and the
    built-in list all have considerable overlaps in the kinds of features they support.
    Are they all more or less related? Or are they fundamentally distinct?
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ll wrap the *Using a class to encapsulate data and processing* recipe in
    [Chapter 6](text00070.html#page "Chapter 6. Basics of Classes and Objects") ,
    *Basics of Classes and Objects,* with this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: Use the nouns and verbs from the original story or problem statement to identify
    all of the classes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Look for overlaps in the feature sets of various classes. In many cases, the
    relationships will come directly from the problem statement itself. In our preceding
    example, a game can deal cards from a deck, or deal cards from a shoe. In this
    case, we might state one of these two views:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A shoe is a specialized deck that starts with multiple copies of the 52-card
    domain
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A deck is a specialized shoe with only one copy of the 52-card domain
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a small ontology that clarifies the relationships among the classes.
    There are several kinds of relationships.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Some classes are independent of each other. They''re linked for the purposes
    of implementing a user story. In our example a `Card` refers to a string for the
    suit. The two objects are independent of each other. Many cards will share a common
    suit string. These are ordinary references between objects and there are no special
    design considerations:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Aggregation** : Some objects are bound into collections, but the objects
    have a properly independent existence. Our `Card` objects might be aggregated
    into a `Hand` collection. When the game ends, the `Hand` objects can be deleted,
    but the `Card` objects continue to exist. We might create a `Deck` that refers
    to a built-in `list` .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Composition** : Some objects are bound into collections, but do not have
    an independent existence. When looking at card games, a `Hand` of cards cannot
    exist without a `Player` . We might say that a `Player` object is composed—in
    part—of a `Hand` . If a `Player` is eliminated from a game, then the `Hand` objects
    must also be removed. While this is important for understanding the relationships
    among objects, there are some practical considerations that we''ll look at in
    the next section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Is-a or inheritance** : This is the idea that a `Shoe` is a `Deck` with an
    extra feature (or two). This may be central to our design. We''ll look into this
    in detail in the *Extending – inheritance* section of this recipe.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We've identified several paths for implementing the associations. The aggregation
    and composition cases are both wrap techniques. The inheritance case is the extend
    technique. We'll look at aggregation and composition—both wrapping techniques
    and extending techniques—separately.
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping – aggregation and composition
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Wrapping is a way to understand a collection. It can be a class that is an aggregate
    of independent objects. It's also a composition that wraps an existing list, meaning
    that the underlying `Card` objects will be shared by a `list` collection and a
    `Deck` collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Define the independent collection. It might be a built-in collection, for example,
    a `set` , `list` , or `dict` . For this example, it will be a list that contains
    the cards:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the aggregate class. For this example, the name has a `_W` suffix. This
    is not a recommended practice; it''s only used here to make the distinctions between
    class definitions more clear. Later, we''ll see a slightly different variation
    on this design:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `__init__()` method of this class as one way to provide the underlying
    collection object. This will also initialize any stateful variables. We might
    create an iterator for dealing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This uses a type hint, `List[Card]` . The `typing` module provides the necessary
    definition of `List` .
  prefs: []
  type: TYPE_NORMAL
- en: If needed, provide other methods to either replace the collection, or update
    the collection. This is rare in Python, since the underlying attribute, `cards`
    , can be accessed directly. However, it might be helpful to provide a method that
    replaces the `self.cards` value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Provide the methods appropriate to the aggregate object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `shuffle()` method randomizes the internal list object, `self.cards` . The
    `deal()` object creates an iterator that can be used to step through the `self.cards`
    list. We've provided a type hint on `deal()` to clarify that it returns a `Card`
    instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how we can use this class. We''ll be sharing a list of `Card` objects.
    In this case, the `domain` variable was created from a list comprehension that
    generated all 52 combinations of 13 ranks and four suits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use the items in this collection, `domain` , to create a second aggregate
    object that shares the same underlying `Card` objects. We''ll build the `Deck_W`
    object from the list of objects in the `domain` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the `Deck_W` object is available, it''s possible to use the unique features:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We've seeded the random number generator to force the cards to have a defined
    order. That makes unit testing possible. After that, we shuffled the deck into
    an order based on the random seed. Once the seed is sown, the results are consistent,
    making unit testing easy. We can deal five cards from the deck. This shows how
    the `Deck_W` object, `d` , shares the same pool of objects as the `domain` list.
  prefs: []
  type: TYPE_NORMAL
- en: We can delete the `Deck_W` object, `d` , and create a new deck from the `domain`
    list. This is because the `Card` objects are not part of a composition. The cards
    have an independent existence from the `Deck_W` collection.
  prefs: []
  type: TYPE_NORMAL
- en: Extending - inheritance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here''s an approach to defining a class that extends a collection of objects.
    We''ll define a `Deck` as an aggregate that wraps an existing list. The underlying
    `Card` objects will be shared by a list and a `Deck` :'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define the extension class as a subclass of a built-in collection. For this
    example, the name has a `_X` suffix. This not a recommended practice; it''s only
    used here to make the distinctions between two class definitions in this recipe
    more clear:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This is a clear and formal statement—a `Deck` is a list.
  prefs: []
  type: TYPE_NORMAL
- en: Use the `__init__()` method inherited from the `list` class. No code is needed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use other methods of the `list` class for adding, changing, or removing items
    from the `Deck` . No code is needed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Provide the appropriate methods to the extended object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `shuffle()` method randomizes the object as a whole, `self` , because it
    is an extension of the list. The `deal()` object creates an iterator that can
    be used to step through the `self.cards` list. We've provided a type hint on `deal()`
    to clarify that it returns a `Card` instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how we can use this class. First, we''ll build a deck of cards:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We used a generator expression to build individual `Card` objects. We can use
    the `Deck_X()` class function exactly the way we'd use the `list()` class function.
    In this case, we built a `Deck_X` object from the generator expression. We could
    build a `list` similarly.
  prefs: []
  type: TYPE_NORMAL
- en: We did not provide an implementation for the built-in `__len__()` method. This
    was inherited from the `list` class, and works nicely.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the deck-specific features for this implementation looks exactly like
    the other implementation, `Deck_W` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We've seeded the random number generator, shuffled the deck, and dealt five
    cards. The extension methods work as well for `Deck_X` as they do for `Deck_W`
    . The `shuffle()` and `deal()` methods do their jobs.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Python''s mechanism for finding a method (or attribute) works like this:'
  prefs: []
  type: TYPE_NORMAL
- en: Search in the class for the method or attribute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the name is not defined in the immediate class, then search in all of the
    parent classes for the method or attribute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This is how Python implements the idea of inheritance. Searching through the
    parent classes assures two things:'
  prefs: []
  type: TYPE_NORMAL
- en: Any method defined in any superclass is available to all subclasses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any subclass can override a method to replace a superclass method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because of this, a subclass of the `list` class inherits all the features of
    the parent class. It is a specialized variation of the built-in `list` class.
  prefs: []
  type: TYPE_NORMAL
- en: This also means that all methods have the potential to be overridden by a subclass.
    Some languages have ways to lock a method against extension. The word `private`
    is used by languages such as C++ and Java. Python doesn't have this, a subclass
    can override any method.
  prefs: []
  type: TYPE_NORMAL
- en: 'To explicitly refer to methods from a superclass, we can use the `super()`
    function to force a search through the superclasses. This allows a subclass to
    add features by wrapping the superclass version of a method. We use it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the `some_method()` object will do something extra and then do
    the superclass version of the method. This allows us a handy way to extend selected
    methods of a class. We can preserve the superclass features while adding features
    unique to the subclass.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When designing a class, we must choose between the several essential techniques:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Wrapping** : This technique creates a new class. All of the required methods
    must be defined. This can be a lot of code to provide the required methods. Wrapping
    can be decomposed into two broad implementation choices:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Aggregation** : The objects being wrapped have an independent existence from
    the wrapper. The `Deck_W` example showed how the `Card` objects and even the list
    of cards were independent from the class. When any `Deck_W` object is deleted,
    the underlying list will continue to exist.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Composition** : The objects being wrapped don''t have any independent existence;
    they''re an essential part of the composition. This involves a subtle difficulty
    because of Python''s reference counting. We''ll look at this shortly in some detail.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Extension via inheritance** : This is the is-a relationship. When extending
    a built-in class, then a great many methods are available from the superclass.
    The `Deck_X` example showed this technique by creating a deck as an extension
    to the built-in `list` class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When looking at independent existence of objects, there's an important consideration.
    We don't really remove objects from memory. Instead, Python uses a technique called
    reference counting to track how many times an object is used. A statement such
    as `del deck` doesn't really remove the `deck` object, it removes the `deck` variable,
    which decrements the reference count for the underlying object. If the reference
    count is zero, the object is not used and can be removed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: At this point, we have an object, `Card(2, Spades)` , and two variables that
    refer to the object—`c_2s` and `another` .
  prefs: []
  type: TYPE_NORMAL
- en: If we remove one of those variables with the `del` statement, the other variable
    still has a reference to the underlying object. The object can't be removed from
    memory until both variables are removed.
  prefs: []
  type: TYPE_NORMAL
- en: This consideration makes the distinction between aggregation and composition
    mostly irrelevant for Python programmers. In languages that don't use automatic
    garbage collection or reference counters, then composition becomes important because
    objects may vanish. In Python, objects can't vanish unexpectedly. We generally
    focus on aggregation because removal of unused objects is entirely automatic.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We've looked at the built-in collections in [Chapter 4](text00048.html#page
    "Chapter 4. Built-in Data Structures – list, set, dict") , *Built-in Data Structures
    – list, set, dict* . Also, in [Chapter 6](text00070.html#page "Chapter 6. Basics
    of Classes and Objects") , *Basics of Classes and Objects* , we looked at how
    to define simple collections.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the  *Designing classes with lots of processing* recipe, we looked at wrapping
    a class with a separate class that handles the processing details. We can contrast
    this with the *Using properties for lazy attributes* recipe of [Chapter 6](text00070.html#page
    "Chapter 6. Basics of Classes and Objects") , *Basics of Classes and Objects*
    , where we put the complex computations into the class as properties; this design
    relies on extension.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Separating concerns via multiple inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the *Choosing between inheritance and extension – the is-a question* recipe,we
    looked at the idea of defining a `Deck` class that was a composition of playing
    card objects. For the purposes of that example, we treated each `Card` object
    as simply having a rank and a suit. This created a number of small problems:'
  prefs: []
  type: TYPE_NORMAL
- en: The display for the card always showed a numeric rank. We didn't see J, Q, or
    K. Instead we saw 11, 12, and 13\. Similarly, an Ace was shown as 1 instead of
    A.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many games, such as, *Blackjack* and *Cribbage* assign a point value to each
    rank. Generally, the face cards have 10 points. For Blackjack, an Ace has two
    different point values; depending on the total of other cards in the hand, it
    can be worth one point or ten points.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can we handle all of the variations in card game rules?
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Card` class is really a mixture of two feature sets:'
  prefs: []
  type: TYPE_NORMAL
- en: Some essential features, such as rank and suit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Some game-specific features, such as the number of points. For a game such as
    *Cribbage* , the points are consistent regardless of any context. For *Blackjack*
    , however, there's a relationship between a `Hand` and the `Card` objects within
    a `Hand` .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Python lets us define a class that has multiple parents. A class can have both
    a `Card` superclass and a `GameRules` superclass.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to make sense of this kind of design, we''ll often partition the various
    class hierarchies into two sets of features:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Essential features** : This includes `rank` and `suit`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mixin features** : These features are mixed into the class definition'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The idea is that a working class definition will have both essential and mixin
    features.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Define the essential class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We've defined a generic `Card` class that is suitable for ranks two to ten.
    We've included an explicit call to any superclass initialization via `super().__init__()`
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'Define any subclasses to handle specializations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We've defined two subclasses of the `Card` class. The `AceCard` class handles
    the special formatting rules for an Ace. The `FaceCard` class handles other formatting
    rules for Jack, Queen, and King.
  prefs: []
  type: TYPE_NORMAL
- en: 'Define a mixin superclass that identifies the additional features that will
    be added. In some cases, the mixins will all inherit features from a common abstract
    class. In this example, we''ll use a concrete class that handles the rules for
    Ace through 10:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: For the game of *Cribbage* , the points for most cards are equal to the rank
    of the card.
  prefs: []
  type: TYPE_NORMAL
- en: 'Define concrete mixin subclasses for the various kinds of features:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: For the three ranks of face cards, the points are always 10.
  prefs: []
  type: TYPE_NORMAL
- en: Create the class definitions that combine the essential classes and the mixin
    classes. While it's technically possible to add unique method definitions here,
    that often leads to confusion. The goal is to have two separate sets of features
    that are simply merged to create the resulting class definition.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a factory function (or factory class) to create the appropriate objects
    based the on input parameters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use this function to create a deck of cards like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We've seeded the random number generator to assure that the results are the
    same each time we evaluate the `shuffle()` function. This makes unit testing possible.
  prefs: []
  type: TYPE_NORMAL
- en: We use a list comprehension to generate a list of cards that include all 13
    ranks and four suits. This is a collection of 52 individual objects. The objects
    belong to two class hierarchies. Each object is a subclass of `Card` as well as
    being a subclass of `CribbagePoints` . This means that both collections of features
    are available for all of the objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can evaluate the `points()` method of each `Card` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The hand has two face cards, plus three, six, and Ace, so the total points are
    `30` .
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Python''s mechanism for finding a method (or attribute) works like this:'
  prefs: []
  type: TYPE_NORMAL
- en: Search in the class for the method or attribute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the name is not defined in the immediate class, then search in all of the
    parent classes for the method or attribute. The parent classes are searched in
    a sequence called appropriately, the **Method Resolution Order** ( **MRO** ).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The method resolution order is computed when the class is created. The algorithm
    used is called C3\. More information is available at [https://en.wikipedia.org/wiki/C3_linearization](https://en.wikipedia.org/wiki/C3_linearization)
    . This algorithm assures that each parent class is searched once. It also assures
    that the relative ordering of superclasses is preserved so that all subclasses
    tend to be searched before any of their parent classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see the method resolution order using the `mro()` method of a class.
    Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We picked a card from the deck, `c` . The card''s `__class__` attribute is
    a reference to the class. In this case, the class name is `CribbageCard` . The
    `mro()` method of this class shows us the order that''s used to resolve names:'
  prefs: []
  type: TYPE_NORMAL
- en: First search the class itself, `CribbageCard` .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If it's not there, search `Card` .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Try to find it in `CribbagePoints` next.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use `object` last.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Class definitions generally use internal `dict` objects to store the method
    definitions. This means that the search is a hash lookup that is extremely fast.
    The overhead difference is about 3% more time to search `object` (when something's
    not found in any of the previous classes) than to search `Card` .
  prefs: []
  type: TYPE_NORMAL
- en: 'If we do one million operations, we see numbers such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We compared the time to find `__repr__()` , defined in `Card` , against the
    time to find `__str__()` , defined in `object` . The extra time summed over a
    million repetitions is 0.03 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Since the cost is negligible, this capability is an important way to structure
    the design of a class hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are several kinds of concerns, that we can separate like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Persistence and representation of state** : We might add methods to manage
    conversion to a consistent external representation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security** : This may involve a mixin class that performs a consistent authorization
    check that becomes part of each object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Logging** : A mixin class that creates a logger that''s consistent across
    a variety of classes might be defined.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Event signaling and change notification** : In this case, we might have objects
    that produce state change notifications and objects that will subscribe to those
    notifications. These are sometimes called the observable and observer design patterns.
    A GUI widget might observe the state of an object; when the object changes, it
    notifies the GUI widget so that the display is refreshed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a small example, we could add a mixin to introduce logging. We'll define
    this class so that it must be provided first in the list of superclasses. Since
    it's early in the MRO list, the `super()` function will find methods defined later
    in the list of classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'This class will add the `logger` attribute to each class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Note that we've used `super().__init__()` to perform the `__init__()` method
    of any other classes defined in the MRO. As we just noted, it's generally the
    simplest approach to have one class that defines the essential features of an
    object, and all other mixins simply add features to that object.
  prefs: []
  type: TYPE_NORMAL
- en: We've provided a definition for `points()` . This will search other classes
    in the MRO list for an implementation of `points()` . Then it will log the results
    computed by the method from another class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some classes that include the `Logged` mixin features:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Each of these classes are built from a three separate class definitions. Since
    the `Logged` class is provided first, we're assured that all classes have consistent
    logging. We're also assured that any method in `Logged` can use `super()` to locate
    an implementation in the superclass list that follows it in the class definition.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make use of these classes, we''d need to make one more small change to an
    application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We need to use this function instead of `make_card()` . This function will use
    the other set of class definitions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how we use this function to build a deck of card instances:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We've replaced `make_card()` with `make_logged_card()` when creating a deck.
    Once we do this, we now have detailed debugging information available from a number
    of classes in a consistent fashion.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When considering multiple inheritance, it's always essential to also consider
    whether or not a wrapper is a better design. See the *Choosing between inheritance
    and extension – the is-a question* recipe.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leveraging Python's duck typing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most of the time that a design involves inheritance, there's a clear relationship
    from a superclass to one or more subclasses. In the *Choosing between inheritance
    and extension – the is-a question* recipe of this chapter as well as the  *Extending
    a collection – a list that does statistics*  recipe in [Chapter 6](text00070.html#page
    "Chapter 6. Basics of Classes and Objects") , *Basics of Classes and Objects*
    , we've looked at extensions that involve a proper subclass-superclass relationship.
  prefs: []
  type: TYPE_NORMAL
- en: Python doesn't have a formal mechanism for abstract superclasses. The standard
    library, however, has the `abc` module that supports the creation of abstract
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'This isn''t always necessary, however. Python relies on duck typing to locate
    methods within a class. This name comes from the quote:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"When I see a bird that walks like a duck and swims like a duck and quacks
    like a duck, I call that bird a duck."*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The quote is originally from James Whitcomb Riley. It''s sometimes taken as
    a summary of **abductive reasoning** : we go from an observation to a more complete
    theory that includes that observation. In the case of Python class relationships,
    if two objects have the same methods, and the same attributes, this has the same
    effect as having a common superclass. It works even if there''s no common superclass
    definition other than the `object` class.'
  prefs: []
  type: TYPE_NORMAL
- en: We can call the collection of methods and attributes the signature of a class.
    The signature uniquely identifies the class's properties and behaviors. In Python,
    the signature is dynamic, and the matching is simply a matter of doing a lookup
    for a name within an object's namespace.
  prefs: []
  type: TYPE_NORMAL
- en: Can we exploit this?
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It's often easy to create a superclass and be sure that all subclasses extend
    this class. In some cases, though, this can be awkward. For example, if an application
    is spread across several modules, it might be challenging to factor out a common
    superclass and put this by itself in a separate module so that it can be included
    widely.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, it's sometimes easier to avoid a common superclass and simply check
    that two classes are both equivalent using the duck test—the two classes have
    the same methods and attributes, therefore, they are effectively members of some
    superclass that has no formal realization as Python code.
  prefs: []
  type: TYPE_NORMAL
- en: We'll use a simple pair of classes to show how this works. These classes will
    both simulate rolling a pair of dice. While the problem is simple, we can easily
    create a variety of implementations.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Define a class with the required methods and attributes. In this example, we''ll
    have one attribute, `dice` , that retains the result of the last roll, and one
    method, `roll()` , that changes the state of the dice:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Define other classes that have the same methods and attributes. Here''s a somewhat
    more complex definition that creates a class that has the same signature as the
    `Dice1` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This class introduces an additional attribute, `_dice` . This change in implementation
    doesn't change the advertised interface of a single attribute, `dice` , and method,
    `roll()` .
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, the two classes can be interchanged freely:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use this function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The objects built from `Dice1` and `Dice2` have enough similarities that they're
    indistinguishable.
  prefs: []
  type: TYPE_NORMAL
- en: We can, of course, push the envelope and look for the `_dice` attribute as a
    way to distinguish between the two classes. We can also use `__class__` to distinguish
    between the classes.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When we write an expression of the form `namespace.name` , Python will look
    up the name within the given namespace. The algorithm works like this:'
  prefs: []
  type: TYPE_NORMAL
- en: Search the object's `self.__dict__` collection for the name. Some class definitions
    will save space, using `__slots__` . See the *Optimizing small objects with __slots__*
    recipe in [Chapter 6](text00070.html#page "Chapter 6. Basics of Classes and Objects")
    , *Basics of Classes and Objects* , for more on this optimization. This is generally
    how attribute values are found.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Search the object's `self.__class__.__dict__` collection for the name. This
    is generally how methods are found.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As we noted in the *Choosing between inheritance and extension - the is-a question*
    and *Separating concerns via multiple inheritance* recipes, the search can continue
    through all of the superclasses of the class. This search is done in the defined
    method resolution order.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'There are two essential outcomes:'
  prefs: []
  type: TYPE_NORMAL
- en: The value is an object that's not callable. This is the value. This is typical
    of attributes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The value of the attribute is a bound method of a class. This is true for both
    ordinary methods and properties. See the *Using properties for lazy attributes*
    recipe in [Chapter 6](text00070.html#page "Chapter 6. Basics of Classes and Objects")
    , *Basics of Classes and Objects* , for more information on properties. The bound
    method must be evaluated. For simple methods, the arguments are in `()` after
    the method name. For properties, there are no `()` with method argument values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We've elided some details about how descriptors are used. For the most common
    use cases, the presence of the descriptor isn't important.
  prefs: []
  type: TYPE_NORMAL
- en: The essence of this is the search through `__dict__` (or `__slots__` ) collections
    of names. If objects have a common superclass, then we can guarantee that a matching
    name will be found. If objects do not have a common superclass, then we don't
    have the same kind of guarantee. We have to rely on disciplined design and good
    test coverage.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we look at the `decimal` module we see an example of a numeric type that
    is distinct from all of the other numeric types. In order to make this work out
    well, the `numbers` module includes a concept of registering a class as a part
    of the `Number` class hierarchy. This injects a new class into the hierarchy without
    using inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: A similar technique is used by the `codecs` module to add new data encodings.
    We can define a new encoding and register it without using any of the classes
    defined in the `codecs` module.
  prefs: []
  type: TYPE_NORMAL
- en: Previously, we noted that the search for a method of a class involves the concept
    of a descriptor. Internally, Python uses descriptor objects to create gettable
    and settable properties of an object.
  prefs: []
  type: TYPE_NORMAL
- en: A descriptor object must implement some combination of the special methods `__get__`
    , `__set__` , and `__delete__` . When the attribute appears in an expression,
    then `__get__` will be used to locate the value. When the attribute appears on
    the left side of an assignment, then `__set__` is used. In a `del` statement,
    the `__delete__` method is used.
  prefs: []
  type: TYPE_NORMAL
- en: The descriptor object acts as an intermediary so that a simple attribute can
    be used in a variety of contexts. It's rare to use descriptors directly. We can
    use the `@property` decorator to build descriptors for us.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The duck type question is implicit in the *Choosing between inheritance and extension
    – the is-a question* recipe; if we leverage duck typing, we're also making a claim
    that two classes are not the same thing. When we bypass inheritance, we are implicitly
    claiming that the is-a relationship doesn't hold.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When looking at the *Separating concerns via multiple inheritance* recipe, we're
    also able to leverage duck typing to create composite classes that may not have
    a simple inheritance hierarchy. Since it's very simple to use the mixin design
    pattern, duck typing is rarely needed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing global and singleton objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Python environment contains a number of implicit global objects. These objects
    provide a convenient way to work with a collection of other objects. Because the
    collection is implicit, we're saved from the annoyance of an explicit initialization
    code.
  prefs: []
  type: TYPE_NORMAL
- en: One example of this is an implicit random number generating object that's part
    of the `random` module. When we evaluate `random.random()` , we're actually making
    use of an instance of the `random.Random` class that's an implicit part of the
    `random` module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Other examples of this include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The collection of numeric types available. By default, we only have `int` ,
    `float` , and `complex` . We can, however, add more numeric types, and they will
    work seamlessly with existing types. There's a global registry of available numeric
    types.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The collection of data code/decode methods (codecs) available. The `codecs`
    module lists the available encoders and decoders. This also involves an implicit
    registry. We can add encodings and decodings to this registry.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `webbrowser` module has a registry of known browsers. For the most part,
    the operating system default browser is the one preferred by the user and the
    right one to use, but it's possible for an application to launch a browser other
    than the user's preferred browser. It's also possible to register a new browser
    that's unique to an application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can we work with this kind of implicit global object?
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Generally, an implicit object can cause some confusion. The idea is to provide
    a suite of features as separate functions rather than methods of an object. The
    benefit, however, is to allow independent modules to share a common object without
    having to write any code that explicitly coordinates between the modules.
  prefs: []
  type: TYPE_NORMAL
- en: For a simple example, we'll define a module that will have a global singleton
    object. We'll look more at modules in [Chapter 13](text00137.html#page "Chapter 13. Application
    Integration") ,  *Application integration* .
  prefs: []
  type: TYPE_NORMAL
- en: Our global object will be a counter that we can use to accumulate centralized
    data from several independent modules or objects. We'll provide an interface to
    this object using simple functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The goal is to be able to write something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This implies two functions that will refer to a global counter:'
  prefs: []
  type: TYPE_NORMAL
- en: '`count()` : It will increment the counter and return the current value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`counts()` : It will provide all of the various counter values'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are two ways to do handle global state information. One technique uses
    a module global variable because modules are singleton objects. The other uses
    a class level (static) variable because a class definition is a singleton object,
    also we'll show both techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Module global variable
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Create a module file. This will be a `.py` file with the definitions in it.
    We'll call it `counter.py` .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If necessary, define a class for the global singleton. In our case, we can
    use this definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: In some cases, a `types.SimpleNamespace` might be used. In other cases, a more
    complex class with methods as well as attributes may be necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Define the one and only instance of the global singleton object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: We've used a leading `_` in the name to make it slightly less visible. It's
    not—technically—private. It is, however, gracefully ignored by many Python tools
    and utilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'Define any wrapper functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: We've defined two functions that use the global object, `_global_counter` .
    These functions encapsulate a detail of how the counter is implemented.
  prefs: []
  type: TYPE_NORMAL
- en: Now we can write applications that use the `count()` function in a variety of
    places. The counted events, however, are fully centralized into this single object.
  prefs: []
  type: TYPE_NORMAL
- en: 'We might have code that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: We've imported the `count()` and `counts()` functions from a central module.
    We've also imported the `Dice1` object as a handy object that we can use to create
    a sequence of events. When we create an instance of `Dice1` , we provide an initialization
    to force a particular random seed. This gives repeatable results.
  prefs: []
  type: TYPE_NORMAL
- en: We can then use the object, `d` , to create random events. For this demonstration,
    we've categorized the events into two simple buckets, labeled `seven` and `other`
    . The `count()` function uses an implied global object.
  prefs: []
  type: TYPE_NORMAL
- en: When the simulation is done, we can dump the results using the `counts()` function.
    This will access the global object defined in the module.
  prefs: []
  type: TYPE_NORMAL
- en: The benefit of this technique is that several modules can all share the global
    object within the `ch07_r04` module. All that's required is an `import` statement.
    No further coordination or overheads are necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Class-level static variable
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Define a class and provide a variable outside the `__init__` method. This variable
    is part of the class, not part of each individual instance. It''s shared by all
    instances of the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: We've given the class-level variable a leading underscore to make it less public.
    This is a note to anyone using the class that the attribute is an implementation
    detail that might change. It's not part of the visible interface to the class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add methods to update and extract data from this variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: We didn't use `self` in this example to make a point about variable assignment
    and instance variables. When we use `self.name` on the right side of an assignment
    statement, the name may be resolved by the object, or the class, or any superclass.
    This is the ordinary rule for searching a class.
  prefs: []
  type: TYPE_NORMAL
- en: When we use `self.name` on the left side of assignment, that will create an
    instance variable. We must use `Class.name` to be sure that a class-level variable
    is updated instead of creating an instance variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The various application components can create objects, but the objects all
    share a common class level value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we've created three separate objects, `c1` , `c2` , and `c3`
    . Since all three share a common variable, defined in the `EventCounter` class,
    each can be used to increment that shared variable. These objects could be part
    of separate modules, separate classes, or separate functions, yet still share
    a common global state.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Python import mechanism uses `sys.modules` to track which modules are loaded.
    Once a module is in this mapping, it is not loaded again. This means that any
    variable defined within a module will be a singleton: there will only be one instance.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We have two ways to share these kinds of global singleton variables:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the module name, explicitly. We could have simply created an instance
    of `Counter` in the module and shared this via `counter.counter` . This can work,
    but it exposes an implementation detail.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using wrapper functions, as shown in this recipe. This requires a little more
    code, but it permits a change in implementation without breaking other parts of
    the application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The functions provide a way to identify relevant features of the global variable,
    while encapsulating details of how it's implemented. This gives us the freedom
    to consider changing the implementation details. As long as the wrapper functions
    have the same semantics, the implementation can be changed freely.
  prefs: []
  type: TYPE_NORMAL
- en: Since we generally provide only one definition of a class, the Python import
    mechanism tends to assure us that the class definition is a proper singleton object.
    If we make the mistake of copying a class definition, and pasting it into two
    or more modules used by a single application, we would not share a single global
    object among these class definitions. This is an easy mistake to avoid.
  prefs: []
  type: TYPE_NORMAL
- en: How can we choose between these two mechanisms? The choice is based on the degree
    of confusion created by having multiple classes sharing a global state. As shown
    in the previous example, three variables share a common `Counter` object. The
    presence of an implicitly shared global state can be confusing.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A shared global state is in a way the opposite of object-oriented programming.
    One ideal of object-oriented programming is to encapsulate all state changes in
    individual objects. When we have a shared global state, we have strayed from this
    ideal:'
  prefs: []
  type: TYPE_NORMAL
- en: Using wrapper functions makes the shared object implicit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a class-level variable conceals the fact that an object is shared
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The alternative, of course, is to create a global object explicitly, and make
    it part of the application in some more obvious way. This might mean providing
    the object as an initialization parameter to objects throughout the application.
    This can be a fairly large burden in a complex application.
  prefs: []
  type: TYPE_NORMAL
- en: Having a few shared global objects is more appealing because the application
    becomes simpler. When these objects are used for pervasive features such as audits,
    logging, and security, they can be helpful.
  prefs: []
  type: TYPE_NORMAL
- en: This is a technique that is open for abuse. A design that relies on too many
    global objects can be confusing. It can also harbor subtle bugs because the encapsulation
    of objects in classes may be difficult to discern. It may also make unit test
    cases hard to write because of the implicit relationships among objects.
  prefs: []
  type: TYPE_NORMAL
- en: '![](image/614271.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Using more complex structures – maps of lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 4](text00048.html#page "Chapter 4. Built-in Data Structures – list,
    set, dict") , *Built-in Data Structures – list, set, dict* , we looked at the
    basic data structures available in Python. The recipes generally looked at the
    various structures in isolation.
  prefs: []
  type: TYPE_NORMAL
- en: We'll look at a common combination structure—the mapping from a key to a list.
    This is used to accumulate detailed information about an object identified by
    a given key. This recipe will transform a flat list of details into a structure
    that for one column contains values taken from other columns.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll work with an imaginary web log that's been transformed from the raw web
    format to a **CSV** ( **comma-separated value** ) format. This kind of transformation
    is often done with a regular expression that picks out the various syntactic groups.
    See the *String parsing with regular expressions* recipe in [Chapter 1](text00014.html#page
    "Chapter 1. Numbers, Strings, and Tuples") , *Numbers, Strings, and Tuples* ,
    for information on how the parsing might work.
  prefs: []
  type: TYPE_NORMAL
- en: 'The raw data looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Each line in the file has a timestamp, a severity level, a module name, and
    some text. After parsing, the data is effectively a flat list of events. It looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: We'd like to examine the log, creating a list of all the messages organized
    by module, instead of sequentially through time. This kind of restructuring can
    make analysis simpler.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Import `defaultdict` from `collections` :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `list` function as the default value for `defaultdict` :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Iterate through the data, appending to the list associated with each key. The
    `defaultdict` object will use the `list()` function to build an empty list for
    each new key:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of this will be a dictionary that maps from a module to a list of
    all log rows for that module name. The data will look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The key for this mapping is the module name and the value in the mapping is
    the list of rows for that module name. We can now focus the analysis on a specific
    module.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two choices for how a mapping behaves when a key is not found:'
  prefs: []
  type: TYPE_NORMAL
- en: The built-in `dict` class raises an exception when a key is missing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The class `defaultdict` evaluates a function that creates a default value when
    a key is missing. In many cases, the function is `int` or `float` to create a
    default numeric value. In this case, the function is `list` to create an empty
    list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can imagine using the `set` function to create an empty `set` object for
    a missing key. This would be suitable for a mapping from a key to a set of objects
    that share that key.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When we think about Python 3.5 and the ability to do type inferencing, we need
    to have a way to describe this structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: This uses the notation `Mapping[str, List]` to show that the result is a mapping
    from string keys to a list of string data items.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also build a version of this as an extension to the built-in `dict`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: We've defined a method that's unique to this class, `add_event()` . This will
    add the empty list if the key, the module name in `event[2]` , is not currently
    present in the dictionary. After the `if` statement, a postcondition could be
    added to assert that the key is now in the dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: 'This allows us to use code such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The resulting structure is very similar to `defaultdict` .
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the *Creating dictionaries – inserting and updating* recipe in [Chapter 4](text00048.html#page
    "Chapter 4. Built-in Data Structures – list, set, dict") , *Built-in Data Structure
    – list, set, dict* , we looked at the basics of using a mapping
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the *Avoiding mutable default values for function parameters* recipe of [Chapter
    4](text00048.html#page "Chapter 4. Built-in Data Structures – list, set, dict")
    , *Built-in Data Structure – list, set, dict* , we looked at other places where
    default values are used
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the *Using more sophisticated collections* recipe of [Chapter 6](text00070.html#page
    "Chapter 6. Basics of Classes and Objects") , *Basics of Classes and Objects*
    , we looked at other examples of using the `defaultdict` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a class that has orderable objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When simulating card games, it's often essential to be able to sort the `Card`
    objects into a defined order. When cards form a sequence, sometimes called a straight,
    this can be an important way to score the hand. This is part of games such as
    Poker, Cribbage, and even Pinochle.
  prefs: []
  type: TYPE_NORMAL
- en: Most of our class definitions have not included the features necessary for sorting
    objects into order. Many of the recipes have kept objects in mappings or sets
    based on the internal hash value computed by `__hash__()` .
  prefs: []
  type: TYPE_NORMAL
- en: In order to keep items in a sorted collection, we'll need the comparison methods
    that implement `<` , `>` , `<=` , `>=` , `==` , and `!=` . These comparisons are
    based on the attribute values of each object.
  prefs: []
  type: TYPE_NORMAL
- en: How do we create comparable objects?
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The game of Pinochle generally involves a deck with 48 cards. There are six
    ranks—9, 10, Jack, Queen, King, and Ace. There are the standard four suits. Each
    of these 24 cards appears twice in the deck. We have to be careful of using a
    structure such as a dict or set because cards are not unique in Pinochle; there
    can be duplicates.
  prefs: []
  type: TYPE_NORMAL
- en: In the *Separating concerns via multiple inheritance* recipe, we defined playing
    cards using two class definitions. The `Card` class hierarchy defined essential
    features of each card. A second set of mixin classes provided game specific features
    for each card.
  prefs: []
  type: TYPE_NORMAL
- en: We'll need to add features to those cards to create objects that can be ordered
    properly. In order to support the *Defining an ordered collection* recipe, we'll
    look at cards for the game of Pinochle.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the first two elements of the design:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: We've imported the existing `Card` hierarchy. We've also defined a rule for
    computing the points for each card taken in a trick during play, the `PinochlePoints`
    class. This has a mapping from card ranks to the potentially confusing points
    for each card.
  prefs: []
  type: TYPE_NORMAL
- en: A 10 is worth 10 points, and an Ace is worth 11 points, but the King, Jack,
    and Queen are worth four, three, and two points respectively. This can be confusing
    for new players.
  prefs: []
  type: TYPE_NORMAL
- en: Because an Ace ranks above a King for purposes of identifying a straight, we've
    made the rank of the Ace 14\. This slightly simplifies the processing.
  prefs: []
  type: TYPE_NORMAL
- en: In order to use a sorted collection of cards, we need to add yet another feature
    to the cards. We'll need to define the comparison operations. There are six special
    methods used for object comparison.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''re using a mixin design. Therefore, we''ll create a new class to hold the
    comparison features:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: This class will join a member of the `Card` hierarchy plus the `PinochlePoints`
    to create the final composite class definition.
  prefs: []
  type: TYPE_NORMAL
- en: 'Define the six comparison methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: We've written all six comparisons out in full. We've converted the relevant
    attributes of a `Card` into a tuple, and relied on Python's built-in tuple comparison
    to handle the details.
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the composite class definitions, built from an essential class and two
    mixin classes to provide additional features:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The final class contains elements with three separate, and largely independent
    feature sets: the essential `Card` features, the mixin comparison features, and
    the mixin Pinochle specific features.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a function that will create individual card objects from the classes
    defined previously:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Even though the point rules are dauntingly complex, the complexity is hidden
    in the `PinochlePoints` class. Building composite classes as a base subclass of
    `Card` plus `PinochlePoints` leads to an accurate model of the cards without too
    much overt complexity.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now make cards that respond to comparison operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s a function that builds the 48-card deck:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The value of `SUITS` is four Unicode characters. We could have set each suit
    string separately, but this seems slightly simpler. The generator expression inside
    the `make_deck()` function builds two copies of each card. There are only six
    ranks and four suits.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python uses special methods for a vast number of things. Almost every visible
    behavior in the language is due to some special method name. In this recipe, we've
    leveraged the six comparison operators.
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code is evaluated as if we''d written the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: This kind of transformation happens for all of the expression operators.
  prefs: []
  type: TYPE_NORMAL
- en: 'Careful study of *Section 3.3* of the *Python Language Reference* shows that
    the special methods can be organized into several distinct groups:'
  prefs: []
  type: TYPE_NORMAL
- en: Basic customization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customizing attribute access
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customizing class creation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customizing instance and subclass checks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Emulating callable objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Emulating container types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Emulating numeric types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With statement context managers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this recipe, we've looked at only the first of these categories. The others
    follow some similar design patterns.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how it looks when we create instances of this class hierarchy. The
    first example will create a 48-card Pinochle deck:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'If we look at the first eight cards, we can see how they''re built from all
    the combinations of rank and suit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'If we look at the second half of the deck, we can see that it has the same
    cards as the first half of the deck:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Since the `deck` variable is a simple list, we can shuffle the list object and
    pick a dozen cards.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: The important part is the use of the `sorted()` function. Because we've defined
    proper comparison operators, we can sort the `Card` instances, and they are presented
    in the expected order.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A little formal logic suggests that we really only need to implement two of
    the comparisons. With any two, all the others can be derived. For example, if
    we could only do the operations for less than (`__lt__()` ) and equal to (`__eq__()`
    ), we could compute the missing three fairly easily:'
  prefs: []
  type: TYPE_NORMAL
- en: '*a* ≤ *b* ≡ *a < b* ∨ *a* = *b*'
  prefs: []
  type: TYPE_NORMAL
- en: '*a* ≥ *b* ≡ *a > b* ∨ *a* = *b*'
  prefs: []
  type: TYPE_NORMAL
- en: '*a* ≠ *b* ≡ ¬( *a* = *b* )'
  prefs: []
  type: TYPE_NORMAL
- en: Python emphatically does not do any of this kind of advanced algebra for us.
    We need to do the algebra carefully, or if we're unsure of the logic, we can write
    out all six comparisons in full.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve assumed that each `Card` is compared against another card. Try this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: We'll get an `AttributeError` exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we need this feature, we''ll have to modify the comparison operators to
    handle two kinds of comparison:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Card` against `Card`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Card` against `int`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is done by using the `isinstance()` function to discriminate between the
    argument types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each of our comparison methods would be changed to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: This handles the `Card` against the `Card` case using rank and suit comparisons.
    For all other cases, Python's ordinary rules are used to compare the rank against
    the other value. If, for some obscure reason, the value of the other was `float`
    , then a `float()` conversion would be used on `self.rank` .
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See the *Defining an ordered collection* recipe that relies on sorting these
    cards into order
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining an ordered collection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When simulating card games, the player's hand can be modeled as a set of cards
    or a list of cards. With most conventional single-deck games, a set works out
    nicely because there's only one instance of any given card, and the set class
    can do very fast operations to confirm that a given card is (or is not) in the
    set.
  prefs: []
  type: TYPE_NORMAL
- en: When modeling Pinochle, however, we have a challenging problem. The Pinochle
    deck is 48 cards; it has two of 9, 10, Jack, Queen, King, and Ace. A simple set
    won't work well for this; we would need a multiset or bag. This is a set that
    permits duplicate items.
  prefs: []
  type: TYPE_NORMAL
- en: The operations are still limited to membership tests. For example, we can add
    the object `Card(9,'♢')` object more than once, and then also remove it more than
    one time.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have a number of ways to create a multiset:'
  prefs: []
  type: TYPE_NORMAL
- en: We can use a list. Appending an item has a nearly fixed cost, characterized
    as *O* (1). Searching for an item has a bad performance problem. The complexity
    of testing for membership tends to grow with the size of the collection. It becomes
    *O* (n).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can use a mapping; the value can be an integer count of the number of times
    a duplicated element shows up. This only requires that the default `__hash__()`
    method is available for each object in the mapping. We have three ways of implementing
    this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define our own subclass of dict.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use a `defaultdict` . See the *Using more complex structures - maps of lists*
    recipe, which uses `defaultdict(list)` to create a list of values for each key.
    The `len()` of this list is the number of times the key occurred. In effect, this
    is a kind of multiset.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use a `Counter` . This can be very simple. We've looked at `Counter` in a number
    of recipes. See the *Avoiding mutable default values for function parameters*
    recipe in [Chapter 4](text00048.html#page "Chapter 4. Built-in Data Structures
    – list, set, dict") , *Built-in Data Structures – list, set, dict* , also the
    *Designing classes with lots of processing* and *Using properties for lazy attributes*
    recipes in [Chapter 6](text00070.html#page "Chapter 6. Basics of Classes and Objects")
    , *Basics of Classes and Objects* , and the *Managing global and singleton objects*
    recipe of this chapter for other examples.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can use a sorted list. Inserting an item that maintains this sort sequence
    is slightly more expensive than inserting into a list, ***O*** ( *n* log *[2]
    n* ). Searching, however, is less expensive than an unsorted list; it's ***O***
    (log *[2] n* ). The `bisect` module provides a set of functions that do this nicely.
    This, however, requires objects with a full set of comparison methods.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can we build a sorted collection of objects? How can we build a multiset
    or bag using a sorted collection?
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the *Creating a class that has orderable objects* recipe, we defined cards
    that could be sorted. This is essential for using `bisect` . The algorithms in
    this module require a full set of comparisons among objects.
  prefs: []
  type: TYPE_NORMAL
- en: We'll define a multiset to keep 12-card Pinochle hands. Because of the duplication,
    there will be more than one card of a given rank and suit.
  prefs: []
  type: TYPE_NORMAL
- en: In order to view a hand as a kind of set, we'll also need to define some set
    operators on hand objects. The idea is to define set membership and subset operators.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''d like to have Python code that''s equivalent to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*c* ∈ *H*'
  prefs: []
  type: TYPE_NORMAL
- en: This is for a card, *c* , and a hand of cards, *H* = { *c* [1] *, c* [2] *,
    c* [3] *,...* }
  prefs: []
  type: TYPE_NORMAL
- en: 'We''d also like code equivalent to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '{ *J, Q* } ⊂ *H*'
  prefs: []
  type: TYPE_NORMAL
- en: This is for a specific pair of cards, called the Pinochle, and a hand of cards,
    *H* .
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll need to import two things:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: The first import brings in our orderable card definitions from the *Creating
    a class that has orderable objects* recipe. The second import brings in the various
    bisect functions that we'll use to maintain an ordered set with duplicates.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Define a class with an initialization that can load the collection from any
    iterable source of data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: We can use this to build a `Hand` from a list or possibly a generator expression.
    If the list is non-empty, we'll need to sort the items into order. The `sort()`
    method of the `self.cards` list will rely on the various comparison operators
    implemented by the `Card` objects.
  prefs: []
  type: TYPE_NORMAL
- en: Technically, we only care about objects that are subclasses of `SortedCard`
    , since that is where the comparison methods are defined.
  prefs: []
  type: TYPE_NORMAL
- en: 'Define a method to add cards to a hand:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: We've used the `bisect` algorithm to assure that the card is properly inserted
    into the `self.cards` list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Define a method to find the position of a given card in a hand:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: We've used the `bisect` algorithm for locating a given card. The additional
    `if` test is recommended in the documentation for `bisect.bisect_left()` to properly
    handle an edge case in the processing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Define the special method that implements the `in` operator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: When we write `card in some_hand` in Python, it's evaluated as if we had written
    `some_hand.__contains__(card)` . We've used the `index()` method to either find
    the card or raise an exception. The exception is transformed into a return value
    of `False` .
  prefs: []
  type: TYPE_NORMAL
- en: 'Define an iterator over the hand. This is a simple delegation to the `self.cards`
    collection:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: When we write `iter(some_hand)` in Python, it's evaluated as if we had written
    `some_hand.__iter__()` .
  prefs: []
  type: TYPE_NORMAL
- en: 'Define a subset operation between two hand instances:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Python doesn't have the *a* ⊂ *b* or *a* ⊆ *b* symbols, so < and <= are pressed
    into service for comparing sets. When we write `pinochle <= some_hand` to see
    if the hand contains a specific combination of cards, it's evaluated as if we'd
    written `pinochle.__le__(some_hand)` . The subset is the `self` instance variable,
    and the target `Hand` is the other parameter value.
  prefs: []
  type: TYPE_NORMAL
- en: The in operator is implemented by the `__contains__()` method. This shows how
    the simple Python syntax is implemented by the special methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use this `Hand` class like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: The cards are properly sorted in the hand. This is a consequence of the way
    the hand was created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example of using the subset operator, `<=` , to compare a specific
    pattern to the hand as a whole:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'A `Hand` is a collection, and supports iteration. We can use generator expressions
    that reference the `Card` objects within the overall `Hand` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our `Hand` collection works by wrapping an internal `list` object and applying
    an important constraint to that object. The items are kept in sorted order. This
    increases the cost to insert a new item, but reduces the cost to search for an
    item.
  prefs: []
  type: TYPE_NORMAL
- en: The core algorithms for locating the position for an item are part of the `bisect`
    module, saving us from having to write (and debug) them. The algorithms aren't
    really very complex. But it seems more efficient to leverage existing code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The module''s name comes from the idea of bisecting the sorted list to look
    for an item. The essence is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: This searches a list, `a` , for a given value, `x` . The value of `lo` is initially
    zero and the value of `hi` is initially the size of the list, `len(a)` .
  prefs: []
  type: TYPE_NORMAL
- en: 'First, the midpoint is identified. If the target value, `x` , is less than
    the midpoint value, `a[mid]` , then it must be in the first half of the list:
    the value of `hi` is shifted so that only the first half is considered.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If the target value, `x` , is greater than or equal to the midpoint value,
    `a[mid]` , then `x` must be in the second half of the list: the value of `lo`
    is shifted so that only the second half is considered.'
  prefs: []
  type: TYPE_NORMAL
- en: Since the list is chopped in half at each operation, it requires *O* (log *[2]
    n* ) steps to have the values of `lo` and `hi` converge on the position that should
    have the target value.
  prefs: []
  type: TYPE_NORMAL
- en: If we have a hand with 12 cards, then the first comparison discards six. The
    next comparison discards three more. The next comparison discards one of the final
    three. The fourth comparison will locate the position the card should occupy.
  prefs: []
  type: TYPE_NORMAL
- en: If we use an ordinary list, with cards stored in the random order of arrival,
    then finding a card will take an average of six comparisons. The worst possible
    case means it's the last of 12 cards, requiring all 12 to be examined.
  prefs: []
  type: TYPE_NORMAL
- en: With `bisect` the number of comparisons is always *O* (log *[2] n* ). That's
    the average as well as the worst case.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `collections.abc` module defines abstract base classes for various collections.
    If we want our `Hand` to behave more like other kinds of sets, we can leverage
    these definitions.
  prefs: []
  type: TYPE_NORMAL
- en: We can add numerous set operators to this class definition to make it behave
    more like the built-in `MutableSet` abstract class definition.
  prefs: []
  type: TYPE_NORMAL
- en: 'A `MutableSet` is an extension to `Set` . The `Set` class is a composite built
    from three class definitions: `Sized` , `Iterable` , and `Container` . This means
    that it must define the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`__contains__()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__iter__()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__len__()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`add()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`discard()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We''ll also need to provide some other methods that are part of being a mutable
    set:'
  prefs: []
  type: TYPE_NORMAL
- en: '`clear()` , `pop()` : These will remove items from the set.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`remove()` : Unlike `discard()` , this will raise an exception when attempting
    to remove a missing item.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In order to have unique set-like features, it also needs a number of additional
    methods. We provided an example of a subset, based on `__le__()` . We also need
    to provide the following subset comparisons:'
  prefs: []
  type: TYPE_NORMAL
- en: '`__le__()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__lt__()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__eq__()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__ne__()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__gt__()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__ge__()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isdisjoint()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are generally not trivial one-line definitions. In order to implement
    the core set of comparisons, we'll often write two and then use logic to build
    the remainder based on those two.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since `__eq__()` is simple, let''s assume we have definitions for the `==`
    and `<=` operators. The others would be defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*x* ≠ *y* ≡ ¬( *x* = *y* )'
  prefs: []
  type: TYPE_NORMAL
- en: '*x* < *y* ≡ ( *x* ≤ *y* ) ∧ ¬( *x* = *y* )'
  prefs: []
  type: TYPE_NORMAL
- en: '*x* > *y* ≡ ¬( *x* ≤ *y* )'
  prefs: []
  type: TYPE_NORMAL
- en: '*x* ≥ *y* ≡ ¬( *x* < *y* ) ≡ ¬( *x* ≤ *y* ) ∨ ( *x* = *y* )'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to do set operations, we''ll need to provide the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`__and__()` and `__iand__()` . These methods implement the Python `&` operator
    and the `&=` assignment statement. Between two sets, this is a set intersection,
    or *a* ∩ *b* .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__or__()` and `__ior__()` . These methods implement the Python `|` operator
    and the `|=` assignment statement. Between two sets, this is a set union, or *a*
    ∪ *b* .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__sub__()` and `__isub__()` . These methods implement the Python `-` operator
    and the `-=` assignment statement. Between sets, this is a set difference, often
    written as *a* - *b* .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__xor__()` and `__ixor__()` . These methods implement the Python `^` operator
    and the `^=` assignment statement. When applied between two sets, this is the
    symmetric difference, often written as *a* ∆ *b* .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The abstract class permits two versions of each operator. There are two cases:'
  prefs: []
  type: TYPE_NORMAL
- en: If we provide `__iand__()` , for example, then the statement `A &= B` will be
    evaluated as `A.__iand__(B)` . This might permit an efficient implementation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we do not provide `__iand__()` , then the statement `A &= B` will be evaluated
    as `A = A.__and__(B)` . This might be somewhat less efficient because we'll create
    a new object. The new object is given the label `A` , and the old object will
    be removed from memory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are almost two dozen methods that would be required to provide a proper
    replacement for the built-in set class. On one the hand, it's a lot of code. On
    the other hand, Python lets us extend the built-in classes in a way that's transparent
    and uses the same operators with the same semantics.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See the *Creating a class that has orderable objects* recipe for the companion
    recipe that defines Pinochle cards
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deleting from a list of mappings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Removing items from a list has an interesting consequence. Specifically, when
    item `list[x]` is removed, one of two other things will happen:'
  prefs: []
  type: TYPE_NORMAL
- en: Item `list[x+1]` takes the place of `list[x]`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Item `x+1 == len(list)` takes the place of `list[x]` because `x` was the last
    index in the list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are side-effects that happen in addition to removing an item. Because
    things can move around in a list, it makes deleting more than one item at a time
    challenging.
  prefs: []
  type: TYPE_NORMAL
- en: When the list contains items that have a definition for the `__eq__()` special
    method, then the list `remove()` method can remove each item. When the list items
    don't have a simple `__eq__()` test, then it becomes more challenging to remove
    multiple items from the list.
  prefs: []
  type: TYPE_NORMAL
- en: How can we delete multiple items from a list?
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ll work with a list-of-dict structure. In this case, we''ve got some data
    that includes a song name, the writers, and a duration. The data looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'To work with this kind of data structure, we''ll need the `pprint` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: We can easily traverse the list of values with the `for` statement. The problem
    is, how do we delete selected items?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: We can't simply use the statement `del item` here, because it has no effect
    on the source collection, `data` . This statement would only delete the local
    variable copy of the item in the original list by deleting the `item` variable
    and the associated object.
  prefs: []
  type: TYPE_NORMAL
- en: 'To properly delete items from a list, we must work with index positions in
    the list. Here''s a naïve approach that emphatically does not work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: We can't simply use `range(len(data))` based on the original size of the list.
    As items are removed, the list gets smaller. The value of the index will be set
    to a value that's too large.
  prefs: []
  type: TYPE_NORMAL
- en: 'When removing simple items that have simple equality tests, we would use something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: The problem is that we don't have an implementation of `__contains__()` that
    identifies items with `Lake` in `item['writer']` . We could use a subclass of
    dict that implements `__eq__()` as a string parameter value in `self['writer']`
    . This clearly violates the semantics of equality because it only checks a single
    field.
  prefs: []
  type: TYPE_NORMAL
- en: We can't extend the built-in features of these classes. The use case here is
    very specific to the problem domain, not a general feature of the list of dict
    structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'To parallel the basic `while in...remove` loop, we need to write something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve written a function, `index()` , that locates the first instance of the
    target value. The result of this function is a single value that provides two
    kinds of information:'
  prefs: []
  type: TYPE_NORMAL
- en: When the value returned is not `None` , the item exists in the list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The return value is the proper index for the item within the list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `index()` function is wordy and inflexible. If we have alternate rules,
    we need to either write multiple `index()` functions or we need to make the test
    more flexible.
  prefs: []
  type: TYPE_NORMAL
- en: More importantly, consider when a target value occurs *x* times in a list of
    *n* items. There will be *x* trips through this loop. Each trip through the loop
    examines an average of **O** ( *x* × *n/2* ) trips through the list. The worst
    case is that the items are all at the end of the list, leading to just under 
    **O** ( *x* × *n* ) processing iterations.
  prefs: []
  type: TYPE_NORMAL
- en: We can do better. Our preferred solution builds on the ideas in the *Designing
    a while statement which terminates properly* recipe in [Chapter 2](text00027.html#page
    "Chapter 2. Statements and Syntax") , *Statements and Syntax* , to design a proper
    loop for removing complex items from a list structure.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Initialize an index value to zero. This establishes a variable that will traverse
    the data collection:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'The terminating condition must show that every item in the list has been examined.
    Additionally, the body of the loop needs to remove all of the items that match
    the target criteria. This leads to an invariant condition that `item[i]` has not
    yet been examined. After the item is examined, it may be preserved, which means
    the index, `i` , must be incremented to reset the not yet examined invariant.
    If the item is removed, then items will shift forward and `item[i]` will automatically
    meet the not yet examined invariant:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: When removing an item, the list becomes one shorter, and the index value, `i`
    , will point to a new, unexamined item. When preserving an item, the index value,
    `i` , is advanced to the next unexamined item.
  prefs: []
  type: TYPE_NORMAL
- en: 'The terminating condition is used to wrap the processing body:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: At the end of the `while` statement, the value of `i` will indicate that all
    items have been examined.
  prefs: []
  type: TYPE_NORMAL
- en: 'This leads to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: This makes exactly one pass through the data and removes the requested items
    without raising index errors, or skipping items that should have been deleted.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The goal is to examine each item exactly once and either remove it or step over
    it. The loop design reflects the way that the Python list item removal works.
    When an item is removed, all of the subsequent items are shuffled forward in the
    list.
  prefs: []
  type: TYPE_NORMAL
- en: 'A naïve process based on the `range()` and `len()` functions will have two
    problems:'
  prefs: []
  type: TYPE_NORMAL
- en: Items will be skipped when the items shift forward and the next value is produced
    by the range object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The index can go beyond the end of the list structure after items are removed
    because the `len()` was used once to get the original size, not the current size
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Because of these two problems, the design of the invariant condition in the
    body of the loop is important. This reflects the two possible state changes:'
  prefs: []
  type: TYPE_NORMAL
- en: If an item is removed, the index must not change. The list itself will change.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If an item is preserved, the index must change.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can argue that the loop makes one trip through the data, and has a complexity
    of **O** ( *n* ). What's not considered in this is the relative cost of each deletion.
    Deleting item `0` from a list means that each remaining item is shuffled forward
    one position. The cost of each deletion is effectively *O* ( *n* ). Therefore
    the complexity is more like  **O** ( *n × x* ), where *x* items are removed from
    a list of *n* items.
  prefs: []
  type: TYPE_NORMAL
- en: Even this algorithm isn't the fastest way to remove items from a list.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If we give up on the idea of deleting, we can do even better. Making a shallow
    copy of items is much faster than removing items from a list, but uses more storage.
    This is a common time versus memory tradeoff.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use a generator expression like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: This will create a shallow copy of the items in the list that we want to keep.
    The items we don't want to keep will be ignored. For more information on the idea
    of a shallow copy, see the *Making shallow and deep copies of objects* recipe
    in [Chapter 4](text00048.html#page "Chapter 4. Built-in Data Structures – list,
    set, dict") , *Built-in Data Structures – list, set, dict* .
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also use a higher-order function such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'The `filter()` function has two arguments: a `lambda` object, and the original
    set of data. The `lambda` object is a kind of degenerate case for a function:
    it has arguments and a single expression. In this case, the single expression
    is used to decide which items to pass. Items for which the lambda is `False` are
    rejected.'
  prefs: []
  type: TYPE_NORMAL
- en: The `filter()` function is a generator. This means that we need to collect all
    of the items to create a final list object. A `for` statement is one way to process
    all results from a generator. The `list()` and `tuple()` functions will also consume
    all items from a generator.
  prefs: []
  type: TYPE_NORMAL
- en: The third way we can implement this is to write our own generator function that
    embodies the filter concept. This will use more statements than the generator
    or the `filter()` function, but it might be more clear.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a generator function definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: We've used a `for` statement to examine each item in the source list. If the
    item has `'Lake'` in the list of writers, we'll continue the `for` statement process
    effectively rejecting this item. If `'Lake'` is not in the list of writers, we'll
    yield the item.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we call this function, it will yield the interesting list. We can use
    the function `writer_rule()` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: This will accumulate the interesting rows into a new structure. Since it's a
    shallow copy, it doesn't waste vast amounts of storage.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is based on the *Designing a while statement which terminates properly*
    recipe in [Chapter 2](text00027.html#page "Chapter 2. Statements and Syntax")
    , *Statements and Syntax*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We''ve also leveraged two other recipes: *Making shallow and deep copies of
    objects* and *Slicing and dicing a list* in [Chapter 4](text00048.html#page "Chapter 4. Built-in
    Data Structures – list, set, dict") , *Built-in Data Structures – list, set, dict*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
