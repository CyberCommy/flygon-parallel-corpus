- en: Objects, Classes, and Inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we discussed functions as a way to bundle up a bunch
    of lines of related code. We talked about how functions abstract away implementation
    details and how the `sqrt()` function does not require you to understand how it
    works internally to use it to find roots. This is a good thing, primarily because
    it saves programmers time and effort, while making the actual work of finding
    square roots easier. This principle of abstraction will come up again here, when
    we discuss objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will be covering:'
  prefs: []
  type: TYPE_NORMAL
- en: What is an object?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Structs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Class versus struct
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getters and setters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constructors and destructors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Class inheritance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiple inheritance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Putting your class into headers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Object oriented programming design patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Callable objects and invoke
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter contains a lot of keywords that might be difficult to grasp at
    first, including `virtual` and `abstract`.
  prefs: []
  type: TYPE_NORMAL
- en: Don't let the more difficult sections of this chapter bog you down. I included
    descriptions of many advanced concepts for completeness. However, bear in mind
    that you don't need to completely understand everything in this chapter to write
    working C++ code in UE4\. It helps to understand everything, but if something
    doesn't make sense, don't get stuck. Give it a read and then move on. Probably
    what will happen is you will not get it at first, but remember a reference to
    the concept in question when you're coding. Then, when you open this book up again,
    voilà! It will make sense.
  prefs: []
  type: TYPE_NORMAL
- en: What is an object?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a nutshell, objects tie together methods (another word for functions) and
    their related data into a single structure. This structure is called a class.
    The main idea behind using objects is to create a code representation for everything
    inside your game. Every object represented in the code will have data and associated
    functions that operate on that data. So, you'd have an object to represent your
    `Player` and related functions that make the `Player` `jump()`, `shoot()`, and
    `pickupItem()`. You'd also have an object to represent every monster instance
    and related functions, such as `growl()`, `attack()`, and possibly `follow()`.
  prefs: []
  type: TYPE_NORMAL
- en: Objects are types of variables, though, and objects will stay in memory as long
    as you keep them there. You create an instance, or a specific representation of
    an object with it's own set of values, once when the thing in your game it represents
    is created, and you destroy the object instance when the thing in your game it
    represents dies.
  prefs: []
  type: TYPE_NORMAL
- en: Objects can be used to represent in-game things, but they can also be used to
    represent any other type of thing. For example, you can store an image as an object.
    The data fields will be the image's width of the image, its height, and the collection
    of pixels inside it. C++ strings are also objects.
  prefs: []
  type: TYPE_NORMAL
- en: The struct object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An object in C++ is basically any variable type that is made up of a conglomerate
    of simpler types. The most basic object in C++ is `struct`. We use the `struct`
    keyword to glue together a bunch of smaller variables into one big variable. If
    you recall, we did introduce `struct` briefly in [Chapter 2](080d0c73-c0d8-42b6-a2ad-7025ee001924.xhtml),
    *Variables and Memory*. Let''s revise that simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This is the structure definition for what makes a `Player` object. The `Player`
    has a `string` for their `name` and an integer for their `hp` value.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you recall from [Chapter 2](080d0c73-c0d8-42b6-a2ad-7025ee001924.xhtml),
    *Variables and Memory*, the way we make an instance of the `Player` object is
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'From here, we can access the fields of the `me` object like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Member functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, here''s the exciting part. We can attach member functions to the `struct`
    definition simply by writing these functions inside the `struct Player` definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: A member function is just a C++ function that is declared inside a `struct`
    or `class` definition.
  prefs: []
  type: TYPE_NORMAL
- en: There is a bit of a funny idea here, so I'll just come out and say it. The variables
    of `struct Player` are accessible to all the functions inside `struct Player`.
    Inside each of the member functions of `struct Player`, we can actually access
    the `name` and `hp` variables as if they were local to the function. In other
    words, the `name` and `hp` variables of `struct Player` are shared between all
    the member functions of `struct Player`.
  prefs: []
  type: TYPE_NORMAL
- en: The this keyword
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In some C++ code (in later chapters), you will see more references to the `this`
    keyword. The `this` keyword is a pointer that refers to the current object. Inside
    the `Player::damage()` function, for example, we can write our reference to `this`
    explicitly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `this` keyword only makes sense inside a member function. We could explicitly
    include the use of the `this` keyword inside member functions, but without writing
    `this`, it is implied that we are talking about the `hp` of the current object.
    So, while this is not strictly necessary in most cases, it may be a personal or
    company preference and could make the code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: Are strings objects?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Yes, strings are objects! Every time you've used a `string` variable in the
    past, you were using an object. Let's try out some of the member functions of
    the `string` class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: What we've done here is use the `append()` member function to add on two extra
    characters to the end of the string (`!!`). Member functions always apply to the
    object that calls the member function (the object to the left of the dot).
  prefs: []
  type: TYPE_NORMAL
- en: 'To see the listing of members and member functions available on an object,
    follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Type the object's variable name in Visual Studio
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then type a dot (`.`)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then press *Ctrl* and the spacebar
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A member listing will pop up as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5b34de60-8c71-4702-9af6-e80b967e0264.png)'
  prefs: []
  type: TYPE_IMG
- en: Pressing Ctrl and the spacebar will make the member listing appear
  prefs: []
  type: TYPE_NORMAL
- en: Invoking a member function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Member functions can be invoked with the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The object invoking the member function is on the left of the dot. The member
    function to call is on the right of the dot. A member function invocation is always
    followed by round brackets `()`, even when no arguments are passed to the brackets.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in the part of the program where the monster attacks, we can reduce the
    `player`''s `hp` value as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Isn't that more readable than the following?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: When member functions and objects are used effectively, your code will read
    more like prose or poetry than a bunch of operator symbols slammed together.
  prefs: []
  type: TYPE_NORMAL
- en: Besides beauty and readability, what is the point of writing member functions?
    Outside the `Player` object, we can now do more with a single line of code than
    just reduce the `hp` member by `15`. We can also do other things as we're reducing
    the `player`'s `hp`, such as take into account the `player`'s armor, check whether
    the player is invulnerable, or have other effects occur when the `Player` is damaged.
    What happens when the player is damaged should be abstracted away by the `damage()`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, imagine the `Player` had an `armorClass`. Let''s add a field to `struct
    Player` for `armorClass`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We''d need to reduce the damage received by the `Player` by the armor class
    of the `Player`. So, we''d type a formula to reduce `hp`. We can do it the non-object-oriented
    way by accessing the data fields of the `Player` object directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Otherwise, we can do it the object-oriented way by writing a member function
    that changes the data members of the `Player` object as needed. Inside the `Player`
    object, we can write a `damage()` member function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is a subtle bug in the `Player`''s `damage` function in the preceding
    code. Can you find and fix it? Hint: what happens if the damage dealt is less
    than the `armorClass` of the `Player`?'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Having only a number for armor class doesn't give enough information about the
    armor! What is the armor's name? What does it look like? Devise a `struct` function
    for the `Player`'s armor with fields for `name`, `armorClass`, and `durability`
    rating.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Solutions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The solution to the first exercise is in the `struct Player` code listed in
    the next section, *Privates and encapsulation*.
  prefs: []
  type: TYPE_NORMAL
- en: For the second, how about using the following code?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'An instance of `Armor` will then be placed inside `struct Player`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This means the `Player` has an armor. Keep this in mind—we'll explore `has-a`
    versus `is-a` relationships later.
  prefs: []
  type: TYPE_NORMAL
- en: All variable names thus far start with a lowercase character. This is a good
    convention with C++ code. You may find some cases where specific teams or other
    languages prefer to use uppercase characters to start variable names, in which
    case it's better to just do what people at your company expect.
  prefs: []
  type: TYPE_NORMAL
- en: Privates and encapsulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So now we've defined a couple of member functions, whose purpose it is to modify
    and maintain the data members of our `Player` object, but some people have come
    up with an argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'The argument is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: An object's data members should only ever be accessed through its member functions,
    never directly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This means that you should never access an object''s data members from outside
    the object directly, in other words, modify the `player`''s `hp` directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This should be forbidden, and users of the class should be forced to use the
    proper member functions to change the values of data members instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This principle is called *encapsulation*. Encapsulation is the concept that
    every object should be interacted via its member functions only. Encapsulation
    says that raw data members should never be accessed directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The reasons behind encapsulation are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**To make the class self-contained**: The primary idea behind encapsulation
    is that objects work best when they are programmed such that they manage and maintain
    their own internal state variables without the need for code outside the class
    to examine that class''s private data. When objects are coded this way, it makes
    the object much easier to work with, that is, easier to read and maintain. To
    make the `Player` object jump, you should just have to call `player.jump()`; let
    the `Player` object manage state changes to its `y-height` position (making the
    `Player` jump!). When an object''s internal members are not exposed, interacting
    with that object is much easier and more efficient. Interact only with an object''s
    public member functions; let the object manage its internal state (we will explain
    the keywords `private` and `public` in a moment).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**To avoid breaking code**: When code outside of a class interacts with that
    class''s public member functions only (the class''s public interface), then an
    object''s internal state management is free to change, without breaking any of
    the calling code. This way, if an object''s internal data members change for any
    reason, all code using the object still remains valid, as long as the member functions''
    signatures - the names, return types, and any parameters—remain the same.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, how can we prevent a programmer from doing the wrong thing and accessing
    data members directly? C++ introduces the concept of *access modifiers* to prevent
    accessing an object's internal data.
  prefs: []
  type: TYPE_NORMAL
- en: Here is how we'd use access modifiers to forbid access to certain sections of
    `struct Player` from outside of `struct Player`.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing you'd do is decide which sections of the `struct` definition
    you want to be accessible outside of the class. These sections will be labelled
    `public`. All other regions that will not be accessible outside of `struct` will
    be labelled `private`,
  prefs: []
  type: TYPE_NORMAL
- en: 'as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Some people like it public
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some people do unabashedly use `public` data members and do not encapsulate
    their objects. This is a matter of preference, though is considered bad object-oriented
    programming practice.
  prefs: []
  type: TYPE_NORMAL
- en: However, classes in UE4 do use `public` members sometimes. It's a judgment call;
    whether a data member should be `public` or `private` is really up to the programmer.
  prefs: []
  type: TYPE_NORMAL
- en: With experience, you will find that, sometimes, you get into a situation that
    requires quite a bit of refactoring (modifying code) when you make a data member
    `public` that should have been `private`.
  prefs: []
  type: TYPE_NORMAL
- en: The class keyword versus struct
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You might have seen a different way of declaring an object, using the `class`
    keyword, instead of `struct`, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `class` and `struct` keywords in C++ are almost identical. There is only
    one difference between `class` and `struct`, and that is that the data members
    inside a `struct` keyword will be declared `public` by default, while in a `class`
    keyword, the data members inside the class will be declared `private` by default.
    (This is why I introduced objects using `struct`; I didn't want to inexplicably put
    `public` as the first line of `class`.)
  prefs: []
  type: TYPE_NORMAL
- en: In general, `struct` is preferred for simple types that don't use encapsulation,
    don't have many member functions, and must be backward-compatible with C. Classes
    are used almost everywhere else.
  prefs: []
  type: TYPE_NORMAL
- en: From now on, let's use the `class` keyword instead of `struct`.
  prefs: []
  type: TYPE_NORMAL
- en: Getters and setters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You might have noticed that, once we slap `private` onto the `Player` class
    definition, we can no longer read or write the name of the `Player` from outside
    the `Player` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Say we try and read the name with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Or write to the name, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the `struct Player` definition with `private` members, we will get the
    following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This is just what we asked for when we labeled the `name` field `private`. We
    made it completely inaccessible outside the `Player` class.
  prefs: []
  type: TYPE_NORMAL
- en: Getters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A getter (also known as an accessor function) is used to pass back copies of
    internal data members to the caller. To read the `Player`''s name, we''d deck
    out the `Player` class with a member function, specifically to retrieve a copy
    of that `private` data member:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'So, now it is possible to read the `player`''s `name` information. We can do
    this by using the following code statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Getters are used to retrieve `private` members that would otherwise be inaccessible
    to you from outside the class.
  prefs: []
  type: TYPE_NORMAL
- en: Real world tip - the const keyword
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside a class, you can add the `const` keyword to a member function declaration.
    What the `const` keyword does is promise to the compiler that the internal state
    of the object will not change as a result of running this function. Attaching
    the `const` keyword will look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`string getName() const`'
  prefs: []
  type: TYPE_NORMAL
- en: '`{`'
  prefs: []
  type: TYPE_NORMAL
- en: '`return name;`'
  prefs: []
  type: TYPE_NORMAL
- en: '`}`'
  prefs: []
  type: TYPE_NORMAL
- en: No assignments to data members can happen inside a member function that is marked `const`.
    As the internal state of the object is guaranteed not to change as a result of
    running a `const` function, the compiler can make some optimizations regarding
    function calls to `const` member functions.
  prefs: []
  type: TYPE_NORMAL
- en: Setters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A setter (also known as a modifier function or mutator function) is a member
    function whose sole purpose is to change the value of an internal variable inside
    the class, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: So we can still change a `private` variable in a `class` from outside the `class`
    function, but only if we do so through a setter function.
  prefs: []
  type: TYPE_NORMAL
- en: But what's the point of get/set operations?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, the first question that crosses a newbie programmer's mind when they first
    encounter get/set operations on `private` members is, isn't get / set self-defeating?
    I mean, what's the point in hiding access to data members when we're just going
    to expose that same data again in another way? It's like saying, *"You can't have
    any chocolates because they are private, unless you say please* `getMeTheChocolate()`.
    *Then, you can have the chocolates."*
  prefs: []
  type: TYPE_NORMAL
- en: 'Some expert programmers even shorten the get/set functions to one-liners, like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Let's answer the question. Doesn't a get/set pair break encapsulation by exposing
    the data completely?
  prefs: []
  type: TYPE_NORMAL
- en: The answer is twofold. First, get member functions typically only return a copy
    of the data member being accessed. This means that the original data member's
    value remains protected and is not modifiable through a `get()` operation.
  prefs: []
  type: TYPE_NORMAL
- en: A `set()` (mutator method) operation is a little bit counter-intuitive though.
    If the setter is a `passthru` operation, such as `void setName( string newName
    ) { name=newName; }`, then having the setter might seem pointless. What is the
    advantage of using a mutator method instead of overwriting the variable directly?
  prefs: []
  type: TYPE_NORMAL
- en: The argument for using mutator methods is to write additional code before the
    assignment of a variable to guard the variable from taking on incorrect values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Say, for example, we have a setter for the `hp` data member, which will look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The mutator method is supposed to prevent the internal `hp` data member from
    taking on negative values. You might consider mutator methods a bit retroactive.
    Should the responsibility lie with the calling code to check the value it is setting
    before calling `setHp( -2 )`, and not let that only get caught in the mutator
    method? Can't you use a `public` member variable and put the responsibility for
    making sure the variable doesn't take on invalid values in the calling code, instead
    of in the setter? You can.
  prefs: []
  type: TYPE_NORMAL
- en: This is the core reason behind using mutator methods. The idea behind mutator
    methods is that the calling code can pass any value it wants to the `setHp` function
    (for example, `setHp( -2 )`), without having to worry whether the value it is
    passing to the function is valid or not. The `setHp` function then takes the responsibility
    of ensuring that the value is valid for the `hp` variable.
  prefs: []
  type: TYPE_NORMAL
- en: Some programmers consider direct mutator functions such as `getHp()`/`setHp()`
    a code smell. A code smell is, in general, a bad programming practice that people
    don't overtly take notice of, except for a niggling feeling that something is
    being done sub-optimally. They argue that higher-level member functions can be
    written instead of mutators. For example, instead of a `setHp()` member function,
    we should have `public` member functions such as `heal()` and `damage()` instead.
    An article on this topic is available at [http://c2.com/cgi/wiki?AccessorsAreEvil](http://c2.com/cgi/wiki?AccessorsAreEvil).
  prefs: []
  type: TYPE_NORMAL
- en: Constructors and destructors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The constructor in your C++ code is a simple little function that runs once
    when the C++ object instance is first created. The destructor runs once when the
    C++ object instance is destroyed. Say we have the following program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have created a `Player` object. The output of this code will be as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The first thing that happens during object construction is that the constructor
    actually runs. This prints the line `Player object constructed`. Following this,
    the line with the `Player`''s name gets printed: `Player named ''Diplo''`. Why
    is the `Player` named Diplo? Because that is the name assigned in the `Player()`
    constructor.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, at the end of the program, the `Player` destructor gets called, and
    we see `Player object destroyed`. The `Player` object gets destroyed when it goes
    out of scope at the end of `main()` (at `}` of `main`).
  prefs: []
  type: TYPE_NORMAL
- en: 'So, what are constructors and destructors good for? Exactly what they appear
    to be for: setting up and tearing down an object. The constructor can be used
    for the initialization of data fields, and the destructor to call `delete` on
    any dynamically allocated resources (we haven''t covered dynamically allocated
    resources yet, so don''t worry about this last point).'
  prefs: []
  type: TYPE_NORMAL
- en: Class inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You use inheritance when you want to create a new, more functional class of
    code, based on an existing class of code. Inheritance is a tricky topic to cover.
    Let's start with the concept of a derived class (or subclass).
  prefs: []
  type: TYPE_NORMAL
- en: Derived classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The most natural way to consider inheritance is by analogy with the animal
    kingdom. The classification of living things is shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b3b310e9-d3c3-4849-bf72-f2a09006fd81.png)'
  prefs: []
  type: TYPE_IMG
- en: What this diagram means is that **Dog**, **Cat**, **Horse**, and **Human** are
    all mammals. What that means is that they all all share some common characteristics,
    such as having common organs (a brain with a neocortex, lungs, a liver, and a
    uterus in females), while being completely different in other regards. How each
    walks is different. How each communicates is also different.
  prefs: []
  type: TYPE_NORMAL
- en: What would that mean if you were coding creatures? You would only have to program
    the common functionality once. Then, you would implement the code for the different
    parts specifically for each of the `Dog`, `Cat`, `Horse`, and `Human` classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'A concrete example of the preceding diagram is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: All of `Dog`, `Cat`, and `Human` inherit from `class Mammal`. This means that
    `dog`, `cat`, and `human` are mammals, and many more.
  prefs: []
  type: TYPE_NORMAL
- en: Syntax of inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The syntax of inheritance is quite simple. Let''s take the `Human` class definition
    as an example. The following screenshot is a typical inheritance statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/06c5e550-28b0-4346-8bdb-8aaae6895259.png)'
  prefs: []
  type: TYPE_IMG
- en: The class on the left of the colon (**:**) is the new, derived class, and the
    class on the right of the colon is the base class.
  prefs: []
  type: TYPE_NORMAL
- en: What does inheritance do?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The point of inheritance is for the derived class to take on all the characteristics
    (data members and member functions) of the base class, and then to extend it with
    even more functionality. For instance, all mammals have a `breathe()` function.
    By inheriting from the `Mammal` class, the `Dog`, `Cat`, and `Human` classes all
    automatically gain the ability to `breathe()`.
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance reduces replication of code, since we don't have to re-implement
    common functionalities (such as `.breathe()`) for `Dog`, `Cat`, and `Human`. Instead,
    each of these derived classes enjoys the reuse of the `breathe()` function defined
    in `class Mammal`.
  prefs: []
  type: TYPE_NORMAL
- en: However, only the `Human` class has the `attack()` member function. This would
    mean that, in our code, only the `Human` class attacks. The `cat.attack()` function
    will introduce a compiler error, unless you write an `attack()` member function inside
    `class Cat` (or in `class Mammal`).
  prefs: []
  type: TYPE_NORMAL
- en: The is-a relationship
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Inheritance is often said to be an `is-a` relationship. When a `Human` class
    inherits from the `Mammal` class, then we say that a human *is-a* mammal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/994a96f0-b90d-4752-bbb0-7e736de6bbed.png)'
  prefs: []
  type: TYPE_IMG
- en: A human inherits all the traits a mammal has.
  prefs: []
  type: TYPE_NORMAL
- en: But what if a `Human` object contains a `Mammal` object inside it, as follows?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we would say the human has a`Mammal` on it somewhere (which
    would make sense if the human were pregnant, or somehow carrying a mammal):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8ec61aa4-5a39-4f71-a182-48a5f68439c7.png)'
  prefs: []
  type: TYPE_IMG
- en: This `Human` class instance has some kind of mammal attached to it
  prefs: []
  type: TYPE_NORMAL
- en: Remember that we previously gave `Player` an `Armor` object inside it? It wouldn't
    make sense for the `Player` object to inherit from the `Armor` class, because
    it wouldn't make sense to say the `Player` *is-an Armor*. When deciding whether
    one class inherits from another or not in code design (for example, the `Human`
    class inherits from the `Mammal` class), you must always be able to comfortably
    say something like the `Human` class *is-a* `Mammal`. If the *is-a* statement
    sounds wrong, then it is likely that inheritance is the wrong relationship for
    that pair of objects.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, we're introducing a few new C++ keywords. The first
    is `protected`.
  prefs: []
  type: TYPE_NORMAL
- en: Protected variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A `protected` member variable is different from a `public` or `private` variable.
    All three classes of variables are accessible inside the class in which they are
    defined. The difference between them is with regard to accessibility outside the
    class. A `public` variable is accessible anywhere inside the class and outside
    the class. A `private` variable is accessible inside the class but not outside
    the class. A `protected` variable is accessible inside the class, and inside of
    derived subclasses, but is not accessible outside the class. So, the `hp` and
    `speed` members of `class Mammal` will be accessible in the derived classes `Dog`,
    `Cat`, `Horse`, and `Human`, but not outside of these classes (in `main()`, for
    instance).
  prefs: []
  type: TYPE_NORMAL
- en: Virtual functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A virtual function is a member function whose implementation can be overridden
    in a derived class. In this example, the `talk()` member function (defined in
    `class Mammal`) is marked `virtual`. This means that the derived classes might
    or might not choose to implement their own version of what the `talk()` member
    function means.
  prefs: []
  type: TYPE_NORMAL
- en: Purely virtual functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A purely `virtual` function (and abstract classes) is one whose implementation
    you are required to override in the derived class. The `walk()` function in `class
    Mammal` is purely virtual; it was declared like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The `= 0` part at the end of the preceding code is what makes the function purely
    virtual.
  prefs: []
  type: TYPE_NORMAL
- en: The `walk()` function in `class Mammal` is purely virtual and this makes the
    `Mammal` class abstract. An abstract class in C++ is any class that has at least
    one purely virtual function.
  prefs: []
  type: TYPE_NORMAL
- en: 'If a class contains a purely virtual function and is abstract, then that class
    cannot be instantiated directly. That is, you cannot create a `Mammal` object
    now, on account of the purely virtual function `walk()`. If you tried to do the
    following code, you would get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'If you try to create a `Mammal` object, you will get the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: You can, however, create instances of derivatives of `class Mammal`, as long
    as the derived classes have all of the purely virtual member functions implemented.
  prefs: []
  type: TYPE_NORMAL
- en: You may wonder why you'd want to use one of these. Well, do you really think
    you'd want to create a `Mammal` object in a game? No, you'd want to create an
    object of the types you derive from `Mammal`, such as `Cat` or `Dog`. This way,
    you can't accidentally create a `Mammal`, which would be very confusing to the
    `Player`!
  prefs: []
  type: TYPE_NORMAL
- en: Multiple inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Not everything multiple is as good as it sounds. Multiple inheritance is when
    a derived class inherits from more than one base class. Usually, this works without
    a hitch if the multiple base classes we are inheriting from are completely unrelated.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can have a class `Window` that inherits from the `SoundManager`
    and `GraphicsManager` base classes. If `SoundManager` provides a member function
    `playSound()` and `GraphicsManager` provides a member function `drawSprite()`,
    then the `Window` class will be able to use those additional capabilities without
    a hitch:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d58d2f1d-0fea-4c2e-84d1-d5e23b7151c4.png)'
  prefs: []
  type: TYPE_IMG
- en: Game Window inheriting from Sound Man and Graphics Man means Game Window will
    have both sets of capabilities
  prefs: []
  type: TYPE_NORMAL
- en: However, multiple inheritance can have negative consequences. Say we want to
    create a `Mule` class that derives from both the `Donkey` and `Horse` classes.
    The `Donkey` and `Horse` classes, however, both inherit from the `Mammal` base
    class. We instantly have an issue! If we were to call `mule.talk()`, but `mule`
    did not override the `talk()` function, which member function should be invoked,
    that of `Horse` or `Donkey`? It's ambiguous.
  prefs: []
  type: TYPE_NORMAL
- en: Private inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A less talked about feature of C++ is `private` inheritance. Whenever a class
    inherits from another class publicly, it is known to all code whose parent class
    it belongs to, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'This means that all code will know that `Cat` is an object of `Mammal`, and
    it will be possible to point to a `Cat*` instance using a base class `Mammal*`
    pointer. For example, the following code would be valid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Putting an object of one class into a variable of the type of the parent class
    is called casting. The preceding code is fine if `Cat` inherits from `Mammal`
    publicly. Private inheritance is where code outside the `Cat` class is not allowed
    to know the parent class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Here, externally called code will not "know" that the `Cat` class derives from
    the `Mammal` class. Casting a `Cat` instance to the `Mammal` base class is not
    allowed by the compiler when inheritance is `private`. Use `private` inheritance
    when you need to hide the fact that a certain class derives from a certain parent
    class.
  prefs: []
  type: TYPE_NORMAL
- en: However, `private` inheritance is rarely used in practice. Most classes just
    use `public` inheritance. If you want to know more about `private` inheritance,
    see [http://stackoverflow.com/questions/406081/why-should-i-avoid-multiple-inheritance-in-c](http://stackoverflow.com/questions/406081/why-should-i-avoid-multiple-inheritance-in-c).
  prefs: []
  type: TYPE_NORMAL
- en: Putting your classes into headers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, our classes have just been pasted before `main()`. If you continue to
    program that way, your code will all be in one file and will appear as one big
    disorganized mess.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, it is a good programming practice to organize your classes into separate
    files. This makes editing each class's code individually much easier when there
    are multiple classes inside the project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take `class Mammal` and its derived classes from earlier. We will properly
    organize that example into separate files. Let''s do this in steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file in your C++ project called `Mammal.h`. Cut and paste the entire
    `Mammal` class into that file. Notice that, since the `Mammal` class included
    the use of `cout`, we write a `#include <iostream>` statement in that file as
    well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write an `"#include``Mammal.h"` statement at the top of your `Source.cpp` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'An example of what this looks like is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dbddea3d-8b13-4b3d-8753-a7deb036398e.png)'
  prefs: []
  type: TYPE_IMG
- en: What's happening here when the code is compiled is that the entire `Mammal`
    class is copied and pasted (`#include`) into the `Source.cpp` file, which contains
    the `main()` function, and the rest of the classes are derived from `Mammal`.
    Since `#include` is a copy and paste function, the code will function exactly
    the same as it did before; the only difference is that it will be much better
    organized and easier to look at. Compile and run your code during this step to
    make sure it still works.
  prefs: []
  type: TYPE_NORMAL
- en: Check that your code compiles and runs often, especially when refactoring. When
    you don't know the rules, you're bound to make a lot of mistakes. This is why
    you should do your refactoring only in small steps. Refactoring is the name for
    the activity we are doing now - we are reorganizing the source to make more sense
    to other readers of our code base. Refactoring usually does not involve rewriting
    too much of it.
  prefs: []
  type: TYPE_NORMAL
- en: The next thing you need to do is isolate the `Dog`, `Cat`, and `Human` classes
    into their own files. To do so, create the `Dog.h`, `Cat.h`, and `Human.h` files
    and add them to your project.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with the `Dog` class, as shown in the following screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you use exactly this setup and try to compile and run your project, you
    will see the ''Mammal'' : ''class'' type redefinition error, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/300eff3f-4a48-41eb-9547-e9c95e432595.png)'
  prefs: []
  type: TYPE_IMG
- en: What this error means is that `Mammal.h` has been included twice in your project,
    once in `Source.cpp` and then again in `Dog.h`. This means, effectively, two versions
    of the `Mammal` class got added to the compiling code, and C++ is unsure which
    version to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few ways to fix this issue, but the easiest (and the one that Unreal
    Engine uses) is the `#pragma once` macro, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e4a0f4c4-3aee-4358-be65-a55683d8e697.png)'
  prefs: []
  type: TYPE_IMG
- en: We write `#pragma once` at the top of each header file. This way, the second
    time `Mammal.h` is included, the compiler doesn't copy and paste its contents
    again, since it  has already been included before, and its content is actually
    already in the compiling group of files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Do the same thing for `Cat.h` and `Human.h`, then `include` them both in your
    `Source.cpp` file where your `main()` function resides:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b28030e8-77f6-4bdd-84c2-be4d67edb365.png)'
  prefs: []
  type: TYPE_IMG
- en: Screenshot with all classes included
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've included all classes into your project, the code should compile
    and run.
  prefs: []
  type: TYPE_NORMAL
- en: Using .h and .cpp files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next level of organization is to leave the class declarations in the header
    files (`.h`) and put the actual function implementation bodies inside some new
    `.cpp` files. Also, leave existing members inside the `class Mammal` declaration.
  prefs: []
  type: TYPE_NORMAL
- en: 'For each class, perform the following operations:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Delete all function bodies (code between `{` and `}`) and replace them with
    just a semicolon. For the `Mammal` class, this would look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new `.cpp` file called `Mammal.cpp`. Then, simply put the member function
    bodies inside this file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: It is important to note the use of the class name and scope resolution operator
    (double colon) when declaring the member function bodies. We prefix all member
    functions belonging to the `Mammal` class with `Mammal::`. This shows that they
    belong to the class (this differentiates them from `.`, which is used for specific
    object instances of that class type).
  prefs: []
  type: TYPE_NORMAL
- en: Notice how the purely virtual function does not have a body; it's not supposed
    to! Purely virtual functions are simply declared (and initialized to `0`) in the
    base class, but implemented later in derived classes.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Complete the separation of the different creature classes above into class header
    (`.h`) and class definition files (`.cpp`).
  prefs: []
  type: TYPE_NORMAL
- en: Object-oriented programming design patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you've been looking into programming, you have probably come across the term
    *design patterns*. Design patterns are important to know because they are standard
    ways of doing things that can be applied to many programming projects. For an
    in-depth look at design patterns if you want to know more, a classic book is *Design
    Patterns* ([https://www.goodreads.com/book/show/85009.Design_Patterns](https://www.goodreads.com/book/show/85009.Design_Patterns)).
    Once you familiar them, you will find many uses for them throughout your career.
    Not all specifically relate to objects, but here are a few examples that do.
  prefs: []
  type: TYPE_NORMAL
- en: Singletons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, you only want to have one instance of an object. Say you're doing
    a kingdom simulator. You only want there to be one king. Otherwise, you risk a
    *Game of Thrones-*type situation with intrigue and Red Weddings everywhere, and
    that's not the type of game you were aiming for, is it? (Of course, you might
    keep that in mind for a different game.) But for this particular game, you want
    one king running things.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, how can you make sure other kings don''t start turning up everywhere? You
    use a singleton. A singleton is a class that keeps an instance of an object, and
    anywhere you want to use it, instead of creating a new object, you call a function
    that gives you a way to access an instance of an object, and you can then call
    functions on that. To make sure you only create one instance of an object, it
    keeps a copy of itself in a static variable inside the class (note: we will be
    talking more about static class members in the next section), and when you call
    `GetInstance()`, it checks to see whether you''ve already created an instance
    of the object. If you have, it uses the existing one. If you haven''t, it creates
    a new one. Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the code for the `cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The constructor is listed in the `private:` section of the code. This is important.
    If you do this, the constructor will not be accessible from outside the class,
    meaning that no other programmers, who may not realize that this is a singleton,
    can start creating new `King` objects and wreak havoc on the game. If they try,
    they will get an error. So, this enforces that this class can only be accessed
    through the `getInstance()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use this new singleton class, you would do something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Once you set the name, it will output `I am King Arthur`, no matter where in
    the code you call it from (just make sure to add `#include "King.h"` at the top
    of the file).
  prefs: []
  type: TYPE_NORMAL
- en: Factories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What do you think of when you think of the term *factory*? Probably a place
    where they mass-produce objects, such as cars, shoes, or computers. In code, a
    `Factory` works the same way. A factory is a class that can create objects of
    other types. But it's even more flexible because it can create objects of different
    types.
  prefs: []
  type: TYPE_NORMAL
- en: We saw earlier that a mammal can be a dog, cat, horse, or human. Because all
    four types are derived from `Mammal`, a `Factory` object can have a function where
    you tell it which type of `Mammal` you want, and it will create an object of that
    type, do any setup necessary, and return it. Because of a principle called polymorphism,
    you can get an object of type `Mammal`, but when you call any virtual functions,
    it knows to use the ones for `Cat`, `Dog`, or `Human`, depending on the type of
    object created. Your C++ compiler knows this because it maintains a virtual function
    table behind the scenes, which keeps a pointer to the version of each virtual
    function you really want to be using, and stores those in each object.
  prefs: []
  type: TYPE_NORMAL
- en: Object pools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Say you're creating a lot of objects, such as a particle system to display fireworks,
    and you have to constantly create new firework animations all over the screen.
    After a while, you'll notice things slowing down, and you might even run out of
    memory and crash. Fortunately, there is a way around this.
  prefs: []
  type: TYPE_NORMAL
- en: You can create an object pool, which is basically a group of objects that should
    be large enough to contain every one on screen at any given time. When one finishes
    its animation and disappears, instead of creating a new one, you throw it back
    into the pool, and when you need another one, you can pull that one back out and
    reuse it (you may want to change the color or other settings first). Reusing objects
    from a pool is much faster and takes less processing than creating new objects
    constantly. It also helps avoid memory leaks.
  prefs: []
  type: TYPE_NORMAL
- en: Static members
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we saw in the singleton example, classes can have static members. A static
    member of a class exists once for all instances of the class, instead of being
    different for each one. You generally access them as we did for the singleton:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Static variables are also commonly used for constants related to a class. But
    they can also be used to track something, such as how many instances of an object
    you have, by incrementing the static variable in a constructor and then decrementing
    it in the destructor. This is similar to how smart pointers can keep track of
    how many references to an object still exist.
  prefs: []
  type: TYPE_NORMAL
- en: Callable objects and invoke
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another new C++ feature is callable objects. This is an advanced topic, so don't
    worry too much about understanding it at this point, but I'll give you a brief
    overview. But to explain it, first, I need to mention another topic — operator
    overloading.
  prefs: []
  type: TYPE_NORMAL
- en: You may think you can't change the meaning of operators such as  `+`, `-`, `*`,
    and `/`. Actually, in C++, you can. You can add a function called `operator(symbol)`.
    So, if you have a string class, you can create an `operator+` function that causes
    strings to be concatenated instead of trying to figure out how to add two objects
    that aren't actually numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Callable objects go even further by overriding `()` with `operator()`. So, you
    can have a class that can be called as an object. C++ 17 has added a new function,
    `invoke()`, that will let you call a callable object with parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about objects in C++; they are pieces of code that
    tie data members and member functions together into a bundle of code called a `class`
    or `struct`. Object-oriented programming means that your code will be filled with
    things instead of just `int`, `float`, and `char` variables. You will have a variable
    that represents `Barrel`, another variable that represents `Player`, and so on,
    that is, a variable to represent every entity in your game. You will be able to
    reuse code by using inheritance; if you have to code implementations of `Cat`
    and `Dog`, you can code a common functionality in the base class `Mammal`. We
    also discussed encapsulation and how it is easier and more efficient to program
    objects such that they maintain their own internal state. We also introduced a
    few design patterns for objects (you'll find there are many more out there).
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll talk about how to allocate memory dynamically, and
    about arrays and vectors.
  prefs: []
  type: TYPE_NORMAL
