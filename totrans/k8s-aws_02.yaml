- en: Start Your Engines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will be taking our first steps with Kubernetes. You will
    learn how to start a cluster suitable for learning and development use on your
    own workstation, and will begin to learn how to use Kubernetes itself. In this
    chapter, we will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Learn how to install and use Minikube to run Kubernetes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build a simple application that runs in a Docker container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use Kubernetes to run simple applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your own Kubernetes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Minikube** is a tool that makes it easy to run a simple Kubernetes cluster
    on your workstation. It is very useful, as it allows you to test your applications
    and configurations locally and quickly iterate on your applications without needing
    access to a larger cluster. For our purposes, it is the ideal tool to get some
    practical hands-on experience with Kubernetes. It is very simple to install and
    configure, as you will discover.'
  prefs: []
  type: TYPE_NORMAL
- en: Installation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You will need a few tools to get Kubernetes running on your workstation:'
  prefs: []
  type: TYPE_NORMAL
- en: '`kubectl` is the Kubernetes command-line interface. Throughout this book, you
    will be using it to interact with Kubernetes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the Kubernetes community, no one agrees how to pronounce `kubectl`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try out these different ways and choose your favorite:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '`minikube` is a command that manages Kubernetes on your local machine. It handles
    all the hard stuff, so you can get started with Kubernetes straight away.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker`, the `minikube` virtual machine, has the Docker daemon running internally,
    but you might need the Docker command line installed on your workstation if you
    want to interact with it directly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It is best to use Minikube in conjunction with a virtual machine, as platforms
    like macOS and Windows don''t natively support Linux containers, and even on Linux
    it helps to keep your environment clean and isolated. There are various virtualization
    tools you can use with `minikube,` depending on your operating system:'
  prefs: []
  type: TYPE_NORMAL
- en: '**VirtualBox**: It is simple to use and can be installed on macOS, Windows,
    and Linux.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**VMware Fusion**: It is a commercial tool available on macOS.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**KVM**: It is a well-known Linux virtualization tool.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**xhyve**: It is an open source project that utilizes the native hypervisor
    framework in macOS. It performs very well but can be a little harder to install
    and use.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hyper-V**: It is the native virtualization tool for Windows. Remember, you
    might need to manually enable it on your machine and set up its networking.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this book, we are going to cover the default option, VirtualBox, but if you
    are using Minikube regularly, you might want to explore some of the other options,
    as they can be more performant and reliable if set up correctly.
  prefs: []
  type: TYPE_NORMAL
- en: You can find some documentation about the different drivers available atÂ [https://git.k8s.io/minikube/docs/drivers.md](https://git.k8s.io/minikube/docs/drivers.md).
  prefs: []
  type: TYPE_NORMAL
- en: macOS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: On a Mac, the best way to install `minikube` and `kubectl` is with the Homebrew
    package manager.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Homebrew package manager for macOS is a simple way to install development
    tools. You can find out how to install it on the website: [https://brew.sh/](https://brew.sh/)[.](https://brew.sh/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by installing the Kubernetes command-line client `kubectl`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, install `minikube` and `virtualbox`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Linux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'On Linux, the simplest installation method is to download and install pre-built
    binaries:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should download the binaries for `minikube` and `kubectl`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have downloaded the binaries, make them executable and move them to
    somewhere on your path:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The method of installing VirtualBox on Linux will depend on your distribution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the instructions on the VirtualBox website: [https://www.virtualbox.org/wiki/Linux_Downloads](https://www.virtualbox.org/wiki/Linux_Downloads).'
  prefs: []
  type: TYPE_NORMAL
- en: Windows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Installing Minikube on a Windows machine is as simple as it is on Linux or macOS.
  prefs: []
  type: TYPE_NORMAL
- en: Start by installing VirtualBox.
  prefs: []
  type: TYPE_NORMAL
- en: You can download the Windows installer for VirtualBox from [https://www.virtualbox.org/wiki/Downloads](https://www.virtualbox.org/wiki/Downloads).
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are using the chocolatey package manager, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install `minikube`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Install `kubectl`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: If you are not using chocolatey, you can manually install `minikube` and `kubectl`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Download `minikube` at [https://storage.googleapis.com/minikube/releases/latest/minikube-windows-amd64.exe](https://storage.googleapis.com/minikube/releases/latest/minikube-windows-amd64.exe)
    and rename it to `minikube.exe`. Then move it to a location on your path. Download
    `kubectl`: [https://dl.k8s.io/v1.10.6/bin/windows/amd64/kubectl.exe](https://dl.k8s.io/v1.10.6/bin/windows/amd64/kubectl.exe)
    and then move it to a location on your path.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Starting Minikube
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once you have got `minikube` and your chosen virtualization tool installed,
    we can use it to build and start a local Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you choose to use `minikube` tool''s default settings, doing so couldn''t
    be simpler. Just run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You should then see some output, similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '`minikube` start has many options that can be used to configure the cluster
    that is launched. Try running `minikube` help start to find out what you can customize.'
  prefs: []
  type: TYPE_NORMAL
- en: You might want to set `--cpus` and/or `--memory` to customize how much of your
    computer's resources are used for the Minikube VM.
  prefs: []
  type: TYPE_NORMAL
- en: Assuming that everything went as expected, that's it; you should have a cluster
    installed and running on your local machine.
  prefs: []
  type: TYPE_NORMAL
- en: The kubectl `config` file (found at `~/.kube/config` by default) defines contexts.
    A context links to a cluster and a user object. The cluster defines how.
  prefs: []
  type: TYPE_NORMAL
- en: The `minikube start` command creates a `kubectl` context pointing to the API
    server running within the Minikube VM, and is correctly configured with a user
    that will allow access to Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you progress through this book, you will of course want to add additional
    contexts in order to connect to remote clusters that you many have set up. You
    should be able to switch back to the `minikube` context whenever you want to use
    `minikube` by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: First steps with kubectl
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start by validating that `kubectl` has indeed been configured to use
    your cluster correctly and that we can connect to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see some output like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Your output might show slightly different version numbers, but assuming that
    you see a version number from both the client and the server, you can connect
    to the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: If you can't see the server version, or you saw some other error message, skip
    forward to the *Troubleshooting Minikube* section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start interacting with the cluster with some of the `kubectl` commands
    that are going to be useful to us when we interact with our cluster.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first command that we will explore is the `get` command. This lets us list
    basic information about the resources on the cluster. In this case, we are getting
    a list of all the node resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, on our Minikube installation, this is not very exciting, as
    we only have one node. But on larger clusters with many nodes, being able to see
    this information about all the nodes (or some subset) could be very useful.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next command will allow us to drill down and look at some more detailed
    information about a particular resource. Try running the following command against
    your installation to see what you can discover about the Minikube VM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As you progress through this book, you will discover that being able to get
    and describe the various resources that the Kubernetes API exposes will become
    second nature to you whenever you want to discover what is happening on your cluster
    and why.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we move on, `kubectl` has one more trick to help us. Try running the
    following command for a description of each of the resource types available on
    the cluster and some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Building Docker containers inside the cluster
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You might already have Docker installation on your workstation, but when you
    are working on an application it can improve your workflow to build your images
    on the Docker daemon running inside the Minikube VM that hosts your Kubernetes
    cluster. This means that you can skip pushing your images to a Docker repo before
    using them in Kubernetes. All you need do is build and tag your images, and then
    refer to them by name in your Kubernetes resources.
  prefs: []
  type: TYPE_NORMAL
- en: If you already have a Docker installation on your workstation, you should already
    have the command-line client installed that you need to interact with the Minikube
    Docker daemon. If you don't, it is quite easy to install, either by installing
    the Docker package for your platform or, if you just want the command-line tool,
    downloading the binary and copying it into your path.
  prefs: []
  type: TYPE_NORMAL
- en: 'To correctly configure the Docker CLI to communicate with the Docker demon
    inside the minikube VM, minikube provides a command that will return environment
    variables to configure the client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'On Mac or Linux, you can correctly expand these variables into your current
    shell environment by running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Try running some `docker` commands to check everything is set up correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This should show you the version of Docker running inside the Minikube VM. You
    might notice that the server version of Docker running in the Minikube VM is a
    little bit behind the latest version of Docker, since it takes some time for Kubernetes
    to be tested against new versions of Docker to be considered stable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try listing the running containers. You should notice a container running the
    Kubernetes dashboard, as well as some other services that Kubernetes has launched,
    such as `kube-dns` and the `addon` manager:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Building and launching a simple application on Minikube
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's take our first steps to building a simple application on our local minikube
    cluster and getting it to run.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we need to do is build a container image for our application.
    The simplest way to do this is to create a Dockerfile and use the `docker build`
    command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use your favorite text editor to create a file called Dockerfile with the following
    content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'To build the application, first ensure your Docker client is pointing to the
    Docker instance inside the Minikube VM by running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Then use Docker to build the image. In this case, we are tagging the image
    `hello`, but you could use any tag you wanted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Kubectl has a `run` command that we can use to quickly get a pod running on
    the Kubernetes cluster. In the background, it creates a Kubernetes deployment
    resource that ensures that a single instance of our `hello` container runs within
    a pod (we will learn more about this later):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We are setting `--image-pull-policy=Never` here to ensure that Kubernetes uses
    the local image that we just built, rather than the default of pulling the image
    from a remote repository, such as Docker Hub.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can check that our container has started correctly with `kubectl get`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Our hello world application was simple enough to set up, but we need some way
    to access it for our experiment to be considered a success. We can use the `kubectl
    expose` command to create a service pointing to the pod in the deployment that
    was just created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We have set the service type to NodePort in this case so that Kubernetes will
    expose a random port on the Minikube VM so that we can access our service easily.
    In [Chapter 6](cb29a916-0f55-4fa9-816d-2322a86e1ccc.xhtml), *Planning for Production*,
    we will discuss exposing our applications to the outside world in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: When you create a service of the `NodePort` type, Kubernetes automatically allocates
    us a port number for the service to be exposed on. In a multi-node cluster, this
    port will be opened on every node in the cluster. Since we only have a single
    node, working out how to access the cluster is a little bit simpler.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to discover the IP address of the Minikube VM. Luckily, there
    is a simple command we can run to get this information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: It is more than likely that when the `minikube` VM started on your machine,
    it was allocated a different IP address from my own, so make a note of the IP
    address on your own machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, in order to discover the port that Kubernetes has exposed our service
    on, let''s use `kubectl get` on our service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: You can see, in this case, that Kubernetes has exposed port `80` on our container
    as port `32286` on our node.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should now be able to construct a URL that you can visit in your browser
    to test out the application. In my case, it is `http://192.168.99.100:32286`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/18dfc655-d7c2-4803-a1cf-717c4add609b.png)You should be able to visit
    your application with your web browser'
  prefs: []
  type: TYPE_NORMAL
- en: What just happened?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have managed to build, run, and expose a single container on our
    Minikube instance. If you are used to using Docker to perform similar tasks, you
    might notice that although the steps we took were quite simple, there is a little
    more complexity in getting a simple hello world application like this up and running.
  prefs: []
  type: TYPE_NORMAL
- en: A lot of this has to do with the scope of the tool. Docker provides a simple
    and easy to use workflow for building and running single containers on a single
    machine, whereas Kubernetes is, of course, first and foremost a tool designed
    to manage many containers running across multiple nodes.
  prefs: []
  type: TYPE_NORMAL
- en: In order to understand some of the complexity that Kubernetes introduces, even
    in this simple example, we are going to explore the ways that Kubernetes is working
    behind the scenes to keep our application running reliably.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we executed `kubectl run`, Kubernetes created a new sort of resource:
    a deployment. A deployment is a higher level abstraction that manages the underlying
    `ReplicaSet` on our behalf. The advantage of this is that if we want to make changes
    to our application, Kubernetes can manage rolling out a new configuration to our
    running application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/3d2f8ccd-a232-469c-95bc-7d1a9e1def08.png)The architecture of our
    simple Hello application'
  prefs: []
  type: TYPE_NORMAL
- en: When we executed kubectl expose, Kubernetes created a service with a label selector
    that matched the pods under management by the deployment that we referenced.
  prefs: []
  type: TYPE_NORMAL
- en: Rolling out changes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the key functions of the deployment resource is to manage the roll-out
    of new versions of an application. Let's look at an example of how you would do
    this.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s update the Dockerfile for version 2 of our `Hello World` application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed that the HTML we used for version 1 was a little incomplete,
    so we are using the `COPY` command in the `Dockerfile` to copy an `index.html`
    file into our container image.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use your text editor to create an `index.html` file that will be visually distinguishable
    from version 1\. I took the opportunity to add a proper DOCTYPE, and, of course,
    to use CSS to re-implement the sadly now defunct blink tag! Since this isn''t
    a book about web design, feel free to make whatever changes you want:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, use Docker to build your version 2 image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can use kubectl to update the deployment resource to use the new image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Wait a few moments for Kubernetes to launch the new pod, and then refresh your
    browser; you should see your changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we update a deployment, behind the scenes Kubernetes creates a new replica
    set with the new configuration and handles rolling the new version out. Kubernetes
    also keeps track of the different configurations you have deployed. This also
    gives you the ability to roll a deployment back if required:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Resilience and scaling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Being able to provide services that are resilient to errors and issues in the
    underlying infrastructure is one of the key reasons why we might want to use Kubernetes
    to deploy our containerized applications.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to experiment with our `Hello World` deployment to discover how
    Kubernetes can deal with problems like these.
  prefs: []
  type: TYPE_NORMAL
- en: The first experiment is to see what happens when we deliberately remove the
    pod where our `hello` container is running.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we need to find the name of this pod, which we can do with the
    `kubectl get` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: On our Minikube cluster, we currently only have one pod running from the one
    deployment that we have created so far. Once you start to deploy more applications,
    the output from commands such as kubectl get can get lengthier. We can use the
    `-l` flag to pass a label selector to filter down the results. In this case, we
    would use `kubectl get pods -l run=hello` to show just the pods where the run
    label is set to `hello`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we can use the `kubectl delete` command to remove the resource. Deleting
    a pod also terminates the processes running inside of the constituent containers,
    effectively cleaning up the Docker environment on our node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'If we then rerun the `get pods` command, you should notice that the pod we
    deleted has been replaced by a new one with a new name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In Kubernetes, we can use replica sets (and deployments) to ensure that pod
    instances continue to run in our cluster despite unexpected events, be they a
    failed server, or a fat-fingered admin deleting our pod (as has happened in this
    case).
  prefs: []
  type: TYPE_NORMAL
- en: You should begin to understand as part of this exercise that a pod is an ephemeral
    entity. When it is deleted or the node it is running on fails, it is gone forever.
    Kubernetes ensures that the missing pod is replaced by another, created in its
    image from the same template. This means that any state that is stored on the
    local filesystem or in memory, the identity of the pod itself is also lost when
    a pod inevitably fails and is replaced.
  prefs: []
  type: TYPE_NORMAL
- en: This makes pods well-suited to some kinds of workload where it is not necessary
    for a state to be stored locally across runs, such as web applications and most
    batch jobs. If you are building new applications that you intend to deploy to
    Kubernetes, you will make them easier to manage by delegating the storage of state
    to an external store, such as a database or a service like Amazon S3.
  prefs: []
  type: TYPE_NORMAL
- en: We will explore features in Kubernetes that allow us to deploy applications
    that need to store local state and/or maintain a stable identity in *Chapter 9*,
    *Storing State*.
  prefs: []
  type: TYPE_NORMAL
- en: One problem you may have noticed when we were testing the abilities of Kubernetes
    to replace a pod that was removed is that, for a short time, our service became
    unavailable. For a simple example service running on a single node cluster such
    as this, perhaps this is not the end of the world. But we do really need a way
    for our applications to run in a way that minimizes even momentary downtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'The answer is, of course, to ask Kubernetes to run multiple pin stances for
    our application, so even if one is lost, a second can take the slack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'If we now check the pods running, we can see a second `hello` pod has joined
    the party:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Using the dashboard
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Kubernetes dashboard is a web application that runs within your Kubernetes
    cluster and offers an alternative, more graphical solution, for exploring and
    monitoring your cluster.
  prefs: []
  type: TYPE_NORMAL
- en: 'Minikube automatically installs the dashboard and provides a command that will
    open it in your web browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '![](assets/97e3c655-3fae-45db-a3ab-1ce32c32e713.png)The Kubernetes dashboard'
  prefs: []
  type: TYPE_NORMAL
- en: The dashboard interface is very easy to use, and you should begin to notice
    more than a few similarities with the way that `kubectl` works, since they both
    allow you to interact with the same underlying API.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Navigation bar on the left of the screen gives access to screens showing
    a list of resources of a particular kind. This is similar to the functionality
    provided by `the` `kubectl get` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/5817fc35-e344-49e5-96d8-44d5a6a6e8a4.png)Using the Kubernetes dashboard
    to list currently running pods'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this view, we can click on the icon that looks like a stack of papers in
    order to open a log viewer to view the logs captured from standard out in each
    container in the pod:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/5422944e-406e-47ce-a0db-88ded575e70b.png)Viewing container logs
    in the Kubernetes dashboard'
  prefs: []
  type: TYPE_NORMAL
- en: Other resources have other options appropriate to their function. For example,
    Deployments and Replica Sets have a dialog to scale the number of pods up or down.
  prefs: []
  type: TYPE_NORMAL
- en: 'By clicking on the name of a particular resource, we get a view that shows
    similar information to `kubectl describe`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/cc0795df-1269-417a-81b1-5fa11a837d58.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The detail screen provides us quite a lot of information about pods or other
    resources in Kubernetes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/b5830e05-da58-41a8-a5bf-7835b8866d94.png)'
  prefs: []
  type: TYPE_IMG
- en: As well as an overview of the configuration and settings for the resources,
    if you scroll to the bottom of the page, you should be able to see a feed of events.
    This is very useful if you are trying to debug issues and will highlight any errors
    or problems with a running resource.
  prefs: []
  type: TYPE_NORMAL
- en: 'For pods, we get a number of other options for managing and inspecting the
    container. For example, opening an in-browser terminal by clicking the exec button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a65495f4-3642-45ed-b80d-ef456c7014b3.png)Debugging a container using
    an interactive shell in the Kubernetes dashboard'
  prefs: []
  type: TYPE_NORMAL
- en: Currently**,** for this feature to work properly**,** your container needs to
    have `/bin/bash` available. This might change in future versions of the dashboard,
    but for now, to make this work add `RUN apk add --no-cache bash` to your `Dockerfile`
    and deploy the newly built image.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration as code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this chapter, we have interacted with Kubernetes by using commands
    provided by `kubectl` or the Kubernetes dashboard. In practice, I find that these
    tools are useful for quickly getting a container running in a cluster. When the
    configuration becomes more complex or I want to be able to deploy the same application
    to multiple environments, having a configuration file that I can submit to the
    cluster, and store in a version control system, is very useful.
  prefs: []
  type: TYPE_NORMAL
- en: '`kubectl` and indeed the Kubernetes dashboard, will allow us to submit YAML
    or JSON formatted configurations for the resources we want to create on the cluster.
    We are going to take another look at how we would deploy the same `Hello World`
    application using YAML-formatted files rather than commands such as `kubectl run`.'
  prefs: []
  type: TYPE_NORMAL
- en: This Kubernetes configuration is often referred to as a Manifest, and the YAML-or-JSON
    formatted files as Manifest files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by removing the configuration we created with `kubectl` so we
    have a clean state to reproduce the same configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s define a deployment for version 1 of the `hello` service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can use `kubectl` to submit the deployment to Kubernetes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s do the same for a service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Submit the definition to Kubernetes with `kubectl`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: You can see that while we have sacrificed the speed and simplicity of just running
    a command to create a deployment, by explicitly specifying the resources we want
    to create, we gain greater control over exactly how our pods are configured, and
    we now have this definition in a form that we can check into version control and
    reliably update.
  prefs: []
  type: TYPE_NORMAL
- en: 'When it comes to updating a resource, we can make an edit to the file and then
    use the `kubectl apply` command to update the resource. `kubectl` detects that
    we are updating an existing resource and updates it to match our configuration.
    Try editing the image tag in `deployment.yaml` and then re submitting it to the
    cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: If we are just making changes to the resource on our local cluster, we might
    just want to quickly change something without having to edit the file at all.
    Firstly, as in our previous example, you can use `kubectl set` to update a property.
    Kubernetes doesn't really care how we created the resource, so everything we did
    previously is still valid. The other method of making a quick change is with the
    `kubectl edit` command. Assuming you have the `$EDITOR` environment variable set
    up correctly with your favorite text editor, you should be able to open YAML for
    a resource, edit it, and then save while `kubectl` seamlessly updates the resource
    for you.
  prefs: []
  type: TYPE_NORMAL
- en: Troubleshooting Minikube
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One common problem that you might run into when trying to use Minikube is that
    you might not be able to access the VM because its network overlaps with another
    network configured on your machine. This can often happen if you are using a corporate
    VPN, or you connect to another network that configures routes for the `192.168.99.1/24`
    IP address range used by Minikube by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is simple to start Minikube with an alternative CIDR to be used for the
    VM. You can choose any private range that you want to use; just check that it
    won''t overlap with other services on your local network:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Well done for making it this far. If you have followed along with the examples
    in this chapter, you should be well on your way to learning how to use Kubernetes
    to manage your own applications. You should be able to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Use Minikube to set up a single node Kubernetes cluster on your workstation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build a simple application container using Docker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run a pod on your Minikube cluster
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Declare a Kubernetes configuration using a Manifest file, so you can reproduce
    your setup
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set up a service so you can access your application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
