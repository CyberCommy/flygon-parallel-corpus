- en: Preparing for Stateful Workloads
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will discuss using popular open source storage solutions
    on Kubernetes and how to protect the state of applications from node or application
    failures and share the same data, or how to handle reattaching volumes when the
    pod is rescheduled on a different node. After following the recipes in this chapter,
    you will have acquired the skills to use both block and file storage options in
    self-managed infrastructure or private clouds.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will be covering the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Managing Amazon EBS volumes in Kubernetes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing GCE PD volumes in Kubernetes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing Azure Disk volumes in Kubernetes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring and managing persistent storage using Rook
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring and managing persistent storage using OpenEBS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up NFS for shared storage on Kubernetes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Troubleshooting storage issues
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Recipes in this section assume that you have a functional Kubernetes cluster
    deployed according to one of the recommended methods described in  [Chapter 1](a8580410-3e1c-4e28-8d18-aaf9d38d011f.xhtml), *Building
    Production-Ready Kubernetes Clusters*.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes' command-line tool, `kubectl`, will be used for the remainder of
    the recipes in this section since it is the main command-line interface for running
    commands against Kubernetes clusters. We will also use `helm` where helm charts
    are available to deploy solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Managing Amazon EBS volumes in Kubernetes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Amazon Elastic Block Store (Amazon EBS) provides persistent block-level storage
    volumes for Amazon EC2 instances used in both `kops`-created Kubernetes clusters
    and Amazon EKS clusters in AWS. In this section, we will create storage classes
    for your applications in Kubernetes running in AWS. You will learn how to create
    a StorageClass resource in Kubernetes, you will learn about the parameters available with
    the variation in performance of EBS volume types and also use the new **Container
    Storage Interface** (**CSI**) to consume EBS volumes.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Clone the `k8sdevopscookbook/src` repository to your workstation in order to
    be able to use manifest files under the `chapter5` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Make sure that you have a Kubernetes cluster ready and `kubectl` configured
    to manage the cluster resources.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This section is sub-divided further into the following subsections to facilitate
    the process:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating an EBS storage class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing the default storage class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using EBS volumes for persistent storage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using EBS storage classes to dynamically create persistent volumes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deleting EBS persistent volumes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing the EBS CSI driver to manage EBS volumes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an EBS storage class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s perform the following steps to learn the storage class parameters required
    to construct an EBS storage class that we can use to dynamically request new persistent
    volumes from AWS Cloud:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a basic storage class with the provisioner, `kubernetes.io/aws-ebs`,
    and `gp2` type specified:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Other type values accepted here include `io1`, `sc1`, and `st1`. You can find
    the definition and use cases for different volume types on the AWS EBS volume
    types link in the *See also* section.
  prefs: []
  type: TYPE_NORMAL
- en: On Amazon EKS clusters, the default EBS volume type is `gp2`. For database workloads,
    such as MongoDB, Cassandra, and PostgreSQL, `io1-type`, high-performance SSDs
    are recommended.
  prefs: []
  type: TYPE_NORMAL
- en: 'List the storage classes. Confirm that you have new `aws-gp2` on the list.
    Depending on the cloud provider or Kubernetes deployment tool, you may see other
    storage classes on the list similar to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Storage classes are the foundation of dynamic provisioning. As you can see in
    our example, you may have more than one storage class in your cluster. Ideally,
    storage classes should be created with an application's requirements in mind,
    since certain applications require faster volumes, while others may take advantage
    of multi-availability zone replication provided by solutions such as Rook and
    OpenEBS, which we will deploy later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the default storage class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Dynamic storage provisioning is a key part of scaling applications. When a
    storage class is not specified by a **Persistent Volume Claim** (**PVC**), Kubernetes
    uses the default option. Let''s perform the following steps to set our preferred
    storage class as the default:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new storage class and define it as the default at the same time by
    setting the `is-default-class` value to `true`. Our example here uses the `io1`
    volume type and limits `iopsPerGB` to `10`. It also sets `reclaimPolicy` to `Retain`,
    meaning that, if the user deletes the related PVC, the volume will be retained
    (the other two retain policy options are `Recycle` and `Delete`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'To change the status of an existing storage class after it has been created,
    first pick a storage class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s set the existing storage class, `aws-io1-slow`, as the non-default option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, define `aws-gp2` as the default storage class again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Confirm the new default storage class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Make sure that there is always one default storage class at a time, otherwise
    PVCs without a storage class defined that are expecting a default storage class
    will fail.
  prefs: []
  type: TYPE_NORMAL
- en: Using EBS volumes for persistent storage
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As an alternative to creating PVCs and dynamically creating volumes, you can
    also manually create a volume and attach it to your application directly as a
    persistent volume by carrying out the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an EBS volume in the same zone as your worker nodes by using the following `aws`
    CLI:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Deploy a test application using the EBS `volumeID` you created in *Step 1:*
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Verify that your pod is in the `Running` state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The main advantage of manually created persistent volumes (PVs) is that PVs
    are not attached to a single cluster or namespace. They exist as a resource on
    your AWS cloud account and they can even be shared across clusters where dynamically
    created PVCs only exist in the namespace created and can only be used by a pod
    within that same namespace.
  prefs: []
  type: TYPE_NORMAL
- en: Using EBS storage classes to dynamically create persistent volumes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As part of a StatefulSet, `volumeClaimTemplates` can provide persistent storage
    using `PersistentVolumes` provisioned by a `PersistentVolume` provisioner of your
    choice. In this recipe, we will use StorageClass to dynamically create PVs for
    your application. Let''s begin with the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `aws-gp2` storage class line under the `volumeClaimTemplates` section
    of your application deployment manifest, similar to the following example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In this recipe, we will deploy the Redis StatefulSet using the `aws-gp2` storage
    class. Review the YAML manifest under the `src/chapter5/aws` directory in the
    example repository before we execute it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the Redis StatefulSet using the following example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Verify that pods have been created. In this recipe, our example has StatefulSet
    with three replicas. As a result, you should see three replicas running, similar
    to the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'List the PVC and PVs created. You should expect to see three PVCs and three
    PVs created similar to our example output here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Now, you know how to dynamically create persistent volumes as part of your deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting EBS persistent volumes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When the reclaim policy is set to retain the volumes, they need to be removed
    separately by observing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember that deleting your workload will not remove the PVCs and PVs, unless
    the PVC manifest was included in the manifest:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'List the remaining PVs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Delete the PVCs. You can delete multiple PVCs at once by adding their names
    in a single command, similar to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Delete the PVs. You can delete multiple PVs at once by adding their names in
    a single command, similar to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Although we removed PVCs and PVs, our EBS volumes are still retained. Let''s
    now remove these as well:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open your AWS Management Console and click on EC2 under the Compute options:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/e950d5e0-afe9-48f7-b588-31547287014d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Under the Resources section, click on Volumes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/d70688f4-a325-4cab-afbe-ab46f6fbfa53.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Select the available and unused volumes. From the *Using EBS storage classes
    to create dynamic persistent volumes *recipe, we have three unused volumes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/5bf71b92-1704-4166-af24-4ce639775da0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'From the Actions drop-down menu, select Delete Volumes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/9d9a918f-52e3-4ff9-ab64-6989ef4c5c27.png)'
  prefs: []
  type: TYPE_IMG
- en: We have successfully removed all storage resources related to the application
    that was created as part of the Redis StatefulSet resource.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the EBS CSI driver to manage EBS volumes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Amazon EBS CSI driver provides a Kubernetes CSI interface that allows Amazon
    EKS clusters to simply manage the life cycle of Amazon EBS volumes for persistent
    volumes. In this recipe, we will learn how to install the EBS CSI driver by observing
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'EBS CSI communicates with your AWS volume to create volumes on demand. Therefore,
    it requires access credentials. Replace the `key_id` and `access_key` values here
    with your AWS credentials and configure CSI driver permission using a secret resource:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Deploy the AWS EBS CSI driver from its repository location. The following command
    will create ClusterRoleBindings, CSI controller deployment, and an `ebs-csi-node`
    DaemonSet that will run every worker node you have:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Verify that the driver is running:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, create a new storage class that will use `ebs.csi.aws.com` as the provisioner:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a PVC:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a pod that will use the PVC and that writes to the `/data/out.txt` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Verify that our `mytestapp` pod writes data to the volume:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Remove resources by deleting the pod and the PVC by using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Now you know how to use CSI drivers to provision EBS volumes. A CSI driver provides
    a unified interface to answer storage requests on Kubernetes. As long as the driver
    is installed and has the functionality implemented by the driver, it can be consumed
    by the user regardless of the underlying storage system.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: AWS EBS volume types: [https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AWS EBS CSI driver repository: [https://github.com/kubernetes-sigs/aws-ebs-csi-driver](https://github.com/kubernetes-sigs/aws-ebs-csi-driver)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'AWS EBS CSI driver documentation: [https://docs.aws.amazon.com/eks/latest/userguide/ebs-csi.html](https://docs.aws.amazon.com/eks/latest/userguide/ebs-csi.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing GCE PD volumes in Kubernetes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Google Cloud Platform** (**GCP**) provides persistent block-level storage
    volumes for use with **Google Kubernetes Engine** (**GKE**) instances. In this section,
    we will create storage classes for your applications in Kubernetes running in
    the GKE. You will learn to create a StorageClass resource in Kubernetes, you will
    learn about the parameters available with the variation in performance of GCP
    PD volume types, and also use the new CSI.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Clone the `k8sdevopscookbook/src` repository to your workstation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Make sure that you have a regional GKE cluster ready and `kubectl` configured
    to manage the cluster resources.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This section is sub-divided further into the following subsections to facilitate
    the process:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a GCE persistent disk storage class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing the default storage class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using GCE PD volumes for persistent storage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using GCE PD storage classes to create dynamic persistent volumes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deleting GCE PD persistent volumes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing the GCP Compute PD CSI driver to manage PD volumes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a GCE persistent disk storage class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s perform the following steps to learn the storage class parameters to
    construct a GCE PD storage class that we can use to dynamically request new persistent
    volumes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'GKE-based Kubernetes clusters are created with a default storage class. List
    the storage classes as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Describe the `standard` storage class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a basic storage class with the provisioner, `kubernetes.io/gce-pd`,
    and the `pd-standard` type specified:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: You can find the definition and use cases for different volume types on the
    *GCE PD volume types* link in the *See also* section.
  prefs: []
  type: TYPE_NORMAL
- en: On GKE clusters, the default PD volume type is `pd-standard`. For database workloads,
    such as MongoDB, Cassandra, and PostgreSQL, `pd-ssd-type`, high-performance SSDs
    are recommended.
  prefs: []
  type: TYPE_NORMAL
- en: 'List the storage classes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: GKE comes with a default storage class called `standard`. You may have more
    than one storage class in your cluster. Ideally, storage classes should be created
    with an application's requirements in mind, since certain applications require
    faster volumes, while others may take advantage of multi-availability zone replication
    provided by other solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the default storage class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Dynamic storage provisioning is a key part of scaling applications. When a
    storage class is not specified by a PVC, Kubernetes uses the default option. Let''s
    perform the following steps to set our preferred storage class as the default:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a new storage class and define it as the default option at the
    same time by setting `is-default-class` to `true`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Having more than one default storage class will cause a problem. You need to
    remove one. To change the status of an existing storage class after it has been
    created, first pick a storage class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s set the `standard` and `gce-pd-ssd` storage classes as non-default:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now define `gce-pd` as the default storage class again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Confirm the new default storage class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Now you have learned how to replace the default storage class with a new storage
    class. Make sure that there is always one default storage class at a time; otherwise
    PVCs without a storage class defined that are expecting a default storage class
    will fail.
  prefs: []
  type: TYPE_NORMAL
- en: Using GCE PD volumes for persistent storage
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As an alternative to creating PVCs and dynamically creating volumes, you can
    also create a volume manually and attach it to your application directly as a
    persistent volume by observing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a GCE PD volume in the same zone as your worker nodes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a PV using the existing volume name, `gce-disk-1`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a PVC using the PV name, `gce-disk-1`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Deploy a test application using the `volumeMounts` name, `gce-disk-1`, that you
    have created in *Step 1:*
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Verify that your pod is in the `Running` state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The main advantage of manually created PVs is that PVs are not attached to a
    single cluster or namespace. They exist as a resource on your GCP account and
    they can even be shared across clusters. On the other hand, dynamically created
    PVCs only exist in the namespace created and can only be used by a pod within
    that same namespace.
  prefs: []
  type: TYPE_NORMAL
- en: Using GCE PD storage classes to create dynamic persistent volumes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As part of a StatefulSet, `volumeClaimTemplates` can provide persistent storage
    using `PersistentVolumes` provisioned by a `PersistentVolume` provisioner of your
    choice. In this recipe, we will use StorageClass to dynamically create PVs for
    your application:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `gce-pd` storage class line under the `volumeClaimTemplates` section
    of your application deployment manifest, similar to the following example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'In this recipe, we will deploy the Redis Statefulset using the `gce-pd` storage
    class. Review the YAML manifest under the `src/chapter5/gcp` directory in the
    example repository before we execute it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the Redis StatefulSet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Verify that pods have been created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'List the PVCs and PVs created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Now you know how to dynamically create GCE PD persistent volumes as part of
    your application deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting GCE PD persistent volumes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When the reclaim policy is set to retain the volumes, they need to be removed
    separately by observing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember that deleting your workload will not remove the PVCs and PVs, unless
    a PVC manifest was included in the manifest:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'List the remaining PVs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Delete the PVCs. You can delete multiple PVCs at once by adding their names
    in a single command, similar to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: We have successfully removed all storage resources related to the application
    that was created as part of the Redis StatefulSet resource.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the GCP Compute PD CSI driver to manage PD volumes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The GCP Compute PD CSI driver provides a Kubernetes CSI interface that allows
    GKE clusters to simply manage the life cycle of GKE volumes for persistent volumes.
    In this recipe, we will learn the steps required to install the GCP Compute PD
    CSI driver by observing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Clone the GCP CSI driver project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace the `PROJECT` name with your GCP project name, `GCE_PD_SA_DIR`, in
    the location where your service account private key file is stored and set the
    GCP service account variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Deploy the GCP Compute PD CSI driver:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Verify that the driver is running:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, create a new regional storage class using the `pd.csi.storage.gke.io` provisioner:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a PVC:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a pod that will use the PVC and that writes to the `/data/out.txt` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Verify that our `mytestapp` pod writes data to the volume:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Remove the resources:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Now you know how to utilize a CSI driver to deploy GCE PD volumes on GKE clusters.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe showed you how to quickly provision a dynamic persistent volume
    using Kubernetes storage classes, and PVC and PV concepts.
  prefs: []
  type: TYPE_NORMAL
- en: In the *Creating a GCP persistent disk storage class* recipe, in *Step 3*, you
    created `gce-pd` storage classes by using the `allowedTopologies` parameter and
    set two GKE zones, `us-central1-a` and `us-central1-b`, under the values.
  prefs: []
  type: TYPE_NORMAL
- en: When `allowedTopologies` is defined in a storage class, GCP creates a regional
    persistent disk and replicates the data between two zones in the same region for
    higher availability.
  prefs: []
  type: TYPE_NORMAL
- en: 'Volumes that are created with this option also get labeled in a similar manner
    to the label here: `failure-domain.beta.kubernetes.io/region : us-central1` and `failure-domain.beta.kubernetes.io/region
    : us-central1-a`'
  prefs: []
  type: TYPE_NORMAL
- en: Regional PDs help to survive a zonal outage. In that case, your Kubernetes cluster
    will failover workloads using the volume to the other zone.
  prefs: []
  type: TYPE_NORMAL
- en: This option is recommended when building highly available stateful workloads
    on GKE clusters.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'GCE PD types: [https://cloud.google.com/persistent-disk/](https://cloud.google.com/persistent-disk/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GCE PD CSI driver repository: [https://github.com/kubernetes-sigs/gcp-compute-persistent-disk-csi-driver](https://github.com/kubernetes-sigs/gcp-compute-persistent-disk-csi-driver)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing Azure Disk volumes in Kubernetes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Azure Cloud provides persistent block-level storage volumes for use with **Azure
    Kubernetes Engine** (**AKS**). In this section, we will create storage classes
    for your applications in Kubernetes running in the AKS. You will learn how to
    create a StorageClass resource in Kubernetes, you will learn about the parameters
    available with the variation in performance of Azure Disk volume types, and you
    will also learn how to use the new CSI.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Clone the `k8sdevopscookbook/src` repository to your workstation in order to
    use manifest files under the `chapter5` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Make sure you have a regional GKE cluster ready and `kubectl` configured to
    manage the cluster resources.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This section is sub-divided further into the following subsections to facilitate
    the process:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating an Azure Disk storage class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing the default storage class to ZRS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Azure Disk storage classes to create dynamic PVs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deleting Azure Disk persistent volumes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing the Azure Disk CSI driver
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an Azure Disk storage class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s perform the following steps to learn the storage class parameters required
    to construct an Azure Disk storage class that we can use to dynamically request
    new persistent volumes from AKS:'
  prefs: []
  type: TYPE_NORMAL
- en: 'AKS-based Kubernetes clusters are created with two locally redundant (LRS)
    storage classes by default. Let''s list the storage classes on your AKS cluster:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Describe the `default` storage class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a zone-redundant storage class with the provisioner, `kubernetes.io/azure-disk`,
    and the `Standard_ZRS` skuName specified:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: You can find the definition and use cases for different volume types on the
    *Azure Disk volume types* link in the *See also* section.
  prefs: []
  type: TYPE_NORMAL
- en: On Azure Cloud clusters, the default Azure Disk volume type is `Standard_LRS`.
    For database workloads, such as MongoDB, Cassandra, and PostgreSQL, `Premium_LRS`-type,
    high-performance SSDs are recommended.
  prefs: []
  type: TYPE_NORMAL
- en: 'List the storage classes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in our example, AKS clusters come with two predefined storage
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the default storage class to ZRS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Dynamic storage provisioning is a key part of scaling applications. When a
    storage class is not specified by a PVC, Kubernetes uses the default option. Let''s
    perform the following steps to set our preferred storage class as the default:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s set the existing `default` storage class as the non-default option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, define `azure-zrs` as the default storage class again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Confirm the new default storage class. You should see new `azure-zrs` as the
    default, similar to the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Now you know how to set your preferred storage class as the default on your
    AKS cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Using Azure Disk storage classes to create dynamic PVs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As part of a StatefulSet, `volumeClaimTemplates` can provide persistent storage
    using `PersistentVolumes` provisioned by a `PersistentVolume` provisioner of your
    choice. In this recipe, we will use the Azure storage class to dynamically create
    PVs for your application:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `azure-zrs` storage class line under the `volumeClaimTemplates` section
    of your application deployment manifest, similar to the following example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'In this recipe, we will deploy Redis Statefulset using the `azure-zrs` storage
    class. Review the YAML manifest under the `src/chapter5/azure` directory in the
    example repository before we execute it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the Redis StatefulSet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Verify that pods have been created. In this recipe, our example has StatefulSet
    with three replicas. As a result, you should see three replicas running, similar
    to the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'List the PVCs and PVs created. You should expect to see three PVCs and three
    PVs created, similar to our example output here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Now you know how to dynamically create persistent volumes as part of your application
    deployment on AKS clusters.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting Azure Disk persistent volumes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When the reclaim policy is set to retain the volumes, they need to be removed
    separately by observing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember that deleting your workload will not remove the PVCs and PVs unless
    the PVC manifest was included in the manifest:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'List the remaining PVs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Delete the PVCs. You can delete multiple PVCs at once by adding their names
    in a single command, similar to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: We have now successfully removed all storage resources related to the application
    that was created as part of the Redis StatefulSet resource.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the Azure Disk CSI driver
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Azure Disk CSI driver provides a Kubernetes CSI that allows AKS clusters
    to simply manage the life cycle of Azure Disk volumes for persistent volumes.
    In this recipe, we will learn the steps required to install the Azure Disk CSI
    driver by observing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Deploy the Azure Disk CSI driver:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Verify that the driver is running that controller and that the `azuredisk-node`
    DaemonSet is running:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, create a new storage class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a PVC using the storage class name, `disk.csi.azure.com`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a pod that will use the `csi-azure-pvc` PVC and that writes to the `/data/out.txt` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Verify that our `mytestapp` pod writes data to the volume:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Now you know how to use the Azure Disk CSI driver to provision persistent volumes
    on your AKS clusters.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Azure Disk volume types: [https://azure.microsoft.com/en-us/pricing/details/managed-disks/](https://azure.microsoft.com/en-us/pricing/details/managed-disks/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AWS EBS CSI driver repository: [https://github.com/kubernetes-sigs/azuredisk-csi-driver](https://github.com/kubernetes-sigs/azuredisk-csi-driver)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring and managing persistent storage using Rook
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rook is a cloud-native, open source storage orchestrator for Kubernetes. Rook
    provides self-managing, self-scaling, and self-healing distributed storage systems
    in Kubernetes. In this section, we will create multiple storage providers using
    the Rook storage orchestrator for your applications in Kubernetes. You will learn
    to create a Ceph provider for your stateful applications that require persistent
    storage.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Make sure that you have a Kubernetes cluster ready and `kubectl` configured
    to manage the cluster resources.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This section is sub-divided further into the following subsections to facilitate
    the process:'
  prefs: []
  type: TYPE_NORMAL
- en: Installing a Ceph provider using Rook
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a Ceph cluster
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Verifying a Ceph cluster's health
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a Ceph block storage class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a Ceph block storage class to create dynamic PVs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing a Ceph provider using Rook
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s perform the following steps to get a Ceph scale-out storage solution
    up and running using the Rook project:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Clone the Rook repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Deploy the Rook Operator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Verify the Rook Operator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Now you have learned how to deploy the Rook orchestration components for the
    Ceph provider running on Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Ceph cluster
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s perform the following steps to deploy a Ceph cluster using the Rook
    Operator:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a Ceph cluster:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Verify that all pods are running:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Within a minute, a fully functional Ceph cluster will be deployed and ready
    to be used. You can read more about Ceph in the *Rook Ceph Storage Documentation*
    link in the *See also* section.
  prefs: []
  type: TYPE_NORMAL
- en: Verifying a Ceph cluster's health
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Rook toolbox is a container with common tools used for rook debugging and
    testing. Let''s perform the following steps to deploy the Rook toolbox to verify
    cluster health:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Deploy the Rook toolbox:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Verify that the toolbox is running:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Connect to the toolbox:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Verify that the cluster is in a healthy state (`HEALTH_OK`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'When you are finished troubleshooting, remove the deployment using the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: Now you know how to deploy the Rook toolbox with its common tools that are used
    to debug and test Rook.
  prefs: []
  type: TYPE_NORMAL
- en: Create a Ceph block storage class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s perform the following steps to create a storage class for Ceph storage.:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create `CephBlockPool`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a Rook Ceph block storage class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'Confirm that the storage class has been created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the preceding provisioner name, `rook-ceph.rbd.csi.ceph.com`,
    Rook also uses CSI to interact with Kubernetes APIs. This driver is optimized
    for RWO pod access where only one pod may access the storage.
  prefs: []
  type: TYPE_NORMAL
- en: Using a Ceph block storage class to create dynamic PVs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this recipe, we will deploy Wordpress using dynamic persistent volumes created
    by the Rook Ceph block storage provider. Let''s perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Clone the examples repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'Review both `mysql.yaml` and `wordpress.yaml`. Note that PVCs are using the
    `rook-ceph-block` storage class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'Deploy MySQL and WordPress:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'Confirm the persistent volumes created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'Get the external IP of the WordPress service:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the external IP of the WordPress service in your browser to access your
    Wordpress deployment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/0903a69e-08b1-472b-b066-e1f786c21455.png)'
  prefs: []
  type: TYPE_IMG
- en: Now you know how to get the popular WordPress service, with persistent storage
    stored on Rook-based Ceph storage, up and running.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Rook documentation: [https://rook.io/docs/rook/master/](https://rook.io/docs/rook/master/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rook Ceph storage documentation: [https://rook.io/docs/rook/master/ceph-storage.html](https://rook.io/docs/rook/master/ceph-storage.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Rook community slack channel: [https://slack.rook.io/](https://slack.rook.io/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring and managing persistent storage using OpenEBS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OpenEBS is a popular open source, cloud-native storage (CNS) project with a
    large community. In this section, we will install an OpenEBS persistent storage
    provider. You will learn how to create volumes using different types of storage
    engine options for stateful workloads on Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we need to have `helm` and `kubectl` installed. Make sure you
    have a Kubernetes cluster ready and `kubectl` configured to manage the cluster
    resources.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This section is sub-divided further into the following subsections to facilitate
    the process:'
  prefs: []
  type: TYPE_NORMAL
- en: Installing iSCSI client prerequisites
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing OpenEBS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using ephemeral storage to create persistent volumes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating storage pools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating OpenEBS storage classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using an OpenEBS storage class to create dynamic PVs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing iSCSI client prerequisites
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The OpenEBS storage provider requires that the iSCSI client runs on all worker
    nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'On all your worker nodes, follow the steps to install and enable `open-iscsi`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'Validate that the iSCSI service is running:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'If the service status is showing as inactive, then enable and start the iscsid
    service:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: After installing the iSCSI service, you are ready to install OpenEBS on your
    cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Installing OpenEBS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s perform the following steps to quickly get the OpenEBS control plane
    installed:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install OpenEBS services by using the operator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'Confirm that all OpenEBS pods are running:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: OpenEBS consists of the core components listed here. Node Disk Manager (NDM)
    is one of the important pieces of OpenEBS that is responsible for detecting disk
    changes and runs as DaemonSet on your worker nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Using ephemeral storage to create persistent volumes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'OpenEBS currently provides three storage engine options (Jiva, cStor, and LocalPV).
    The first storage engine option, `Jiva`, can create replicated storage on top
    of the ephemeral storage. Let''s perform the following steps to get storage using
    ephemeral storage configured:'
  prefs: []
  type: TYPE_NORMAL
- en: 'List the default storage classes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'Describe the `openebs-jiva-default` storage class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a persistent volume claim using `openebs-jiva-default`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'Confirm that the PVC status is `BOUND`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, use the PVC to dynamically provision a persistent volume:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'Now list the pods and make sure that your workload, OpenEBS controller, and
    replicas are all in the running state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: Now you know how to get highly available, cloud-native storage configured for
    your stateful applications on Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Creating storage pools
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this recipe, we will use raw block devices attached to your nodes to create
    a storage pool. These devices can be AWS EBS volumes, GCP PDs, Azure Disk, virtual
    disks, or vSAN volumes. Devices can be attached to your worker node VMs, or basically
    physical disks if you are using a bare-metal Kubernetes cluster. Let''s perform
    the following steps to create a storage pool out of raw block devices:'
  prefs: []
  type: TYPE_NORMAL
- en: 'List unused and unclaimed block devices on your nodes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: In our example, we have a three-node Kubernetes cluster on AWS EC2 with one
    additional EBS volume attached to each node.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a storage pool using the unclaimed devices from *Step 1*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'List the storage pool claims:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'Verify that a cStor pool has been created and that its status is `Healthy`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: Now we can use the storage pool in storage classes to provision dynamic volumes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating OpenEBS storage classes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s perform the following steps to create a new storage class to consume
    StoragePool, which we created previously in the *Creating storage pools* recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an OpenEBS cStor storage class using the cStor `StoragePoolClaim` name, `cstor-disk-pool`,
    with three replicas:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'List the storage classes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'Set the `gp2` AWS EBS storage class as the non-default option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'Define `openebs-cstor-default` as the default storage class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: Make sure that the previous storage class is no longer set as the default and
    that you only have one default storage class.
  prefs: []
  type: TYPE_NORMAL
- en: Using an OpenEBS storage class to create dynamic PVs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s perform the following steps to deploy dynamically created persistent
    volumes using the OpenEBS storage provider:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Clone the examples repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: Review `minio.yaml` and note that PVCs are using the `openebs-stor-default` storage
    class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Deploy Minio:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'Get the Minio service load balancer''s external IP:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'Add port `9000` to the end of the address and open the external IP of the Minio
    service in your browser:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use the username `minio`, and the password `minio123` to log in to the Minio
    deployment backed by persistent OpenEBS volumes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/04aacbb2-701d-474e-bc57-dd66a0ae32f3.png)'
  prefs: []
  type: TYPE_IMG
- en: You have now successfully deployed a stateful application that is deployed on
    the OpenEBS cStor storage engine.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe showed you how to quickly provision a persistent storage provider
    using OpenEBS.
  prefs: []
  type: TYPE_NORMAL
- en: In the *Using ephemeral storage to create persistent volumes* recipe, in *Step
    6*, when we deployed a workload using the `openebs-jiva-default` storage class,
    OpenEBS launched OpenEBS volumes with three replicas.
  prefs: []
  type: TYPE_NORMAL
- en: 'To set one replica, as is the case with a single-node Kubernetes cluster, you
    can create a new storage class (similar to the one we created in the *Creating
    OpenEBS storage class* recipe) and set the `ReplicaCount` variable value to `1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: When ephemeral storage is used, the OpenEBS Jiva storage engine uses the `/var/openebs`
    directory on every available node to create replica sparse files. If you would
    like to change the default or create a new StoragePool resource, you can create
    a new storage pool and set a custom path.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: OpenEBS documentation: [https://docs.openebs.io/](https://docs.openebs.io/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Beyond the basics: OpenEBS workshop: [https://github.com/openebs/community/tree/master/workshop](https://github.com/openebs/community/tree/master/workshop)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OpenEBS Community Slack channel: [https://openebs.io/join-our-slack-community](https://openebs.io/join-our-slack-community)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OpenEBS enterprise platform: [https://mayadata.io/product](https://mayadata.io/product)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OpenEBS director for managing stateful workloads: [https://account.mayadata.io/login](https://account.mayadata.io/login)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up NFS for shared storage on Kubernetes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although it's not the best-performing solution, NFS is still used with cloud-native
    applications where multi-node write access is required. In this section, we will
    create an NFS-based persistent storage for this type of application. You will
    learn how to use OpenEBS and Rook to **ReadWriteMany** (**RWX**) accessible persistent
    volumes for stateful workloads that require shared storage on Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we need to have either `rook` or `openebs` installed as an
    orchestrator. Make sure that you have a Kubernetes cluster ready and `kubectl`
    configured to manage the cluster resources.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two popular alternatives when it comes to providing an NFS service.
    This section is sub-divided further into the following subsections to explain
    the process using Rook and OpenEBS:'
  prefs: []
  type: TYPE_NORMAL
- en: Installing NFS prerequisites
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing an NFS provider using a Rook NFS operator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a Rook NFS operator storage class to create dynamic NFS PVs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing an NFS provider using OpenEBS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the OpenEBS operator storage class to create dynamic NFS PVs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing NFS prerequisites
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To be able to mount NFS volumes, NFS client packages need to be preinstalled
    on all worker nodes where you plan to have NFS-mounted pods:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are using Ubuntu, install `nfs-common` on all worker nodes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: 'If using CentOS, install `nfs-common` on all worker nodes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: Now we have `nfs-utils` installed on our worker nodes and are ready to get the
    NFS server to deploy.
  prefs: []
  type: TYPE_NORMAL
- en: Installing an NFS provider using a Rook NFS operator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s perform the following steps to get an NFS provider functional using
    the Rook NFS provider option:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Clone the Rook repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'Deploy the Rook NFS operator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: 'Confirm that the operator is running:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a namespace, `rook-nfs`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: Make sure that you have defined your preferred storage provider as the default
    storage class. In this recipe, we are using `openebs-cstor-default`, defined in
    persistent storage using the OpenEBS recipe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a PVC:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the NFS instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: 'Verify that the NFS pod is in the `Running` state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: By observing the preceding command, an NFS server instance type will be created.
  prefs: []
  type: TYPE_NORMAL
- en: Using a Rook NFS operator storage class to create dynamic NFS PVs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'NFS is used in the Kubernetes environment on account of its `ReadWriteMany`
    capabilities for the application that requires access to the same data at the
    same time. In this recipe, we will perform the following steps to dynamically
    create an NFS-based persistent volume:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create Rook NFS storage classes using `exportName`, `nfsServerName`, and `nfsServerNamespace`
    from the *Installing an NFS provider using a Rook NFS operator* recipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can use the `rook-nfs-share1` storage class to create PVCs for applications
    that require `ReadWriteMany` access:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: By observing the preceding command, an NFS PV will be created.
  prefs: []
  type: TYPE_NORMAL
- en: Installing an NFS provisioner using OpenEBS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'OpenEBS provides an NFS provisioner that is protected by the underlying storage
    engine options of OpenEBS. Let''s perform the following steps to get an NFS service
    with OpenEBS up and running:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Clone the examples repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: 'In this recipe, we are using the `openebs-jiva-default` storage class. Review
    the directory content and apply the `YAML` file under the NFS directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: 'List the PVCs and confirm that a PVC named `openebspvc` has been created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: Using the OpenEBS NFS provisioner storage class to create dynamic NFS PVs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s perform the following steps to dynamically deploy an NFS PV protected
    by the OpenEBS storage provider:'
  prefs: []
  type: TYPE_NORMAL
- en: 'List the storage classes, and confirm that `openebs-nfs` exists:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can use the `openebs-nfs` storage class to create PVCs for applications
    that require `ReadWriteMany` access:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Rook NFS operator documentation: [https://github.com/rook/rook/blob/master/Documentation/nfs.md](https://github.com/rook/rook/blob/master/Documentation/nfs.md)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OpenEBS provisioning read-write-many PVCs: [https://docs.openebs.io/docs/next/rwm.html](https://docs.openebs.io/docs/next/rwm.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Troubleshooting storage issues
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you will learn how to solve the most common storage issues
    associated with Kubernetes. After following the recipes in this chapter, you will
    gain the basic skills required to troubleshoot persistent volumes stuck in pending
    or termination states.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Make sure that you have a Kubernetes cluster ready and `kubectl` configured
    to manage the cluster resources.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This section is sub-divided further into the following subsections to facilitate
    the process:'
  prefs: []
  type: TYPE_NORMAL
- en: Persistent volumes in the pending state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A PV is stuck once a PVC has been deleted
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Persistent volumes in the pending state
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You have deployed an application, but both pods and persistent volume claims
    are stuck in the pending state, similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s perform the following steps to start troubleshooting:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, describe the PVC to understand the root cause:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: 'A PVC is stuck due to an incorrect or non-existing storage class. We need to
    change the storage class with a valid resource. List the storage classes as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: Delete the deployment using `kubectl delete -f <deployment.yaml>`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Edit the deployment and replace the `storageClassName` field with a valid storage
    class from the output of the previous step, in our case, `openebs-cstor-default`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Redeploy the application using `kubectl apply -f <deployment.yaml>`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Confirm that the PVC status is `Bound`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: Now you have successfully troubleshooted PVC issues caused by a missing StorageClass
    resource.
  prefs: []
  type: TYPE_NORMAL
- en: A PV is stuck once a PVC has been deleted
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You have deleted a PVC. However, either the PVC or PV deletion is stuck in
    the terminating state, similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: 'Edit the stuck PVs or PVCs in the terminating state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: Remove finalizers similar to `- kubernetes.io/pv-protection`, and save the changes.
  prefs: []
  type: TYPE_NORMAL
