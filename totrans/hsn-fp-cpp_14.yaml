- en: Property-Based Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've seen that pure functions have one important property—they return the same
    output for the same inputs. We've also seen that this property allows us to easily
    write example-based unit tests for pure functions. Moreover, we can write data-driven
    tests, allowing one test function to be reused with multiple inputs and outputs.
  prefs: []
  type: TYPE_NORMAL
- en: It turns out that we can do even better. Instead of, or in addition to, writing
    many lines of data-driven tests, we can take advantage of mathematical properties
    of pure functions. This technique is possible due to data generators that are
    enabled by functional programming. These tests are confusingly named **property-based
    tests**; you'll have to remember that the name comes from mathematical properties
    of pure functions, and not from properties implemented in classes or objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the idea of property-based tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to write generators and take advantage of them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to get to property-based tests from example-based tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to write good properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need a compiler that supports C++ 17\. I used GCC 7.4.0.
  prefs: []
  type: TYPE_NORMAL
- en: The code can be found on GitHub at [https:/​/​github.​com/​PacktPublishing/​Hands-​On-​Functional-Programming-​with-​Cpp](https://github.%E2%80%8Bcom/PacktPublishing/Hands-On-Functional-Programming-with-Cpp)
    in the `Chapter11` folder. It includes and uses `doctest`, which is a single header
    open source unit testing library. You can find it on its GitHub repository at [https:/​/github.com/​onqtam/​doctest](https://github.%E2%80%8Bcom/onqtam/doctest).
  prefs: []
  type: TYPE_NORMAL
- en: Property-based testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Unit tests are an extremely useful software development technique. A good suite
    of unit tests can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Speed up deployments by automating the boring parts of regression testing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enable professional testers to find the hidden issues rather than running the
    same test plan again and again.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remove bugs very early in the development process, thereby reducing the cost
    of finding and fixing them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improve the software design by providing feedback as a first client of the code
    structure (if tests are complicated, most likely your design is complicated),
    as long as the developers know how to see and interpret the feedback.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Increase the trust in the code, hence allowing for more changes, and thereby
    facilitating refactoring that speeds up development or removes risks from the
    code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I love writing unit tests. I love figuring out the interesting test cases, and
    I love using tests to drive my code—as you've seen in [Chapter 9](f3b31186-dfef-496e-bc6e-82a55eeb0cba.xhtml),
    *Test-Driven Development for Functional Programming*. At the same time, I'm always
    looking for better ways to write the tests, since it would be great if we could
    speed up the process.
  prefs: []
  type: TYPE_NORMAL
- en: We've seen in [Chapter 9](f3b31186-dfef-496e-bc6e-82a55eeb0cba.xhtml), *Test-Driven
    Development for Functional Programming*, that pure functions allow us to more
    easily identify test cases, because, by definition, their outputs are constrained.
    It turns out that we can go further than that if we venture into the realm of
    mathematical properties associated with these pure functions.
  prefs: []
  type: TYPE_NORMAL
- en: If you've been writing unit tests for a while, you probably had the feeling
    that some of the tests are a bit redundant. If only we could write tests like
    this—for inputs in a certain interval of values, the expected outputs must have
    a certain property. It turns out that, with the help of data generators and a
    bit of abstract thinking, we can make this work.
  prefs: []
  type: TYPE_NORMAL
- en: Let's compare approaches.
  prefs: []
  type: TYPE_NORMAL
- en: Example-based tests versus property-based tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s take an example of the `power` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'How would you test it using example-based tests? We need to figure out a few
    interesting values for first and second and combine them. We''ll limit ourselves
    to positive integers for the goal of this exercise. In general, interesting values
    for integers are—`0`, `1`, many, and maximum. This leads to the following possible
    cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '*0⁰ -> undefined* (* the `pow` implementation in C++ returns `1` unless specific
    errors are enabled)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*0^(any integer from 0 to max) -> 0*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*1^(any integer) -> 1*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*(any integer except 0)⁰ -> 1*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*2² -> 4*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*2^(max integer that doesn''t overflow) -> value to be computed*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*10⁵ -> 100000*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*10^(max integer that doesn''t overflow) -> value to be computed*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This list is by no means complete, but it shows an interesting analysis of
    the problem. So, let''s write these tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This is obviously not the full list of tests we would need to check to establish
    that the power function works, but it's a good start. While looking at this list,
    I'm wondering, what do you think—would you write more or fewer tests? I would
    definitely want to write more, but I lost the drive in the process. Sure, one
    of the issues is that I wrote these tests after the code; I'm much more motivated
    to write them along with the code as in **Test-Driven Development** (**TDD**).
    But maybe there's a better way?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s think differently for a moment. Are there properties we can test that
    hold for some or all of the expected outputs? Let''s write a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '*0⁰ -> undefined (1 by default in pow function in C++)*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*0^([1 .. maxInt]) -> 0*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*value: [1 .. maxInt]⁰ -> 1*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*value: [0 .. maxInt]¹ -> value*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These are some obvious properties. They cover, however, only a small subset
    of the values. We still need to cover the general case of *x**^y*, where both
    *x* and *y* are neither `0` nor `1`. Can we find any property here? Well, think
    about the mathematical definition of integer power—it''s a repeated multiplication.
    We can therefore infer, for any *x* and *y* value greater than `1`, the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/785b00f6-7df4-4d02-94ee-1e520377ed0c.png)'
  prefs: []
  type: TYPE_IMG
- en: We do have a boundary issue here, since the computation might overflow. So,
    the values of *x* and *y* need to be picked so that *x^y* is smaller than `maxInt`.
    One way to deal with this issue is to pick *x* first and pick *y* between *y=2*
    and `maxy=floor(log[x]maxInt)`. To make it as close to boundaries as possible,
    we should always pick `maxy` as a value. To check for the overflow case, we just
    need to test that *x* to the power of `maxy + 1` overflows.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding approach implies, of course, that we trust the result of the logarithm
    function from the standard library. If your *tester paranoia* is larger than mine,
    I suggest using a verified logarithm table for all bases from `2` to `maxInt`
    and the value `maxInt`. I will, however, use the STL logarithm function.
  prefs: []
  type: TYPE_NORMAL
- en: We now have a list of the mathematical properties of the power function. But
    we'd like to implement them as previously seen, with intervals. Can we even do
    that? Enter data generators.
  prefs: []
  type: TYPE_NORMAL
- en: Generators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Generators are a staple feature of functional programming languages. They are
    usually implemented through a combination of lambdas and lazy evaluation, allowing
    code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The generator function usually generates an infinite number of values, but because
    it is lazy evaluated, the `100` values materialize only when `pick` is called.
  prefs: []
  type: TYPE_NORMAL
- en: C++ doesn't yet have standard support for lazy evaluation and data generators,
    so we'll have to implement our own generator. It's worth noting that C++ 20 has
    adopted the inclusion of the awesome ranges library in the standard, which enables
    both these features. For the goals of this chapter, we'll stick to the standard
    available today, but you'll find the basic usage of ranges library in the final
    chapters of this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, how can we generate data? STL offers us a nice way to generate uniformly
    distributed random integers by using the `uniform_int_distribution` class. Let''s
    first look at the code; I''ve added comments to explain what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This function will generate uniformly distributed numbers from `min` to `max`.
    I prefer to always include the edges of the intervals, since these are always
    interesting values for tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re also using a function called `range` that you haven''t seen yet. Its
    goal is to fill a vector with the values from `minValue` to `maxValue` to allow
    simpler transformations. Here it is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: It's worth noting that ranges are usually lazy-evaluated in functional programming
    languages, which highly reduces their memory footprint. For the goals of our example
    though, this works fine.
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous `generator` function allows us to create input data for our tests,
    uniformly distributed between one and the maximum integer value. It just takes
    a simple bind:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Let's use this for our property-based tests.
  prefs: []
  type: TYPE_NORMAL
- en: Putting the properties to the test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s see again the list of properties that we''d like to check:'
  prefs: []
  type: TYPE_NORMAL
- en: '*0⁰ -> undefined (1 by default in pow function in C++)*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*0^([1 .. maxInt]) -> 0*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*value: [1 .. maxInt]⁰ -> 1*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*value: [0 .. maxInt]¹ -> value*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*x^y = x^(y-1) * x*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will now implement each of the properties in turn. For every property, we
    will use either a normal example-based test, or the data generators inspired by
    the `generate_ints_greater_than_1` function. Let's start with the simplest property—*0⁰*
    should be undefined—or actually `1` in its standard implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Property: 00 -> undefined
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first one is quite simple to implement using a normal example-based test.
    We''ll extract it in a function for the sake of consistency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In our test, we will write a description of the property, as well, in order
    to obtain an informative output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'When run, this results in the following output, passing the test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This was easy enough! We now have a basic structure for property-based test.
    The next test will require a data generator, but we already have it. Let's see
    how it will work for the `0` property to any power, except `0` equals `0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Property: 0[1 .. maxInt] -> 0'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We need our number generator from `1` to `maxInt`, which we''ve already implemented.
    We then need a property function that checks that, for any exponent from `1` to
    `maxInt`, `0` raised to the exponent equals `0`. The code is quite easy to write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to check this property. Since we have a list of generated values,
    we can use the `all_of` function to check all of them against the property. To
    make things more informative, I decided to display the list of values we''re using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can write our test. We once again display the property name before
    the test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the test gives the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, a bunch of random values are used for the test, and the final
    two values are `1` and `maxInt`.
  prefs: []
  type: TYPE_NORMAL
- en: It's time to pause and reflect for a minute. These tests are unusual. One of
    the key ideas in unit testing is to have repeatable tests, but here, we have a
    bunch of random values. Do these count? And what do we do when one value leads
    to a failure?
  prefs: []
  type: TYPE_NORMAL
- en: These are great questions! First, using property-based tests doesn't exclude
    example-based tests. In fact, we are mixing the two right now—*0⁰* is an example
    rather than a property. So, don't hesitate to check for any specific values when
    it makes sense.
  prefs: []
  type: TYPE_NORMAL
- en: Second, libraries that support property-based testing allow the collection of
    specific failure values and retesting for those automatically. It's simple enough—whenever
    there's a failure, save the values somewhere, and include them in the generation
    the following occasions when the tests are run. Not only does this allow you to
    test more thoroughly, but you also discover the behaviors of the code.
  prefs: []
  type: TYPE_NORMAL
- en: We have, therefore, to look at example-based testing and property-based testing
    as complementary techniques. The first helps you to drive the code using **Test-Driven
    Development** (**TDD**) and check the interesting cases. The second allows you
    to find the cases you haven't considered and retest for the same mistakes. Both
    are useful, just in different ways.
  prefs: []
  type: TYPE_NORMAL
- en: Let's go back to writing our properties, then. The next one is about any number
    to the power `0` equals `1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Property: value: [1 .. maxInt]0 -> 1'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have everything in place, and we just need to write it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The test then becomes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'And running the test leads to the following output (a few lines are omitted
    for brevity):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: You can see from the preceding samples that the numbers are indeed random, while
    always including `1` and `maxInt`.
  prefs: []
  type: TYPE_NORMAL
- en: We're getting the hang of this! The next property is that any value to the power
    of `1` is the value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Property: value: [0 .. maxInt]1 -> value'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We need another generator method, starting from `0`. We just need to use the
    bind magic again to obtain the required result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This property is easy enough to write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The test is obvious:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Running the test leads once again to a pass.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a moment to reflect once again:'
  prefs: []
  type: TYPE_NORMAL
- en: How many values do we check? The answer is `301`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How many lines of test code are there? The test code is just 23 lines of code,
    while the *library* functions that we reuse for our tests are roughly 40 lines
    of code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Isn't this amazing? Doesn't this make a worthy investment in your testing?
  prefs: []
  type: TYPE_NORMAL
- en: We know how to do this. It's time for the most complex property from our exercise—any
    number raised to power *y* equals the number raised to the power *y-1* multiplied
    by the number.
  prefs: []
  type: TYPE_NORMAL
- en: Property: xy = xy-1 * x
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This will require us to generate two sets of values, *x* and *y*, so that *x^y
    < maxInt*. It took me some fiddling with the data generators, but I figured out
    that any *x* that''s larger than ![](img/26c14df0-ec8d-4ebe-96a3-b44950f3df7c.png)
    can only be tested for *y=1*. I will therefore use two generators; the first one
    will generate numbers between `2` and ![](img/11ab32f9-a191-4287-803b-b8c1f5457f18.png),
    while the second generates numbers greater than ![](img/5406f9ba-b514-4cb4-9a41-d1d3813e3745.png)
    and smaller than `maxInt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The first part of the property becomes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to implement the property, we also need to generate exponents for
    the `x` base, so that we can write the property as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from the name of the generator function, we need to generate
    numbers between `1` and *log[x]maxInt*. Any number above this value will overflow
    when computing x^y. Since we don''t have a general logarithm function in STL,
    we need to implement one. To compute *log[x]maxInt*, we just need to use a mathematical
    equality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'And our generator function becomes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'With this in place, we can run our tests. Here''s a brief portion of the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The final part of the test is to add the interval from ![](img/11ab32f9-a191-4287-803b-b8c1f5457f18.png)
    + 1 to `maxInt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This also leads to an update in the generation function to support a few edge
    cases; refer to the comments for explanations in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: And with this, we've implemented our final property!
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''re now checking all of the following things with just a few lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '*0⁰ -> undefined (1 by default in pow function in C++)*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*0^([1 .. maxInt]) -> 0*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*value: [1 .. maxInt]⁰ -> 1*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*value: [0 .. maxInt]¹ -> value*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*x^y = x^(y-1) * x*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How does this compare with the more commonly used approach of having example-based
    tests? We test more with less code. We can find hidden issues in code. But the
    properties are more difficult to identify than examples. We've also established
    that property-based tests work very well together with example-based tests.
  prefs: []
  type: TYPE_NORMAL
- en: So, let's tackle now the problem of finding the properties. This requires a
    bit of analysis, and we'll explore a practical way in which you can evolve the
    properties from examples through data-driven tests.
  prefs: []
  type: TYPE_NORMAL
- en: From examples to data-driven tests to properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When I first heard about property-based tests, I had two issues. First, I thought
    they were meant to replace example tests—and we know now that they are not; just
    use the two techniques side by side. Second, I had no idea how to come up with
    good properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'I had, however, a good idea on how to come with good examples and how to remove
    duplication between tests. We''ve seen a sample on how to come up with good examples
    for the power function; let''s recap them:'
  prefs: []
  type: TYPE_NORMAL
- en: '*0⁰ -> undefined (* the pow implementation in C++ returns 1 unless specific
    errors are enabled)*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*0^(any integer from 0 to max) -> 0*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*1^(any integer) -> 1*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*(any integer except 0)⁰ -> 1*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*2² -> 4*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*2^(max int that doesn''t overflow) -> value to be computed*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*10⁵ -> 100000*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*10^(max int that doesn''t overflow) -> value to be computed*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We''ve also seen that it''s easy enough to write the example-based tests for
    these situations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'These examples exhibit code similarity. The `0`, `1`, `2`, and `3` bases repeat
    a number of times. We''ve seen in [Chapter 9](f3b31186-dfef-496e-bc6e-82a55eeb0cba.xhtml),
    *Test-Driven Development for Functional Programming*, that we can remove this
    similarity with data-driven tests by specifying multiple input values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'After I worked to remove these similarities for some time, I started to see
    the properties. It''s quite obvious, in this case, that we can add a test that
    checks the same mathematical property by using random inputs rather than specific
    examples. Indeed, we wrote it in the previous section, and it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: So my advice is—if you reflect for a few minutes on the problem and find the
    mathematical properties to check, perfect! (Write the property-based tests and
    add as many example-based tests to feel confident that you have covered the situations.)
    If you can't see them, no worries; keep adding example-based tests, remove duplication
    between tests by using data-driven tests, and eventually you will reveal the properties.
    Then, add property-based tests and decide what to do with the existing example-based
    tests.
  prefs: []
  type: TYPE_NORMAL
- en: Good properties, bad properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since properties are an abstraction level higher than the examples, it's easy
    to implement them in a confusing or unclear manner. You already need to pay a
    lot of attention to example-based tests; you now need to up your efforts in relation
    to the property-based tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, good properties are like good unit tests. We want, therefore
    to have properties that are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Small
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Named appropriately and clearly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Giving a very clear message when they fail
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fast
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Repeatable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's one caveat with property-based tests though—since we're using random
    values, shouldn't we expect random failures? Well, when a property-based test
    fails, we learn something new about our code, so it's a reason for celebration.
    We should expect, however, to have fewer failures as time passes by and we remove
    our bugs. If your property-based tests fail every day, something is definitely
    wrong—maybe the property is too large, or the implementation has many holes in
    it. If your property-based tests fail from time to time, and they show a possible
    bug in the code—that's great.
  prefs: []
  type: TYPE_NORMAL
- en: One of the difficult things with property-based tests is to keep the generators
    and the property checks free of bugs. This is code too, and any code can have
    bugs. In example-based tests, we deal with this problem by simplifying the unit
    tests to a level where it's virtually impossible to make mistakes. Be aware that
    properties are more complex, and so may require more attention. The old principle
    *keep it simple, stupid* is even more valuable when it comes to property-based
    tests. So, favor smaller properties over larger ones, make your analysis, and
    review your code with colleagues—both the names and the implementation.
  prefs: []
  type: TYPE_NORMAL
- en: A few words regarding implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we've used a custom set of functions for implementing data
    generators in order to keep the code standard C++ 17\. However, these functions
    are optimized for learning the technique, and are not production ready. You could
    already see that they are not optimized for memory footprint or performance. We
    could already make them better with a smart use of iterators, but there's a better
    way.
  prefs: []
  type: TYPE_NORMAL
- en: If you can use the range library or compile your tests using C++ 20, it's quite
    easy to implement infinite data generators (due to lazy evaluation). I also advise
    you to research for property-based tests libraries, or for generator libraries,
    since some of the generators have already been written by other people and it's
    much faster to use them in your code once you understand the concept.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Property-based tests are a welcome addition to the example-based tests we've
    known and used for many years. They show us how we can combine data generation
    with a bit of analysis to both remove duplication from tests and find cases we
    hadn't considered.
  prefs: []
  type: TYPE_NORMAL
- en: Property-based tests are enabled by data generators that are very easy to implement
    using pure functions. Things will become even easier with lazy evaluation coming
    in C++ 20 or with the ranges library.
  prefs: []
  type: TYPE_NORMAL
- en: But the core technique in property-based testing is to identify the properties.
    We've seen two ways to do that—the first by analyzing the examples, and the second
    by writing the example-based tests, removing duplication to turn them into data-driven
    tests, and then replacing the rows of data with properties.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, remember that property-based tests are code, and they need to be very
    clean, easy to change, and easy to understand. Favor small properties whenever
    possible, and make them very understandable by naming them clearly.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at how we can use pure functions to support
    our refactoring effort and at how design patterns can be implemented as functions.
  prefs: []
  type: TYPE_NORMAL
