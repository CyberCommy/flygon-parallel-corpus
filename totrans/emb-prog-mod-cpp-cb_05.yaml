- en: Debugging, Logging, and Profiling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Debugging and profiling is an important part of the development workflow for
    any type of application. In the case of an embedded environment, these tasks require
    special attention from developers. Embedded applications run on a system that
    might be very different from a developer's workstation, and that often has limited
    resources and user interface capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Developers should plan in advance how they are going to debug their application
    during the development phase, and how they are going to determine the root causes
    of, as well as fix, the issues in the production environment.
  prefs: []
  type: TYPE_NORMAL
- en: Often, the solution is to use an emulator for a target device along with an
    interactive debugger that is provided by the embedded system vendor. For more
    complex systems, however, complete and accurate emulation is hardly feasible,
    and remote debugging is the most viable solution.
  prefs: []
  type: TYPE_NORMAL
- en: In many cases, using an interactive debugger is not possible or not practical
    at all. Hardware states can change in a few milliseconds after a program stops
    on a breakpoint, and a developer has insufficient time to analyze it. In such
    cases, developers have to use extensive logging for root cause analysis.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will focus on debugging approaches for the more powerful
    systems based on **SoC** (short for **System On a Chip**) and running Linux OS.
    We will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Running your applications in the **GDB** (short for** GNU Project Debugger) **
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with breakpoints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with core dumps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using gdbserver for debugging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding debug logging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with debug and release builds
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These basic debugging techniques will help significantly while working with
    the recipes in this book as well as in your work on embedded applications of any
    kind.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn how to debug embedded applications in the **ARM**
    (short for** Acorn RISC Machines**) platform emulator. At this point, you should
    already have two systems configured in a virtualized Linux environment running
    on your laptop or desktop:'
  prefs: []
  type: TYPE_NORMAL
- en: Ubuntu Linux in a Docker container as a build system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debian Linux in a **QEMU** (short for **Quick EMUlato**) ARM emulator as a target
    system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To learn the theory of cross-compilation and set up the development environment,
    please refer to the recipes in [Chapter 2](899e14bb-12be-4df1-a42b-60a316ea0af6.xhtml), *Setting
    Up the Environment*.
  prefs: []
  type: TYPE_NORMAL
- en: Running your applications in the GDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to run a sample application in a debugger
    on a target system, as well as try out some basic debugging techniques.
  prefs: []
  type: TYPE_NORMAL
- en: GDBis an open source and widely used interactive debugger. Unlike most of the
    debuggers that come as part of **Integrated Development Environment** (**IDE**)
    products, the GDB is a standalone, command-line debugger. This means that it does
    not depend on any particular IDE. As you can see in the example, you can use a
    plain text editor to work on the code of your application, while still being able
    to debug it interactively, use breakpoints, view the content of variables and
    stack traces, and much more.
  prefs: []
  type: TYPE_NORMAL
- en: The user interface of the GDB is minimalist. You run with it in the same way
    as you work with a Linux console— by typing in commands and analyzing their output.
    This simplicity makes it extremely suitable for embedded projects. It can run
    on a system that does not have a graphical subsystem. It is especially handy if
    the target system can only be accessed over a serial connection or ssh shell.
    Since it does not have a fancy user interface, it can work on systems with limited
    resources.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will use an artificial sample application that crashes with
    an exception. It does not log any useful information and the exception message
    is too vague to determine the root cause of the crash. We will use the GDB to
    determine the root cause of the issue.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are now going to create a simple application that crashes under specific
    conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: In your working directory, `~/test`, create a subdirectory called `loop`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use your favorite text editor to create a `loop.cpp` file in the `loop` subdirectory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s put some code into the `loop.cpp` file. We start with includes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we define three functions that our program will consist of. The first
    one is `runner`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The second function is `delay_ms`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, we add the entry-point function, `main`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file called `CMakeLists.txt` in the `loop` subdirectory with the following
    content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Now, switch to the build system terminal and change the current directory to
    `/mnt/loop` by running the following command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Build the application as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Switch back to your native environment, find the `loop` output file in the
    `loop` subdirectory, and copy it over ssh to the target system. Use the user account.
    Switch to the target system terminal. Log in using the user credentials if needed.
    Now, run the `loop` executable binary using `gdb`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The debugger has been started and shows the command-line prompt (`gdb`). To
    run the application, type the `run` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see that the application terminated abnormally due to the runtime exception.
    The exception message, `Time limit exceeded`, gives us a clue, but does not indicate
    under what specific conditions it happened. Let''s try to establish this. Firstly,
    let''s check the stack trace of the crashing application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This shows seven stack frames from the top-level function, `main`, down to
    the library function, `__GI_abort`, which actually terminates the application.
    As we can see, only frames `7` and `6` belong to our application, since only they
    are defined in `loop.cpp`. Let''s take a close look at `frame 6`, since this is
    the function that throws the exception:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the `list` command to see the nearby code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, the exception is thrown if the value of the delta variable exceeds
    the value of the limit variable. But what are what are these values?. These are
    the values of variable ‘delta’ and ‘limit Run the `info locals` command to figure
    this out:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We cannot see the value of the limit variable here. Use the `info args` command to
    see it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can see that the limit is `10`, and the delta `11`. The crash happens
    when the function is called with the `fn` parameter set to the `delay_ms` function and
    the value of the `value` parameter set to `7`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The application is intentionally created to crash under certain conditions and
    does not provide enough information to be able to nail down to these conditions.
    The application consists of two major functions – `runner` and `delay_ms`.
  prefs: []
  type: TYPE_NORMAL
- en: The `runner` function accepts three parameters—the time limit, the function
    of one parameter, and the function parameter value. It runs the function provided
    as a parameter, passing it the value, and measures the elapsed time. If the time
    exceeds the time limit, it throws an exception.
  prefs: []
  type: TYPE_NORMAL
- en: The `delay_ms` function performs a delay. However, it is implemented incorrectly
    and considers each millisecond as consisting of 1,100 microseconds instead of
    1,000.
  prefs: []
  type: TYPE_NORMAL
- en: The `main` function runs the runner in the `loop` directory, providing fixing
    values of 10 milliseconds as a time limit and `delay_ms` as a function to run,
    but increasing values of the `value` parameter. At some point, the `delay_ms`
    function exceeds the time limit and the app crashes.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we build the application for the ARM platform and transfer it to the
    emulator to run:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/52c9bbb6-e17c-4961-a4da-0e45d3a73859.png)'
  prefs: []
  type: TYPE_IMG
- en: 'It is important to pass the `-g` parameter to the compiler. This parameter
    instructs the compiler to add debug symbols to the resulting binary. We add it
    to the `CMAKE_CXX_FLAGS` parameter in the `CMakeLists.txt` file, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we run the debugger and pass the application executable name as its parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e3b7393c-2d4c-4b8d-a1dd-1f5ea2c2ced8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The application does not run immediately. We start it using the `run` GDB command and
    observe it crashing shortly afterward:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/66aacaec-d965-40bc-bac7-e0de3e630951.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we use the `backtrace` command to review the stack trace:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b394f587-a045-48f3-8c60-299f1cbb9fc7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'An analysis of the stack trace shows that `frame 6` should give us more information
    to reveal the root cause. By way of the next steps, we switch to `frame 6` and
    review the relevant fragment of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ee18e675-c717-4500-8d75-c88fd036ad38.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we analyze the values of local variables and function parameters to determine
    how they are related to the time limit:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a37ff8ac-9ac1-4185-9e4c-d641e7c05ff4.png)'
  prefs: []
  type: TYPE_IMG
- en: We ascertain that the crash occurs when the value passed to `delay_ms` reaches
    `7`, not `11`, as would be expected in the case of correct implementation of the
    delay.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'GDB commands often accept multiple parameters to fine-tune their behavior.
    Learn more about each command using the `help` GDB command. For example, here
    is the output of the `help bt` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/96d294ad-4432-4294-bd38-b8480c1ccec6.png)'
  prefs: []
  type: TYPE_IMG
- en: This displays information on the `bt` command that is used to review and analyze
    stack traces. Similarly, you can get information regarding all the other commands
    supported by the GDB.
  prefs: []
  type: TYPE_NORMAL
- en: Working with breakpoints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn more advanced debugging techniques when working
    with the GDB. We will use the same sample application and use breakpoints to find
    the dependency of the actual delay on the value of the `delay_ms` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Working with breakpoints in the GDB is similar to working with breakpoints in
    debuggers integrated into IDE, the only difference being that instead of using
    the built-in editor to navigate the source code, developers have to learn to use
    line numbers, filenames, or function names explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: This is less convenient than click-and-run debuggers, but the flexibility allows
    developers to create powerful debugging scenarios. In this recipe, we will learn
    how to use breakpoints in the GDB.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we will use the same environment and the same test application
    as in the first recipe. Refer to steps 1 to 9 of the *Running your applications in
    the GDB* recipe to build the application and copy it over to the target system:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We want to debug our `runner` function. Let''s take a look at its content.
    In the gdb shell, run the program as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We want to see how the delta changes on each iteration. Let''s set a breakpoint
    at the line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `break 14` command to set a breakpoint on line 14:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, run the program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Check the value of `delta`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Continue execution of the program by typing `continue`, or just `c`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Check the value of `delta` again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: As we expected, the value of `delta` increases on each iteration, since `delay_ms`
    takes more and more time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Running `print delta` each time is not convenient. Let''s automate it using
    the command named `command`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Run `c` again. Now, the value of `delta` is displayed after each stop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'However, the output is too verbose. Let''s silence the GDB output by typing `command`
    again and writing the following instructions. Now, run the `c` or `continue` command several
    times to see the difference:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We can make the output even more concise by using the `printf` command, as
    shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can see two values, the calculated delay and the expected delay, and
    can see how they diverge over time.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we want to set a breakpoint to debug the `runner` function.
    Since the GDB does not have a built-in editor, we need to know the line number
    to set the breakpoint. Though we can get it directly from a text editor, another
    way is to look at the relevant code snippet in the GDB. We use the `gdb` command
    list with two parameters – function names, to display lines of code between the
    first line of the function runner and the first line of the `delay_ms` function. This
    efficiently shows the content of the function runner:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/482a8b75-c389-4e61-b14d-de3f5cd496b9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'At *step 4*, set the breakpoint at line `14` using the `break 14` command and
    run the program. The execution stops at the breakpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c22a841e-1537-4806-b134-47c6733547bc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We check the value of the `delta` variable using the `print` command and continue
    execution of the program using the `continue` command, and since the `runner`
    function is invoked in the loop, it stops at the same breakpoint again:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3e1b1f31-812a-4201-8a63-1866a3febe7a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we try a more advanced technique. We define a set of GDB commands to
    be executed when the breakpoint is triggered. We start with a simple `print` command.
    Now, every time we continue execution, we can see the value of the `delta` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/55443211-11e7-43c4-a6c2-6a135a946c64.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we disable the auxiliary GDB output using the `silent` command to make
    the output more concise:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7175eb69-bc52-4946-b777-6277cae952a9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, we use the `printf` command to format messages with the two most interesting
    variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7b3fe1fb-b927-4590-9e68-2172dde5d955.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the GDB provides lots of flexibility for developers to make
    debugging comfortable, even lacking the graphical interface.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is important to remember that the optimization options, `-O2` and `-O3`,
    may result in some lines of code being eliminated by the compiler completely.
    If you set breakpoints to such lines, these breakpoints are never triggered. To
    avoid such situations, turn off the compiler optimizations for the debug builds.
  prefs: []
  type: TYPE_NORMAL
- en: Working with core dumps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the first recipe, we learned how to nail down the root cause of a crashing
    application using an interactive command-line debugger. However, there are situations
    when applications crash in the production environment, and it is impossible or
    impractical to reproduce the same issue running the application under the GDB
    on a test system.
  prefs: []
  type: TYPE_NORMAL
- en: Linux provides a mechanism to help with the analysis of crashing applications
    even when they are not run from the GDB directly. When an application is terminated
    abnormally, the operating system saves the image of its memory into a file named
    `core`. In this recipe, we will learn how to configure Linux to generate core
    dumps for crashing applications, and how to use the GDB for their analysis.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to identify the root cause of a crash in an application that was
    not run in the GDB:'
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will use the same environment and the same test application
    as in the first recipe. Refer to *steps 1* to *7* of the first recipe to build
    the application and copy it over to the target system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Firstly, we need to enable the generation of core dumps for crashing applications.
    This feature is turned off by default in most Linux distribution. Run the `ulimit
    -c` command to check the current status:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The value reported by the preceding command is the maximum size of core dumps
    to generate. Zero means no core dumps. To increase the limit, we need to get superuser
    privileges first. Run the `su -` command. When prompted for a `Password`, type
    `root`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the `ulimit -c unlimited` command to allow core dumps of any size:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Now, exit the root shell by pressing *Ctrl *+ *D* or by running the `logout`
    command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Preceding commands changed the core dump limit for the superuser only. To apply
    it to the current user, run the same command again in the user shell:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Make sure that the limit was changed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, run the application as usual:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'It will crash with an exception. Run the `ls` command to check whether a core
    file was created in the current directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, run `gdb`, passing the executable and the `core` files as parameters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'In the GDB shell, run the `bt` command to see the stack trace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: You can see the same stack trace as for the application running from inside
    `gdb`. However, in this case, we see the stack trace of the core dump.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At this point, we can use the same debugging techniques as in the first recipe
    to narrow down the cause of the crash.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Core dump functionality is a standard feature of Linux and other Unix-like operating
    systems. However, the creation of core files in every case is not practical. Since
    core files are snapshots of process memory, they can account for megabytes or
    even gigabytes on a filesystem. In many cases, this is not acceptable.
  prefs: []
  type: TYPE_NORMAL
- en: Developers need to explicitly specify the maximum size of the core files that
    are allowed to be generated by the operating system. This limit, among other limits,
    can be set using the `ulimit` command.
  prefs: []
  type: TYPE_NORMAL
- en: We run `ulimit` twice to remove the limit first for the superuser root, and
    then for the ordinary user/developer. The two-stage process is needed because
    the ordinary user limit cannot exceed the superuser limit.
  prefs: []
  type: TYPE_NORMAL
- en: After we have removed the limit for the core file size, we run our test application
    without the GDB. It crashes, as expected. After the crash, we can see that a new
    file called `core` was created in the current directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we run our application, it crashes. Normally, we would not be able to
    track the root cause of the crash. However, since we enabled core dumps, a file
    named `core` was automatically created for us by the operating system:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a897ffd1-0aa8-4f4d-b1d3-a9e2941e9e77.png)'
  prefs: []
  type: TYPE_IMG
- en: A core file is a binary dump of all process memory, but it is difficult to analyze
    it without additional tools. Thankfully, the GDB provides the necessary support.
  prefs: []
  type: TYPE_NORMAL
- en: 'We run the GDB passing two parameters – the path to the executable, and the
    path to the core file. In this mode, we do not run the application from inside
    the GDB. We already have its state frozen at the moment of the crash in the core
    dump. The GDB uses the executable to bind memory addressed within the `core` file
    to functions and variable names:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8f81cb30-8138-4cd4-8688-2db1c3152d52.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As a result, you can analyze the crashed application in an interactive debugger,
    even when the application was not run from the debugger. When we invoke the `bt`
    command, the GDB displays the stack trace at the moment of the crash:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/56155e9f-ad93-4de6-b78e-4511160d4840.png)'
  prefs: []
  type: TYPE_IMG
- en: This way, we can nail down the root cause of an application crashing even if,
    initially, it was not run in a debugger.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Analyzing core dumps using the GDB is a widely used and effective practice for
    embedded applications. However, to use the full capabilities of the GDB, the application
    should be built with debug symbol support.
  prefs: []
  type: TYPE_NORMAL
- en: In most cases, however, embedded applications are deployed and run without debug
    symbols to reduce the binary size. In this case, an analysis of core dumps becomes
    harder and may require some knowledge of assembly language for the particular
    architecture and of the internals of data structure implementations.
  prefs: []
  type: TYPE_NORMAL
- en: Using gdbserver for debugging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The environment for embedded development normally involves two systems— a build
    system and a target system, or an emulator. Although the command-line interface
    of the GDB makes it a good choice even for low-performance embedded systems, in
    many cases, interactive debugging on the target system is impractical because
    of the high latency of remote communication.
  prefs: []
  type: TYPE_NORMAL
- en: In such situations, developers can use remote debugging support provided by
    the GDB. In this setup, an embedded application is launched on the target system
    using gdbserver. Developers run the GDB on a build system and connect to gdbserver
    over the network.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to start debugging an application using the
    GDB and gdbserver.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Follow the *Connecting to the embedded system* recipe of [Chapter 2](899e14bb-12be-4df1-a42b-60a316ea0af6.xhtml), *Setting
    Up the Environment*,to have the `hello` application available on the target system.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will use the same application we used in the preceding recipes, but now
    we will run the GDB and applications in different environments:'
  prefs: []
  type: TYPE_NORMAL
- en: Switch to the target system window and type *Ctrl* + *D* to log out from the
    existing user session.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Log in as `user`, using the `user` password.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the `hello` application under `gdbserver`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Switch to the build system terminal and change the directory to `/mnt`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Run `gdb`, passing the application binary as a parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Configure a remote connection by typing the following command in the GDB command
    line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, type the `continue` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The program now runs and we can see its output and debug it as if it were run
    locally.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, we log in to our target system as root and install gdbserver, unless
    it is already installed. Once installation is complete, we log in again with user
    credentials and run gdbserver, passing the name of the application to debug, the
    IP address, and the port to listen to for incoming connections as its parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we switch to our build system and run the GDB there. However, instead
    of running the application in the GDB directly, we instruct the GDB to initiate
    a connection to a remote host using the provided IP address and port. After that,
    all commands you type at the GDB prompt will be transferred to gdbserver and executed
    there.
  prefs: []
  type: TYPE_NORMAL
- en: Adding debug logging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Logging and diagnostics are an important aspect of any embedded project. In
    many cases, using an interactive debugger is not possible or not practical. Hardware
    state can change in a few milliseconds after a program stops on a breakpoint,
    and a developer has insufficient time to analyze it. Collecting detailed log data
    and using tools for their analysis and visualization is a better approach for
    high-performance, multithreaded, time-sensitive embedded systems.
  prefs: []
  type: TYPE_NORMAL
- en: Logging itself introduces certain delays. Firstly, it takes time to format the
    log messages and put them into the log stream. Secondly, the log stream should
    be reliably stored in persistent storage, such as a flash card or a disk drive,
    or sent to the remote system.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to use logging instead of interactive debugging
    to find the root causes of issues. We will use a system of different log levels
    to minimize the delays introduced by logging.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will modify our application to output information that is useful for root
    cause analysis:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to your work directory, `~/test`, and make a copy of the `loop` project directory. Name
    the copy `loop2`. Change directory to `loop2`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use your text editor to open the `loop.cpp` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add one more `include`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Modify the `runner` function by adding calls to the `syslog` function, as highlighted
    in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, update the `main` function to initialize and finalize `syslog`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Switch to the build system terminal. Go to the `/mnt/loop2` directory and run
    the program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Copy the resulting `binary` file loop to the target system and run it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The debug output is verbose and gives more context to find the root cause of
    the issue.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we added logging using the standard logging tool, `syslog`.
    Firstly, we initialized our logging by using a call to `openlog`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we added logging to the `runner` function. There are different logging
    levels that facilitate the filtering of log messages, from most severe to least
    severe. We log the `delta` value, which indicates how long the function that the
    runner invokes actually runs for, using the `LOG_DEBUG` level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: This level is used to log detailed information that is helpful for application
    debugging but might prove to be too verbose when running applications in production.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the delta, however, exceeds the limit, we log this situation using the `LOG_ERR` level
    to indicate that this situation should not normally happen and that it is an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Before returning from the application, we close the logging to make sure that
    all the log messages are properly saved:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run the application on the target system, we can see our log messages
    on the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fee9835c-ae1e-48c7-ac4c-7d5061ab539c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Since we use standard Linux logging, we can find the messages in the system
    logs as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2aafea69-e7e5-4925-a431-9efec515aca3.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, logging is not hard to implement, but it is extremely helpful
    in finding the root causes of various issues in your application during debugging
    and normal operation.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a number of logging libraries and frameworks that may be more suitable
    for particular tasks than the standard logger; for example, *Boost.Log*, at [https://theboostcpplibraries.com/boost.log](https://theboostcpplibraries.com/boost.log),
    and *spdlog*, at [https://github.com/gabime/spdlog](https://github.com/gabime/spdlog).
    They provide a more convenient C++ interface compared to the generic C interface
    of `syslog`. When starting work on your project, check existing logging libraries
    and pick the one that best suits your requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Working with debug and release builds
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we learned in the preceding recipe, logging has costs associated with it.
    It introduces delays to format log messages and writes them to persistent storage
    or a remote system.
  prefs: []
  type: TYPE_NORMAL
- en: Using log levels helps to reduce the overhead by skipping the writing of some
    messages to the log file. However, the message is usually being formatted before
    passing to a `log` function. For example, in the case of a system error, a developer
    wants to add an error code reported by the system to the log message. Although
    string formatting is generally less expensive than writing data to a file, it
    might still be an issue for highly-loaded systems or systems with limited resources.
  prefs: []
  type: TYPE_NORMAL
- en: Debug symbols added by a compiler do not add runtime overhead. However, they
    increase the size of the resulting binary. Moreover, performance optimizations
    made by the compiler can make interactive debugging difficult.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to avoid runtime overheads by separating debug
    and release builds and using the C pre-processor macros.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to modify build rules of the application we used in the preceding
    recipes to have two build targets—debug and release:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to your work directory, `~/test`, and make a copy of the `loop2` project
    directory. Name the copy `loop3`. Change directory to `loop3`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use your text editor to open the `CMakeLists.txt` file. Replace the following
    line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding line needs to be replaced with the following lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Use your text editor to open the `loop.cpp` file. Modify the file by adding
    the highlighted lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Switch to the build system terminal. Go to the `/mnt/loop3` directory and run
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Copy the resulting `loop` binary file to the target system and run it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the application does not generate any debug output. Let''s
    now check its size using the `ls -l` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The size of the resulting binary is 24 KB. Now, let''s build the `Debug` build
    and effect a comparison as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Check the size of the executable file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The size of the executable is now 80 KB. It is more than three times bigger
    than the release build. Run it the same way as before:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the output is now different.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We start with the copy of the project we used for the *Adding debug logging*
    recipe and create two distinct build configurations:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Debug**: A configuration with interactive debugging and debug logging support'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Release**: A highly optimized configuration that has all debug support disabled
    at compile time'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To implement it, we utilize the functionality provided by `CMake`. It supports
    different built types out of the box. We only need to define compile options for
    release and debug builds separately.
  prefs: []
  type: TYPE_NORMAL
- en: 'The only build flag we define for the release build is the C++ standard to
    use. We explicitly require the code to conform to the C++11 standard:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: For the debug build, we reuse the same flags as for the release build, referencing
    them as `${CMAKE_CXX_FLAGS_RELEASE}`, and adding two more options. `-g` instructs
    the compiler to add debug symbols to the target executable binary, and `-DDEBUG`
    defines a pre-processor macro, `DEBUG`.
  prefs: []
  type: TYPE_NORMAL
- en: We use the `DEBUG` macro in the code of `loop.cpp` to select between two different
    implementations of the `LOG_DEBUG` macro.
  prefs: []
  type: TYPE_NORMAL
- en: If `DEBUG` is defined, `LOG_DEBUG` is expanded to the call of the `fprintf`
    function, which performs actual logging in the standard error channel. If, however,
    `DEBUG` is not defined, `LOG_DEBUG` is expanded to the empty string. This means
    that in this case, `LOG_DEBUG` does not produce any code, and hence does not add
    any runtime overhead.
  prefs: []
  type: TYPE_NORMAL
- en: We use `LOG_DEBUG` in the body of the runner function to log values of the actual
    delay and the limit. Note that there is no `if` around `LOG_DEBUG` – the decision
    to format and log data or do nothing is done not by our program when it runs,
    but by the code pre-processor when we build the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'To select a build type, we invoke `cmake`, passing the name of the build type
    as a command-line parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '`CMake` only generates a `Make` file to actually build the application we require
    in order to invoke `make`. We can combine these two commands in a single command
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'When we build and run our application for the first time, we select the release
    build. As a result, we do not see any debug output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/55077ea0-cd5e-411c-82f1-286108dc17f0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After that, we rebuild our application using the debug build type and see a
    different result when running it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/719acbab-871a-4922-88e4-07915e394e61.png)'
  prefs: []
  type: TYPE_IMG
- en: With debug and release builds, you can have sufficient information for comfortable
    debugging, but be sure that the production build won't have any unnecessary overhead.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When switching between release and debug builds in a complex project, make sure
    that all the files were rebuilt properly. The easiest way to do this is by removing
    all the previous build files. When using `make`, this can be done by invoking
    the `make clean` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'It can be added as part of the command line along with `cmake` and `make`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Combining all three commands into one line makes this more convenient for developers.
  prefs: []
  type: TYPE_NORMAL
