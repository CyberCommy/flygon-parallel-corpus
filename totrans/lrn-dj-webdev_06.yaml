- en: Chapter 6. Enhancing the User Interface with AJAX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The coming of **AJAX** was an important landmark in the history of Web 2.0\.
    AJAX is a group of technologies that enables developers to build interactive,
    feature-rich Web applications. Most of these technologies were available many
    years before AJAX itself. However, the advent of AJAX represents the transition
    of the Web from static pages that needed to be refreshed whenever data was exchanged
    to dynamic, responsive, and interactive user interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Since our project is a Web 2.0 application, it should be heavily focused on
    user experience. The success of our application depends on getting users to post
    and share content on it. Therefore, the user interface of our application is one
    of our major concerns. This chapter will improve the interface of our application
    by introducing AJAX features, making it more user-friendly and interactive.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn about the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: AJAX and its advantages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using AJAX in Django
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use the open source jQuery framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the searching of tweets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Editing a tweet in place without loading a separate page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Auto completion of hashtags while submitting a tweet
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AJAX and its advantages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'AJAX, which stands for **Asynchronous JavaScript and XML**, consists of the
    following technologies:'
  prefs: []
  type: TYPE_NORMAL
- en: HTML and CSS to structure and style information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JavaScript to access and manipulate information dynamically
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An `XMLHttpRequest` object, which is an object provided by modern browsers to
    exchange data with the server without reloading the current web page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A format to transfer data between the client and server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: XML is used sometimes, but it could be in the HTML, plain text, or JavaScript-based
    format called JSON.
  prefs: []
  type: TYPE_NORMAL
- en: AJAX technologies let you code the client-side exchange data with the server
    behind the scenes, without reloading the entire page each time the user makes
    a request. By using AJAX, Web developers are able to increase the interactivity
    and usability of Web pages.
  prefs: []
  type: TYPE_NORMAL
- en: 'AJAX offers the following advantages when implemented in the right places:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Better user experience**: With AJAX, the user can do a lot without refreshing
    the page, which brings Web applications closer to the regular desktop applications'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Better performance**: By exchanging only the required data with the server,
    AJAX saves the bandwidth and increases the application''s speed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are numerous examples of Web applications that use AJAX. Google Maps and
    Gmail are perhaps two of the most prominent examples. In fact, these two applications
    played an important role in spreading the use of AJAX because of the success that
    they enjoyed. What sets Gmail apart from other webmail services is its user interface,
    which enables users to manage their e-mails interactively without waiting for
    a page to reload after every action. This creates a better user experience and
    makes Gmail feel like a responsive and feature-rich application rather than a
    simple website.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter explains how to use AJAX with Django, so as to make our application
    more responsive and user-friendly. We are going to implement three of the most
    common AJAX features found in web applications today. However, before that, we
    will learn about the benefits of using an AJAX framework, as opposed to working
    with raw JavaScript functions.
  prefs: []
  type: TYPE_NORMAL
- en: Using an AJAX framework in Django
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have already used Bootstrap in our project, we need not configure it separately
    for AJAX and jQuery.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many advantages of using an AJAX framework:'
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript implementations vary from browser to browser. Some browsers provide
    more complete and feature-rich implementations, whereas others contain implementations
    that are incomplete or don't adhere to standards.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Without an AJAX framework, developers must keep track of browser support for
    the JavaScript features that they are using and must work around the limitations
    that are present in some browsers for the implementation of JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, when using an AJAX framework, the framework takes care of
    this for us; it abstracts access to the JavaScript implementation and deals with
    the differences and quirks of JavaScript across browsers. This way, we can concentrate
    on developing features instead of worrying about browser differences and limitations.
  prefs: []
  type: TYPE_NORMAL
- en: The standard set of JavaScript functions and classes is a bit lacking for full-fledged
    web application development. Various common tasks require many lines of code even
    though they could be wrapped in simple functions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Therefore, even if you decide not to use an AJAX framework, you will find yourself
    writing a library of functions that encapsulates JavaScript facilities and makes
    them more usable. However, why reinvent the wheel when there are many excellent
    open source libraries already available?
  prefs: []
  type: TYPE_NORMAL
- en: AJAX frameworks available in the market today range from comprehensive solutions
    that provide server-side and client-side components to light-weight client-side
    libraries that simplify working with JavaScript. Given that we are already using
    Django on the server side, we only want a client-side framework. In addition to
    this, the framework should be easy to integrate with Django without requiring
    any additional dependencies. Finally, it is preferable to pick a light and fast
    framework. There are many excellent frameworks that fulfill our requirements,
    such as **Prototype**, the **Yahoo! UI Library**, and **jQuery**.
  prefs: []
  type: TYPE_NORMAL
- en: However, for our application, I'm going to pick jQuery because it's the lightest
    of the three. It also enjoys a very active development community and a wide range
    of plugins. If you already have experience with another framework, you can continue
    using it during this chapter. It is true that you will have to adapt the JavaScript
    code in this chapter to your framework, but Django code on the server side will
    remain the same no matter which framework you choose.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You need to import Bootstrap and jQuery as well. Thus, no specific installation
    or import is needed to use the AJAX feature in our Django project.
  prefs: []
  type: TYPE_NORMAL
- en: Using the open source jQuery framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we start implementing AJAX enhancements in our project, let's go through
    a quick introduction to the jQuery framework.
  prefs: []
  type: TYPE_NORMAL
- en: The jQuery JavaScript framework
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: jQuery is a library of JavaScript functions that facilitates interaction with
    HTML documents and manipulates them. The library is designed to reduce the time
    and effort spent on writing code and achieving cross-browser compatibility, while
    at the same time it takes full advantage of what JavaScript offers to build interactive
    and responsive web applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'The general workflow of using jQuery consists of the following two steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Selecting an HTML element or a group of elements to work on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Applying a jQuery method to the selected group.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Element selectors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'jQuery provides a simple approach to select elements: it works by passing a
    CSS selector string to a function called `$()`. Here are some examples that illustrate
    the usage of this function:'
  prefs: []
  type: TYPE_NORMAL
- en: If you want to select all anchor (`<a>`) elements on a page, you can use the
    `$("a")` function call
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you want to select anchor elements that have the `.title` CSS class, use
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: To select an element whose ID is `#nav`, you can use `$("#nav")`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To select all the list item (`<li>`) elements inside `#nav`, use `$("#nav li")`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `$()` function constructs and returns a jQuery object. After that, you can
    call methods on this object to interact with the selected HTML elements.
  prefs: []
  type: TYPE_NORMAL
- en: jQuery methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: jQuery offers a variety of methods to manipulate HTML documents. You can hide
    or show elements, attach event handlers to events, modify CSS properties, manipulate
    the page structure, and, most importantly, perform AJAX requests.
  prefs: []
  type: TYPE_NORMAL
- en: To debug, we are choosing the Chrome browser as the browser of our choice. Chrome
    is one of the most advanced JavaScript debugger in the form of its Chrome developer's
    tools. To launch it, press *Ctrl*+*Shift*+*J* on the keyboard.
  prefs: []
  type: TYPE_NORMAL
- en: To experiment with the methods outlined in this section, launch the development
    server and navigate to the user profile page (`http://127.0.0.1:8000/user/ratan/`).
    Open the Chrome developer tool (by pressing *Ctrl*+*Shift*+*J* on your keyboard)
    console by pressing *F12*, and try selecting the elements and manipulating them.
  prefs: []
  type: TYPE_NORMAL
- en: Hiding and showing elements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s start with something simple. To hide an element on the page, call the
    `hide()` method on it. To show it again, call the `show()` method. For example,
    try this on the navigation menu called `navbar` in Bootstrap of your application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You can also animate the element while hiding and showing it. Try the `fadeOut()`,
    `fadeIn()`, `slideUp()`, or `slideDown()` methods to see two of these animated
    effects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, these methods (like all other jQuery methods) also work if you select
    more than one element at once. For example, if you open a user profile and enter
    the following method call into the Chrome developers tools console, all of the
    tweets will disappear:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Accessing CSS properties and HTML attributes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next, we will learn how to change the CSS properties of elements. jQuery offers
    a method called `css()` to perform CSS operations. If you call this method with
    a CSS property name passed as a string, it returns the value of this property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If you pass a second argument to this method, it sets the specified CSS property
    of the selected element to the additional argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In fact, you can manipulate any HTML attribute and not just CSS properties.
    To do so, use the `attr()` method, which works in a similar way as the `css()`
    method. Calling it with an attribute name returns the attribute value, whereas
    calling it with an attribute name or value pair sets the attribute to the passed
    value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This will change the size of all the input elements on the page at once to `48`.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to this, there are shortcut methods to get and set commonly used
    attributes, such as `val()`, which returns the value of an input field when called
    without arguments and sets this value to an argument if you pass one. There is
    also the `html()` method that controls the HTML code inside an element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, there are two methods that can be used to attach or detach a CSS class
    to an element: they are the `addClass()` and `removeClass()` methods. A third
    method is provided to toggle a CSS class and it is called as the `toggleClass()`
    method. All of these class methods take the name of the class to be changed as
    a parameter.'
  prefs: []
  type: TYPE_NORMAL
- en: Manipulating HTML documents
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that you are comfortable with manipulating HTML elements, let's see how
    to add new elements or remove the existing elements. To insert HTML code before
    an element, use the `before()` method, and to insert code after an element, use
    the `after()` method. Note how jQuery methods are well named and very easy to
    remember!
  prefs: []
  type: TYPE_NORMAL
- en: Let's test these methods by inserting parentheses around tag lists on the user
    page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open your user page and enter the following in the Chrome developer tools console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: You can pass any string you want to, the `before()` or `after()` methods. The
    string may contain plain text, one HTML element, or more. These methods offer
    a very flexible way to dynamically add HTML elements to an HTML document.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to remove an element, use the `remove()` method. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Not only does this method hide the element, it also removes it completely from
    the document tree. If you try to select the element again after using the `remove()`
    method, you will get an empty set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Of course, this only removes the elements from the current instance of the page.
    If you reload the page, the elements will appear again.
  prefs: []
  type: TYPE_NORMAL
- en: Traversing the document tree
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although CSS selectors offer a very powerful way to select elements, there are
    times when you want to traverse the document tree starting from a particular element.
  prefs: []
  type: TYPE_NORMAL
- en: For this, jQuery provides several methods. The `parent()` method returns the
    parent of the currently selected element. The `children()` method returns all
    the immediate children of the selected element. Finally, the `find()` method returns
    all the descendants of the currently selected element. All of these methods take
    an optional CSS selector string to limit the result to elements that match the
    selector. For example, `$(".column").find("span")` returns all the `<span>` descendants
    of a class column.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to access an individual element of a group, use the `get()` method,
    which takes the index of the element as a parameter. The `$("span").get(0)` method,
    for example, returns the first `<span>` element out of the selected group.
  prefs: []
  type: TYPE_NORMAL
- en: Handling events
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Next we will learn about event handlers. An event handler is a JavaScript function
    that is invoked when a particular event happens, for example, when a button is
    clicked or a form is submitted. jQuery provides a large set of methods to attach
    handlers to events; events of particular interest in our application are mouse
    clicks and form submissions. To handle the event of clicking on an element, we
    select this element and call the `click()` method on it. This method takes an
    event handler function as a parameter. Let's try this in our Chrome developer
    console.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the user profile page of the application and insert a button after the
    tweet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that we had to escape the quotations in the strings passed to the `after()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you try to click on this button, nothing will happen, so let''s attach an
    event handler to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Now, when you click on the button, a message box will appear. How did this work?
  prefs: []
  type: TYPE_NORMAL
- en: 'The argument that we passed to the `click()` method may look a bit complicated,
    so let''s examine it again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This appears to be a function declaration, but without a function name. Indeed,
    this construct creates what is called an anonymous function in JavaScript terminology
    and it is used when you need to create a function on the fly and pass it as an
    argument to another function. We could have avoided using anonymous functions
    and declared the event handler as a regular function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code achieves the same effect, but the first one is more concise
    and compact. I highly recommend you to get used to anonymous functions in JavaScript
    (if you are not already), as I'm sure you will appreciate this construct and find
    it more readable after using it for a while.
  prefs: []
  type: TYPE_NORMAL
- en: Handling form submissions is very similar to handling mouse clicks. First you
    select the form, then you call the `submit()` method on it, and then you pass
    the handler as an argument. We will use this method many times while adding AJAX
    features to our project in later sections.
  prefs: []
  type: TYPE_NORMAL
- en: Sending AJAX requests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we finish this section, let's talk about AJAX requests. jQuery provides
    many ways to send AJAX requests to the server. There is, for example, the `load()`
    method that takes a URL and loads the page at this URL into the selected element.
    There are also methods to send the GET or POST requests and to receive the results.
    We will examine these methods in more depth while implementing AJAX features in
    our project.
  prefs: []
  type: TYPE_NORMAL
- en: What next?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This wraps up our quick introduction to jQuery. The information provided in
    this section will be enough to continue with this chapter, and once you finish
    this chapter, you will be able to implement many interesting AJAX features on
    your own. However, please keep in mind that this jQuery introduction is only the
    tip of the iceberg. If you want a comprehensive treatment of the jQuery framework,
    I highly recommend you read *Learning jQuery* from Packt Publishing, as it covers
    jQuery in much more detail. You can find out more about this book at [http://www.packtpub.com/jQuery](http://www.packtpub.com/jQuery).
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the searching of tweets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will start introducing AJAX in our application by implementing live searches.
    The idea behind this feature is simple: when the user types a few keywords into
    a text field and clicks on search, a script works behind the scenes to fetch the
    search results and presents them on the same page. The search page does not reload,
    thus saving bandwidth, and provides a better and more responsive user experience.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we start implementing this, we need to keep in mind an important rule
    while working with AJAX: write your application so that it works without AJAX
    and then introduce AJAX to it. If you do so, you ensure that everyone will be
    able to use your application, including users who don''t have JavaScript enabled
    and those who use browsers without AJAX support.'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a searching
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So, before we work with AJAX, let''s write a simple view that searches bookmarks
    by title. First of all, we need to create a search form, so open the `tweets/forms.py`
    file and add the following class to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, it''s a pretty straightforward form class with only one text
    field. This field will be used by the user to enter search keywords. Next, let''s
    create a view to conduct the search. Open the `tweets/views.py` file and enter
    the following code into it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Apart from a couple of method calls, the view should be very easy to understand.
    If you look at the `get` request, it is pretty simple, as it prepares the search
    form and then renders it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `post()` method is where all the magic happens. When we are rendering the
    search result, it is just a layout rendering with the search form, that is, if
    you take a look at the new file we created called `search.html`, you can see the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'If you look carefully, you will see the inclusion of a new section named `{%
    block js %}`. The concept used here is the same as of the `{% block content %}`
    block, that is, what is declared here will be rendered in the `base.html` file.
    Taking it further, and looking at the modified `base.html` file, we can see the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code clearly shows the two new content blocks, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: They are used to include the respective file types and to render the file types
    with the base, so that maintaining the project becomes much simpler using the
    simple rule of declaring just one CSS and JavaScript file per page. We will implement
    this later in the book with the concepts that call **assets pipeline**.
  prefs: []
  type: TYPE_NORMAL
- en: Now, coming back to our AJAX search feature, you will see that this `search.html`
    file is similar to the `tweet.html` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the search feature, we will create a new URL, which we need to append to
    the following `urls.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `search.html` file, we defined the `search.js` method; let''s create
    this JavaScript file, which actually makes the AJAX request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This JavaScript code gets triggered when the form is submitted, it makes an
    AJAX post request to the `/search` user with the serialized form data, and it
    gets the response. Then, with the response it gets, it appends the data to the
    element that has the class tweets.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we open the user search in the browser, it will look like the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing a searching](img/image00303.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now, wait! What happens when this form is submitted?
  prefs: []
  type: TYPE_NORMAL
- en: 'The AJAX request goes to the `post()` method of the search class, which is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We are checking the form validation after we extract from the `request.POST`
    method; if the form is valid, the query is extracted from the form object.
  prefs: []
  type: TYPE_NORMAL
- en: Then, the `tweets = Tweet.objects.filter(text__icontains===query)` method searches
    for the substring match for the given query term.
  prefs: []
  type: TYPE_NORMAL
- en: 'Searches are conducted using a method called `filter` in the `Tweets.objects`
    module. You can think of it as the equivalent of the `SELECT` statements in Django
    models. It receives the search criteria in its arguments and returns the search
    results. The name of each argument must adhere to the following naming convention:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the `field` and `operator` variables are separated by two underscores:
    the field, which is the name of the field that we want to search by, and operator,
    which is the lookup method that we want to use. Here is a list of the commonly
    used operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '`exact`: This is the value of the argument that is an exact match of the field'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`contains`: This field contains the value of the argument'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`startswith`: This field starts with the value of the argument'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lt`: This field is less than the value of the argument'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gt`: This field is greater than the value of the argument'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Also, there are case-insensitive versions of the first three operators: `iexact`,
    `icontains`, and `istartswith` that can be included in the list as well.'
  prefs: []
  type: TYPE_NORMAL
- en: 'One thing that we are doing is totally different now, which is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Our goal was to load the search results without reloading or refreshing the
    search page. If so, how our previous render method will help us? It can't. We
    need some methods that can help us send the date to the browser without reloading
    it.
  prefs: []
  type: TYPE_NORMAL
- en: We widely use the concepts in web development called **partials**. They are
    generally small snippets of HTML code generated on the server side, are rendered
    as JSON, and then they get appended to the existing DOM with the help of JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement this method, we will first create a folder called partials in
    the existing template folder, a `_tweet_search.html` file with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The code will render the entire tweet object within a well box or, if no tweet
    object is found, it will render `No tweet Found` inside the well box.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding concept is to render a partial as a string in the view, and if
    we need to pass any parameters for the render, we need to pass them in the first
    place with the call to generate the string from partials. To pass the parameters
    for partials, we need to create a context object and then pass our parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we will create the context with the `query` (which we will use later)
    and `tweets` parameters and use the `render_to_string()` function. Then, we can
    use JSON to dump the string to the `HttpResponse()` function with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The list of imports are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s it! We completed a basic AJAX-based search for our tweets. Searching
    for `django` listed the two tweets we created, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing a searching](img/image00304.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Go ahead and play with the search engine, and I'm sure you will fall more in
    love with Django.
  prefs: []
  type: TYPE_NORMAL
- en: We now have a functional (albeit very basic) search page. The search functionality
    itself will be improved during later chapters, but what matters to us now is introducing
    AJAX to the search form, so that results are fetched behind the scenes and are
    presented to the user without reloading the page. Thanks to our modular code,
    this task will turn out to be much simpler than it may seem.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the live searching of tweets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we conducted a simple search in the previous section, we will now implement
    the live search, which is technically the same, but the only difference is that
    the search form will be submitted with every key stroke and the results will be
    loaded in real, time.
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement live searches, we need to do the following two things:'
  prefs: []
  type: TYPE_NORMAL
- en: We need to intercept and handle the event of submitting the search form. This
    can be done using the `submit()` method of jQuery.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need to use AJAX to load the search results in the background and insert
    them in the page.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: jQuery offers a method called `load()` that retrieves a page from the server
    and inserts its contents into the selected element. In its simplest form, the
    function takes the URL of the remote page to be loaded as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: We will implement the live search on hashtags, that is, we will create a new
    page that is the same as the search page that we just created, but this will be
    for hashtags and we will use a live hashtag suggestion (autocomplete for hashtag).
    Before we begin, we need the Twitter `typeahead` JavaScript library for the same.
  prefs: []
  type: TYPE_NORMAL
- en: Download the latest version of this library from [http://twitter.github.io/typeahead.js/](http://twitter.github.io/typeahead.js/).
  prefs: []
  type: TYPE_NORMAL
- en: For this chapter, we downloaded the version 10.05 of the library. Download it
    and save it to your current JavaScript folder.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, let's modify our search view a little, so that it only returns
    the search results without the rest of the search page when it receives an additional
    GET variable called AJAX. We do so to enable the JavaScript code on the client
    side to easily retrieve search results without the rest of the search page HTML
    format. This can be done by simply using the `bookmark_list.html` template instead
    of the `search.html` template when requested.
  prefs: []
  type: TYPE_NORMAL
- en: 'GET contains the key AJAX parameter. Open the `bookmarks/views.py` file and
    modify the `search_page` parameter (toward the end), so that it becomes as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create a file called `search.js` in the `site_media` directory and link
    it to the `templates/search.html` file like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now for the fun part! Let''s create a function that loads the search results
    and inserts them into the corresponding `div` tag. Write the following code in
    the `site_media/search.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s go through this function line by line:'
  prefs: []
  type: TYPE_NORMAL
- en: The function first gets the query string from the text field using the `val()`
    method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We use the `load()` method to get the search results from the `search_page`
    view and to insert the search results into the `#search-results` div. The request
    URL is constructed by first calling the `encodeURIComponent` parameter on query,
    which works exactly like the `urlencode` filter we used in the Django templates.
    Calling this function is important to ensure that the constructed URL remains
    valid even if the user enters special characters into the text field, such as
    `&`. After the escape query, we concatenate it with the `/search/?AJAX&query=`
    parameter. This URL invokes the `search_page` view and passes the GET variable's
    AJAX parameter and query to it. The view returns the search results and the `load()`
    method in turn loads the results into the `#search-results` div.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We return `False` from the function to tell the browser not to submit the form
    after calling our handler. If we don't return `False` in the function, the browser
    will continue to submit the form as usual and we don't want that.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'One little detail remains: where and when should you attach the `search_submit`
    parameter to the submit event of the search form? A rule of thumb when writing
    JavaScript is that we cannot manipulate elements in the document tree before the
    document finishes loading. Therefore, our function must be invoked as soon as
    the search page is loaded. Fortunately for us, jQuery provides a method to execute
    a function when the HTML document is loaded. Let''s utilize it by appending the
    following code to the `site_media/search.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The `$(document)` function selects the document element of the current page.
    Note that there are no quotations around the `document` variable; it's a variable
    provided by the browser, not a string.
  prefs: []
  type: TYPE_NORMAL
- en: The `ready()` method takes a function and executes it as soon as the selected
    element finishes loading. So, in effect, we are telling jQuery to execute the
    passed function as soon as the HTML document is loaded. We pass an anonymous function
    to the `ready()` method, and this function simply binds the `search_submit` parameter
    to the submit event of the `#search-form` form.
  prefs: []
  type: TYPE_NORMAL
- en: That's it. We've implemented live searches with less than fifteen lines of code.
    To test the new functionality, navigate to `http://127.0.0.1:8000/search/`, submit
    queries, and note how the results are displayed without reloading the page.
  prefs: []
  type: TYPE_NORMAL
- en: The information covered in this section can be applied to any form that needs
    to be processed in the background without reloading the page. You can, for example,
    create a comment form with a preview button that loads the preview in the same
    page without reloading. In the next section, we will enhance the user page to
    let users edit their bookmarks in place without navigating away from the user
    page.
  prefs: []
  type: TYPE_NORMAL
- en: Editing a tweet in place without loading a separate page
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Editing posted content is a very common task on websites. It's usually implemented
    by offering an **edit** link next to the content. When clicked on, this link takes
    the user to a form located at another page, where the content can be edited. When
    the user submits the form, they are redirected back to the content page.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine, on the other hand, that you could edit content without navigating away
    from the content page. When you click on the **edit** button, the content is replaced
    with a form. When you submit the form, it disappears and the updated content appears
    in its place. Everything happens on the same page; editing the form's rendering
    and submissions are done using JavaScript and AJAX. Wouldn't such a workflow be
    more intuitive and responsive?
  prefs: []
  type: TYPE_NORMAL
- en: The preceding technique described is called **in-place editing**. It now finds
    its way in Web applications and becomes more common. We will implement this feature
    in our application by letting the user edit their bookmarks in place on the user
    page.
  prefs: []
  type: TYPE_NORMAL
- en: Since our application doesn't support the editing of bookmarks yet, we will
    implement this first and then modify the editing procedure to work in place.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing bookmark editing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We already have most of the parts that are needed to implement bookmark editing.
    If you recall from the previous chapter, in the `bookmarks/views.py` file, we
    implemented the `bookmark_save_page` view in such a way that if the user tries
    to save the same URL more than once, the same bookmark is updated rather than
    being duplicated. This was easy to do thanks to the `get_or_create()` method provided
    by data models. This little detail greatly simplifies the implementation of bookmark
    editing. Here is what we need to do:'
  prefs: []
  type: TYPE_NORMAL
- en: We pass the URL of the bookmark that we want to edit as a GET variable named
    URL to the `bookmark_save_page` view.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We modify the `bookmark_save_page` view, so that it populates the fields of
    the bookmark form if it receives the GET variable. The form is populated with
    the data of the bookmark that corresponds to the passed URL.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the populated form is submitted, the bookmark will be updated, as we explained
    earlier, because it will seem to be that the user submitted the same URL another
    time.
  prefs: []
  type: TYPE_NORMAL
- en: Before we implement the preceding described technique, let's reduce the size
    of the `bookmark_save_page` view by moving the part that saves a bookmark to a
    separate function. We will call this function `_bookmark_save`. The underscore
    at the beginning of the name tells Python not to import this function when the
    views module is imported. The function expects a request and a valid form object
    as parameters; it saves a bookmark out of the form data and returns this bookmark.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `bookmarks/views.py` file and create the following function; you can
    cut and paste the code from the `bookmark_save_page` view if you like, as we will
    not make any changes to it except for the `return` statement at the end:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The current logic in the `bookmark_save_page` view works like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Pseudo Code]'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'To implement bookmark editing, we need to slightly modify the logic, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Pseudo Code]'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s translate the preceding pseudo code into Python. Modify the `bookmark_save_page`
    view in the `bookmarks/views.py` file, so that it looks like the following code
    (the new code is highlighted):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This new section of the code first checks whether a GET variable called URL
    exists. If this is the case, it loads the corresponding `Link` and `Bookmark`
    objects of this URL and binds all the data to a bookmark saving form. You may
    wonder why we load the `Link` and `Bookmark` objects in a try-except construct
    that silently ignores exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: Indeed, it's perfectly valid to raise an HTTP 404 exception if no bookmark was
    found for the requested URL. However, our code chooses to only populate the URL
    field in this situation, leaving the title and tags fields empty.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s add **edit** links next to each bookmark in the user page. Open
    the `templates/bookmark_list.html` file and insert the highlighted code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Note how we constructed edit links by appending the bookmark's URL to `/save/?url=
    {{ bookmark.link.url|urlencode }}`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, since we only want to show edit links on the user''s page, the template
    renders these links only when the `show_edit` flag is set to `True`. Otherwise,
    it wouldn''t make sense to let the user edit other people''s links. Now open the
    `bookmarks/views.py` file and add the `show_edit` flag to the template variables
    in the `user_page` flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The `username == request.user.username` expression evaluates to `True` only
    when users view their own page, and this is precisely what we want.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, I suggest you reduce the font size of the edit links a little. Open
    the `site_media/style.css` file and append the following to its end:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: And we are done! Feel free to navigate to your user page and experiment with
    editing your bookmarks before we continue.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing in-place editing of bookmarks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have bookmark editing implemented, let''s move to the exciting
    part: adding in-place editing with AJAX!'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our approach to this task will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We will intercept the event of clicking on an edit link and use AJAX to load
    a bookmark editing form from the server. Then we will replace the bookmark on
    the page with the editing form.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the user submits the edit form, we will intercept the submission event
    and use AJAX to send the updated bookmark to the server.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The server saves the bookmark and returns the HTML representation of the new
    bookmark. We will then replace the edit form on the page with the markup returned
    by the server.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will implement the preceding procedure using an approach very similar to
    live searching. First, we will modify the `bookmark_save_page` view, so that it
    responds to AJAX requests when a GET variable called AJAX exits. Next, we will
    write JavaScript code to retrieve an edit form from the view, which posts bookmark
    data back to the server when the user submits this form.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we want to return the markup of an edit form to the AJAX script from
    the `bookmark_save_page` view, let''s restructure our templates a little. Create
    a file called `bookmark_save_form.html` in templates and move the bookmark saving
    form from the `bookmark_save.html` file to this new file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Note that we also changed the action attribute of the form to `/save/` and gave
    it an ID. This is necessary for the form to work on the user page as well as on
    the bookmark submission page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, include this new template in the `bookmark_save.html` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '*Ok*, now we have the form in a separate template. Let''s update the `bookmark_save_page`
    view to handle both the normal and AJAX requests. Open the `bookmarks/views.py`
    file and update the view, so that it looks like the following (modified with the
    new lines that are highlighted):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s examine each highlighted section separately:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'At the beginning of the method, we will check whether a GET variable named
    AJAX exists. We will store the result in a variable called AJAX. Later in the
    method, we can check whether we are handling an AJAX request or not, using this
    variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'If we receive a POST request, we check whether the submitted form is valid
    or not. If it is valid, we save the bookmark. Next, we check whether this is an
    AJAX request. If it is, we render the saved bookmark using the `bookmark_list.html`
    template and return it to the requesting script. Otherwise, it is a normal form
    submission, so we redirect the user to their user page. On the other hand, if
    the form is not valid, we only act as if it''s an AJAX request by returning the
    string `''failure''`, which we will respond to by displaying an error dialog in
    JavaScript. We don''t need to do anything if it''s a normal request because the
    page will be reloaded and the form will display any errors in the input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: This is checked at the end of the method. The execution reaches this point if
    there is no POST data, which means that we should render a form and return it.
    We use the `bookmark_save_form.html` template if it's an AJAX request and the
    `bookmark_save` method, otherwise save it as an HTML file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our view is now ready to serve AJAX requests as well as normal page requests.
    Let''s write the JavaScript code that will take advantage of the updated view.
    Create a new file called `bookmark_edit.js` in the `site_media` profile. However,
    before we add any code to it, let''s link the `bookmark_edit.js` file to the `user_page.html`
    template. Open the `user_page.html` file and modify it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'We have to write two functions in the `bookmark_edit.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '`bookmark_edit`: This function handles the clicks on edit links. It loads an
    edit form from the server and replaces the bookmark with this form.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bookmark_save`: This function handles the submissions of edit forms. It sends
    form data to the server and replaces the form with the bookmark HTML returned
    by the server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s start with the first function. Open the `site_media/bookmark_edit.js`
    file and write the following code in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Because this function handles click events on an edit link, the `this` variable
    refers to the edit link itself. Wrapping it in the jQuery `$()` function and calling
    the `parent()` function returns the parent of the edit link, which is the `<li>`
    element of the bookmark (try it in the Firebug console to see the same for yourself).
  prefs: []
  type: TYPE_NORMAL
- en: After retrieving a reference to the bookmark's `<li>` element, we obtain a reference
    to the bookmark's title and extract the bookmark's URL from it using the `attr()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we use the `load()` method to put an editing form in place of the bookmark''s
    HTML file. This time, we are calling the `load()` method with two extra arguments
    in addition to the URL. The `load()` function takes two optional parameters, which
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: It takes an object of key or value pairs if we are sending a POST request. Since
    we get the edit form from the server-side view using a GET request, we pass null
    for this parameter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It takes a function that is called when jQuery finishes loading the URL into
    the selected element. The function we are passing attaches the `bookmark_save()`
    method (which we are going to write next) to the form that we've just retrieved.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally, the function returns `False` to tell the browser not to follow the
    edit link. Now we need to attach the `bookmark_edit()` function to the event of
    clicking an edit link using `$(document).ready()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'If you try to edit a bookmark in the user page after writing this function,
    an edit form should appear, but you should also get a JavaScript error message
    in the Firebug console because the `bookmark_save()`function is not defined, so
    let''s write it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `this` variable refers to the edit form because we handle the event
    of submitting a form. The function starts by retrieving a reference to the form's
    parent, which is again the bookmark's `<li>` element. Next, the function retrieves
    the updated data from the form using the ID of each form field and the `val()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Then it uses a method called `$.post()` to send data back to the server. Finally,
    it returns `False` to prevent the browser from submitting the form.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you may have guessed, the `$.post()` function is a jQuery method that sends
    POST requests to the server. It takes three parameters, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The URL of the target of the POST request.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An object of key/value pairs that represents POST data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A function that is invoked when the request is done. The server response is
    passed to this function as a string parameter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's worth mentioning that jQuery provides a method called `$.get()` to send
    a GET request to the server. It takes the same types of parameters as the `$.post()`
    function. We use the `$.post()` method to send the updated bookmark data to the
    `bookmark_save_page` view. As discussed a few paragraphs ago, the view returns
    the update bookmark HTML if it succeeds in saving it. Otherwise, it returns the
    `failure` string.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, we check whether the result returned from the server is `failure`
    or not. If the request succeeds, we insert the new bookmark before the old one
    using the `before()` method and remove the old bookmark from the HTML document
    using the `remove()` method. If, on the other hand, the request fails, we display
    an alert box displaying the failure.
  prefs: []
  type: TYPE_NORMAL
- en: Several little things remain before we finish this section. Why do we insert
    the `$("li",result).get(0)` method instead of the result itself? If you check
    the `bookmark_save_page` view, you will see that it uses the `bookmark_list.html`
    template to construct the bookmark's HTML. However, the `bookmark_list.html` template
    returns the bookmark `<li>` element wrapped in an `<ul>` tag. Basically, the `$("li",
    result).get(0)` method tells jQuery to extract the first `<li>` element in the
    result and this is the element that we want. As you see from the preceding snippet,
    you can use the jQuery `$()` function to select the elements from an HTML string
    by passing this string as a second argument to the function.
  prefs: []
  type: TYPE_NORMAL
- en: The `bookmark_submit` template is attached to its event from within the `bookmark_edit`
    template, so we don't need to do anything about it in the `$(document).ready()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, after loading the updated bookmark into the page, we call the `$("ul.bookmarks.edit").click(bookmark_edit)`
    method again to attach the `bookmark_edit` template to the newly loaded edit link.
    If you don't do so and try to edit a bookmark twice, the second click on the edit
    link will take you to a separate form page.
  prefs: []
  type: TYPE_NORMAL
- en: When you finish writing the JavaScript code, open your browser and go to your
    user page to experiment with the new feature. Edit the bookmarks, save them, and
    note how the changes are immediately reflected on the page without any reloading.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have completed this section, you should have a good understanding
    of how in-place editing is implemented. There are many other scenarios where this
    feature can be useful, for example, it can be used to edit an article or a comment
    on the same page without navigating away to a form located on a different URL.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will implement a third common AJAX feature that helps
    the user enter tags while submitting a bookmark.
  prefs: []
  type: TYPE_NORMAL
- en: Autocompletion of hashtags while submitting a tweet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last AJAX enhancement that we are going to implement in this chapter is
    autocompletion of tags. The concept of autocompletion found its way into web applications
    when Google released their Suggest searching interface. Suggest works by displaying
    the most popular search queries below the search input field based on what the
    user has typed so far. It's also similar to how code editors in integrated development
    environments offer code completion suggestions based on what you type. This feature
    saves time by letting the user type a few characters of the word they want and
    then lets them select it from a list without having to type it in completely.
  prefs: []
  type: TYPE_NORMAL
- en: We will implement this feature by offering suggestions when the user enters
    tags while submitting a bookmark, but instead of writing this feature from scratch,
    we are going to use a jQuery plugin to implement it. jQuery enjoys a large and
    continually growing list of plugins that provides a variety of features. Installing
    a plugin is no different from installing jQuery itself. You download one (or more)
    files and link them to your template and then you write a few lines of JavaScript
    code to activate the plugin.
  prefs: []
  type: TYPE_NORMAL
- en: You can browse the list of the available jQuery plugins by navigating to [http://docs.jquery.com/Plugins](http://docs.jquery.com/Plugins).
    Search for the autocomplete plugin in the list and download it, or you can directly
    grab it from [http://bassistance.de/jquery-plugins/jquery-plugin-autocomplete/](http://bassistance.de/jquery-plugins/jquery-plugin-autocomplete/).
  prefs: []
  type: TYPE_NORMAL
- en: 'You will get a zip archive with many files in it. Extract the following files
    (which can be found in the `jquery/autocomplete/scroll` directory) to the `site_media`
    directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '**jquery.autocomplete.css**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**dimensions.js**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**jquery.bgiframe.min.js**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**jquery.autocomplete.js**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Since we want to offer the autocomplete feature on the bookmark submission
    page, create an empty file called `tag_autocomplete.js` in the `site_media` folder.
    Then open the `templates/bookmark_save.html` file and link all of the preceding
    files to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'We now finished installing the plugin. If you read its documentation, you will
    find that this plugin is activated by calling a method named `autocomplete()`
    on a selected input element. The `autocomplete()` function takes the following
    parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**A server-side URL**: For this, the plugin sends a GET request to this URL
    with what has been typed so far and expects the server to return a set of suggestions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**An object that can be used to specify various options**: Options that are
    of interest to us are multiple. This option has a Boolean variable that tells
    the plugin that the input field is used to enter multiple values (remember that
    we use the same text field to enter all the tags) and multiple separators that
    are used to tell the plugin which string separates multiple entries. In our case,
    it''s a single space character.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So before activating the plugin, we need to write a view that receives user
    input and returns a set of suggestions. Open the `bookmarks/views.py` file and
    append the following to its end:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The `autocomplete()` plugin sends user input in a GET variable named `q`. Therefore,
    we can verify that this variable exists and build a list of tags whose names begin
    with the value of this variable. This is done using the `filter()` method and
    the `istartswith` operator that we learned about earlier in this chapter. We only
    take the first ten results to avoid overwhelming the user with suggestions and
    to reduce the bandwidth and performance costs. Finally, we join the suggestions
    into a single string separated by newlines, wrap the string into an `HttpResponse`
    object, and return it.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the suggestion view ready, add a URL entry to the plugin in the `urls.py`
    file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Now activate the plugin on the tags input field by entering the following code
    in the `site_media/tag_autocomplete.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The code passes an anonymous function to the `$(document).ready()` method. This
    function invokes the `autocomplete()` function on the tags input field, passing
    the arguments that we talked about earlier.
  prefs: []
  type: TYPE_NORMAL
- en: These few lines of code are all that we need in order to implement autocompletion
    of tags. To test the new feature, navigate to the bookmark submission form at
    `http://127.0.0.1:8000/save/` and try to enter a character or two in the tags
    field. Suggestions should appear based on the tags available in your database.
  prefs: []
  type: TYPE_NORMAL
- en: With this feature, we finish this chapter. We covered a lot of material and
    learned about many exciting technologies and techniques. After reading the chapter,
    you should be able to think of and implement many other enhancements to the user
    interface, such as the ability to delete bookmarks from the user page or to do
    live browsing of bookmarks by tags among, many other things.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next chapter will shift to a different topic: we will let users vote and
    comment on their favorite bookmarks and the front page of our application won''t
    remain as empty as it is now!'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Phew! This was a long chapter, but hopefully you learned a lot from it! We
    started the chapter with learning about the jQuery framework and how to integrate
    it in to our Django project. After that, we implemented three exciting features
    in our bookmarking application: live searching, in-place editing, and autocompletion.'
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter is going to be another exciting one. We will let users submit
    bookmarks to the front page and vote for their favorite bookmarks. We will also
    enable users to comment on bookmarks. So, read on!
  prefs: []
  type: TYPE_NORMAL
