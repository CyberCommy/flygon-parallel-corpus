- en: Docker and Jenkins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will learn how to leverage Jenkins to build our Docker images
    and deploy our Docker containers. Next, we will learn how to deploy our Jenkins
    server as a Docker container. We will follow that by learning how to build Docker
    images within the Dockerized Jenkins server. This is what is often called Docker
    in Docker. Finally, we will see how to utilize Docker containers as Jenkins build
    agents, allowing every build to be run in a pristine, ephemeral Docker container.
    Of course, we will show how to build Docker images, test applications, and push
    tested images to a Docker registry, all within our Dockerized Jenkins build agents.
    This will provide you will all the tools you will need to set up your CI/CD systems.
  prefs: []
  type: TYPE_NORMAL
- en: If all the containers in the world were laid end to end, they would go around
    the earth more than twice.– [https://www.bigboxcontainers.co.za/](https://www.bigboxcontainers.co.za/)
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Using Jenkins to build Docker images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up a Dockerized Jenkins server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building Docker images inside a Dockerized Jenkins server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Docker containers for your Jenkins build nodes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building, testing, and pushing Docker images inside Dockerized build nodes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will be pulling Docker images from Docker's public repo, and installing
    the Jenkins server software, so basic internet access is required to execute the
    examples within this chapter. Note also that these examples have higher system
    requirements than those presented in previous chapters. The server used in this
    chapter's examples has 8 GB ram, 2 CPUs, and 20 GB of HDD.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code files of this chapter can be found on GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Docker-Quick-Start-Guide/tree/master/Chapter08](https://github.com/PacktPublishing/Docker-Quick-Start-Guide/tree/master/Chapter08)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the code in action: [http://bit.ly/2AyRz7k](http://bit.ly/2AyRz7k)'
  prefs: []
  type: TYPE_NORMAL
- en: Using Jenkins to build Docker images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You probably already know that Jenkins is a widely-used tool for continuous
    integration/continuous delivery (CI/CD) systems. Virtually every company, both
    large and small, is using it in some capacity. It is extremely effective, and
    highly configurable, especially with the variety of plugins that can be used with
    it. So, it is very natural to expand its use to create Docker images. This first
    step in using Jenkins with Docker is pretty easy to accomplish. If you have an
    existing Jenkins server in use today, all you need to do to use it to build Docker
    images is to install Docker on the Jenkins server. You use the exact same installation
    techniques that we saw and used in Chapter 1, *Setting up a Docker Development
    Environment*. Based on the OS of the system that is running your Jenkins server,
    you follow the install steps you learned in [Chapter 1](899dfdb1-3f82-4f8d-813e-2d8a4c9f58cd.xhtml),
    S*etting up a Docker Development Environment*; when you are done, you can use
    Jenkins to build Docker images.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you don''t already have a Jenkins server up and running, you can follow
    the guide found in the *Installing Jenkins* web page link in the following *References*
    section and install Jenkins on whatever OS you''re using. As an example, we will
    be using the information from that page to set up a Jenkins server on an Ubuntu
    system. Start by opening a terminal window. Now get the apt-key for Jenkins packages.
    Next, you will add the Debian Jenkins source to the apt sources list. Next, you
    will update the packages on the system, and finally, you will install Jenkins
    using apt-get. The commands look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Running these commands on my system looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/9ffd1d7c-3383-4e84-acf8-771ca376e97c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When the install completes, you will want to open your browser and browse to
    port `8080` on the system to finish the setup and configuration of your Jenkins
    system. This will include entering the admin password and then deciding which
    plugins to install as part of the initial deployment of your Jenkins server. I
    recommend using the set recommended by Jenkins as it is a great starting point:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/95c474c0-2d10-402b-af99-71ad922f7dd7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that you have a Jenkins server, you can begin creating jobs for it to execute
    to confirm that it is working as desired. Let''s start out with a trivial Hello
    world! job to confirm that Jenkins is working. Log into your Jenkins server and
    click on the New Item link. In the new item page, enter the name for our job.
    I''m using `hello-test`. Select the type of job that we want to create as pipeline.
    Next, click the OK button near the bottom left of the page. This will take you
    to the configuration screen for our new job. This one is going to be very simple.
    We are going to create a pipeline script, so scroll down until you see the Pipeline
    script input box, and enter the following script (note that the pipeline script
    is written in groovy, which uses the Java (and C) form of comments):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s all for now, so click on the Save button to save the updated configuration
    of our Jenkins job. Once the configuration has been saved, let''s test the job
    by clicking on the Build now link. If everything is functioning as expected, we
    should see the job complete successfully. It will look something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/076b8ce5-1c78-4a28-9822-c898bf0ef082.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now let''s create another job. Click the link to go back to the dashboard and
    then click the New Item link again. This time, let''s name the job `hello-docker-test`.
    Again, select the pipeline for the type of job you want to create and then click
    the OK button. Again, scroll down to the Pipeline script input and enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Click on the Save button to save the configuration for the new job, and then
    click the Build Now link to launch the Jenkins job. The following is what it might
    look like this time:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/140e4cd5-a668-4c00-928e-d2f9dd279357.png)'
  prefs: []
  type: TYPE_IMG
- en: 'What happened this time? This one didn''t complete successfully. Well, obviously
    it failed because we don''t have Docker installed on our Jenkins server yet. So
    let''s go ahead and follow the instructions found in Chapter 1, S*etting up a
    Docker Development Environment*, for installing Docker, and install it on our
    Jenkins server. Once you have it installed, there is one additional step you will
    want to do, which is to add the Jenkins user to the Docker group. The following
    is the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: It is very much like the command we used to add the current user of our Docker
    server to the docker group so that it was unnecessary to use `sudo` for Docker
    commands. OK, now let's go back to our Jenkins server UI and to our `hello-docker-test`
    job and click the Build now button again.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/6ab728c9-55d5-4d7f-a12e-43f03623c137.png)'
  prefs: []
  type: TYPE_IMG
- en: Congratulations! You have a shiny, new Jenkins server, properly configured to
    build (test, push, and deploy) Docker images. Well done. Still, while this is
    a great accomplishment, it was kind of a lot of work. Don't you wish there was
    an easier way to set up a new Jenkins server? So, you know how you already have
    a nice set of servers running Docker? Do you think you can use that environment
    to stand up your Jenkins server in an easier way? You betcha! Let's take a look.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following is the web page to install Jenkins: [https://jenkins.io/doc/book/installing/](https://jenkins.io/doc/book/installing/).
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a Dockerized Jenkins server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You have just seen how much work it is to set up a new Jenkins server. While
    it is not a Herculean effort, there are at least five steps you have to do before
    you can pick your plugins and log in to get to work. And in the spirit of the
    game show *Name That Tune*, I can deploy a Jenkins server in three steps, and
    the first two are just to allow our Jenkins data to persist beyond the life of
    the Docker container that hosts the Jenkins server. Assuming you have a Docker
    host set up-and-running as per the instructions in Chapter 1, S*etting up a Docker
    Development Environment*, we want to create a location for the Jenkins server
    to store its data. We will create a folder and assign ownership to it. It will
    look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The owner `1000` is the user ID that will be used for the jenkins user inside
    the Docker container.
  prefs: []
  type: TYPE_NORMAL
- en: 'The third step is to deploy our container. Before I show you the command, let
    me talk a little about which container image to use. I am including a link for
    searching on the Docker hub for Jenkins images. If you use that link or search
    on your own, you will see that there are a lot of options to choose from. Initially,
    you might think about using the official Jenkins image. However, if you browse
    to that repo, you will find what I feel is kind of odd, which is that the official
    image is deprecated. It has stopped being updated past version LTS 2.60.x:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/69a04bfa-7556-4017-9b3a-dad4edb474a7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'It recommends using the image found in the jenkins/jenkins:lts Jenkins repo,
    which at the time of writing is version 2.149.x. This is the image we will use
    in the following example. The following is the command we are going to use to
    deploy our Jenkins server container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Taking a closer look at this command, we see that we are launching the container
    as a daemon (non-interactively). We see that we are opening two ports on the host,
    which are mapped to the same port numbers on the container, specifically `8080`
    and `50000`. Next, we see that we are using a volume, and it is mapping to the
    folder we created earlier. This is where Jenkins will store its data, such as
    the jobs we create and the status of their execution. Then you will notice we
    are nameing the container `jenkins`. After that, we tell Docker to remove the
    container when it exits using the `--rm` flag. Finally, we tell Docker what image
    we want to run.
  prefs: []
  type: TYPE_NORMAL
- en: When you run this container, giving it a minute or two to start up and browse
    to port `8080` on the Docker host, you will see the same prompt for a password
    that you see when you deploy Jenkins as a standalone application. That will be
    followed by the create-the-first-user screen and the default-plugin-configuration
    screen. Go ahead and give it a try.
  prefs: []
  type: TYPE_NORMAL
- en: Since we have created a volume for the Jenkins data (written to `/var/jenkins_home`),
    our Jenkins configuration data is being saved to the host and will live beyond
    the life of the container itself. Of course, you can use a storage driver and
    have this data somewhere more permanent than the Docker host, but you get the
    idea, right?
  prefs: []
  type: TYPE_NORMAL
- en: The only problem is that neither the official Jenkins image nor the `jenkins/jenkins`
    image supports creating jobs that will build a Docker image. And since this book
    is all about Docker, we need to do something more than just run our Jenkins server
    using the aforementioned images. Don't worry, I have a plan for that… Keep reading.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Docker hub search for Jenkins images: [https://hub.docker.com/search/?isAutomated=0&isOfficial=0&page=1&pullCount=0&q=jenkins&starCount=0](https://hub.docker.com/search/?isAutomated=0&isOfficial=0&page=1&pullCount=0&q=jenkins&starCount=0)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Official Jenkins image repo: [https://hub.docker.com/_/jenkins/](https://hub.docker.com/_/jenkins/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jenkins/jenkins repo: [https://hub.docker.com/r/jenkins/jenkins/](https://hub.docker.com/r/jenkins/jenkins/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building Docker images inside of a Dockerized Jenkins server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Alright. Now you know how to deploy Jenkins as a Docker container, but we really
    want to be able to use Jenkins to build Docker images, as we did in the standalone
    deployment of Jenkins. To do that, we could deploy the same Jenkins image, and
    exec into it and install Docker and could probably get it to work, but we don't
    need to go to that much trouble. We're not the first pioneers to go down this
    road. There are several Docker images that have been created to do just what we
    are looking to do. One such image is `h1kkan/jenkins-docker:lts`. You can read
    about it by following the link in the following *References* section, but for
    now just know that it is an image that has been set up as a Jenkins server, and
    has Docker already installed in it. In fact, it also has Ansible and the AWSCLI
    pre-installed so you can do more than just build Docker images using it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin, we will create a location on the Docker host to mount a Docker volume
    to store and preserve the Jenkins configuration. If you are using the same Docker
    host as you used in the previous section, you should already have created your
    folder and assigned ownership of it to ID `1000`. If not, the following are the
    commands you use to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, if you haven''t done so already, you can use the `docker container stop
    jenkins` command to stop (and remove) the Jenkins container that we created in
    the previous section to clear the way for our new and improved Jenkins server.
    When you are ready to create the new container, you can use these commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: You will have noticed a couple of differences in this code block. The first
    is the use of a second volume. This is a well-known trick, of sorts, that allows
    a container to issue Docker commands to its host. This essentially allows what
    is known as Docker-in-Docker. The next difference is an extra Docker command that
    will start the Docker service inside the running container. Because each container
    starts up with a single process, having both a Jenkins server process and a Docker
    daemon running requires this extra step.
  prefs: []
  type: TYPE_NORMAL
- en: Once the Docker service has started within the Jenkins container, you are all
    set to create new Jenkins jobs that use and build Docker images. You can test
    it out yourself by recreating the second example above, `hello-docker-test`, in
    your new Jenkins server. And since we are using the Docker volume mounted on the
    host at `$HOME/jenkins_home` to store our Jenkins data, this should be the last
    time you need to create this job.
  prefs: []
  type: TYPE_NORMAL
- en: This is all working wonderfully, but you may recall from Chapter 7, *Docker
    Stacks*, that we have a better way to deploy apps than by using the `docker container
    run` command, namely using Docker stacks. So would you like to see our example
    re-imagined as a Docker stack? Me too! OK then, let's do it.
  prefs: []
  type: TYPE_NORMAL
- en: 'First off, use the container stop command to stop your current Jenkins container.
    It will leave behind the `jenkins_home` folder with our Jenkins server''s data,
    but if for some reason you skipped ahead to this part of the chapter and haven''t
    created that yet, the following are the commands to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Again, if you did those two commands for one of the previous examples, and you
    are using the same Docker host, you don't have to do that again because the folder
    already exists and has the right ownership.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, you need to create a compose file for our Jenkins stack. I called mine
    `jenkins-stack.yml` and entered the following YML code into it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: You will notice that we are creating two services; one is our Jenkins server,
    and the other is a Docker registry. We will use the registry service in an upcoming
    example, so keep that in your back pocket for now. Looking at the Jenkins service
    description, there is nothing we did not see already in Chapter 7, *Docker Stacks*,
    when we learned about Docker stacks. You will notice our two port mappings and
    the two volumes that were used in the last example. We are confining the single
    Jenkins replica to our manager node.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that to use Docker stacks we have to be running in swarm mode, so if
    you have not done so already, create your swarm with the `docker swarm init` command
    that we learned in Chapter 5,  *Docker Swarm*.
  prefs: []
  type: TYPE_NORMAL
- en: Understand that if your swarm has more than one manager node, you will need
    to further confine the Jenkins replica to just the single manager that has your
    `jenkins_home` volume mount point. This can be accomplished with a combination
    of roles and labels. Alternatively, you can use a storage driver and mount a volume
    that can be shared among swarm managers. For simplicity, we are assuming a single
    manager node for our example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now use the stack deploy command to set up the Jenkins application. The following
    is an example of the command to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Once the stack is deployed and the services up and running, you can browse to
    any node in your swarm, on port 8080, and get to your Jenkins server. What's more,
    if you are reusing the `jenkins_home` folder from our previous example, you will
    not have to supply the admin password, create a new user, and select your plugins
    because all of the data related to those tasks was stored in the `jenkins_home`
    folder and is reused now by your stack-based Jenkins service. One more interesting
    note is that you do not have to start the Docker service when you use this image
    in a stack application. Bonus!
  prefs: []
  type: TYPE_NORMAL
- en: 'OK, we now have a sweet stack-based Jenkins service that is capable of using
    and building Docker images. Everything seems right with the World. But there is
    one thing that could make this better. And by better, I mean more Docker-y: instead
    of using the normal Jenkins agents for our build jobs, what if we wanted to spin
    up a new, pristine Docker container to use for each execution of our Jenkins jobs?
    This would ensure that every build was built from scratch in a clean, consistent
    environment. Plus, it really takes the Docker inception level up a notch, so I
    like it a lot. If you want to see how it''s done, keep reading.'
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: H1kkan/jenkins-docker repo: [https://hub.docker.com/r/h1kkan/jenkins-docker/](https://hub.docker.com/r/h1kkan/jenkins-docker/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Docker containers for your Jenkins build nodes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To use Docker containers for the Jenkins build agents, you need to do a few
    things to your Jenkins configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: Build a new Docker image that can act as a Jenkins build agent, and is capable
    of building Docker images (of course)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Push the new image to a Docker registry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Turn off the default Jenkins build agents
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Install the Docker plugin for Jenkins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configure a new cloud to enable Dockerized build agents
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building the Docker image
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s get started. The first thing we want to do is build our specialized
    Docker image that can be used for our Jenkins agents. To do this, we are going
    to use the skills we learned in Chapter 3, *Creating Docker Images*, to create
    Docker images. Start by creating a new folder on your development system, and
    then change your working directory to that folder. I named mine `jenkins-agent`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now create a new file, named `Dockerfile`, using your favorite editor, enter
    the following code into it, and then save it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is what our new Dockerfile is doing: in our `FROM` instruction, we are
    using the same Docker image that we used in our Docker-in-Docker example above
    so that we have a base image that will allow us to build Docker images. Next,
    we use the `USER` command to set the current user to root. Next, we create an
    `ARG` named user and set it to a value of `jenkins`. After that, we set an environment
    variable named `HOME` that has a value for the Jenkins user''s home folder. Then,
    we set two more `ARGs`, one for the version and one for the Jenkins agent''s working
    directory. The next one is where the magic happens. We are using a `RUN` command
    to set up and curl the Jenkins `slave.jar` file. This is the bit that is required
    to run as a Jenkins agent. We also set some permissions on the folder and file,
    and then clean up a bit by deleting curl. After that, we set another environment
    variable, this one for `AGENT_WORKDIR`. Next up, we create a couple of folders
    in the container. Then, we use the `USER` instruction again, this time setting
    the current user to our Jenkins user. We round out the Dockerfile by creating
    a couple of `VOLUME` instances and, finally, we set the current working directory
    to the home directory for our Jenkins user. Phew! That seems like a lot, but really
    it''s not so bad, and all you have to do copy and paste the preceding code into
    your Dockerfile and save it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have our Dockerfile ready to use, it might be a good time to create
    a git repo and save your code to it. Once you are satisfied that your project
    has been properly set up with git, we can build our new Docker image. The following
    is the command you will use for that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: It should build successfully and create a locally-cached image tagged as `jenkins-agent:latest`.
  prefs: []
  type: TYPE_NORMAL
- en: Pushing the new image to a Docker registry
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next, we need to push our new image to a Docker registry. Of course, we could
    push it to our repo within hub.docker.com, but since we have an application stack
    that just so happens to have deployed a Docker registry, why don''t we utilize
    it for our Jenkins agent image? First, we need to tag our new image with the registry.
    Your tag command will differ from mine based on the domain name of your Docker
    swarm, but for my example, the following is what my tag command looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that the image is tagged locally, we can push it to the registry with the
    following command; again, your command will be different based on the domain name
    of your swarm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: All of these commands might utilize a better version scheme than the oversimplified
    use of the `latest` tag, but you should be able to address that on your own. With
    our image built, tagged, and pushed to the Docker registry, we are ready to update
    our Jenkins configuration to use it.
  prefs: []
  type: TYPE_NORMAL
- en: Turning off the default Jenkins build agents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we are ready to update our Jenkins configuration to support our Dockerized
    build agents. The first configuration change we are going to make is to turn off
    the default build agents. To do this, log into your Jenkins server, and click
    the Manage Jenkins menu link. This will take you to a variety of configuration
    groups you can manage, such as system, plugins, and CLI settings. For now, we
    will need to go to the Configure System management group:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/ca007e0f-82ae-4c3e-a93a-cd1c22f5d9d4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once you are in the Configure System management group, you are going to change
    the value for # of executors to `0`. It should look something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/930fbb65-4fa9-4fd7-b80e-7166516f870c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When you have changed the # of executors value to `0`, you can go ahead and
    save the settings by clicking the Save button in the lower-left part of the screen.
    At this point, with this change in place, your Jenkins server will not be able
    to run any jobs because there are no Jenkins agents configured to run them. So
    let''s move on quickly to the next step, which is to install the Docker plugin.'
  prefs: []
  type: TYPE_NORMAL
- en: Installing the Docker plugin for Jenkins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we need to install the Docker plugin for Jenkins. You accomplish this as
    you would other plugin installations. Click on the Manage Jenkins menu link, and
    from the list of configuration groups, click the link for the Manage Plugins group:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/b844e146-e6c0-45f3-9795-d35802f31383.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once you are in the Manage Plugins configuration group, select the tab for
    Available plugins, and then in the filter box, type `docker` to narrow down the
    list of available plugins to those related to Docker:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/8ac3ae3c-383f-4ec3-8cfe-de0d89fe93f2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Even with a filtered list, there are still a lot of plugins to choose from.
    Find and check the box for the Docker plugin. It looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/a78b0276-360d-4e6c-aaeb-686e4b69ef4e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'With the Docker plugin checkbox checked, scroll down and click the Install
    without restart button. This will download and install the plugin for you, and
    then enable it as soon as Jenkins restarts. On the install screen, you have the
    option to execute a restart as soon as the plugin is installed. To do this, check
    the Restart Jenkins when installation is complete and no jobs are running checkbox:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/df355ed4-fc95-4e7d-90f8-7ad906a74f02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Since we set the # of executors to `0` a few minutes ago, there will not be
    any jobs running now, so as soon as the plugin is installed, Jenkins will restart.
    As soon as Jenkins comes back online, the plugin will be installed. We need to
    log back in to Jenkins and set up our Cloud.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new Cloud to enable our Dockerized build agents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we will tell Jenkins to use our custom Docker image to run containers as
    Jenkins build agents. Once more, click on the Manage Jenkins menu link. From the
    list of configuration groups, you will again click the link for the Configure
    System group. You will find the Cloud configuration near the bottom of the configuration
    options. Click on the Add a new cloud dropdown and select `Docker`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/85ccfde1-560f-4fcd-8957-d8bb1409904d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The screen will update and you will have two new configuration groups: Docker
    Cloud details... and Docker Agent templates...:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/bd8072d5-822e-4414-9048-d83ba0de2a74.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s take care of the Docker Cloud details first. Click on that button now.
    You can leave the Name value as the default for `docker`. In the Docker Host URI
    field, enter `unix:///var/run/docker.sock`. You can find this value by clicking
    the question mark help icon and copying and pasting it into the input field. Next,
    click the Test Connection button and you should see a version line show up, similar
    to the one you will see in the following screenshot. Make note of the API Version
    number as you will need it for the Advanced... setup. Click the Advanced... button
    and enter the API Version number in the Docker API Version field. You need to
    check the Enabled checkbox to enable this feature, so be sure to do so. Finally,
    you may want to change the number of containers that the system can run concurrently.
    The default is 100\. For my example, I reduced the value to `10`. When you are
    done, your configuration should look something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/f2e0d7ea-7952-4496-a6d5-fd3a9cf456a7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, click the Docker Agent templates... button and then click the Add Docker
    template button that appears so that we can to configure the Jenkins agent settings.
    Here, you will want to click the agent''s Enabled checkbox to enable our new agent
    template. You can give a name to use as the prefix for the containers that are
    run by Jenkins as the build agents, or you can leave the name blank and the `docker`
    prefix will be used. Next, enter the repository and the name tag for the image
    you want to use for the build agent containers. We created our custom image, tagged
    it, and pushed it to our Jenkins stack application repo using the `ubuntu-node01:5000/jenkins-agent:latest`
    image name, so enter that value into the Docker Image field. Set the Instance
    Capacity value to `1`, and the Remote File System Root value to `/home/jenkins/agent`.
    Make sure the Usage value is set to `Use this node as much as possible`, and use
    the `Attach Docker container` value for the Connect method. Set the User to `root`.
    Change the Pull strategy value to `Pull once and update latest`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/79d3e2f7-bed3-4876-8839-acd362836905.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, we need to configure some Container settings..., so click to expand
    that section. The value we need to enter here is the command we want to use when
    the container is run. The value you need in the Docker Command field is `java
    -jar /usr/share/jenkins/slave.jar`. The value you need in the Volumes field is
    `/var/run/docker.sock:/var/run/docker.sock`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/91b7b76b-f375-4e9a-96dd-fc80c59193a3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'And lastly, check the checkbox for Allocate a pseudo-TTY:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/2361d7a1-efdd-4143-a14a-91c14c5be184.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Scroll down to the bottom of the configuration screen and click the Save button
    to save all of the Cloud settings. That was some serious configuration Kung Fu—great
    job! However, just in case you want a quick reference for all of the values entered,
    here are all of the custom (or non-default) values entered to configure the Docker
    Cloud in our example:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Field name** | **Value used** |'
  prefs: []
  type: TYPE_TB
- en: '| Docker Host URI | `unix:///var/run/docker.sock` |'
  prefs: []
  type: TYPE_TB
- en: '| Docker API Version | `1.38` (match the version shown in the connection test)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Docker Cloud Enabled | Checked |'
  prefs: []
  type: TYPE_TB
- en: '| Container Cap | `10` |'
  prefs: []
  type: TYPE_TB
- en: '| Docker Agent Enabled | Checked |'
  prefs: []
  type: TYPE_TB
- en: '| Docker Agent Template Name | `agent` |'
  prefs: []
  type: TYPE_TB
- en: '| Docker Image | `ubuntu-node01:5000/jenkins-agent:latest` |'
  prefs: []
  type: TYPE_TB
- en: '| Instance Capacity | `1` |'
  prefs: []
  type: TYPE_TB
- en: '| Remote File System Root | `/home/jenkins/agent` |'
  prefs: []
  type: TYPE_TB
- en: '| Usage | `Use this node as much as possible` |'
  prefs: []
  type: TYPE_TB
- en: '| Connection Method | `Attach Docker container` |'
  prefs: []
  type: TYPE_TB
- en: '| User | `root` |'
  prefs: []
  type: TYPE_TB
- en: '| Pull Strategy | `Pull once and update latest` |'
  prefs: []
  type: TYPE_TB
- en: '| Docker Command | `java -jar /usr/share/jenkins/slave.jar` |'
  prefs: []
  type: TYPE_TB
- en: '| Volumes | `/var/run/docker.sock:/var/run/docker.sock` |'
  prefs: []
  type: TYPE_TB
- en: '| Allocate a pseudo-TTY | Checked |'
  prefs: []
  type: TYPE_TB
- en: Now that everything is configured, let's give our newly-defined Jenkins agents
    a test.
  prefs: []
  type: TYPE_NORMAL
- en: Testing our new build agents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Head back to the Jenkins dashboard and click on the Schedule a Build button
    for our `hello-docker-test` job. This will start a new build for our job, which
    in turn will create a new Dockerized build agent. It uses the configuration we
    set to execute a `docker container run` command to run a new container based on
    the image we specified. Initially, the executor will be offline as the container
    spins up:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/5ef3cfa0-9f85-4bd8-9f0d-8033edc1ab22.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Notice that the executor name has the agent prefix that we specified. Once
    the container is running, the Jenkins job will be initiated within it, essentially
    using the `docker container exec` command. When the Jenkins job has started, the
    normal job-progress graphic will display, and the executor will no longer show
    as offline. The status will then look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/fe9dfbb5-5374-4b37-8847-010948778f6f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you click on the progress bar of the executing job, you can view the job''s
    console output, and after a short while the job will show the finished: SUCCESS
    status, like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/5b261ded-6411-40af-affc-42214a2e25ed.png)'
  prefs: []
  type: TYPE_IMG
- en: A job well done! Let's examine one last example Jenkins job to show a pipeline
    script that has more stages, and represents a real-world example of a Docker job.
    Are you ready? Read on.
  prefs: []
  type: TYPE_NORMAL
- en: Building, testing, and pushing Docker images inside Dockerized build nodes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To wrap up this chapter on Docker and Jenkins, let''s walk through the steps
    of creating a template for a real-world Dockerized node application. The following
    is what we will do:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Prepare our application:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new repo on GitHub
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clone the repo to our development workstation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create our application files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Push our application files up to GitHub
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Create and test the Jenkins job that will build our Dockerized node application:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Jenkins job that utilizes the GitHub repo
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test our Jenkins job that will pull the repo, build the app, test it, and publish
    the image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Celebrate our success!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's begin by preparing our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we want to do is create our application repo on GitHub. Browse
    and log into [github.com](http://www.github.com), go to your repositories page,
    and click on the Create New Repo button. Enter a name for the new repository.
    For our example, I used `dqs-example-app`. Enter an appropriate description. You
    can make your repo public or private. For this example, I am keeping it public
    for the simplicity of not needing to authenticate to pull the repo later. Check
    the Initialize the repository checkbox so you can immediately clone the empty
    repo on your workstation. You can select the project type to use when creating
    the `.gitignore` file. I selected `Node`. When you have entered and selected all
    this, it will look much like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/48bc3985-be57-41e8-a45e-e19d7f4998e0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on the Create repository button to create your new application repo.
    Now that it is created on GitHub, you will want to clone it to your workstation.
    Use the Clone or download button and then the copy button to copy the repo''s
    URL for the cloning step:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/44409c48-3703-4a37-a8ef-bb67901d05a2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, return to your workstation and, in the location where you keep your local
    repos, clone the new (mostly) empty repo. Then change directory into the new repo''s
    folder. For me, that looked like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/983a1f97-6082-47e2-85df-40b296775617.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now we are going to create the application''s scaffolding. This will consist
    of creating a `Dockerfile`, a `Jenkinsfile`, the `main.js` and `test.js` files,
    and the `package.json` file. Use your favorite editor to create each of these
    files in your application folder. The following are the contents for the files:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the contents of the `Dockerfile` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are the contents of the `Jenkinsfile` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are the contents of the `main.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are the contents of the `package.json` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, the following are the contents of the `test.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'When you are all done, your repo folder should look something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/94cd891d-3d0f-44a1-87bd-a5b1d51a81cf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s push our work up to the GitHub repo. You will use standard git
    commands to add the files, commit the files, and then push the files up to the
    repo. The following are the commands I used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is what that looked like for me:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/f01fd31d-6e5e-42cd-8382-a8657926144b.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that the initial version of our application has been created and pushed
    to our GitHub repo, we are ready to create the Jenkins job to pull our repo code,
    build our application image, test it, and then publish our application's Docker
    image. Start off by creating a new Jenkins job, by logging into your Jenkins server
    and clicking on the New Item link. Next, enter the name you want to use for the
    job in the Enter an item name input box. I am using `dqs-example-app`. Select
    `Pipeline` for the type of job we are creating, and then click the OK button.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can, and probably should, provide a meaningful description for the build
    job we are creating. Just enter it into the Description: input box at the top
    of the configuration screen. For our example, I have entered the somewhat terse
    description `Build the dqs-example-app using a pipeline script from SCM`. You
    can probably do a lot better.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to set up the Jenkins job to poll the GitHub repo every five minutes
    to look for changes to the master branch. There are better options where changes
    to the repo can trigger the build job without scheduled polling, but for the simplicity
    of this example, we will just use a poll method. So scroll down to the Build Triggers
    section of the job''s configuration and check Poll SCM. Then in the schedule,
    enter a value of `H/5 * * * *`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/2edd77ba-1fd9-43c2-a54b-c0721a69ebd8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we want to set up our pipeline. Unlike the previous examples, this time
    we will select the Pipeline script from SCM option. We will select `Git` for our
    SCM, and then enter the Repository URL for our application''s repo on GitHub.
    For this example, that URL is `https://github.com/EarlWaud/dqs-example-app.git`.
    Make sure that the Branches to build value is set to `*/master`, which is the
    default value. Your pipeline definition should like a lot like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/c00bff59-f503-4d42-a9b0-5ace6f9aaf57.png)'
  prefs: []
  type: TYPE_IMG
- en: 'There is one more key setting for the pipeline, and that is the Script Path.
    This is the (path and) filename to the Jenkins script file. In our case, that
    is literally just `Jenkinsfile` because the name we gave the file is `Jenkinsfile` and
    it is in the root of our repo. This is what our example''s input looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/50c3760a-1450-49fd-9276-ab3def3f10a4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'That is all the configuration needed at this time. Everything else is already
    set up in our source files, and they will be pulled from our application repo.
    All that''s left to do for the configuration is to click the Save button. Back
    at the job''s page, we are ready to execute our first build. The newly-created
    job screen looks like this in our example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/33667e7a-61d6-4fa0-8c47-8deffb2a9522.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, just wait. In five minutes or fewer, the first build of the job will kick
    off automatically because we have set up polling the repo at five-minute intervals.
    We will take a look at the console log when the job has finished, but first here
    is our Jenkins job view after the job completes (successfully, of course!):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/2d26df0f-15ab-4df0-908a-45787221ef31.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following is an edited view of the console log output for reference (the
    full log output can be found in the source bundle):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'All that is left to do now is celebrate our success:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/0d4fb92f-733c-4808-bc8a-904b799a8bd6.png)'
  prefs: []
  type: TYPE_IMG
- en: Seriously, this is a great foundation for creating your own Dockerized applications
    and building, testing and publishing them using Jenkins. Consider it as a template
    that you can reuse and build from. You are now ready to utilize Docker with Jenkins
    in any way you desire.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Well, here we are, at the end of the chapter. I hope you had as much fun reading
    this chapter as I had writing it. We had the opportunity to use many of the skills
    that we learned in the previous chapters. Not only that, there are some really
    useful Jenkins lessons in this chapter as well. So much so that you could seriously
    consider skipping any planned Jenkins training or book-reading because pretty
    much everything you need to know about using Jenkins is right here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s recap: first, we learned how to set up a standalone Jenkins server.
    We quickly transitioned into deploying a Jenkins server as a Docker container.
    That''s the kind of thing you''re reading this book for, right? Then we learned
    how to build a Docker image in a Dockerized Jenkins server. Next, we found out
    how to replace the boring Jenkins agents with super-cool Docker containers that
    can build our Docker image. You might think about this and Docker-in-Docker-in-Docker.
    Have you seen the movie Inception? Well, you just lived it. Finally, to wrap up
    the chapter, we created an example dockerized app and the Jenkins job that builds,
    tests, and publishes that app''s image. It''s an example that you can use as a
    template and foundation for the real-world applications you will create in the
    future.'
  prefs: []
  type: TYPE_NORMAL
- en: And, here we are at the end of the book. I'll say it again… I hope you had as
    much fun reading it as I had writing it. And I hope you learned as much reading
    it as I did writing it. We covered a lot of Docker information throughout these
    chapters. We nailed Docker workstation setup in the [Chapter 1](899dfdb1-3f82-4f8d-813e-2d8a4c9f58cd.xhtml),
    *Setting up a Dockerized Development Environment*, regardless of the type of OS
    you prefer. In [Chapter 2](e66034ed-dcc0-48a8-a2ec-9466669e6649.xhtml), *Learning
    Docker Commands*, we learned just about everything there is to know about the
    Docker command set. In [Chapter 3](ab7747ed-23c9-462c-98cb-c70e330c5d87.xhtml),
    *Creating Docker Images*, we studied the `Dockerfile` instruction set in depth
    and learned how to create just about any Docker image you could want to build.
    Chapter 4, *Docker Volumes*, showed us the power and usefulness of Docker volumes.
    We started putting several of the lessons from the earlier chapters to use when
    we exercised the features of the almost magical Docker swarm in [Chapter 5](f1681897-580b-44fb-9e43-4aed37e67529.xhtml),
    *Docker Swarm*. Then, in [Chapter 6](873454a4-2f8e-42df-93ab-7648545167bb.xhtml),
    *Docker Networking*, we continued our Docker education, this time learning how
    Docker has simplified the complex topic of networking for us. And in [Chapter
    7](1a206f3a-faf8-43cb-9413-d1e451bd2a35.xhtml), *Docker Stacks*, we saw more Docker
    magic and power when we learned about Docker stacks. Finally, in [Chapter 8](88652c62-a041-4cec-b42c-0aaa414d7083.xhtml),
    *Docker and Jenkins*, we put all of our learning to use and leveraged Docker with
    Jenkins to prepare us to create real-world applications.
  prefs: []
  type: TYPE_NORMAL
- en: All that is left is for me to say thanks and wish you success in your Docker
    journey.
  prefs: []
  type: TYPE_NORMAL
