- en: Creating Rich Text with QTextDocument
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whether drafting business memos in a word processor, writing a blog entry, or
    generating reports, much of the world's computing involves the creation of text
    documents. Most of these applications require the ability to produce not just
    plain alphanumeric strings, but rich text as well. Rich text (as opposed to plain
    text) means text that includes styles and formatting features such as font faces,
    colors, lists, tables, and images.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to learn how PyQt allows us to work with rich
    text by covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating rich text using markup
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manipulating rich text using `QTextDocument`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Printing rich text
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this chapter, you'll need the basic Python and Qt setup you've been using
    since [Chapter 1](bce5f3b1-2979-4f78-817b-3986e7974725.xhtml), *Getting Started
    with PyQt*. You might like to have the example code that can be found at [https://github.com/PacktPublishing/Mastering-GUI-Programming-with-Python/tree/master/Chapter11](https://github.com/PacktPublishing/Mastering-GUI-Programming-with-Python/tree/master/Chapter11) as
    a reference.
  prefs: []
  type: TYPE_NORMAL
- en: Check out the following video to see the code in action: [http://bit.ly/2M5P4Cq](http://bit.ly/2M5P4Cq)
  prefs: []
  type: TYPE_NORMAL
- en: Creating rich text using markup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every application that supports rich text must have some format to represent
    that text in memory and when saving it to a file. Some formats use custom binary
    code, such as the `.``doc` and `.``rtf` files used by older versions of Microsoft
    Word. In other cases, a plain-text **markup language** is used. In a markup language,
    special strings called **tags** indicate the placement of rich text features.
    Qt takes the markup approach and represents rich text using a subset of **hypertext
    markup language** (**HTML**) version 4.
  prefs: []
  type: TYPE_NORMAL
- en: Rich text markup in Qt is rendered by the `QTextDocument` object, and as such
    it is only usable on widgets that use `QTextDocument` to store their contents.
    This includes the `QLabel`, `QTextEdit`, and `QTextBrowser` widgets. In this section,
    we're going to create a demo script to explore the syntax and capabilities of
    this markup language.
  prefs: []
  type: TYPE_NORMAL
- en: Given the popularity and ubiquity of web development, it's likely that you already
    know a bit about HTML; in case you don't, the following section will act as a
    quick introduction.
  prefs: []
  type: TYPE_NORMAL
- en: HTML basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An HTML document is composed of text content interspersed with tags to indicate
    non-plain text features. A tag is simply a word enclosed in angle brackets, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Notice the `</sometag>` code at the end of the preceding example. This is called
    a **closing tag**, and it's simply like the opening tag but with a forward slash
    (`/`) before the tag name. Closing tags are generally only used for tags that
    enclose (or have the ability to enclose) text content.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `b`, `em`, and `u` tags require a closing tag because they enclose a portion
    of the content and indicate a change in appearance. The `br` and `hr` tags (*break* and
    *horizontal rule*, respectively) simply indicate non-textual items to include
    in the document, so they have no closing tags.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to see what any of these examples look like, you can copy them into
    a text file and open them in your web browser. Also, check out the `html_examples.html`
    file in the example code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, complex structures are created by nesting tags, such as in the following
    list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the `ol` tag starts an ordered list (a list that uses sequential numbers
    or letters, rather than bullet characters). Each item in the list is indicated
    by the `li` (list item) tag. Note that when nesting tags use a closing tag, the
    tags must be closed in the correct order, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The preceding incorrect example would not work because the inner tag (`<i>`)
    was closed after the outer tag (`<b>`).
  prefs: []
  type: TYPE_NORMAL
- en: 'HTML tags can have attributes, which are key-value pairs that are used to configure
    the tag, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The preceding tag is an `img` (image) tag that's used for showing images. Its
    attributes are `src` (indicating the image file path), `width` (indicating the
    width to display the image), and `height` (indicating the height to display).
  prefs: []
  type: TYPE_NORMAL
- en: HTML attributes are space-delimited, so don't put commas between them. Values
    can be quoted using single or double-quotes, or left unquoted if they contain
    no spaces or other confusing characters (such as a closing angle bracket); in
    general, however, it's usually best to double-quote them. In Qt HTML, sizes are
    usually specified in `px` (pixels) or `%` (percent), though in modern web HTML,
    other units are commonly used.
  prefs: []
  type: TYPE_NORMAL
- en: Style sheet syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Modern HTML is styled using **Cascading Style Sheets** (**CSS**). You learned
    about CSS in [Chapter 6](c3eb2567-0e73-4c37-9a9e-a0e2311e106c.xhtml), *Styling
    Qt Applications*, when we discussed QSS. To review, CSS allows you to make declarations
    about the way a tag will look, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The preceding CSS directive will make all the content inside bold tags (between
    `<b>` and `</b>`) appear in a red 16 point font.
  prefs: []
  type: TYPE_NORMAL
- en: 'Certain tags can also have modifiers, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The preceding CSS applies to `<a>` (anchor) tag contents, but *only* when the
    anchor is hovered over by the mouse pointer. Modifiers like this are also called
    **pseudo-classes**.
  prefs: []
  type: TYPE_NORMAL
- en: Semantic versus cosmetic tags
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some HTML tags describe how a piece of content should appear. We call these
    **cosmetic** tags. For example, the `<i>` tag indicates that text should be printed
    in an italic font. Consider, though, that italics are used in modern printing
    for many reasons—to emphasize a word, to indicate a title of a published work,
    or to indicate that a phrase is from a foreign language. To differentiate between
    these uses, HTML also has *semantic* tags. For example, `<em>` means emphasis,
    and will result in italic text in most situations. But unlike the `<i>` tag, it
    also indicates *why* the text should be italic. Older versions of HTML generally
    focused on cosmetic tags, whereas newer versions focus increasingly on semantic
    tags.
  prefs: []
  type: TYPE_NORMAL
- en: Qt's rich-text HTML supports a few semantic tags, but they are merely aliases
    for equivalent cosmetic tags.
  prefs: []
  type: TYPE_NORMAL
- en: There is much more to the modern HTML and CSS that's used on web pages than
    we've described here, but what we've covered is sufficient for understanding the
    limited subset used by Qt widgets. If you want to learn more, take a look at the
    resources under the, *Further reading* section at the end of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Structure and heading tags
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To experiment with rich text markup, we're going to write an advertisement for
    our next big game, *Fight Fighter 2*, and view it in a QTextBrowser. To begin,
    get a copy of the application template from [Chapter 4](9281bd2a-64a1-4128-92b0-e4871b79c040.xhtml),
    *Building Applications with QMainWindow,* and call it `qt_richtext_demo.py`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `MainWindow.__init__()`, add in a `QTextBrowser` object as the main widget,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '`QTextBrowser` is based on `QTextEdit`, but is read-only and preconfigured
    to navigate hypertext links. After creating the text browser, we open the `fight_fighter2.html`
    file and insert its contents into the browser using the `insertHtml()` method.
    Now, we can edit `fight_fighter2.html` and see how it is rendered in PyQt.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `fight_fighter2.html` in your editor and begin with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: HTML documents are built hierarchically, with the outermost tag usually being
    `<html>`. However, we can also use `<qt>` as the outermost tag when passing HTML
    to a `QTextDocument`-based widget, which is a good idea as it reminds us that
    we're writing the Qt-supported subset of HTML, not actual HTML.
  prefs: []
  type: TYPE_NORMAL
- en: Inside that, we have a `<body>` tag. This tag is also optional, but it will
    make styling easier down the road.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we've got a title inside an `<h1>` tag. The *H* here stands for heading,
    and tags `<h1>` through `<h6>` indicate section headings from the outermost to
    the innermost. This tag will be rendered in a larger and bolder font, indicating
    that it is the title of the section.
  prefs: []
  type: TYPE_NORMAL
- en: Following the heading, we have an `<hr>` tag to add a horizontal line. By default,
    `<hr>` produces a single-pixel-thick black line, but that can be customized using
    style sheets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add the following regular text content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `<p>` tag, or paragraph tag, indicates a block of text. It is not strictly
    necessary to enclose text content in paragraph tags, but understand that HTML
    does not respect new lines by default. If you want to get distinct paragraphs
    separated by line breaks, you need to enclose them in paragraph tags. (You can
    also insert `<br>` tags, but the paragraph tag is considered a cleaner approach
    as it is more semantic.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, add the first child heading, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Any child section under `<h1>` should be `<h2>`; any child section inside `<h2>`
    should be `<h3>`, and so on. Heading tags are examples of semantic tags, and indicate
    the level of the document hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: Never select heading levels based on the appearance they produce—for example,
    don't use `<h4>` under `<h1>` just because you want smaller header text. Use them
    semantically and adjust the look using styles (see the *Fonts, colors, images,
    and styles*, sectionfor more information).
  prefs: []
  type: TYPE_NORMAL
- en: Typography tags
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Qt rich text supports many tags for altering the basic appearance of the text,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we''ve used the following tags:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Tag | Result |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `<i>` | *Italic* |'
  prefs: []
  type: TYPE_TB
- en: '| `<b>` | **Bold** |'
  prefs: []
  type: TYPE_TB
- en: '| `<u>` | Underlined |'
  prefs: []
  type: TYPE_TB
- en: '| `<s>` | Strikethrough |'
  prefs: []
  type: TYPE_TB
- en: 'These are cosmetic tags, and each of them alters the appearance of the text
    inside the tag as indicated. In addition to these tags, some lesser-used tags
    for the sizing and position of text are supported, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we can see the `<sup>` and `<sub>` tags, which provide
    superscript and subscript text, respectively, and the `<big>` and `<small>` tags,
    which provide slightly bigger or smaller fonts.
  prefs: []
  type: TYPE_NORMAL
- en: Hyperlinks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Hyperlinks can also be added to Qt rich text using the `<a>` (anchor) tag,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The exact behavior of hyperlinks varies according to the widget displaying the
    hyperlink and the settings of the widget.
  prefs: []
  type: TYPE_NORMAL
- en: The QTextBrowser by default will attempt to navigate to a hyperlink within the
    widget; keep in mind, however, that these links will only work if they are resource
    URLs or local file paths. `QTextBrowser` lacks a network stack and cannot be used
    to browse the internet.
  prefs: []
  type: TYPE_NORMAL
- en: 'It can, however, be configured to open URLs in an external browser; back in
    the Python script, add the following line of code to `MainWindow.__init__()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This utilizes `QDesktopServices.openUrl()` to open the anchor's `href` value
    in the desktop's default browser. You should configure this setting whenever you
    want to support external hyperlinks in a document.
  prefs: []
  type: TYPE_NORMAL
- en: External hyperlinks can also be configured on `QLabel` widgets, but not within
    a `QTextEdit` widget.
  prefs: []
  type: TYPE_NORMAL
- en: 'Documents can also use hyperlinks for navigating within a document itself,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Here, we've added an anchor pointing to `#Features` (with a pound sign), followed
    by a number of breaks to simulate more content. When a user clicks the link, it
    will scroll the browser widget to the anchor tag with a `name` (not `href`) attribute
    of `Features` (without the pound sign).
  prefs: []
  type: TYPE_NORMAL
- en: This feature can be useful for doing things such as providing a navigable table
    of contents.
  prefs: []
  type: TYPE_NORMAL
- en: Lists and tables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lists and tables are very useful for presenting orderly information in a way
    that users can quickly parse.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of a list is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Lists in Qt rich text can be of the ordered or unordered variety. In the preceding
    example, we have an unordered list (`<ul>`). The optional `type` attribute allows
    you to specify what kind of bullets should be used. In this case, we've chosen
    `square`; other options for unordered lists include `circle` and `disc`.
  prefs: []
  type: TYPE_NORMAL
- en: Each item in a list is specified using the `<li>` (list item) tag. We can also
    nest a list inside a list item to make a sublist. In this case, we've added an
    ordered list, which will use sequential numbers to indicate new items. Ordered
    lists also accept the `type` attribute; valid values are `a` (lower case letters),
    `A` (upper case letters), or `1` (sequential numbers).
  prefs: []
  type: TYPE_NORMAL
- en: '`&gt;` in the last bullet item is an example of an HTML entity. These are special
    codes that are used to display HTML special characters such as angle brackets,
    or non-ASCII characters, such as the copyright symbol. Entities start with an
    ampersand and end with a colon and contain a string indicating the character to
    display. The `gt`, in this case, stands for *greater than*. An official list of
    entities can be found at [https://dev.w3.org/html5/html-author/charref](https://dev.w3.org/html5/html-author/charref),
    though not all may be supported by `QTextDocument`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating HTML tables is somewhat more involved, as it requires many levels
    of nesting. The hierarchy for table tags is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The table itself is defined by a `<table>` tag
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The heading portion of the table is defined by the `<thead>` tag
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each row of the table (header or data) is defined by a `<tr>` (table row) tag
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Within each row, table cells are defined by either a `<th>` (table heading)
    tag or a `<td>` (table data) tag
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s start a table with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we've started with the opening `<table>` tag. The
    `border` attribute specifies a width for the table border in pixels; in this case,
    we want a two-pixel border. Keep in mind that this border goes around each cell
    and does not collapse (that is, merge with an adjacent cell's border), so in actuality,
    we'll have a four-pixel border between each cell. Table borders can have different
    styles; by default, the *ridge* style is used, so this border will be shaded to
    look slightly three-dimensional.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `<thead>` section, there is a table row filled with table heading
    cells. By setting the `bgcolor` attribute of the row, we can change the background
    color of all the header cells to grey.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s add some data rows with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the rows contain `<td>` cells for the actual table
    data. Note that we can use the `rowspan` and `colspan` attributes on individual
    cells to make them take up additional rows and columns, and the `bgcolor` attribute
    can also be applied to individual cells.
  prefs: []
  type: TYPE_NORMAL
- en: It's possible to wrap the data rows in a `<tbody>` tag to differentiate it from
    the `<thead>` section, but this doesn't actually have any useful impact in Qt
    rich text HTML.
  prefs: []
  type: TYPE_NORMAL
- en: Fonts, colors, images, and styles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Rich text fonts can be set using the `<font>` tag, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '`<font>` may be unfamiliar to those who have learned more modern HTML, as it
    was deprecated in HTML 5\. As you can see, though, it can be used to set the `face`,
    `size`, and `color` attributes of the text enclosed in the tags.'
  prefs: []
  type: TYPE_NORMAL
- en: The `<tt>` (typewriter type) tag is shorthand for using mono-spaced fonts and
    is useful for presenting things like inline code, keyboard shortcuts, and terminal
    output.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you prefer to use more modern CSS-style font configuration, this can be
    done by setting the `style` attribute on a block-level tag like `<div>`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Within the `style` attribute, you can set any of the supported CSS values to
    be applied to that block.
  prefs: []
  type: TYPE_NORMAL
- en: Document-wide styles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Qt rich text documents do *not* support HTML `<style>` tags or `<link>` tags
    for setting a document-wide style sheet. Instead, you can use the `setDefaultStyleSheet()`
    method of the `QTextDocument` object to set a CSS style sheet that will be applied
    to all viewed documents.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back in `MainWindow.__init__()`, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Note, however, that this must be added *before* the HTML is inserted into the
    widget. The `defaultStyleSheet` method is only applied to newly inserted HTML.
  prefs: []
  type: TYPE_NORMAL
- en: Also note that certain aspects of the appearance are not properties of the document,
    but of the widget. Notably, the background color of the document cannot be set
    by altering the body's styles.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, set the widget''s style sheet, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Keep in mind that the widget's style sheet uses QSS, whereas the document's
    style sheet uses CSS. The difference is minimal, but could come into play in certain
    situations.
  prefs: []
  type: TYPE_NORMAL
- en: Images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An image can be inserted using the `<img>` tag, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `src` attribute should be a file or resource path to an image file supported
    by Qt (see [Chapter 6](c3eb2567-0e73-4c37-9a9e-a0e2311e106c.xhtml), *Styling Qt
    Applications*, for more information about image format support). The `width` and
    `height` attributes can be used to force a certain size.
  prefs: []
  type: TYPE_NORMAL
- en: Differences between Qt rich text and Web HTML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have any experience in web design or development, you have no doubt already
    noted several differences between Qt's rich text markup and the HTML used in modern
    web browsers. It's important to keep these in mind as you create rich text, so
    let's go over the main differences.
  prefs: []
  type: TYPE_NORMAL
- en: First, Qt rich text is based on HTML 4 and CSS 2.1; as you have seen, it includes
    some deprecated tags, such as `<font>`, and excludes many of the more modern tags,
    such as `<section>` or `<figure>`.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, Qt rich text is based on only a subset of those specifications,
    so it lacks support for many tags. For example, there are no input- or form-related
    tags, such as `<select>` or `<textarea>`.
  prefs: []
  type: TYPE_NORMAL
- en: '`QTextDocument` is also less forgiving than most web browser renderers when
    it comes to syntax errors and case. For example, when setting a default style
    sheet, the case of the tag name needs to match the case used in the document,
    or the style won''t apply. In addition, failing to use block-level tags (such
    as `<p>`, `<div>`, and so on) around content can lead to unpredictable results.'
  prefs: []
  type: TYPE_NORMAL
- en: In short, it's best not to think of Qt rich text markup as true HTML, but rather
    as a similar but separate markup language. If you have any questions about whether
    a particular tag or style directive is supported, consult the support reference
    at [https://doc.qt.io/qt-5/richtext-html-subset.html](https://doc.qt.io/qt-5/richtext-html-subset.html).
  prefs: []
  type: TYPE_NORMAL
- en: Manipulating rich text using QTextDocument
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to allowing us to specify rich text in markup, Qt provides us with
    an API to create and manipulate rich text programmatically. This API is called
    the **Qt Scribe Framework**, and it's built around the `QTextDocument` and `QTextCursor`
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate how to create a document using the `QTextDocument` and `QTextCursor`
    classes, we're going to build a simple invoice generator application. Our application
    will take data from a widget form and use it to generate a rich text document
    programmatically.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the invoice application GUI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Get a fresh copy of our PyQt application template and call it `invoice_maker.py`.
    We'll begin our application by creating the GUI elements, and then develop the
    method that will actually build the document.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start your script with a data entry form class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Like with most of the forms we've created, this class is based on `QWidget`
    and starts by defining a `submitted` signal to carry a dictionary of the form's
    values. Here, we have also added various inputs to `QFormLayout` to enter basic
    invoice data such as customer name, customer address, and invoice date.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we''ll add `QTableWidget` for entering the invoice''s line items, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Each row of this table widget contains a description of the task, the rate for
    the work, and the number of hours worked. Because the values in the last two columns
    are numbers, we're using the table widget's `setCellWidget()` method to replace
    the default `QLineEdit` widgets in those cells with `QSpinBox` widgets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we''ll add a `submit` button with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The `submit` button calls an `on_submit()` method, which starts as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This method is simply going to extract the values that are entered into the
    form, make a few calculations, and emit the resulting data `dict` with the `submitted`
    signal. Here, we started by grabbing the values from each of the form's input
    widgets into a Python dictionary using the appropriate method for each widget.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to retrieve the line items'' data, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: For each row in the table widget that has a description, we're going to retrieve
    all the data, calculate a total cost by multiplying the rate and hours, and append
    all the data to the list in our `data` dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we''ll calculate a grand total cost and append that with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: After summing the cost in each line, we will add it to the data dictionary and
    emit our `submitted` signal with the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'This takes care of our `form` class, so let''s set up the main application
    layout in `MainWindow`. Down in `MainWindow.__init__()`, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The main widget is given a horizontal layout to contain the form and the view
    widget for the formatted invoice. We then connect the form's `submitted` signal
    to a `build_invoice()` method, which we will create on the view object.
  prefs: []
  type: TYPE_NORMAL
- en: This is the main GUI and logic for the application; now all that's left to do
    is create our `InvoiceView` class.
  prefs: []
  type: TYPE_NORMAL
- en: Building InvoiceView
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `InvoiceView` class is where all the hard work takes place; we will base
    it on a read-only `QTextEdit` widget, and it will contain a `build_invoice()`
    method that, when called with a dictionary of data, will construct a formatted
    invoice document using the Qt Scribe framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the constructor, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: To begin, we've defined class variables for the document's width and height.
    We've chosen these values to give us the aspect ratio of a standard US letter-sized
    document at a reasonable size for the average computer monitor. Inside the constructor,
    we use the calculated value to set a fixed size for the widget. This is all we
    need to do in the constructor, so it's now time to get to the real work—building
    a document.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s begin with `build_invoice()`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the preceding example, the method starts by creating a fresh
    `QTextDocument` object and assigning it to the view's `document` property. Then,
    the `pageSize` property is set using the document dimensions calculated in the
    class definition. Note that our QTextEdit-based view already has a `document`
    object that we could retrieve, but we're creating a fresh object so that the method
    will start with an empty document each time it is called.
  prefs: []
  type: TYPE_NORMAL
- en: Editing documents with `QTextDocument` may feel a bit backward from the way
    we have been creating GUI forms, where we typically create objects, and then configure
    and place them on the layout.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, the `QTextDocument` workflow is more like a word processor:'
  prefs: []
  type: TYPE_NORMAL
- en: There is a `cursor` that always points to some location in the document
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is an active text style, paragraph style, or another block-level style
    whose settings will be applied to whatever is entered
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To add content, users start by positioning the cursor, configuring the styles,
    and finally creating the content
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, clearly, the first step is to get a reference to the cursor; do this with
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The `QTextCursor` object is the tool that we use to insert content, and it has
    many methods for inserting different types of elements into the document.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, at this point, we could just start inserting text content, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: However, before we start writing content to our document, we should build a
    basic document framework to work within. To do this, we need to understand how
    `QTextDocument` objects are structured.
  prefs: []
  type: TYPE_NORMAL
- en: The QTextDocument structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Just like an HTML document, a `QTextDocument` object is a hierarchical structure.
    It is made up of **frames**, **blocks**, and **fragments**, which are defined
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A frame is represented by the `QTextFrame` object, and is a rectangular region
    of a document that can contain any type of content, including other frames. At
    the top of our hierarchy is the **root frame**, which contains all the document's
    contents.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A block, represented by the `QTextBlock` object, is a region of text surrounded
    by line breaks, such as a paragraph or a list item.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A fragment, represented by the `QTextFragment` object, is a contiguous region
    of text inside a block that shares a common text formatting. For example, if you
    have a sentence containing a word in bold, that represents three text fragments:
    the sentence before the bold word, the bold word, and the sentence after the bold
    word.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other items, such as tables, lists, and images, are subclassed from one of these
    preceding classes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We''re going to organize our document by inserting a set of sub-frames under
    the root frame so that we can easily navigate to the section of the document we
    want to work on. Our document will have the following four frames:'
  prefs: []
  type: TYPE_NORMAL
- en: The **logo frame** will contain the company logo and contact information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **customer address frame** will hold the customer name and address
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **terms frame** will hold a list of the invoice terms and conditions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **line items frame** will hold a table of the line-items and totals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s create some text frames to outline the structure of our document. We''ll
    start by saving a reference to the root frame so that we can easily return to
    it after creating a sub-frame, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have that, we can retrieve a cursor position for the end of the
    root frame at any point by calling the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The cursor's `setPosition()` method places our cursor at any given position,
    and the root frame's `lastPosition()` method retrieves the position at the end
    of the root frame.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s define the first sub-frame, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: A frame must be created with a `QTextFrameFormat` object defining its format,
    so before we can write the frame, we have to define our formatting. Unfortunately,
    the frame format's properties cannot be set using keyword arguments, so we must
    configure it using setter methods instead. In this example, we've set a two-pixel
    border around the frame, as well as ten pixels of padding.
  prefs: []
  type: TYPE_NORMAL
- en: Once the format object is created, we call the cursor's `insertFrame()` method
    to create a new frame with our configured format.
  prefs: []
  type: TYPE_NORMAL
- en: '`insertFrame()` returns the `QTextFrame` object created, and also positions
    our document''s cursor inside the new frame. Since we aren''t ready to add content
    to this frame, and we don''t want to create the next frame inside of it, we need
    to return to the root frame before creating the next frame by using the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we're using the frame format to set the width of this
    frame to one-third of the width of the document and to make it float to the right.
    *Floating* a document frame means that it will be pushed to one side of the document
    and other content will flow around it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we''ll add the terms frame, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This time, we're going to make the frame half of the document's width and float
    it to the left.
  prefs: []
  type: TYPE_NORMAL
- en: In theory, these two frames should be next to each other. In practice, due to
    a quirk in the `QTextDocument` class' rendering, the top of the second frame will
    be a line below the top of the first one. This is OK for our demo, but if you
    need actual columns, use a table instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s add the frame to hold our line items table, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Once again, we've moved the cursor back to the root frame and inserted a new
    frame. This time, the format adds a margin of 25 pixels to the frame.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we don't have to do any special configuration of the `QTextFrameFormat`
    objects if we don't want to, but we *do* have to create one for each frame, and
    we *do* need to set up any configuration on them *before* creating the new frame.
    Note that it's also possible to reuse frame formats if you have many frames with
    the same configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Character formats
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just like frames must be created with a frame format, text content must be created
    with a **character format**, which defines properties such as the font and alignment
    of the text. Before we start adding content to our frames, we should define some
    common character formats to use for different parts of the document.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is done using the `QTextCharFormat` class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we''ve created the following three formats:'
  prefs: []
  type: TYPE_NORMAL
- en: '`std_format`, which will be used for regular text. We aren''t changing anything
    from the default settings.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`logo_format`, which will be used for our company logo. We''re customizing
    its font and adding an underline, as well as setting its vertical alignment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`label_format`, which will be used for labels; they will be in 12-point font
    and bold.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that `QTextCharFormat` allows you to make many font configurations directly
    using setter methods, or you can even configure a `QFont` object to assign to
    the format. We'll use these three formats when we add our text content for the
    remainder of the document.
  prefs: []
  type: TYPE_NORMAL
- en: Adding basic content
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s add some basic content to our `logo_frame` with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like we called the root frame''s `lastPosition` method to get the position
    at its end, we can call the logo frame''s `firstPosition()` method to get the
    position at the beginning of the frame. Once there, we can insert content, such
    as a logo image, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Images can be inserted just like this—by passing a path to the image as a string.
    However, this method offers little in the way of configuration, so let''s try
    a slightly more involved approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: By using a `QTextImageFormat` object, we can configure various aspects of the
    image first, such as its height and width, then add it along with an enum constant
    specifying its positioning policy. In this case, `FloatLeft` will cause the image
    to align to the left of the frame, and subsequent text will wrap around it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s write the following text in the block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Using our `logo_format`, we have written a text fragment containing the company
    name and then inserted a new block so, we can add another fragment containing
    the address on another line. Note that passing a character format is optional;
    if we don't do it, the fragment will be inserted with the currently active format,
    just as it is in a word processor.
  prefs: []
  type: TYPE_NORMAL
- en: 'That takes care of our logo, so now let''s deal with the customer address block,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Text blocks can have formats just like frames and characters. Let''s create
    a text block format to use with our customer address using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Text block formats allow you to change the sort of settings you''d change in
    a paragraph of text: margins, line heights, indents, and alignment. Here, we''ve
    set the text alignment to the right-aligned, a right margin of 25 pixels, and
    the line-height to 1.5 lines. There are multiple ways to specify the height in
    `QTextDocument`, and the second argument to `setLineHeight()` determines how the
    value passed in will be interpreted. In this case, we''re using the `ProportionalHeight`
    mode, which interprets the value as a percentage of the line-height.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can pass our block format object to any `insertBlock` call, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Each time we insert a block, it's like starting a new paragraph. Our multi-line
    address string will be inserted as one paragraph, but note that it will still
    be spaced to 1.5 lines.
  prefs: []
  type: TYPE_NORMAL
- en: Inserting a list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our invoice terms will be presented as an unordered bullet list. Ordered and
    unordered lists can be inserted into `QTextDocument` using the cursor''s `insertList()`
    method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The argument for `insertList()` can be either a `QTextListFormat` object or
    a constant from the `QTextListFormat.Style` enum. In this case, we're using the
    latter, specifying that we want a list with disc-style bullets.
  prefs: []
  type: TYPE_NORMAL
- en: Other options for list formats include `ListCircle` and `ListSquare` for unordered
    lists, and `ListDecimal`, `ListLowerAlpha`, `ListUpperAlpha`, `ListUpperRoman`,
    and `ListLowerRoman` for ordered lists.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we''ll define some items to insert into our list, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we''re using markup in the preceding example, rather than raw strings.
    You can still use markup when creating a document with `QTextCursor`; however,
    you''ll need to tell the cursor it''s inserting HTML rather than plain text by
    calling `insertHtml()` rather than `insertText()`, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: After calling `insertList()`, our cursor is positioned inside the first list
    item, so we now need to call `insertBlock()` to get to subsequent items (we don't
    want to do this for the first item, since we're already in a bullet point, hence
    the `if i > 0` check).
  prefs: []
  type: TYPE_NORMAL
- en: Unlike `insertText()`, `insertHtml()` does not accept a character format object.
    You have to rely on your markup to determine the formatting.
  prefs: []
  type: TYPE_NORMAL
- en: Inserting a table
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last thing we're going to insert in our invoice is a table containing our
    line items. `QTextTable` is a subclass of `QTextFrame`, and just like a frame,
    we'll need to create a format object for it before we can create the table itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'The class we need is the `QTextTableFormat` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Here, we've configured the `headerRowCount` property, which indicates that the
    first row is a header row and should be repeated at the top of each page. This
    is equivalent to putting the first row in a `<thead>` tag in markup.
  prefs: []
  type: TYPE_NORMAL
- en: We're also setting the width, but instead of using pixel values, we're making
    use of a `QTextLength` object. This class is somewhat confusingly named because
    it doesn't refer specifically to the length of text, but rather to any generic
    length you might need in `QTextDocument`. `QTextLength` objects can be of the
    percentage, fixed, or variable type; in this case, we're specifying `PercentageLength`
    with a value of `100`, or 100%.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s insert our table with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: When inserting a table into `QTextDocument`, we not only need to define a format,
    but also a number of rows and columns. To do that, we've created a tuple of the
    headers, then calculated the rows and columns by taking the length of the line
    item list (adding 1 for the header row), and the length of the headers tuple.
  prefs: []
  type: TYPE_NORMAL
- en: We then need to position the cursor in the line items frame and insert our table.
    Just like other insert methods, `insertTable()` positions our cursor inside the
    inserted item, in the first column of the first row.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now insert our heading row with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Up to this point, we've been positioning the cursor by passing an exact position
    to `setPosition()`. `QTextCursor` objects also have a `movePosition()` method
    which can take a constant from the `QTextCursor.MoveOperation` enum. This enum
    defines constants representing about two dozen different cursor movements, such
    as `StartOfLine`, `PreviousBlock`, and `NextWord`. In this case, the `NextCell`
    movement takes us to the next cell in a table.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the same idea to insert our data, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we're iterating every column of every row in the data list and
    using `insertText()` to add the data to the cell. If the column number is `1`
    or `3`, that is, a monetary value, we need to add a currency symbol to the display.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to add one more row to hold the grand total for the invoice. To
    add an extra row in our table, we can use the following `QTextTable.appendRows()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'To position our cursor into a particular cell in the new row, we can use the
    table object''s `cellAt()` method to retrieve a `QTableCell` object, then use
    that object''s `lastCursorPosition()` method, which returns a new cursor positioned
    at the end of the cell, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: That's the last bit of content we need to write to the invoice document, so
    let's go ahead and test it out.
  prefs: []
  type: TYPE_NORMAL
- en: Finishing and testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, if you run your application, fill in the fields, and hit Create Invoice,
    you should see something like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/79fad3bf-5ad0-4208-a822-82277ebe1785.png)'
  prefs: []
  type: TYPE_IMG
- en: Looking good! Of course, that invoice won't do us much good if we can't print
    or export it. So, in the next section, we'll look at how to handle the printing
    of documents.
  prefs: []
  type: TYPE_NORMAL
- en: Printing rich text
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nothing strikes terror into the hearts of programmers like being asked to implement
    printer support. The act of turning pristine digital bits into ink on paper is
    messy in real life and can be just as messy in the software world. Fortunately,
    Qt provides the `QtPrintSupport` module, a cross-platform print system that can
    easily turn `QTextDocument` into hard-copy format, no matter what OS we're using.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the Invoice app for print support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Readers outside the United States almost certainly groaned when we hard-coded
    the dimensions of our document to 8.5×11, but never fear—we're going to make some
    changes that will allow us to set the size based on a user's selection of document
    sizes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `InvoiceView` class, create the following new method, `set_page_size()`,
    to set the page size:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: This method will receive a `QRect` object, from which it will extract width
    and height values to update the document's settings, the widget's fixed size,
    and the document's page size.
  prefs: []
  type: TYPE_NORMAL
- en: 'Down in `MainWindow.__init__()`, add a toolbar to control printing and set
    up the following actions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: We'll implement each of these callbacks as we walk through how to set up each
    aspect of the print process.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the printer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Printing begins with a `QtPrintSupport.QPrinter` object, which represents a
    printed document in memory. The basic workflow of printing in PyQt is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `QPrinter` object
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure the `QPrinter` object using its methods or printer configuration dialogs
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Print `QTextDocument` to the `QPrinter` object
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pass the `QPrinter` object to the operating system's print dialog, from which
    the user can print using a physical printer
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `MainWindow.__init__()`, let''s create our `QPrinter` object, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Once the printer is created, we can configure a wide number of properties; here,
    we've simply set the orientation and page size (to the US letter defaults, once
    again, but feel free to change this to your preferred paper size).
  prefs: []
  type: TYPE_NORMAL
- en: 'Anything you can configure in a printer settings dialog can be configured via
    the `QPrinter` method, but ideally, we''d rather let the user make these decisions.
    So, let''s implement the following `printer_config()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: The `QPageSetupDialog` object is a `QDialog` subclass that presents all the
    options that are available for the `QPrinter` object. We pass into it our `QPrinter`
    object, which causes any changes that have been made in the dialog to be applied
    to that printer object. On Windows and macOS, Qt will use the OS-provided print
    dialogs by default; on other platforms, a Qt-specific dialog will be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the user can configure paper size, we need to allow the page size
    used by `InvoiceView` to reset after each change. So, let''s add the following
    method to `MainWindow`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: The `QPrinter.pageRect()` method extracts a `QRect` object, defining the configured
    page size. Since our `InvoiceView.set_page_size()` method accepts a `QRect`, we
    just need to pass this object along to it.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we've passed a constant into `pageRect()`, indicating that we want
    the size in **points**. A pointis 1/72 of an inch, so our widget size will be
    72 × the physical page size in inches. You can request the page rectangle in a
    variety of units (including millimeters, picas, inches, and so on) if you want
    to do your own calculations to scale the widget's size.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, the `QPrinter` object is not a `QObject` descendant, so that
    we cannot use signals to determine when its parameters were changed.
  prefs: []
  type: TYPE_NORMAL
- en: Now, add a call to `self._update_preview_size()` to the end of `printer_config()`,
    so that it will be called whenever the user configures the page. You'll find that
    if you change the size of the paper in the printer configuration dialog, your
    preview widget will resize accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Printing a page
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we can physically print a document, we have to first print `QTextDocument`
    to the `QPrinter` object. This is done by passing the printer object to the document's
    `print()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll create the following method to do that for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Note that this doesn't actually cause your printing device to start putting
    ink on the page – it just loads the document into the `QPrinter` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'To actually print it to paper, a printer dialog is needed; so, add the following
    method to `MainView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: In this method, we first call our internal method to load the document into
    the `QPrinter` object, then pass the object to a `QPrintDialog` object, which
    we execute by calling its `exec()` method. This will display the printing dialog,
    which the user can then use to send the document off to a physical printer.
  prefs: []
  type: TYPE_NORMAL
- en: If you don't need the printing dialog to block program execution, you can call
    its `open()` method instead. We're blocking in the preceding example so we can
    perform actions once the dialog is closed.
  prefs: []
  type: TYPE_NORMAL
- en: After the dialog has closed, we call `_update_preview_size()` to grab the new
    paper size and update our widget and document. In theory, we could connect the
    dialog's `accepted` signal to that method, but in practice, there are some race
    conditions that may cause this to fail.
  prefs: []
  type: TYPE_NORMAL
- en: Print previewing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Nobody likes to waste paper by printing something that isn''t right, so we
    should add a `print_preview` function. `QPrintPreviewDialog` exists for this purpose
    and works very much like other printing dialogs, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Once again, we just need to pass the printer object to the dialog's constructor
    and call `exec()`. We also need to connect the dialog's `paintRequested` signal
    to a slot that will update the document in `QPrinter` so that the dialog can make
    sure the preview is up to date. Here, we've connected it to our `_print_document()`
    method, which does exactly what is required.
  prefs: []
  type: TYPE_NORMAL
- en: Exporting to PDF
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this paperless digital age, the PDF file has replaced the hard copy for many
    purposes, so an easy export to PDF function is always a good thing to add. `QPrinter`
    can do this for us easily.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following `export_pdf()` method to `MainView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Here, we're going to start by asking the user for a filename. If they provide
    one, we'll configure our `QPrinter` object with the filename, set the output format
    to `PdfFormat`, and then print the document. When writing to a file, `QTextDocument.print()`
    will take care of writing the data and saving the file for us, so we don't need
    to do anything else here.
  prefs: []
  type: TYPE_NORMAL
- en: That covers all your printing needs for the invoice program! Take some time
    to test this functionality and see how it works with your printers.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you mastered working with rich text documents in PyQt5\. You
    learned how to use Qt's HTML subset to add rich text formatting in the `QLabel`, `QTextEdit`,
    and `QTextBrowser` widgets. You worked through constructing a QTextDocument programmatically
    using the `QTextCursor` interface. Finally, you learned how to bring your `QTextDocument`
    objects into the real world using Qt's printing support module.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](1a25e80a-2680-47f4-b309-782cf9b8580f.xhtml), *Creating 2D Graphics
    with QPainter*, you'll learn some advanced concepts of two-dimensional graphics.
    You'll learn to work with `QPainter` objects to create graphics, build custom
    widgets, and create an animation.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Try these questions to test your knowledge from this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following HTML isn''t displaying as you''d hoped. Find as many errors as
    you can:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: What is wrong with the following Qt HTML snippets?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: This snippet is supposed to implement a table of contents. Why doesn't it work
    correctly?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Using `QTextCursor`, add a sidebar to the right-hand side of your document.
    Explain how you would go about this.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You are trying to create a document with `QTextCursor`. It should have a top
    and bottom frame; in the top frame, there should be a title, and in the bottom
    frame, an unordered list. Correct the following code so that it does that:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: You're creating your own `QPrinter` subclass to add a signal when the page size
    changes. Will the following code work?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '`QtPrintSupport` contains a class called `QPrinterInfo`. Using this class,
    print a list of the names, makes, models, and default page sizes of all of the
    printers on your system.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For further information, please refer to the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: Qt's overview of the Scribe framework can be found at [https://doc.qt.io/qt-5/richtext.html](https://doc.qt.io/qt-5/richtext.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advanced document layouts can be defined using the `QAbstractTextDocumentLayout`
    and `QTextLine` classes; information about how to use these classes can be found
    at [https://doc.qt.io/qt-5/richtext-layouts.html](https://doc.qt.io/qt-5/richtext-layouts.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An overview of Qt's printing system can be found at [https://doc.qt.io/qt-5/qtprintsupport-index.html](https://doc.qt.io/qt-5/qtprintsupport-index.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
