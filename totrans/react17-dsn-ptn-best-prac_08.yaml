- en: Managing Data
  prefs: []
  type: TYPE_NORMAL
- en: '**Proper data fetching** goes through some of the most common patterns to make
    a child and parent communicate using callbacks. We''ll learn how we can use a
    common parent to share data across components that are not directly connected.
    We will then start learning about the new React Context API and React Suspense.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: React Context API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to consume a context with useContext
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use React Suspense with SWR
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To complete this chapter, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Node.js 12+
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visual Studio Code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can find the code for this chapter in the book''s GitHub repository: [https://github.com/PacktPublishing/React-17-Design-Patterns-and-Best-Practices-Third-Edition/tree/main/Chapter06](https://github.com/PacktPublishing/React-17-Design-Patterns-and-Best-Practices-Third-Edition/tree/main/Chapter06).'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the React Context API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The React Context API has been officially added since version 16.3.0; before
    it was just experimental. The new Context API is a game-changer. A lot of people
    are moving away from Redux in order to use the new Context API. Context provides
    a way to share data between components without passing a prop to all the child
    components.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see a basic example where we can use the new Context API. We will do the
    same example we did in *Chapter 3, React Hooks*, where we fetched some GitHub
    issues, but now using the Context API.
  prefs: []
  type: TYPE_NORMAL
- en: Creating our first context
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first thing you need to do is to create the issue context. For this, you
    can create a folder called `contexts` inside your `src` folder and then inside
    that, add the `Issue.tsx`  file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, you need to import some functions from React and `axios`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, it is clear that you should install `axios`. If you still don''t
    have it, just do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we need to declare our interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The first thing we need to do after this is to create our context by using
    the `createContext` function and define the value we want to export:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have `IssueContext`, we need to create a component where we can receive
    props, set some states, and perform the fetch by using `useEffect`, and then we
    render `IssueContext.Provider` where we specify the context (value) we will export:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As you know, every time you want to use a function inside the `useEffect` Hook,
    you need to wrap your function with the `useCallback` Hook. A good practice if
    you want to use `async/await` is to have it in a separate function and not directly
    in `useEffect`.
  prefs: []
  type: TYPE_NORMAL
- en: Once we perform the fetch and get the data in our `issues` state, then we add
    all the values we want to export as context, then when we render `IssueContext.Provider`,
    we pass the context on the `value` prop, and finally, we render the children of
    the component.
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping our components with the provider
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The way you consume a context is divided into two parts. The first one is where
    you wrap your app with your context provider, so this code can be added to `App.tsx`
    (normally all the providers are defined in parent components).
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that here we are importing the `IssueProvider` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As you can see we are wrapping the `Issues` component with `IssueProvider`,
    which means inside the `Issues` component we can consume our context and get the
    issues value.
  prefs: []
  type: TYPE_NORMAL
- en: Many people get confused with this sometimes. If you forget to wrap your components
    with the provider, then you can't consume your context inside your components,
    and the hard part is that you probably won't get any error; you will just get
    some undefined data, which makes this hard to identify.
  prefs: []
  type: TYPE_NORMAL
- en: Consuming context with useContext
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you've already placed `IssueProvider` in `App.tsx`, now you can consume your
    context in your `Issues` component by using the `useContext` Hook.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that here we are importing the `IssueContext` context (between `{ }`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If you did everything correctly, you should be able to see the issues list:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/6edba673-ea96-4588-a2b8-d86791557dd5.png)'
  prefs: []
  type: TYPE_IMG
- en: The Context API is super useful when you want to separate your application from
    your data and do all the fetching in there. Of course, there are multiple uses
    for the Context API, which can also  be used for theming or to pass functions;
    it all depends on your application.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we are going to learn how to implement React Suspense using
    the SWR  library.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing React Suspense with SWR
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'React Suspense was introduced in React 16.6\. Right now (April 2021) this feature
    is still experimental and you should not use it in your production applications.
    Suspense lets you suspend component rendering until a condition is met. You can
    render a loading component or anything you want as a fallback of Suspense. Right
    now there are only two use cases for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Code splitting**: When you split your application and you''re waiting to
    download a chunk of your app when a user wants to access it'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data fetching**: When you''re fetching data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In both scenarios, you can render a fallback, which can normally be a loading
    spinner, some loading text, or even better, a placeholder skeleton.
  prefs: []
  type: TYPE_NORMAL
- en: '**WARNING**: The new React Suspense feature is still experimental so I recommend
    you do not use it on production because it is not yet available in a stable release.'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing SWR
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Stale-While-Revalidate** (**SWR**) is a React Hook for data fetching; it
    is an HTTP cache invalidation strategy. SWR is a strategy to first return the
    data from cache (stale), then send the fetch request (revalidate), and finally,
    return with up-to-date data, and was developed by Vercel, the company that created
    Next.js.'
  prefs: []
  type: TYPE_NORMAL
- en: Building a Pokedex!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I could not find a better example to explain React Suspense and SWR than building
    a Pokedex. We will use a public Pokemon API ([https://pokeapi.co](https://pokeapi.co));
    *gotta catch 'em all*!
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing you need to do is to install some packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: For this example, you will need to create the Pokemon directory at `src/components/Pokemon`.
    The first thing we need to do to work with SWR is to create a fetcher file where
    we will perform our requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'This file should be created at `src/components/Pokemon/fetcher.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: If you notice, we are returning an object with an error if the response is not
    successful. This is because sometimes we can get a 404 error from the API that
    can cause the app to break.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have created your fetcher, let''s modify `App.tsx` to configure `SWRConfig`
    and enable Suspense:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we need to wrap our `PokeContainer` component inside `SWRConfig`
    to be able to fetch the data. The `PokeContainer` component will be our parent
    component where we will add our first Suspense. This file exists at `src/components/Pokemon/PokeContainer.tsx`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we are defining a fallback for our first Suspense, which is
    just `Loading Pokedex...` text. You can render whatever you want in there, React
    components or plain text. Then, we have our `Pokedex` component inside Suspense.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s take a look at our `Pokedex` component where we are going to fetch
    data for the first time by using the `useSWR` Hook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we are fetching the first 150 Pokemon because I'm old school
    and those were the first generation. Right now I don't know how many Pokemon exist.
    Also, if you notice, we are grabbing the `results` variable that comes from the
    data (this is the actual response from the API). Then we map our results to render
    each Pokemon but we add a Suspense component to each one with a `<LoadingSkeleton
    />` fallback (`<StyledGrid />` has some CSS styles to make it look nicer), and
    finally, we pass `pokemonName` to our `<Pokemon>` component, and this is because
    the first fetch just brings us the name of the Pokemon but we need to do another
    fetch to bring the actual Pokemon data (name, types, power, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, finally, our Pokemon component will perform a specific fetch by the Pokemon
    name and will render the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Basically, in this component, we put together all the Pokemon data (`id`, `name`,
    `sprites`, and `types`) and we render the information. As you have seen, I''m
    using `styled` components, which are amazing, so if you want to know the styles
    I''m using for `Pokedex`, here is the `Pokemon.styled.ts` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, our `LoadingSkeleton` component should be like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This library is amazing. It lets you create skeleton placeholders to wait for
    the data. Of course, you can build as many forms as you want. You have probably  seen
    this effect on sites such as LinkedIn or YouTube.
  prefs: []
  type: TYPE_NORMAL
- en: Testing our React Suspense
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once you have all the pieces of the code working, there is a trick you can
    do in order to see all the Suspense fallbacks. Normally, if you have a high-speed
    connection, it is hard to see it, but you can slow down your connection to see
    how everything is being rendered. You can do this by selecting Slow 3G connection
    in your Network tab on your Chrome inspector:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/b8f1b87e-300c-4b20-a642-990ebc8d1fe0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once you set the Slow 3G preset and you run your project, the first fallback
    you will see is Loading Pokedex...:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/9060d4d4-09ec-4844-a3d7-421fcc9bb8ca.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, you will see the Pokemon fallbacks that are rendering `SkeletonLoading`
    for each Pokemon that is being loaded:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/6d0a18fd-d91a-4c09-89c4-4d6bffd52bde.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Normally those loaders have animation but you won''t see that in this book,
    of course! And then you will start seeing how the data is rendering and some images
    start appearing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/46590725-c067-4d2d-a269-8c48965e8361.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you wait until all the data has downloaded correctly, you should now  see
    the Pokedex with all the Pokemon:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/fb2507aa-63c4-4bbe-a64a-095ad5f08c09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Pretty nice, huh? But there is something else to mention; as I mentioned before,
    SWR will bring the data from the cache first and then will revalidate the data
    all the time to see whether there are new updates. This means that any time the
    data changes, SWR will perform another fetch to re-validate whether the old data
    is still valid or needs to be replaced by new ones. You can see this effect even
    if you move out from the Pokedex tab to another and then you come back. You''ll
    see that your Network terminal for the first time should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c9f97cee-179c-447a-8df8-9cf959726b63.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, we performed 151 initial requests  (1 for the Pokemon lists
    and 150 others, 1 for each Pokemon), but if you change the tab and you come back,
    you will see how SWR is  fetching again:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/f8cd8287-2369-430e-aaa3-906e1f4d0384.png)'
  prefs: []
  type: TYPE_IMG
- en: Now you can see that it is performing 302 requests (another 151). This is very
    useful when you have real-time data that you want to fetch every second or every
    minute.
  prefs: []
  type: TYPE_NORMAL
- en: Right now, React Suspense does not have a defined pattern of use, which means
    you can find different ways to use it and there are not yet some good practices
    defined for this. I found SWR is the easiest and most understandable way of playing
    with React Suspense and I think it is a very powerful library that can be used
    even without Suspense.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I really hope you enjoyed reading this chapter, which contains a lot of information
    about the React Context API and how to implement React Suspense with SWR.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to handle forms and animations.
  prefs: []
  type: TYPE_NORMAL
