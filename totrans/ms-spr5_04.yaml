- en: Evolution toward Microservices and Cloud-Native Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last decade, Spring Framework has evolved into the most popular framework
    to develop Java Enterprise applications. Spring Framework has made it easy to
    develop loosely coupled, testable applications. It has simplified the implementation
    of cross-cutting concerns.
  prefs: []
  type: TYPE_NORMAL
- en: The world today, however, is very different from a decade back. Over a period
    of time, applications grew into monoliths, which became difficult to manage. And
    because of this problems, new architectures started evolving. The buzzwords in
    the recent past have been RESTful services, microservices, and Cloud-Native applications.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will start with reviewing the problems Spring Framework
    solved in the last decade. We will look at the problems with **monolithic applications**
    and get introduced to the world of smaller, independently deployable components.
  prefs: []
  type: TYPE_NORMAL
- en: We will explore why the world is moving toward microservices and Cloud-Native
    applications. We will end the chapter by looking at how Spring Framework and Spring
    projects are evolving to solve today's problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Architecture of a typical Spring-based application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Problems solved by the Spring Framework in the last decade
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are our goals when we develop applications?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are the challenges with monolithic applications?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are microservices?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are the advantages of microservices?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are the challenges with microservices?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are the good practices that help in deploying microservices to the Cloud?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are the Spring projects that help us in developing microservices and Cloud-Native
    applications?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Typical web application architecture with Spring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spring has been the framework of choice to wire Java Enterprise applications
    during the last decade and half. Applications used a layered architecture with
    all cross-cutting concerns being managed using aspect-oriented programming. The
    following diagram shows a typical architecture for a web application developed
    with Spring:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/14f46f15-3f3d-47c6-b9da-b8094b076498.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The typical layers in such an application are listed here. We will list cross-cutting
    concerns as a separate layer, though in reality, they are applicable across all
    layers:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Web layer**: This is typically responsible for controlling the web application
    flow (controller and/or Front Controller) and rendering the view.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Business layer**: This is where all your business logic is written. Most
    applications have transaction management starting from the business layer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data layer**: It is also responsible for talking to the database. This is
    responsible for persisting/retrieving data in Java objects to the tables in the
    database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integration layer**: Applications talk to other applications, either over
    queues or by invoking web services. The integration layer establishes such connections
    with other applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cross-cutting concerns**: These are concerns across different layers--logging,
    security, transaction management, and so on. Since Spring IoC container manages
    the beans, it can weave these concerns around the beans through **Aspect-oriented
    programming** (**AOP**).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's discuss each of the layers and the frameworks used in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Web layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Web layer is dependent on how you would want to expose the business logic to
    the end user. Is it a web application? Or are you exposing RESTful web services?
  prefs: []
  type: TYPE_NORMAL
- en: Web application - rendering an HTML View
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: These web applications use a web MVC framework such as Spring MVC or Struts.
    The View can be rendered using JSP, JSF, or template-based frameworks such as
    Freemarker.
  prefs: []
  type: TYPE_NORMAL
- en: RESTful services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two typical approaches used to develop RESTful web services:'
  prefs: []
  type: TYPE_NORMAL
- en: '**JAX-RS**: The Java API for REST services. This is a standard from the Java
    EE specification. Jersey is the reference implementation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Spring MVC or Spring REST**: Restful services can also be developed with
    Spring MVC.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring MVC does not implement JAX-RS so, the choice is tricky. JAX-RS is a Java
    EE standard. But Spring MVC is more innovative and more likely to help you build
    new features faster.
  prefs: []
  type: TYPE_NORMAL
- en: Business layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The business layer typically contains all the business logic in an application.
    Spring Framework is used in this layer to wire beans together.
  prefs: []
  type: TYPE_NORMAL
- en: This is also the layer where the boundary of transaction management begins.
    Transaction management can be implemented using Spring AOP or AspectJ. A decade
    back, **Enterprise Java Beans** (**EJB**) were the most popular approach to implement
    your business layer. With its lightweight nature, Spring is now the framework
    of choice for the business layer.
  prefs: []
  type: TYPE_NORMAL
- en: EJB3 is much simpler than EJB2\. However, EJB3 is finding it difficult to recover
    the ground lost to Spring.
  prefs: []
  type: TYPE_NORMAL
- en: Data layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Most applications talk to a database. The data layer is responsible for storing
    data from your Java objects to your database and vice versa. The following are
    the most popular approaches to building data layers:'
  prefs: []
  type: TYPE_NORMAL
- en: '**JPA**: The **Java Persistence API** helps you to map Java objects (POJOs)
    to your database tables. Hibernate is the most popular implementation for JPA.
    JPA is typically preferred for all transactional applications. JPA is not the
    best choice for batch and reporting applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**MyBatis**: MyBatis (previously, iBatis) is a simple data-mapping framework.
    As its website ([http://www.mybatis.org/mybatis-3/](http://www.mybatis.org/mybatis-3/))
    says, *MyBatis is a first class persistence framework with support for custom
    SQL, stored procedures and advanced mappings. MyBatis eliminates almost all of
    the JDBC code and manual setting of parameters and retrieval of results*. MyBatis
    can be considered for batch and reporting applications where SQLs and stored procedures
    are more typically used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Spring JDBC**: JDBC and Spring JDBC are not that commonly used anymore.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will discuss in detail the advantages and disadvantages of JDBC, Spring JDBC,
    MyBatis and JPA in [Chapter 8](b134d136-6980-440f-980c-227e8a46e532.xhtml), *Spring
    Data*.
  prefs: []
  type: TYPE_NORMAL
- en: Integration layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The integration layer is typically where we talk to other applications. There
    might be other applications exposing SOAP or RESTful services over HTTP (the web)
    or MQ:'
  prefs: []
  type: TYPE_NORMAL
- en: Spring JMS is typically used to send or receive messages on queues or service
    buses.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring MVC RestTemplate can be used to invoke RESTful services.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring WS can be used to invoke SOAP-based web services.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Integration provides a higher level of abstraction for building enterprise
    integration solutions. It enables testability with a clear separation of concerns
    between the application and integration code. It supports all popular enterprise
    integration patterns. We will discuss more about Spring Integration in [Chapter
    10](e6e89939-cdb1-470b-a052-e4688e5bacb1.xhtml), *Spring Cloud Data Flow*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cross-cutting concerns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Cross-cutting concerns are concerns that are typically common to multiple layers
    of an application--logging, security, and transaction management, among others.
    Let''s quickly discuss some of these:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Logging**: Audit logging at multiple layers can be implemented using Aspect-Oriented
    Programming (Spring AOP or AspectJ).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security**: Security is typically implemented using the Spring Security framework.
    As discussed in the previous chapter, Spring Security makes the implementation
    of security very simple.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Transaction management**: Spring Framework provides a consistent abstraction
    for transaction management. More importantly, Spring Framework provides great
    support for declarative transaction management. The following are some of the
    transaction APIs that the Spring Framework supports:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Java Transaction API** (**JTA**) is a standard for transaction management.
    It is a part of Java EE's specifications.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JDBC.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JPA (including Hibernate).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Error handling**: Most abstractions provided by Spring use unchecked exceptions
    so unless required by business logic, it is sufficient to implement error handling
    in the layer that is exposed to the client (user or other application). Spring
    MVC provides Controller Advice to implement consistent error handling across the
    application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Spring Framework plays a major role in application architecture. Spring
    IoC is used to wire beans from different layers together. Spring AOP is used to
    weave cross-cutting concerns around the beans. Added to these is the fact that
    Spring provides great integration with frameworks in different layers.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will quickly review some of the important problems Spring
    has solved in the last decade or so.
  prefs: []
  type: TYPE_NORMAL
- en: Problems solved by Spring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spring is the framework of choice to wire Enterprise Java applications. It
    has solved a number of problems that Enterprise Java applications have faced since
    the complexity associated with EJB2\. A few of them are listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Loose coupling and testability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Plumbing code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lightweight architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Architectural flexibility
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simplified implementation of cross-cutting concerns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Best design patterns for free
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loose coupling and testability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Through dependency injection, Spring brings loose coupling between classes.
    While loose coupling is beneficial to application maintainability in the long
    run, the first benefits are realized with the testability that it brings in.
  prefs: []
  type: TYPE_NORMAL
- en: Testability was not a forte of Java EE (or J2EE, as it was called then) before
    Spring. The only way to test EJB2 applications was to run them in the container.
    Unit testing them was incredibly difficult.
  prefs: []
  type: TYPE_NORMAL
- en: That's exactly the problem Spring Framework set out to solve. As we saw in the
    earlier chapters, if objects are wired using Spring, writing unit tests becomes
    easier. We can easily stub or mock dependencies and wire them into objects.
  prefs: []
  type: TYPE_NORMAL
- en: Plumbing code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The developer of the late 1990s and early-to mid-2000s will be familiar with
    the amount of plumbing code that had to be written to execute a simple query through
    JDBC and populate the result into a Java object. You had to perform a **Java Naming
    and Directory** **Interface** (**JNDI**) lookup, get a connection, and populate
    the results. This resulted in duplicate code. Usually, problems were repeated
    with exception handling code in every method. And this problem is not limited
    to JDBC.
  prefs: []
  type: TYPE_NORMAL
- en: One of these problems Spring Framework solved was by eliminating all the plumbing
    code. With Spring JDBC, Spring JMS, and other abstractions, the developers could
    focus on writing business logic. Spring framework took care of the nitty-gritty.
  prefs: []
  type: TYPE_NORMAL
- en: Lightweight architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using EJBs made the applications complex, and not all applications needed that
    complexity. Spring provided a simplified, lightweight way of developing applications.
    If distribution was needed, it could be added later.
  prefs: []
  type: TYPE_NORMAL
- en: Architecture flexibility
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spring Framework is used to wire objects across an application in different
    layers. In spite of its ever-looming presence, Spring Framework did not restrict
    the flexibility or choice of frameworks that application architects and developers
    had. A couple of examples are listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Spring Framework provided great flexibility in the web layer. If you wanted
    to use Struts or Struts 2 instead of Spring MVC, it was configurable. You had
    the choice of integrating with a wider range of view and template frameworks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another good example is the data layer, where you had possibilities to connect
    with JPA, JDBC, and mapping frameworks, such as MyBatis.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simplified implementation of cross-cutting concerns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When Spring Framework is used to manage beans, the Spring IoC container manages
    the life cycle--creation, use, auto-wiring, and destruction--of the beans. It
    makes it easier to weave an additional functionality--such as the cross-cutting
    concerns--around the beans.
  prefs: []
  type: TYPE_NORMAL
- en: Design patterns for free
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spring Framework encourages the use of a number of design patterns by default.
    A few examples are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Dependency Injection or Inversion of Controller**: This is the fundamental
    design pattern Spring Framework is built to enable. It enables loose coupling
    and testability.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Singleton**: All Spring beans are singletons by default.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Factory Pattern**: Using the bean factory to instantiate beans is a good
    example of the factory pattern.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Front Controller**: Spring MVC uses DispatcherServlet as the Front Controller.
    So we use the Front Controller pattern when we develop applications with Spring
    MVC.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Template Method**: Helps us avoid boilerplate code. Many Spring-based classes--JdbcTemplate
    and JmsTemplate--are implementations of this pattern.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application development goals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we move on to the concepts of REST services, microservices, and Cloud-Native
    applications, let's take some time to understand the common goals we have when
    we develop applications. Understanding these goals will help us understand why
    applications are moving toward the microservices architecture.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, we should remember that the software industry is still a relatively
    young industry. One thing that's been a constant in my decade and a half experience
    with developing, designing, and architecting software is that things change. The
    requirements of today are not the requirements of tomorrow. Technology today is
    not the technology we will use tomorrow. While we can try predicting what happens
    in the future, we are often wrong.
  prefs: []
  type: TYPE_NORMAL
- en: One of the things we did during the initial decades of software development
    was build software systems for the future. The design and architecture were made
    complex in preparation for future requirements.
  prefs: []
  type: TYPE_NORMAL
- en: 'During the last decade, with **agile** and **extreme programming**, the focus
    shifted to being **lean** and building good enough systems, adhering to basic
    principles of design. The focus shifted to evolutionary design. The thought process
    is this: **If a system has good design for today''s needs, and is continuously
    evolving and has good tests, it can easily be refactored to meet tomorrow''s needs**.'
  prefs: []
  type: TYPE_NORMAL
- en: While we do not know where we are heading, we do know that a big chunk of our
    goals when developing applications have not changed.
  prefs: []
  type: TYPE_NORMAL
- en: The key goals of software development, for a large number of applications, can
    be described with the statement s*peed and safety at scale*.
  prefs: []
  type: TYPE_NORMAL
- en: We will discuss each of these in elements in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Speed
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The speed of delivering new requirements and innovations is increasingly becoming
    a key differentiator. It is not sufficient to develop (code and test) fast. It
    is important to deliver (to production) quickly. It is now common knowledge that
    the best software organizations in the world deliver software to production multiple
    times every day.
  prefs: []
  type: TYPE_NORMAL
- en: 'The technology and business landscape is in a constant flux, and is constantly
    evolving. The key question is "How fast can an application adapt to these changes?".
    Some of the important changes in the technology and business landscape are highlighted
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: New programming languages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Go
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scala
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Closure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New programming paradigms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functional programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reactive programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New frameworks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code quality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automation testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deployment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Containerizations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New processes and practices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Agile
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test-driven development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Behavior-driven development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Continuous integration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Continuous delivery
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DevOps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New devices and opportunities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mobile
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cloud
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Safety
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the use of speed without safety? Who would want to go in a car that
    can travel at 300 miles an hour but that has no proper safety features built in?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider a few characteristics of a safe application:'
  prefs: []
  type: TYPE_NORMAL
- en: Reliability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reliability is a measure of how accurately the system functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The key questions to ask are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Is the system meeting its functional requirements?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How many defects are leaked during different release phases?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Availability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most external client-facing applications are expected to be available round
    the clock. Availability is a measure of how much percentage of time your application
    is available for your end user.
  prefs: []
  type: TYPE_NORMAL
- en: Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The security of applications and data is critical to the success of organizations.
    There should be clear procedures for authentication (are you who you claim to
    be?), authorization (what access does a user have?), and data protection (is the
    data that is received or sent accurate? Is the data safe and not intercepted by
    unintended users?).
  prefs: []
  type: TYPE_NORMAL
- en: We will discuss more about implementing security using Spring Security in [Chapter
    6](09291379-92b0-4d7d-bff7-d77e089f33db.xhtml), *Extending Microservices*.
  prefs: []
  type: TYPE_NORMAL
- en: Performance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If a web application does not respond within a couple of seconds, there is a
    very high chance that the user of your application will be disappointed. Performance
    usually refers to the ability of a system to provide an agreed-upon response time
    for a defined number of users.
  prefs: []
  type: TYPE_NORMAL
- en: High resilience
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As applications become distributed, the probability of failures increases. How
    does the application react in the case of localized failures or disruptions? Can
    it provide basic operations without completely crashing?
  prefs: []
  type: TYPE_NORMAL
- en: This behavior of an application to provide the bare minimum service levels in
    case of unexpected failures is called resilience.
  prefs: []
  type: TYPE_NORMAL
- en: As more and more applications move towards the Cloud, the resilience of applications
    becomes important.
  prefs: []
  type: TYPE_NORMAL
- en: We will discuss building highly resilient microservices using *Spring Cloud
    and Spring Data Flow* in [Chapter 9](9d263fde-d65c-4222-8da9-b360de7ccc12.xhtml),
    *Spring Cloud* and [Chapter 10](e6e89939-cdb1-470b-a052-e4688e5bacb1.xhtml), *Spring
    Cloud Data Flow*.
  prefs: []
  type: TYPE_NORMAL
- en: Scalability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Scalability is a measure of how an application would react when the resources
    at its disposal are scaled up. If an application supports 10,000 users with a
    given infrastructure, can it support at least 20,000 users with double the infrastructure?
  prefs: []
  type: TYPE_NORMAL
- en: If a web application does not respond within a couple of seconds, there is a
    very high chance that the user of your application will be disappointed. Performance
    usually refers to the ability of a system to provide an agreed-upon response time
    for a defined number of users.
  prefs: []
  type: TYPE_NORMAL
- en: In the world of Cloud, the scalability of applications becomes even more important.
    It's difficult to guess how successful a startup might be. Twitter or Facebook
    might not have expected such success when they were incubated. Their success,
    for large measure, depends on how they were able to adapt to a multi-fold increase
    in their user base without affecting the performance.
  prefs: []
  type: TYPE_NORMAL
- en: We will discuss building highly scalable microservices using Spring Cloud and
    Spring Data Flow in [Chapter 9](9d263fde-d65c-4222-8da9-b360de7ccc12.xhtml), *Spring
    Cloud* and [Chapter 10](e6e89939-cdb1-470b-a052-e4688e5bacb1.xhtml), *Spring Cloud
    Data Flow*.
  prefs: []
  type: TYPE_NORMAL
- en: Challenges with monolithic applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Over the last few years, in parallel to working with several small applications,
    I had the opportunity to work on four different monolithic applications in varied
    domains--insurance, banking, and health care. All these applications had very
    similar challenges. In this section, we will start with looking at the characteristics
    of monoliths and then look at the challenges they bring in.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all: What is a monolith? An application with a lot of code--may be
    greater than 100K lines of code? Yeah.'
  prefs: []
  type: TYPE_NORMAL
- en: For me, monoliths are those applications for which getting a release out to
    production is a big challenge. Applications that fall into this category have
    a number of user requirements that are immediately needed, but these applications
    are able to do new feature releases once every few months. Some of these applications
    even do feature releases once a quarter or sometimes even as less as twice a year.
  prefs: []
  type: TYPE_NORMAL
- en: 'Typically, all monolithic applications have these characteristics:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Large size**: Most of these monolithic applications have more than 100K lines
    of code. Some have codebases with more than a million lines of code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Large teams**: The team size could vary from 20 to 300.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Multiple ways of doing the same thing**: Since the team is huge, there is
    a communication gap. This results in multiple solutions for the same problem in
    different parts of the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lack of automation testing**: Most of these applications have very few unit
    tests and a complete lack of integration tests. These applications have great
    dependence on manual testing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because of these characteristics, there are a number of challenges faced by
    these monolithic applications.
  prefs: []
  type: TYPE_NORMAL
- en: Long release cycles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Making a code change in one part of the monolith may impact some other part
    of the monolith. Most code changes will need a complete regression cycle. This
    results in long release cycles.
  prefs: []
  type: TYPE_NORMAL
- en: Because there is a lack of automation testing, these applications depend on
    manual testing to find defects. Taking the functionality live is a major challenge.
  prefs: []
  type: TYPE_NORMAL
- en: Difficult to scale
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Typically, most monolithic applications are not Cloud-Native, which means that
    they are not easy to deploy on the Cloud. They depend on manual installation and
    manual configuration. There is typically a lot of work put in by the operations
    team before a new application instance is added to the cluster. This makes scaling
    up and down a big challenge.
  prefs: []
  type: TYPE_NORMAL
- en: The other important challenge is large databases. Typically, monolithic applications
    have databases running into **terabytes** (**TB**). The database becomes the bottleneck
    when scaling up.
  prefs: []
  type: TYPE_NORMAL
- en: Adapting new technologies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most monolithic applications use old technologies. Adding a new technology to
    the monolith only makes it more complex to maintain. Architects and developers
    are reluctant to bring in any new technologies.
  prefs: []
  type: TYPE_NORMAL
- en: Adapting new methodologies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'New methodologies such as **agile** need small (four-seven team members), independent
    teams. The big questions with monolith are these: How do we prevent teams from
    stepping on each other''s toes? How do we create islands that enable teams to
    work independently? This is a difficult challenge to solve.'
  prefs: []
  type: TYPE_NORMAL
- en: Adapting modern development practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Modern development practices such as **Test-Driven Development** (**TDD**),
    **Behavior-Driven Development** (**BDD**) need loosely coupled, testable architecture.
    If the monolithic application has tightly coupled layers and frameworks, it is
    difficult to unit test. It makes adapting modern development practices challenging.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The challenges with monolithic applications lead to organizations searching
    for the silver bullet. How will we be able to make more features live more often?
  prefs: []
  type: TYPE_NORMAL
- en: Many organizations have tried different architectures and practices to find
    a solution.
  prefs: []
  type: TYPE_NORMAL
- en: In the last few years, a common pattern emerged among all the organizations
    that were successful at doing this. From this emerged an architectural style that
    was called **microservices architecture**.
  prefs: []
  type: TYPE_NORMAL
- en: 'As Sam Newman says in the book Building Microservices: Many organizations have
    found that by embracing fine-grained, microservice architectures, they can deliver
    software faster and embrace newer technologies.'
  prefs: []
  type: TYPE_NORMAL
- en: What is a microservice?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the principles I love in software is *keep it small*. This principle
    is applicable irrespective of what you are talking about--the scope of a variable,
    the size of a method, class, package, or a component. You would want all of these
    to be as small as they possibly could be.
  prefs: []
  type: TYPE_NORMAL
- en: Microservices is a simple extension of this principle. It's an architectural
    style focused on building small capability-based independently deployable services.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is no single accepted definition of a microservice. We will look at some
    of the popular definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '"Microservices are small, autonomous services that work together"'
  prefs: []
  type: TYPE_NORMAL
- en: '- Sam Newman, Thoughtworks'
  prefs: []
  type: TYPE_NORMAL
- en: '"Loosely coupled service-oriented architecture with bounded contexts"'
  prefs: []
  type: TYPE_NORMAL
- en: '- Adrian Cockcroft, Battery Ventures'
  prefs: []
  type: TYPE_NORMAL
- en: '"A microservice is an independently deployable component of bounded scope that
    supports interoperability through message-based communication. Microservice architecture
    is a style of engineering highly automated, evolvable software systems made up
    of capability-aligned microservices" in the book Microservice Architecture'
  prefs: []
  type: TYPE_NORMAL
- en: '- Irakli Nadareishvili, ‎Ronnie Mitra, ‎Matt McLarty'
  prefs: []
  type: TYPE_NORMAL
- en: While there is no accepted definition, there are a few characteristics that
    are commonly featured in all definitions of microservice. Before we look at the
    characteristics of microservices, we will try and understand the big picture--we
    will look at how architecture without microservices compares with architecture
    using microservices.
  prefs: []
  type: TYPE_NORMAL
- en: The microservice architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Monolithic applications--even those that are modularized--have a single deployable
    unit. The following figure shows an example of a monolithic application with three
    modules, module 1, 2, and 3\. These modules can be a business capability that
    is part of the monolithic application. In a shopping application, one of the modules
    might be a product recommendation.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/55f0018d-98ab-4e04-832f-a78c693e8f53.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following figure shows what the preceding monolith looks like when developed
    using microservice architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ea2b1e73-54dd-4612-8346-d95ee4392fef.png)'
  prefs: []
  type: TYPE_IMG
- en: 'A few important things to note are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Modules are identified based on business capabilities. What functionality is
    the module providing?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each module is independently deployable. In the following example, modules 1,
    2, and 3 are separate deployable units. If there is a change in the business functionality
    of module 3, we can individually build and deploy module 3.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Microservice characteristics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous section, we looked at an example of the microservice architecture.
    An evaluation of experiences at organizations successful at adapting the microservices
    architectural style reveals that there are a few characteristics that are shared
    by teams and architectures. Let''s look at some of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c29a5bb1-1fcc-42eb-b70a-318000004230.png)'
  prefs: []
  type: TYPE_IMG
- en: Small and lightweight microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A good microservice provides a business capability. Ideally, microservices should
    follow the **single responsibility principle**. Because of this, microservices
    are generally small in size. Typically, a rule of thumb I use is that it should
    be possible to build and deploy a microservice within 5 minutes. If the building
    and deployment takes any longer, it is likely that you are building a larger than
    recommended microservice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some examples of small and lightweight microservices are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Product recommendation service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Email notification service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shopping cart service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interoperability with message-based communication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The key focus of microservices is on interoperability--communication between
    systems using diverse technologies. The best way to achieve interoperability is
    using message-based communication.
  prefs: []
  type: TYPE_NORMAL
- en: Capability-aligned microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is essential that microservices have a clear boundary. Typically, every microservice
    has a single identified business capability that it delivers well. Teams have
    found success adapting the *Bounded Context* concept proposed in the book *Domain-Driven
    Design* by Eric J Evans.
  prefs: []
  type: TYPE_NORMAL
- en: Essentially, for large systems, it is very difficult to create one domain model.
    Evans talks about splitting the system into different bounded contexts. Identifying
    the right bounded contexts is the key to success with microservice architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Independently deployable units
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Each microservice can be individually built and deployed. In the example discussed
    earlier, modules 1, 2, and 3 can each be independently built and deployed.
  prefs: []
  type: TYPE_NORMAL
- en: Stateless
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An ideal microservice does not have a state. It does not store any information
    between requests. All the information needed to create a response is present in
    the request.
  prefs: []
  type: TYPE_NORMAL
- en: Automated build and release process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Microservices have automated build and release processes. Take a look at the
    following figure. It shows a simple build and release process for a microservice:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/de250ec2-6ae1-4f5c-936e-0d9a760ac053.png)'
  prefs: []
  type: TYPE_IMG
- en: When a microservice is built and released, a version of the microservice is
    stored in the repository. The deploy tool has the capability of picking the right
    version of microservice from the repository, matching it with the configuration
    needed for the specific environment (from the configuration repository), and deploying
    the microservice to a specific environment.
  prefs: []
  type: TYPE_NORMAL
- en: Some teams take it a step further and combine the microservice package with
    the underlying infrastructure needed to run the microservice. The deploy tool
    will replicate this image and match it with an environment-specific configuration
    to create an environment.
  prefs: []
  type: TYPE_NORMAL
- en: Event-driven architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Microservices are typically built with event-driven architecture. Let''s consider
    a simple example. Whenever a new customer is registered, there are three things
    that need to be performed:'
  prefs: []
  type: TYPE_NORMAL
- en: Store customer information to the database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mail a welcome kit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Send an email notification
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's look at two different approaches to design this.
  prefs: []
  type: TYPE_NORMAL
- en: Approach 1 - sequential approach
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s consider three services--`CustomerInformationService`, `MailService`,
    and `EmailService`, which can provide the capabilities listed earlier. We can
    create `NewCustomerService` with the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Call `CustomerInformationService` to save customer information to the database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call `MailService` to mail the welcome kit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call `EmailService` to send the e-mail notification.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`NewCustomerService` becomes the central place for all business logic. Imagine
    if we have to do more things when a new customer is created. All that logic would
    start accumulating and bloating up `NewCustomerService`.'
  prefs: []
  type: TYPE_NORMAL
- en: Approach 2 - event-driven approach
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this approach, we use a message broker. `NewCustomerService` will create
    a new event and post it to the message broker. The following figure shows a high-level
    representation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/38848057-d17b-462d-a224-4ee1b659f944.png)'
  prefs: []
  type: TYPE_IMG
- en: The three services--`CustomerInformationService`, `MailServic`e, and `EmailService`--will
    be listening on the message broker for new events. When they see the new customer
    event, they process it and execute the functionality of that specific service.
  prefs: []
  type: TYPE_NORMAL
- en: The key advantage of the event-driven approach is that there is no centralized
    magnet for all the business logic. Adding a new functionality is easier. We can
    create a new service to listen for the event on the message broker. Another important
    thing to note is that we don't need to make changes to any of the existing services.
  prefs: []
  type: TYPE_NORMAL
- en: Independent teams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The team developing a microservice is typically independent. It contains all
    the skills needed to develop, test, and deploy a microservice. It is also responsible
    for supporting the microservice in production.
  prefs: []
  type: TYPE_NORMAL
- en: Microservice advantages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Microservices have several advantages. They help in keeping up with technology
    and getting solutions to your customers faster.
  prefs: []
  type: TYPE_NORMAL
- en: Faster time to market
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The faster time to market is one of the key factors in determining the success
    of an organization.
  prefs: []
  type: TYPE_NORMAL
- en: Microservices architecture involves creating small, independently deployable
    components. Microservice enhancements are easier and less brittle because each
    microservice focuses on a single business capability. All the steps in the process--building,
    releasing, deployment, testing, configuration management, and monitoring--are
    automated. Since the responsibility of a microservice is bounded, it is possible
    to write great automation unit and integration tests.
  prefs: []
  type: TYPE_NORMAL
- en: All these factors result in applications being able to react faster to customer
    needs.
  prefs: []
  type: TYPE_NORMAL
- en: Technology evolution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are new languages, frameworks, practices, and automation possibilities
    emerging every day. It is important that the application architectures allow flexibility
    to adapt to emerging possibilities. The following figure shows how different services
    are developed in different technologies:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6360b071-e610-4a12-a742-6e8534da43e5.png)'
  prefs: []
  type: TYPE_IMG
- en: The microservice architecture involves creating small services. Within some
    boundaries, most organizations give the individual teams the of technology to
    make some of the technology decisions. This allows teams to experiment with new
    technologies and innovate faster. This helps applications adapt and stay in tune
    with the evolution of technology.
  prefs: []
  type: TYPE_NORMAL
- en: Availability and scaling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The load on different parts of the application is typically very different.
    For example, in the case of a flight booking application, a customer usually searches
    multiple times before making a decision on whether to book a flight. The load
    on the search module would typically be many times more than the load on the booking
    module. The microservices architecture provides the flexibility of setting up
    multiple instances of the search service with few instances of the booking service.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure shows how we can scale up specific microservices based
    on the load:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f71c83f5-dfe6-44c3-9914-e031e7e9ee2e.png)'
  prefs: []
  type: TYPE_IMG
- en: Microservices **2** and **3** share a single box (the deployment environment).
    Microservice **1**, which has more load, is deployed into multiple boxes.
  prefs: []
  type: TYPE_NORMAL
- en: Another example is the need for start-ups. When a start-up begins its operations,
    they are typically unaware of the extent to which they might grow. What happens
    if the demand for applications grows very fast? If they adapt the microservice
    architecture, it enables them to scale better when the need arises.
  prefs: []
  type: TYPE_NORMAL
- en: Team dynamics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Development methodologies such as agile advocate small, independent teams. Since
    microservices are small, it is possible to build small teams around them. Teams
    are cross-functional, with end-to-end ownership of specific microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Microservice architecture fits in very well with agile and other modern development
    methodologies.
  prefs: []
  type: TYPE_NORMAL
- en: Microservice challenges
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Microservice architecture has significant advantages. However, there are significant
    challenges too. Deciding the boundaries of microservices is a challenging but
    important decision. Since microservices are small, and there would be hundreds
    of microservices in a large enterprise, having great automation and visibility
    is critical.
  prefs: []
  type: TYPE_NORMAL
- en: Increased need for automation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With microservice architecture, you are splitting up a large application into
    multiple microservices, so the number of builds, releases, and deployments increases
    multifold. It would be very inefficient to have manual processes for these steps.
  prefs: []
  type: TYPE_NORMAL
- en: Test automation is critical to enable a faster time to market. Teams should
    be focused on identifying automation possibilities as they emerge.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the boundaries of subsystems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Microservices should be intelligent. They are not weak CRUD services. They should
    model the business capability of the system. They own all the business logic in
    a bounded context. Having said this, microservices should not be large. Deciding
    the boundaries of microservices is a challenge. Finding the right boundaries might
    be difficult on the first go. It is important that as a team gains more knowledge
    about the business context, the knowledge flows into the architecture and new
    boundaries are determined. Generally, finding the right boundaries for microservices
    is an evolutionary process.
  prefs: []
  type: TYPE_NORMAL
- en: 'A couple of important points to note are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Loose coupling and high cohesion are fundamental to any programming and architectural
    decisions. When a system is loosely coupled, changes in one part should not require
    a change in other parts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bounded contexts represent autonomous business modules representing specific
    business capabilities.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As Sam Newman says in the book *Building Microservices--*"Specific responsibility
    enforced by explicit boundaries". Always think, "What capabilities are we providing
    to the rest of the domain?".
  prefs: []
  type: TYPE_NORMAL
- en: Visibility and monitoring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With microservices, one application is split into several microservices. To
    conquer the complexity associated with multiple microservices and asynchronous
    event-based collaboration, it is important to have great visibility.
  prefs: []
  type: TYPE_NORMAL
- en: Ensuring high availability means each microservice should be monitored. Automated
    health management of the microservices becomes important.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging problems needs insights into what's happening behind multiple microservices.
    Centralized logging with aggregation of logs and metrics from different microservices
    is typically used. Mechanisms such as correlation IDs need to be used to isolate
    and debug issues.
  prefs: []
  type: TYPE_NORMAL
- en: Fault tolerance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's say we are building a shopping application. What happens if the recommendation
    microservice is down? How does the application react? Does it completely crash?
    Or will it let the customer shop? These kinds of situations happen more often
    as we adapt the microservices architecture.
  prefs: []
  type: TYPE_NORMAL
- en: As we make the services small, the chance that a service is down increases.
    How the application reacts to these situations becomes an important question.
    In the earlier example, a fault-tolerant application would show some default recommendations
    while letting the customer shop.
  prefs: []
  type: TYPE_NORMAL
- en: As we move into microservices architecture, applications should be more fault
    tolerant. Applications should be able to provide toned-down behavior when services
    are down.
  prefs: []
  type: TYPE_NORMAL
- en: Eventual consistency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is important to have a degree of consistency between microservices in an
    organization. Consistency between microservices enables similar development, testing,
    release, deployment, and operational processes across the organization. This enables
    different developers and testers to be productive when they move across teams.
    It is important to be not very rigid and have a degree of flexibility within limits
    so as to not stifle innovation.
  prefs: []
  type: TYPE_NORMAL
- en: Shared capabilities (enterprise level)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's look at a few capabilities that have to be standardized at an enterprise
    level.
  prefs: []
  type: TYPE_NORMAL
- en: '**Hardware**: What hardware do we use? Do we use Cloud?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Code management**: What version control system do we use? What are our practices
    in branching and committing code?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Build and deployment**: How do we build? What tools do we use to automate
    deployment?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data store**: What kind of data stores do we use?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Service orchestration**: How do we orchestrate services? What kind of message
    broker do we use?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security and identity**: How do we authenticate and authorize users and services?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**System visibility and monitoring**: How do we monitor our services? How do
    we provide fault isolation across the system?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Increased need for operations teams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we move into a microservice world, there is a distinct shift in the responsibilities
    of operations team. The responsibilities shift to identifying opportunities for
    automation compared to manual operations such as executing releases and deployments.
  prefs: []
  type: TYPE_NORMAL
- en: With multiple microservices and an increase in communications across different
    parts of the system, the operations team becomes critical. It is important to
    involve operations as part of the team from the initial stages to enable them
    to identify solutions to make operations easier.
  prefs: []
  type: TYPE_NORMAL
- en: Cloud-Native applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Cloud is disrupting the world. A number of possibilities have emerged that
    were never possible before. Organizations are able to provision computing, network,
    and storage devices on demand. This has high potential to reduce costs in a number
    of industries.
  prefs: []
  type: TYPE_NORMAL
- en: Consider the retail industry, where there is high demand in pockets (Black Friday,
    holiday season, and so on). Why should they pay for hardware throughout the year
    when they could provision it on demand?
  prefs: []
  type: TYPE_NORMAL
- en: While we would like to be benefit from the possibilities of the Cloud, these
    possibilities are limited by architecture and the nature of applications.
  prefs: []
  type: TYPE_NORMAL
- en: How do we build applications that can be easily deployed on the Cloud? That's
    where Cloud-Native applications come into the picture.
  prefs: []
  type: TYPE_NORMAL
- en: Cloud-Native applications are those that can easily be deployed on the Cloud.
    These applications share a few common characteristics. We will begin by looking
    at the Twelve-Factor App--a combination of common patterns among Cloud-Native
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: Twelve-Factor App
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Twelve-Factor App evolved from the experiences of engineers at Heroku. It
    is a list of patterns that are used in Cloud-Native application architectures.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that an app here refers to a single deployable unit.
    Essentially, every microservice is an app (because each microservice is independently
    deployable).
  prefs: []
  type: TYPE_NORMAL
- en: Maintain one code base
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Each app has one code base in revision control. There can be multiple environments
    where the app can be deployed. However, all these environments use code from a
    single codebase. An example antipattern is building a deployable from multiple
    codebases.
  prefs: []
  type: TYPE_NORMAL
- en: Dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All dependencies must be explicitly declared and isolated. Typical Java applications
    use build management tools such as Maven and Gradle to isolate and track dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure shows typical Java applications managing dependencies
    using Maven:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8e22e887-9a41-4542-880d-0bd0d8861a08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following figure shows `pom.xml`, where the dependencies are managed for
    a Java application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4500d394-7dd1-4681-b0ea-5f6fa3a2d815.png)'
  prefs: []
  type: TYPE_IMG
- en: Config
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All applications have configuration that varies from one environment to another.
    Configuration is found at multiple locations; application code, property files,
    databases, environment variables, JNDI, and system variables are a few examples.
  prefs: []
  type: TYPE_NORMAL
- en: A Twelve-Factor App
  prefs: []
  type: TYPE_NORMAL
- en: App should store configuration in the environment. While environment variables
    are recommended in order to manage configuration in a Twelve-Factor App, other
    alternatives, such as having a centralized repository for application configuration,
    should be considered for more complex systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Irrespective of the mechanism used, we recommend that you do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Manage configuration outside the application code (independent of the application's
    deployable unit)
  prefs: []
  type: TYPE_NORMAL
- en: Use a standardized way of configuration
  prefs: []
  type: TYPE_NORMAL
- en: Backing services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Applications depend on other services being available--data stores and external
    services, among others. The Twelve-Factor App treats backing services as attached
    resources. A backing service is typically declared via an external configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Loose coupling to a backing service has many advantages, including the ability
    to gracefully handle an outage of a backing service.
  prefs: []
  type: TYPE_NORMAL
- en: Build, release, run
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The build, release, and run phases are described as follows. We should maintain
    a clear separation between all these three phases:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Build**: Creates an executable bundle (EAR, WAR, or JAR) from code, as well
    as dependencies that can be deployed to multiple environments'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Release**: Combines the executable bundle with a specific environment configuration
    to deploy in an environment'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Run**: Runs the app in an execution environment using a specific release'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The build and release phases are highlighted in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/01ede5e0-7a64-46c7-8474-66b8abc6a0ea.png)'
  prefs: []
  type: TYPE_IMG
- en: An antipattern is the building of separate executable bundles specific to each
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: Stateless
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Twelve-Factor App does not have a state. All the data that it needs is stored
    in a persistent store.
  prefs: []
  type: TYPE_NORMAL
- en: An antipattern is a sticky session.
  prefs: []
  type: TYPE_NORMAL
- en: Port binding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Twelve-Factor App exposes all services using port binding. While it is possible
    to have other mechanisms to expose services, these mechanisms are implementation-dependent.
    Port binding gives full control of receiving and handling messages irrespective
    of where an app is deployed.
  prefs: []
  type: TYPE_NORMAL
- en: Concurrency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Twelve-Factor App is able to achieve more concurrency by scaling out horizontally.
    Scaling vertically has its limits. Scaling out horizontally provides opportunities
    to expand without limits.
  prefs: []
  type: TYPE_NORMAL
- en: Disposability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Twelve-Factor App should promote elastic scaling. Hence, they should be disposable.
    They can be started and stopped when needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'A Twelve-Factor App should do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Have minimum startup time. A long startup time means a long delay before an
    application can take requests.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shut down gracefully.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handle hardware failures gracefully.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Environment parity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the environments--development, test, staging, and production--should be
    similar. They should use the same processes and tools. With continuous deployment,
    they should have very frequently have similar code. This makes finding and fixing
    problems easier.
  prefs: []
  type: TYPE_NORMAL
- en: Logs as event streams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Visibility is critical to a Twelve-Factor App. Since applications are deployed
    on the Cloud and are automatically scaled, it is important that you have a centralized
    view of what's happening across different instances of the applications.
  prefs: []
  type: TYPE_NORMAL
- en: Treating all logs as stream enables the routing of the log stream to different
    destinations for viewing and archival purposes. This stream can be used to debug
    issues, perform analytics, and create alerting systems based on error patterns.
  prefs: []
  type: TYPE_NORMAL
- en: No distinction of admin processes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Twelve-Factor Apps treat administrative tasks (migrations, scripts) similar
    to normal application processes.
  prefs: []
  type: TYPE_NORMAL
- en: Spring projects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the world moves toward Cloud-Native applications and microservices, Spring
    projects are not far behind. There are a number of new Spring projects--Spring
    Boot, Spring Cloud, among others, that solve the problems of the emerging world.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Boot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the era of monoliths, we had the luxury of taking the time to set the frameworks
    up for an application. However, in the era of microservices, we want to create
    individual components faster. The Spring Boot project aims to solve this problem.
  prefs: []
  type: TYPE_NORMAL
- en: As the official website highlights, Spring Boot makes it easy to create standalone,
    production-grade Spring-based applications that you can *just run*. We take an
    opinionated view of the Spring platform and third-party libraries so that you
    can get started with minimum fuss.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Boot aims to take an opinionated view--basically making a lot of decisions
    for us--to developing Spring-based projects.
  prefs: []
  type: TYPE_NORMAL
- en: In the next couple of chapters, we will look at Spring Boot and the different
    features that enable us to create production-ready applications faster.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Cloud
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spring Cloud aims to provide solutions to some commonly encountered patterns
    when building systems on the Cloud:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Configuration management**: As we discussed in the Twelve-Factor App section,
    managing configuration is an important part of developing Cloud-Native applications.
    Spring Cloud provides a centralized configuration management solution for microservices
    called Spring Cloud Config.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Service discovery**: Service discovery promotes loose coupling between services.
    Spring Cloud provides integration with popular service discovery options, such
    as Eureka, ZooKeeper, and Consul.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Circuit breakers**: Cloud-Native applications must be fault tolerant. They
    should be able to handle the failure of backing services gracefully. Circuit breakers
    play a key role in providing the default minimum service in case of failures.
    Spring Cloud provides integration with the Netflix Hystrix fault tolerance library.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**API Gateway**: An API Gateway provides centralized aggregation, routing,
    and caching services. Spring Cloud provides integration with the API Gateway library
    Netflix Zuul.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at how the world evolved toward microservices and
    Cloud-Native applications. We understood how Spring Framework and projects are
    evolving to meet the needs of today's world with projects such as Spring Boot,
    Spring Cloud, and Spring Data.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will start focusing on Spring Boot. We will look at
    how Spring Boot makes developing microservices easy.
  prefs: []
  type: TYPE_NORMAL
- en: The first version of Spring Framework 1.0 was released in March 2004\. For more
    than a decade and a half, Spring Framework remained the framework of choice to
    build Java applications.
  prefs: []
  type: TYPE_NORMAL
- en: In the relatively young and dynamic world of Java frameworks, a decade is a
    long time.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we start with understanding the core features of Spring Framework.
    We will look at why the Spring Framework became popular and how it adapted to
    remain the framework of choice. After taking a quick look at the important modules
    in the Spring Framework, we will jump into the world of Spring Projects. We will
    end the chapter by looking at the new features in Spring Framework 5.0.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will answer the following questions:'
  prefs: []
  type: TYPE_NORMAL
- en: Why is Spring Framework popular?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How has Spring Framework adapted to the evolution of application architectures?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are the important modules in Spring Framework?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Where does Spring Framework fit in the umbrella of Spring Projects?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are the new features in Spring Framework 5.0?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Spring website ([https://projects.spring.io/spring-framework/](https://projects.spring.io/spring-framework/))
    defines Spring Framework as follows: *The Spring Framework provides a comprehensive
    programming and configuration model for modern Java-based enterprise applications*.'
  prefs: []
  type: TYPE_NORMAL
- en: Spring Framework is used to wire enterprise Java applications. The main aim
    of Spring Framework is to take care of all the technical plumbing that is needed
    in order to connect the different parts of an application. This allows programmers
    to focus on the crux of their jobs--writing business logic.
  prefs: []
  type: TYPE_NORMAL
- en: Problems with EJB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring Framework was released in March 2004\. When the first version of Spring
    Framework was released, the popular way of developing an enterprise application
    was using **Enterprise Java Beans** (**EJB**) 2.1.
  prefs: []
  type: TYPE_NORMAL
- en: 'Developing and deploying EJBs was a cumbersome process. While EJBs made the
    distribution of components easier, developing, unit testing, and deploying them
    was not easy. The initial versions of EJBs (1.0, 2.0, 2.1) had a complex **Application
    Programmer Interface** (**API**), leading to a perception (and truth in most applications)
    that the complexity introduced far outweighed the benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: Difficult to unit test. Actually, difficult to test outside the EJB Container.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiple interfaces need to be implemented with a number of unnecessary methods.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cumbersome and tedious exception handling.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inconvenient deployment descriptors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Framework was introduced as a lightweight framework aimed at making developing
    Java EE applications simpler.
  prefs: []
  type: TYPE_NORMAL
- en: Why is Spring Framework popular?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first version of Spring Framework was released in March 2004\. In the subsequent
    decade and a half, the use and popularity of Spring Framework only grew.
  prefs: []
  type: TYPE_NORMAL
- en: 'The important reasons behind the popularity of Spring Framework are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Simplified unit testing--because of dependency injection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reduction in plumbing code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Architectural flexibility
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keeping up with changing times
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's discuss each of these in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Simplified unit testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Earlier versions of EJBs were very difficult to unit test. In fact, it was difficult
    to run EJBs outside the container (as of version 2.1). The only way to test them
    was to deploy them in a container.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Framework brought in the concept of **Dependency Injection** (**DI**).
    We will discuss dependency injection in complete detail in Chapter 2, *Dependency
    Injection*.
  prefs: []
  type: TYPE_NORMAL
- en: The dependency injection enables unit testing by making it easy to replace the
    dependencies with their mocks. We do not need to deploy the entire application
    to unit test it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Simplifying unit testing has multiple benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: Programmers are more productive
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defects are found earlier so they are less costly to fix
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applications have automated unit tests, which can run in **Continuous Integration**
    builds, preventing future defects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reduction in plumbing code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before Spring Framework, typical J2EE (or Java EE, as it is called now) applications
    contained a lot of plumbing code. For example: getting a database connection,
    exception handling code, transaction management code, logging code, and a lot
    more.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at a simple example of executing a query using prepared
    statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, there are four lines of business logic and more than
    10 lines of plumbing code.
  prefs: []
  type: TYPE_NORMAL
- en: 'With Spring Framework, the same logic can be applied in a couple of lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: How does Spring Framework do this magic?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the preceding example, Spring JDBC (and Spring, in general) converts most
    checked exceptions into unchecked exceptions. Typically, when a query fails, there
    is not a lot we can do--other than to close the statement and fail the transaction.
    Instead of implementing exception handling in every method, we can have centralized
    exception handling and inject it in using Spring **Aspect-Oriented Programming**
    (**AOP**).
  prefs: []
  type: TYPE_NORMAL
- en: Spring JDBC removes the need to create all the plumbing code involved in getting
    a connection, creating a prepared statement, and so on. The `jdbcTemplate` class
    can be created in the Spring context and injected into the **Data Access Object**
    (**DAO**) class wherever it is needed.
  prefs: []
  type: TYPE_NORMAL
- en: Similar to the preceding example, Spring JMS, Spring AOP, and other Spring modules
    help in reducing a lot of plumbing code.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Framework lets the programmer focus on the primary job of a programmer--
    writing business logic.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding all the plumbing code also has another great benefit--reduced duplication
    in code. Since all code for transaction management, exception handling, and so
    on (typically, all your cross-cutting concerns) is implemented at one place, it
    is easier to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: Architectural flexibility
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring Framework is modular. It is built as a set of independent modules built
    on top of the core Spring modules. Most of the Spring modules are independent--you
    can use one of them without having to use others.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at a few examples:'
  prefs: []
  type: TYPE_NORMAL
- en: In the web layer, Spring offers a framework of its own--Spring MVC. However,
    Spring has great support for Struts, Vaadin, JSF, or any web framework of your
    choice.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Beans can provide lightweight implementation for your business logic.
    However, Spring can be integrated with EJBs as well.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the data layer, Spring simplifies JDBC with its Spring JDBC module. However,
    Spring has great support for any of your preferred data layer frameworks--JPA,
    Hibernate (with or without JPA), or iBatis.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You have the option of implementing your cross-cutting concerns (logging, transaction
    management, security, and so on) with Spring AOP. Or, you can integrate with a
    fully fledged AOP implementation such as AspectJ.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Framework does not want to be the jack-of-all-trades. While focusing
    on its core job of reducing coupling between different parts of the application
    and making them testable, Spring provides great integration with frameworks of
    your choice. This means you have flexibility in your architecture--if you do not
    want to use a specific framework, you can easily replace it with another.
  prefs: []
  type: TYPE_NORMAL
- en: Keep up with changing times
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first version of Spring Framework focused on making applications testable.
    However, as time moved on, there were new challenges. Spring Framework managed
    to evolve and stay ahead of the curve with the flexibility and modules that are
    offered. A couple of examples are listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Annotations were introduced in Java 5\. Spring Framework (version 2.5 – Nov
    2007) was ahead of Java EE in introducing an annotation-based controller model
    for Spring MVC. Developers using Java EE had to wait until Java EE 6 (Dec 2009
    – 2 years) before having comparable functionality.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Framework introduced a number of abstractions ahead of Java EE to keep
    the application decoupled from specific implementation. Caching API provides a
    case in point. Spring provided a transparent caching support in Spring 3.1\. Java
    EE came up with *JSR-107* for JCache (in 2014)--support for which was provided
    in Spring 4.1.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Another important thing Spring brings in is the umbrella of Spring Projects.
    Spring Framework is just one of the many projects under Spring Projects. We will
    discuss the different Spring Projects in a separate section. The following examples
    illustrate how Spring managed to stay ahead of times with new Spring Projects:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Spring Batch** defines a new approach to building Java Batch applications.
    We had to wait until Java EE 7 (June 2013) to have comparable batch application
    specification in Java EE.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As architecture evolved toward Cloud and microservices, Spring came up with
    new Cloud-oriented Spring Projects. Spring Cloud helps in simplifying the development
    and deployment of microservices. Spring Cloud Data Flow provides orchestrations
    around microservice applications.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The modularity of Spring Framework is one of the most important reasons for
    its widespread used. Spring Framework is highly modular with more than 20 different
    modules--having clearly defined boundaries.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure shows different Spring modules--organized by the layer
    of application they are typically used in:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/05c2894a-a465-4c3a-88f4-ad2a4931bab7.png)'
  prefs: []
  type: TYPE_IMG
- en: We will start with discussing the Spring Core Container before moving on to
    other modules grouped by the application layer they are typically used in.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Core Container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring Core Container provides the core features of Spring Framework--dependency
    injection, **IoC** (**Inversion of Control**) container, and the application context.
    We will learn more about DI and IoC Container in Chapter 2, *Dependency Injection*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Important core Spring modules are listed in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Module/Artifact** | **Use** |'
  prefs: []
  type: TYPE_TB
- en: '| spring-core | Utilities used by other Spring modules. |'
  prefs: []
  type: TYPE_TB
- en: '| spring-beans | Support for Spring beans. In combination with spring-core
    provides the core feature of Spring Framework--dependency injection. Includes
    implementation of BeanFactory. |'
  prefs: []
  type: TYPE_TB
- en: '| spring-context | Implements ApplicationContext, which extends BeanFactory
    and provides support to load resources and internationalization, among others.
    |'
  prefs: []
  type: TYPE_TB
- en: '| spring-expression | Extends **EL** (**Expression Language** from JSP) and
    provides a language for bean property (including arrays and collections) access
    and manipulations. |'
  prefs: []
  type: TYPE_TB
- en: Cross-cutting concerns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cross-cutting concerns are applicable to all application layers--logging and
    security, among others. **AOP** is typically used to implement cross-cutting concerns.
  prefs: []
  type: TYPE_NORMAL
- en: Unit tests and integration tests fit this category since they are applicable
    to all layers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Important Spring modules related to cross-cutting concerns are listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Module/Artifact** | **Use** |'
  prefs: []
  type: TYPE_TB
- en: '| spring-aop | Provides basic support for Aspect-Oriented Programming--with
    method interceptors and pointcuts. |'
  prefs: []
  type: TYPE_TB
- en: '| spring-aspects | Provides integration with the most popular and fully featured
    AOP framework, AspectJ. |'
  prefs: []
  type: TYPE_TB
- en: '| spring-instrument | Provides basic instrumentation support. |'
  prefs: []
  type: TYPE_TB
- en: '| spring-test | Provides basic support for unit testing and integration testing.
    |'
  prefs: []
  type: TYPE_TB
- en: Web
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring provides its own MVC framework, Spring MVC, other than providing great
    integration with popular web frameworks such as Struts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Important artifacts/modules are listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**spring-web**: Provides basic web features, such as multi-part file upload.
    Provides support for integration with other web frameworks, such as Struts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**spring-webmvc**: Provides a fully featured web MVC framework--Spring MVC,
    which includes features to implement REST services as well.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will cover Spring MVC and develop web applicaitions and rest services with
    it in Chapter 3, *Building Web Application with Spring MVC* and Chapter 5, *Building
    Microservices with Spring Boot.*
  prefs: []
  type: TYPE_NORMAL
- en: Business
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The business layer is focused on executing the business logic of the applications.
    With Spring, business logic is typically implemented in **Plain Old Java Object**
    (**POJO**).
  prefs: []
  type: TYPE_NORMAL
- en: '**Spring Transactions** (**spring-tx**) provides declarative transaction management
    for POJO and other classes.'
  prefs: []
  type: TYPE_NORMAL
- en: Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The data layer in applications typically talks to the database and/or the external
    interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the important Spring modules related to the data layer are listed in
    the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Module/Artifact** | **Use** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| spring-jdbc | Provides abstraction around JDBC to avoid boilerplate code.
    |'
  prefs: []
  type: TYPE_TB
- en: '| spring-orm | Provides integration with ORM frameworks and specifications--
    JPA and Hibernate, among others. |'
  prefs: []
  type: TYPE_TB
- en: '| spring-oxm | Provides an object to XML mapping integration. Supports frameworks
    such as JAXB, Castor, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| spring-jms | Provides abstraction around JMS to avoid boilerplate code. |'
  prefs: []
  type: TYPE_TB
- en: Spring Projects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While Spring Framework provides the base for core features of enterprise applications
    (DI, web, data), other Spring Projects explore integration and solutions to other
    problems in the enterprise space--deployment, Cloud, Big Data, Batch and Security,
    among others.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the important Spring Projects are listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Spring Boot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Cloud
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Batch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring HATEOAS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Boot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Some of the challenges while developing microservices and web applications
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Making framework choices and deciding compatible framework versions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing mechanisms for externalizing configuration--properties that can change
    from one environment to another
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Health checks and monitoring--providing alerts if a specific part of the application
    is down
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deciding the deployment environment and configuring the application for it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Boot solves all these problems out of the box by taking an *opinionated
    view* of how applications have to be developed.
  prefs: []
  type: TYPE_NORMAL
- en: We will look at Spring Boot in depth in two chapters--Chapter 5, *Building Microservices
    with Spring Boot* and [Chapter 7](c46a5b67-c5be-49c0-af8e-b0c4713f890b.xhtml),
    *Advanced Spring Boot Features*.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Cloud
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is not an exaggeration to say *The world is moving to the Cloud*.
  prefs: []
  type: TYPE_NORMAL
- en: Cloud Native microservices and applications are the order of the day. We will
    discuss this in detail in Chapter 4, *Evolution toward Microservices and Cloud-Native
    Applications*.
  prefs: []
  type: TYPE_NORMAL
- en: Spring is taking rapid strides toward making application development for the
    Cloud simpler with Spring Cloud.
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring Cloud provides solutions for common patterns in distributed systems.
    Spring Cloud enables developers to quickly create applications that implement
    common patterns. Some of the common patterns implemented in Spring Cloud are listed
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Configuration management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Service discovery
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Circuit breakers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Intelligent routing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will discuss Spring Cloud and its varied range features in more detail in
    [Chapter 9](9d263fde-d65c-4222-8da9-b360de7ccc12.xhtml), *Spring Cloud.*
  prefs: []
  type: TYPE_NORMAL
- en: Spring Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are multiple sources of data in today's world--SQL (relational) and a
    variety of NOSQL databases. Spring Data tries to provide a consistent data-access
    approach to all these different kinds of databases.
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring Data provides integration with a varied range of specifications and/or
    data stores:'
  prefs: []
  type: TYPE_NORMAL
- en: JPA
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MongoDB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Redis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Solr
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gemfire
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apache Cassandra
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some of the important features are listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Provides abstractions around repository and object mappings--by determining
    queries from method names
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simple Spring integration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integration with Spring MVC controllers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advanced automatic auditing features--created by, created date, last changed
    by, and last changed date
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will discuss Spring Data in more detail in [Chapter 8](b134d136-6980-440f-980c-227e8a46e532.xhtml),
    *Spring Data*.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Batch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Enterprise applications today process large volumes of data using batch programs.
    The needs of these applications are very similar. Spring Batch provides solutions
    for high- volume batch programs with high performance requirements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Important features in Spring Batch are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The ability to start, stop, and restart jobs--including the ability to restart
    failed jobs from the point where they failed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ability to process data in chunks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ability to retry steps or to skip steps on failure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Web-based administration interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Authentication** is the process of identifying the user. **Authorization**
    is the process of ensuring that a user has access to perform the identified action
    on the resource.'
  prefs: []
  type: TYPE_NORMAL
- en: Authentication and authorization are critical parts of Enterprise applications,
    both web applications and web services. Spring Security provides declarative authentication
    and authorization for Java based applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Important features in Spring Security are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Simplified authentication and authorization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Great integration with Spring MVC and Servlet APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support to prevent common security attacks--**cross-site forgery request** (**CSRF**)
    and Session Fixation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modules available for integration with SAML and LDAP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will discuss how to secure web applications with Spring Security in Chapter
    3, *Building Web Application with Spring MVC*.
  prefs: []
  type: TYPE_NORMAL
- en: We will discuss how to secure REST Services with Basic and OAuth authentication
    mechanisms using Spring Security in [Chapter 6](09291379-92b0-4d7d-bff7-d77e089f33db.xhtml),
    *Extending Microservices*.
  prefs: []
  type: TYPE_NORMAL
- en: Spring HATEOAS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**HATEOAS** stands for **Hypermedia as The Engine of Application State**. Though
    it sounds complex, it is quite a simple concept. Its main aim is to decouple the
    server (the provider of the service) from the client (the consumer of the service).'
  prefs: []
  type: TYPE_NORMAL
- en: The service provider provides the service consumer with information about what
    other actions can be performed on the resource.
  prefs: []
  type: TYPE_NORMAL
- en: Spring HATEOAS provides a HATEOAS implementation--especially for the REST services
    implemented with Spring MVC.
  prefs: []
  type: TYPE_NORMAL
- en: 'Important features in Spring HATEOAS are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Simplified definition of links pointing to service methods, making the links
    less fragile
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support for JAXB (XML-based) and JSON integration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support for service consumer (client side)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will discuss how to use HATEOAS in [Chapter 6](09291379-92b0-4d7d-bff7-d77e089f33db.xhtml),
    *Extending Microservices*.
  prefs: []
  type: TYPE_NORMAL
- en: New features in Spring Framework 5.0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring Framework 5.0 is the first major upgrade in Spring Framework, almost
    four years after Spring Framework 4.0\. In this time frame, one of the major developments
    has been the evolution of the Spring Boot project. We will discuss the new features
    in Spring Boot 2.0 in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the biggest features of Spring Framework 5.0 is **Reactive Programming**.
    Core reactive programming features and support for reactive endpoints are available
    out of the box with Spring Framework 5.0\. The list of important changes includes
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Baseline upgrades
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JDK 9 runtime compatibility
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Usage of JDK 8 features in the Spring Framework code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reactive programming support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A functional web framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java modularity with Jigsaw
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kotlin support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dropped features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Baseline upgrades
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring Framework 5.0 has JDK 8 and Java EE 7 baseline. Basically, it means that
    previous JDK and Java EE versions are not supported anymore.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the important baseline Java EE 7 specifications for Spring Framework
    5.0 are listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Servlet 3.1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JMS 2.0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JPA 2.1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JAX-RS 2.0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bean Validation 1.1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are many changes to the minimum supported versions of several Java frameworks.
    The following list contains some of the minimum supported versions of prominent
    frameworks:'
  prefs: []
  type: TYPE_NORMAL
- en: Hibernate 5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jackson 2.6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: EhCache 2.10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JUnit 5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tiles 3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following list shows the supported server versions:'
  prefs: []
  type: TYPE_NORMAL
- en: Tomcat 8.5+
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jetty 9.4+
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: WildFly 10+
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Netty 4.1+ (for web reactive programming with Spring Web Flux)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Undertow 1.4+ (for web reactive programming with Spring Web Flux)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applications using earlier versions of any of the preceding specifications/frameworks
    need to be upgraded at least to the previously listed versions before they can
    use Spring Framework 5.0.
  prefs: []
  type: TYPE_NORMAL
- en: JDK 9 runtime compatibility
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JDK 9 is expected to be released mid-2017\. Spring Framework 5.0 is expected
    to have runtime compatibility with JDK 9.
  prefs: []
  type: TYPE_NORMAL
- en: Usage of JDK 8 features in Spring Framework code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Spring Framework 4.x baseline version is Java SE 6\. This means that it
    supports Java 6, 7, and 8\. Having to support Java SE 6 and 7 puts constraints
    on the Spring Framework code. The framework code cannot use any of the new features
    in Java 8\. So, while the rest of the world upgraded to Java 8, the code in Spring
    Framework (at least the major parts) was restricted to using earlier versions
    of Java.
  prefs: []
  type: TYPE_NORMAL
- en: 'With Spring Framework 5.0, the baseline version is Java 8\. Spring Framework
    code is now upgraded to use the new features in Java 8\. This will result in more
    readable and performant framework code. Some of the Java 8 features used are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Java 8 default methods in core Spring interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Internal code improvements based on Java 8 reflection enhancements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use of functional programming in the framework code--lambdas and streams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reactive programming support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reactive programming is one of the most important features of Spring Framework
    5.0.
  prefs: []
  type: TYPE_NORMAL
- en: Microservices architectures are typically built around event-based communication.
    Applications are built to react to events (or messages).
  prefs: []
  type: TYPE_NORMAL
- en: Reactive programming provides an alternate style of programming focused on building
    applications that react to events.
  prefs: []
  type: TYPE_NORMAL
- en: 'While Java 8 does not have built-in suppport for reactive programming, there
    are a number of frameworks that provide support for reactive programming:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Reactive Streams**: Language-neutral attempt to define reactive APIs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reactor**: Java implementation of Reactive Streams provided by the Spring
    Pivotal team.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Spring WebFlux**: Enables the development of web applications based on reactive
    programming. Provides a programming model similar to Spring MVC.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will discuss Reactive Programming and how you can implement it with Spring
    Web Flux in [Chapter 11](116716f1-7046-4aaa-b89b-9794b6079880.xhtml), *Reactive
    Programming*.
  prefs: []
  type: TYPE_NORMAL
- en: Functional web framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building on top of the reactive features, Spring 5 also provides a functional
    web framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'A functional web framework provides features to define endpoints using functional
    programming style. A simple hello world example is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'A functional web framework can also be used to define more complex routes,
    as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'A couple of important things to note are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`RouterFunction` evaluates the matching condition to route requests to the
    appropriate handler function'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are defining three endpoints, two GETs, and one POST, and mapping them to
    different handler functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will discuss Mono and Flux in more detail in [Chapter 11](116716f1-7046-4aaa-b89b-9794b6079880.xhtml),
    *Reactive Programming.*
  prefs: []
  type: TYPE_NORMAL
- en: Java modularity with Jigsaw
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Until Java 8, the Java platform was not modular. A couple of important problems
    resulted out of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Platform Bloat**: Java modularity has not been a cause of concern in the
    last couple of decades. However, with **Internet of Things** (**IOT**) and new
    lightweight platforms such as Node.js, there is an urgent need to address the
    bloat of the Java platform. (Initial versions of JDK were less than 10 MB in size.
    Recent versions of JDK need more than 200 MB.)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**JAR Hell**: Another important concern is the problem of JAR Hell. When Java
    ClassLoader finds a class, it will not see whether there are other definitions
    for the class available. It immediately loads the first class that is found. If
    two different parts of the application need the same class from different jars,
    there is no way for them to specify the jar from which the class has to be loaded.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Open System Gateway initiative** (**OSGi**) is one of the initiatives, started
    way back in 1999, to bring modularity into Java applications.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Each module (referred to as bundle) defines the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**imports**: Other bundles that the module uses'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**exports**: Packages that this bundle exports'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each module can have its own life cycle. It can be installed, started, and stopped
    on its own.
  prefs: []
  type: TYPE_NORMAL
- en: 'Jigsaw is an initiative under **Java Community Process** (**JCP**), started
    with Java 7, to bring modularity into Java. It has two main aims:'
  prefs: []
  type: TYPE_NORMAL
- en: Defining and implementing a modular structure for JDK
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining a module system for applications built on the Java platform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jigsaw is expected to be part of Java 9 and Spring Framework 5.0 is expected
    to include basic support for Jigsaw modules.
  prefs: []
  type: TYPE_NORMAL
- en: Kotlin support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kotlin is a statically typed JVM language that enables code that is expressive,
    short, and readable. Spring framework 5.0 has good support for Kotlin.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider a simple Kotlin program illustrating a data class, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In fewer than 10 lines of code, we created and tested a data bean with three
    properties and the following functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`equals()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hashCode()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`toString()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`copy()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Kotlin is strongly typed. But there is no need to specify the type of each
    variable explicitly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Named arguments allow you to specify the names of arguments when calling methods,
    resulting in more readable code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Kotlin makes functional programming simpler by providing default variables
    (`it`) and methods such as `take`, `drop`, and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also specify default values for arguments in Kotlin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: With all its features making the code concise and expressive, we expect Kotlin
    to be a language to be learned for the .
  prefs: []
  type: TYPE_NORMAL
- en: We will discuss more about Kotlin in [Chapter 13](116716f1-7046-4aaa-b89b-9794b6079880.xhtml),
    *Working with Kotlin in Spring.*
  prefs: []
  type: TYPE_NORMAL
- en: Dropped features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spring Framework 5 is a major Spring release with substantial increase in the
    baselines. Along with the increase in baseline versions for Java, Java EE and
    a few other frameworks, Spring Framework 5 removed support for a few frameworks:'
  prefs: []
  type: TYPE_NORMAL
- en: Portlet
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Velocity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JasperReports
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: XMLBeans
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JDO
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Guava
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are using any of the preceding frameworks, it is recommended that you
    plan a migration and stay with Spring Framework 4.3--which has support until 2019.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Boot 2.0 new features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first version of Spring Boot was released in 2014\. The following are some
    of the important updates expected in Spring Boot 2.0:'
  prefs: []
  type: TYPE_NORMAL
- en: The baseline JDK version is Java 8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The baseline Spring Version is Spring Framework 5.0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Boot 2.0 has support for Reactive Web programming with WebFlux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Minimum supported versions of some important frameworks are listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Jetty 9.4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tomcat 8.5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hibernate 5.2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gradle 3.4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will discuss Spring Boot extensively in Chapter 5, *Building Microservices
    with Spring Boot* and [Chapter 7](c46a5b67-c5be-49c0-af8e-b0c4713f890b.xhtml),
    *Advanced Spring Boot Features*.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Over the course of the last decade and a half, Spring Framework has dramatically
    improved the experience of developing Java Enterprise applications. With Spring
    Framework 5.0, it brings in a lot of features while significantly increasing the
    baselines.
  prefs: []
  type: TYPE_NORMAL
- en: In the subsequent chapters, we will cover dependency injection and understand
    how we can develop web applications with Spring MVC. After that, we will move
    into the world of microservices. In Chapters 5, *Building Microservices with Spring
    Boot*, [Chapter 6](09291379-92b0-4d7d-bff7-d77e089f33db.xhtml), *Extending Microservices*,
    and [Chapter 7](c46a5b67-c5be-49c0-af8e-b0c4713f890b.xhtml), *Advanced Spring
    Boot Features*, we will cover how Spring Boot makes the creation of microservices
    simpler. We will then shift our attention to building applications in the Cloud
    with Spring Cloud and Spring Cloud Data Flow.
  prefs: []
  type: TYPE_NORMAL
