- en: The Python Automation Framework – Beyond Basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 1](2bb48797-d649-4704-85fc-0f5244ed34fb.xhtml), *Review of TCP/IP
    Protocol Suite and Python*, we looked at some of the basic structures to get Ansible
    up and running. We worked with Ansible inventory files, variables, and playbooks.
    We also looked at some examples of using network modules for Cisco, Juniper, and
    Arista devices.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will further build on the knowledge we have gained from
    the previous chapters and dive deeper into the more advanced topics of Ansible.
    Many books have been written about Ansible, and there is more to Ansible than
    we can cover in two chapters. The goal here is to introduce the majority of the
    features and functions of Ansible that I believe you will need as a network engineer
    and shorten the learning curve as much as possible.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to point out that if you were not clear on some of the points
    made in [Chapter 4](2784e1ec-c5d2-4b04-9e57-7db3caf0e310.xhtml), *The Python Automation
    Framework – Ansible Basics*, now is a good time to go back and review them as
    they are a prerequisite for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will look into the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Ansible conditionals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ansible loops
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Group and host variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Ansible Vault
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ansible roles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing your own module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have a lot of ground to cover, so let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Ansible conditionals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ansible conditionals are similar to conditional statements in programming languages.
    In [Chapter 1](2bb48797-d649-4704-85fc-0f5244ed34fb.xhtml), *Review of TCP/IP
    Protocol Suite and Python*,we saw that Python uses conditional statements to only
    execute a section of the code using `if.. then` or `while` statements. In Ansible,
    it uses conditional keywords to only run a task when the condition is met. In
    many cases, the execution of a play or task may depend on the value of a fact,
    variable, or the previous task result. For example, if you have a play to upgrading
    router images, you want to include a step to make sure the new router image is
    on the device before you move on to the next play of rebooting the router.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will discuss the `when` clause, which is supported for
    all modules, as well as unique conditional states that are supported in Ansible
    networking command modules. Some of the conditions are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Equal to (`eq`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Not equal to (`neq`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Greater than (`gt`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Greater than or equal to (`ge`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Less than (`lt`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Less than or equal to (`le`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Contains
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The when clause
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `when` clause is useful when you need to check the output of a variable
    or a play execution result and act accordingly. We saw a quick example of the
    `when` clause in [Chapter 4](2784e1ec-c5d2-4b04-9e57-7db3caf0e310.xhtml), *The
    Python Automation Framework – Ansible Basic*s, when we looked at the Ansible 2.5
    best practices structure. If you recall, the task only ran when the network operating
    system of the device was the Cisco IOS. Let''s look at another example of its
    use in `chapter5_1.yml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We have seen all the elements in this playbook before in [Chapter 4](2784e1ec-c5d2-4b04-9e57-7db3caf0e310.xhtml),
    *The Python Automation Framework – Ansible Basics**,* up to the end of the first
    task. For the second task in the play, we are using the `when` clause to check
    if the output contains the `iosv-2` keyword. If true, we will proceed to the task,
    which is using the debug module to display the output. When the playbook is run,
    we will see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that the `iosv-r1` device is skipped from the output because the
    clause did not pass. We can further expand this example in `chapter5_2.yml` to
    only apply certain configuration changes when the condition is met:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see the execution output here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Again, note in the execution output that `ios-r2` was the only change applied
    while `ios-r1` was skipped. In this case, the logging buffer size was only changed
    on `ios-r2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `when` clause is also very useful in situations when the setup or facts
    module is used – you can act based on some of the `facts` that were gathered initially.
    For example, the following statement will ensure that only the Ubuntu host with
    major release `16` will be acted upon by placing a conditional statement in the
    clause:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: For more conditionals, check out the Ansible conditionals documentation ([http://docs.ansible.com/ansible/playbooks_conditionals.html](http://docs.ansible.com/ansible/playbooks_conditionals.html)).
  prefs: []
  type: TYPE_NORMAL
- en: Ansible network facts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Prior to 2.5, Ansible networking shipped with a number of network-specific fact
    modules. The network fact modules exist, but the naming and usage was different
    between vendors. Starting with version 2.5, Ansible started to standardize its
    network fact module usage. The Ansible network fact modules gather information
    from the system and store the results in facts prefixed with `ansible_net_`. The
    data collected by these modules is documented in the *return values* in the module
    documentation. This is a pretty big milestone for Ansible networking modules,
    as it does a lot of the heavy lifting for you to abstract the fact-gathering process
    by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use the same structure we saw in [Chapter 4](2784e1ec-c5d2-4b04-9e57-7db3caf0e310.xhtml),
    *The Python Automation Framework – Ansible Basics*, Ansible 2.5 best practices,
    but expand upon it to see how the `ios_facts` module was used to gather facts.
    As a review, our inventory file contains two iOS hosts with the host variables
    residing in the `host_vars` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Our playbook will have three tasks. The first task will use the `ios_facts`
    module to gather facts for both of our network devices. The second task will display
    certain facts gathered and stored for each of the two devices. You will see that
    the facts we displayed were the default `ansible_net` facts, as opposed to a registered
    variable from the first task. The third task will display all the facts we collected
    for the `iosv-1` host:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run the playbook, you can see that the result for the first two tasks
    were what we would have expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The third task will display all the network device facts gathered for iOS devices.
    There is a ton of information that has been gathered for iOS devices that can
    help with your networking automation needs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The network facts module in Ansible 2.5 was a big step forward in streamlining
    your workflow and brought it on par with other server modules.
  prefs: []
  type: TYPE_NORMAL
- en: Network module conditional
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s take a look at another network device conditional example by using the
    comparison keyword we saw at the beginning of this chapter. We can take advantage
    of the fact that both IOSv and Arista EOS provide the outputs in JSON format for
    the `show` commands. For example, we can check the status of the interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'If we have an operation that we want to perform and it depends on `Ethernet1/3`
    being disabled in order to have no user impact, such as to ensure no users are
    actively connected to `Ethernet1/3`, we can use the following tasks in the `chapter5_3.yml` playbook.
    It uses the `eos_command` module to gather the interface state output, and checks
    the interface status using the `waitfor`  and `eq` keywords before proceeding
    to the next task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Upon the condition being met, the second task will be executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If the interface is active, an error will be given as follows following the
    first task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Check out the other conditions such as `contains`, `greater than`, and `less
    than`, as they fit into your situation.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible loops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Ansible provides a number of loops in the playbook, such as standard loops,
    looping over files, subelements, do-until, and many more. In this section, we
    will look at two of the most commonly used loop forms: standard loops and looping
    over hash values.'
  prefs: []
  type: TYPE_NORMAL
- en: Standard loops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Standard loops in playbooks are often used to easily perform similar tasks
    multiple times. The syntax for standard loops is very easy: the `{{ item }}` variable
    is the placeholder looping over the `with_items` list. For example, take a look
    at the following section in the `chapter5_4.yml` playbook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'It will loop over the five list items with the same `echo` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We will combine the standard loop with the network command module in the `chapter5_5.yml` playbook
    to add multiple VLANs to the device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The `with_items` list can also be read from a variable, which gives greater
    flexibility to the structure of your playbook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The standard loop is a great time saver when it comes to performing redundant
    tasks in a playbook. It also makes the playbook more readable by reducing the
    lines required for the task.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will take a look at looping over dictionaries.
  prefs: []
  type: TYPE_NORMAL
- en: Looping over dictionaries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Looping over a simple list is nice. However, we often have an entity with more
    than one attribute associated with it. If you think about the `vlan` example in
    the last section, each `vlan` would have several unique attributes to it, such
    as the `vlan` description, the gateway IP address, and possibly others. Oftentimes,
    we can use a dictionary to represent the entity to incorporate multiple attributes
    to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s expand on the `vlan` example in the last section for a dictionary example
    in `chapter5_6.yml`. We defined the dictionary values for three `vlans`, each
    with a nested dictionary for the description and the IP address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We can configure the first task, `add vlans`, by using the key of the each
    of items as the `vlan` number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We can proceed with configuring the `vlan` interfaces. Note that we use the `parents` parameter
    to uniquely identify the section the commands should be checked against. This
    is due to the fact that the description and the IP address are both configured
    under the `interface vlan <number>` subsection in the configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Upon execution, you will see the dictionary being looped through:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s check if the intended configuration is applied to the device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: For more loop types of Ansible, feel free to check out the documentation ([http://docs.ansible.com/ansible/playbooks_loops.html](http://docs.ansible.com/ansible/playbooks_loops.html)).
  prefs: []
  type: TYPE_NORMAL
- en: Looping over dictionaries takes some practice the first few times you use them.
    But just like standard loops, looping over dictionaries will be an invaluable
    tool in your tool belt.
  prefs: []
  type: TYPE_NORMAL
- en: Templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For as long as I can remember, working as a network engineer, I have always
    used a kind of network template. In my experience, many of the network devices
    have sections of the network configuration that are identical, especially if these
    devices serve the same role in the network.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the time, when we need to provision a new device, we use the same configuration
    in the form of a template, replace the necessary fields, and copy the file over
    to the new device. With Ansible, you can automate all of the work by using the
    template module ([http://docs.ansible.com/ansible/template_module.html](http://docs.ansible.com/ansible/template_module.html)).
  prefs: []
  type: TYPE_NORMAL
- en: The base template file we are using utilizes the Jinja2 template language ([http://jinja.pocoo.org/docs/](http://jinja.pocoo.org/docs/)).
    We briefly discussed the Jinja2 templating language in [Chapter 4](2784e1ec-c5d2-4b04-9e57-7db3caf0e310.xhtml),
    *The Python Automation Framework – Ansible Basics*, and we will look at it a bit
    more here. Just like Ansible, Jinja2 has its own syntax and method of doing loops
    and conditionals; fortunately, we just need to know the very basics of it for
    our purpose. The Ansible template is an important tool that we will be using in
    our daily task, and we will spend more of this section exploring it. We will learn
    the syntax by gradually building up our playbook from simple to more complex.
  prefs: []
  type: TYPE_NORMAL
- en: The basic syntax for template usage is very simple; you just need to specify
    the source file and the destination location that you want to copy it to.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create an empty file for now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we will use the following playbook to copy `file1` to `file2`. Note that
    the playbook is executed on the control machine only. Next, we will specify the
    path of both the source and destination files as arguments for the `template`
    module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We do not need to specify a host file during playbook execution since the localhost
    is available by default. However, you will get a warning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The source file can have any extension, but since they are processed through
    the Jinja2 template engine, let''s create a text file called `nxos.j2` as the
    template source. The template will follow the Jinja2 convention of using double
    curly brace to specify the variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The Jinja2 template
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s also modify the playbook accordingly. In `chapter5_8.yml`, we will make
    the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: Change the source file to `nxos.j2`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the destination file to be a variable
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Provide the variable values as a dictionary that we will substitute in the
    template:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'After running the playbook, you will find the destination file called `nx-osv-1.conf`
    with the values filled in and ready to be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Jinja2 loops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can also loop through a list as well as a dictionary in Jinja2\. We will
    use both as loops in `nxos.j2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Provide the additional list and dictionary variables in the `chapter5_8.yml`
    playbook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Run the playbook, and you will see the configuration for both `vlan` and `vlan_interfaces`
    filled in on the router config.
  prefs: []
  type: TYPE_NORMAL
- en: The Jinja2 conditional
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Jinja2 also supports an `if` conditional check. Let''s add this field in for
    turning on the netflow feature for certain devices. We will add the following
    to the `nxos.j2` template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We will list out the difference in the playbook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The last step we will undertake is to make `nxos.j2` more scalable by placing
    the `vlan` interface section inside of a `true-false` conditional check. In the
    real world, more often than not, we will have multiple devices with knowledge
    of the `vlan` information, but only one device as the gateway for client hosts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We will also add a second device, called `nx-osv-2`, in the playbook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We are now ready to run our playbook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s check the differences in the two configuration files to make sure that
    the conditional changes are taking place:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Neat, huh? This can certainly save us a ton of time for something that required
    repeated copy and paste before. Personally, the template module was a big game
    changer for me. This module alone was enough to motivate me to learn and use Ansible
    a few years ago.
  prefs: []
  type: TYPE_NORMAL
- en: Our playbook is getting kind of long. In the next section, we will see how we
    can optimize the playbook by offloading the variable files into groups and directories.
  prefs: []
  type: TYPE_NORMAL
- en: Group and host variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Note that, in the previous playbook, `chapter5_8.yml`, we have repeated ourselves
    in the username and password variables for the two devices under the `nexus_devices`
    variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This is not ideal. If we ever need to update the username and password values,
    we will need to remember to update at two locations. This increases the management
    burden as well as the chances of making mistakes. For a best practice, Ansible
    suggests that we use the `group_vars` and `host_vars` directories to separate
    out the variables.
  prefs: []
  type: TYPE_NORMAL
- en: For more Ansible best practices, check out [http://docs.ansible.com/ansible/playbooks_best_practices.html](http://docs.ansible.com/ansible/playbooks_best_practices.html).
  prefs: []
  type: TYPE_NORMAL
- en: Group variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By default, Ansible will look for group variables in the same directory as the
    playbook called `group_vars` for variables that can be applied to the group. By
    default, it will look for the filename that matches the group name in the inventory
    file. For example, if we have a group called `[nexus-devices]` in the inventory
    file, we can have a file under `group_vars` named `nexus-devices` to house all
    the variables that can be applied to the group.
  prefs: []
  type: TYPE_NORMAL
- en: We can also use a special file named `all` to include variables applied to all
    the groups.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will utilize this feature for our username and password variables. First,
    we will create the `group_vars` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can create a YAML file called `all` to include the username and password:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then use variables for the playbook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Host variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can further separate out the host variables in the same format as the group
    variables. This was how we were able to apply the variables in the Ansible 2.5
    playbook examples in [Chapter 4](2784e1ec-c5d2-4b04-9e57-7db3caf0e310.xhtml),
    *The Python Automation Framework – Ansible Basics*, and earlier in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'In our case, we execute the commands on the localhost, and so the file under
    `host_vars` should be named accordingly, such as `host_vars/localhost`. In our
    `host_vars/localhost` file, we can also keep the variables declared in `group_vars`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'After we separate out the variables, the playbook now becomes very lightweight
    and only consists of the logic of our operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The `group_vars` and `host_vars` directories not only decrease our operations
    overhead, they can also help with securing the files by allowing us to encrypt
    the sensitive information with Ansible Vault, which we will look at next.
  prefs: []
  type: TYPE_NORMAL
- en: The Ansible Vault
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you can see from the previous section, in most cases, the Ansible variable
    provides sensitive information such as a username and password. It would be a
    good idea to put some security measures around the variables so that we can safeguard
    against them. The Ansible Vault ([https://docs.ansible.com/ansible/2.5/user_guide/vault.html](https://docs.ansible.com/ansible/2.5/user_guide/vault.html))
    provides encryption for files so they appear in plaintext.
  prefs: []
  type: TYPE_NORMAL
- en: 'All Ansible Vault functions start with the `ansible-vault` command. You can
    manually create an encrypted file via the create option. You will be asked to
    enter a password. If you try to view the file, you will find that the file is
    not in clear text. If you have downloaded the book example, the password I used
    was just the word *password*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'To edit or view an encrypted file, we will use the `edit` option for edit or
    view the file via the `view` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s encrypt the `group_vars/all and host_vars/localhost` variable files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when we run the playbook, we will get a decryption failed error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'We will need to use the `--ask-vault-pass` option when we run the playbook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The decryption will happen in memory for any Vault-encrypted files that are
    accessed.
  prefs: []
  type: TYPE_NORMAL
- en: Prior to Ansible 2.4, Ansible Vault required all the files to be encrypted with
    the same password. Since Ansible 2.4 and later, you can use vault ID to supply
    a different password file ([https://docs.ansible.com/ansible/2.5/user_guide/vault.html#multiple-vault-passwords](https://docs.ansible.com/ansible/2.5/user_guide/vault.html#multiple-vault-passwords)).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also save the password in a file and make sure that the specific file
    has restricted permission:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then execute the playbook with the `--vault-password-file` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also encrypt just a string and embed the encrypted string inside of
    the playbook by using the `encrypt_string` option ([https://docs.ansible.com/ansible/2.5/user_guide/vault.html#use-encrypt-string-to-create-encrypted-variables-to-embed-in-yaml](https://docs.ansible.com/ansible/2.5/user_guide/vault.html#use-encrypt-string-to-create-encrypted-variables-to-embed-in-yaml)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The string can then be placed in the playbook file as a variable. In the next
    section, we will optimize our playbook even further with `include` and `roles`.
  prefs: []
  type: TYPE_NORMAL
- en: The Ansible include and roles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The best way to handle complex tasks is to break them down into smaller pieces.
    Of course, this approach is common in both Python and network engineering. In
    Python, we break complicated code into functions, classes, modules, and packages.
    In networking, we also break large networks into sections such as racks, rows,
    clusters, and datacenters. In Ansible, we can use `roles` and `includes` to segment
    and organize a large playbook into multiple files. Breaking up a large Ansible
    playbook simplifies the structure as each of the files focuses on fewer tasks.
    It also allows the sections of the playbook to be reused.
  prefs: []
  type: TYPE_NORMAL
- en: The Ansible include statement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the playbook grows in size, it will eventually become obvious that many of
    the tasks and plays can be shared across different playbooks. The Ansible `include`
    statement is similar to many Linux configuration files that just tell the machine
    to extend the file the same way as if the file was directly written in. We can
    use an `include` statement for both playbooks and tasks. Here, we will look at
    a simple example of extending our task.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s assume that we want to show outputs for two different playbooks. We
    can make a separate YAML file called `show_output.yml` as an additional task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can reuse this task in multiple playbooks, such as in `chapter5_11_1.yml`,
    which looks largely identical to the last playbook with the exception of registering
    the output and the include statement at the end:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Another playbook, `chapter5_11_2.yml`, can reuse `show_output.yml` in the same
    way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Note that both playbooks use the same variable name, `output`, because in `show_output.yml`,
    we hard coded the variable name for simplicity. You can also pass variables into
    the included file.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible roles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ansible roles separate the logical function with a physical host to fit your
    network better. For example, you can construct roles such as spines, leafs, core,
    as well as Cisco, Juniper, and Arista. The same physical host can belong to multiple
    roles; for example, a device can belong to both Juniper and the core. This flexibility
    allows us to perform operations, such as upgrade all Juniper devices, without
    worrying about the device's location in the layer of the network.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible roles can automatically load certain variables, tasks, and handlers
    based on a known file infrastructure. The key is that this is a known file structure
    that we automatically include. In fact, you can think of roles as pre-made `include`
    statements by Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: The Ansible playbook role documentation ([http://docs.ansible.com/ansible/playbooks_roles.html#roles](http://docs.ansible.com/ansible/playbooks_roles.html#roles))
    describes a list of role directories that we can configure. We do not need to
    use all of them. In our example, we will only modify the `tasks and the vars`
    folders. However, it is good to know all of the available options in the Ansible
    role directory structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is what we will use as an example for our roles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see that, at the top level, we have the hosts file as well as the playbooks.
    We also have a folder named `roles`. Inside the folder, we have two roles defined:
    `cisco_nexus` and `spines`. Most of the subfolders under the roles were empty,
    with the exception of the `tasks and vars` folders. There is a file named `main.yml`
    inside each of them. This is the default behavior: the `main.yml` file is your
    entry point that is automatically included in the playbook when you specify the
    role in the playbook. If you need to break out additional files, you can use the
    include statement in the `main.yml` file.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is our scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: We have two Cisco Nexus devices, `nxos-r1` and `nxos-r2`. We will configure
    the logging server as well as the log link-status for all of them, utilizing the
    `cisco_nexus` role for them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition, nxos-r1 is also a spine device, where we will want to configure
    more verbose logging, perhaps because spines are at a more critical position within
    our network.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For our `cisco_nexus` role, we have the following variables in `roles/cisco_nexus/vars/main.yml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'We have the following configuration tasks in `roles/cisco_nexus/tasks/main.yml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Our playbook is extremely simple, as it just needs to specify the hosts that
    we would like to configure according to `cisco_nexus role`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: When you run the playbook, the playbook will include the tasks and variables
    defined in the `cisco_nexus` role and configure the devices accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our `spine` role, we will have an additional task of more verbose logging
    in `roles/spines/tasks/mail.yml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'In our playbook, we can specify that it contains both the role of `cisco_nexus`
    as well as `spines`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'When we include both roles in this order, the `cisco_nexus` role tasks will
    be executed, followed by the spines role:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Ansible roles are flexible and scalable – just like Python functions and classes.
    Once your code grows beyond a certain level, it is almost always a good idea to
    break it into smaller pieces for maintainability.
  prefs: []
  type: TYPE_NORMAL
- en: You can find more examples of roles in the Ansible examples Git repository at
    [https://github.com/ansible/ansible-examples](https://github.com/ansible/ansible-examples).
  prefs: []
  type: TYPE_NORMAL
- en: '**Ansible Galaxy** ([https://docs.ansible.com/ansible/latest/reference_appendices/galaxy.html](https://docs.ansible.com/ansible/latest/reference_appendices/galaxy.html))
    is a free community site for finding, sharing, and collaborating on roles. You
    can see an example of the Juniper networks supplied by the Ansible role on Ansible
    Galaxy:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/6809eca8-e5b1-4f7c-8fc6-f690fc747597.png)JUNOS Role on Ansible Galaxy
    ( [https://galaxy.ansible.com/Juniper/junos](https://galaxy.ansible.com/Juniper/junos))'
  prefs: []
  type: TYPE_IMG
- en: In the next section, we will take a look at how to write our own custom Ansible
    module.
  prefs: []
  type: TYPE_NORMAL
- en: Writing your own custom module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By now, you may get the feeling that network management in Ansible is largely
    dependent on finding the right module for your task. There is certainly a lot
    of truth in that logic. Modules provide a way to abstract the interaction between
    the managed host and the control machine; they allow us to focus on the logic
    of our operations. Up to this point, we have seen the major vendors providing
    a wide range of modules for Cisco, Juniper, and Arista.
  prefs: []
  type: TYPE_NORMAL
- en: Use the Cisco Nexus modules as an example, besides specific tasks such as managing
    the BGP neighbor (`nxos_bgp`) and the aaa server (`nxos_aaa_server`). Most vendors
    also provide ways to run arbitrary show (`nxos_config`) and configuration commands
    (`nxos_config`). This generally covers most of our use cases.
  prefs: []
  type: TYPE_NORMAL
- en: Starting with Ansible 2.5, there is also the streamline naming and usage of
    network facts modules.
  prefs: []
  type: TYPE_NORMAL
- en: What if the device you are using does not currently have the module for the
    task that you are looking for? In this section, we will look at several ways that
    we can remedy this situation by writing our own custom module.
  prefs: []
  type: TYPE_NORMAL
- en: The first custom module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Writing a custom module does not need to be complicated; in fact, it doesn't
    even need to be in Python. But since we are already familiar with Python, we will
    use Python for our custom modules. We are assuming that the module is what we
    will be using ourselves and our team without submitting back to Ansible, therefore
    we will ignore some of the documentation and formatting for the time being.
  prefs: []
  type: TYPE_NORMAL
- en: If you are interested in developing modules that can be submitted upstream to
    Ansible, please consult the developing modules guide from Ansible ([https://docs.ansible.com/ansible/latest/dev_guide/developing_modules.html](https://docs.ansible.com/ansible/latest/dev_guide/developing_modules.html)).
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, if we create a folder named `library` in the same directory as
    the playbook, Ansible will include the directory in the module search path. Therefore,
    we can put our custom module in the directory and we will be able to use it in
    our playbook. The requirement for the custom module is very simple: all the module
    needs is to return a JSON output to the playbook.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall that in [Chapter 3](d2c76e60-c005-4efc-85de-c7a3253e4b47.xhtml), *APIs
    and Intent-Driven Networking*, we used the following NXAPI Python script to communicate
    to the NX-OS device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'When we executed it, we simply received the system version. We can simply modify
    the last line to be a JSON output, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'We will place this file under the `library` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'In our playbook, we can then use the action plugin ([https://docs.ansible.com/ansible/dev_guide/developing_plugins.html](https://docs.ansible.com/ansible/dev_guide/developing_plugins.html)),
    `chapter5_14.yml`, to call this custom module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that, just like the `ssh` connection, we are executing the module locally
    with the module making API calls outbound. When you execute this playbook, you
    will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, you can write any module that is supported by API, and Ansible
    will happily take any returned JSON output.
  prefs: []
  type: TYPE_NORMAL
- en: The second custom module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building upon the last module, let's utilize the common module boilerplate from
    Ansible that's stated in the module development documentation ([http://docs.ansible.com/ansible/dev_guide/developing_modules_general.html](http://docs.ansible.com/ansible/dev_guide/developing_modules_general.html)).
    We will modify the last custom module and create `custom_module_2.py` to ingest
    inputs from the playbook.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will import the boilerplate code from `ansible.module_utils.basic`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'From there, we can define the main function where we will house our code. `AnsibleModule`,
    which we have already imported, provides lots of common code for handling returns
    and parsing arguments. In the following example, we will parse three arguments
    for `host`, `username`, and `password`, and make them required fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'The values can then be retrieved and used in our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we will follow the exit code and return the value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Our new playbook, `chapter5_15.yml`, will look identical to the last playbook,
    except now we can pass values for different devices in the playbook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: When executed, this playbook will produce the exact same output as the last
    playbook. However, because we are using arguments in the custom module, the custom
    module can now be passed around for other people to use without them knowing the
    details of our module. They can write in their own username, password, and host
    IP in the playbook.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, this is a functional but incomplete module. For one, we did not perform
    any error checking, nor did we provide any documentation for usage. However, it
    is a good demonstration of how easy it is to build a custom module. The additional
    benefit is that we saw how we can use an existing script that we already made
    and turn it into a custom Ansible module.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered a lot of ground. Building from our previous knowledge
    of Ansible, we expanded into more advanced topics such as conditionals, loops,
    and templates. We looked at how to make our playbook more scalable with host variables,
    group variables, include statements, and roles. We also looked at how to secure
    our playbook with the Ansible Vault. Finally, we used Python to make our own custom
    modules.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible is a very flexible Python framework that can be used for network automation.
    It provides another abstraction layer separated from the likes of the Pexpect
    and API-based scripts. It is declarative in nature in that it is more expressive
    in terms of matching our intent. Depending on your needs and network environment,
    it might be the ideal framework that you can use to save time and energy.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 6](30262891-a82e-4bef-aae2-2e8fe530a16f.xhtml), *Network Security
    with Python*, we will look at network security with Python.
  prefs: []
  type: TYPE_NORMAL
