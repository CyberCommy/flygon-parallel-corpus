- en: Navigation Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The crucial part of almost every application is navigation. To this day, this
    topic gives headaches to many React Native developers. Let’s see which libraries
    are available and which one will suit your project. This chapter starts with a
    breakdown of the available libraries. Then, we will introduce a new project and
    play with it. We will focus on one library at a time. Once we finish this, I will
    walk you through the patterns that are used, and what these imply, while you write
    the navigation code. Remember to try the code on your machine and your phone.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn about the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Why are there many alternative libraries for routing in React Native?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are the challenges that navigation libraries face?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is the difference between native navigation and JavaScript navigation?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use Tab navigation, Drawer navigation, and Stack navigation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The basics of native solutions: you will eject the Create React Native App
    for the first time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: React Native navigation alternatives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Usually, if you are a beginner and you try to Google for *React Native navigation*,
    you will end up with a headache. The number of available alternatives is high.
    There are a few reasons why this is so:'
  prefs: []
  type: TYPE_NORMAL
- en: Some early libraries are not maintained anymore, as maintainers have simply
    quit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some companies with resources started a library and then changed their employees
    focus to other things
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some solutions are proven to be inefficient, or a better solution is implemented
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is an architectural reason for different approaches, which leads to a
    need to maintain different solutions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will focus on the last point here, as it is vital to understand which library
    fits your needs. We will discuss the solutions so that, at the end of this chapter,
    you will know which library to choose for your project.
  prefs: []
  type: TYPE_NORMAL
- en: Designers navigation patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we dive into the world of libraries, I would like to show you different
    ways of designing navigation in your application. Usually, this is work for the
    project's designer; however, once you understand the trade-offs, it will be easier
    to add a code pattern layer on top of it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The mobile app consists of screens and transitions. Altogether, these can be
    represented by the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/d751e3ad-7a4c-4b30-b7ae-8e0143930d68.png)'
  prefs: []
  type: TYPE_IMG
- en: This is an example diagram representing the screens of a tasks application
  prefs: []
  type: TYPE_NORMAL
- en: 'The main takeaways from the preceding diagram are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Each app consists of top-level screens (**Homepage**, **Projects**, and **Search**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From top-level screens, you can navigate forward and deeper down the tree (**Projects**
    => **Project task list**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sometimes, you transition backwards (**Task** => **Project task list**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With this in mind, let's look into the components that will help us make these
    transitions.
  prefs: []
  type: TYPE_NORMAL
- en: Navigation to top-level screens
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Navigation to top-level screens is usually done using one or more of the following
    three alternatives:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Classical bottom navigation, like the one we already implemented. This usually
    uses icons or a combination of icons and text. Depending on the choice made, this allows
    us to place between two to five links. This is usually avoided on tablet designs:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](Images/6f7d2d47-ab2f-4f80-80ac-53b235e4d5d2.png)'
  prefs: []
  type: TYPE_IMG
- en: An example of classic bottom navigation
  prefs: []
  type: TYPE_NORMAL
- en: 'The navigation drawer, opened from the side of the screen. This contains a
    list of links, possibly more than five. This can be sophisticated and can include
    a user profile at the top. This tends to be opened by a hamburger icon placed
    in one of the upper corners:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](Images/b6344c65-d72c-4d1c-a21d-ea7dcf667f36.png)'
  prefs: []
  type: TYPE_IMG
- en: An example of drawer navigation
  prefs: []
  type: TYPE_NORMAL
- en: Tabs, which are placed at the top of the screen and appear as pairs, at the
    least. The number of tabs can exceed four, and in such a case, tabs can be scrolled
    horizontally. This is used not only for top-level navigation, but for any navigation
    between screens of the same depth.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Navigating between different levels of the graph
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once we reach a certain level, sometimes we want to explore that particular
    area even further. In the case of the Tasks application, this would mean choosing
    a project or choosing a specific task within the project itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Usually, to navigate down the graph, we use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Containers, including lists, cards, image list, and image cards
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simple buttons, text links, or icons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'However, to go back up the graph, usually we use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A back icon, such as an arrow, usually positioned  in the upper left corner
    or bottom left corner
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A button or link, with text such as back | cancel | start over
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A cross icon positioned in the relevant part of the edit/create screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To some of you, this knowledge comes naturally; however, I have bumped into
    proposals or early drafts of designs that clearly confused these concepts and,
    in the end, terribly affected the user experience. Experimenting is good, but
    only in a controlled environment that uses standard and well-known patterns, which
    feel natural for most of the users.
  prefs: []
  type: TYPE_NORMAL
- en: For experimenting with design, you should implement A/B tests. These require
    the ability to run different versions of the app in production for different subsets
    of users. Thanks to analytics, you can later assess whether A or B was a better
    choice. Finally, all of the users can be migrated to the winning scenario.
  prefs: []
  type: TYPE_NORMAL
- en: Navigating on the same level of the graph
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In more complex apps, aside from the top-level navigation, you will also need
    to horizontally transition between different screens that are on the same depth.
  prefs: []
  type: TYPE_NORMAL
- en: 'To transition between screens on the same level, you can use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Tabs, similar to that discussed in the top-level navigation section
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Screen swipes (literally swiping between screens)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Swiping in a container (for instance, to see either task description, connected
    tasks or task, comments) can be connected with tabs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Left or right arrows, or dots indicating your position within the level
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Similarly, you can use these for collections of data too. Collections of data,
    however, provide more freedom to use lists or less constrained containers that
    take advantage of top/bottom swipes, too.
  prefs: []
  type: TYPE_NORMAL
- en: Bearing in mind how designers are solving problems of navigation, let's now
    discuss how to make it performant and how to maintain the navigation graph.
  prefs: []
  type: TYPE_NORMAL
- en: Developers' navigation patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To be honest, it all comes down to this—is a JavaScript implementation good
    enough? If so, let''s use it for our benefit (that is, tracking, control in JavaScript,
    logs, and so on). Over time, it looks like the React Native community managed
    to create something stable, called React Navigation:'
  prefs: []
  type: TYPE_NORMAL
- en: '"React Navigation is entirely made up of React components and the state is
    managed in JavaScript on the same thread as the rest of your app. This is what
    makes React Navigation great in many ways but it also means that your app logic
    contends for CPU time with React Navigation — there''s only so much JavaScript
    execution time available per frame."'
  prefs: []
  type: TYPE_NORMAL
- en: '- React Navigation official documentation, available at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://reactnavigation.org/docs/en/limitations.html](https://reactnavigation.org/docs/en/limitations.html).'
  prefs: []
  type: TYPE_NORMAL
- en: However, as discussed in the preceding quote, this competes with your application
    for CPU cycles. This means it is draining resources and slowing down the application
    to some extent.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pros of JavaScript navigation are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: You can tweak and extend the solution using JavaScript code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Current implementations are performant enough for small to medium apps.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The state is managed in JavaScript and easily integrates with state management
    libraries such as Redux.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The API is decoupled from native APIs. This means that if React Native eventually
    goes beyond Android and iOS, the API will stay the same, and once implemented
    by the library maintainers, this will enable you to use the same solution for
    yet another platform.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easy to learn.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Good for beginners.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Cons of JavaScript navigation are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: It is very tough to implement in a performant way.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It may still be too slow for large applications.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some animations slightly differ from the native ones.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some gestures or animations may be entirely different than the native ones (for
    instance, if the native system changes the defaults, or there is inconsistency
    because of historical changes).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is hard to integrate with native code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Routing should be static, as per current documentation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some solutions, which you would expect to be present if you have ever created
    native navigation, may not be available (for instance, a connection with the native
    lifecycle).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Limited international support (for instance, as of July 2018, the Right-to-Left
    is not supported by some JavaScript navigation libraries, including React Navigation).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the other hand, let's look at Native navigation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pros of Native navigation are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Native navigation can be optimized by the system library that may, for instance,
    containerize navigation stacks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Native navigation outperforms JavaScript navigation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It leverages each system's unique capabilities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ability to leverage the native life cycle and hook to it with animations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most implementations integrate with state management libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Cons of Native navigation are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes it defeats React Native's purpose – it diverges navigation across
    systems, instead unifying it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is tough to provide a consistent API across platforms, or it is even not
    consistent at all.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Single source of truth is no longer true – our state leaks to the native code
    that manages the state internally within the specific platform. This kills time-traveling.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Problematic state synchronization – the chosen library either does not promise
    immediate state synchronization at all, or implements different locks that slow
    down the application to an extent that usually kills the purpose.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some experts argue that developers of NavigatorIOS library (as of July 2018,
    still mentioned in official React Native documentation) did a great job of working
    on it, but its future is uncertain.
  prefs: []
  type: TYPE_NORMAL
- en: It requires working with tools and configuration of the native systems.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is aimed at experienced developers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You need to take into account all of this and make the right trade-offs before
    choosing either one. But before we dive into the code, please focus on the next
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Restructuring your application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: No-one likes huge monolithic code bases with all features intertwined. What
    can we do to prevent this as the application grows? Make sure to wisely locate
    code files and have a standardized way of doing so.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of a monolithic code base that will cause you a headache once it
    surpasses 10,000 lines is the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/20583eb7-7b0d-4ace-9024-327e5662b0ff.png)'
  prefs: []
  type: TYPE_IMG
- en: An example of a directory structure that is not good enough for large projects
  prefs: []
  type: TYPE_NORMAL
- en: Imagine one directory with 1,200 reducers to scroll through. You would probably
    use search instead. Believe me, this also becomes tough with 1,200 reducers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, it is much better to group code by features. Thanks to this, we will
    have a clear scope of files to look at while investigating a certain isolated
    part of the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/44efa3e0-6d89-497a-be46-6d182e8ce91a.png)'
  prefs: []
  type: TYPE_IMG
- en: An example of a directory structure that may be good for medium to large projects
  prefs: []
  type: TYPE_NORMAL
- en: To see this new structure in action, please check the code files of `Example
    1` from the `src` folder in  [Chapter 7](f5f1ab36-54de-49a6-b245-e0145fe78bf0.xhtml), *Navigation
    Patterns*.
  prefs: []
  type: TYPE_NORMAL
- en: If you have ever worked with microservices, think of it as if you wanted your
    features to be simple micro services within your frontend code base. A screen
    may ask them to operate by sending data, and expects a certain output.
  prefs: []
  type: TYPE_NORMAL
- en: In some architectures, every such entity also creates its own Flux store. This
    is a good separation of concerns for large projects.
  prefs: []
  type: TYPE_NORMAL
- en: React Navigation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Browsers have a navigation solution baked in, React Native needs to have an
    own one, and there is a reason behind this:'
  prefs: []
  type: TYPE_NORMAL
- en: '"In a web browser, you can link to different pages using an anchor (<a>) tag.
    When the user clicks on a link, the URL is pushed to the browser history stack.
    When the user presses the back button, the browser pops the item from the top
    of the history stack, so the active page is now the previously visited page. React
    Native doesn''t have a built-in idea of a global history stack like a web browser
    does -- this is where React Navigation enters the story."'
  prefs: []
  type: TYPE_NORMAL
- en: '- React Navigation official documentation, available at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://reactnavigation.org/docs/en/hello-react-navigation.html](https://reactnavigation.org/docs/en/hello-react-navigation.html).'
  prefs: []
  type: TYPE_NORMAL
- en: To sum this up, our mobile navigation can be handled not only like that seen
    in a browser, but also in any custom way we please. This is thanks to historical
    reasons, as some screen changes are usually tied to particular animations that
    users of the specific operating system do recognize. Thus, it is wise to follow
    them as closely as possible to resemble the native feel.
  prefs: []
  type: TYPE_NORMAL
- en: Using React Navigation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start our journey with React Navigation by installing the library with
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Once the library is installed, let's try the easiest path and use a stack navigation
    system that resembles the type seen in a browser.
  prefs: []
  type: TYPE_NORMAL
- en: For those of you who do not know, or have forgotten what a stack is, the name
    stack comes from a real-life analogy to a set of items stacked on top of each
    other. Item can be pushed to the stack (placed at the top), or popped from the
    stack (taken from the top).
  prefs: []
  type: TYPE_NORMAL
- en: A special structure, pushing this idea further, resembles a horizontal stack
    with access from both the bottom and top. Such a structure is called a queue;
    however, we will not use queues in this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous section, I made a refactor of our file structure. As part of
    the refactor, I created a new file, called `TaskListScreen`, which is made up
    of features from our code base:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `withGeneralLayout` HOC is also part of the refactor and all it does is
    wrap the screen with a header and bottom bar. Such a wrapped `TaskList` component
    is ready to be called a `Screen` and be provided straight to the React Navigation
    setup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we use a `createStackNavigator` function that expects two objects:'
  prefs: []
  type: TYPE_NORMAL
- en: An object representing all of the screens that should be handled by this `StackNavigator`.
    Each of the screens should specify a component that represents this screen and
    path. You can also use `navigationOptions` to customize your screen. In our case,
    we do not want the default header bar.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An object representing the settings of the navigator itself. You probably want
    to define the initial route name and its parameters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Having done this, we have finished the hello world of navigation – we have one
    screen working.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple screens with React Navigation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s time to add a Task screen to our `StackNavigator`. Use your newly learned
    syntax and create a placeholder screen for task details. The following is my implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, I also pass `navigationOptions`, as I want to use the default navigator
    top bar with a specific title:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/65bb51fc-698b-4430-911b-02d7092141a3.png)'
  prefs: []
  type: TYPE_IMG
- en: An example of how the new Task screen could look
  prefs: []
  type: TYPE_NORMAL
- en: 'To navigate to Task Details, we will need a separate link or button that will
    take us there. Let''s create a reusable one in the top of our directory structure,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The last line in the preceding snippet uses the `withNavigation` HOC, which
    is part of React Navigation. This HOC provides the navigation prop to `NavigateButton`.
    `To`, `data`, and `text` need to be passed manually to the component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s it! Let''s look at the following result. Use your skills from [Chapter
    3,](3045eaef-f5e9-4096-accb-c7d61fc5a9c0.xhtml) *Styling Patterns*, if you feel
    the design needs a little polish:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/ed751d62-83e8-4209-a870-e3a580005433.png)'
  prefs: []
  type: TYPE_IMG
- en: Each Task row is now displaying a Details link
  prefs: []
  type: TYPE_NORMAL
- en: You can now tap the Details button to navigate to the Task Details screen.
  prefs: []
  type: TYPE_NORMAL
- en: Tab navigation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we already have the bottom icon controls in place, it will be very straightforward
    to make them work. This is a classic example for tab navigation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Please note the use of shorthand for creating screens. Instead of using an
    object, I pass the component directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/c3ca77f7-38a2-4c25-a493-303606816378.png)'
  prefs: []
  type: TYPE_IMG
- en: By default, React Navigation will create a bottom bar for us
  prefs: []
  type: TYPE_NORMAL
- en: 'To disable the bar, we need to pass the appropriate prop, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to make our icons respond to a user''s touch. First, create a `NavigateIcon`
    component that you can reuse in your app. Check the repository for a full code
    sample, but an example is provided here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'It is fairly straightforward to replace existing icons with the `NavigateIcon`,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing to take care of is the general layout. The `Search` and `Notifications`
    screens should display our custom bottom navigation. This is surprisingly easy
    thanks to the HOC pattern we have learned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The results are shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/db515245-8a78-4128-88b4-36cf98f04933.png)'
  prefs: []
  type: TYPE_IMG
- en: The Search screen with its placeholder.
  prefs: []
  type: TYPE_NORMAL
- en: Please fix the header name by adding a configuration object to the `withGeneralLayout`
    HOC.
  prefs: []
  type: TYPE_NORMAL
- en: Drawer navigation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s time to implement drawer navigation to allow users to access less commonly
    used screens, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'As we have our default drawer ready, let''s add an icon which will show it.
    The hamburger icon is the most popular, and is usually placed within one of the
    header corners:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, just place it in the header part of the `GeneralAppView` component and
    style it appropriately:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s it, our drawer is fully functional. Your drawer might look something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/d22aea70-bfc0-4cc9-8961-7ae12d831c35.png)'
  prefs: []
  type: TYPE_IMG
- en: Opened drawer menu on the iPhone X simulator.
  prefs: []
  type: TYPE_NORMAL
- en: You can open the drawer by clicking the hamburger icon in the upper right corner.
  prefs: []
  type: TYPE_NORMAL
- en: Issues with duplicated data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The task list component fetches the data necessary to display the list on its
    successful mounting. However, there is no mechanism implemented to prevent duplication
    of data. This book is not meant to provide recipes for common problems. However,
    let''s think of a few solutions you could implement:'
  prefs: []
  type: TYPE_NORMAL
- en: Change the API and rely on unique task identifiers (such as ID, UUID, or GUID).
    Make sure you filter to only allow unique ones.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clear data on every request. This is good; however, in our case we would lose
    unsaved (API-related) tasks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maintain status, and only request once. This would work in our simple use case
    only. In more complex apps, you will need to update data more often.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Okay, bearing this in mind, let's finally dive into the library based on a native
    navigation solution.
  prefs: []
  type: TYPE_NORMAL
- en: React Native Navigation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will play with a native solution for navigation. React Native
    Navigation is a wrapper on the native navigation for Android and iOS.
  prefs: []
  type: TYPE_NORMAL
- en: Our goal is to recreate what we have achieved in the previous section, but with
    React Navigation.
  prefs: []
  type: TYPE_NORMAL
- en: A few words on the setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the biggest challenges you may face in this section is setting up the
    library. Please follow the most up-to-date installation instructions. Take your
    time—it may take over 8 hours if you are not familiar with the tools and ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: Follow the installation instructions at the following link: [https://github.com/wix/react-native-navigation](https://github.com/wix/react-native-navigation).
  prefs: []
  type: TYPE_NORMAL
- en: This book uses the API from version 2 of React Native Navigation. To use the
    same code examples, you will need to install version 2 too.
  prefs: []
  type: TYPE_NORMAL
- en: You may also need to either eject Create React Native App, or bootstrap another
    project with `react-native init` and copy the key files there. If you struggle
    with the process, try using the code from `src/Chapter 7/Example 6/` (just React
    Native) or `src/Chapter 7/Example 7/` (the whole React Native Navigation setup).
    I used `react-native init` and copied all of the important stuff there.
  prefs: []
  type: TYPE_NORMAL
- en: There will be certainly errors on your path to a working setup. Don't get upset;
    search for any errors on StackOverflow or GitHub issues with React Native and
    React Native Navigation.
  prefs: []
  type: TYPE_NORMAL
- en: Basics of React Native Navigation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first big change is the lack of the `AppRegistry` and the `registerComponent`
    call. Instead, we will use `Navigation.setRoot(...)` and it will do the job. The
    `setRoot` function should only be invoked if we are certain that the application
    was launched successfully, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Our root/entry file will then only invoke the React Native Navigation function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Okay. The more interesting part is what we put into the `setRoot` function.
    Basically, we have a choice here: either stack navigation or tab navigation. Following
    our previous application, the top-level one will be tab navigation (drawer navigation
    is decoupled in React Native Navigation).'
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing this book, using the default built-in bottom bar is the
    only option to retain previous capabilities. Once library authors release version
    2 of RNN and fix `Navigation.mergeOptions(...)`, you will be able to implement
    custom bottom bars.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s remove the default top bar and customize the bottom bar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Having done that, we are ready to define the tabs. The very first thing to
    do in React Native Navigation is register the screens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'When we have all of the basic three screens registered, we can proceed with
    tab definitions, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We define every single tab out of the three – `Tasks`, `Search`, and `Notifications`.
    With regard to `Tasks`, this is another navigator. The `Stack` navigator can be
    configured as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding snippet, the `bottomTab` options set the text and icon in
    the bottom bar:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/742b3f87-12e2-4516-a3ec-fac4f7712eb2.png)'
  prefs: []
  type: TYPE_IMG
- en: The Tasks tab with React Native Navigation
  prefs: []
  type: TYPE_NORMAL
- en: Further investigation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I'll leave the investigation of how to implement navigation elements, such as
    the Drawer or Task Detail screens, to those of you who are brave enough. At the
    time of writing, React Native Navigation v2 is quite unstable and I chose not
    to publish any more snippets from this library. For most readers, this should
    be enough to get the overall feeling.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we finally expanded our application with far more views than
    before. You have learned different approaches to navigation in mobile applications.
    In the React Native world, it is either native navigation, JavaScript navigation,
    or a hybrid of the two. Along with learning navigation itself, we have used components
    including `StackNavigation`, `TabNavigation`, and `DrawerNavigation`.
  prefs: []
  type: TYPE_NORMAL
- en: For the first time, we have also ejected the Create React Native App and installed
    native code from the native navigation library. We are starting to dive really
    deeply into React Native. Now is the time to step back and refresh our JavaScript
    knowledge. We will learn patterns that are not only beneficial in React Native,
    but in JavaScript overall.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'React Navigation common mistakes – from the official documentation, available
    at:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://reactnavigation.org/docs/en/common-mistakes.html](https://reactnavigation.org/docs/en/common-mistakes.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Thousand ways to navigate in React Native, by Charles Mangwa:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.youtube.com/watch?v=d11dGHVVahk.](https://www.youtube.com/watch?v=d11dGHVVahk)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigation playground for React Navigation:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://expo.io/@react-navigation/NavigationPlayground](https://expo.io/@react-navigation/NavigationPlayground).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Expo documentation on navigation:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.expo.io/versions/v29.0.0/guides/routing-and-navigation](https://docs.expo.io/versions/v29.0.0/guides/routing-and-navigation).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Material Design on Tabs:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://material.io/design/components/tabs.html#placement](https://material.io/design/components/tabs.html#placement).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Section on Navigation within the Awesome React Native repository:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/jondot/awesome-react-native#navigation](https://github.com/jondot/awesome-react-native#navigation).'
  prefs: []
  type: TYPE_NORMAL
