- en: Chapter 5. Building a Touch Screen Application with Qt5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Qt for mobile applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing a basic user interface with QML
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Touch events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Animation in QML
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying information using model views
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating QML and C++
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Qt is not only a cross-platform software development kit for PC platforms, it
    also supports mobile platforms such as iOS and Android. The developers of Qt introduced
    Qt Quick back in 2010, which provides an easy way to build custom user interfaces
    that are highly dynamic, where users can easily create fluid transitions and effects
    with only minimal coding. Qt Quick uses a declarative scripting language called
    **QML**, which is similar to the JavaScript language used in web development.
    Advanced users can also create custom functions in C++ and port them over to Qt
    Quick to enhance its functionality. At the moment, Qt Quick supports multiple
    platforms such as Windows, Linux, Mac, iOS, and Android.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Qt for mobile applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this example, we will learn how to set up our Qt project in Qt Quick and
    enable it to be build and exported to mobile devices.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First of all, let's create a new project by going to **File** | **New File or
    New Project**. Then, a window will pop up for you to choose a project template.
    Select **Qt Quick Application** and click the **Choose** button:![How to do it…](img/B02820_05_01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After that, insert the project name and select the project location. Click the
    **Next** button and it will ask you to select the minimum Qt version required
    for your project. Please make sure that you select a version that exists on your
    computer, otherwise you won't be able to run it properly. Once you have done that,
    proceed by clicking the **Next** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, Qt Creator will ask you which **kit** you want to use for your project.
    These "kits" are basically different compilers that you can use to compile your
    project for different platforms. Since we're doing an application for a mobile
    platform, we will enable the Android kit (or the iOS kit if you're running a Mac)
    in order to build and export your app to your mobile device. Do note that you
    need to configure the Android kit if you're using it for the first time, so that
    Qt can find the directory of the Android SDK. Click **Next** once you're done
    with it:![How to do it…](img/B02820_05_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once the project has been created, Qt Creator will automatically open up a
    file from your project, called `main.qml`. You will see something like this on
    screen, which is very different from your usual C/C++ project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Build and run the project now by clicking on the green arrow button located
    at the bottom-left corner of your Qt Creator. If you set the default kit to **Desktop**,
    a window will pop up which looks something like this:![How to do it…](img/B02820_05_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can switch between different kits by going to the **Projects** interface
    and selecting the kit you want your project to be built with. You can also manage
    all the kits available on your computer, or add a new kit to your project from
    the **Projects** interface:![How to do it…](img/B02820_05_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If this is your first time building and running your project, you need to create
    a template for the Android kit under the **Build** settings. Once you have clicked
    the **Create Templates** button, Qt will generate all the files required to run
    your app on an Android device. If you don't plan to use Gradle in your project,
    disable the option **Copy the Gradles files to Android directory**. Otherwise,
    you may encounter problems when trying to compile and deploy your app to your
    mobile device:![How to do it…](img/B02820_05_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you have created the template, press the **Run** button and now you should
    see a window popping up, asking which device it should export to:![How to do it…](img/B02820_05_06.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the device that is currently connected to your computer and press the
    **OK** button. Wait for a while for it to build the project, and you should see
    something like this on your mobile device:![How to do it…](img/B02820_05_07.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A Qt Quick application project is quite different from a form application project.
    You will be writing QML script most of the time instead of writing C/C++ code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Android Software** **Development Kit** (**SDK**), **Android** **Native
    Development Kit** (**NDK**), **Java** **Development Kit** (**JDK**), and **Apache
    Ant** are required to build and export your app to the Android platform. Alternatively,
    you can also use Gradle instead of Apache Ant for your Android kit. All you need
    to do is to enable the **Use Gradle instead of Ant** option and provide Qt with
    Gradle''s installation path. Note that Android Studio is currently not supported
    by Qt Creator:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/B02820_05_31.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you're running the app on an Android device, make sure that you have enabled
    USB Debugging Mode. To enable USB Debugging Mode, you need to first enable the
    developer options on your Android device by going to **Settings** | **About Phone**
    and tap the **Build Number** seven times. After that, go to **Settings** | **Developer
    Options** and you will see the **Android Debugging** option in the menu. Enable
    that option and you can now export your app to your device for testing.
  prefs: []
  type: TYPE_NORMAL
- en: To build for the iOS platform, you need to run Qt Creator on a Mac and make
    sure the latest XCode is installed on your Mac as well.
  prefs: []
  type: TYPE_NORMAL
- en: To test your app on an iOS device, you need to register a developer account
    with Apple, register your device at the developer portal, and install the provisioning
    to your XCode, which is a lot trickier than Android. You will be given access
    to the developer portal once you have obtained a developer account from Apple.
  prefs: []
  type: TYPE_NORMAL
- en: Designing a basic user interface with QML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this example, we will learn how to use Qt Quick Designer to design our program's
    user interface.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First of all, create a new Qt Quick application project, just like we did in
    the previous recipe. You can also use the previous project files if you wish to.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You will see two QML files in your project resources—`main.qml` and `MainForm.ui.qml`.
    The former is where we implement the logic for our application, and the latter
    is where we design our user interface. We will start with the UI design, so let''s
    open up `MainForm.ui.qml`. Once it''s been opened by Qt Creator, you will see
    an entirely different UI editor compared to the one we used in previous chapters.
    This editor is called the Qt Quick Designer, which is used specifically to design
    UI for Qt Quick projects. The components of this editor are described as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Library**: The **Library** window displays all the predefined QML types that
    you can add to your UI canvas. You can also import custom Qt Quick components
    from the **Import** tab and display them here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Navigator**: The **Navigator** window displays the items in the current QML
    file in a tree structure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Connections**: You can use the tools provided in the **Connections** window
    to connect objects to signals, specify dynamic properties for objects, and create
    bindings between the properties of two objects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**State**: The **State** window displays the different states of an item. You
    can add a new state for an item by clicking on the **+** button on the right of
    the **State** window.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Canvas**: The canvas is where you design your program''s user interface.
    You can drag and drop a Qt Quick component from the **Library** window onto the
    canvas and instantly see what it will look like in the program.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Properties**: This is where you change the properties of a selected item.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Select everything under the **Rectangle** object (**mouseArea** and **Text**)
    in the **Navigator** window and delete them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We're about to make a simple login screen. From the **Library** window, drag
    two text widgets onto the canvas.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the text properties of both the text widgets to **Username:** and **Password:**![How
    to do it…](img/B02820_05_32.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag two rectangles from the **Library** window to the canvas, then drag two
    text input widgets onto the canvas and parent each of them to the rectangles you
    just added to the canvas. Set the `border` property of the rectangles to `1` and
    the `radius` to `5`. Then, set the `echo mode` of one of the text fields to `Password`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we're going to manually create a button widget by combining a mouse area
    widget with a rectangle and a text widget. Drag a mouse area widget onto the canvas,
    then drag a rectangle and a text widget onto the canvas and parent them both to
    the mouse area. Set the color of the rectangle to `#bdbdbd`, then set its `border`
    property to `1` and its `radius` to `5`. Then, set the `text` to `Login` and make
    sure the size of the mouse area is the same as the rectangle.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After that, drag another rectangle onto the canvas to act as the container for
    the login form so that it will look neat. Set its `border color` to `#5e5858`
    and its `border` property to `2`. Then, set its `radius` property to `5` to make
    its corners look a little rounded.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure the rectangle that we added in the previous step is positioned at
    the top of the hierarchy in the **Navigator** window so that it appears behind
    all the other widgets. You can arrange the widget positions within the hierarchy
    by pressing the arrow buttons located at the top of the **Navigator** window:![How
    to do it…](img/B02820_05_08.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we will export three widgets—mouse area and the two text input widgets—as
    alias properties of the root item so that later on we can access these widgets
    from the `main.qml` file. The widgets can be exported by clicking on the small
    icon behind the widget name and making sure the icon changes to the **On** status:![How
    to do it…](img/B02820_05_09.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By now, your UI should look something like this:![How to do it…](img/B02820_05_10.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now let's open up `main.qml`. Qt Creator will not open this file in Qt Quick
    Designer by default, but instead, it will be opened with the Script Editor. This
    is because all the UI design-related tasks were done in `MainForm.ui.qml`, and
    `main.qml` is only for defining the logic and functions that will be applied to
    the UI. You can, however, open it with Qt Quick Designer to preview the UI by
    clicking on the **Design** button located in the side bar on the left of the editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the top of the script, add the third line to import the dialog module to
    `main.qml`, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, replace the code below it with this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Build and run this program on your PC and you should get a simple program that
    shows a message box when you click on the **Login** button:![How to do it…](img/B02820_05_11.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since Qt 5.4, a new file extension called `.ui.qml` has been introduced. The
    QML engine handles it like the normal `.qml` files, but forbids any logic implementation
    to be written in it. It serves as the UI definition template, which can be reused
    in different `.qml` files. The separation of UI definition and logic implementation
    improves the maintainability of QML code and creates a better workflow.
  prefs: []
  type: TYPE_NORMAL
- en: All the widgets under **Qt Quick – Basic** are the most basic widgets that we
    can use to mix and match and create a new type of widget. In the previous example,
    we have learned how to put three widgets together—a text, a mouse area, and a
    rectangle, to form a button widget.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you''re lazy, however, you can import pre-made modules to your Qt Quick
    project by going to the **Imports** tab in the **Library** window and clicking
    the **<Add Import>** button. Then, select the module you want to add to your project
    from the drop-down list. You can also create your own Qt Quick module once you
    have advanced in both QML scripting and C++ programming:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/B02820_05_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We imported `QtQuick.dialogs` module in `main.qml` and created a message box
    that displays the user name and password filled in by the user when the **Login**
    button is pressed, so that we can prove that the UI function is working. If the
    widgets are not exported from `MainForm.ui.qml`, we will not be able to access
    its properties in `main.qml`.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we can export the program to iOS and Android, but the UI may
    not look accurate on some of the devices that have higher resolution or higher
    **Density-per-Pixel** (**DPI**) unit. We will cover this issue later on in this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Touch events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will learn how to develop a touch-driven application that
    runs on mobile devices using Qt Quick.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First of all, create a new Qt Quick application project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Qt Creator, right-click on `qml.qrc` and select **Open in Editor**. Then,
    click **Add** | **Add Files** and add `tux.png` to the project:![How to do it…](img/B02820_05_13.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, open up `MainForm.ui.qml`. Drag an image widget from the **Library** window
    to the canvas. Then, set the source of the image to `tux.png` and set its `fillmode`
    to `PreserveAspectFit`. After that, set its `width` to `200` and its `height`
    to `220`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure both the mouse area widget and the image widget are exported as alias
    properties of the root item by clicking on the small icon besides their respective
    widget name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After that, switch over to the Script Editor by clicking on the **Edit** button
    on the side bar located at the left side of the editor. We need to change the
    mouse area widget to a multi-point touch area widget, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We also set the `Image` widget to be automatically placed at the center of
    the window by default:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The final UI should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it…](img/B02820_05_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once you''re done with that, let''s open up `main.qml`. First, clear everything
    within the `MainForm` object except `anchors.fill: parent`, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, declare several variables within the `MainForm` object that will
    be used to rescale the image widget. If you want to know more about the `property`
    keyword used in the following code, check out the *There''s more…* section at
    the end of this example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will define what will happen when our finger touches the multi-point
    area widget. In this case, we will save the positions of the first and second
    touch points if more than one finger touches the multi-point touch area. We also
    save the width and height of the image widget so that later on we can use these
    variables to calculate the scale of the image when the fingers start to move:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The following image shows the example of touch points being registered when
    two fingers are touching the screen, within the touchArea boundary. `touchArea`.`touchPoints[0]`
    is the first registered touch point and `touchArea.touchPoints[1]` is the second.
    We then calculate the X and Y distance between the two touch points and save them
    as `prevDistX` and `prevDistY`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it…](img/B02820_05_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'After that, we will define what will happen when our fingers move while remaining
    in contact with the screen and still within the boundary of the touch area. At
    this point, we will calculate the scale of the image by using the variables we
    saved in the previous step. At the same time, if we detect that only a single
    touch is found, then we will move the image instead of altering its scale:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The following image shows the example of moving touch points - `touchArea.touchPoints[0]`
    moved from point A to point B while `touchArea.touchPoints[1]` moved from point
    C to point D. We can then determine how many units have the touch points moved
    by looking at the differences between the previous X, Y variables with the current
    ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it…](img/B02820_05_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can now build and export the program to your mobile device. You will not
    be able to test this program on a platform that does not support multi-touch.
    Once the program is running on the mobile device (or desktop/laptop that supports
    multi-touch), try two things: put only one finger on the screen and move it around,
    and put two fingers on the screen and move them in opposite directions. What you
    should see is that the penguin will be moved to another place if you use only
    one finger, and it will be scaled up or down if you use two fingers:![How to do
    it…](img/B02820_05_33.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a finger touches the screen of the device, the multi-point touch area widget
    triggers the `onPressed` event and registers the position of each of the touch
    points in an internal array. We can get this data by telling Qt which touch point
    you want to get access to. The first touch will bear the index number of `0`,
    the second touch will be `1`, and so on. We will then save this data into variables
    so that we can retrieve it later to calculate the scaling of the penguin image.
  prefs: []
  type: TYPE_NORMAL
- en: When one or more fingers remain in contact with the screen while moving, a multi-point
    touch area will trigger the `onUpdate` event. We will then check how many touches
    there are—if only one touch is found, we will just move the penguin image based
    on how much our finger has moved. If there is more than one touch, we will compare
    the distance between the two touches and compare this with the previous variables
    we have saved, to determine how much we should rescale the image.
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/B02820_05_34.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We must also check whether the first touch is on the left side of the second
    touch or the right side. This way we can prevent the image from being scaled in
    the inverse direction of the finger movement and producing an inaccurate result.
  prefs: []
  type: TYPE_NORMAL
- en: As for the movement of the penguin, we will just get the difference between
    the current touch position and the previous one, add that to the coordinate of
    the penguin, and it's done. A single touch event is usually a lot simpler and
    more straightforward than a multi-touch event.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Qt Quick, all its components have built-in properties such as width, height,
    color, and so on that are attached to the components by default. However, Qt Quick
    also allows you to create your own custom properties and attach them to the components
    you declared in your QML script. A custom property of an object type may be defined
    in an object declaration in a QML document by adding the `property` keyword before
    the type keyword, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also bind the custom property to a value by using a colon (`:`) before
    the value, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'To learn more about the property types supported by Qt Quick, check out this
    link: [http://doc.qt.io/qt-5/qtqml-typesystem-basictypes.html](http://doc.qt.io/qt-5/qtqml-typesystem-basictypes.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Animation in QML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Qt allows us to easily animate a UI component without writing a bunch of code.
    In this example, we will learn how to make our program's UI more interesting by
    applying animations to it.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once again, we will start everything from scratch. Therefore, create a new Qt
    Quick application project in Qt Creator and open up `MainForm.ui.qml`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to the **Imports** tab in the **Library** window and add a Qt Quick module
    called **QtQuick.Controls** to your project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After that, you will see a new category appear in the **QML Types** tab called
    **Qt Quick - Controls**, which contains many new widgets that can be placed on
    the canvas.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, drag three button widgets to the canvas and set their height to `45`.
    Then, go to the **Layout** tab on the **Properties** window and enable both the
    left and right anchors for all the three button widgets. Make sure the target
    for the anchors are set to **Parent** and the margins remain as `0`. This will
    make the buttons resize horizontally according to the width of the main window.
    After that, set the *y* value of the first button to `0`, the second to `45`,
    and the third to `90`. The UI should now look like this:![How to do it…](img/B02820_05_17.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, open up `qml.qrc` with the Editor and add `fan.png` to the project:![How
    to do it…](img/B02820_05_18.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, add two mouse area widgets to the canvas. After that, drag a rectangle
    widget and an image widget on the canvas. Parent the rectangle and image to the
    mouse areas we have just added before this.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the color of the rectangle to `#0000ff` and apply `fan.png` to the image
    widget. Your UI should now look like this:![How to do it…](img/B02820_05_19.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After that, export all the widgets in your `MainForm.ui.qml` as alias properties
    of the root item by clicking on the icons located to the right of the widget name:![How
    to do it…](img/B02820_05_20.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we will apply animation and logic to the UI but we won't be doing it in
    `MainForm.ui.qml`. Instead, we will do it all in `main.qml`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `main.qml`, remove the default code for the mouse area and add in a width
    and height for the window so that we get more space to preview:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, add the code that defines the behavior of the buttons in the `MainForm`
    widget:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, follow this with the behavior of the `fan` image and the mouse area widget
    it is attached to:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Last but not least, add the behavior of the rectangle and the mouse area widget
    it's attached to:![How to do it…](img/B02820_05_21.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you compile and run the program now, you should see three buttons at the
    top of the window and a moving rectangle at the bottom left, followed by a spinning
    fan at the bottom right. If you click any of the buttons, they will move slightly
    downward with a nice, smooth animation. If you click on the rectangle, it will
    change color from blue to red. Meanwhile, the fan image will pause its animation
    if you click on it while it's animating, and it will resume the animation if you
    click on it again:![How to do it…](img/B02820_05_22.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most of the animation elements supported by the C++ version of Qt, such as transition,
    sequential animation, parallel animation, and so on, are also available in Qt
    Quick. If you are familiar with the Qt animation framework in C++, you should
    be able to grasp this pretty easily.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we added a spring animation element to all three buttons that
    specifically tracked their respective *y*-axes. If Qt detects that the y value
    has changed, the widget will not instantly pop to the new position, but instead
    it will be interpolated, move across the canvas, and perform a little shaking
    animation when reaching its destination, which simulates the spring effect. We
    just have to write one line of code and leave the rest to Qt.
  prefs: []
  type: TYPE_NORMAL
- en: As for the fan image, we added a rotation animation element to it and set the
    `duration` to `1000` milliseconds, which means it will complete a full rotation
    in one second. We also set it to loop its animation infinitely. When we clicked
    on the mouse area widget it's attached to, we just called `pause()` or `resume()`
    to enable or disable the animation.
  prefs: []
  type: TYPE_NORMAL
- en: Next, for the rectangle widget, we added two states to it, one called `BLUE`
    and one called `RED`, each of which carries a `color` property that will be applied
    to the rectangle upon state change. At the same time, we added a sequential animation
    group to the mouse area widget that the rectangle is attached to, and then added
    two property animation elements to the group. You can also mix different types
    of group animation; Qt can handle this very well.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying information using Model View
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Qt includes a Model View framework that maintains separation between the way
    data is organized and managed, and the way that it is presented to the user. In
    this section, we will learn how to make use of the model view, in particular by
    using the list view to display information and at the same time apply our own
    customization to make it look slick.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new Qt Quick application project and open up `qml.qrc` with Qt Creator.
    Add six images, `home.png`, `map.png`, `profile.png`, `search.png`, `settings.png`,
    and `arrow.png`, to the project:![How to do it…](img/B02820_05_35.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After that, open up `MainForm.ui.qml`. Delete all the default widgets on the
    canvas and drag a **List View** widget from under the **Qt Quick - Views** category
    in the Library window onto the canvas. Then, set its **Anchors** setting to **Fill
    the parent size** by clicking on the button located in the middle of the **Layout**
    window:![How to do it…](img/B02820_05_23.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, switch over to the Script Editor, as we will define what the list view
    will look like:![How to do it…](img/B02820_05_24.jpg)![How to do it…](img/B02820_05_36.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After that, open up `main.qml` and replace the code with this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Build and run the program, and now your program should look like this:![How
    to do it…](img/B02820_05_25.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Qt Quick allows us to customize the look of each row of the list view with ease.
    The `delegate` defines what each row will look like and the `model` is where you
    store the data that will be displayed on the list view.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we added a background with a gradient on each row, then we
    also added an icon on each side of the item, a title, a description, and a mouse
    area widget that makes each row of the list view clickable. The delegate is not
    static, as we allow the model to change the title, description, and the icon to
    make each row look unique.
  prefs: []
  type: TYPE_NORMAL
- en: In `main.qml`, we defined the behavior of the mouse area widget, which will
    halve its own opacity value lower when pressed and return to fully opaque when
    released. Since all other elements, such as title, icon, and so on, are all the
    children of the mouse area widget, they all will also automatically follow their
    parent widget's behavior and become semi-transparent.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, we have finally solved the display problem on mobile devices with high
    resolution and DPI. It''s a very simple trick—first, we defined a variable called
    `sizeMultiplier`. The value of `sizeMultiplier` is the result of dividing the
    width of the window by a predefined value, say `480`, which is the current window
    width we used for the PC. Then, multiply `sizeMultiplier` by all the widget variables
    that have to do with size and position, including font size. Do note that in this
    case, you should use the `pixelSize` property for text instead of `pointSize`,
    so that you will get the correct display when multiplying by `sizeMultiplier`.
    The following screenshot shows you what the app looks like on the mobile device
    with and without `sizeMultiplier`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/B02820_05_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Notice that you may get a messed up UI in the editor once you multiply everything
    with the `sizeMultiplier` variable. This is because the `width` variable may return
    as `0` in the editor. Hence, by multiplying `0` by `480`, you may get the result
    `0`, which makes the entire UI to look funny. However, it will look fine when
    running the actual program. If you want to preview the UI on the editor, temporarily
    set the `sizeMultiplier` to `1`.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating QML and C++
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Qt supports bridging between C++ classes with the QML engine. This combination
    allows developers to take advantage of both the simplicity of QML and the flexibility
    of C++. You can even integrate features that are not supported by Qt from an external
    library, then pass the resulting data to Qt Quick to be displayed in the UI. In
    this example, we will learn how to export our UI components from QML to the C++
    framework and manipulate their properties before displaying them on screen.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once again, we will start everything from scratch. Therefore, create a new Qt
    Quick application project in Qt Creator and open up `MainForm.ui.qml`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can keep the mouse area and text widget, but place the text widget at the
    bottom of the window. Change the **Text** property of the text widget to **Change
    this text using C++** and set its font size to `18`. After that, go to the **Layout**
    tab and enable both **Vertical center anchor** and **Horizontal center anchor**
    to ensure it's always somewhere in the middle of the window, regardless of how
    you rescale the window. Set the **Margin** for the **Vertical center anchor**
    to `120`:![How to do it…](img/B02820_05_27.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, drag a **Rectangle** widget from the **Library** window to the canvas
    and set its color to `#ff0d0d`. Set its **Width** and **Height** to `200` and
    enable both the vertical and horizontal center anchor. After that, set the **Margin**
    of the horizontal center anchor to `-14`. Your UI should now look something like
    this:![How to do it…](img/B02820_05_28.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you are done with that, right-click on your project directory in Qt Creator
    and choose **Add New**. Then, a window will pop up and let you pick a file template.
    Select **C++ Class** and press **Choose…**. After that, it will ask you to define
    the C++ class by filling in the information for the class. In this case, insert
    **MyClass** in the **Class Name** field and select **QObject** as the **Base class**.
    Then, make sure **Include QObject** option is ticked and you can now click the
    **Next** button, follow by the **Finish** button. Two files—`myclass.h` and `myclass.cpp`—will
    now be created and added to your project:![How to do it…](img/B02820_05_29.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, open up `myclass.h` and add a variable and function below the class constructor,
    like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, open up `myclass.cpp` and define the `setMyObject()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now close `myclass.cpp` and open up `main.qml`. At the top of the file,
    add in the third line, which imports the custom library we just created in C++:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, define `MyClass` in the `Window` object and call its function `setMyObject()`
    within the `MainForm` object, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, open up `main.cpp` and register the custom class to the QML engine.
    We also change the properties of the text widget and the rectangle here using
    C++ code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Build and run the program now, and you should see the colors of the rectangle
    and the text are completely different from what you defined earlier in Qt Quick.
    This is because their properties have been changed by the C++ code:![How to do
    it…](img/B02820_05_30.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: QML is designed to be easily extensible through C++ code. The classes in the
    Qt QML module enable QML objects to be loaded and manipulated from C++.
  prefs: []
  type: TYPE_NORMAL
- en: Only classes that are inherited from the `QObject` base class can be integrated
    with QML, as it is part of the Qt ecosystem. Once the class has been registered
    with the QML engine, we get the root item from the QML engine and use it to find
    the objects we want to manipulate. After that, use the `setProperty()` function
    to change any of the properties belong to the widget.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the `Q_INVOKABLE` macro is required in front of the function that
    you intend to call in QML. Without it, Qt will not expose the function to Qt Quick
    and you will not be able to call it.
  prefs: []
  type: TYPE_NORMAL
