- en: Securing APIs with API Keys and Azure Key Vault
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we are going to see how we can keep secrets in Azure Key Vault.
    We will also be looking at how we can use API keys to secure our own keys with
    authentication and role-based authorization. To gain first-hand experience with
    API security, we will build a fully functional FinTech API.
  prefs: []
  type: TYPE_NORMAL
- en: Our API will extract third-party API data using a private key (kept safe in
    Azure Key Vault). We will then secure our API with two API keys; one key will
    be used internally and a second key will be used by external users.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics are covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Accessing the Morningstar API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing the Morningstar API in Azure Key Vault
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the dividend calendar ASP.NET Core web application in Azure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Publishing our web application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using an API key to secure our dividend calendar API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing our API key's security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding the dividend calendar code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Throttling our API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You will understand the basics of good API design and you will be armed with
    the knowledge needed to push your API abilities forward. This chapter will assist
    you in gaining the following skills:'
  prefs: []
  type: TYPE_NORMAL
- en: Securing an API with a client API key
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing and retrieving secrets using Azure Key Vault
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Postman to execute API commands that post and get data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying for and using third-party APIs on RapidAPI.com
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Throttling API usage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing FinTech APIs that leverage online financial data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before we continue, make sure you implement the following technical requirements
    to get the most out of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will be using the following technologies in this chapter to write an API:'
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio 2019 Community edition or higher
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your own personal Morningstar API key from [https://rapidapi.com/integraatio/api/morningstar1](https://rapidapi.com/integraatio/api/morningstar1)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RestSharp ([http://restsharp.org/](http://restsharp.org/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Swashbuckle.AspNetCore 5 or higher
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Postman ([https://www.postman.com/](https://www.postman.com/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Swagger ([https://swagger.io](https://swagger.io))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Undertaking the API project – dividend calendar
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The best way to learn is by doing. So, we will build a working API and secure
    it. The API won''t be perfect and there will be room for improvement. However,
    you are free to implement these improvements yourself and expand on the project
    as you wish. The main goal here is to have a fully functioning API that does one
    thing: return financial data that lists all the company dividends that will be
    paid in the current year.'
  prefs: []
  type: TYPE_NORMAL
- en: Our dividend calendar API, which we will be building in this chapter, is an
    API that is authenticated with an **API key**. Depending on what key is used,
    authorization will determine whether the user is internal or external. The controller
    will then execute the appropriate method, depending on the type of user. Only
    the internal user method will be implemented, but you are free to implement the
    external user method yourself as a training exercise.
  prefs: []
  type: TYPE_NORMAL
- en: The internal method extracts an API key from Azure Key Vault and executes various
    API calls to a third-party API. The data is returned in **JavaScript Object Notation** (**JSON**)
    format, deserialized into objects and then processed to extract future dividend
    payments, which are added to a list of dividends. This list is then returned to
    the caller in JSON format. The end result is a JSON file that has all the scheduled
    dividend payments for the current year. The end user can then take this data and
    convert it into a list of dividends that can be queried using LINQ.
  prefs: []
  type: TYPE_NORMAL
- en: The project we will be building in this chapter is a web API that returns processed
    JSON from third-party financial APIs. Our project will obtain a list of companies
    from a given stock exchange. We will then loop through these companies to obtain
    their dividend data. The dividend data will then be processed for the current
    year. So, what we will end up returning to the API caller is JSON data. This JSON
    data will contain a list of companies and their dividend payment forecast for
    the current year. The JSON data can then be converted by the end user into C#
    objects, and LINQ queries can be performed on these objects. Queries can be carried
    out to get x-dividend payments for the next month or payments due this month,
    for example.
  prefs: []
  type: TYPE_NORMAL
- en: The APIs that we will be using will be part of the Morningstar API, which is
    available via RapidAPI.com. You can sign up for a free Morningstar API key. We
    will secure our API with a login system, where users log in using an email address
    and password. You will also need Postman, as we will be using it to fire the API's `POST`
    and `GET` requests to the dividend calendar API.
  prefs: []
  type: TYPE_NORMAL
- en: Our solution will contain a single project, which will be an ASP.NET Core application
    that targets .NET Framework Core 3.1 or higher. We will now discuss how to access
    the Morningstar API.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing the Morningstar API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Go to [https://rapidapi.com/integraatio/api/morningstar1](https://rapidapi.com/integraatio/api/morningstar1) and
    request an API access key. The API is a Freemium API. This means you are allowed
    a certain number of calls for free for a limited period, after which you need
    to pay for its usage. Take some time to look at the API and its documentation.
    Pay attention to the pricing plans and keep your key a secret when you receive
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The APIs that we are interested in are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GET /companies/list-by-exchange`: This API returns a list of countries for
    the specified exchange.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GET /dividends`: This API gets all the historical and current dividend payment
    information for the specified company.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first part of the API request is the `GET` HTTP verb, which is used to retrieve
    a resource. The second part of the API request is the resource to `GET`, which
    in this case is `/companies/list-by-exchange`. As we can see in the second bullet
    point of the preceding list, we are getting the `/dividends` resource.
  prefs: []
  type: TYPE_NORMAL
- en: You can test each API in the browser and see the data that is returned. I recommend
    you do this before you continue. This will help you get a feel for what we will
    be working on. The basic flow we will be using is getting the list of companies
    that belong to a specified exchange, then looping through them to obtain the dividend
    data. If the dividend data has a future payment date, then the dividend data will
    be added to the calendar; otherwise, it will be discarded. No matter how much
    dividend data exists for a company, we are only interested in the first record,
    which is the most current one.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your API key (assuming you are following along with these
    steps), we will start to build our API.
  prefs: []
  type: TYPE_NORMAL
- en: Storing the Morningstar API key in Azure Key Vault
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will be using Azure Key Vault and **Managed Service Identity** (**MSI**)
    with an ASP.NET Core web application. So, before you continue, you will need an
    Azure subscription. For new customers, there is a free 12-month offer available
    at [http://azure.microsoft.com/en-us/free](https://azure.microsoft.com/en-us/free/).
  prefs: []
  type: TYPE_NORMAL
- en: As web developers, it is important not to store secrets in code because code
    can be *reverse-engineered*. If code is open source, then there is the danger
    of uploading personal or enterprise keys to a public version control system. A
    way around this is to store secrets securely, but this gives rise to a dilemma.
    To access secret keys, we need to be authenticated. So, how do we overcome this
    dilemma?
  prefs: []
  type: TYPE_NORMAL
- en: We can overcome this dilemma by enabling MSI for our Azure service. As a result,
    a service principal is produced by Azure. This service principal is used by applications
    developed by the user to access resources on Microsoft Azure. For the service
    principal, you can use a certificate or a username and password, along with any
    role you choose that has the required set of permissions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The person who controls the Azure account is in control of what specific tasks
    each service can perform. It is often best to start with full restrictions and
    only add capabilities as and when they are needed. The following diagram shows
    the relationships between our ASP.NET Core web applications, MSI, and our Azure
    service:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/98b01f77-0e13-4266-9d5e-de1621a12700.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Azure Active Directory **(**Azure AD**) is employed by MSI to inject the
    service principal for the service instance. An Azure resource known as a **local
    metadata service** is used to obtain an access token and will be used to authenticate
    service access to the Azure key vault.'
  prefs: []
  type: TYPE_NORMAL
- en: The code then calls a local metadata service that is available on the Azure
    resource to get the access token. The access token extracted from the local MSI
    endpoint is then used by our code to authenticate to an Azure Key Vault service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the Azure CLI and type `az login` to log in to Azure. Once we are logged
    in, we can create a resource group. Azure resource groups are logical containers
    into which Azure resources are deployed and managed. The following command creates
    a resource group in the `East US` location:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Use this resource group throughout the rest of the chapter. We will now move
    on to creating our key vault. The creation of a key vault requires the following
    information:'
  prefs: []
  type: TYPE_NORMAL
- en: The name of the key vault, which is a string that is between 3 to 24 characters
    long and can only contain the `0-9`, `a-z`, `A-Z`, and `-` (hyphen) characters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The name of the resource group
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The location—for example, `East US` or `West US`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the Azure CLI, enter the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Only your Azure account is authorized to perform operations on your new vault
    at this stage. You can add other accounts if necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main key that we need to add to our project is `MorningstarApiKey`. To
    add the Morningstar API key to your key vault, type the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Your key vault now stores your Morningstar API key. To check that the value
    is stored correctly, type the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: You should now see your secret displayed in the console window, which shows
    the key and value for the stored secret.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the dividend calendar ASP.NET Core web application in Azure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To complete this stage of the project, you will need Visual Studio 2019 with
    the ASP.NET and web development workload installed:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new ASP.NET Core web application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/83a0ae31-6cad-493c-8818-9b2c23ebe9c1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Make sure API is selected with No Authentication set:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f1d634c9-d3d2-44d9-9003-6b2a961c0d8a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on Create to scaffold your new project. Then, run your project. By default,
    an example weather forecast API is defined, and it outputs the following JSON
    code in the browser window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Next, we will publish our application to Azure.
  prefs: []
  type: TYPE_NORMAL
- en: Publishing our web application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we can publish our web applications, we will first create a new Azure
    app service to publish our application to. We will need a resource group to contain
    our Azure app service, as well as a new hosting plan that specifies the location,
    size, and features of the web server farm that hosts our application. So, let''s
    take care of these requirements, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure you are signed in to your Azure account from Visual Studio. To create
    the app service, right-click on the project that you just created and select Publish from
    the menu. This will display the Pick a publish target dialog, as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/bb8f7ab3-0071-4ef9-972a-6499efb8f6e4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Select App Service | Create New and click on Create Profile. Create a new hosting
    plan, as in the following example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/73abd32c-f8df-4d10-82d4-73fc691a21d3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, make sure you provide a name, select a subscription, and select your
    resource group. It is recommended that you also set the Application Insights setting:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/35f10e70-0b39-4035-973a-6ea031b28dc8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on Create to create your app service. Once it''s created, your Publish screen
    should look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/82f95f6e-c959-43fd-89ba-b2bd2ac7e14f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'At this stage, you can click on the site URL. This will load your site URL
    in the browser. If your service is successfully configured and running, your browser
    should display the following page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e45fb271-cba1-45ba-9150-e5fdf60cf2a5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s publish our API. Click on the Publish button. When the web page runs,
    it will display an error page. Modify the URL to `https://dividend-calendar.azurewebsites.net/weatherforecast`.
    The web page should now display the weather forecast API JSON code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Our service is now live. If you log in to your Azure portal and visit the resource
    group for your hosting plan, you will see four resources. These resources are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**App Service**: `dividend-calendar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Application Insights**: `dividend-calendar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**App Service plan**: ``DividendCalendarHostingPlan``'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Key vault**: Whatever your key vault is called. In my case, it''s `Keys-APIs`,
    as shown here:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/4ece03d9-20f5-4014-b1bf-1d03e363bb20.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you click on your app service from the Azure portal home page ([https://portal.azure.com/#home](https://portal.azure.com/#home)),
    you will see that you can browse to your service, as well as stop, restart, and
    delete your app service:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8ba4b623-0f35-4f20-bd5b-526ef3b17ef3.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that we have our project in place with Application Insights and our Morningstar
    API key is stored securely, we can start building our dividend calendar.
  prefs: []
  type: TYPE_NORMAL
- en: Using an API key to secure our dividend calendar API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To secure access to our dividend calendar API, we are going to use a client
    API key. There are many ways to share client keys with your clients, but we will
    not be discussing them here. You can come up with your own strategies. What we
    will be focusing on is how to enable authenticated and authorized client access
    to our API.
  prefs: []
  type: TYPE_NORMAL
- en: To keep things simple, we will be using the **repository pattern**. The repository
    pattern helps to decouple our program from the underlying data store. This pattern
    improves maintainability and allows you to change the underlying data store without
    affecting the program. For our repository, our keys will be defined in a class,
    but in a commercial project, you would store the keys in a data store, such as
    Cosmos DB, SQL Server, or Azure Key Vault. You decide the strategy that best suits
    your needs, which is the main reason why we use the repository pattern as you
    are in control of the underlying data source for your own needs.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the repository
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are going to start by setting up our repository:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new folder to your project called `Repository`. Then, add a new interface
    called `IRepository` and a class that will implement `IRepository`, called `InMemoryRepository`.
    Modify your interface, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This interface defines one method for retrieving the API key. We have not yet
    defined the `ApiKey` class and we will do that later. Now, let''s implement `InMemoryRepository`.
    Add the following `using` statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The `security` namespaces will be created when we start adding the authentication
    and authorization classes. Modify the `Repository` class to implement the `IRepository` interface.
    Add the member variable that will hold our API keys, and then add the `GetApiKey()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The `InMemoryRepository` class implements the `GetApiKey()` method of `IRepository`.
    This returns a dictionary of API keys. These keys will be stored in our `_apiKeys` dictionary
    member variable. Now, we''ll add our constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Our constructor creates a new list of API keys. It creates an internal API key
    for internal use only and an external API key for external use only. It then converts
    the list into a dictionary and stores the dictionary in `_apiKeys`. So, we now
    have our repository in place.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will be using an HTTP header called `X-Api-Key`. This will store the client''s
    API key, which will be passed into our API for authentication and authorization.
    Add a new folder to the project called `Shared`, and then add a new file called `ApiKeyConstants`.
    Update the file with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This file contains two constants—the header name, which will be used when establishing
    the user's identity, and the URL for the Morningstar API key, which is stored
    in the Azure key vault that we created earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we will be handling JSON data, we need to set our JSON naming policy.
    Add a folder to your project called `Json`. Then, add a class called `DefaultJsonSerializerOptions`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `DefaultJsonSerializerOptions` class sets our JSON naming policy to ignore
    null values and to use camel case names.
  prefs: []
  type: TYPE_NORMAL
- en: We will now start adding authentication and authorization to our API.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up authentication and authorization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will now start work on the security classes for authentication and authorization.
    It is good to clarify what we mean by authentication and authorization first.
    Authentication is establishing whether the user is authorized to access our API.
    Authorization is establishing what permissions the user has once they gain access
    to our API.
  prefs: []
  type: TYPE_NORMAL
- en: Adding authentication
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before we continue, add a `Security` folder to your project and then under
    that folder, add the `Authentication` and `Authorisation` folders. We will start
    by adding our `Authentication` classes; the first class that we will add to our
    `Authentication` folder is `ApiKey`. Add the following properties to `ApiKey`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'These properties store information that pertains to the specified API key and
    its owner. The properties are set via the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The constructor sets the API key properties. If a person fails authentication,
    then they will be notified with an `Error 403 Unauthorized` message. So, let''s
    now define our `UnauthorizedProblemDetails` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This class inherits the `Microsoft.AspNetCore.Mvc.ProblemDetails` class. The
    constructor takes a single parameter of the `string` type, which defaults to `null`.
    You can pass details into this constructor to provide more information if required.
    Next, we add `AuthenticationBuilderExtensions`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This extension method adds API key support to the authentication service, which
    will be set in the `ConfigureServices` method of the `Startup` class. Now, add
    the `ApiKeyAuthenticationOptions` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ApiKeyAuthenticationOptions` class inherits the `AuthenticationSchemeOptions`
    class. We set the default scheme to use API key authentication. The final part
    of our authorization is to build up our `ApiKeyAuthenticationHandler` class. As
    the name suggests, this is the main class for validating the API key, ensuring
    the client is authorized to access and use our API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `ApiKeyAuthenticationHandler` class inherits from `AuthenticationHandler`
    and uses `ApiKeyAuthenticationOptions`. We define the content type for the problem
    details (exception information) as `application/problem+json`. We also provide
    a placeholder for our API key repository using the `_repository` member variable.
    The next step is to declare our constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Our constructor passes the `ApiKeyAuthenticationOptions`, `ILoggerFactory`,
    `UrlEncoder`, and `ISystemClock` parameters to the base class. Explicitly, we
    set the repository. If the repository is null, we throw a null argument exception
    with the name of the repository. Let''s add our `HandleChallengeAsync()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The `HandleChallengeAsync()` method returns an `Error 401 Unauthorized` response
    when the user challenge fails. Now, let''s add our `HandleForbiddenAsync()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The `HandleForbiddenAsync()` method returns an `Error 403 Forbidden` response
    when the user permission check fails. Now, we need to add a final method that
    returns `AuthenticationResult`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The code we've just written checks whether our header exists. If the header
    is not present, then `AuthenticateResult()` returns a Boolean value of `true`
    for the `None` property, indicating that there was no information provided for
    this request. We then check whether the header has a value. If no value is provided,
    the `return` value indicates that no information was provided for this request.
    We then obtain our server-side key from our repository using the client-side key.
  prefs: []
  type: TYPE_NORMAL
- en: If the server-side key is null, then a failed `AuthenticationResult()` instance
    is returned, indicating that the provided API key is invalid, as identified in
    the `Failure` property of the `Exception` type. Otherwise, the user is deemed
    authentic and is allowed to access our API. For valid users, we set the claims
    for their identities and then pass back a successful `AuthenticateResult()` instance.
  prefs: []
  type: TYPE_NORMAL
- en: So, we have our authentication sorted. Now, we need to work on our authorization.
  prefs: []
  type: TYPE_NORMAL
- en: Adding authorization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Our authorization classes will be added to the `Authorisation` folder. Add
    the `Roles` struct with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We expect our API to be used internally and externally. However, for our minimum
    viable product, only the code for internal users will be implemented. Now, add
    the `Policies` struct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In our `Policies` structure, we have added two policies that will be used for
    internal and external clients. Now, we''ll add the `ForbiddenProblemDetails` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This class provides the forbidden problem details if one or more permissions
    are not available to the authenticated user. You can pass a string into this class's
    constructor to provide relevant information if required.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our authorization, we will need to add authorization requirements and handlers
    for both internal and external clients. We''ll add the `ExternalAuthorisationHandler` class
    first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ExternalRequirement` class is an empty class that implements the `IAuthorizationRequirement` interface.
    Now, add the `InternalAuthorisationHandler` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The `InternalAuthorisationHandler` class handles the authorization of the internal
    requirement. If the context user is assigned to the internal role, then permission
    is granted. Otherwise, permission is denied. Let''s add the required  `InternalRequirement`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `InternalRequirement` class is an empty class that implements the `IAuthorizationRequirement` interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now have our authentication and authorization classes in place. So, it is
    now time to update our `Startup` class to wire up the `security` classes. Start
    by modifying the `Configure()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The `Configure()` method sets the exception page to the developer page if we
    are in development. It then requests the app to use *routing* to match URIs with
    the actions in our controllers. The app is then informed that it should use our
    authentication and authorization methods. Finally, the application endpoints are
    mapped from the controllers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final method we need to update to complete our API key authentication and
    authorization is the `ConfigureServices()` method. The first thing we need to
    do is add our authentication service with API key support:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are setting the default authentication scheme. We add `AddApiKeySupport()`
    using our extension key, as defined in our `AuthenticationBuilderExtensions` class,
    which returns; `Microsoft.AspNetCore.Authentication.AuthenticationBuilder`. Our
    default scheme is set to the API key, as configured in our `ApiKeyAuthenticationOptions`
    class. The API key is a constant value that informs the authentication service
    that we will be using API key authentication. Now, we need to add our authorization
    service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are setting our internal and external policies and requirements. These
    are defined in our `Policies`, `InternalRequirement`, and `ExternalRequirement`
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: Well, we've added all of our API key security classes. So, we can now test whether
    our API key authentication and authorization is working using Postman.
  prefs: []
  type: TYPE_NORMAL
- en: Testing our API key security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we are going to test our API key authentication and authorization
    using Postman. Add a class to your `Controllers` folder called `DividendCalendar`.
    Update the class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This class will contain all of our dividend calendar API code functionality.
    Even though external code will not be used in this initial release of our minimum
    viable product, we will be able to test our internal and external authentication
    and authorization.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open Postman and create a new `GET` request. For the URL, use `https://localhost:44325/api/dividendcalendar/internal`.
    Click Send:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/cb86a829-e085-40e4-a8e8-222ddf94a65a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, without the API key present in the API request, we get the
    expected `401 Unauthorized` status with our forbidden JSON, as defined in the `ForbiddenProblemDetails` class.
    Now, add the `x-api-key` header with the `C5BFF7F0-B4DF-475E-A331-F737424F013C` value.
    Then, click Send:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d2968005-7ae2-4e3f-8c33-cdae1e1fcc44.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You will now have a status of `200 OK`. This means that the API request has
    been successful. You can see the result of the request in the body. Internal users
    will see `Hello from GetDividendCalendar`. Run the request again, but change the
    URL so that the route is external instead of internal. So, the URL should be `https://localhost:44325/api/dividendcalendar/external`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/70e85d72-8e5f-4e57-b678-fb074a597962.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You should receive a status of `403 Forbidden` with the forbidden JSON. This
    is because the API key is a valid API key, but the route is for an external client
    and the external client does not have access to the internal API. Change the `x-api-key` header
    value to `9218FACE-3EAC-6574-C3F0-08357FEDABE9`. Then, click Send:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/222f0de1-53d5-4a1a-bd17-86c1dc9b7158.png)'
  prefs: []
  type: TYPE_IMG
- en: You will see that you have a status of `200 OK` and that the body has the `External
    access is currently unavailable` text.
  prefs: []
  type: TYPE_NORMAL
- en: Good news! Our role-based security system using API key authentication and authorization
    is tested and working. So, before we have even added our actual FinTech API, we
    have implemented and tested our API key, which is used to secure our FinTech API.
    So, we have put the security of our API first before writing a single line of
    our actual API. Now, we can start in earnest to build our dividend calendar API
    functionality, knowing that it is secure.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the dividend calendar code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our internal API only has one purpose, which is to build up an array of dividends
    that are to be paid out this year. You, however, can build on this project to
    save the JSON to a file or database of some type. So, you would only make an internal
    call once a month to save money on API calls. However, the external role could
    access the data from your file or database as often as needed.
  prefs: []
  type: TYPE_NORMAL
- en: We already have our controller in place for our dividend calendar API. This
    security is in place to prevent unauthenticated and unauthorized users from accessing
    our internal `GetDividendCalendar()` API endpoint. So, all we have to do now is
    generate the dividend calendar JSON, which our method will return.
  prefs: []
  type: TYPE_NORMAL
- en: 'So that you can see what we will be working toward, have a look at the following
    truncated JSON response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This JSON response is an array of dividends. A dividend consists of the `Mic`,
    `Ticker`, `CompanyName`, `DividendYield`, `Amount`, `ExDividendDate`, `DeclarationDate`,
    `RecordDate`, `PaymentDate`, `DividendType`, and `CurrencyCode` fields. Add a
    new folder to your project called `Models`, and then add the `Dividend` class
    with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see what each of these fields represents:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Mic`: **ISO 10383 Market Identification Code** (**MIC**), which is where the
    stock is listed. See [https://www.iso20022.org/10383/iso-10383-market-identifier-codes](https://www.iso20022.org/10383/iso-10383-market-identifier-codes) for
    more information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Ticker`: The stock market ticker for the common stock.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CompanyName`: The name of the company that owns the stock.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DividendYield`: The ratio of the company''s annual dividend compared to its
    share price. The dividend yield is calculated in terms of percentage and is calculated
    with the *Dividend Yield = Annual Dividend / Share Price* formula.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Amount`: The amount that will be paid out to the shareholder per share.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ExDividendDate`: The date before which you must purchase the share in order
    to receive the next dividend payment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DeclarationDate`: The date that the company declares they are paying a dividend.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RecordDate`: The date that the company looks at its records to determine who
    will receive the dividend.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PaymentDate`: The date that the shareholders receives the dividend payment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DividendType`: This can be, for example, `Cash Dividend`, `Property Dividend`,
    `Stock Dividend`, `Scrip Dividend`, or `Liquidating Dividend`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CurrencyCode`: The currency that the amount will be paid in.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The next class we need in our `Models` folder is the `Company` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The `Mic` and `Ticker` fields are the same as for our `Dividend` class. Between
    the different API calls, the APIs use different names for the currency identifier.
    That is why we have `CurrencyCode` in `Dividend` and `Currency` in `Company`.
    This helps the JSON with the object-mapping process so that we don't experience
    formatting exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each of these fields represents the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Currency`: The currency used to price the stock'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SecurityId`: The stock market security identifier for the common stock'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CompanyName`: The name of the company that owns the stock'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Our next `Models` class is called `Companies`. This class is required to store
    the companies that are returned in the initial Morningstar API call. We will be
    looping through the list of companies to make further API calls to get each company''s
    record so that we can then make our API call to get the company''s dividend:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Each of these properties defines the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Total`: The total number of records returned from the API query'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Offset`: The record offset'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Results`: The list of companies returned'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ResponseStatus`: Provides detailed response information, especially if errors
    are returned'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, we will add the `Dividends` class. This class holds the list of dividends
    returned by the dividends'' Morningstar API response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Each of these properties is the same as those defined previously, except for
    the `Results` property, which defines a list of dividend payments returned for
    the specified company.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final class we need to add to our `Models` folder is the `ResponseStatus` class.
    This is mainly used to store error information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The properties of this class are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ErrorCode`: The number of the error'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Message`: The error message'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`StackTrace`: The error diagnostics'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Errors`: A list of errors'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Meta`: A list of the error metadata'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We now have all the models we need in place. So now, we can start to make our
    API calls to build up our dividend payment calendar. In the controller, add a
    new method called `FormatStringDate()`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'This method takes a string date. If the string is null or empty, then `null`
    is returned. Otherwise, the string is parsed and a nullable `DateTime` value is
    passed back. We''ll also need a method that extracts our Morningstar API key from
    our Azure key vault:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The `GetMorningstarApiKey()` method instantiates `AzureServiceTokenProvider`.
    It then creates a new `KeyVaultClient` object type, which performs cryptographic
    key operations. Then, the method awaits the response to get the Morningstar API
    key from the Azure key vault. It then passes back the response value. If an error
    occurs processing a request, `KeyVaultErrorException.Message` is returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'When processing the dividends, we first obtain a list of companies from a stock
    exchange. We then loop through these companies and make another call to get the
    dividends for each company in that stock exchange. So, we''ll start with our method
    to obtain a list of companies by MIC. Remember, we are using the `RestSharp` library.
    So, if you have not already installed it, then now is a good time to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Our `GetCompanies()` method creates a new REST client that points to the API
    URL that retrieves a list of companies that are listed on the specified stock
    exchange. The type of the request is a `GET` request. We add three headers to
    our `GET` request for `x-rapidapi-host`, `x-rapidapi-key`, and `accept`. Then,
    we execute the request and return the deserialized JSON data via the `Companies` model.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will write the methods that return the dividends for the specified
    exchange and company. Let''s start by adding the `GetDividends()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The `GetDividends()` method is the same as the `GetCompanies()` method, except
    the request returns the dividends for the specified stock exchange and company.
    The JSON is deserialized into an instance of the `Dividends` object and is returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our final method, we need our minimum viable product to be built into the `BuildDividendCalendar()` method.
    This method is the method that will build up the dividend calendar JSON that will
    be returned to the client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: In this version of the API, we hardcode the MIC to `"XLON"`—the **London Stock
    Exchange**. However, in future releases, this method and the public endpoint could
    be updated to accept a MIC as a `request` parameter. We then add a `list` variable
    to hold this year's dividend payments. Then, we perform our Morningstar API call
    to extract the list of companies that are currently listed on the specified MIC.
    Once the list is returned, we loop through results. For each company, we then
    make a further API call to get the complete dividend record for the MIC and the
    ticker. If the company has no dividends listed, then we continue with the next
    iteration and select the next company.
  prefs: []
  type: TYPE_NORMAL
- en: If the company has dividend records, we get the first record, which will be
    the latest dividend payment. We check whether the payable date is `null`. If the
    payable date is `null`, then we continue on to the next iteration with the next
    customer. If the payable date is not `null`, we check whether the payable date
    is greater than December 31^(st) from the previous year. If the date difference
    is greater than 1, then we add a new dividend object to this year's dividends
    list. Once we have iterated through all the companies and built up a list of this
    year's dividends, we then pass the list back to the calling method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final step before we run our project is to update the `GetDividendCalendar()` method
    to call the `BuildDividendCalendar()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `GetDividendCalendar()` method, we return a JSON string from the serialized
    list of this year''s dividends. So, if you run the project in Postman using the
    internal `x-api-key` variable, then you should find that after around 20 minutes,
    the following JSON is returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: This query does take a lot of time to run, roughly around 20 minutes, and the
    results will change over the course of a year. So, a strategy we could use is
    to throttle the API to run once a month and then store the JSON either in a file
    or a database. Then, this file or database record is what you would update the
    external method to call and pass back to external clients. Let's throttle our
    API to only run once a month.
  prefs: []
  type: TYPE_NORMAL
- en: Throttling our API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When exposing APIs, you need to throttle them. There are many methods available
    to do this, such as limiting the number of simultaneous users or limiting the
    number of calls within a given period of time, for example.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we are going to throttle our API. The method we will use to
    throttle our API will be to limit our API to run only once a month on the 25^(th)
    of the month. Add the following line to your `appsettings.json` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'This value will contain the date that the next API can be executed. Now, add
    the `AppSettings` class at the root of your project, and then add the following
    property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'This property will hold the value of the `MorningstarNextRunDate` key. The
    next thing to do is to add our static method, which will be called to add or update
    an application setting in the `appsetting.json` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '`AddOrUpdateAppSetting()` tries to get the file path for the `appsettings.json` file.
    It then reads the JSON from the file. The JSON is then deserialized into a `dynamic` object.
    We then call our method to recursively set the required value. Then, we write
    the JSON back to the same file. If an error is encountered, then we output an
    error message to the console. Let''s write our `SetValueRecursively()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The `SetValueRecursively()` method splits the string at the first apostrophe
    character. It then proceeds to recursively process the JSON, moving down the tree.
    When it gets to where it needs to be—that is, it finds the required value—the
    value is then set and the method returns. Add the `ThrottleMonthDay` constant to
    the `ApiKeyConstants` struct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'This constant is used for our day-of-the-month check when an API request is
    issued. In `DividendCalendarController`, add the `ThrottleMessage()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ThrottleMessage()` method simply returns the message, `"This API call
    can only be made once on the 25th of each  month."`. Now, add the following constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'This constructor provides us with access to the values in the `appsettings.json` file. 
    Add these two lines to the end of your `Startup.ConfigureServices()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'These two lines enable the `AppSettings` class to be dynamically injected into
    our controller when we need it. Add the `SetMorningstarNextRunDate()` method to
    the `DividendCalendarController` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The `SetMorningstarNextRunDate()` method checks whether the current month''s
    day is less than `25`. If the current month''s day is less than `25`, then the
    month is set to the current month so that the API can be run on the 25^(th) of
    the current month. Otherwise, for days that are `25` and upward, the month is
    set to the following month. The new date is then assembled and the `MorningstarNextRunDate` key
    of `appsettings.json` is then updated and the nullable `DateTime` value is returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '`CanExecuteApiRequest()` gets the current value of the `MorningstarNextRunDate`
    value from the `AppSettings` class. If `DateTime?` does not have a value, then
    the value is set and assigned to the `nextRunDate` local variable. If the current
    month''s day does not equal `ThrottleMonthDay`, then we return `false`. If the
    current month does not equal the next run date month, then we return `false`.
    Otherwise, we set the next API run date to the 25^(th) of the following month
    and return `true`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we update our `GetDividendCalendar()` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: When an internal user calls the API now, their request will be validated to
    see whether it can run. If it runs, then the serialized JSON for the dividend
    calendar is returned. Otherwise, we return the `throttle` message.
  prefs: []
  type: TYPE_NORMAL
- en: That concludes our project.
  prefs: []
  type: TYPE_NORMAL
- en: Well, we've completed our project. It is not perfect, and there are improvements
    and extensions that we can make. The next step would be to document our API and
    deploy the API and documentation. We should also add logging and monitoring.
  prefs: []
  type: TYPE_NORMAL
- en: Logging is useful for storing exception details and for tracking how our API
    is used. Monitoring is a way to keep an eye on the health of our API so that we
    can be alerted if anything goes wrong. This way, we can be proactive in keeping
    our API up and running. I will leave you to extend the API as you desire. It will
    be a good learning exercise for you.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter addresses cross-cutting concerns. It will give you an idea
    about how to address logging and monitoring using aspects and attributes.
  prefs: []
  type: TYPE_NORMAL
- en: Let's summarise what we have learned.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you signed up to a third-party API and received your own key.
    The API key is stored in your Azure key vault and kept secure from access by unauthorized
    clients. You then moved on to create an ASP.NET Core web application and published
    it to Azure. Then, you set about securing the web application by using authentication
    and role-based authorization.
  prefs: []
  type: TYPE_NORMAL
- en: The authorization we set up is performed using an API key. You used two API
    keys in this project—one for internal use and one for external use. The testing
    of our API and API key security was performed using the Postman application. Postman
    is a very good and useful tool for testing HTTP requests and responses for the
    various HTTP verbs.
  prefs: []
  type: TYPE_NORMAL
- en: You then added the dividend calendar API code and enabled internal and external
    access based on API keys. The project itself performed a number of different API
    calls to build up a list of companies that are expecting to pay dividends to investors.
    The project then serializes the objects into JSON format, which is returned to
    the client. Finally, the project is throttled to run once a month.
  prefs: []
  type: TYPE_NORMAL
- en: So, by working through this chapter, you have created a FinTech API that you
    can run once a month. This API will provide dividend payment information for the
    current year. Your clients can deserialize this data and then perform LINQ queries
    on it to extract data that meets their specific requirements.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be using PostSharp to implement **Aspect-Oriented
    Programming **(**AOP**). With our AOP framework, we will learn how to manage common
    functionalities such as exception handling, logging, security, and transactions
    within our applications. But before that, let's put your brain to work to see
    what you have learned.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What URL is a good source for hosting your own APIs and accessing third-party
    APIs?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the two required parts for securing an API?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are claims and why should you use them?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What do you use Postman for?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why should you use the repository pattern for your data store?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/aspnet/web-api/overview/security/individual-accounts-in-web-api](https://docs.microsoft.com/en-us/aspnet/web-api/overview/security/individual-accounts-in-web-api) is
    Microsoft''s in-depth guide to web API security.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/aspnet/web-forms/overview/older-versions-security/membership/creating-the-membership-schema-in-sql-server-vb](https://docs.microsoft.com/en-us/aspnet/web-forms/overview/older-versions-security/membership/creating-the-membership-schema-in-sql-server-vb) covers
    creating the ASP.NET membership database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.iso20022.org/10383/iso-10383-market-identifier-codes](https://www.iso20022.org/10383/iso-10383-market-identifier-codes)
    is about ISO 10383 MIC.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-gb/azure/key-vault/vs-key-vault-add-connected-service](https://docs.microsoft.com/en-gb/azure/key-vault/vs-key-vault-add-connected-service) covers
    adding key vault to your web application by using Visual Studio Connected Services.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://aka.ms/installazurecliwindows](https://aka.ms/installazurecliwindows) is
    about the Azure CLI MSI installer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/azure/key-vault/service-to-service-authentication](https://docs.microsoft.com/en-us/azure/key-vault/service-to-service-authentication) is
    the Azure service-to-service documentation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://azure.microsoft.com/en-gb/free/?WT.mc_id=A261C142F](https://azure.microsoft.com/en-gb/free/?WT.mc_id=A261C142F) is
    where you can sign up for your free 12-month subscription to Azure if you are
    a new customer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/azure/key-vault/basic-concepts](https://docs.microsoft.com/en-us/azure/key-vault/basic-concepts) looks
    at the Azure Key Vault basic concepts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/azure/app-service/app-service-web-get-started-dotnet](https://docs.microsoft.com/en-us/azure/app-service/app-service-web-get-started-dotnet) covers
    creating a .NET Core app in Azure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-gb/azure/app-service/overview-hosting-plans](https://docs.microsoft.com/en-gb/azure/app-service/overview-hosting-plans) provides
    an Azure App Service plan overview.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/azure/key-vault/tutorial-net-create-vault-azure-web-app](https://docs.microsoft.com/en-us/azure/key-vault/tutorial-net-create-vault-azure-web-app) is
    a tutorial on using Azure Key Vault with an Azure web app in .NET.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
