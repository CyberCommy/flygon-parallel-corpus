- en: 'Chapter 11. When it''s Time to Go Live: Moving to Production'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The final topic we will cover on the subject of testing and debugging Django
    applications is the move to production. When the application code is all written,
    fully tested and debugged, it is time to set up a production web server and make
    the application accessible to real users. Since the application has been fully
    tested and debugged during development, this should be straightforward, right?
    Unfortunately, not always. There are a number of differences between a production
    web server environment and the Django development server environment. These differences
    can cause problems during the move to production. In this chapter, we will see
    what some of these differences are, what types of problems they can cause, and
    how to overcome them. Specifically, we will:'
  prefs: []
  type: TYPE_NORMAL
- en: Configure an Apache web server with `mod_wsgi` to run the sample `marketr` project.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encounter a number of issues during development of the Apache configuration.
    For each, we will see how to diagnose and address the problem.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Perform functional stress testing of the application running under Apache to
    ensure that it operates correctly under load.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fix any code errors revealed by the functional stress testing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discuss the possibility of using Apache with `mod_wsgi` during development.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing an Apache/mod_wsgi configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ordinarily, the move to production will involve running the code on a machine
    other than the ones it has been developed on. The production server might be dedicated
    hardware or resources obtained from a hosting provider. In either case, it is
    typically entirely separate from the machines used by developers when writing
    the code. The production server needs to have any of the pre-requisite packages
    installed (Django and matplotlib, for example, for our sample project). In addition
    a copy of the application project code, generally extracted from a version control
    system, needs to be placed on the production server.
  prefs: []
  type: TYPE_NORMAL
- en: For the sake of simplicity in this chapter, though, we are going to configure
    a production web server on the same machine where we have been developing the
    code. This will allow us to skip over some of the complexity involved in a real
    move to production while still experiencing many of the issues that may arise
    during production deployment. For the most part the issues we will skip over in
    doing this are not Django-specific, but rather are common issues that need to
    be dealt with whenever moving any kind of application from development into production.
    The issues we will encounter will tend to be more Django-specific.
  prefs: []
  type: TYPE_NORMAL
- en: The example deployment environment that will be developed is Apache with `mod_wsgi`,
    which is the current recommended environment for deploying Django applications.
    **WSGI** stands for **Web Server Gateway Interface**. WSGI is a Python standard
    specification that defines an interface between web servers (Apache, for example)
    and web applications or frameworks written in Python (Django, for example).
  prefs: []
  type: TYPE_NORMAL
- en: The base Apache web server does not support WSGI. However, Apache's modular
    structure allows such support to be provided by a plug-in module. Thus, the web
    server side support for WSGI is provided by `mod_wsgi`, an Apache module written
    and actively maintained by Graham Dumpleton. Django itself does implement the
    application side of the WSGI specification. Thus, there is no need for any additional
    adapter module between `mod_wsgi` and Django.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Prior to the development of `mod_wsgi`, the `mod_python` module for Apache was
    the recommended deployment environment for Django. Though `mod_python` is still
    available and even still in wide use, its most recent release was over three years
    ago. The current source code needs a patch in order to compile with the latest
    Apache 2.2.X release. Going forward, more extensive changes will be needed due
    to changes in Apache APIs, but there are no active `mod_python` developers to
    make such changes. Given the current moribund state of `mod_python` development,
    I believe it is now a poor choice for Django application deployment. Therefore,
    specifics of configuring it are not covered here. If for some reason you must
    use `mod_python`, many of the issues encountered in this chapter with `mod_wsgi`
    apply to `mod_python` as well, and the specifics of configuring `mod_python` are
    still included in the Django documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Both Apache and `mod_wsgi` are readily obtained and easily installed on a variety
    of different platforms. Details of installation for these will not be covered.
    As a general guide, using your machine's regular package management service to
    install these packages is likely the easiest path. If that isn't possible, details
    of downloading and installing Apache can be found on the Web at [http://httpd.apache.org/](http://httpd.apache.org/)
    and the same information for `mod_wsgi` can be found at [http://code.google.com/p/modwsgi/](http://code.google.com/p/modwsgi/).
  prefs: []
  type: TYPE_NORMAL
- en: The machine used to develop the sample configuration shown in this chapter is
    running Ubuntu, a Debian-based version of Linux. This flavor of Linux has developed
    a particular structure for Apache configuration that may not match the structure
    used on your own machine. The configuration structure, however, is not significant.
    Rather it is the Apache directives contained in the configuration that are important.
    If your machine does not follow the Debian structure, you may simply place the
    directives shown here in the main Apache configuration file, usually named `httpd.conf`.
  prefs: []
  type: TYPE_NORMAL
- en: There are two pieces to the configuration for a WSGI client application running
    under Apache with `mod_wsgi`. First, there is a Python WSGI script that sets up
    the environment for and identifies the WSGI client application that will handle
    requests. Second, there are the Apache configuration directives that control the
    operation of `mod_wsgi` and direct requests for particular URL paths to `mod_wsgi`.
    Creating each of these for the Django `marketr` project will be discussed next.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the WSGI script for the marketr project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The WSGI script for a Django project has three responsibilities. First, it must
    set the Python path to include any paths that are needed by the Django project
    but are not on the regular system path. In our case, the path to the `martketr`
    project itself will need to be added to the Python path. All of the other pre-requisite
    code used by the project has been installed so that it is automatically found
    under the Python site-packages directory.
  prefs: []
  type: TYPE_NORMAL
- en: Second, the WSGI script must set the `DJANGO_SETTINGS_MODULE` variable in the
    environment to point to the appropriate settings module. In our case, it will
    need to be set to point to the `settings.py` file in `/dj_projects/marketr`.
  prefs: []
  type: TYPE_NORMAL
- en: Third, the WSGI script must set the variable `application` to an instance of
    a callable that implements the WSGI interface. For Django, this interface is provided
    by `django.core.handlers.wsgi.WSGIHandler`, so the script for the `marketr` project
    may simply set `application` to an instance of that class. There is nothing specific
    to the `marketr` project here—this piece of the WSGI script will be the same for
    all Django projects.
  prefs: []
  type: TYPE_NORMAL
- en: Where should this script go? It might seem natural to place it directly in `/dj_projects/marketr`,
    along with the `settings.py` and `urls.py` files, since they are all project-level
    files. However, as mentioned in the `mod_wsgi` documentation, this would be a
    poor choice. Apache will need to be configured to allow access to files in the
    directory containing the WSGI script. Thus, it is best to keep the WSGI script
    in a directory separate from any code files that should not be accessible to website
    users. (The directory containing `settings.py`, in particular, should never be
    configured to be accessible to website clients, since it may contain sensitive
    information such as the database password.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, we will create a new directory inside `/dj_projects/marketr` named
    `apache`, to hold all of the files related to running the project under Apache.
    Under the `apache` directory, we''ll create a `wsgi` directory to hold the WSGI
    script for the `marketr` project, which we will name `marketr.wsgi`. Based on
    the three responsibilities previously noted for this script, a first pass at implementing
    this `/dj_projects/marketr/apache/wsgi/marketr.wsgi` script might be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This code adds the `marketr` project directory at the front of the Python system
    path, sets the `DJANGO_SETTINGS_MODULE` environment variable to `marketr.settings`,
    and sets `application` to be an instance of the Django-provided callable that
    implements the WSGI application interface. When `mod_wsgi` is called to respond
    for a URL path that has been mapped to this script, it will call the appropriate
    Django code with an environment correctly set so that Django will be able to handle
    the request. The next step, then, is to develop the Apache configuration that
    will route requests appropriately to `mod_wsgi` and this script.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an Apache VirtualHost for the marketr project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to isolate the Django project from anything else that you might already
    be using Apache for, we will use an Apache `VirtualHost` tied to port 8080 for
    the Django configuration. The following directives instruct Apache to listen for
    requests on port 8080 and define a virtual host to handle those requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note that this is in no way a complete Apache configuration, but is rather what
    needs to be added to an existing (or the shipped sample) configuration to support
    handling requests for the `marketr` project directed at port 8080\. Inside the
    `VirtualHost` container are three directives that control the behavior of `mod_wsgi`,
    and three that will affect how logging is handled for this virtual host.
  prefs: []
  type: TYPE_NORMAL
- en: The first directive, `WSGIScriptAlias`, is straightforward. It maps all requests
    matching its first argument, `/`, to the WSGI script specified in its second argument,
    `/dj_projects/marketr/apache/wsgi/marketr.wsgi`. The effect of this directive
    will be to have all requests for this virtual host routed to the `marketr` WSGI
    script defined in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: The next two directives, `WSGIDaemonProcess` and `WSGIProcessGroup`, instruct
    `mod_wsgi` to route requests for this virtual host to an independent group of
    processes, distinct from the normal Apache child processes used to service requests.
    This is referred to as running `mod_wsgi` in daemon mode. By contrast, having
    `mod_wsgi` use the normal Apache child processes is referred to as running in
    embedded mode.
  prefs: []
  type: TYPE_NORMAL
- en: Generally running in daemon mode is preferable (see the `mod_wsgi` documentation
    for full details as to why), but this mode is not supported when running Apache
    on Windows. Thus, if you are using a Windows machine for your Apache server, you
    will need to omit these two directives from your configuration.
  prefs: []
  type: TYPE_NORMAL
- en: In the directives shown, the `WSGIDaemonProcess` directive defines a process
    group named `marketr`. This directive supports several additional arguments that
    can be used to control, for example, the number of processes in the group, the
    number of threads in each process, and the user and group for the processes. None
    of those arguments have been specified here so `mod_wsgi` will use its default
    values. The `WSGIProcessGroup` directive names the previously-defined `marketr`
    group as the one to use for handling requests for this virtual host.
  prefs: []
  type: TYPE_NORMAL
- en: The next directive, `LogLevel debug`, sets logging to its most verbose setting.
    A more typical setting for production would be `warn`, but when just getting started
    setting something up, it is frequently useful to have the code log as much information
    as possible, so we will use `debug` here.
  prefs: []
  type: TYPE_NORMAL
- en: The final two directives, `ErrorLog` and `CustomLog`, define error and access
    logs for this virtual host, distinct from the main Apache error and access logs.
    This can be convenient to isolate log information related to the new project from
    any other traffic Apache may be handling. In this case, we have directed Apache
    to place the logs in a `logs` directory under the `/dj_projects/marketr/apache`
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: Activating the new Apache configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Where should the configuration directives from the previous section be placed?
    As noted earlier, the answer depends on the specifics of how Apache is configured
    on your machine. For an Apache configuration that consists of a single `httpd.conf`
    file, you may simply place the directives at the end of that file. Although that
    may also work for more structured configurations, it is better to avoid confusion
    and use the provided structure. Thus, this section will describe how to integrate
    the definitions previously listed into a Debian-based configuration, since that
    is the type of machine being used for the example project.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a Debian-based Apache configuration, the `Listen` directive should be placed
    in `/etc/apache2/ports.conf`. The `VirtualHost` directive, and all it contains,
    should be placed in a file under `/etc/apache2/sites-available`. For this example,
    though, the virtual host configuration has been placed in a file `/dj_projects/marketr/apache/conf/marketr`
    so that the `/dj_projects` directory can contain complete configuration information
    for the project. We can make this file also appear in the `sites-available` directory
    by creating a symbolic link for it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note that general users cannot create or modify files under `/etc/apache2/sites-available`,
    so the `sudo` command is needed to perform the requested command as a superuser.
    This is necessary for all commands that modify the Apache configuration or control
    its operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the file containing the virtual host configuration is in place in `sites-available`,
    the `a2ensite` command can be used to enable the new site:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `a2ensite` command creates a symbolic link in the `/etc/apache2/sites-enabled`
    directory to the specified file in the `sites-available` directory. There is a
    companion command, `a2dissite`, that disables a site by removing the symbolic
    link for it in `sites-enabled`. (Note that you can also manage the symbolic links
    manually and not use these commands, if you prefer.)
  prefs: []
  type: TYPE_NORMAL
- en: 'As noted by the output of `a2ensite`, it is necessary to reload Apache in order
    for the new site configuration to take effect. In this case, since a `Listen`
    directive was added, a full restart of Apache is required. That is done by running
    the `/etc/init.d/apache2` command and specifying `restart` as an argument. When
    we try that, the response is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Activating the new Apache configuration](img/7566_11_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The **[fail]** on the right-hand side of the screen does not look good. Something
    apparently went wrong during restart, but what? The answer is not found in the
    output of the command used to restart Apache, which only reports success or failure.
    Rather, the Apache error log contains details of the reason for the failure. Further,
    for a failure related to server start-up, it will likely be the main Apache error
    log that contains the detailed information, not a site-specific error log. On
    this machine, the main Apache error logfile is `/var/log/apache2/error.log`. Looking
    at the end of that file, we find the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The problem is that the new virtual host configuration specified a directory
    for the error logfile that does not exist. Apache will not automatically create
    the specified directory, thus we need to create it manually. Doing that and again
    attempting to restart Apache produces a better result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Activating the new Apache configuration](img/7566_11_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**[ OK ]** certainly looks better than **[fail]**; apparently this time Apache
    was able to start successfully. We''ve now gotten to the point where we have a
    valid Apache configuration, but there may still be some work to do to get a working
    configuration, as we will see next.'
  prefs: []
  type: TYPE_NORMAL
- en: Debugging the new Apache configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The next test is to see whether Apache will successfully process a request
    directed to the new virtual host''s port. To do that, let''s try to retrieve the
    project root (home) page from a web browser. The result does not look good:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Debugging the new Apache configuration](img/7566_11_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'What might be wrong now? In this case, the main Apache error log is silent
    on the reason for the error. Rather, it is the error log configured for the `marketr`
    virtual site that provides an indication of the problem. Checking that file, we
    see that the full content of `/dj_projects/marketr/apache/logs/error.log` is now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Except for the last one, none of these messages indicate a problem. Rather they
    are informational and debug level messages logged by `mod_wsgi`, as requested
    by the setting of `LogLevel debug` in the virtual host configuration. These messages
    show `mod_wsgi` reporting on various values (deadlock timeout, inactivity timeout)
    it is using, and show that `mod_wsgi` started 15 threads in the daemon process
    `marketr`. All looks good until the last line, which is an error level message.
  prefs: []
  type: TYPE_NORMAL
- en: The specifics of this last message are not much more helpful than the bare **Forbidden**
    displayed by the web browser. The message does indicate that the `marketr.wsgi`
    script is involved, and that the request is **denied by server configuration**.
    In this case, the problem is not that the file does not exist, but rather that
    the server has been configured to not allow access to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The cause of this specific problem lies elsewhere in the Apache configuration
    on this machine, and this is a problem you may or may not encounter depending
    on your overall Apache configuration. The problem is that this machine''s Apache
    configuration has been set up to deny access to files in all directories except
    those that are explicitly enabled for access. This type of configuration is good
    from a security standpoint, but it does make configuration a bit more tedious.
    In this case, what is needed is a `Directory` block that allows access to files
    in the directory containing the `marketr.wsgi` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The details of Apache's three-pass access control system is beyond the scope
    of this book; if you are interested, the Apache documentation describes the process
    in detail. For our purposes, it is sufficient to note that this `Directory` block
    allows all clients to access files in `/dj_projets/marketr/apache/wsgi`, which
    should be acceptable and enough to get past the **Forbidden** initially returned
    by the browser for the `marketr` project's home page.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Directory` block should be placed inside the `VirtualHost` block for the
    `marketr` project. Changing the configuration requires an Apache restart, after
    which we can try again to access the project home page. This time we see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Debugging the new Apache configuration](img/7566_11_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The good news is we got past the **Forbidden** error. The bad news is we did
    not get much farther. Again the page returned to the browser is of little use
    in debugging the problem, rather the site''s error log is where details of the
    problem are recorded. This time at the end of the file we find:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Clearly, the `marketr.wsgi` script did get used this time, since the traceback
    shows that Django code has been called. But the environment was not set up entirely
    correctly, since Django is unable to import the specified `marketr.settings` settings
    module. This is a commonly-encountered error that is almost always due to one
    of two things: either the Python path has not been set properly, or the user that
    the Apache process runs as does not have read access to the settings file (and
    the directory that contains it).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, a quick check of the permissions on the `/dj_projects/marketr`
    directory and its files show that they are readable by all:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Thus, it does not seem likely the problem is related to the ability of the web
    server process to access the `settings.py` file. Note, however, if you are running
    a version of Linux that uses the security-enhanced kernel (SELinux kernel), the
    permissions information displayed by `ls -l` may be misleading. This kernel has
    a complex file access control structure that requires additional configuration
    (beyond the scope of this book) in order to allow the web server process to access
    files outside of its own designated area.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, though, the machine is not running the SELinux kernel and the
    permissions information shows that any process can read the `settings.py` file.
    The problem, then, is likely in the path setting. Recall that the path and settings
    specification in the `marketr.wsgi` script is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: That path does not work to import a settings file specified as `marketr.settings`
    because the `marketr` part has been duplicated in both the path and the module
    specification. Python, in trying to find the module and using the first element
    on the path, will attempt to find a file named `/dj_projects/marketr/marketr/settings.py`.
    This will fail since the actual file is `/dj_projects/marketr/settings.py`. Unless
    `/dj_projects` alone is on `sys.path`, Python will not be able to load `marketr.settings`.
  prefs: []
  type: TYPE_NORMAL
- en: 'One fix, then, is to include `/dj_projects` in the path setting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'It seems a bit odd, though, to need to add two different items to the path
    for a single project. Are both really necessary? The first is necessary because
    throughout the survey application code, for example, we used imports of the form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Since `marketr` is not included in those imports, it must be included in an
    element of the Python path. When running the development server, the `/dj_projects/marketr`
    directory is the current path, which is automatically included in the Python path,
    so these imports work. When running under Apache, `/dj_projects/marketr` must
    be included on the path for these imports to work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, we could change all the imports in both the `survey` and `gen_utils`
    applications to use the form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This approach, however, ties these applications tightly to the `marketr` project,
    making it harder to re-use them outside of that one project. I feel it is better
    practice to make applications independent and not include in their imports the
    name of the containing project.
  prefs: []
  type: TYPE_NORMAL
- en: 'What about `/dj_projects`—does that really need to be included in the path?
    Could we eliminate needing to have it in the path by specifying the settings module
    as simply `settings` instead of `marketr.settings`? Yes, that would get us past
    this particular error, but we would quickly hit another similar error when the
    `ROOT_URLCONF` value in the settings file was processed. `ROOT_URLCONF` also includes
    `marketr` in its specification:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We could change that as well, and hope it is the last one, but it is probably
    easier to just include `/dj_projects` in the path when running under the web server.
  prefs: []
  type: TYPE_NORMAL
- en: You might wonder how `/dj_projects` was included in the path when running under
    the development server, since the parent of the current directory is not generally
    included in the Python path the way the current directory is. The answer is that
    the setup code for the development server places the parent of the project directory
    in the Python path. This can be helpful to people new to Python when starting
    out, but often causes confusion in the long run, since it is somewhat surprising
    behavior to anyone who is not new to Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'To proceed from this point, however, we will just include `/dj_projects` as
    well as `/dj_projects/marketr` in the Python path, as previously shown. Note that
    when running `mod_wsgi` in daemon mode, it is not necessary to reload or restart
    Apache to get it to pick up changes to the WSGI script. Changing the WSGI script
    itself is sufficient to cause `mod_wsgi` to automatically restart its daemon processes.
    Thus, all we need to do is save the modified file and again try to access the
    project home page. This time we see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Debugging the new Apache configuration](img/7566_11_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Again, we have good news and bad news. We certainly got further, and the Django
    code is working well enough to return a debug page, which is encouraging and easier
    to deal with than having to go search in the Apache error logs for the problem.
    Unfortunately, the fact that we got a debug page and not the project home page
    means there is still more that is not quite right in the environment when running
    under the web server.
  prefs: []
  type: TYPE_NORMAL
- en: 'This time the exception information indicates that the `matplotlib` code needs
    write access to a directory for its configuration data. It apparently tried to
    create a directory named `/var/www/.matplotlib`, and that failed. The message
    suggests that if an environment variable named `MPLCONFIGDIR` is set to point
    to a writable directory, we may get past this problem. We can certainly set this
    environment variable in the `marketr.wsgi` script, just as the `DJANGO_SETTINGS_MODULE`
    environment variable is set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to create the directory specified there and make it writeable
    by the web server process. The easiest way to do this is to simply change the
    owner of the directory to the user the web server process runs as, which on this
    machine is `www-data`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Alternatively, the `WSGIDaemonProcess` directive in the virtual host configuration
    could be changed to specify a different user. But the only user that would have
    write access, by default, to directories under `/dj_projects` would be my own
    user, `kmt`, and I would prefer not to have a web server process running with
    write access to all of my own files. Thus, it is easier to simply let the web
    server continue to run as `www-data` and explicitly give it permission to access
    directories as necessary. Note that if you are using SQLite as your database,
    you will also need to set permissions on the database file so that the Apache
    process can read and write it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Have we got past the last problem yet? Saving the changed `marketr.wsgi` file
    and retrying the project home page brings up the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Debugging the new Apache configuration](img/7566_11_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Success at last, of a sort. There are no surveys displayed on the home page
    because enough time has passed that the one closed `survey` we had been working
    with has now been closed for too long to be listed. Thus, there is not much of
    interest to see on the home page. The next natural step in testing is to go to
    the admin application and change the `closes` date on the survey so that it will
    appear on the home page. Attempting to do this reveals some configuration we have
    not yet set up, which will be discussed next.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Apache to serve static files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Attempting to access the admin application running under Apache, we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![CoApache/mod_wsgi configurationnew configuration, debuggingnfiguring Apache
    to serve static files](img/7566_11_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: That looks a lot like our sample project pages, bare of any custom styling.
    But the admin application, unlike our sample project, does have stylesheets it
    uses, which were correctly loaded when running under the development server. That
    was done by special-purpose code in the development server. When running under
    Apache, we need to configure it (or some other web server) to serve the admin
    application's static files.
  prefs: []
  type: TYPE_NORMAL
- en: How do we do that? All of the admin's static files will be referenced using
    the same prefix, specified by `ADMIN_MEDIA_PREFIX` in `settings.py`. The default
    value for this setting is `/media/`. Thus, we need to instruct Apache to serve
    files with this prefix directly from the admin's media directory tree, instead
    of routing the request to `mod_wsgi` and our Django project code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Apache directives to accomplish this are (note that though the `Alias`
    and `Directory` lines below are split due to page width constraints, these need
    to be placed on single lines in the Apache configuration file):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The first directive, `Alias`, sets up a mapping from URL paths that start with
    `/media` to the actual files which are located (on this machine) under `/usr/lib/python2.5/site-packages/django/contrib/admin/media/`.
    The following `Directory` block instructs Apache to allow all clients to access
    files in the directory where the admin media is located. Like the `Directory`
    block for the `marketr.wsgi` script, this is only needed if your Apache configuration
    has been set up to deny access to all directories by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'These directives should be placed in the `VirtualHost` block for the `marketr`
    project virtual host. Apache then needs to be reloaded to recognize the configuration
    changes. Reloading the admin page in the browser then brings up a page with the
    correct custom styling:'
  prefs: []
  type: TYPE_NORMAL
- en: '![CoApache/mod_wsgi configurationnew configuration, debuggingnfiguring Apache
    to serve static files](img/7566_11_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Note, though, it is not only admin that has static files. In [Chapter 9](ch09.html
    "Chapter 9. When You Don''t Even Know What to Log: Using Debuggers"), *When You
    Don''t Even Know What to Log: Using Debuggers*, we added some use of static files
    into the `marketr` project. Specifically, the image files generated by matplotlib
    to show survey results are served as static files. These files, unlike the admin
    media files, were not automatically served by the development server, so we had
    to add an entry for them in the `marketr` project `urls.py` file, specifying that
    they be served by the Django static server view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This configuration would still work to serve the files under Apache, but the
    static server is not recommended for use in production. Besides being a very inefficient
    way to serve static files, the static server code has not been audited for security.
    Thus, for production, this URL pattern should be removed from the `urls.py` file
    and Apache (or another server) should be configured to serve these files directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The directives to get Apache to serve these files are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: These are nearly identical to the directives needed for the admin media files,
    only modified to specify the URL path prefix used for the site media files, and
    the actual location of those files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Is that all? Not quite. Unlike the admin media files, the image files used
    by the `marketr` project are actually generated on-demand by the `marketr` project
    code. If we delete the existing image files and attempt to access the detail page
    for the completed survey, we will get an error when the web server process attempts
    to create one of the image files, as the following shows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![CoApache/mod_wsgi configurationnew configuration, debuggingnfiguring Apache
    to serve static files](img/7566_11_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To fix this, the web server code will need write access to the directory containing
    the files. This can be done by changing the owner of the directory `/dj_projects/marketr/site_media
    /piecharts` to `www-data`, as was done for the matplotlib configuration directory.
    After we make that change, attempting to reload the survey detail page shows that
    the web server is now able to create the image files, as the following shows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![CoApache/mod_wsgi configurationnew configuration, debuggingnfiguring Apache
    to serve static files](img/7566_11_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We have now got the project up and running under Apache. Next, we will consider
    whether there are any additional potential problems we might run into as a result
    of differences between the development and production web server environments.
  prefs: []
  type: TYPE_NORMAL
- en: Testing multithreaded behavior
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we encountered a few environmental differences between
    running under the development server and running under Apache. Some of these (for
    example, file permissions and Python path differences) caused problems that had
    to be overcome before we could get the project functioning properly under Apache.
    One difference we observed, but have not yet encountered a problem with, is multithreading.
  prefs: []
  type: TYPE_NORMAL
- en: When we checked the error log in the previous section we could see that `mod_wsgi`
    had started one process with 15 threads, each ready to handle an incoming request.
    Multiple requests that arrive at the server nearly simultaneously, then, will
    be dispatched to different threads for handling, and the steps of their execution
    may be arbitrarily interleaved in real time. This can never happen with the development
    server, which is strictly single threaded, ensuring each request is fully processed
    before processing of the next one is started. It also never happens with any of
    the test tools covered in the first five chapters, since they too all test in
    a single-threaded manner.
  prefs: []
  type: TYPE_NORMAL
- en: In Chapter 9 we already noted the need to keep in mind potential multithreading
    issues. In that chapter, we wrote the code to generate the image files for the
    display of survey results. The images are generated on-demand when the first request
    to display the survey is received after the survey has closed. Generating the
    image and writing it to disk took a perceptible amount of time, and it was fairly
    obvious that the code needed to properly handle the case where a second request
    was received for the survey results, but the processing of the first request had
    not yet completed.
  prefs: []
  type: TYPE_NORMAL
- en: In that chapter, we learned how we could use breakpoints in the debugger to
    force multiple threads to execute in a particular sequence. In this way, we saw
    how we could test to ensure that the code behaved properly in whatever worst-case
    interleaved execution scenarios might arise in a multithreaded environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'But it is not only operations that take a significant amount of time, such
    as generating images or writing files, that we need to be concerned with. Under
    a heavy request load in a multithreaded environment, even the processing of requests
    that are generally quite quick may get interrupted and interleaved with processing
    from other requests being handled at the same time. On a multiprocessor machine,
    it''s not even necessary for one request to be interrupted: a second request could
    be running on a second processor truly simultaneously.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Is there any code in the `marketr` project that might not function properly
    in a multithreaded environment? Possibly. Generally, the first code to consider
    for potential multithreading problems is any code that updates data. For the `survey`
    application, there is one view that updates data on the server: the one that receives
    and records posted survey results.'
  prefs: []
  type: TYPE_NORMAL
- en: Are we sure the survey results recording code will function properly when it
    is run in a multithreaded environment where many copies of it may be running simultaneously?
    Since we have not tested it, no, we can't be sure. But now that we have the code
    running in a multithreaded environment, we can try testing it and see the outcome.
  prefs: []
  type: TYPE_NORMAL
- en: Generating load with siege
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Having the code available for testing in a multithreaded environment is only
    half of what is needed to effectively test multithreaded behavior. The other half
    is some way of generating many simultaneous requests for the server to process.
    There are a number of different tools that can be used for this. The one we will
    use here is called `siege`, a freely available command line tool written by Jeffrey
    Fulmer. Information on downloading and installing `siege` can be found at [http://www.joedog.org/index/siege-home](http://www.joedog.org/index/siege-home).
  prefs: []
  type: TYPE_NORMAL
- en: 'Once installed, `siege` is very easy to use. The simplest way to call it is
    to pass a URL on the command line. It will start up several threads and continuously
    request the passed URL. As it runs, it displays what it is doing and key information
    about the responses it is receiving. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Here we see `siege` called to continuously request the project home page. During
    startup, it reports its version and prints out how many threads it will be using
    to make simultaneous requests. The default, as seen here, is 15; the `-c` (for
    concurrent) command line switch could be used to change that. `Siege` then prints
    out information about each request it sends. For each, it prints the protocol
    used (here all `HTTP/1.1`), the response code received (`200`), how long it took
    for the response to arrive (between `.02` and `.06` seconds), how many bytes in
    the response (`986`), and finally the URL path for the request.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default `siege` will keep running until interrupted by *Ctrl-C*. When interrupted,
    it will stop generating load and report statistics on the results. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The tool made slightly over 700 requests and all received responses, as indicated
    by the report of 100 percent availability and 0 failed transactions. The performance
    numbers reported are interesting, but since we are presently running on a development
    machine with debug still turned on, it is a little early to be reading much into
    performance numbers. What we really want to check is whether the code that processes
    survey responses behaves correctly when called in a multithreaded environment
    under heavy load. We will consider how to do that next.
  prefs: []
  type: TYPE_NORMAL
- en: Load testing the results recording code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: How can we use `siege` to test the code that records survey answers? First,
    we need a survey in the database that is still open and thus will accept posted
    responses. The easiest way to do this is to use the admin application and change
    the `closes` date on the existing **Television Trends** survey to be some time
    in the future. At the same time, we can change the answer counts for all of the
    answers in the survey to be 0, which will make it easy to tell if all of the responses
    we generate with `siege` are processed correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next we need to determine what URL to specify to `siege` to get it to POST
    valid data for the survey''s form. The easiest way to do this is to bring up the
    page that displays the survey form in a browser and check the HTML source to see
    what the form fields are named and what the valid values for each are. In this
    case, the source HTML for the form displayed when we retrieve `http://localhost:8080/1/`
    is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The form has two radio group inputs, one named `answer` and one named `1-answer`.
    Valid choices for `answer` are `1`, `2`, and `3`. Valid choices for `1-answer`
    are `4`, `5`, and `6`. Thus, we want to instruct `siege` to POST to `http://localhost:8080/1/`
    a value between `1` and `3` for `answer` and between `4` and `6` for `1-answer`.
    The way to do this, arbitrarily choosing the first choice for both questions,
    is to specify the URL as `"http://localhost:8080/1/ POST answer=1&1-answer=4"`.
    Note that the quotes around this URL are needed when passing it as a parameter
    on the command line due to the spaces and `&` in it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to get a predictable number of requests generated, we can specify
    the `-r` command line switch, specifying the number of test repetitions. If we
    leave the default number of concurrent threads at 15 and specify 5 repetitions,
    at the end of the test we should see that the two chosen answers each have 5*15,
    or 75 votes. Let''s try it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Here the output is a bit different from the first example. The `survey` application
    response to a successful POST of a survey response is an HTTP redirect (status
    302). The `siege` tool, like a browser, responds to the received redirect by requesting
    the location specified in the redirect response. The previous output, then, is
    showing that the POST requests are succeeding, and then the subsequent redirects
    to the thanks page for the survey are also succeeding.
  prefs: []
  type: TYPE_NORMAL
- en: 'The tail end of the output for this test run is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: That looks good. The total number of transactions is twice the number of posts
    requested, indicating that all of the POST requests returned a redirect, so they
    were all successfully processed. From the client side, then, it appears that the
    test ran successfully.
  prefs: []
  type: TYPE_NORMAL
- en: 'But do the vote counts on the server match up to what we expect? Answers 1
    (**Comedy**) and 4 (**Hardly any: I already watch too much TV!**) were each posted
    75 times, so we expect that they each have 75 votes while all of the other answers
    have none. Checking the vote count for the first question in the admin application,
    we see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Load testing the results recording code](img/7566_11_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Similarly, checking the second question we see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Load testing the results recording code](img/7566_11_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: That's not good. While the `votes` values that were supposed to be 0 are all
    indeed **0**, the two `votes` values that were supposed to be 75 are instead **40**
    and **34**. Based on the results sent to the client, the server appeared to process
    all of the requests successfully. Yet clearly many of the votes were not actually
    recorded. How did that happen? The answer lies in the code that attempts to record
    posted survey responses, which we will check next.
  prefs: []
  type: TYPE_NORMAL
- en: Fixing the results recording code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Recall that the code which records posted survey answers is in the `display_active_survey`
    function in `survey/views.py`. This code processes both GET and POST requests.
    In the case of a POST, the code to validate and record the submitted values is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This code runs fine and behaves properly when a single thread runs through it
    at a time. However, if multiple threads (from the same or different processes)
    are running through it simultaneously, all trying to increment `votes` value for
    the same answers, this code is likely to lose votes. The problem is that retrieving
    the current `votes` value, incrementing it, and saving the new value is not atomic.
    Rather it is done in three distinct steps that may be interleaved with the same
    steps done by another thread simultaneously.
  prefs: []
  type: TYPE_NORMAL
- en: Consider two threads running concurrently, both attempting to record a vote
    for the `Answer` with primary key value 1\. (For simplicity, we will assume there
    is only one question in the survey.) The first thread enters this code and runs
    through the `for qf in qforms` loop validating the forms. It is during this loop
    that the current `votes` value for the chosen answer will be read from the database.
    Let's say the value that the first thread reads for the `votes` value for answer
    with primary key 1 is 5.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, before this first thread is able to finish its work and save an incremented
    value of 6 for the `votes` field to the database, a second thread (either through
    pre-emptive scheduling or multiprocessor execution) enters the `for qf in qforms`
    loop. The posted form data this second thread is working with also specifies a
    vote for the answer with primary key 1\. This second thread also reads a current
    value of 5 for the `votes` value for this answer. Now we have a problem: two threads,
    both intending to increment the `votes` value for the same answer, both read the
    same existing value, and both will increment that value and save the result. Together
    the two threads will only cause the `votes` count to be incremented by one: one
    of the votes will effectively be lost.'
  prefs: []
  type: TYPE_NORMAL
- en: 'How do we fix this problem? For this simple case of incrementing (or performing
    some other arithmetic operation on) an existing field''s value in the database,
    it is reasonably easy to avoid the problem. We can slightly change the code in
    the `for answer in chosen_answers` loop to use a Django `F` expression to describe
    the desired result for `votes` instead of giving it an explicit numerical value.
    The changed code looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Use of an `F` expression in the value for `votes` will cause Django to construct
    an `UPDATE` SQL statement of the form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This type of `UPDATE` statement pushes the responsibility of ensuring that the
    increment operation is atomic onto the database server. That is generally where
    you want to place such responsibility, since that is exactly what database servers
    are supposed to do both correctly and efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we now save this change to the code, reset all the vote counts to 0, and
    re-run the `siege` test, the problem will hopefully be gone. Only it is not! Checking
    the `votes` values again after running the test shows the same behavior: for the
    two answers that should have values of 75, one value is 43 and the other 39\.
    Why didn''t the code change fix the problem?'
  prefs: []
  type: TYPE_NORMAL
- en: The problem in this case is that the code change was not seen by the running
    web server process. When running under Apache with `mod_wsgi`, changes to the
    Django application code will not automatically cause a reload of the processes
    that handle requests. Thus, the existing running processes will continue to use
    the old code. When running in daemon mode, touching the WSGI script will trigger
    a reload on receipt of the next request. Alternatively, restarting Apache will
    ensure the new code is loaded. As we will see later in the chapter, it is also
    possible to code the WSGI script to automatically restart the daemon process when
    a code change is detected.
  prefs: []
  type: TYPE_NORMAL
- en: For now, since the existing WSGI script does not monitor for source code changes,
    and since we are running in daemon mode, touching the WSGI script is the easiest
    way to get the application code change loaded. If we do that, again use the admin
    application to reset the vote counts to 0, and again try the `siege` test, we
    see that when the test finishes the votes for the two chosen answers are indeed
    the correct value, 75.
  prefs: []
  type: TYPE_NORMAL
- en: Additional load testing notes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While we have successfully found and fixed a multithreading problem with the
    code that receives and records survey results, we have not done enough testing
    to ensure that the remainder of the application will behave properly in a typical
    production environment. A full test would involve load testing all views, both
    in isolation and in combination with each other, and ensures that the server responds
    correctly. Constructing such a test is beyond the scope of this book, but some
    notes about the process are included here.
  prefs: []
  type: TYPE_NORMAL
- en: First, for the problem we did find we were fortunate that a very simple code
    change, namely use of an `F` expression, was available to easily make the database
    update atomic. For other situations, Django may or may not provide a simple API
    to help ensure atomicity of updates. For creating objects, for example, Django
    does have an atomic `get_or_create` function. For more complicated situations,
    such as ones involving updating several values in different objects, there may
    not be a simple Django API to use to ensure atomicity.
  prefs: []
  type: TYPE_NORMAL
- en: In these cases, it will be necessary to use database support for maintaining
    data consistency. Some databases provide transactions to help with this, and Django
    in turn provides an API that allows an application to control transactional behavior.
    Other databases don't support transactions but do provide lower-level support,
    such as the ability to lock tables. Django does not provide an API for table locking,
    but it does allow applications to construct and execute arbitrary (raw) SQL, so
    an application can still use such functions. The disadvantage of using the raw
    SQL API is that the application will generally not be portable to a different
    database.
  prefs: []
  type: TYPE_NORMAL
- en: When setting out to create a new application, then, careful consideration should
    be given to the kinds of database updates the application will need to perform.
    If possible, it is best to structure the data so that simple atomic APIs can be
    used for all updates. If that is not possible, then use of database transactions
    or lower-level locking support may be required. The range of options available
    may be restricted by the database in use (if it is predetermined), and likewise
    the choice of specific technique used for ensuring data consistency may limit
    the databases on which the application will ultimately be able to run correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Second, while careful consideration and coding will help to ensure no multithreading
    surprises like the one bug we uncovered, explicit testing for problems like this
    is a good idea. Unfortunately, it is not something supported by the testing tools
    covered in the first five chapters, which all focus on verifying correct single-threaded
    behavior. Thus, some additional work will generally be required to augment the
    unit testing suite with additional tests that ensure correct behavior (and possibly
    some minimum level of performance) in a production environment under load. It
    may not be practical to expect individual developers to routinely run these additional
    tests, but having them available, and running them before placing any code updates
    into production, will save headaches in the long run.
  prefs: []
  type: TYPE_NORMAL
- en: Using Apache/mod_wsgi during development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As described throughout this chapter, the switch from using the Django development
    server to a production server such as Apache with `mod_wsgi` may run into various
    snags along the way. Some are easily overcome, others may require more effort.
    It is often inconvenient to encounter such difficulties late in the development
    cycle, when there is typically very little time available for making code changes.
    One way to make the transition smoother is to use a production server configuration
    during development. This is an idea worth some serious consideration.
  prefs: []
  type: TYPE_NORMAL
- en: One possible objection to using a production server (namely Apache with `mod_wsgi`)
    during development is that installing and properly configuring Apache is difficult.
    Asking individual developers to do this is asking too much of them. Installation,
    however, is not generally difficult—and most development machines today are easily
    capable of running Apache without causing any performance impact for other activities.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Apache can indeed be daunting, since there are many configuration
    directives and optional modules to consider. However, it is not necessary to become
    an expert in Apache configuration in order to successfully take a shipped default
    configuration and modify it to support running a Django application. The result
    may not be finely tuned for great performance under heavy load, but such tuning
    is not required for use of the configuration during development testing.
  prefs: []
  type: TYPE_NORMAL
- en: A second objection to using Apache during development may be that it is relatively
    inconvenient, compared to the development server. The console of the development
    server provides an easy way to check on what is going on; needing to consult the
    Apache log files is a bit of a nuisance in comparison. This is true but a very
    minor inconvenience.
  prefs: []
  type: TYPE_NORMAL
- en: A more serious inconvenience is the need to be sure the running web server processes
    are restarted in order to pick up code changes during development. It is very
    easy to get used to the development server's automatic restart, and forget the
    need to do something (even if it is as simple as touching the WSGI script file)
    to ensure that the web server is using the latest code.
  prefs: []
  type: TYPE_NORMAL
- en: However, it is in fact possible to set up the WSGI script for a Django project
    to behave in the same way as the development server. That is, the WSGI script
    can start up a code monitoring thread that checks for changed Python source files
    and triggers an automatic reload when necessary. Details of this can be found
    at [http://code.google.com/p/modwsgi/wiki/ReloadingSourceCode](http://code.google.com/p/modwsgi/wiki/ReloadingSourceCode).
    Using the code included on that page, an Apache with `mod_wsgi` configuration
    can be almost as convenient for development as the Django development server.
  prefs: []
  type: TYPE_NORMAL
- en: One remaining convenience of the development server that has not yet been covered
    is the ability to easily put breakpoints in code and drop into the Python debugger.
    Even this is possible when running under Apache, but for this Apache does need
    to be started in a special mode from a console session, so that it has a console
    to allow the debugger to interact with the user. Details of doing this can be
    found at [http://code.google.com/p/modwsgi/wiki/DebuggingTechniques](http://code.google.com/p/modwsgi/wiki/DebuggingTechniques).
  prefs: []
  type: TYPE_NORMAL
- en: In summary, it is quite possible to get nearly all the convenience of the Django
    development server from an Apache/`mod_wsgi` setup. Using such a configuration
    during development can help to ease the eventual transition to production, and
    can be well worth the additional early effort of installing and configuring Apache
    with `mod_wsgi` on a development machine.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have now reached the end of discussing the move to production for a Django
    application. In this chapter, we:'
  prefs: []
  type: TYPE_NORMAL
- en: Developed a configuration to support running the `marketr` project under Apache
    with `mod_wsgi`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encountered a number of problems getting the project running under Apache. For
    each, we saw how to diagnose and fix the issue.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Considered what additional testing could be done in the new environment, given
    its ability to run multiple threads concurrently.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developed a test for the code that records posted survey responses, and observed
    that the code did not operate correctly under heavy load in the production environment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed the problem found in the results recording code, and discussed other techniques
    that may be needed to fix more complex multithreading problems.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discussed the possibility of using Apache and `mod_wsgi` during development.
    This configuration can be made nearly as convenient for development as the Django
    development server, and use of the production setup during development can help
    reduce the number of problems encountered during the eventual move to production.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
