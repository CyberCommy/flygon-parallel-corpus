- en: Preface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Programming languages sometimes fit neatly into tidy categories like imperative
    and functional. Imperative languages might further subdivide into those that are
    procedural and those that include features for object-oriented programming. The
    Python language, however, contains aspects of all of these three language categories.
    Though Python is not a purely functional programming language, we can do a great
    deal of functional programming in Python.
  prefs: []
  type: TYPE_NORMAL
- en: Most importantly, we can leverage many design patterns and techniques from other
    functional languages and apply them to Python programming. These borrowed concepts
    can lead us to create succinct and elegant programs. Python's generator expressions,
    in particular, avoid the need to create large in-memory data structures, leading
    to programs which may execute more quickly because they use fewer resources.
  prefs: []
  type: TYPE_NORMAL
- en: We can't easily create purely functional programs in Python. Python lacks a
    number of features that would be required for this. For example, we don't have
    unlimited recursion, lazy evaluation of all expressions, and an optimizing compiler.
  prefs: []
  type: TYPE_NORMAL
- en: Generally, Python emphasizes strict evaluation rules. This means that statements
    are executed in order and expressions are evaluated from left to right. While
    this deviates from functional purity, it allows us to perform manual optimizations
    when writing in Python. We'll take a hybrid approach to functional programming
    using Python's functional features when they can add clarity or simplify the code
    and use ordinary imperative features for optimization.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several key features of functional programming languages that are
    available in Python. One of the most important is the idea that functions are
    first-class objects. In some languages, functions exist only as a source code
    construct: they don''t exist as proper data structures at runtime. In Python,
    functions can use functions as arguments and return functions as results.'
  prefs: []
  type: TYPE_NORMAL
- en: Python offers a number of higher-order functions. Functions like `map()`, `filter()`,
    and `functools.reduce()` are widely used in this role. Less obvious functions
    like `sorted()`, `min()`, and `max()` are also higher-order functions; they have
    a default function and, consequently, different syntax from the more common examples.
  prefs: []
  type: TYPE_NORMAL
- en: Functional programs often exploit immutable data structures. The emphasis on
    stateless objects permits flexible optimization. Python offers tuples and namedtuples
    as complex but immutable objects. We can leverage these structures to adapt some
    design practices from other functional programming languages.
  prefs: []
  type: TYPE_NORMAL
- en: Many functional languages emphasize recursion but exploit Tail-Call Optimization
    (TCO). Python tends to limit recursion to a relatively small number of stack frames.
    In many cases, we can think of a recursion as a generator function. We can then
    simply rewrite it to use a `yield from` statement, doing the tail-call optimization
    ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: We'll look at the core features of functional programming from a Python point
    of view. Our objective is to borrow good ideas from functional programming languages,
    and use these ideas to create expressive and succinct applications in Python.
  prefs: []
  type: TYPE_NORMAL
- en: What this book covers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Chapter 1](ch01.html "Chapter 1. Introducing Functional Programming"), *Introducing
    Functional Programming*, introduces some of the techniques that characterize functional
    programming. We''ll identify some of the ways to map these features to Python,
    and finally, we''ll also address some ways that the benefits of functional programming
    accrue when we use these design patterns to build Python applications.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 2](ch02.html "Chapter 2. Introducing Some Functional Features"), *Introducing
    Some Functional Features*, will delve into six central features of the functional
    programming paradigm. We''ll look at each in some detail to see how they''re implemented
    in Python. We''ll also point out some features of functional languages that don''t
    apply well to Python. In particular, many functional languages have complex type-matching
    rules required to support compilation and optimization.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 3](ch03.html "Chapter 3. Functions, Iterators, and Generators"), *Functions,
    Iterators, and Generators*, will show how to leverage immutable Python objects
    and generator expressions, and adapt functional programming concepts to the Python
    language. We''ll look at some of the built-in Python collection and how we can
    leverage them without departing too far from functional programming concepts.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 4](ch04.html "Chapter 4. Working with Collections"), *Working with
    Collections*, shows how we can use a number of built-in Python functions to operate
    on collections of data. This section will focus on a number of relatively simple
    functions such as `any()` and `all()`, which will reduce a collection of values
    to a single result.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 5](ch05.html "Chapter 5. Higher-order Functions"), *Higher-order Functions*,
    examines the commonly used higher order functions such as `map()` and `filter()`.
    The chapter also includes a number of other functions that are also higher-order
    functions, as well as how we can create our own higher-order functions.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 6](ch06.html "Chapter 6. Recursions and Reductions"), *Recursions
    and Reductions*, shows how we can design an algorithm using recursion and then
    optimize it into a high performance `for` loop. We''ll also look at some other
    reductions that are widely used, including the `collections.Counter()` function.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 7](ch07.html "Chapter 7. Additional Tuple Techniques"), *Additional
    Tuple Techniques*, shows a number of ways in which we can use immutable tuples
    and namedtuples instead of stateful objects. Immutable objects have a much simpler
    interface: we never have to worry about abusing an attribute and setting an object
    into some inconsistent or invalid state.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 8](ch08.html "Chapter 8. The Itertools Module"), *The Itertools Module*,
    examines a number of functions in the standard library module. This collection
    of functions simplifies writing programs that deal with collections or generator
    functions.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 9](ch09.html "Chapter 9. More Itertools Techniques"), *More Itertools
    Techniques*, covers the combinatoric functions in the itertools module. These
    functions are somewhat less useful. This chapter includes some examples that illustrate
    ill-considered uses of these functions and the consequences of combinatoric explosion.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 10](ch10.html "Chapter 10. The Functools Module"), *The Functools
    Module*, will show how to use some of the functions in this module for functional
    programming. A few of the functions in this module are more appropriate for building
    decorators, and are left for the next chapter. The other functions, however, provide
    several more ways to design and implement function programs.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 11](ch11.html "Chapter 11. Decorator Design Techniques"), *Decorator
    Design Techniques*, shows how we can look at a decorator as a way to build a composite
    function. While there is considerable flexibility here, there are also some conceptual
    limitations: we''ll look at ways in which overly complex decorators can become
    confusing rather than helpful.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 12](ch12.html "Chapter 12. The Multiprocessing and Threading Modules"),
    *The Multiprocessing and Threading Modules*, points out an important consequence
    of good functional design: we can distribute the processing workload. Using immutable
    objects means that we can''t corrupt an object because of poorly synchronized
    write operations.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 13](ch13.html "Chapter 13. Conditional Expressions and the Operator
    Module"), *Conditional Expressions and the Operator Module*, will show some ways
    in which we can break out of Python''s strict order of evaluation. There are limitations
    to what we can achieve here. We''ll also look at the operator module and how the
    operator module can lead to some slight clarification of some simple kinds of
    processing.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 14](ch14.html "Chapter 14. The PyMonad Library"), *The PyMonad Library*,
    examines some of the features of the PyMonad library. This provides some additional
    functional programming features. This also provides a way to learn more about
    monads. In some functional languages, monads are an important way to force a particular
    order for operations that might get optimized into an undesirable order. Since
    Python already has strict ordering of expressions and statements, the monad feature
    is more instructive than practical.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 15](ch15.html "Chapter 15. A Functional Approach to Web Services"),
    *A Functional Approach to Web Services*, shows how we can think of web services
    as a nested collection of functions that transform a request into a reply. We''ll
    see ways in which we can leverage functional programming concepts for building
    responsive, dynamic web content.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 16](ch16.html "Chapter 16. Optimizations and Improvements"), *Optimizations
    and Improvements*, includes some additional tips on performance and optimization.
    We''ll emphasize techniques like memoization because they''re easy to implement
    and can—in the right context—yield dramatic performance improvements.'
  prefs: []
  type: TYPE_NORMAL
- en: What you need for this book
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This book presumes some familiarity with Python 3 and general concepts of application
    development. We won't look deeply at subtle or complex features of Python; we'll
    avoid much consideration of the internals of the language.
  prefs: []
  type: TYPE_NORMAL
- en: We'll presume some familiarity with functional programming. Since Python is
    not a functional programming language, we can't dig deeply into functional concepts.
    We'll pick and choose the aspects of functional programming that fit well with
    Python and leverage just those that seem useful.
  prefs: []
  type: TYPE_NORMAL
- en: Some of the examples use Exploratory Data Analysis (EDA) as a problem domain
    to show the value of functional programming. Some familiarity with basic probability
    and statistics will help with this. There are only a few examples that move into
    more serious data science.
  prefs: []
  type: TYPE_NORMAL
- en: You'll need to have Python 3.3 or 3.4 installed and running. For more information
    on Python, visit [http://www.python.org/](http://www.python.org/).
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 14](ch14.html "Chapter 14. The PyMonad Library"), *The PyMonad Library*,
    we'll look at installing this additional library. If you have Python 3.4 ,which
    includes pip and Easy Install, this will be very easy. If you have Python 3.3,
    you might have already installed pip or Easy Install or both. Once you have an
    installer, you can add PyMonad. Visit [https://pypi.python.org/pypi/PyMonad/](https://pypi.python.org/pypi/PyMonad/)
    for more details.
  prefs: []
  type: TYPE_NORMAL
- en: Who this book is for
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This book is for programmers who want to create succinct, expressive Python
    programs by borrowing techniques and design patterns from functional programming
    languages. Some algorithms can be expressed elegantly in a functional style; we
    can—and should—adapt this to make Python programs more readable and maintainable.
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, a functional approach to a problem will also lead to extremely
    high performance algorithms. Python makes it too easy to create large intermediate
    data structures, tying up memory and processor time. With functional programming
    design patterns, we can often replace large lists with generator expressions that
    are equally expressive, but take up much less memory and run much more quickly.
  prefs: []
  type: TYPE_NORMAL
- en: Conventions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this book, you will find a number of styles of text that distinguish between
    different kinds of information. Here are some examples of these styles, and an
    explanation of their meaning.
  prefs: []
  type: TYPE_NORMAL
- en: 'Code words in text are shown as follows: "We can create a `Pool` object of
    concurrent worker processes, assign tasks to them, and expect the tasks to be
    executed concurrently."'
  prefs: []
  type: TYPE_NORMAL
- en: 'A block of code is set as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Any command-line input or output is written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Warnings or important notes appear in a box like this.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Tips and tricks appear like this.
  prefs: []
  type: TYPE_NORMAL
