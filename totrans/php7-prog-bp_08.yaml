- en: Chapter 8.  Building a Parser and Interpreter for a Custom Language
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Extensibility and adaptability are often the required features in enterprise
    applications. Often, it is useful and practical-or even an actual feature requirement
    by users-to change an application's behavior and business rules at runtime. Imagine,
    for example, an e-commerce application in which sales representatives can configure
    business rules themselves; for example, when the system should offer free shipping
    for a purchase or should apply a certain discount when some special conditions
    are met (offer free shipping when the purchase amount exceeds 150 Euros , and
    the customer has already made two or more purchases in the past or has been a
    customer for more than a year).
  prefs: []
  type: TYPE_NORMAL
- en: By experience, rules such as these tend to get ridiculously complex (offer a
    discount when the customer is male and is older than 35 years and has two kids
    and a cat named Mr. Whiskers and placed the purchase order on a cloudless full-moon
    night) and may change frequently. For this reason, as a developer, you might actually
    be glad to offer your user a possibility to configure rules such as these for
    themselves, instead of having to update, test, and redeploy the application every
    time one of these rules changes. A feature like this is called **end-user development**
    and is often implemented using  **domain-specific languages**.
  prefs: []
  type: TYPE_NORMAL
- en: Domain-specific languages are languages that are tailored for one specific application
    domain (in contrast to general-purpose languages, such as C, Java or-you guessed
    it-PHP). In this chapter, we will build our own parser for a small expression
    language that can be used to configure business rules in enterprise applications.
  prefs: []
  type: TYPE_NORMAL
- en: For this, we'll need to recapitulate how a parser works and how formal languages
    are described using formal grammars.
  prefs: []
  type: TYPE_NORMAL
- en: How interpreters and compilers work
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Interpreters and compilers read programs that are formulated in a programming
    language. They either execute them directly (interpreters) or first convert them
    into a machine language or another programming language (compilers). Both interpreters
    and compilers usually have (among others) two components called **lexer** and
    **parser**.
  prefs: []
  type: TYPE_NORMAL
- en: '![How interpreters and compilers work](graphics/image_08_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is a basic architecture of a compiler or interpreter
  prefs: []
  type: TYPE_NORMAL
- en: An interpreter may omit the code generation and run the parsed program directly
    without a dedicated compilation step.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **lexer** (also called **scanner** or **tokenizer**) dissects an input
    program into its smallest possible parts, the so-called tokens. Each token consists
    of a token class (for example, numerical value or variable identifier) and the
    actual token contents. For example, a lexer for a calculator given the input string
    `2 + (3 * a)` might generate the following list of tokens (each having a token
    class and value):'
  prefs: []
  type: TYPE_NORMAL
- en: Number ("`2`")
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Addition operator ("`+`")
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Opening bracket ("`(`")
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Number ("`3`")
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Multiplication operator ("`*`")
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Variable identifier ("`a`")
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Closing bracket ("`)`")
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the next step, the **parser** takes the token streams and tries to derive
    the actual program structure from this stream. For this, the parser needs to be
    programmed with a set of rules that describe the input language, a grammar. In
    many cases, a parser generates a data structure that represents the input program
    in a structured tree; the so-called syntax tree. For example, the input string
    `2 + (3 * a)` generates the following syntax tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How interpreters and compilers work](graphics/image_08_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: An Abstract Syntax Tree (AST) that can be generated from the expression 2 +
    (3 * a)
  prefs: []
  type: TYPE_NORMAL
- en: Note that there are programs that will pass the lexical analysis, but in the
    following step, they are recognized as syntactically wrong by the parser. For
    example, the input string called `2 + ( 1` would pass the lexer (and generate
    a token list such as `{Number(2), Addition Operator, Opening bracket, Number(1)}`),
    but it is obviously syntactically wrong as the opening bracket does not make any
    sense without a matching closing bracket (assuming that the parser uses the grammar
    universally recognized for mathematical expressions; in other grammars, `2+(1`
    might actually be a syntactically valid expression)
  prefs: []
  type: TYPE_NORMAL
- en: Languages and grammars
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order for a parser to be able to understand a program, it needs a formal
    description of that language-a grammar. In this chapter, we will work with a so-called
    **parsing expression grammar** (**PEG**). A PEG is (relatively) easy to define
    and there are libraries that can generate a parser for a given grammar automatically.
  prefs: []
  type: TYPE_NORMAL
- en: A grammar consists of **terminal symbols** and **non-terminal symbols**. A non-terminal
    symbol is a symbol that maybe composed of several other symbols, following certain
    rules (**production rules**). For example, a grammar could contain a *number*
    as non-terminal symbol. Each number could be defined as an arbitrary-length sequence
    of digits. As a digit could then be any of the characters from 0 to 9 (with each
    of the actual digits being a terminal symbol).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try to describe the structure of numbers (and then building on this
    mathematical expressions in general) formally. Let''s start by describing how
    a number looks like. Each number consists of one or more digits, so let''s start
    by describing digits and numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In this example, Digit is our first non-terminal symbol. The first rule of our
    grammar states that any of the characters 0 to 9 is a digit. In this example,
    the characters '0' to '9' are terminal symbols, the smallest possible building
    blocks.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In practice, many Parser generators will allow you to use regular expressions
    to match terminal symbols. In the previous example, instead of enumerating all
    possible digits, you could then simply state this: `Digit: /[0-9]/`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The second rule of our grammar states that a `Number` (our second non-terminal
    symbol) consists of one or more `Digit` symbols (the `+` means repeat once or
    more). Using the same way, we could also expand the grammar to also support decimal
    numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we''ve introduced two new non-terminal symbols: `Integer` and `Decimal`.
    `Integer` is simply a sequence of digits, while a `Decimal` may start with any
    number of digits (or none at all, which means that a value such as `.12` would
    also be a valid number), then a dot and then one or more digits. In contrast to
    the `+` operator ("repeat once or more") already used above, the `*` operator
    means "none or once or more". The production rule for `Number` now states that
    a number can either be a decimal number or an integer.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Order is important here; given an input string of `3.14`, the integer rule would
    match the `3` of this input string, while the Decimal rule would match the entire
    string. So, in this case it's safer to first try to parse the number as a decimal,
    and when that fails, parse the number as an integer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Right now, this grammar describes only positive numbers. However, it can easily
    be modified to also support negative numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `?` character used in this example states that a symbol is optional. This
    means that both an integer and a decimal number can now optionally start with
    a `-` character.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now continue to define more rules for our grammar. For example, we could
    add a new rule that describes a multiplication:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'As a division is basically the same operation as a multiplication (and has
    the same operator precedence), we can treat both cases with the same rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'As soon as you add a rule for sums to your grammar, it''s important to consider
    the order of operations (multiplication first, then addition). Let''s define a
    new rule called `Sum` (again, covering both addition and subtraction with one
    rule):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This may seem counter intuitive, at first. After all, a sum does not really
    need to consist of two products. However, as our `Product` rule uses `*` as a
    quantifier, it will also match single numbers, allowing expressions such as `5
    + 4` to be parsed as `Product + Product`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our grammar to become complete, we still need the ability to parse nested
    statements. As it is, our grammar is able to parse statements such as `2 * 3`,
    `2 + 3`. Even `2 + 3 * 4` will be parsed correctly as `2 + (3 * 4)` (and not `(2
    + 3) * 4`). However, a statement such as `(2 + 3) * 4` does not match any rule
    of our grammar. After all, the `Product` rule states that a product is any number
    of `Number`s joined by `*` characters; since a bracket-enclosed sum does not match
    the `Number` rule, the `Product` rule will not match either. To solve this problem,
    we''ll introduce two new rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'With the new `Value` rule, we can adjust the `Product` rule to match either
    regular numbers or bracket-enclosed exceptions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, you will find a complete grammar necessary for describing mathematical
    expressions. It does not support any kind of variables or logical statements yet,
    but it will be a reasonable starting point for our own parser that we''ll build
    in the remainder of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Your first PEG parser
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building a tokenizer and parser from scratch is a very tedious task. Luckily,
    many libraries exist that you can use to generate a parser automatically from
    some kind of formal grammar definition.
  prefs: []
  type: TYPE_NORMAL
- en: 'In PHP, you can use the `hafriedlander/php-peg` library to generate the PHP
    code for a parser for any kind of formal language that can be described by a parsing
    expression grammar. For this, create a new project directory and create a new
    `composer.json` file with the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `hafriedlander/php-peg` library does not use a PSR-0 or PSR-4
    autoloader, but it ships its own class loader instead. Because of this, you cannot
    use composer's built-in PSR-0/4 class loader and need to manually include the
    package's autoloader.
  prefs: []
  type: TYPE_NORMAL
- en: Similar to the previous chapters, we'll be using `Packt\Chp8\DSL` as a base
    namespace for our PSR-4 class loader based in the `src/` directory. This means
    that a PHP class called `Packt\Chp8\DSL\Foo\Bar` should be located in the `src/Foo/Bar.php`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: When working with PHP PEG, you write a parser as a regular PHP class that contains
    the grammar in a special kind of comment. This class is used as an input file
    for the actual parser generator, which then generates the actual parser source
    code. The file type for the parser input file is typically `.peg.inc`. The parser
    class has to extend the `hafriedlander\Peg\Parser\Basic` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our parser will have the `Packt\Chp8\DSL\Parser\Parser` class name. It will
    be stored in the `src/Parser/Parser.peg.inc` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note the comment within the class that starts with the `/*!*` characters. This
    special comment block will be picked up by the parser generator and needs to contain
    the grammar from which the parser will be generated.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can then build the actual parser (which will be stored in the file `src/Parser/Parser.php`,
    where it will be able to be picked up by the composer class loader) using the
    PHP-PEG CLI script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `-d pcre.jit=0` flag is required to fix a PHP 7-related bug in the PEG package.
    Disabling the `pcre.jit` flag may have an impact on the program's performance;
    however this flag must only be disabled when the parser is generated. The generated
    parser will not be affected by the `pcre.jit` flag.
  prefs: []
  type: TYPE_NORMAL
- en: 'Currently, the parser generation will fail with an error, because the parser
    class does not yet contain a valid grammar. This can easily be changed; add the
    following lines to the special comment (starting with `/*!*`) in your parser input
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: You will note that this is exactly the example grammar for matching numbers
    that we've used in the previous section. This means that after rebuilding the
    parser, you will have a parser that knows how numbers look like and can recognize
    them. Admittedly, this is not enough. But we can build on it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rebuild your parser by running the `cli.php` script as shown previously and
    continue by creating a test script called `test.php` in your project directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Remember, the `Packt\Chp8\DSL\Parser\Parser` class was automatically generated
    from your `Parser.peg.inc` input file. The class inherits the `hafriedlander\Peg\Parser\Basic`
    class, which also provides the constructor. The constructor accepts an expression
    that the parser should parse.
  prefs: []
  type: TYPE_NORMAL
- en: For each non-terminal symbol that is defined in your grammar, the parser will
    contain a function named `match_[symbol name]()` (so, for example, `match_Number`)
    that will match the input string against the given rule.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example, `$result1` is the matching result against a valid number (or,
    in general, an input string that''s matched by the parser''s grammar), while the
    input string of `$result2` is obviously not a number and should not be matched
    by the grammar. Let''s have a look at the output of this test script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, parsing the first input string returns an array that contains
    both the matching rule and the string that was matched by the rule. If the rule
    did not match (as for example in `$result2`), the `match_*` functions will always
    return `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s continue by adding the remainder of the rules that we''ve already seen
    in the previous section. These will allow our parser to not only parse numbers
    but entire mathematical expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Pay special attention to the `> `characters in this code example. Those are
    a special symbol provided by the parser generator that matches whitespace sequences
    of any length. In some grammars, whitespaces might matter, but when parsing mathematical
    expressions, you typically do not care if someone enters `2+3` or `2 + 3`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rebuild your parser and adjust your test script to test these new rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Pay special attention to the last line. Obviously, the `(1 + 2)) * 3` expression
    is syntactically wrong, because it contains more closing brackets than opening
    brackets. However, the output of the `match_Expr` function for this input statement
    will be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the input string still matched the `Expr` rule, just not the
    entire string. The first part of the string, `(1 + 2)`, is syntactically correct
    and mated by the `Expr` rule. This is very important to keep in mind when working
    with the PEG parser. If a rule does not match the entire input string, the parser
    will still match as much of the input as it can. It's up to you, as a user of
    this parser, to determine if a partial match is a good thing or not (in our case,
    this should probably trigger an error, as a partially matched expression would
    result in very strange results and undoubtedly be very surprising for a user).
  prefs: []
  type: TYPE_NORMAL
- en: Evaluating expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up until now, we've only used our custom-built PEG parser to check if an input
    string conforms to a given grammar (meaning, we can *tell* if an input string
    contains a valid mathematical expression or not). The next logical step is to
    actually evaluate these expressions (for example, determining that `'(1 + 2) *
    3'` evaluates to `'9'`).
  prefs: []
  type: TYPE_NORMAL
- en: 'As you have already seen, each `match_*` function returns an array with additional
    information on the matched string. Within the parser, you can register custom
    functions that will be called when a given symbol is matched. Let''s start with
    something simple and try to convert numbers that are matched by our grammar to
    actual PHP integer or float values. For this, start by modifying the `Integer`
    and `Decimal` rules in your grammar as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s have a look at what''s happening here. In each rule, you can specify
    names for subpatterns within the rule. For example, the pattern `Digit+` in the
    `Integer` rule gets the name called `value` assigned. As soon as the parser finds
    a string matching this pattern, it will call the function with the same name supplied
    below the `Integer` rule. The function will be called with two parameters: the
    `&$result` parameter will be the array returned by the actual `match_Number` function
    later. As you can see, the parameter is passed as reference and you can modify
    it within the value function. The `$sub` parameter contains the result array of
    the subpattern (which, in any case, contains a property `text` from which you
    can access the actual text contents of the matched subpattern).'
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we simply use PHP's built-in functions to convert the number within
    the text to an actual `int` or `float` variable. However, this is only possible
    because our custom grammar and PHP coincidentally represent numbers the same way,
    allowing us to use the PHP interpreter to convert these values to actual numeric
    values.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are using a non-terminal symbol in one of your rules, it is not necessary
    to explicitly specify a subpattern name; you can simply use the symbol name as
    a function name. This can be done in the `Number` rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Again, the `$sub` parameter contains the result array from matching the subpattern.
    In this case, this means the result array returned by the `match_Decimal` and
    `match_Integer` functions that you've modified yourself previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'This will get a little more complex with the `Product` and `Sum` rules. Start
    by adding labels to the individual parts of your `Product` rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Continue by adding the respective rule functions to the rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Sum` rule can be modified respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, you still need to modify the `Value` and `Expr` rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Using these new functions in your parser, it will now be able to evaluated
    parsed expressions on the fly (note that we''re not following the *traditional*
    compiler architecture here, as parsing and execution are not treated as separate
    steps, but rather both be done in the same pass). Re-build your parser class using
    the `cli.php` script and adjust your test script to test some expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Running your test script will provide the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Building an Abstract Syntax Tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Currently, our parser interprets the input code and evaluates it in the same
    pass. Most compilers and interpreters; however, create an intermediate data structure
    before actually running the program: an **Abstract Syntax Tree** (**AST**). Using
    an AST offers some interesting possibilities; for example, it provides you with
    a structured representation of your program that you can then analyze. Also, you
    can use the AST and transform it back into a text-based program (maybe of another
    language).'
  prefs: []
  type: TYPE_NORMAL
- en: 'An AST is a tree that represents the structure of a program. The first step
    to building an AST-based parser is to design the tree''s object model: which classes
    are needed and in which way are they associated to another. The following figure
    shows the first draft for an object model that can be used to describe mathematical
    expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building an Abstract Syntax Tree](graphics/image_08_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The (preliminary) object model for our Abstract Syntax Tree
  prefs: []
  type: TYPE_NORMAL
- en: 'In this model, nearly all classes implement the `Expression` interface. This
    interface prescribes the `evaluate()` method, which can be provided by the implementations
    of this interface to actually execute the operation modeled by the respective
    tree node. Let''s start by implementing the `Packt\Chp8\DSL\AST\Expression` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is the `Number` class with its two subclasses: `Integer` and
    `Decimal`. As we''re going to be using PHP 7''s type hinting feature, and both
    the `Integer` and `Decimal` classes work exclusively with either the `int` or
    `float` variables; we cannot make much use of inheritance, forcing us to leave
    the `Number` class empty:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Integer` class can be initialized with a PHP integer value. As this class
    models a literal integer value; the only thing that the `evaluate()` method needs
    to do in this class is to return this value again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Decimal` class can be implemented the same way; in this case, simply use
    `float` instead of `int` as type hints:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'For the classes `Addition`, `Subtraction`, `Multiplication` and `Division`,
    we''ll be using a common base class, `Packt\Chp8\DSL\AST\BinaryOperation`. This
    class will hold the constructor that you then won''t have to implement over and
    over again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Implementing the actual classes modeling the operations becomes easy. Let''s
    consider the `Addition` class as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The remaining classes called `Subtraction`, `Multiplication` and `Division`
    can be implemented in a way similar to the `Addition` class. For the sake of brevity,
    the actual implementation of these classes is left as an exercise for you.
  prefs: []
  type: TYPE_NORMAL
- en: What's left now is to actually build the AST in the parser. This is relatively
    easy, as we can now simply modify the already existing hook functions that are
    called by the parser when individual rules are matched.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the rules for parsing numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: When the `Integer` or `Decimal` rule matches, we create a new AST node of the
    `Integer` or `Decimal` class and save it in the return array's node property.
    When the `Number` rule matches, we simply take over the already created node stored
    in the matched symbol.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can adjust the `Product` rule in a similar way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'As our AST model treats operations such as multiplications strictly as binary
    operations, the parser will deconstruct input expressions such as `1 * 2 * 3 *
    4` into a chain of binary multiplications (similar to `1 * (2 * (3 * 4))` as shown
    in the following figure):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building an Abstract Syntax Tree](graphics/image_08_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The expression 1 * 2 * 3 * 4 as a syntax tree
  prefs: []
  type: TYPE_NORMAL
- en: 'Continue by adjusting your `Sum` rule in the same way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, all that''s left is to read the created AST node in the `Value` and `Expr`
    rules is follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'In your test script, you can now test if the AST is correctly built by extracting
    the `node` property from the `match_Expr()` function''s return value. You can
    then get the expression''s result by calling the `evaluate()` method on the AST''s
    root node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Note that the two expressions in this test script should yield two different
    syntax trees (both shown in the following figure) and evaluate to 7 and 9, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: '![Building an Abstract Syntax Tree](graphics/image_08_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The two syntax trees resulting from parsing the 1+2*' and (1+2)*' expressions
  prefs: []
  type: TYPE_NORMAL
- en: Building a better interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Right now, the parser that we have built is not really easy to use. In order
    to use the parser correctly, a user (in this context, read "user" as "another
    developer that uses your parser") has to call the `match_Expr()` method (which
    is just one of many public `match_*` functions offered by the parser that are
    not actually supposed to be called by external users), extract the `node` property
    from the returned array, and then call the evaluate function on the root node
    contained in this property. Also, the parser also matches partial strings (remember
    the example `(1 + 2)) * 3`, which was recognized as partially correct by our parser),
    which might really surprise some users.
  prefs: []
  type: TYPE_NORMAL
- en: 'This reason is enough to extend our project by a new class that encapsulates
    these quirks and to offer a cleaner interface to our parser. Let''s create a new
    class, `Packt\Chp8\DSL\ExpressionBuilder`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we''re checking if the entire string could be parsed by asserting
    that the matched string returned by the parser is actually equal to the input
    string (and not just a substring). If this is the case (or if the expression could
    not be parsed at all, and the result is just false), an instance of `Packt\Chp8\DSL\Exception\ParsingException`
    is thrown. This exception class is not yet defined; for now, it can simply inherit
    the base exception class and does not need to contain any custom logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The new `ExpressionBuilder` class now offers you a more concise way to parse
    and evaluate expressions. For example, you can now use the following construct
    in your `test.php` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Evaluating variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, our parser can evaluate static expressions, starting with simple ones
    such as `3` (which evaluates, what a surprise, to 3) up to arbitrarily complicated
    ones such as `(5 + 3.14) * (14 + (29 - 2 * 3.918))` (which, by the way, evaluates
    to 286.23496). However, all of these expressions are static; they will always
    evaluate to the same result.
  prefs: []
  type: TYPE_NORMAL
- en: In order to make this more dynamic, we will now extend our grammar to allow
    variables. An example of an expression with variables is `3 + a`, which could
    then be evaluated multiple times with different values for `a`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This time, let''s start by modifying the object model for the syntax tree.
    First, we''ll need a new node type, `Packt\Chp8\DSL\AST\Variable`, allowing for
    example the `3 + a` expression to generate the following syntax tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Evaluating variables](graphics/image_08_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The syntax tree generated from the expression 3 + a
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s also a second problem: contrary to the `Number` nodes or arithmetic
    operations that use **Number** nodes, we cannot simply compute the numeric value
    of a **Variable** node (after all, it could have any value - that''s the point
    of a variable). So when evaluating an expression, we''ll also need to pass information
    on which variables exists and what values they have. For this, we''ll simply extend
    the `evaluate()` function defined in the `Packt\Chp8\DSL\AST\Expression` interface
    by an additional parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Changing the interface definition necessitates changing all classes that implement
    this interface. In the `Number` subclasses (`Integer` and `Decimal`), you can
    add the new parameter and simply ignore it. The value of a static number does
    not depend on the values of any variables at all. The following code example shows
    this change in the `Packt\Chp8\DSL\AST\Integer` class, but it remembers to change
    the `Decimal` class in the same way as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `BinaryOperation` subclasses (`Addition`, `Subtraction`, `Multiplication`,
    and `Division`), the values of defined variables also do not really matter. But
    we need to pass them to the subnodes of these nodes. The following example shows
    this change in the `Packt\Chp8\DSL\AST\Addition` class, but it remembers to also
    change the `Subtraction`, `Multiplication`, and `Division` classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can now declare our `Packt\Chp8\DSL\AST\Variable` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Within this class'' `evaluate()` method, you can look up the actual value that
    this variable currently has. If a variable is not defined (read: does not exist
    in the `$variables` argument), we''ll raise an instance of the (not-yet-implemented)
    `Packt\Chp8\DSL\Exception\UndefinedVariableException` to let the user know something''s
    wrong.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: How you handle undefined variables in your custom language is completely up
    to you. Instead of triggering errors, you could also change the `Variable` class'
    `evaluate()` method to return a default value such as 0 (or anything else) when
    an undefined variable is evaluated. However, using an undefined variable is probably
    unintentional, and simply continuing with a default value would probably be very
    surprising for your users.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `UndefinedVariableException` class can simply extend the regular `Exception`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to adjust the parser''s grammar to actually recognize variables
    in expressions. For this, our grammar needs two additional symbols:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, you''ll need to extend the `Value` rule. Currently, `Value` can be either
    a `Number` symbol, or an `Expr` wrapped in braces. Now, you need to also allow
    variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Rebuild your parser using PHP-PEG''s `cli.php` script, and add a few calls
    to your `test.php` script to test this new feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: These should evaluate to 3, 29, and -1 respectively. You can also try evaluating
    the expression without passing any variables, which should (rightfully so) result
    in an `UndefinedVariableException` being thrown.
  prefs: []
  type: TYPE_NORMAL
- en: Adding logical expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Currently, our language only supports numerical expressions. Another useful
    addition would be to support Boolean expressions that do not evaluate to numeric
    values but to *true* or *false*. Possible examples would include expressions such
    as `3 = 4` (which would always evaluate to *false*), `2 < 4` (which would always
    evaluate to *true*), or `a <= 5` (which depends on the value of variable `a`).
  prefs: []
  type: TYPE_NORMAL
- en: Comparisons
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As before, let''s start by extending the object model of our syntax tree. We''ll
    start with an **Equals** node that represents an equality check between two expressions.
    Using this node, the `1 + 2 = 4 - 1` expression would produce the following syntax
    tree (and should of course eventually evaluate to *true*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Comparisons](graphics/image_08_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The syntax tree that should result from parsing the 1 + 2 = 4 - 1 expression
  prefs: []
  type: TYPE_NORMAL
- en: 'For this, we will implement the `Packt\Chp8\DSL\AST\Equals` class. This class
    can inherit the `BinaryOperation` class that we implemented earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'While we''re at it, we can also implement the `NotEquals` node at the same
    time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'In the next step, we''ll need to adjust our parser''s grammar. First, we need
    to change the grammar to differentiate between numerical and Boolean expressions.
    For this, we''ll rename the `Expr` symbol to `NumExpr` in the entire grammar.
    This affects the `Value` symbol:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, you''ll also need to change the `Expr` rule itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we can define a rule for equality (and also non-equality):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Note that this rule got a bit more complicated in this case, as it supports
    multiple operators. However, these rules are now relatively easy to be extended
    by more operators (when we're checking non-equality things such as "greater than"
    or "smaller than" might be the next logical steps). The `ComparisonOperator` symbol,
    which is defined first, matches all kinds of comparison operators and the `Comparison`
    rule that uses this symbol to match the actual expressions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, we can add a new `BoolExpr` symbol, and also define the `Expr` symbol
    again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'When calling the `match_Expr()` function, our parser will now match both numeric
    and Boolean expressions. Rebuild your parser using PHP-PEG''s `cli.php` script,
    and add a few new calls to your `test.php` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: These expressions should evaluate to *false*, *true*, and *false* respectively.
    The numeric expressions that you've added before should continue to work as before.
  prefs: []
  type: TYPE_NORMAL
- en: Similar to this, you could now add additional comparison operators, such as
    `>`, `>=`, `<`, or `<=` to your grammar. Since the implementation of these operators
    would be largely identical to the `=` and `|=` operations, we'll leave it as an
    exercise for you.
  prefs: []
  type: TYPE_NORMAL
- en: The "and" and "or" operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another important feature in order to fully support logical expressions is the
    ability to combine logical expressions via the "and" and "or" operators. As we
    are developing our language with an end user in mind, we'll build our language
    to actually support `and` and `or` as logical operators (in contrast to the ubiquitous
    `&&` and `||` that you find in many general-purpose programming language that
    are derived from the C syntax).
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, let''s start by implementing the respective node types for the syntax
    tree. We will need node types modeling both the `and` and `or` operation so that
    a statement such as `a = 1` or `b = 2` will be parsed into the following syntax
    tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The "and" and "or" operators](graphics/image_08_008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The syntax tree resulting from parsing a=1 or b=2
  prefs: []
  type: TYPE_NORMAL
- en: 'Begin by implementing the `Packt\Chp8\DSL\AST\LogicalAnd` class (we cannot
    use *And* as a class name, because that''s a reserved word in PHP):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: For the `or` operator, you can also implement the `Packt\Chp8\DSL\AST\LogicalOr`
    class the same way.
  prefs: []
  type: TYPE_NORMAL
- en: When working with the `and` and `or` operators, you will need to think about
    operator precedence. While operator precedence is well defined for arithmetic
    operations, this is not the case for logical operators. For example, the statement
    `a and b or c and d` could be interpreted as `(((a and b) or c) and d)` (same
    precedence, left to right), or just as well as `(a and b) or (c and d)` (precedence
    on `and`) or `(a and (b or c)) and d` (precedence on `or`). However, most programming
    languages treat the `and` operator with the highest precedence, so barring any
    other convention it makes sense to stick with this tradition.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure shows the syntax trees that result from applying this
    precedence on the `a=1 and b=2 or b=3` and `a=1 and (b=2 or b=3)` statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The "and" and "or" operators](graphics/image_08_009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The syntax trees resulting form parsing a=1 and b=2 or b=3 and a=1 and (b=2
    or b=3)
  prefs: []
  type: TYPE_NORMAL
- en: We will need a few new rules in our grammar for this. First of all, we need
    a new symbol representing a Boolean value. For now, such a Boolean value may either
    be a comparison or any Boolean expression wrapped in brackets.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Do you remember how we implemented operator precedence previously using the
    `Product` and `Sum` rules? We can implement the `And` and `Or` rules the same
    way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'After this, we can extend the `BoolExpr` rule to also match `Or` expressions
    (and since a single `And` symbol also matches the `Or` rule, a single `And` symbol
    will also be a `BoolExpr`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now add a few new test cases to your `test.php` script. Play around
    with variables and pay special attention to how operator precedence is resolved:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Conditions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that our language supports (arbitrarily complex) logical expressions, we
    can use these to implement another important feature: conditional statements.
    Our language currently supports only expressions that evaluate to a single numeric
    or the Boolean value; we''ll now implement a variant of the ternary operator,
    which is also known in PHP:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'As our language is targeted at end users, we''ll use a more readable syntax,
    which will allow statements such as `when <condition> then <value> else <value>`.
    In our syntax tree, constructs such as these will be represented by the `Packt\Chp8\DSL\AST\Condition`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'This means that, for example, the `when a > 2 then a * 1.5 else a * 2` expression
    should be parsed into the following syntax tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Conditions](graphics/image_08_010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In theory, our language should also support complex expressions in the condition
    or the then/else part, allowing statements such as `when (a > 2 or b = 2) then
    (2 * a + 3 * b) else (3 * a - b)` or even nested statements such as `when a=2
    then (when b=2 then 1 else 2) else 3`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Conditions](graphics/image_08_011.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Continue by adding a new symbol and rule to your parser''s grammar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, adjust the `BoolExpr` rule to also match conditions. In this case, the
    order is important: if you''re putting the `Or` or `Comparison` symbol first in
    the `BoolExpr` rule, the rule might interpret when as a variable name, instead
    of a conditional expression.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, rebuild your parser using PHP-PEG''s **cli.php** script, and add a few
    test statements to your test script to test the new grammar rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: These test cases should evaluate to 3.14, 4, and 6 respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Working with structured data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, our custom expression language has only supported very simple variables-numbers
    and Boolean values. However, in real applications, this is often not so simple.
    When using an expression language to offer programmable business rules, you will
    often be working with structured data. For example, consider an e-commerce system
    in which a back-office user has the possibility to define under which conditions
    a discount should be offered to a user and what amount of a purchase should be
    discounted (the following figure shows a hypothetical example of how such a feature
    might actually look in an application).
  prefs: []
  type: TYPE_NORMAL
- en: Typically, you do not know beforehand how a user is going to use this feature.
    Using only numerical variables, you'd have to pass a whole set of variables when
    evaluating the expression, on the off chance that the user might be using one
    or two of them. Alternatively, you could pass an entire domain object (for example,
    a PHP object representing a shopping cart and maybe another one representing the
    customer), as variable into the expression and give the user the option to access
    properties or call methods of these objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'A feature such as this would allow a user to use expressions such as `cart.value`
    in an expression. When evaluating this expression, this could be translated to
    either a direct property access (if the `$cart` variable does have a publicly
    accessible `$value` property), or a call to a `getValue()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with structured data](graphics/image_08_012.jpg)'
  prefs: []
  type: TYPE_IMG
- en: An example of how structured data could be used as variables in an enterprise
    e-commerce application
  prefs: []
  type: TYPE_NORMAL
- en: 'For this, we''ll need to modify our AST object model a bit. We''ll introduce
    a new node type, `Packt\Chp8\DSL\AST\PropertyFetch`, which models a named property
    being fetched from a variable. However, we need to consider that these property
    fetches need to be chained, for example, in expressions such as `cart.customer.contact.firstname`.
    This expression should be parsed into the following syntax tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with structured data](graphics/image_08_013.jpg)'
  prefs: []
  type: TYPE_IMG
- en: For this, we'll redefine the `Variable` node type that we added before. Rename
    the `Variable` class to `NamedVariable` and add a new interface named `Variable`.
    This interface can then be implemented by both the `NamedVariable` class and the
    `PropertyFetch` class. The `PropertyFetch` class can then accept a `Variable`
    instance as its left operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by renaming the `Packt\Chp8\DSL\AST\Variable` class to `Packt\Chp8\DSL\AST\NamedVariable`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, add the new interface called `Packt\Chp8\DSL\AST\Variable`. It does not
    need to contain any code; we''ll use it just for type hinting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Continue by adding the `Packt\Chp8\DSL\AST\PropertyFetch` new class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, modify the `Variable` rule in your parser''s grammar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Using this rule, the `Variable` symbol can consist of multiple property names
    chained together with the `.` character. The rule functions will then build a
    `NamedVariable` node for the first property name, and then work this node into
    a chain of the `PropertyFetch` nodes for subsequent properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'As usual, rebuild your parser and add a few lines to your test script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Working with objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Getting end users to grasp the concept of data structures is no easy task. While
    the concept of *objects* having *properties* (for instance, a customer having
    a first name and a last name) is usually easy to convey, you probably would not
    bother end users with things like data encapsulation and object methods.
  prefs: []
  type: TYPE_NORMAL
- en: Because of this, it might be useful to hide the intricacies of data access from
    your end user; if a user want to access a customer's first name, they should be
    able to write `customer.firstname`, even if the actual property of the underlying
    object is protected, and you would usually need to call a `getFirstname()` method
    to read this property. Since getter functions typically follow certain naming
    patterns, our parser can automatically translate expressions such as `customer.firstname`
    to method calls such as `$customer->getFirstname()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement this feature, we need to extend the `evaluate` method of `PropertyFetch`
    by a few special cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Using this implementation, an expression such as `customer.firstname` will first
    check if the customer object implements a `getFirstname()`method that can be called.
    Should this not be the case, the interpreter will check for an `isFirstname()`
    method (which does not make sense in this case, but could be useful as getter
    functions, for Boolean properties are often named `isSomething` instead of `getSomething`).
    If no `isFirstname()` method exists either, the interpreter will look for an accessible
    property named `firstname`, and then as a last resort simply return null.
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing the interpreter by adding a compiler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our parser now works as it should, and you could use it in any kind of application
    to offer very flexible customization options to the end user. However, the parser
    does not work very efficiently. In general, parsing expressions are computationally
    expensive, and in most use cases, it is reasonable to assume that the actual expressions
    that you're working with do not change with every request (or at least, are evaluated
    more often than they are changed).
  prefs: []
  type: TYPE_NORMAL
- en: Because of this, we can optimize the parser's performance by adding a caching
    layer to our interpreter. Of course, we cannot cache the actual evaluation results
    of an expression; after all, these could change when they are interpreted with
    different variables.
  prefs: []
  type: TYPE_NORMAL
- en: What we're going to do in this section is add a compiler feature to our parser.
    For each parsed expression, our parser generates an AST that represents the structure
    of this expression. You can now use this syntax tree to translate the expression
    into any other programming language, for example, to PHP.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the `2 + 3 * a` expression. This expression generates the following
    syntax tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Optimizing the interpreter by adding a compiler](graphics/image_08_014.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In our AST model, this corresponds to an instance of the `Packt\Chp8\DSL\AST\Addition`
    class, holding a reference to an instance of the `Packt\Chp8\DSL\AST\Number` class
    and the `Packt\Chp8\DSL\AST\Product` class (and so forth).
  prefs: []
  type: TYPE_NORMAL
- en: 'We cannot implement a compiler feature to translate this expressions back into
    PHP code (after all, PHP does support simple arithmetic operations, too), which
    might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: The PHP code that is generated in this way could then be saved in files for
    later lookup. If the parser gets passed an expression that is already cached,
    it could simply load the saved PHP files in order to not actually parse the expression
    again.
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement this feature, we''ll need to have the possibility to convert each
    node in a syntax tree into a corresponding PHP expression. For this, let''s start
    by extending our `Packt\Chp8\DSL\AST\Expression` interface by a new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'The downside of this approach is that you''ll now need to implement this method
    for each and every single one of the classes that implement this interface. Let''s
    start with something simple: the `Packt\Chp8\DSL\AST\Number` class. As each `Number`
    implementation will always evaluate to the same number (3 will always evaluate
    to 3 and never to 4), we can simply return the numeric value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'As for the remaining node types, we''ll need methods that return an implementation
    of each expression type in PHP. For example, for the `Packt\Chp8\DSL\AST\Addition`
    class, we could add the following `compile()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Proceed similarly for the remaining arithmetic operations: `Subtraction`, `Multiplication`,
    and `Division`, and also the logical operations such as `Equals`, `NotEquals`,
    `And`, and `Or`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For the `Condition` class, you can use PHP''s ternary operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'The `NamedVariable` class is difficult to adjust; the class'' `evaluate()`
    method currently throws `UnknownVariableException` when a non-existing variable
    is referenced. However, our `compile()` method needs to return a single PHP expression.
    And looking up a value and also throwing an exception cannot be done in a single
    expression. Luckily, you can instantiate classes and call methods on them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Using this workaround, the `a * 3` expression would be compiled to the following
    PHP code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'This just leaves the `PropertyFetch` class. You might remember that this class
    was a bit more complex than the other node types, as it implemented quite a few
    different contingencies on how to look up properties from objects. In theory,
    this logic could be implemented in a single expression using ternary operators.
    This would result in the `foo.bar` expression being compiled to the following
    monstrosity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to prevent the compiled code from getting overly complicated, it''s
    easier to refactor the `PropertyFetch` class a little bit. You can extract the
    actual property lookup method in a static method that can be called from both
    the `evaluate()` method and the `compiled` code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'This way, the `foo.bar` expression will simply evaluate to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: In the next step, we can add an alternative to the previously introduced `ExpressionBuilder`
    class that transparently compiles expressions, saves them in a cache, and reuses
    the compiled versions when necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll call this class `Packt\Chp8\DSL\CompilingExpressionBuilder`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: As we don't want to re-implement the `ExpressionBuilder's` parsing logic, this
    class takes an instance of `ExpressionBuilder` as a dependency. When a new expression
    is parsed that is not yet present in the cache, this inner expression builder
    will be used to actually parse this expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s continue by adding a `parseExpression` method to this class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s have a look at what happens in this method: first, the actual input
    string is used to calculate a hash value, uniquely identifying this expression.
    If a file with this name exists in the cache directory, it will be included as
    a PHP file, and the file''s return value will return as the method''s return value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: As the method's type hint specified that the method needs to return an instance
    of the `Packt\Chp8\DSL\AST\Expression` interface, the generated cache files also
    need to return an instance of this interface.
  prefs: []
  type: TYPE_NORMAL
- en: If no compiled version of the expression could be found, the expression is parsed
    as usual by the inner expression builder. This expression is then compiled to
    a PHP expression using the `compile()` method. This PHP code snippet is then used
    to write the actual cache file. In this file, we're creating a new anonymous class
    that implements the expression interface, and in its `evaluate()` method contains
    the compiled expression.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Anonymous classes are a feature added in PHP 7\. This feature allows you to
    create objects that implement an interface or extend an existing class without
    needing to explicitly define a named class for this. Syntactically, this feature
    can be used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$a = new class implements SomeInterface {` `    public function test() {`
    `        echo ''Hello'';` `    }` `};` `$a->test();`'
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that the `foo.bar * 3` expression would create a cache file with
    the following PHP code as its contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Interestingly, the PHP interpreter itself works much the same way. Before actually
    executing PHP code, the PHP interpreter compiles the code into an intermediate
    representation or Bytecode, which is then interpreted by the actual interpreter.
    In order to not parse the PHP source code over and over again, the compiled bytecode
    is cached; this is how PHP's opcode cache works.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we''re saving our compiled expressions as PHP code, these will also be compiled
    into PHP bytecode and cached in the opcode cache for even more performance again.
    For example, the previous cached expression''s evaluate method evaluates to the
    following PHP bytecode:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Optimizing the interpreter by adding a compiler](graphics/image_08_015.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The PHP bytecode generated by the PHP interpreter
  prefs: []
  type: TYPE_NORMAL
- en: Verifying performance improvements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The motivation for implementing the compilation to PHP was to increase the parser's
    performance. As a last step, we'll now try to verify that the caching layer does
    actually increase the performance of the parser.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this, you can use the **PHPBench** package that you can install using composer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: PHPBench offers a framework for benchmarking single units of code in isolation
    (in that respect being similar to PHPUnit, only for benchmarks instead of tests).
    Each benchmark is a PHP class that contains scenarios as methods. The name of
    each scenario method needs to start with `bench`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by creating a `bench.php` file in your root directory with the following
    contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then run this benchmark using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'This should generate a report such as the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Verifying performance improvements](graphics/image_08_016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Currently, PHPBench runs the benchmark function exactly once and measures the
    time that it took to execute this function. In this case, it is about 2 milliseconds.
    This is not very precise, because micro-measurements such as these can vary quite
    a lot, depending on other things happening on your computer at the same time.
    For this reason, it''s usually better to execute the benchmark function multiple
    times (let''s say, a few hundred or thousand times) and then compute the average
    execution time. Using PHPBench, you can do this easily by adding a `@Revs(5000)`
    annotation to your benchmark class'' DOC comment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: This annotation will cause PHPBench to actually run this benchmark function
    5000 times and then compute the average runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s also add a second scenario in which we''re using the new `CompilingExpressionBuilder`
    with the same expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the benchmark again; this time benchmarking both parsers and with 5000
    iterations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Verifying performance improvements](graphics/image_08_017.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see here, parsing and evaluating the `a = 2` expression takes our
    regular parser about 349 microseconds, on average (and about 20 megabytes of RAM).
    Using the compiling parser takes only about 33 microseconds (that's a runtime
    reduction of about 90%) and only 5 MB's of RAM (or about 71%).
  prefs: []
  type: TYPE_NORMAL
- en: Now, `a=2` might not really be the most representative benchmark, because actual
    expressions used in a real-life use case might get a little more complex.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a more realistic benchmark, let''s add two more scenarios, this time with
    a more complex expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the benchmark again and have a new look at the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Verifying performance improvements](graphics/image_08_018.jpg)'
  prefs: []
  type: TYPE_IMG
- en: That's even better than before! Using the regular parser for parsing the `when
    (customer.age = 1 and cart.value = 200) then cart.value * 0.1 else cart.value
    * 0.2` expression takes about 2.5 milliseconds (remember we were talking about
    *microseconds* in the last benchmark), while only 50 microseconds are using the
    optimized parser! That's an improvement of about 98%.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use the PHP-PEG library to implement a parser,
    interpreter, and compiler for a custom expression language. You also learned how
    to define grammars for such languages and how you can use them to develop domain-specific
    languages. These can be used to offer end-user development features in large software
    systems, which allow users to customize their software's business rules to a large
    extent.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamically modifying a program using domain-specific languages can be a strong
    selling point, especially in enterprise systems. They allow users to modify a
    program's behavior by themselves, without having to wait for a developer to change
    a business rule and trigger a lengthy release process. This way, new business
    rules can be implemented quickly and allow your customers to react quickly to
    changing requirements.
  prefs: []
  type: TYPE_NORMAL
