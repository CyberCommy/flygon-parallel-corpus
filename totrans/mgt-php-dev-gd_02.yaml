- en: Chapter 2. Magento Fundamentals for Developers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will cover the fundamental concepts for working with Magento.
    We will learn how Magento is structured, and we will go over the source of Magento's
    flexibility, that is, its modular architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Magento is a flexible and powerful system. Unfortunately, this adds some level
    of complexity too. Currently, a clean installation of Magento has around 30,000
    files and over 1.2 million lines of code.
  prefs: []
  type: TYPE_NORMAL
- en: With all that power and complexity, Magento can be daunting for new developers;
    but don't worry. This chapter is designed to teach new developers all the fundamental
    concepts and tools they will need to use and extend Magento, and in the next chapter,
    we will be diving deep into Magento models and data collections.
  prefs: []
  type: TYPE_NORMAL
- en: Zend Framework – the base of Magento
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you probably know, Magento is the most powerful e-commerce platform in the
    market; what you might not know about Magento is that it is also an **object-oriented**
    (**OO**) PHP framework developed on top of Zend Framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'Zend''s official site describes the framework as:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Zend Framework 2 is an open source framework for developing web applications
    and services using PHP 5.3+. Zend Framework 2 uses 100% object-oriented code and
    utilises most of the new features of PHP 5.3, namely namespaces, late static binding,
    lambda functions and closures.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '>'
  prefs: []
  type: TYPE_NORMAL
- en: '*The component structure of Zend Framework 2 is unique; each component is designed
    with few dependencies on other components. ZF2 follows the SOLID object oriented
    design principle. This loosely coupled architecture allows developers to use whichever
    components they want. We call this a "use-at-will" design.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'But what is Zend Framework exactly? Zend Framework is an OO framework developed
    on PHP that implements the **Model-View-Controller** (**MVC**) paradigm. When
    Varien, now Magento Inc., started developing Magento it decided to do it on top
    of Zend because of the following components:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Zend_Cache`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Zend_Acl`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Zend_Locale`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Zend_DB`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Zend_Pdf`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Zend_Currency`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Zend_Date`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Zend_Soap`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Zend_Http`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In total, Magento uses around 15 different Zend components. The Varien library
    directly extends several of the Zend components mentioned previously, for example
    `Varien_Cache_Core` extends from `Zend_Cache_Core` .
  prefs: []
  type: TYPE_NORMAL
- en: 'Using Zend Framework, Magento was built with the following principles in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Maintainability**: It occurs using code pools to keep the core code separate
    from local customizations and third-party modules'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Upgradability**: Magento modularity allows extensions and third-party modules
    to be updated independently from the rest of the system'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Flexibility**: Allows seamless customization and simplifies the development
    of new features'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although having used Zend Framework or even understanding it are not the requirements
    for developing with Magento, having at least a basic understanding of the Zend
    components, usage, and interaction can be invaluable information when we start
    digging deeper into the core of Magento.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can learn more about Zend Framework at [http://framework.zend.com/](http://framework.zend.com/).
  prefs: []
  type: TYPE_NORMAL
- en: Magento folder structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Magento folder structure is slightly different from other MVC applications;
    let''s take a look at the directory tree, and each directory and its functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`app`: This folder is the core of Magento and is subdivided into three importing
    directories:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`code`: This contains all our application code divided into three code pools
    such as `core`, `community`, and `local`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`design`: This contains all the templates and layouts for our application'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`locale`: This contains all the translation and e-mail template files used
    for the store'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`js`: This contains all the JavaScript libraries that are used in Magento'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`media`: This contains all the images and media files for our products and
    CMS pages as well as the product image cache'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lib`: This contains all the third-party libraries used in Magento such as
    Zend and PEAR, as well as the custom libraries developed by Magento, which reside
    under the Varien and Mage directories'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`skin`: This contains all CSS code, images, and JavaScript files used by the
    corresponding theme'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`var`: This contains our temporary data such as cache files, index lock files,
    sessions, import/export files, and in the case of the Enterprise edition the full
    page cache folders'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Magento is a modular system. This means that the application, including the
    core, is divided into smaller modules. For this reason, the folder structure plays
    a key role in the organization of each module core; a typical Magento module folder
    structure would look something like the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Magento folder structure](graphics/3060OS_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s review each folder in more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Block`: This folder contains blocks in Magento that form an additional layer
    of logic between the controllers and views'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`controllers`: `controllers` folders are formed by actions that process web
    server requests'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Controller`: The classes in this folder are meant to be abstract classes and
    extended by the `controller` class under the the `controllers` folder'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`etc`: Here we can find the module-specific configuration in the form of XML
    files such as `config.xml` and `system.xml`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Helper`: This folder contains auxiliary classes that encapsulate a common-module
    functionality and make it available to a class of the same module and to other
    modules'' classes as well'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Model`: This folder contains models that support the controllers in the module
    for interacting with data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sql`: This folder contains the installation and upgrade files for each specific
    module'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we will see later on in this chapter, Magento makes heavy use of factory
    names and factory methods. This is why the folder structure is so important.
  prefs: []
  type: TYPE_NORMAL
- en: Modular architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rather than being a large application, Magento is built by smaller modules,
    each adding specific functionality to Magento.
  prefs: []
  type: TYPE_NORMAL
- en: One of the advantages of this approach is the ability to enable and disable
    specific module functionality with ease, as well as add new functionality by adding
    new modules.
  prefs: []
  type: TYPE_NORMAL
- en: Autoloader
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Magento is a huge framework, composed of close to 30,000 files. Requiring every
    single file when the application starts would make it incredibly slow and heavy.
    For this reason, Magento makes use of an autoloader class to find the required
    files each time a factory method is called.
  prefs: []
  type: TYPE_NORMAL
- en: So, what exactly is an autoloader? PHP5 includes a function called `__autoload()`.
    When instantiating a class, the `__autoload()` function is automatically called;
    inside this function, custom logic is defined to parse the class name and the
    required file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a closer look at the Magento bootstrap code located at `app/Mage.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The bootstrap file takes care of defining the `include` paths and initializing
    the Varien autoloader, which will in turn define its own `autoload` function as
    the default function to call. Let''s take a look under the hood and see what the
    Varien `autoload` function is doing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `autoload` class takes a single parameter called `$class`, which is an alias
    provided by the factory method. This alias is processed to generate a matching
    class name that is then included.
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned before, Magento's directory structure is important due to the
    fact that Magento derives its class names from the directory structure. This convention
    is the core principle behind factory methods that we will be reviewing later on
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Code pools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we mentioned before, inside our `app/code` folder we have our application
    code divided into three different directories known as code pools . They are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`core`: This is where the Magento core modules that provide the base functionality
    reside. The golden rule among Magento developers is that you should never, by
    any circumstance, modify any files under the `core` code pool.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`community`: This is the location where third-party modules are placed. They
    are either provided by third parties or installed through Magento Connect.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`local`: This is where all the modules and code developed specifically for
    this instance of Magento reside.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The code pools identify where the module came from and on which order they
    should be loaded. If we take another look at the `Mage.php` bootstrap file, we
    can see the order on which code pools are loaded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This means that for each class request, Magento will look in `local`, then `community`,
    then `core`, and finally inside the `lib` folder.
  prefs: []
  type: TYPE_NORMAL
- en: This also leads to an interesting behavior that can easily be used for overriding
    `core` and `community` classes, by just copying the directory structure and matching
    the class name.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Needless to say that this is a terrible practice, but it is still useful to
    know about just in case you someday have to take care of a project that exploits
    this behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Routing and request flow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before going into more detail about the different components that form a part
    of Magento, it is important that we understand how these components interact together
    and how Magento processes requests coming from the web server.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with any other PHP application, we have a single file as an entry point
    for every request; in the case of Magento this file is `index.php`, which is in
    charge of loading the `Mage.php` bootstrap class and starting the request cycle.
    It then goes through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: The web server receives the request and Magento is instantiated by calling the
    bootstrap file, `Mage.php`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The frontend controller is instantiated and initialized; during this controller
    initialization Magento searches for the web routes and instantiates them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Magento then iterates through each of the routers and calls the match. The `match`
    method is responsible for processing the URL and generating the corresponding
    controller and action.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Magento then instantiates the matching controller and takes the corresponding
    action.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Routers are especially important in this process. The `Router` objects are
    used by the frontend controller to match a requested URL (route) to a module controller
    and action. By default, Magento comes with the following routers:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Mage_Core_Controller_Varien_Router_Admin`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Mage_Core_Controller_Varien_Router_Standard`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Mage_Core_Controller_Varien_Router_Default`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The action controller will then load and render the layout, which in turn will
    load the corresponding blocks, models, and templates.
  prefs: []
  type: TYPE_NORMAL
- en: Let's analyze how Magento will handle a request to a category page; we will
    use `http://localhost/catalog/category/view/id/10` as an example. Magento URIs
    are comprised of three parts – */FrontName/ControllerName/ActionName*.
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that for our example URL, the breakdown would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**FrontName**: `catalog`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ControllerName**: `category`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ActionName**: `view`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If I take a look at the Magento router class, I can see the `Mage_Core_Controller_Varien_Router_Standard`
    match function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'From the preceding code, we can see that the first thing the router tries to
    do is to parse the URI into an array. Based on our example URL, the corresponding
    array would be something like the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The next part of the function will first try to check if the request has the
    module name specified; if not, then it tries to determine the module name based
    on the first element of our array. And if a module name can''t be provided, then
    the function will return `false`. Let''s take a look at that part of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, the match function will iterate through each of the available modules
    and try to match the controller and action, using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now that looks like an awful lot of code, so let's break it down even further.
    The first part of the loop will check if the request has a controller name; if
    it is not set, it will check our parameter array's (`$p`) second value and try
    to determine the controller name, and then it will try to do the same for the
    action name.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we got this far in the loop, we should have a module name, a controller
    name, and an action name, which Magento will now use to try and get a matching
    controller class name by calling the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This function will not only generate a matching class name but it will also
    validate its existence; in our example case this function should return `Mage_Catalog_CategoryController`.
  prefs: []
  type: TYPE_NORMAL
- en: Since we now have a valid class name, we can proceed to instantiate our controller
    object; if you were paying attention up to this point, you have probably noticed
    that we haven't done anything with our action yet, and that's precisely the next
    step in our loop.
  prefs: []
  type: TYPE_NORMAL
- en: Our new instantiated controller comes with a very handy function called `hasAction()`
    ; in essence, what this function does is to call a PHP function called `is_callable()`,
    which will check if our current controller has a public function matching the
    action name; in our case this will be `viewAction()` .
  prefs: []
  type: TYPE_NORMAL
- en: The reason behind this elaborate matching process and the use of a `foreach`
    loop is that it is possible for several modules to use the same FrontName.
  prefs: []
  type: TYPE_NORMAL
- en: '![Routing and request flow](graphics/3060OS_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now, `http://localhost/catalog/category/view/id/10` is not a very user-friendly
    URL; fortunately, Magento has its own URL rewrite system that allows us to use
    `http://localhost/books.html`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s dig a little deeper into the URL rewrite system and see how Magento
    gets the controller and action names from our URL alias. Inside our `Varien/Front.php`
    controller dispatch function, Magento will call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Before actually looking into the inner workings of the `rewrite` function,
    let''s take a look at the structure of the `core/url_rewrite` model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the rewrite module is comprised of several properties, but only
    two of them are of particular interest to use – `request_path` and `target_path`.
    Simply put, the job of the rewrite module is to modify the request object path
    information with the matching values of `target_path`.
  prefs: []
  type: TYPE_NORMAL
- en: Magento version of MVC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are familiar with the traditional MVC implementations such as CakePHP
    or Symfony, you may know that the most common implementation is called a convention-based
    MVC. With a convention-based MVC, to add a new model or let's say a controller,
    you only need to create the file/class (following the framework conventions) and
    the system will pick it up automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Magento, on the other hand, uses a configuration-based MVC pattern , meaning
    that creating our file/class is not enough; we explicitly have to tell Magento
    that we added a new class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each Magento module has a `config.xml` file, which is located under the module
    `etc/` directory and contains all the relevant module configuration. For example,
    if we want to add a new module that includes a new model, we would need to define
    a node in the configuration file that tells Magento where to find our model, such
    as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Although this might look like additional work, it also gives us a huge amount
    of flexibility and power. For example, we can rewrite another class by using the
    `rewrite` node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Magento will then load all the `config.xml` files and merge them at runtime,
    creating a single configuration tree.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, modules can also have a `system.xml` file, which is used to specify
    configuration options in the Magento backend, which in turn can be used by end
    users to configure the module functionality. A snippet of a `system.xml` file
    would look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s break down each node function:'
  prefs: []
  type: TYPE_NORMAL
- en: '`section_name`: This is just an arbitrary name that we use to identify our
    configuration section; inside this node we will specify all the fields and groups
    for the configuration section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`group`: Groups, as the name implies, are used to group configuration options
    and display them inside an accordion section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`label`: This defines the title or label to be used on the field/section/group.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tab`: This defines the tab on which the section should be displayed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`frontend_type`: This node allows us to specify which render to use for our
    custom option field. Some of the available options are:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`button`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`checkboxes`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`checkbox`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`date`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`file`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hidden`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`image`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`label`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`link`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`multiline`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`multiselect`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`password`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`radio`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`radios`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`select`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`submit`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`textarea`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`text`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`time`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sort_order`: It specifies the position of the field, group, or section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`source_model`: Certain type of fields such as a `select` field can take options
    from a source model. Magento already provides several useful classes under `Mage/Adminhtml/Model/System/Config/Source`.
    Some of the classes we can find are:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`YesNo`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Country`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Currency`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AllRegions`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Category`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Language`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By just using XML, we can build complex configuration options for our modules
    right on the Magento backend, without having to worry about setting up templates
    for populating fields or validating data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Magento is also kind enough to provide a comprehensive amount of form field
    validation models, which we can use with the `<validate>` tag. Among the following
    field validators we have:'
  prefs: []
  type: TYPE_NORMAL
- en: '`validate-email`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`validate-length`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`validate-url`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`validate-select`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`validate-password`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As with any other part of Magento we can extend the `source_model`, `frontend_type`,
    and `validator` functions and even create new ones. We will be tackling this task
    in a later chapter where we will create a new type of each. But for now, we will
    explore the concepts of models, views, file layouts, and controllers.
  prefs: []
  type: TYPE_NORMAL
- en: Models
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Magento makes use of the ORM approach; although we can still use `Zend_Db`
    to access the database directly, we will be using models to access our data most
    of the time. For this type of task, Magento provides the following two types of
    models:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Simple models**: This model implementations are a simple mapping of one object
    to one table, meaning our object attributes match each field and our table structure'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Entity Attribute Value (EAV) models**: This type of models are used to describe
    entities with a dynamic number of attributes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Magento splits the model layer up into two parts: a model handling the business
    logic and a resource handling the database interaction. This design decision allows
    Magento to eventually support multiple database platforms without having to change
    any of the logic inside the models.'
  prefs: []
  type: TYPE_NORMAL
- en: Magento ORM uses one of PHP's magic class methods to provide dynamic access
    to object properties. In the next chapter we will look into models, the Magento
    ORM, and the data collections in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Magento models don't necessarily have to be related to any type of table in
    the database or an EAV entity. Observers, who we will be reviewing later, are
    perfect examples of this type of Magento models.
  prefs: []
  type: TYPE_NORMAL
- en: Views
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The view layer is one of the areas where Magento truly sets itself apart from
    other MVC applications. Unlike traditional MVC systems, Magento''s view layer
    is divided into the following three different components:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Layouts**: Layouts are XML files that define the block structure and properties
    such as name and the template file we can use. Each Magento module has its own
    set of layout files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Blocks**: Blocks are used in Magento to reduce the burden on the controller
    by moving most of the logic into blocks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Templates**: Templates are PHTML files that contain the required HTML code
    and PHP tags.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Layouts give the Magento frontend an amazing amount of flexibility. Each module
    has its own layout XML files, which tell Magento what to include and render on
    each page request. Through the use of the layouts, we can move, add, or remove
    blocks from our store without worrying about changing anything else other than
    our XML files.
  prefs: []
  type: TYPE_NORMAL
- en: Dissecting a layout file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s examine one of the core layout files of Magento, in this case `catalog.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Layout blocks are comprised of three main XML nodes, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`handle`: Each page request will have several unique handles; the layout uses
    these handles to tell Magento which blocks to load and render on a per page basis.
    The most commonly used handles are `default` and `[frontname]_[controller]_[action]`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `default` handle is especially useful for setting global blocks, for example
    adding a CSS or JavaScript to all pages on the header block.
  prefs: []
  type: TYPE_NORMAL
- en: '`reference`: A `<reference>` node is used to make references to a block. It
    is useful for specifying nested blocks or modifying an already existing block.
    In our example we can see a new children block being specified inside `<reference
    name="left">`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`block`: The `<block>` node is used to load our actual blocks. Each block node
    can have the following properties:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`type`: This is the identifier for the actual block class. For example, `catalog`/`product_list`
    makes reference to the `Mage_Catalog_Block_Product_List`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`name`: This is the name used by other blocks to make reference to this block.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`before`/`after`: These properties can be used to position the blocks relative
    to other blocks'' position. Both these properties can use a hyphen as a value
    to specify if the module should appear at the very top or the very bottom.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`template`: This property determines the `.phtml` template file, which will
    be used for rendering the block.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`action`: Each block type has specific actions that affect the frontend functionality.
    For instance, the `page`/`html_head` block, which has actions for adding CSS and
    JavaScript (`addJs` and `addCss`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`as`: This is used to specify the unique identifier that we will be using for
    calling the block from the template, for example calling a child block by using
    `getChildHtml(''block_name'')`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Blocks are a new concept that Magento implements in order to reduce the controller
    load. They are basically data resources that communicate directly with the models,
    which manipulate the data, if needed, and then pass it to the views.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we have our PHTML files; the templates contain the `html` and `php`
    tags and are in charge of formatting and displaying the data from our models.
    Let''s take a look at a snippet from the product view template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the block diagram of MVC:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Dissecting a layout file](graphics/3060OS_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Controllers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Magento, MVC controllers are designed to be thin controllers; thin controllers
    have little business logic and are mostly used for driving the application requests.
    A basic Magento controller action would just load and render the layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: From here it is the job of the blocks to handle the display logic, get the data
    from our models, prepare the data, and send it to the views.
  prefs: []
  type: TYPE_NORMAL
- en: Websites and store scopes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the core features of Magento is the ability to handle multiple websites
    and stores with a single Magento installation; internally, Magento refers to each
    of these instances as scopes.
  prefs: []
  type: TYPE_NORMAL
- en: '![Websites and store scopes](graphics/3060OS_02_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Values for certain elements such as products, categories, attributes, and configurations
    are scope specific and can differ on different scopes; this gives Magento tremendous
    flexibility, for example, a product can be set up on two different websites with
    different prices but can still share the rest of the attribute configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'As developers, one of the areas where we will be using scopes the most is when
    working with configuration. The different configuration scopes available in Magento
    are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Global**: As the name implies, this applies across all scopes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Website**: These are defined by a domain name and are composed by one or
    more stores. Websites can be set up to share customer data or be completely isolated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Store**: Stores are used to manage products and categories, and to group
    store views. Stores also have a root category that allows us to have separated
    catalogs per store.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Store view**: By using store views we can set up multiple languages on our
    store frontend.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Configuration options in Magento can store values on three scopes (global,
    website, and store view); by default, all the values are set on the global scope.
    By using `system.xml` on our modules, we can specify the scopes on which the configuration
    options can be set; let''s revisit our previous `system.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Factory names and functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Magento makes use of factory methods to instantiate `Model`, `Helper`, and `Block`
    classes. A factory method is a design pattern that allows us to instantiate an
    object without using the exact class name and using a class alias instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Magento implements several factory methods, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Mage::getModel()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Mage::getResourceModel()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Mage::helper()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Mage::getSingleton()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Mage::getResourceSingleton()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Mage::getResourceHelper()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Each of these methods takes a class alias that is used to determine the real
    class name of the object that we are trying to instantiate; for example, if we
    wanted to instantiate a `product` object, we can do so by calling the `getModel()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that we are passing a factory name composed of `group_classname/model_name`;
    Magento will resolve this to the actual class name of `Mage_Catalog_Model_Product`.
    Let''s take a closer look at the inner workings of `getModel()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '`getModelInstance()` in return calls the `getModelClassName()` method, which
    takes our class alias as a parameter. Then it tries to validate the existence
    of the returned class, and if the class exists, it will create a new instance
    of that class and return it to our `getModel()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '`getModelClassName()` calls the `getGroupedClassName()` method, which is actually
    in charge of returning the real class name of our model.'
  prefs: []
  type: TYPE_NORMAL
- en: '`getGroupedClassName()` takes two parameters – `$groupType` and `$classId`;
    `$groupType` refers to the type of object that we are trying to instantiate (currently
    only models, blocks, and helpers are supported) and `$classId`, which we are trying
    to instantiate.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, `getGroupedClassName()` is actually doing all the work; it grabs
    our class alias `catalog`/`product` and creates an array by exploding the string
    on the slash character.
  prefs: []
  type: TYPE_NORMAL
- en: Then, it loads an instance of `VarienSimplexml_Element` and passes the first
    value in our array (`group_classname`). It will also check if the class has been
    rewritten, and if it has, we will use the corresponding group name.
  prefs: []
  type: TYPE_NORMAL
- en: Magento also uses a custom version of the `uc_words()` function, which will
    capitalize the first letters and convert separators of the class alias if needed.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the function will return the real class name to the `getModelInstance()`
    function; in our example case it will return `Mage_Catalog_Model_Product`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Factory names and functions](graphics/3060OS_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Events and observers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The event and observer pattern is probably one of Magento's more interesting
    features, since it allows developers to extend Magento in critical parts of the
    application flow.
  prefs: []
  type: TYPE_NORMAL
- en: In order to provide more flexibility and facilitate the interaction between
    the different modules, Magento implements an event/observer pattern; this pattern
    allows for modules to be loosely coupled.
  prefs: []
  type: TYPE_NORMAL
- en: There are two parts of this system – an event dispatch with the object and event
    information, and an observer listening to a particular event.
  prefs: []
  type: TYPE_NORMAL
- en: '![Events and observers](graphics/3060OS_02_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Event dispatch
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Events are created or dispatched using the `Mage::dispatchEvent()` function.
    The core team has already created several events on critical parts of the core.
    For example, the model abstract class `Mage_Core_Model_Abstract` calls two protected
    functions every time a model is saved – `_beforeSave()` and `_afterSave()`; on
    each of these methods two events are fired:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Each function fires a generic `mode_save_after` event, and then a dynamic version
    based on the type of object being saved. This gives us a wide range of possibilities
    for manipulating objects through observers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Mage::dispatchEvent()` method takes two parameters: the first is the event
    name and the second is an array of data that is received by the observer. We can
    pass values or objects in this array. This comes in handy if we want to manipulate
    the objects.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to understand the details of the event system, let''s take a look
    at the `dispatchEvent()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This function is actually an alias to the `dispatchEvent()` function inside
    the `app` core class located in `Mage_Core_Model_App`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The `dispatchEvent()` method is actually doing all the work on the event/observer
    model:'
  prefs: []
  type: TYPE_NORMAL
- en: It gets the Magento configuration object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It walks through the observer's node children, checking if the defined observer
    is listening to the current event.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For each of the available observers, the dispatch event will try to instantiate
    the observer object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Lastly, Magento will try to call the corresponding observer function mapped
    to this particular event.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Observer bindings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, dispatching an event is the only part of the equation. We also need to
    tell Magento which observer is listening to each event. Not to our surprise, observers
    are specified through `config.xml`. As we saw before, the `dispatchEvent()` function
    queries the configuration object for available observers. Let''s take a look at
    an example `config.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The `event` node can be specified in each of the configuration sections (admin,
    global, frontend, and so on) and we can specify multiple `event_name` children
    nodes; the `event_name` has to match the event name used in the `dispatchEvent()`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: Inside each `event_name` node, we have a single observer node that can contain
    multiple observers, each with a unique identifier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Observer nodes have two properties such as `<class>`, which points to our observer
    model class and `<method>`, which in turn points to the actual method inside the
    observer class. Let''s analyze an example observer class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One interesting thing about observer models is that they don't extend any other
    Magento class.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered many important and fundamental topics about Magento
    such as its architecture, folder structure, routing system, MVC patterns, events
    and observers, and configuration scopes.
  prefs: []
  type: TYPE_NORMAL
- en: And while this might seem overwhelming at first sight, it is just the tip of
    the iceberg. There is a lot more to learn about each of these topics and Magento.
    The purpose of this chapter is to make developers aware of all the important components
    of the platform from the configuration object up to the way the event/object pattern
    is implemented.
  prefs: []
  type: TYPE_NORMAL
- en: Magento is a powerful and flexible system, and it is much more than an e-commerce
    platform. The core team has put a lot of effort in making Magento a powerful framework.
  prefs: []
  type: TYPE_NORMAL
- en: In later chapters, we will not only review all these concepts in more detail,
    but we will also apply them in a practical manner by building our own extensions.
  prefs: []
  type: TYPE_NORMAL
