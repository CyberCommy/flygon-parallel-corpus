- en: Persistence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 5](d1169ccb-4e46-49f4-b41b-2aaf896337ad.xhtml), *Data*, we created
    a framework for capturing and holding data in memory.  However, this is only half
    of the story, as without persisting the data to some external destination, it
    will be lost as soon as we close the application. In this chapter, we will build
    on our earlier work and save our data to disk in a SQLite database so that it
    can live on beyond the lifetime of the application. Once saved, we will also build
    methods for finding, editing, and deleting our data. To get all these operations
    for free in our various data models, we will extend our data entities so that
    they can load and save to our database automatically, without us having to write
    boilerplate code in each class. We will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: SQLite
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Primary keys
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating clients
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding clients
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Editing clients
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deleting clients
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SQLite
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: General purpose database technology has fragmented in the recent years with
    the explosion of NoSQL and Graph databases. However, SQL databases are still fighting
    fit and absolutely an appropriate choice in a lot of applications. Qt comes with
    built-in support for several SQL database driver types, and can be extended with
    custom drivers. MySQL and PostgreSQL are very popular open source SQL database
    engines and are both supported by default, but are intended for use on servers
    and require administration, which makes them a bit unnecessarily complicated for
    our purposes. Instead, we will use the much more lightweight SQLite, which is
    commonly used as a client-side database and is very popular in mobile applications
    due to its small footprint.
  prefs: []
  type: TYPE_NORMAL
- en: According to the official website at [https://www.sqlite.org](https://www.sqlite.org/),
    "SQLite is a self-contained, high-reliability, embedded, full-featured, public-domain,
    SQL database engine. SQLite is the most used database engine in the world". Paired
    with Qt's SQL related classes, it's a snap to create a database and store your
    data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we need to do is add the SQL module to our library project
    to get access to all of Qt’s SQL goodness. In `cm-lib.pro`, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we’ll take onboard what we discussed in the previous chapter and implement
    our database-related functionality behind an interface. Create a new `i-database-controller.h`
    header file in `cm-lib/source/controllers`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are implementing the four basic functions of (**Create**, **Read**,
    **Update**, and **Delete**) **CRUD**, which are relevant to persistent storage
    in general, not just SQL databases. We supplement these functions with an additional
    `find()` method that we will use to find an array of matching clients based on
    supplied search text.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s create a concrete implementation of the interface. Create a new `DatabaseController`
    class in `cm-lib/source/controllers`.
  prefs: []
  type: TYPE_NORMAL
- en: '`database-controller.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s walk through each of the key implementation details in `database-controller.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Starting with the private implementation, we’ve broken the initialization into
    two operations: `initialise()` instantiates a connection to a SQLite database
    with a file named `cm.sqlite`, and this operation will first create the database
    file for us if it doesn’t already exist. The file will be created in the same
    folder as the application executable, `createTables()`, then creates any tables
    that we need which don’t already exist in the database. Initially, we only need
    a single table named client, but this can be easily extended later. We delegate
    the actual work of creating the named table to the `createJsonTable()` method
    so that we can reuse it for multiple tables.
  prefs: []
  type: TYPE_NORMAL
- en: 'A conventional normalized relational database approach would be to persist
    each of our data models in their own table, with fields that match the properties
    of the class. Recall the model diagram back in [Chapter 5](d1169ccb-4e46-49f4-b41b-2aaf896337ad.xhtml),
    *Data*, which is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f194d8cd-8f52-4936-bebc-64a2f23f37a9.png)'
  prefs: []
  type: TYPE_IMG
- en: We could create a Client table with the "reference" and "name" fields, a contact
    table with the "type", "address", and other fields. However, we will instead leverage
    the JSON serialization code we’ve already implemented and implement a pseudo document-style
    database. We will utilize a single client table that will store a unique ID for
    the client along with the whole client object hierarchy serialized to JSON.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we''ve also added a `sqliteVersion()` utility method to identify which
    version of SQLite the database is using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The CRUD operations are all based around the `QSqlQuery` class and prepared
    `sqlStatements`. In all cases, we first perform some perfunctory checks on the
    parameters to ensure that we’re not trying to do something silly. We then concatenate
    the table name into a SQL string, representing parameters with the `:myParameter`
    syntax. After preparing the statement, parameters are subsequently substituted
    in using the `bindValue()` method on the query object.
  prefs: []
  type: TYPE_NORMAL
- en: 'When creating, deleting, or updating rows, we simply return a `true`/`false`
    success indicator on query execution. Assuming that the query prepares and executes
    without error, we check that the number of rows affected by the operation is greater
    than `0`. The read operation returns a JSON object parsed from the JSON text stored
    in the matching record. If no record is found or if the JSON cannot be parsed,
    then we return a default JSON object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Finally, the `find()` method does essentially the same thing as the CRUD operations
    but compiles an array of JSON objects as there may be more than one match. Note
    that we use the `like` keyword in the SQL statement, combined with the `%` wildcard
    character, to find any JSON that contains the search text. We also convert both
    sides of the comparison to lowercase to make the search effectively case-insensitive.
  prefs: []
  type: TYPE_NORMAL
- en: Primary keys
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Integral to most of these operations is an ID parameter used as the primary
    key in our table. To support the persistence of our entities using this new database
    controller, we need to add a property to our `Entity` class that uniquely identifies
    an instance of that entity.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `entity.cpp`, add a member variable to `Entity::Implementation`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, initialize it in the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: When we instantiate a new `Entity`, we need to generate a new unique ID, and
    we use the QUuid class to this for us with the `createUuid()` method. A **Universally
    Unique Identifier** (**UUID**)is essentially a randomly generated number that
    we then convert to a string in the “{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}" format, where
    "x" is a hex digit. You will need to `#include <QUuid>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, provide a public accessor method for it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The challenge now is that if we are creating an `Entity` that already has an
    ID (for example, loading a client from the database), we need some mechanism for
    overwriting the generated ID value with the known value. We’ll do this in the
    `update()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, when we serialize the object to JSON, we need to include the ID
    too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Great! This gives us automatically generated unique IDs for all of our data
    models, which we can use as the primary key in our database table. However, a
    common usecase with database tables is that there is actually an existing field
    that is a great candidate for use as a primary key, for example, a National Insurance
    or Social Security number, an account reference, or site ID. Let’s add a mechanism
    for specifying a data decorator to use as the ID that will override the default
    UUID, if set.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our `Entity` class, add a new private member in `Implementation`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'You will need to `#include` the `StringDecorator` header. Add a protected mutator
    method to set it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then tweak our `id()` method to return us the primary key value if appropriate,
    otherwise default to the generated UUID value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in the `client.cpp` constructor, after we have instantiated all the data
    decorators, we can specify that we want to use the reference field as our primary
    key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Let’s add a couple of tests to verify this behavior. We’ll verify that if a
    reference value is set, the `id()` method returns that value, otherwise it returns
    a generated UUID loosely of the “{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}" format.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `client-tests.h` of the `cm-tests` project, add two new tests in the private
    slots scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, implement the tests in `client-tests.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Note that the checks are effectively performed twice in the first test just
    to demonstrate a couple of different approaches you can take. First, we check
    using individual character matches (‘{‘, ‘-’, and ‘}’), which is quite long-winded
    but easy for other developers to read and understand. Then, we perform the check
    again using Qt’s regular expression helper class. This is much shorter but more
    difficult to parse for normal humans who don’t speak regular expression syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Build and run the tests, and they should validate the changes we have just implemented.
  prefs: []
  type: TYPE_NORMAL
- en: Creating clients
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s put our new infrastructure to use and wire up the `CreateClientView`.
    If you remember, we present a save command that when clicked on, calls `onCreateClientSaveExecuted()`
    on `CommandController`. In order to be able to perform anything useful, `CommandController`
    needs visibility of the client instance to be serialized and saved, and an implementation
    of the `IDatabaseController` interface to perform the create operation for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inject them into the constructor in `command-controller.h`, including any necessary
    headers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'As we’ve seen a few times now, add the member variables to `Implementation`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Pass them through the `CommandController` constructor to the Implementation
    constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can update the `onCreateClientSaveExecuted()` method to create our new
    client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Our client instance provides us with all the information we need to be able
    to save it to the database, and the database controller performs the database
    interactions.
  prefs: []
  type: TYPE_NORMAL
- en: Our `CommandController` is now ready, but we’re not actually injecting the database
    controller or new client in yet, so head over to `master-controller.cpp` and add
    an instance of a `DatabaseController` as we did with `CommandController` and `NavigationController`.
    Add a private member, accessor method, and `Q_PROPERTY`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `Implementation` constructor, we need to ensure that we initialize the
    new client and `DatabaseController` before we initialize the `CommandController`,
    and then pass the pointers through:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Build and run `cm-ui`, and you should see messages in the Application Output
    from the newly instantiated `DatabaseController`, telling you that it has created
    the database and table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Take a look at the output folder where your binaries are, and you will see a
    new `cm.sqlite` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you navigate to Create Client View, enter a name, and click on the Save
    button, you will see further output, confirming that the new client has been saved
    successfully:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s take a look inside our database and see what work has been done for us.
    There are several SQLite browsing applications and web browser plugins available,
    but the one I tend to use is found at [http://sqlitebrowser.org/](http://sqlitebrowser.org/).
    Download and install this, or any other client of your choice for your operating
    system, and open the `cm.sqlite` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/035414d6-2999-4408-b674-f05e382fe65d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You will see that we have a client table, just as we asked for, with two fields: id
    and json. Browse Data for the client table, and you will see our newly created
    record with the name property we entered on the UI:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/63acbb6f-08c5-42b8-8189-e2cc4d95bb86.png)'
  prefs: []
  type: TYPE_IMG
- en: Fantastic, we have created our first client in the database. Note that the `DatabaseController`
    initialization methods are idempotent, so you can launch the application again
    and the existing database will not be affected. Similarly, if you manually delete
    the `cm.sqlite` file, then launching the application will create a new version
    for you (without the old data), which is a simple way of deleting test data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s make a quick tweak to add the `reference` property of the client. In
    `CreateClientView`, duplicate the `StringEditorSingleLine` component bound to
    `ui_name`, and bind the new control to `ui_reference`. Build, run, and create
    a new client:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2c9bf851-c9e6-4512-9e50-8cffc2b6c766.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Our new client happily uses the specified client reference as the unique primary
    key:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fcbd34f0-f483-49be-beed-c0b2fb8dda95.png)'
  prefs: []
  type: TYPE_IMG
- en: Panels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s flesh out our `CreateClientView` a little so that we can actually
    save some meaningful data rather than just a bunch of empty strings. We still
    have lots of fields to add in, so we''ll break things up a little, and also visually
    separate the data from the different models, by encapsulating them in discreet
    panels with descriptive titles and a drop shadow to give our UI a bit of pizzazz:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d1af194c-0617-4db3-ac07-4fb20013f77c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We’ll begin by creating a generic panel component. Create a new QML file in
    `cm-ui/components` named `Panel.qml`. Update `components.qrc` and `qmldir`, as
    we have done for all the other components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This is an extremely dynamic component. Unlike our other components, where we
    pass in a string or maybe even a custom class, here we are passing in the entire
    contents of the panel. We achieve this using a `Loader` component, which loads
    a QML subtree on demand. We alias the `sourceComponent` property so that calling
    elements can inject their desired content at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Due to the dynamic nature of the content, we can’t set the component to be a
    fixed size, so we leverage the `implicitWidth` and `implicitHeight` properties
    to tell parent elements how large the component wants to be based on the size
    of the title bar plus the size of the dynamic content.
  prefs: []
  type: TYPE_NORMAL
- en: To render the shadow, we draw a simple `Rectangle`, ensuring that it is rendered
    first by placing it near the top of the file. We then use the `x` and `y` properties
    to offset it from the rest of the elements, moving it slightly across and down.
    The remaining `Rectangle` elements for the header strip and panel background are
    then drawn over the top of the shadow.
  prefs: []
  type: TYPE_NORMAL
- en: 'To support the styling here, we need to add a collection of new `Style` properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Next, let’s add a component for address editing so that we can reuse it for
    both the supply and billing addresses. Create a new QML file in `cm-ui/components`
    named `AddressEditor.qml`. Update `components.qrc` and `qmldir` as earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll use our new `Panel` component as the root element and add an `Address`
    property, so that we can pass in an arbitrary data model to bind to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Here, you can see the flexibility of our new `Panel` component in action, thanks
    to the embedded `Loader` element. We can pass in whatever QML content we want,
    and it will be presented in the panel.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we can update our `CreateClientView` to add our new refactored address
    components. We’ll also move the client controls onto their own panel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we build and run, we just need to tweak the background color of our
    `StringEditorSingleLine` `textLabel` so that it matches the panels they are now
    displayed on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/b6e32497-89df-4bf3-ba33-42af47bc0b7b.png)'
  prefs: []
  type: TYPE_IMG
- en: Go ahead and create a new client and check the database. You should now see
    the supply and billing address details successfully saved. We’ve now got the C
    in our CRUD operational, so let’s move on to the ‘R’.
  prefs: []
  type: TYPE_NORMAL
- en: Finding clients
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've just successfully saved our first clients to the database, so let's now
    look at how we can find and view that data. We’ll encapsulate our searching functionality
    in a dedicated class in `cm-lib`, so go ahead and create a new class named `ClientSearch`
    in `cm-lib/source/models`.
  prefs: []
  type: TYPE_NORMAL
- en: '`client-search.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '`client-search.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: We need to capture some text from the user, search the database using that text,
    and display the results as a list of matching clients. We accommodate the text
    using a `StringDecorator`, implement a `search()` method to perform the search
    for us, and finally, add an `EntitityCollection<Client>` to store the results.
    One additional point of interest here is that we need to signal to the UI when
    the search results have changed so that it knows that it needs to rebind the list.
    To do this, we notify using the signal `searchResultsChanged()`, and we connect
    this signal directly to the `collectionChanged()` signal built into `EntityCollection`.
    Now, whenever the list that is hidden away in `EntityCollection` is updated, the
    UI will be automatically notified of the change and will redraw itself as needed.
  prefs: []
  type: TYPE_NORMAL
- en: Next, add an instance of `ClientSearch` to `MasterController`, just as we did
    for the new client model. Add a private member variable of the `ClientSearch*` type
    named `clientSearch`, and initialize it in the `Implementation` constructor. Remember
    to pass the `databaseController` dependency to the constructor. Now that we are
    passing more and more dependencies, we need to be careful about the initialization
    order. `ClientSearch` has a dependency on `DatabaseController`, and when we come
    to implement our search commands in `CommandController`, that will have a dependency
    on `ClientSearch`. So ensure that you initialize `DatabaseController` before `ClientSearch`
    and that `CommandController` comes after both of them. To finish off the changes
    to `MasterController`, add a `clientSearch()` accessor method and a `Q_PROPERTY`
    named `ui_clientSearch`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As usual, we need to register the new class in the QML subsystem before we
    can use it in the UI. In `main.cpp`, `#include <models/client-search.h>` and register
    the new type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'With all that in place, we can wire up our `FindClientView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We access the `ClientSearch` instance via `MasterController` and create a shortcut
    to it with a property. We also utilize our new `Panel` component again, which
    gives us a nice consistent look and feel across views with very little work:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ff6f1c18-de37-4492-952d-1c01d8775251.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The next step is to add a command button for us to be able to instigate a search.
    We do this back over in `CommandController`. Before we get into the commands,
    we have an additional dependency on the `ClientSearch` instance, so add a parameter
    to the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Pass the parameter through to the `Implementation` class and store it in a
    private member variable, just as we did with `newClient`. Hop back to `MasterController`
    briefly and add the `clientSearch` instance into the `CommandController` initialization:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Next, in `CommandController`, duplicate and rename the private member variable,
    accessor, and `Q_PROPERTY` that we added for the create client view so that you
    end up with a `ui_findClientViewContextCommands` property for the UI to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an additional public slot, `onFindClientSearchExecuted()`, which will
    be called when we hit the search button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have an empty command list for our find view and a delegate to be called
    when we click on the button; all we need to do now is add a search button to the
    `Implementation` constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'That’s it for the command plumbing; we can now easily add a command bar to
    `FindClientView`. Insert the following as the last element within the root item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/1c44bc94-195d-43b8-b7c0-4129fb1fc62e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Enter some search text and click on the button, and you will see in the Application
    Output console that everything triggers as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Great, now what we need to do is take the search text, query the SQLite database
    for a list of results, and display those results on screen. Fortunately, we’ve
    already done the groundwork for querying the database, so we can easily implement
    that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'There is a bit more work to do on the UI side to display the results. We need
    to bind to the `ui_searchResults` property and dynamically display some sort of
    QML subtree for each of the clients in the list. We will use a new QML component,
    `ListView`, to do the heavy lifting for us. Let’s start simple to demonstrate
    the principle and then build out from there. In `FindClientView`, immediately
    after the Panel element, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The two key properties of a `ListView` are as listed:'
  prefs: []
  type: TYPE_NORMAL
- en: The `model`, which is the list of items that you want to display
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `delegate`, which is how you want to visually represent each item
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In our case, we bind the model to our `ui_searchResults` and represent each
    item with a simple `Text` element displaying the client reference number. Of particular
    importance here is the `modelData` property, which is magically injected into
    the delegate for us and exposes the underlying item (which is a client object,
    in this case).
  prefs: []
  type: TYPE_NORMAL
- en: 'Build, run, and perform a search for a piece of text you know exists in the
    JSON for one of the test clients you have created so far, and you will see that
    the reference number is displayed for each of the results. If you get more than
    one result and they lay out incorrectly, don’t worry, as we will replace the delegate
    anyway:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a63d1111-ec63-4786-a8bc-0614cd56606f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To keep things neat and tidy, we’ll write a new custom component to use as
    the delegate. Create `SearchResultDelegate` in `cm-ui/components`, and update
    `components.qrc` and `qmldir` as usual:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: There isn’t really anything new here, we’ve just combined techniques covered
    in other components. Note that the `MouseArea` element will trigger a method on
    `masterController` that we haven’t implemented yet, so don’t worry if you run
    this and get an error when you click on one of the clients.
  prefs: []
  type: TYPE_NORMAL
- en: 'Replace the old `Text` delegate in `FindClientView` with our new component
    using the `modelData` property to set the `client`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/763dcfa3-7b48-4081-a618-625ed04edda2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let’s implement the `selectClient()` method on `MasterController`:'
  prefs: []
  type: TYPE_NORMAL
- en: We can just emit the `goEditClientView()` signal directly from the `SearchResultDelegate`
    and bypass `MasterController` entirely. This is a perfectly valid approach and
    is indeed simpler; however, I prefer to route all the interactions through the
    business logic layer, even if all the business logic does is to emit the navigation
    signal. This means that if you need to add any further logic later on, everything
    is already wired up and you don’t need to change any of the plumbing. It’s also
    much easier to debug C++ than QML.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `master-controller.h`, we need to add our new method as a public slot as
    it will be called directly from the UI, which won’t have visibility of a regular
    public method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Provide the implementation in `master-controller.cpp`, simply calling the relevant
    signal on the navigation coordinator and passing through the client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: With the searching and selection in place, we can now turn our attention to
    editing clients.
  prefs: []
  type: TYPE_NORMAL
- en: Editing clients
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With an existing client now located and loaded from the database, we need a
    mechanism to be able to view and edit the data. Let’s prepare by first creating
    the context commands we will use in the edit view. Repeat the steps we took for
    the Find Client View and in `CommandController`, add a new list of commands named
    `editClientViewContextCommands`, along with an accessor method and `Q_PROPERTY`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new slot to be called when the user saves their changes on the edit
    view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a new save command to the list that calls the slot when executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'We now have a list of commands we can present to the Edit Client View; however,
    a challenge that we now need to overcome is that when we execute this command,
    the `CommandController` has no idea which client instance it needs to work with.
    We can’t pass in the selected client as a dependency to the constructor like we
    do with the new client, because we have no idea which client the user will select.
    One option would be to move the list of edit commands out of the `CommandController`
    and into the client model. Then, each client instance can present its own commands
    to the UI. However, this means that command functionality is fractured, and we
    lose the nice encapsulation that the command controller gives us. It also bloats
    the **client** model with functionality it shouldn’t care about. Instead, we will
    add the currently selected client as a member within `CommandController` and set
    it whenever the user navigates to the `editClientView`. In `CommandController::Implementation`,
    add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a new public slot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have the selected client available, we can go ahead and complete
    the implementation of the save slot. Again, we’ve already done the hard work in
    the `DatabaseController` and client classes, so this method is really straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'From the UI point of view, editing an existing client will essentially be the
    same as creating a new client. So much so, in fact, that we can even probably
    use the same view and just pass in a different client object in each case. However,
    we’ll keep the two functions separate and just copy and tweak the QML we’ve already
    written for creating a client. Update `EditClientView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: We change the client property to match the `selectedClient` property `MasterView`
    sets in the `Connections` element. We use the `Component.onCompleted` slot to
    call through to `CommandController` and set the currently selected client. Finally,
    we update `CommandBar` to reference the new context command list we just added.
  prefs: []
  type: TYPE_NORMAL
- en: Build and run, and you should now be able to make changes to a selected client
    and use the Save button to update the database.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting clients
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The final part of our CRUD operations is deleting an existing client. Let’s
    trigger this via a new button on `EditClientView`. We’ll begin by adding the slot
    that will be called when the button is pressed to `CommandController`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: This follows the same pattern as the other slots, except this time we also clear
    the `selectedClient` property as although the client instance still exists in
    application memory, it has been semantically deleted by the user. We also refresh
    the search so that the deleted client is removed from the search results. As this
    method stands, we’ve performed the correct database interaction but the user will
    be left on `editClientView` for a client that they have just asked to be deleted.
    What we want is for the user to be navigated back to the dashboard. In order to
    do this, we need to add `NavigationController` as an additional dependency to
    our `CommandController` class. Replicate what we did for the `DatabaseController`
    dependency so that we can inject it into the constructor. Remember to update `MasterController`
    and pass in the navigation controller instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'With an instance of a database controller available, we can then send the user
    to the Dashboard View:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have the navigation controller available, we can also improve the
    experience when creating new clients. Rather than leaving the user on the new
    client view, let’s perform a search for the newly created client ID and navigate
    them to the results. They can then easily select the new client if they wish to
    view or edit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'With the deletion slot complete, we can now add a new delete command to the
    `editClientContextCommands` list in `CommandController`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'We are now presented with the option to delete an existing client:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a16062b1-ad68-44bf-ad11-094b3cc3c6b7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you delete a client, you will see that the row is removed from the database
    and the user is successfully navigated back to the dashboard. However, you will
    also see that the Application Output window is full of QML warnings along the
    lines of `qrc:/views/EditClientView:62: TypeError: Cannot read property ''ui_billingAddress''
    of null`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The reason for this is that the edit view is bound to a client instance that
    is part of the search results. When we refresh the search, we delete the old search
    results, which means that the edit view is now bound to `nullptr` and can no longer
    access the data. This continues to happen even if you navigate to the dashboard
    before refreshing the search, because of the asynchronous nature of the signals/slots
    used to perform the navigation. One way of fixing these warnings is to add null
    checks on all the bindings in the view and bind to local temporary objects if
    the main object is null. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'So, if `selectedClient` is not null, bind to the `ui_reference` property of
    that, otherwise bind to `temporaryObject`. You can even add a level of indirection
    to the root Client property and substitute the entire client object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Here, `selectedClient` will be set by the parent as normal; `localTemporaryClient`
    will not be set, so a default instance will be created locally. `clientToBindTo`
    will then pick the appropriate object to use and all the child controls can bind
    to that. As these bindings are dynamic, if `selectedClient` was deleted after
    loading the view (as in our case), then `clientToBindTo` will automatically switch
    over.
  prefs: []
  type: TYPE_NORMAL
- en: As this is just a demonstration project, it is safe for us to ignore the warnings,
    so we will take no action here to keep things simple.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we added database persistence for our client models. We made
    it generic and flexible so that we can easily persist other model hierarchies
    by simply adding a new table to our `DatabaseController` class. We covered all
    the core CRUD operations, including a free text search capability that matches
    against the entire JSON object.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](d04b2aa4-cbbe-4826-b27f-5f00ea4cfb07.xhtml), *Web Requests*,
    we will continue the theme of reaching outside of our application for data and
    look at another extremely common Line of Business application requirement making
    HTTP requests to web services.
  prefs: []
  type: TYPE_NORMAL
