- en: Dependency Injection with Monkey Patching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Do you have code that relies on a global variable? Do you have code that is
    dependent on the filesystem? Have you ever tried to test your database error handling
    code?
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will examine monkey patching as a way to *swap out* dependencies
    during our tests and test in a manner that is otherwise impossible. It doesn't
    matter if these dependencies are objects or functions. We will apply monkey patching
    to our sample service so that we can decouple our tests from the database; decouple
    the different layers from each other and all without resorting to significant
    refactoring.
  prefs: []
  type: TYPE_NORMAL
- en: In continuing with our pragmatic, skeptical approach, we will also discuss the
    advantages and disadvantages of monkey patching.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Monkey magic—an introduction to monkey patching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advantages of monkey patching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying monkey patching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disadvantages of monkey patching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It would be beneficial to be familiar with the code for our service that we
    introduced in [Chapter 4](9b5a6d56-9d43-4a12-a580-6ca8b13b9201.xhtml), *Introduction
    to ACME registration service*. You might also find it useful to read and run the
    full versions of the code for this chapter, which are available at [https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/tree/master/ch05](https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/tree/master/ch05).
  prefs: []
  type: TYPE_NORMAL
- en: Instructions to obtain the code and configure the sample service are available
    in the README here [https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/](https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/).
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code for our service, with the changes from this chapter already
    applied, in `ch05/acme`.
  prefs: []
  type: TYPE_NORMAL
- en: Monkey magic!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Monkey patching is changing a program at runtime, typically by replacing a function
    or variable.
  prefs: []
  type: TYPE_NORMAL
- en: While this is not a traditional form of **dependency injection** (**DI**), it
    can be used in Go to facilitate testing. In fact, monkey patching can be used
    to test in ways that are otherwise impossible.
  prefs: []
  type: TYPE_NORMAL
- en: Let's consider a real-world analogy first. Let's say you want to test the effects
    of a car crash on the human body. You probably wouldn't be volunteering to be
    the human that was in the car during testing. Nor are you allowed to make changes
    to the vehicle to facilitate your testing. But you could swap out (monkey patch)
    the human for a crash test dummy during your test.
  prefs: []
  type: TYPE_NORMAL
- en: The same process holds true for monkey patching in code; the changes only exist
    during the test and in many cases can be applied with little impact on the production
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 'A quick note for those of you familiar with dynamic languages such as Ruby,
    Python, and JavaScript: it is possible to monkey patch individual class methods,
    and in some cases, patch the standard library. Go only offers us the ability to
    patch variables, which can be objects or functions, as we will see in this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: Advantages of monkey patching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Monkey patching as a form of DI is very different from the other methods presented
    in this book in both implementation and effect. As such, there are some situations
    in which monkey patching is either the only option or the only succinct one. 
    Monkey patching's other advantages are detailed in this section.
  prefs: []
  type: TYPE_NORMAL
- en: '**DI via monkey patching is cheap to implement**—In this book, we have talked
    a lot about decoupling, which is the idea that separate pieces of our code should
    be kept separate, even though they use/depend on each other. We introduce abstractions
    and inject them into each other. Let''s step back for a moment and consider why
    we want the code decoupled in the first place. It''s not only about making it
    easier to test. It''s also about allowing the code to evolve separately and provide
    us with small groups, mental boxes if you will, with which we can think about
    different parts of the code individually. It is this decoupling or separation
    with which monkey patching can be applied.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'How do we decouple this function from the operating system? Let me put it a
    different way: how do we test how this function behaves when the file is missing?'
  prefs: []
  type: TYPE_NORMAL
- en: We could replace the filename with `*os.File` or `io.Writer`, but that just
    pushes the problem somewhere else. We could refactor this function into a struct,
    change the call to `ioutil.WriteFile` into an abstraction, and then mock it. But
    that sounds like a lot of work.
  prefs: []
  type: TYPE_NORMAL
- en: 'With monkey patching, there is a far cheaper option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: With one line, we have given ourselves the ability to replace `writeFile()`
    with a mock that will allow us to test both happy path and error scenarios with
    ease.
  prefs: []
  type: TYPE_NORMAL
- en: '**Allows us to mock other packages, without fully understanding its internals**—In
    the previous example, you may have noticed that we are mocking a standard library
    function. Do you know how to make `ioutil.WriteFile()` fail? Sure, we could go
    rooting around in the standard library; while that''s a great way to improve your
    Go skills, it''s not what we get paid for. How `ioutil.WriteFile()` could fail
    is not even significant in this case. What is actually important is how our code
    reacts to errors.'
  prefs: []
  type: TYPE_NORMAL
- en: Monkey patching, like other forms of mocking, offers us the ability to not care
    about the internals of the dependency and yet be able to get it to behave as we
    need it to.
  prefs: []
  type: TYPE_NORMAL
- en: I propose that testing *from the outside* is the way to go anyway. Decoupling
    how we think about the dependency ensures that any tests have less knowledge of
    the internals and are not therefore susceptible to changes in implementation or
    environment. Should any changes occur to the internal implementation details of
    `io.WriteFile()`, they cannot break our tests. Our tests are only dependent on
    our code, so their reliability is entirely on us.
  prefs: []
  type: TYPE_NORMAL
- en: '**DI via monkey patching has minimal impact on existing code**—In the previous
    example, we defined the external dependency as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s change this slightly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Does this remind you of anything? In this version, we are explicitly defining
    our requirements, just like we did in the *Dependency inversion principle* section
    in [Chapter 2](53a15217-38a7-4622-9242-a57fe46335ec.xhtml), *SOLID Design Principles
    for Go*. While this change is entirely superfluous, it does raise some interesting
    questions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s double back and examine what kinds of changes we would have to make
    to test our method without monkey patching. The first option would be injecting
    `io.WriteFile` into the function, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: What is wrong with that? Personally, I have three problems with it. Firstly,
    this is a small, simple function with only one dependency; the function would
    get really ugly really quickly if we had more dependencies. To put it another
    way, the code UX is terrible.
  prefs: []
  type: TYPE_NORMAL
- en: Secondly, it breaks the encapsulation (information hiding) of the implementation
    of the function. This might feel like I am taking up a zealot-like argument, but
    I don't think of it this way. Imagine what happens if we refactor the implementation
    of our `SaveConfig()` such that we need to change `io.WriteFile` to something
    else. In that situation, we would have to change every use of our function, potentially
    a lot of changes and therefore a lot of risk.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, this change is arguably test-induced damage, as we discussed in the *Test-induced
    damage* section of [Chapter 3](26893ac5-a588-4954-943e-0eaf690feb34.xhtml), *Coding
    for User Experience*, as it is a change that only serves to improve testing and
    does not enhance the non-test code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another option that might come to mind is to refactor our function into an
    object and then use a more traditional form of DI, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Sadly, this refactor suffers from similar issues as the previous one, not least
    of which is that it has the potential to be a considerable amount of changes.
    As you can see, monkey patching required significantly fewer changes than traditional
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: '**DI via monkey patching allows testing of globals and singletons**—You probably
    think I am crazy, Go doesn''t have singletons. Perhaps not in the strictest sense,
    but have you ever read the code for the `math/rand` standard library package ([https://godoc.org/math/rand](https://godoc.org/math/rand))?
    In it, you will find the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: How would you test the `Rand` struct? You could swap the `Source` with a mock
    that returned a predictable, non-random result, easy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, how would you test the convenience function `Int()`? It''s not so easy.
    This method, by definition, returns a random value. With monkey patching, however,
    we can, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: With monkey patching, we are able to test the usage of the singleton without
    any changes to the client code. To achieve this with other methods, we would have
    to introduce a layer of indirection, which in turn would necessitate changes to
    the client code.
  prefs: []
  type: TYPE_NORMAL
- en: Applying monkey patching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s apply monkey patching to our ACME registration service that we introduced
    in [Chapter 4](9b5a6d56-9d43-4a12-a580-6ca8b13b9201.xhtml), *Introduction to ACME
    Registration Service*. One of the many things we would like to improve with our
    service is the test reliability and coverage. In this case, we will be working
    on the `data` package. Currently, we only have one test, and it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In this test, we are performing a save and then loading the newly saved registration
    back using both the `Load()` and `LoadAll()` methods.
  prefs: []
  type: TYPE_NORMAL
- en: This code has at least three major issues.
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, we are only testing the *happy path*; we have not tested our error
    handling at all.
  prefs: []
  type: TYPE_NORMAL
- en: Secondly, the test relies on the database. Some people will argue this is fine,
    and I do not want to add to that debate. In this particular case, the use of a
    live database causes our test of `LoadAll()` to be not very specific, which makes
    our tests less thorough than they could be.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, we are testing all the functions together, rather than in isolation. Consider
    what happens when the following part of the test fails:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Where is the problem? Is `Load()` broken or is `Save()` broken? This is the
    basis for the argument regarding testing in isolation.
  prefs: []
  type: TYPE_NORMAL
- en: All of the functions in the `data` package depend on a global instance of `*sql.DB`,
    which represents a pool of database connections. We therefore will be monkey patching
    that global variable and introducing a mocked version.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing SQLMock
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The SQLMock package ([https://github.com/DATA-DOG/go-sqlmock](https://github.com/DATA-DOG/go-sqlmock))
    describes itself as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '"A mock library implementing sql/driver. Which has one and only purpose - to
    simulate any sql driver behavior in tests, without needing a real database connection"'
  prefs: []
  type: TYPE_NORMAL
- en: I find SQLMock useful, but often more work than directly using the database.
    Being a pragmatic programmer, I am happy to use either. Typically, the choice
    of which to use is made based on how I want the tests to work. If I want to be
    very precise, have no potential for issues related to existing contents of the
    table, and have no possibility for data races caused by the concurrent usage of
    the table, then I will spend the extra effort to use SQLMock.
  prefs: []
  type: TYPE_NORMAL
- en: A data race occurs when two or more goroutines access a variable at the same
    time, and at least one of the goroutines is writing to the variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at using SQLMock to test. Consider the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This function takes `*Person` and `*sql.DB` as input, saves the person into
    the database provided, and then returns the ID of the newly created record. This
    function is using a traditional form of DI to pass the database connection pool
    into the function. This allows us an easy way to swap out the real database connection
    with a fake one. Now, let''s build the test. First, we create a mock database
    using SQLMock:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we define the query we are expecting as a regular expression and use
    that to configure the mock database. In this case, we are expecting a single `db.Exec`
    call that returns `2`, the ID of the newly created record, and `1`, the affected
    row:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we call the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'And then, we validate the results and the mock''s expectations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have an idea of how we can leverage SQLMock to test our database
    interactions, let's apply it to our ACME registration code.
  prefs: []
  type: TYPE_NORMAL
- en: Monkey patching with SQLMock
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Firstly, a quick refresher: currently, the `data` package does not use DI,
    and therefore we cannot pass in the `*sql.DB` like we did in the previous example.
    The function currently looks as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We could refactor to this, and perhaps in the future we might, but at the moment
    we have almost no tests on this code and refactoring without tests is a terrible
    idea. You might be thinking something similar to *but if we write tests with monkey
    patching and then refactor to a different style of DI later, then we would have
    to refactor these tests*, and you are right; this example is a little contrived.
    That said, there is nothing wrong with writing tests to provide you with a safety
    net or a high level of confidence now, and then deleting them later. It might
    feel like double work, but it's bound to be both less humiliating than introducing
    regression into a running system that people are relying on, and potentially less
    work that debugging that regression.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing that jumps out is the SQL. We are going to need almost exactly
    the same string in our tests. So, to make it easier to maintain the code in the
    long term, we are going to convert that to a constant and move it to the top of
    the file. As the test is going to be quite similar to our previous example, let''s
    first examine just the monkey patching. From the previous example, we have the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In these lines, we are creating a test instance of `*sql.DB` and a mock to control
    it. Before we can monkey patch our test instance of `*sql.DB`, we first need to
    create a backup of the original one so that we can restore it after the test is
    complete. To do this, we are going to use the `defer` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: 'For those not familiar with it, `defer` is a function that is run just before
    the current function exits, that is, between executing the `return` statement
    and returning control to the caller of the current function. Another significant
    feature of `defer` is the fact that the arguments are evaluated immediately. The
    combination of these two features allows us to take a copy of the original `sql.DB`
    when `defer` is evaluated and not worry about how or when the current function
    exits, saving us from potentially a lot of copying and pasting of *clean up* code.
    This code looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'With this done, the test looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Fantastic, we have our happy path test done. Unfortunately, we've only tested
    7 out of 13 lines of our function; perhaps more importantly, we don't know whether
    our error handling code even works correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Testing error handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are three possible errors we need to handle:'
  prefs: []
  type: TYPE_NORMAL
- en: The SQL insert could fail
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Failure to get the database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We could fail to retrieve the ID of the inserted record
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, how do we test for SQL insert failure? With SQLMock it''s easy: we make
    a copy of the previous test and instead of returning `sql.Result`, we return an
    error, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then change our expectations from a result to an error, as shown in
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Moving on to testing *failure to get the database*, this time SQLMock can''t
    help us, but monkey patching can. Currently, our `getDB()` function looks as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s change the function to a variable, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We have not otherwise changed the implementation of the function. We can now
    monkey patch that variable and the resulting test looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed a high amount of duplication between the happy path and
    error path tests. This is somewhat common in Go tests and is perhaps driven by
    the fact that we are intentionally calling a function repeatedly with different
    inputs or environments, essentially documenting and enforcing a contract of behavior
    for the object we are testing.
  prefs: []
  type: TYPE_NORMAL
- en: Given these fundamental responsibilities, we should be looking to ensure that
    our tests are both easy to read and maintain. To achieve these goals we can apply
    one of my favorite features in Go, table-driven tests ([https://github.com/golang/go/wiki/TableDrivenTests](https://github.com/golang/go/wiki/TableDrivenTests)).
  prefs: []
  type: TYPE_NORMAL
- en: Reducing test bloat with table-driven tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With table-driven tests, we define a slice of scenarios (often the function
    inputs, mock configuration, and our expectations) at the start of the test and
    then a scenario runner, which is typically part of the test that would otherwise
    have been duplicated. Let''s see what this looks like as an example. The happy
    path test for the `Load()` function looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This function has about 11 functional lines (after removing the formatting),
    of which approximately 9 would be almost identical in our test for SQL load failure.
    Converting this to a table-driven test gives us this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Sorry, there''s a lot going on there, so let''s break this into its separate
    parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'These lines define a slice and an anonymous struct that will be our list of
    scenarios. In this case, our scenario contains the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**A description**: This is useful for adding to test error messages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mock configuration**: As we are testing how our code reacts to different
    responses from the database, this is where most of the magic happens.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**An expected result**: Fairly standard, given the inputs and environment (that
    is, mock configuration). This is what we want to get back.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A Boolean to indicate whether we expect an error**: We could use an error
    value here; it would be more precise. However, I prefer to use a custom error,
    which means the output is not constant. I have also found that error messages
    can change over time and therefore the narrowness of the check makes the tests
    brittle. Essentially, I am trading test specificity for durability.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then we have our scenarios, one per test case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now there''s the test runner, which is basically a loop over all the scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The contents of this loop are quite similar to the contents of our original
    test. It's often easier to write the happy path test first and then convert it
    to a table-driven test by adding the additional scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Perhaps the only difference between our test runner and the original function
    is that we are monkey patching. We cannot use `defer` inside a `for` loop as `defer`
    only runs when the function exits; we therefore have to restore the database at
    the end of the loop instead.
  prefs: []
  type: TYPE_NORMAL
- en: The use of table-driven tests here not only reduced the duplication in our test
    code, but it also has two other significant advantages. Firstly, it has distilled
    the tests down to inputs equals outputs, making them very easy to understand and
    very easy to add more scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Secondly, the code that is likely to change, namely the function call itself,
    only exists in one place. If that function altered to accept another input or
    return another value, we would have to fix it in one place, compared to once per
    test scenario.
  prefs: []
  type: TYPE_NORMAL
- en: Monkey patching between packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have looked at monkey patching a private global variable or function
    for the purposes of testing inside our `data` package. But what happens if we
    want to test other packages? Wouldn't it be nice to decouple the business logic
    layer from the database too? That would certainly stop our business logic layer
    tests from breaking for unrelated events, such as optimizing our SQL queries.
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, we are faced with a dilemma; we could start large-scale refactoring,
    but as we''ve mentioned before, it''s a lot of work and a lot of risk, especially
    without tests to keep us out of trouble. Let''s look at the most straightforward
    business logic package we have, the `get` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this function does very little beyond loading the person from
    the database. You could argue therefore that it does not need to exist; don't
    worry, we will be giving it more responsibility later on.
  prefs: []
  type: TYPE_NORMAL
- en: So how do we test this without the database? The first thing that comes to mind
    might be to monkey patch the database pool or the `getDatabase()` function as
    we did before.
  prefs: []
  type: TYPE_NORMAL
- en: This would work, but it would be sloppy and pollute the public API for the `data`
    package with things that we don't want production code using, the very definition
    of test-induced damage. It would also do nothing to decouple this package from
    the internal implementation of the `data` package. In fact, it would make it worse.
    Any change to the implementation of the `data` package would likely break our
    test for this package.
  prefs: []
  type: TYPE_NORMAL
- en: Another aspect to consider is that we can make any alteration we want because
    the service is small and we own all the code. This is often not the case; the
    package could be owned by another team, it could be part of an external dependency,
    or even part of the standard library. It's better, therefore, to get into the
    habit of keeping our changes local to the package we are working on.
  prefs: []
  type: TYPE_NORMAL
- en: 'With that in mind, we can adopt a trick we looked at briefly in the previous
    section, *Advantages of monkey patching*. Let''s intercept the call from the `get`
    package to the `data` package, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can intercept the calls with monkey patching, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Now, our test is not dependent on the database or any internal implementation
    details of the `data` package. While we have not entirely decoupled the packages,
    we have significantly reduced the number of things that must happen correctly
    for the tests in the `get` package to pass. This is arguably one of the points
    of DI by monkey patching, reducing the ways tests could break by reducing the
    dependence on outside factors and increasing the focus of the tests.
  prefs: []
  type: TYPE_NORMAL
- en: When the magic fades
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Earlier in the book, I challenged you to examine each method of DI presented
    in the book with a critical eye. With that in mind, we should consider the potential
    costs of monkey patching.
  prefs: []
  type: TYPE_NORMAL
- en: '**Data races**—We saw in our examples that monkey patching is the process of
    replacing a global variable with a copy that performs in the way we need it to
    for a particular test. And that is perhaps the biggest problem. Swapping something
    global, and therefore shared, for something specific causes a data race on that
    variable.'
  prefs: []
  type: TYPE_NORMAL
- en: To understand this data race a little more, we need to understand how Go runs
    tests. By default, tests within a package are executed sequentially. We can reduce
    our test execution time by marking our tests with `t.Parallel()`. With our current
    tests of the `data` package, marking the test as parallel would cause the data
    race to appear, resulting in unpredictable tests.
  prefs: []
  type: TYPE_NORMAL
- en: Another significant feature of Go testing is that Go executes multiple packages
    in parallel. Like `t.Parallel()`, this can be fantastic for our test execution
    time. With our current code, we are safe from this because we only monkey patched
    within the same package as the tests. If we had monkey patched across package
    boundaries, then the data race would appear.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your tests are flaky and you suspect a data race, you can try Go''s built-in
    race detection ([https://golang.org/doc/articles/race_detector.html](https://golang.org/doc/articles/race_detector.html))
    with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'If that doesn''t find the problem, you can try running all the tests sequentially
    with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: If the tests start passing consistently, then you will need to start digging
    for data races.
  prefs: []
  type: TYPE_NORMAL
- en: '**Verbose tests**—As you have seen in our tests, the code to monkey patch and
    restore can become rather lengthy. With a little bit of refactoring, it is possible
    to lessen the boilerplate. For example, look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We could change it to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: After this refactoring, we have far less duplication in the tests, resulting
    in less to maintain, but more importantly, the tests are no longer overshadowed
    by all of the monkey-patching-related code.
  prefs: []
  type: TYPE_NORMAL
- en: '**Obfuscated dependency relationship**—This is not a problem with monkey patching
    itself but with the style of dependency management in general. In traditional
    DI, the dependency is passed in as a parameter, making the relationship explicit
    and visible.'
  prefs: []
  type: TYPE_NORMAL
- en: From a user perspective, this lack of parameters can be considered an improvement
    to the UX of the code; after all, fewer inputs typically makes a function easier
    to use. However, when it comes to testing, things get messy quickly.
  prefs: []
  type: TYPE_NORMAL
- en: In our previous example, the `SaveConfig()` function depends on `ioutil.WriteFile()`
    and so mocking that dependency to test `SaveConfig()` seems reasonable. However,
    what happens when we need to test a function that calls `SaveConfig()`?
  prefs: []
  type: TYPE_NORMAL
- en: How does the user of `SaveConfig()` know that they need to mock `ioutil.WriteFile()`?
  prefs: []
  type: TYPE_NORMAL
- en: Because the relationship is muddled, the knowledge required increases and, incidentally,
    so does the test length; it isn't long before we have half a screen of monkey
    patching of functions at the beginning of every test.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned how to leverage monkey patching to *swap out* dependencies
    in our tests. With monkey patching, we have tested globals, decoupled packages,
    and removed our dependence on external resources such as databases and the filesystem.
    We've worked through some practical examples while improving our sample service's
    code, and we frankly discussed both the advantages and disadvantages of using
    monkey patching.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at the second and perhaps the most traditional
    DI technique, dependency injection with constructor injection. With it, we will
    improve our service's code even further.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How does monkey patching work?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the ideal use cases for monkey patching?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you use monkey patching to decouple two packages without changing the
    dependency package?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Packt has many other great resources for learning about monkey patching:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Mastering JQuery**: [https://www.packtpub.com/mapt/book/web_development/9781785882166/12/ch12lvl1sec100/monkey-patching](https://www.packtpub.com/mapt/book/web_development/9781785882166/12/ch12lvl1sec100/monkey-patching)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Learn to code with Ruby**: [https://www.packtpub.com/mapt/video/application_development/9781788834063/40761/41000/monkey-patching-ii](https://www.packtpub.com/mapt/video/application_development/9781788834063/40761/41000/monkey-patching-ii)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
