- en: Going Offline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Users expect applications to operate seamlessly with unreliable network connections.
    If your mobile application can't cope with transient network issues, then your
    users will use a different app. When there's no network, you have to persist data
    locally on the device. Or, perhaps your app doesn't even require network access,
    in which case you'll still need to store data locally.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you'll learn how to do the following three things with React
    Native. First, you'll learn how to detect the state of the network connection.
    Second, you'll learn how to store data locally. Lastly, you'll learn how to synchronize
    local data that's been stored due to network problems, once it comes back online.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting the state of the network
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If your code tries to make a request over the network while disconnected, using
    `fetch()`, for example, an error will occur. You probably have error-handling
    code in place for these scenarios already, since the server could return some
    other type of error. However, in the case of connectivity trouble, you might want
    to detect this issue before the user attempts to make network requests.
  prefs: []
  type: TYPE_NORMAL
- en: There are two potential reasons for proactively detecting the network state.
    You might display a friendly message to the user stating that, since the network
    is disconnected, they can't do anything. You would then prevent the user from
    performing any network requests until you detect that it's back online. The other
    possible benefit of early network state detection is that you can prepare to perform
    actions offline and sync the app state when the network is connected again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at some code that uses the `NetInfo` utility to handle changes
    in network state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This component will render the state of the network, based on the string values
    in `connectedMap`. The `connectionChange` event of the `NetInfo` object will cause
    the `connected` state to change. For example, when you first run this app, the
    screen might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/ad3ce214-c944-440d-b018-3990874045c1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, if you turn off networking on your host machine, the network state will
    change on the emulated device as well, causing the state of our application to
    change as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/1d263789-b1cf-4bb8-9360-5a8336a20e83.png)'
  prefs: []
  type: TYPE_IMG
- en: Storing application data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `AsyncStorage` API works the same on both the iOS and Android platforms.
    You would use this API for applications that don't require any network connectivity
    in the first place, or to store data that's eventually synchronized using an API
    endpoint once a network becomes available.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at some code that allows the user to enter a key and a value, and
    then stores them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Before I walk through what this code is doing, let''s first take a look at
    the following screen, since it''ll provide most of the explanation you need:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/384aaa8d-0697-45d0-9947-2d6832a0b200.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, there are two input fields and two buttons. The fields allow
    the user to enter a new key and value. The Add button allows the user to store
    this key-value pair locally on their device, while the Clear button clears any
    existing items that have been stored previously.
  prefs: []
  type: TYPE_NORMAL
- en: The `AsyncStorage` API works the same for both iOS and Android. Under the hood,
    `AsyncStorage` works very differently depending on which platform it's running
    on. The reason React Native is able to expose the same storage API on both platforms
    is due to its simplicity—it's just key-value pairs. Anything more complex than
    that is left up to the application developer.
  prefs: []
  type: TYPE_NORMAL
- en: The abstractions that you've created around `AsyncStorage` in this example are
    minimal. The idea is to set and get items. However, even straightforward actions
    like this deserve an abstraction layer. For example, the `setItem()` method you've
    implemented here will make the asynchronous call to `AsyncStorage` and update
    the `items` state once that has completed. Loading items is even more complicated
    because you need to get the keys and values as two separate asynchronous operations.
  prefs: []
  type: TYPE_NORMAL
- en: The reason is to keep the UI responsive. If there are pending screen repaints
    that need to happen while data is being written to disk, preventing those from
    happening by blocking them would lead to a sub-optimal user experience.
  prefs: []
  type: TYPE_NORMAL
- en: Synchronizing application data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far in this chapter, you've learned how to detect the state of a network
    connection, and how to store data locally in a React Native application. Now it's
    time to combine these two concepts and implement an app that can detect network
    outages and continue to function.
  prefs: []
  type: TYPE_NORMAL
- en: The basic idea is to only make network requests when you know for sure that
    the device is online. If you know that it isn't, you can store any changes in
    state locally. Then, when you're back online, you can synchronize those stored
    changes with the remote API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s implement a simplified React Native app that does this. The first step
    is implementing an abstraction that sits between the React components and the
    network calls that store data. We''ll call this module `store.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This module exports two functions—`set()` and `get()`. Their jobs are to set
    and get data, respectively. Since this is just a demonstration of how to sync
    between local storage and network endpoints, this module just mocks the actual
    network with the `fakeNetworkData` object.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by looking at the `set()` function. It's an asynchronous function
    that will always return a promise that resolves to a Boolean value. If it's true,
    it means that you're online, and that the call over the network was successful.
    If it's false, it means that you're offline, and `AsyncStorage` was used to save
    the data.
  prefs: []
  type: TYPE_NORMAL
- en: The same approach is used with the `get()` function. It returns a promise that
    resolves a Boolean value that indicates the state of the network. If a key argument
    is provided, then the value for that key is looked up. Otherwise, all values are
    returned, either from the network or from `AsyncStorage`.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to these two functions, this module does two other things. It uses
    `NetInfo.getConnectionInfo()` to set the `connected` state. Then, it adds a listener
    for changes in the network state. This is how items that have been saved locally
    when you're offline become synced with the network when it's connected again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s check out the main application that uses these functions as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The job of the `App` component is to save the state of three checkboxes, which
    is difficult when you're providing the user with a seamless transition between
    online and offline modes. Thankfully, your `set()` and `get()` abstractions, implemented
    in another module, hide most of the details from the application functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will notice, however, that you need to check the state of the network in
    this module before you attempt to load any items. If you don''t do this, then
    the `get()` function will assume that you''re offline, even if the connection
    is fine. Here''s what the app looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/03d50c1c-606b-4b1b-a8d3-a74aee4df357.png)'
  prefs: []
  type: TYPE_IMG
- en: Note that you won't actually see the Saved Offline message until you change
    something in the UI.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter introduced you to storing data offline in React Native applications.
    The main reason you would want to store data locally is when the device goes offline
    and your app can't communicate with a remote API. However, not all applications
    require API calls and `AsyncStorage` can be used as a general purpose storage
    mechanism. You just need to implement the appropriate abstractions around it.
  prefs: []
  type: TYPE_NORMAL
- en: You learned how to detect changes in network state in React Native apps as well.
    It's important to know when the device has gone offline so that your storage layer
    doesn't make pointless attempts at network calls. Instead, you can let the user
    know that the device is offline, and then synchronize the application state when
    a connection is available.
  prefs: []
  type: TYPE_NORMAL
- en: That wraps up the second part of this book. You've seen how to build React components
    for the Web, and React components for mobile platforms. At the beginning of this
    book, I posited that the beauty of React lies in the notion of rendering targets.
    The declarative programming interface of React never has to change. The underlying
    mechanisms that translate JSX elements are completely replaceable—in theory, you
    can render React to anything.
  prefs: []
  type: TYPE_NORMAL
- en: In the final part of this book, I'll talk about state in React applications.
    State and the policies that govern how it flows through an application can make
    or break the React architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Test your knowledge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Why are operations in the `AsyncStorage` API asynchronous?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: So that you can perform lots of storage operations concurrently.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To avoid interfering with the responsiveness of the UI.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: They're not asynchronous operations, they're just returning promises to be consistent
    with other storage APIs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which `AsyncStorage` API would you use to look up several items at once?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`AsyncStorage.getAll()`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`AsyncStorage.filter()`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A combination of `AsyncStorage.getAllKeys()` and `AsyncStorage.multiGet()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you get the connectivity status of the device in a React Native application?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You call `NetInfo.getConnectionInfo()` and read the resulting connection type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You call `NetInfo.getConnectionInfo()` and if it returns true, you're connected.
    Otherwise, you're offline.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There's a global `reactNativeConnectionInfo` object that you can read from at
    any point to determine the status of the connection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you respond to a change in connectivity status in a React Native application?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There's no way to respond to connectivity status changes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can listen to the `connectionChange` event by calling `NetInfo.addEventListener('connectionChange',
    ...)`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can provide a callback function to the `NetInfo.onChange()` API.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Visit the following links for more information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://facebook.github.io/react-native/docs/asyncstorage](https://facebook.github.io/react-native/docs/asyncstorage)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://facebook.github.io/react-native/docs/netinfo](https://facebook.github.io/react-native/docs/netinfo)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
