- en: Deploying and Operating GCP Networking Resources with Ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Google Cloud is one of the big players in the public cloud and it provides a
    comprehensive set of services and features on its **Google Cloud Platform** (**GCP**)
    cloud. In this chapter, we will explore how to automate the provisioning of resources
    on the GCP cloud using Ansible and how to use the various Ansible modules to orchestrate
    the building of virtual networks across the GCP cloud.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will use a simple network setup to illustrate the use of
    different Ansible modules in building an example network across GCP. The following
    diagram outlines this sample network that we will build:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/910e0c04-0d37-4c3e-a965-7e793b6ba1be.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This chapter will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Installing the GCP SDK
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building an Ansible inventory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authenticating to your GCP account
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating GCP VPC networks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating subnets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying firewall rules in GCP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying VMs in GCP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adjusting routing within a VPC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validating GCP deployment using Ansible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decommissioning GCP resources using Ansible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to start working with GCP, we need to create an account. You can set
    up a free GCP account at [https://cloud.google.com/free/](https://cloud.google.com/free/).
  prefs: []
  type: TYPE_NORMAL
- en: The GitHub code used in this chapter can be found at [https://github.com/PacktPublishing/Network-Automation-Cookbook/tree/master/ch9_gcp](https://github.com/PacktPublishing/Network-Automation-Cookbook/tree/master/ch9_gcp).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the software releases that this chapter is based on:'
  prefs: []
  type: TYPE_NORMAL
- en: CentOS 7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ansible 2.9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python 3.6.8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Check out the following video to see the Code in Action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://bit.ly/3erVlSN](https://bit.ly/3erVlSN)'
  prefs: []
  type: TYPE_NORMAL
- en: Installing the GCP SDK
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will outline how to install the required Python libraries
    needed to start interacting with the GCP orchestration system using Ansible. This
    step is mandatory since the required Python libraries must be installed on the
    Ansible control machine in order for all the Ansible GCP modules to work.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You need to have `sudo` access on the machine in order to install the GCP Python
    libraries. You also need to have Python installed and the Python pip package,
    which we will use to install the GCP package.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Install the `requests` package as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Install the Google authentication package as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new folder called `ch9_gcp` to host all the code for this chapter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The default installation of Ansible doesn’t include all the required Python
    modules needed to execute the GCP cloud modules. In this recipe, we installed
    the two required Python packages that are needed by all GCP modules. The first
    package is the `requests` package, which is used mainly to invoke REST API calls
    to the Google orchestration system, and the other package is the `google-auth`
    package to authenticate against the API.
  prefs: []
  type: TYPE_NORMAL
- en: See also...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For more information regarding how to start interacting with GCP using Ansible,
    please refer to [https://docs.ansible.com/ansible/latest/scenario_guides/guide_gce.html](https://docs.ansible.com/ansible/latest/scenario_guides/guide_gce.html).
  prefs: []
  type: TYPE_NORMAL
- en: Building an Ansible inventory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will outline how to build an Ansible inventory to describe
    the network infrastructure setup that we will build across the GCP public cloud.
    This is a mandatory step that we need to take in order to define all our VPC networks
    across all the regions that we will deploy our infrastructure in.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create the `hosts` file inside the `ch9_gcp` directory with the following data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the `ansible.cfg` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the `group_vars` folder and the `gcp_vpc.yml`, which will host all the
    variables that define our infrastructure in this VPC:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the `roles` directory within our main folder (`ch9_gcp`). This folder
    will include all the roles that we will use to create our GCP infrastructure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We created the `hosts` Ansible inventory file and we declared all the VPCs that
    we will provision in the GCP cloud. We have a single VPC in our sample setup,
    so we created a single group called the `gcp_vpc`, which includes our VPC (`demo_gcp_vpc`).
  prefs: []
  type: TYPE_NORMAL
- en: We created the `group_vars/gcp_vpc.yml` file, which will house all the variables
    that we will declare to define our infrastructure in this VPC.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this time, our directory layout is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Authenticating to your GCP account
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will outline how to create the required credentials to programmatically
    authenticate to our GCP account from Ansible. This is a mandatory step that you
    need to take in order to be able to run any Ansible module in the following recipes.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Ansible controller must have internet access. In addition, the user performing
    these steps must have administrative access to the GCP console in order to create
    the required resources to enable programmatic interaction with the GCP APIs.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Log in to GCP Console with an administrative account.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From the main console, choose IAM & admin | Manage Resources. Create a new
    project within GCP that will house all the infrastructure that we will build in
    GCP:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/1b91a110-bc79-4a46-b76b-fdcd84ccda23.png)'
  prefs: []
  type: TYPE_IMG
- en: 'From the main console, go to IAM & admin | Service accounts:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/9bfee5ee-1ba7-4c43-9483-99c695d42552.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Create a New Service account for a new Ansible user:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/80d7aaaa-3f81-461c-a8bb-7a92cd076ea2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Assign the appropriate role to this new service account so that you can create/edit/delete
    the resources in this GCP project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/cc8950c4-cabc-44dd-b85e-72b808026853.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Create and download the private key that will be used to authenticate this
    user:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/3d5de4dd-7de0-4b64-b77c-2f24cd4c203f.png)'
  prefs: []
  type: TYPE_IMG
- en: Copy the downloaded JSON key file to the project directory `ch9_gcp` and rename
    it as `gcp_ansible_secret.json`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'On the GCP console, select API & Services and enable the Google Compute Engine
    API for the current project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/321bf2ae-6fb7-406f-b41c-1190a4844803.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to have programmatic access to the GCP API (this is how Ansible communicates
    with the GCP cloud to provision resources), we need to create a special account
    called a service account within our GCP project. This service account is similar
    to a user, but with only API access to the GCP project. We created this service
    account and called it Ansible, and we provided it with the Project Owner role
    in order to have full privilege to create resources within the GCP project (in
    production, a more restrictive role should be assigned to this service account).
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to authenticate to the GCP API using this service account, GCP provided
    us with a JSON file that has the identification information for this account.
    The main parameters included in this JSON file are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The private SSH key for this service account
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The type of this account
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Project_id`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Client_id`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`client_email`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We save this JSON file and copy it to our directory, since we will refer to
    it in all our playbooks in order to provision the resources on the GCP cloud.
    The final step is to enable the API in our GCP project; we need to enable the
    GCP compute engine API in order to start interacting with this API since, by default,
    the API access is disabled within the GCP project.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The JSON file that holds all the identification information to authenticate
    the GCP API again is a critical file that should be secured, and so we are going
    to use an Ansible vault in order to secure this file.
  prefs: []
  type: TYPE_NORMAL
- en: 'We create a new file called `vault_pass`, which holds our Ansible vault password
    and we update our `ansible.cfg` file to point to it, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We encrypt the JSON file using Ansible vault, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: At this stage, we have our JSON file secure and all its contents encrypted using
    the password declared in the `vault_pass` file.
  prefs: []
  type: TYPE_NORMAL
- en: See also...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For more information regarding how to create a new service account in GCP, go
    to [https://cloud.google.com/iam/docs/creating-managing-service-accounts](https://cloud.google.com/iam/docs/creating-managing-service-accounts).
  prefs: []
  type: TYPE_NORMAL
- en: Creating GCP VPC networks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the GCP, VPCs are the main networking construct that are used to group all
    our resources. We can think of them as a virtual data center in the cloud. We
    need to define our VPCs in order to prepare our cloud environment to host our
    applications. In this recipe, we will outline how to define and provision a VPC
    in GCP.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Ansible control machine must be connected to the internet with reachability
    to GCP public API endpoints, and the GCP account should be configured as outlined
    in the previous recipes.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new YAML file called `gcp_account_info.yml` and include the following
    data for our GCP login parameters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new Ansible role called `gcp_net_build`, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the `gcp_net_build/tasks/main.yml` file with the following task to create
    our VPC:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the `group_vars` folder and create the `gcp_vpc.yml` file with the following
    data for the VPC:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the `pb_gcp_env_build.yml` playbook with the following task to read
    the vault-encrypted JSON file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the `pb_gcp_env_build.yml` playbook with the following task to create
    the required VPCs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the playbook with the following handlers to delete the temporary JSON
    credentials file, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we created and deployed the GCP VPC in the project that we created
    previously. We used an Ansible role in order to build all the components of the
    GCP network, and the first task was to create the VPC using the Ansible module
    `gcp_compute_network`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to use any Ansible GCP module, we needed to authenticate every API
    call triggered by each module and we needed to provide the following information
    in order to authenticate the API calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Auth_kind`: The type of authentication—in our case, `serviceaccount`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Project`: This is the project name for the current project that we created.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Service_account_file`: This is the JSON file that we downloaded when we created
    the service account.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since we are using an Ansible vault in order to encrypt all the contents of
    the JSON file that holds all the authentication information, we needed to decrypt
    this file during playbook execution in order to use the data within this file.
    Furthermore, since we are not directly reading the contents of this JSON file
    but rather pointing to it using the `serivce_account_file` parameter in all our
    GCP Ansible modules, we created a task to read the contents of this JSON file
    using the `lookup` module and store this data in a temporary file. With this approach,
    we can read the encrypted data in this JSON file and create a new temporary JSON
    file with the data in plaintext. We can also use this temporary JSON file as the
    input to `service_account_file`. We used a handler task in order to delete this
    temporary file at the end of the play. On the play level, we used `force_handlers`
    in order to ensure the run of all the tasks within the handler section, even if
    any of the tasks within our play fails. This means that we are sure that the plaintext
    JSON file that holds our credentials is always deleted.
  prefs: []
  type: TYPE_NORMAL
- en: 'We grouped all the preceding parameters and placed them in the `gcp_account_info.yml`
    file, and we included this file in our playbook. We created the VPC using the
    `gcp_compute_network` module and we supplied the following information in order
    to deploy the VPC:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Name`: The name of our new VPC.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Auto_create_subnetwork`: Set it to `no`, since we want to create a custom
    VPC network, not an auto-mode VPC network.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Routing_config`: Set it to `Regional` in order to stop route propagation between
    subnets in different regions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One clear point that we need to highlight is that VPCs within GCP have a global
    scope, which means that they are not bound to a specific region, but span all
    the regions in the GCP cloud. The subnets, on the other hand, are region-specific;
    however, since we created a custom VPC, no subnets are created by default in any
    region, and we have complete control over where to define our subnets. This logic
    is different when we compare it with AWS and GCP in terms of VPC scope.
  prefs: []
  type: TYPE_NORMAL
- en: When creating the VPC using the `gcp_compute_network` module, we must supply
    the VPC name. In this task, we used the `regex_replace` Ansible filter in order
    to make sure that the VPC name doesn’t contain the underscore character (`_`),
    since it is not a valid character in the VPC name. We use this filter to replace
    any occurrence of the underscore with the dash (`-`) in order to make sure that
    the VPC name is compliant with GCP VPC naming standards.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we run our playbook with this single task, we can see that the VPC is
    created, as seen on the GCP console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/bd8f757e-a201-4e5c-baef-9804eab8465b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following snippet outlines the parameters returned by the Ansible module
    after creating the VPC:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This information is important, and we will use it in subsequent recipes in order
    to create subnets so that we can register the output of this task in the `gcp_vpc`
    variable in order to be able to refer to it in later tasks.
  prefs: []
  type: TYPE_NORMAL
- en: There is more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By default, when we create a new project in GCP, an auto-mode VPC is created
    for this project named `default`. It is recommended that we delete this default
    network since we will rely on our custom VPC to house all of our compute workload.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see in our project that this default VPC is present and it has subnets
    in each region across the GCP cloud, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/6d052d97-7467-4efa-83b1-c6e5304e3e78.png)'
  prefs: []
  type: TYPE_IMG
- en: I have created a playbook called `pb_gcp_delete_default_vpc.yml` to delete this
    default VPC and all the default firewall rules attached to it.
  prefs: []
  type: TYPE_NORMAL
- en: See also...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For more information regarding the GCP Virtual Private Cloud module in Ansible
    and all the other parameters supported by this module, go to [https://docs.ansible.com/ansible/latest/modules/gcp_compute_network_module.html#gcp-compute-network-module](https://docs.ansible.com/ansible/latest/modules/gcp_compute_network_module.html#gcp-compute-network-module).
  prefs: []
  type: TYPE_NORMAL
- en: Creating subnets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We segregate our GCP VPCs using subnets, which is the tool that allows us to
    place our compute workload into a specific region. Furthermore, subnets provide
    us with the tool to segregate our virtual network into distinct routing and security
    domains that we can control in order to provide differentiated routing and security
    behavior within each subnet. In this recipe, we will outline how to define and
    provision subnets within the GCP cloud.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Ansible control machine must be connected to the internet with reachability
    to the GCP public API endpoints and the GCP account should be configured as outlined
    in the previous recipes. Also, the GCP VPC needs to be created as outlined in
    the previous recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Update the `group_vars/gcp_vpc.yml` file with the subnets data, as shown in
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the `gcp_net_build/tasks/main.yml` file with the following task to create
    our subnets:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we created the subnets that we are going to use in our deployment.
    The first thing to notice in our subnet definition is that we defined a region
    for each subnet. This is mandatory since, as we discussed, a subnet in GCP has
    regional scope compared to VPCs, which have global scope. We defined a CIDR range
    for each subnet, along with its name.
  prefs: []
  type: TYPE_NORMAL
- en: 'We used the `gcp_compute_subnet` module in order to create all our subnets.
    We used the same parameters that we discussed before for authentication. To create
    the subnets, we specified the following parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Name`: The name of our subnet.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Region`: The region where this subnet will be deployed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Ip_cidr_range`: The CIDR block for this subnet.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Network`: The reference for our VPC that we want this subnet to be part of.
    We get this parameter from the output of creating the VPC. We supply the `gcp_vpc`
    variable, which is the registered variable from our VPC creation task.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once we run the playbook, we can see that all subnets are created as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/521c81aa-441c-497a-8940-f0ab24a28790.png)'
  prefs: []
  type: TYPE_IMG
- en: See also...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For more information regarding the GCP subnets module in Ansible and all the
    other parameters supported by this module, go to [https://docs.ansible.com/ansible/latest/modules/gcp_compute_subnetwork_module.html](https://docs.ansible.com/ansible/latest/modules/gcp_compute_subnetwork_module.html).
  prefs: []
  type: TYPE_NORMAL
- en: Deploying firewall rules in GCP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GCP provides many tools in order to enforce security within the customer environment
    of the GCP cloud. Firewall rules are one of the most basic security tools supported
    in GCP in order to implement the first level of defense for all the workloads
    within a VPC. In this recipe, we will outline how to define and provision firewall
    rules on the GCP cloud.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Ansible control machine must be connected to the internet with reachability
    to GCP public API endpoints, and the GCP account should be configured as outlined
    in the previous recipes. Also, VPC and subnets should be provisioned as outlined
    in the previous recipes.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Update `group_vars/gcp_vpc.yml` with the following firewall rules to secure
    traffic between the web and DB layers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Update `group_vars/gcp_vpc.yml` with the following firewall rules to secure
    traffic toward the web layer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Update `group_vars/gcp_vpc.yml` with the following firewall rules to allow
    `ssh` to only bastion hosts:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the `roles/gcp_net_build/tasks.main.yml` file with the following task
    to create all the required firewall rules:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The firewall rules in GCP are stateful firewall rules that are applied to hosts
    within the VPC. Firewall rules within GCP can be applied on the ingress or the
    egress direction, and there are some default firewall rules that are defined and
    applied to all hosts within a VPC, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: On the ingress direction, there is a default `deny all` for all traffic destined
    to any host within a new custom VPC.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the egress direction, there is a default `allow all` for all traffic from
    any host within a new custom VPC.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the preceding default rules, and since all the firewall rules are stateful,
    any communication initiated from any host within the VPC to the outside world
    will be allowed; however, any initiated traffic from outside the VPC will be rejected.
  prefs: []
  type: TYPE_NORMAL
- en: 'GCP firewall rules can match traffic based on the following criteria:'
  prefs: []
  type: TYPE_NORMAL
- en: Source/destination IPv4 ranges
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IP protocol numbers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TCP/UDP port numbers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Network tags
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the preceding criteria are quite obvious except for network tags. Network
    tags are special metadata that can be applied to any host within a VPC to identify
    and group these hosts. We can use these network tags in order to use them as match
    criteria in firewall rules, as well as to apply the firewall rules only to a subset
    of our hosts within the VPC.
  prefs: []
  type: TYPE_NORMAL
- en: 'With all this information, we want to implement the following security policy
    on our hosts within our sample network:'
  prefs: []
  type: TYPE_NORMAL
- en: All HTTP/HTTPs traffic should be allowed only to all our web servers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SSH access from outside should be limited to only our bastion hosts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SSH access to our web and DB servers is limited to only bastion hosts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Only allow SQL traffic from the web to DB servers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We defined our firewall rules in a new data structure, `fw_rules`, which is
    a list of all our rules that need to be applied to our VPC. We used the network
    tags in all our policies in order to apply the correct firewall rule to the hosts
    where this rule should be enforced.
  prefs: []
  type: TYPE_NORMAL
- en: We used the Ansible module `gcp_compute_firewall` in order to iterate over all
    the firewall policies and apply them. In this module, we can define the match
    criteria to be either based on source/destination IPv4 address ranges or based
    on source and target network tags. We defined our task so that if a parameter
    is not defined in our firewall rule (for example, source IPv4 ranges), we should
    remove this parameter from the list of parameters supplied to the module. We use
    the `omit` filter in order to accomplish this logic.
  prefs: []
  type: TYPE_NORMAL
- en: All firewall rules within GCP have the priority field, which defines the priority
    of the rule compared to other rules and its precedence in terms of processing.
    Any rule with no specific priority gets the priority value of 1,000\. The default
    firewall rules applied by GCP to the VPC have the priority value of `65535`, so
    any rule we define will have precedence over them. In all our rules, we specify
    the priority value of `10`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we run the following task, we can see that the following rules are applied
    to our VPC, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/379efda5-40a4-47eb-a471-75cdcecdaa58.png)'
  prefs: []
  type: TYPE_IMG
- en: See also...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For more information regarding the GCP firewall modules in Ansible and all the
    other parameters supported by this module, go to [https://docs.ansible.com/ansible/latest/modules/gcp_compute_firewall_module.html](https://docs.ansible.com/ansible/latest/modules/gcp_compute_firewall_module.html).
  prefs: []
  type: TYPE_NORMAL
- en: Deploying VMs in GCP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will outline how to deploy virtual machines (using Google
    Compute Engine) in GCP within our VPCs using the correct subnets that we have
    deployed. We will also assign the correct network tags in order to enforce the
    correct security policy on these machines.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Ansible control machine must be connected to the internet with reachability
    to GCP public API endpoints, and the VPCs, subnets, and firewall rules need to
    be deployed as outlined in the previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Update the `group_vars/gcp_vpc.yml` file to include the required information
    to describe the flavor and OS that we will use on all our VMs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the `group_vars/gcp_vpc.yml` file to include the required information
    that describes our compute nodes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new Ansible role (`gcp_vm_build`) to deploy the VM workload on GCP:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the `gcp_vm_build/tasks/main.yml` file with the following task to create
    the disks for the VMs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the `gcp_vm_build/tasks/main.yml` file with the following task to create
    a VM with no public IP address:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the `gcp_vm_build/tasks/main.yml` file with the following task to create
    a VM with a public IP address:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the `pb_gcp_env_build.yml` playbook with the following task to create
    all the required VMs that we have defined:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As per our example network''s design, we will deploy two web servers and two
    database servers in two different availability zones. Then we will build a bastion
    host in a single AZ since it is only used for management. We defined all our required
    machines in the `compute_nodes` variable and, for each machine, we specified the
    following parameters, which we will use during the provisioning:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Name`: The name of the machine'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Network`: Specifies the subnet in which we will deploy this machine and enforce
    the correct network tag'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Zone`: Specifies the zone in which we want to deploy this machine'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`has_internet`: Signifies whether this machine should get a public IP address'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We created a new role to deploy our compute workload and we defined the following
    main sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Create disk for VMs**: The initial task is to create the disk that will house
    the OS for these machines. We used the `gcp_compute_disk` Ansible module to define
    these disks and we specified the following parameters:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Name`: This is the name of this disk.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Image_source`: Specifies the OS that the machine will run—in our example,
    all our machines will run CentOS.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Zone`: Specifies the availability zone where this disk will be created.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Size_gb`: Specifies the disk size that will be deployed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Create VMs**: After creating the disks, we created the VMs using the `gcp_compute_instance`
    module, which takes the following parameters in order to provision the VM:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Name`: The name of this VM.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Machine_type`: Specifies the instance type that we use for these machines.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Disks`: A dictionary that specifies the disk that we will use with this machine.
    We supply the `gcp_vm_disk` variable, which we obtained when we provisioned the
    disks in the previous task.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Network_interfaces`: A dictionary that specifies which subnet and VPC that
    we need to deploy this instance on. For the VPC, we supply the `gcp_vpc` variable,
    which is the value that we get when we provision the VPC.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Zone`: Specifies which availability zone we will deploy our VM in.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Tags`: Specifies the network tags that we will assign to these VMs. These
    are the same tags that we used in our firewall rules in order to reference our
    compute nodes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On top of the preceding parameters, we have the `access_configs` parameter (which
    is a dictionary), and it is used to specify whether a compute node will get a
    public IP address. If the VM gets a public IP address, we set the name parameter
    in `access_configs` as external NAT and the type parameter as `ONE_TO_ONE_NAT`.
    If the machine doesn't require a public IP address, we omit the `access_configs`
    dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: In our setup, all our web servers and bastion hosts should get a public IP address;
    however, our DB servers shouldn't have direct internet connectivity, and so no
    public IP address should be assigned to them. We differentiated this using the
    `has_internet` parameter in our compute node definition, and we used this parameter
    to choose the correct task to use during the VM provisioning.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we run the playbook with the new role to create the VMs, we will see that
    all the disks for each VM are created, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/cbe1800d-ea8d-42b1-b0fc-e7bc02959f8b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Also, all the VMs are created in the correct subnet, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/db3cc28c-7465-4b14-a4cf-fdcbfa89b0fe.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once our VMs are created with the correct network tags, we can verify that
    our firewall rules are applied only on those VMs that are based on the network
    tags assigned to those VMs. The following snippet outlines the firewall rule `allow-internet-to-anz-web`
    and how it is applied only to web servers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/b9df588b-aaf3-474a-953b-d28d2a153088.png)'
  prefs: []
  type: TYPE_IMG
- en: See also...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For more information regarding the GCP instance and disk modules in Ansible,
    and all the other parameters supported by these modules, please go to the following
    links:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.ansible.com/ansible/2.8/modules/gcp_compute_instance_module.html#gcp-compute-instance-module](https://docs.ansible.com/ansible/2.8/modules/gcp_compute_instance_module.html#gcp-compute-instance-module)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.ansible.com/ansible/latest/modules/gcp_compute_disk_module.html#gcp-compute-disk-module](https://docs.ansible.com/ansible/latest/modules/gcp_compute_disk_module.html#gcp-compute-disk-module)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adjusting routing within a VPC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will outline how to control routing within the GCP VPC to
    enforce custom routing decisions for hosts. This allows us to have full control
    of the routing for our hosts within the VPC.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Ansible control machine must be connected to the internet with reachability
    to GCP public API endpoints and the GCP account should be configured as outlined
    in the previous recipes. In addition, the resource group, virtual networks, and
    subnets should be provisioned as outlined in the previous recipes.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Update the `group_vars/gcp_vpc.yml` file to include the required routing data,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the `pb_gcp_env_build.yml` playbook with the following task to create
    the routes in GCP:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: How it works..
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our example setup, with the current routing and firewall rules, our DB servers
    have no internet connectivity; however, we need to have the ability to access
    the internet from these servers in order to install software or perform patches.
    In order to achieve this goal, we are going to use our bastion hosts as NAT instances
    to provide internet access to our DB servers. In order to achieve this, we need
    to adjust the routing for all the DB servers in our VPC.
  prefs: []
  type: TYPE_NORMAL
- en: 'In GCP, we have a default route that is pointing to our internet gateway in
    the VPC. This default route is present in the VPC and is applied to all the hosts
    within the VPC. The following is the routing table for our VPC:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/27312aab-e7bc-44a6-a936-e265fd6807ea.png)'
  prefs: []
  type: TYPE_IMG
- en: However, because of the firewall rules in place and the fact that all the DB
    servers have no external public IP addresses, the DB servers will not be able
    to access the internet. We need to adjust the routing for the DB servers to point
    to the bastion hosts (which are performing NAT). We also need to leave the original
    default route since this is the main path that is used by our web and bastion
    hosts in order to reach the internet.
  prefs: []
  type: TYPE_NORMAL
- en: 'We defined the custom routes that we need to apply using the `custom_routes`
    list data structure, and we used the `gcp_compute_route` Ansible module to loop
    across this data structure to create all the required routes. We used the network
    tag applied on the DB hosts in order to enforce this route only on the hosts with
    this network tag. Once we run this new task, the updating routing table for the
    VPC is as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/27312aab-e7bc-44a6-a936-e265fd6807ea.png)'
  prefs: []
  type: TYPE_IMG
- en: We can set the next hop for the route to either an IP address or an instance
    identification; however, we used the IP address for simplicity, and in our VM
    definition, we selected a static IP address for our bastion host in order to make
    it easy to reference this IP address in our routing setup.
  prefs: []
  type: TYPE_NORMAL
- en: We created this routing task in the main playbook since we need to have the
    bastion VM provisioned in order to set up the route with the next hop set to its
    IP address. If we created the route before the VM is provisioned, the route will
    be created; however, the task will fail with a warning that the next hop IP address
    for our route is not present.
  prefs: []
  type: TYPE_NORMAL
- en: See also...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For more information regarding the GCP routing modules in Ansible and all the
    other parameters supported by this module, go to [https://docs.ansible.com/ansible/latest/modules/gcp_compute_route_module.html#gcp-compute-route-module](https://docs.ansible.com/ansible/latest/modules/gcp_compute_route_module.html#gcp-compute-route-module).
  prefs: []
  type: TYPE_NORMAL
- en: Validating GCP deployment using Ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ansible provides multiple modules to collect the operational state of the different
    resources that we created in GCP, and we can use these modules to validate the
    current state of our network resources in the GCP cloud. This provides a programmatic
    approach for validating a deployment without the need to log in to the portal
    via the **Graphical User Interface** (**GUI**) to check the status of the different
    components provisioned in GCP. In this recipe, we will outline how to use some
    Ansible modules to validate the network subnets that we have deployed.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Ansible control machine must be connected to the internet with the ability
    to reach GCP public API endpoints, and the GCP account should be configured as
    outlined in the previous recipes.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new `pb_gcp_net_validate.yml` playbook and add the following task
    to collect VPC subnet information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the playbook with the following task to validate the IP prefix provisioned
    on all the deployed subnets:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We created a new playbook that we will use to validate all the subnets that
    we have deployed in our GCP project. Ansible provides multiple modules to collects
    the operational state or facts for the different resources in GCP (subnets, VPC,
    virtual machines, and so on). In this example, we are using the `gcp_compute_subnetwork_facts`
    module in order to collect the subnet facts for our deployment. We registered
    all the data returned by this module in a new variable, `gcp_vpc_subnets`. Finally,
    we used the `assert` module to loop across all our subnet definitions to validate
    whether the IP prefixes provisioned on all these subnets are correct and aligned
    with our design.
  prefs: []
  type: TYPE_NORMAL
- en: We can use the other fact-gathering modules in order to validate the other aspect
    of our deployment and to use the same approach using multiple `assert` statements
    in order to make sure that all the resources deployed are aligned with our design.
  prefs: []
  type: TYPE_NORMAL
- en: See also...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For more information regarding the other GCP fact-gathering modules, please
    visit the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.ansible.com/ansible/2.8/modules/gcp_compute_network_facts_module.html](https://docs.ansible.com/ansible/2.8/modules/gcp_compute_network_facts_module.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.ansible.com/ansible/2.8/modules/gcp_compute_subnetwork_facts_module.html](https://docs.ansible.com/ansible/2.8/modules/gcp_compute_subnetwork_facts_module.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decommissioning GCP resources using Ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Similar to creating resources at scale using automation, we can destroy these
    resources once we decide we don’t need them. We use the same Ansible modules that
    we used to create the resources in GCP in order to destroy these resources.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Ansible control machine must be connected to the internet and be able to
    reach GCP public API endpoints, and the GCP account should be configured as outlined
    in the previous recipes.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new `pb_gcp_env_destroy.yml` playbook and add the following task to
    read the vault-encrypted JSON file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the `pb_gcp_env_destroy.yml` playbook and add the following task to
    collect VPC information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the playbook with the following task to delete all the VMs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the playbook with the following task to delete all the disks that we
    created for all the VMs in our VPC:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the playbook with the following task to delete all the firewall rules
    within our VPC:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the playbook with the following task to delete all the custom routes
    within our VPC:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the playbook with the following task to delete all the subnets within
    our VPC:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the playbook with the following task to delete all the VPCs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We created a new playbook that we will use to destroy all our resources within
    our sample network design. We used the same modules that we utilized to provision
    the resources across the GCP cloud; however, we used the `state: absent` in order
    to delete all these resources.'
  prefs: []
  type: TYPE_NORMAL
- en: The only thing that we need to take care when decommissioning the resources
    is the order by which we delete these resources. We can’t delete any resource
    if there is a dependent resource still active that depends on the resource that
    we are trying to delete. For example, we can’t delete a disk without deleting
    the VM that utilizes this disk first.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we run our playbook, we can see that all the VMs are deleted, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/e1086b33-0b3d-404c-baea-2c7a5a3664a9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Also, all our VPCs and subnets are deleted as well, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/569aa2b4-e3d7-4a16-9401-396c065c9240.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding screenshot shows that there are no local VPC networks in the current
    project.
  prefs: []
  type: TYPE_NORMAL
