- en: Resource Limits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will look at per-process resource limits—what they are,
    and why we require them. We will go on to describe the granularity and the types
    of resource limits, distinguishing between soft and hard limits. Details on how
    a user (or system administrator) can query and set the per-process resource limits
    using appropriate CLI frontends (`ulimit`, `prlimit`) will be covered.
  prefs: []
  type: TYPE_NORMAL
- en: The programming interfaces (APIs)—practically speaking, the key `prlimit(2)`
    system call API—will be covered in detail. Two detailed code examples, querying
    the limits and setting a limit on CPU usage, will give the reader hands-on experience
    of working with resource limits.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, with regard to resource limits, we will cover the following
    topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Necessity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Granularity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Types—soft and hard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The resource limits APIs, with example code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resource limits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A common hack is the **(Distributed) denial-of-service** (**(D)DoS**) attack.
    Here, the malicious attacker attempts to consume, indeed overload, resources on
    the target system to such an extent that the system either crashes, or at the
    very least, becomes completely unresponsive (hung).
  prefs: []
  type: TYPE_NORMAL
- en: Interestingly, on an untuned system, performing this type of attack is quite
    easy; as an example, let's imagine we have shell access (not root, of course,
    but as a regular user) on a server. We could attempt to have it run out of disk
    space (or at least run short) quite easily by manipulating the ubiquitous `dd(1)`
    (disk dump) command. One use of `dd` is to create files of arbitrary lengths.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to create a 1 GB file filled with random content, we could do
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'What if we bump the blocksize (`bs`) value to `1G`, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '`dd` will now attempt to create a file that is 1,024 GB—a terabyte—in size! What
    if we run this line (in a script) in a loop? You get the idea.'
  prefs: []
  type: TYPE_NORMAL
- en: To control resource-usage, Unix (including Linux) has a resource limit, that
    is, an artificial limit imposed upon a resource by the OS.
  prefs: []
  type: TYPE_NORMAL
- en: 'A point to be clear on from the very beginning: these resource limits are on
    a per-process basis and not system-wide globals—more on this in the next section.'
  prefs: []
  type: TYPE_NORMAL
- en: Before diving into more detail, let's continue with our hack example to eat
    up a system's disk space, but this time with the resource limit for the maximum
    size of a file set in place beforehand.
  prefs: []
  type: TYPE_NORMAL
- en: 'The frontend command to view and set resource limits is a built-in shell command
    (these commands are called **bash-builtins**): **`ulimit`**. To query the maximum
    possible size of files written to by the shell process (and its children), we
    set the `-f` option switch to `ulimit`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Okay, it's unlimited. Really? No, unlimited only implies that there is no particular
    limit imposed by the OS. Of course it's finite, limited by the actual available
    disk space on the box.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s set a limit on the maximum file size, simply by passing the `-f` option
    switch and the actual limit. But what''s the unit of the size? bytes, KB, MB?
    Let''s look up its man page: by the way, the man page for `ulimit` is the man
    page for `bash(1)`. This is logical, as `ulimit` is a built-in shell command.
    Once in the `bash(1)` man page, search for `ulimit`; the manual informs us that
    the unit (by default) is 1,024-byte increments. Thus, `2` implies *1,024*2 = 2,048*
    bytes. Alternatively, to get some help on `ulimit`, just type `help ulimit` on
    the shell.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s try this: reduce the file size resource limit to just 2,048 bytes
    and then test with `dd`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3a5aaecd-3731-4be5-94f8-b6368b050e63.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1: A simple test case with ulimit -f'
  prefs: []
  type: TYPE_NORMAL
- en: As can be seen from the preceding screenshot, we reduce the file size resource
    limit to `2`, implying 2,048 bytes, and then test with `dd`. As long as we create
    a file at or below 2,048 bytes, it works; the moment we attempt to go beyond the
    limit, it fails.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an aside, note that `dd` does *not* attempt to use some clever logic to
    test the resource limit, displaying an error if it were to attempt to create a
    file over this limit. No, it just fails. Recall from [Chapter 1](c17af8c2-a426-4ab6-aabb-aa1374e56cc4.xhtml),
    *Linux System Architecture*, the Unix philosophy principle: provide mechanisms,
    not policies!'
  prefs: []
  type: TYPE_NORMAL
- en: Granularity of resource limits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous example with `dd(1)`, we saw that we can indeed impose a limit
    upon the maximum file size. An important question arises: what is the *scope*
    or *granularity* of the resource limit? Is it system-wide?'
  prefs: []
  type: TYPE_NORMAL
- en: 'The short answer: no, it''s not system-wide, it''s *process-wide*, implying
    that the resource limits apply at the granularity of a process and not the system.
    To clarify this, consider two shells—nothing but the `bash` process—shell A and
    shell B. We modify the maximum file-size resource limit for shell A (with the
    usual `ulimit -f <new-limit>` command), but leave the resource limit for maximum
    file size for shell B untouched. If now they both use `dd` (as we did), we would
    find that the `dd`  process invoked within shell A would likely die with the `''File
    size limit exceeded (core dumped)''` failure message, whereas the `dd` process
    invoked within shell B would likely continue and succeed (provided, of course,
    there''s sufficient disk space available).'
  prefs: []
  type: TYPE_NORMAL
- en: This simple experiment proves that the granularity of a resource limit is per
    process*.*
  prefs: []
  type: TYPE_NORMAL
- en: When we delve into the inner details of multithreading, we'll revisit the granularity
    of resource limits and how they apply to individual threads. For the impatient,
    all resource limits-except for the stack size are shared by all threads within
    the process
  prefs: []
  type: TYPE_NORMAL
- en: Resource types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we've only checked out the maximum file size resource limit; are there
    not others? Yes, indeed, there are several others.
  prefs: []
  type: TYPE_NORMAL
- en: Available resource limits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following table enumerates the available resource limits on a typical Linux
    system (alphabetically ordered by the `ulimit option switch` column):'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Resource limit** | **ulimit option** **switch** | **Default value** | **Unit**
    |'
  prefs: []
  type: TYPE_TB
- en: '| `max core file size` | `-c` | `unlimited` | KB |'
  prefs: []
  type: TYPE_TB
- en: '| `max data segment size` | `-d` | `unlimited` | KB |'
  prefs: []
  type: TYPE_TB
- en: '| `max scheduling priority` (nice) | `-e` | `0` | Unscaled |'
  prefs: []
  type: TYPE_TB
- en: '| `max file size` | `-f` | `unlimited` | KB |'
  prefs: []
  type: TYPE_TB
- en: '| `max (real-time) pending signals` | `-i` | `<varies>` | Unscaled |'
  prefs: []
  type: TYPE_TB
- en: '| `max locked memory` | `-l` | `<varies>` | KB |'
  prefs: []
  type: TYPE_TB
- en: '| `max memory size` | `-m` | `unlimited` | KB |'
  prefs: []
  type: TYPE_TB
- en: '| `max open files` | `-n` | `1024` | Unscaled |'
  prefs: []
  type: TYPE_TB
- en: '| `max pipe size` | `-p` | `8` | 512-byte increments |'
  prefs: []
  type: TYPE_TB
- en: '| `max POSIX message queues` | `-q` | `<varies>` | Unscaled |'
  prefs: []
  type: TYPE_TB
- en: '| `max real-time scheduling priority` | `-r` | `0` | Unscaled |'
  prefs: []
  type: TYPE_TB
- en: '| `max stack segment size` | `-s` | `8192` | KB |'
  prefs: []
  type: TYPE_TB
- en: '| `max CPU time` | `-t` | `unlimited` | Seconds |'
  prefs: []
  type: TYPE_TB
- en: '| `max user processes` | `-u` | `<varies>` | Unscaled |'
  prefs: []
  type: TYPE_TB
- en: '| `address space limit` or `max virtual memory` | `-v` | `unlimited` | KB |'
  prefs: []
  type: TYPE_TB
- en: '| `max file locks held` | `-x` | `unlimited` | Unscaled |'
  prefs: []
  type: TYPE_TB
- en: 'There are a few points to note:'
  prefs: []
  type: TYPE_NORMAL
- en: At a glance, some of the resource limit meanings are quite obvious; several
    may not be. Most of them are not explained here, some of them will be touched
    upon in subsequent chapters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The second column is the option switch to pass to `ulimit` to display the current
    value for the particular resource limit in that row; for example, `ulimit -s`
    to print out the current value of the stack size resource limit (unit: KB).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third column is **Default value**. This, of course, could vary across Linux
    platforms. In particular, enterprise-class servers may tune their default values
    to be much higher than, say, an embedded Linux system. Also, quite often the default
    value is a calculation (based on, say, amount of RAM installed on the box); hence,
    the entry *<varies>* in some cases. Also, as mentioned earlier, `unlimited` does
    not mean infinite—it implies that no artificial upper limit has been enforced.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Regarding the fourth column, **Unit**, the (`bash(1)`) man page (source:[https://linux.die.net/man/1/bash](https://linux.die.net/man/1/bash))
    states the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Also, `unscaled` implies it's just a number.
  prefs: []
  type: TYPE_NORMAL
- en: One can display all resource limits via the `-a` option switch; we leave it
    to you to try out the `ulimit -a` command.
  prefs: []
  type: TYPE_NORMAL
- en: Note that `ulimit -a` orders the resource limits alphabetically by option switch,
    just as we did in the table.
  prefs: []
  type: TYPE_NORMAL
- en: Also, it's really important to understand that these resource limits are with
    respect to a single process—the shell process (Bash)—that invoked the `ulimit`
    command.
  prefs: []
  type: TYPE_NORMAL
- en: Hard and soft limits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Unixes make a further distinction: in reality (under the hood), the resource
    limit for a given type is not one number—it''s two:'
  prefs: []
  type: TYPE_NORMAL
- en: A value for the hard limit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A value for the soft limit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The hard limit is the true maximum; as a regular user, it''s impossible to
    exceed this limit. What if a process attempts this? Simple: it gets killed by
    the OS.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The soft limit, on the other hand, can be breached: in the case of some resource
    limits, the process (that exceeds the soft limit) will be sent a signal by the
    kernel. Think of this as a warning: you''re nearing the limit kind of thing. Again,
    don''t worry, we take a deep dive into signalingin [Chapter 11](99fafa09-8972-4d9f-b241-46caf9de98f3.xhtml),
    *Signaling - Part I*, and, [Chapter 12](657b6be0-ebc8-40dd-81b6-4741b04602b1.xhtml),
    *Signaling - Part II*. For example, if a process exceeds the soft limit for file
    size, the OS responds by delivering the `SIGXFSZ` signal—`SIGnal: eXceeding FileSiZe`—to
    it! Overstep the soft limit for CPU and guess what? You will be the proud recipient
    of the `SIGXCPU` signal.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, there''s more to it: the man page on `prlimit(2)` shows how, on Linux,
    with regard to the CPU limit, `SIGKILL` is sent after multiple warnings via `SIGXCPU`.
    The right behavior: the application should clean up and terminate upon receiving
    the first `SIGXCPU` signal. We will look at signal-handling in [Chapter 11](99fafa09-8972-4d9f-b241-46caf9de98f3.xhtml),
    *Signaling – Part I*!'
  prefs: []
  type: TYPE_NORMAL
- en: It's instructive to think of the hard limit as a ceiling value for the soft
    limit; in effect, the range of the soft limit for a given resource is [0, hard-limit].
  prefs: []
  type: TYPE_NORMAL
- en: 'To view both the hard and soft limits on your shell process, use the `-S` and
    `-H` option switches on `ulimit`, respectively. Here''s the output of `ulimit
    -aS` on our trusty Fedora 28 desktop system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run `ulimit` with both the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-aS`: Display all Soft resource limit values'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-aH`: Display all Hard resource limit values'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A question comes up: where exactly do the soft and hard limits (for the Bash
    process) differ? Instead of trying to manually interpret it, let''s use a super
    GUI frontend to `diff` (well, it''s more than just a `diff` frontend actually),
    called  `meld`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Screenshot of meld comparing the soft and hard limit resource values shown
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/baca4e69-7511-48aa-9486-4627af191135.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2: Screenshot showing meld comparing the soft and hard limit resource
    values'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that we run `ps`; this is to reiterate the fact that the resource limit
    values we''re seeing `/` are with respect to it (PID `23843`). So, meld clearly
    shows us that, by default on a typical Linux system, only two resource limits
    differ in their soft and hard values: the max open files (soft=1024, hard=4096),
    and max stack size (soft=8192 KB = 8 MB, hard=unlimited).'
  prefs: []
  type: TYPE_NORMAL
- en: '`meld` is extremely valuable to developers; we often use it to (peer-) review
    code and make changes (merges via the right- and left-pointing arrows).  In fact,
    the powerful Git SCM uses `meld` as one of the available tools (with the `git
    mergetool` command). Install `meld` on your Linux box using the appropriate package
    manager for your distribution and try it out.'
  prefs: []
  type: TYPE_NORMAL
- en: Querying and changing resource limit values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We now understand that it''s the kernel (the OS) that sets up resource limits
    per process and tracks usage, even killing the process if necessary—if it attempts
    to exceed a resource''s hard limit. This raises the question: is there a way one
    can change the soft and hard resource-limit values? We''ve already seen it in
    fact: `ulimit`. More than that, though, the deeper question is: are we allowed
    to set any hard/soft limits?'
  prefs: []
  type: TYPE_NORMAL
- en: 'The kernel has certain preset rules regarding the changing of a resource limit. Querying
    or setting a process''s resource limits can only be done by the calling process
    upon itself or upon a process that it owns; more correctly, for any other process
    besides itself, the process must have the `CAP_SYS_RESOURCE` capability bit set
    (worry not, detailed coverage on process capabilities can be found in [Chapter
    8](b4538277-87f0-46f1-83fa-632fa470bfd7.xhtml), *Process Capabilities*):'
  prefs: []
  type: TYPE_NORMAL
- en: '**Querying**: Anyone can query the resource limits hard and soft (current)
    values of the processes they own.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Setting**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A hard limit, once set, cannot be further increased (for that session).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A soft limit can be increased up to the hard limit value only, that is, soft
    limit range = [0, hard-limit].
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When one sets the resource limit using `ulimit`, the system internally sets
    *both the hard and soft limits.* This has important consequences (see the preceding
    points).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Permissions for setting resource limits is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A privileged process (such as `superuser/root/sysadmin`, or one with the aforementioned
    `CAP_SYS_RESOURCE` capability) can increase or decrease both hard and soft limits.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A non-privileged process (non-root):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can set the soft limit of a resource in the range [0, hard-limit] for that resource.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can irreversibly decrease a resource's hard limit (once reduced, it cannot ever
    increase it, but can only continue to decrease it). More precisely, the hard limit
    can be decreased to a value greater than or equal to the current soft limit.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Every good rule has an exception: a non-privileged user *can* decrease and/or
    increase the *core file* resource limit. This is usually to allow developers to
    generate a core dump (which can be subsequently analyzed via GDB).'
  prefs: []
  type: TYPE_NORMAL
- en: 'A quick test case to demonstrate this is in order; let''s manipulate the max
    open files resource limit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command are explained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The current soft limit is 1,024 (the default)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The soft limit is 1,024, the hard limit is 4,096
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `ulimit`, we set the limit to 3,000; this, internally, has caused both
    the soft and hard limits to be set to 3,000
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attempting to set the value higher (to 3,001) fails
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reducing the value (to 2,000) succeeds
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Realize though, that again, both the soft and hard limits have been set to 2,000
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attempting to go back to a previously valid value fails (3,000); this is because
    the valid range now is [0, 2,000]
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing this with root access is left as an exercise to the reader; see the
    *Caveats* section that follows, though.
  prefs: []
  type: TYPE_NORMAL
- en: Caveats
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Things to consider, and exceptions that apply:'
  prefs: []
  type: TYPE_NORMAL
- en: Even if one can, increasing a resource limit may do more harm than good; think
    through what you are trying to achieve here. Put yourself in the malicious-hacker
    mindset (recall (DDoS attacks). On both server class, as well as on highly resource-constrained
    systems (often an embedded one), setting resource limits appropriately can help
    mitigate risk.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Setting a resource limit to a higher value requires root privilege. For example:
    we wish to increase the max open files resource limit from 1,024 to 2,000\. One
    would assume that using `sudo` should do the job. However, at first surprisingly,
    something such as `sudo ulimit -n 2000` will not work! Why? Well, when you run
    it, `sudo` expects that `ulimit` is a binary executable and thus searches for
    it in the `PATH`; but of course, that''s not the case: `ulimit` is a built-in
    shell command and thus fails to launch. So, try it this way:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Exception—you cannot seem to change the max pipe size resource limit.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Advanced: The default maximum pipe size is actually in `/proc/sys/fs/pipe-max-size`
    and defaults to 1 MB (from Linux 2.6.35). What if the programmer must change the
    pipe size? To do so, one could use the `fcntl(2)`system call, via the `F_GETPIPE_SZ`
    and `F_SETPIPE_SZ` parameters. Refer to the *fcntl(2)* man page for details.'
  prefs: []
  type: TYPE_NORMAL
- en: A quick note on the prlimit utility
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Besides using `ulimit`, another frontend to querying and displaying resource
    limits is the `prlimit` utility. `prlimit` differs from `ulimit` in the following
    ways:'
  prefs: []
  type: TYPE_NORMAL
- en: It's a newer, modern interface (Linux kernel version 2.6.36 onward)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can be used to modify limits as required *and* launch another program that
    will inherit the new limits (a useful feature; see the following examples)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's a binary executable program in itself, not a built-in like `ulimit` is
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Without any parameters, `prlimit` displays the resource limits of the calling
    process (itself). One can optionally pass resource limit `<name=value>` pairs
    to set the same, the PID of the process to query/set resource limits, or a command
    to be launched with the newly set resource limits. Here is the synopsis from its
    man page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note how the `--pid` and `command` options are mutually exclusive.
  prefs: []
  type: TYPE_NORMAL
- en: Using prlimit(1) – examples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Example 1—querying limits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Output for the preceding command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0f483e82-6b24-4d49-9316-a3ef79eb63ef.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have abbreviated the output for better readability.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 2—set the resource limits for max file size and max stack size for
    the (preceding) shell process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Example 3—a program, `rlimit_primes`, that generates prime numbers; have it
    generate a large number of primes but give it only two seconds of CPU time to
    do so.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the `rlimit_primes` program, along with its source code, is described
    in detail in the *API interfaces* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, we just run it within the scope of the built-in `prlimit `program,
    ensuring that the `rlimit_primes`process only gets the CPU bandwidth (in seconds)
    that we pass via the `prlimit --cpu=`option switch. In the example, we ensure
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: We give our prime number generator process two seconds (via `prlimit`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We pass `-2` as the second parameter; this will cause the `rlimit_primes`program
    to skip setting the CPU resource limit itself
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We ask it to generate primes up to the number 8,000,000:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Note how, once it's out of its newly constrained CPU time resource (two seconds,
    in the preceding example), it gets killed by the kernel! (Technically, by the
    `SIGKILL` signal; a lot more on signals follows in [Chapter 11](99fafa09-8972-4d9f-b241-46caf9de98f3.xhtml), *Signaling
    - Part I*, and [Chapter 12](657b6be0-ebc8-40dd-81b6-4741b04602b1.xhtml), *Signaling
    - Part II*). Note how the word **`Killed`** appears, indicating that the OS has
    killed the process.
  prefs: []
  type: TYPE_NORMAL
- en: Refer to the man page on `prlimit(1)` for further details.
  prefs: []
  type: TYPE_NORMAL
- en: 'A practical case: When running fairly heavy software such as Eclipse and Dropbox,
    I have found it necessary to bump up the resource limits for them (as advised);
    otherwise, they abort as they run out of resources.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Advanced: From the Linux kernel version 2.6.24 onward, one can look up the
    resource limits for a given process PID via the powerful `proc` filesystem: `/proc/<PID>/limits`.'
  prefs: []
  type: TYPE_NORMAL
- en: API interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Querying and/or setting resource limits programmatically can be achieved with
    the following APIs—the system calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '`getrlimit`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setrlimit`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`prlimit`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Of these, we will only focus on `prlimit(2)`; `[get|set]rlimit(2)` is an older
    interface, has quite a few issues (bugs), and is generally considered outdated.
  prefs: []
  type: TYPE_NORMAL
- en: For `prlimit(2)` to work properly, one must be running on Linux kernel version
    2.6.36 or later.
  prefs: []
  type: TYPE_NORMAL
- en: How does one determine the Linux kernel version one is running on?
  prefs: []
  type: TYPE_NORMAL
- en: 'Simple: use the `uname` utility to query the kernel version:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$ uname -r`'
  prefs: []
  type: TYPE_NORMAL
- en: '`4.14.11-300.fc27.x86_64`'
  prefs: []
  type: TYPE_NORMAL
- en: '`$`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s get back to the `prlimit(2)` system call API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `prlimit()` system call can be used to both query and set a given resource
    limit—only one resource limit per call—for or on a given process. It receives
    four arguments; the first argument, `pid`, is the PID of the process to act upon.
    The special `0` value implies that it acts upon the calling process itself. The
    second argument, resource*,* is the name of the resource limit we wish to query
    or set (refer to the following table for the full list). Both the third and fourth
    arguments are pointers to `struct rlimit`; the third parameter, if non-NULL, is
    the new value we want to set (which is why it is marked `const`); the fourth parameter,
    if non-NULL, is the structure where we will receive the previous (or old) limit.
  prefs: []
  type: TYPE_NORMAL
- en: Experienced C programmers will realize how easy it is to create bugs. It's the
    programmer's responsibility to ensure that the memory for the *rlimit* structures
    (third and fourth parameters), if used, must be allocated*;* the OS certainly
    does not allocate memory for these structures.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `rlimit` structure contains two members, the soft and hard limits (`rlim_cur `and `rlim_max`, respectively):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Back to the second argument, resource, which is the programmatic name of the
    resource limit we wish to query or set. The following table enumerates all of
    them:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Resource limit** | **Programmatic****name (use in API)**  | **Default value**
    | **Unit** |'
  prefs: []
  type: TYPE_TB
- en: '| `max core file size` | `RLIMIT_CORE` | `unlimited` | KB |'
  prefs: []
  type: TYPE_TB
- en: '| `max data segment size` | `RLIMIT_DATA` | `unlimited` | KB |'
  prefs: []
  type: TYPE_TB
- en: '| `max scheduling priority (*nice*)` | `RLIMIT_NICE` | `0` | unscaled |'
  prefs: []
  type: TYPE_TB
- en: '| `max file size` | `RLIMIT_FSIZE` | `unlimited` | KB |'
  prefs: []
  type: TYPE_TB
- en: '| `max (real-time) pending signals` | `RLIMIT_SIGPENDING` | `<varies>` | unscaled
    |'
  prefs: []
  type: TYPE_TB
- en: '| `max locked memory` | `RLIMIT_MEMLOCK` | `<varies>` | KB |'
  prefs: []
  type: TYPE_TB
- en: '| `max open files` | `RLIMIT_NOFILE` | `1024` | unscaled |'
  prefs: []
  type: TYPE_TB
- en: '| `max POSIX message queues` | `RLIMIT_MSGQUEUE` | `<varies>` | unscaled |'
  prefs: []
  type: TYPE_TB
- en: '| `max real-time priority` | `RLIMIT_RTTIME` | `0` | microseconds |'
  prefs: []
  type: TYPE_TB
- en: '| `max stack segment size` | `RLIMIT_STACK` | `8192` | KB |'
  prefs: []
  type: TYPE_TB
- en: '| `max CPU time` | `RLIMIT_CPU` | `unlimited` | seconds |'
  prefs: []
  type: TYPE_TB
- en: '| `max user processes` | `RLIMIT_NPROC` | `<varies>` | unscaled |'
  prefs: []
  type: TYPE_TB
- en: '| `address space limit or max virtual memory` | `RLIMIT_AS  ` (AS = Address
    Space) | `unlimited` | KB |'
  prefs: []
  type: TYPE_TB
- en: '| `max file locks held` | `RLIMIT_LOCKS` | `*unlimited*` | *unscaled* |'
  prefs: []
  type: TYPE_TB
- en: 'Points to note are given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The `RLIM_INFINITY` value for a resource value implies that there is no limit.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Alert readers will notice that there is no entry for `max pipe size` (as there
    was in the previous table); this is because this resource cannot be modified via
    the `prlimit(2)` API.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technically, to modify a resource limit value, a process requires the `CAP_SYS_RESOURCE`
    capability (capabilities is explained in details in [Chapter 8](b4538277-87f0-46f1-83fa-632fa470bfd7.xhtml),
    *Process Capabilities*). For now, let's just use the traditional approach and
    say that in order to change a process's resource limit, one needs to own the process
    (or be root; being root or superuser is pretty much a shortcut to all the rules).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code examples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following two C programs are used to demonstrate the usage of the `prlimit(2)`
    API:'
  prefs: []
  type: TYPE_NORMAL
- en: The first program, `rlimits_show.c`, queries all resource limits for the current
    or calling process and prints out their values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second, given a CPU resource limit (in seconds), runs a simple prime number
    generator under the influence of that limit.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For readability, only the relevant parts of the code are displayed. To view
    and run it, the entire source code is available at [https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux](https://github.com/PacktPublishing/Hands-on-System-Programming-with-Linux)*.*
  prefs: []
  type: TYPE_NORMAL
- en: 'Refer to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s try it out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We first use the program to dump all the resource limits. Then, we query the
    file-size resource limit, modify it (lower it from unlimited to about 512 KB using
    `ulimit`), and run the program again, which reflects the change.
  prefs: []
  type: TYPE_NORMAL
- en: Now for the second program; given a CPU resource limit (in seconds), we run
    a simple prime number generator under the influence of that CPU resource limit.
  prefs: []
  type: TYPE_NORMAL
- en: For readability, relevant parts of the source code (the relevant source file
    is `ch3/rlimit_primes.c`) are shown.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the simple prime number generator function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the function to set up the CPU resource limit to the parameter passed,
    which is the time in seconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following code, we first just do a quick test run—we print the first
    100 primes and leave the CPU resource limit value untouched (it typically defaults
    to infinite). Then we invoke it to print the first 90,000 primes with five seconds
    of CPU time available to it. As expected (on modern hardware), both succeed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now for the fun part: we invoke `rlimit_primes` to print the first 200,000
    primes with only one second of CPU time available to it; this time it fails (note
    that we redirect standard output to a temporary file, so that we are not distracted
    by all the output):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Why did it fail? Obviously, the CPU resource limit—just one second—was too small
    a time for it to complete the given task; when the process attempted to exceed
    this limit, it was killed by the kernel.
  prefs: []
  type: TYPE_NORMAL
- en: 'A note to advanced readers: one can use the very powerful and versatile `perf(1)`
    Linux utility to see this too:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$ sudo **perf stat** ./rlimit_primes 200000 1 >/tmp/prm`'
  prefs: []
  type: TYPE_NORMAL
- en: '`./rlimit_primes: **Killed**`'
  prefs: []
  type: TYPE_NORMAL
- en: '`Performance counter stats for ''./rlimit_primes 200000 1'':`'
  prefs: []
  type: TYPE_NORMAL
- en: '`  1001.917484   task-clock (msec)  # 0.999 CPUs utilized`'
  prefs: []
  type: TYPE_NORMAL
- en: '`           17   context-switches   # 0.017 K/sec`'
  prefs: []
  type: TYPE_NORMAL
- en: '`            1   cpu-migrations     # 0.001 K/sec`'
  prefs: []
  type: TYPE_NORMAL
- en: '`           51   page-faults        # 0.051 K/sec`'
  prefs: []
  type: TYPE_NORMAL
- en: '`3,018,577,481   cycles             # 3.013 GHz`'
  prefs: []
  type: TYPE_NORMAL
- en: '`5,568,202,738   instructions       # 1.84 insn per cycle`'
  prefs: []
  type: TYPE_NORMAL
- en: '`  982,845,319   branches           # 980.964 M/sec`'
  prefs: []
  type: TYPE_NORMAL
- en: '`       88,602   branch-misses      # 0.01% of all branches`'
  prefs: []
  type: TYPE_NORMAL
- en: '`**1.002659905 seconds time elapsed**`'
  prefs: []
  type: TYPE_NORMAL
- en: '`$`'
  prefs: []
  type: TYPE_NORMAL
- en: Permanence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've demonstrated that, within its operational framework, one can indeed query
    and set per-process resource limits using frontends, such as `ulimit, prlimit(1)`, as
    well as programmatically via library and system call APIs. However, the changes
    we wrought are temporary—for that process's life or the session's life only. How
    does one make a resource limit value change permanent?
  prefs: []
  type: TYPE_NORMAL
- en: The Unix way is to use (ASCII-text) configuration files that reside on the filesystem.
    In particular, on most Linux distributions, editing the `/etc/security/limits.conf`
    configuration file is the answer. We shall not delve further into the details
    here; if interested, check out the man page on `limits.conf(5)`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter initially delved into the motivation behind per-process resource
    limits and why we require them. We also explained the granularity and the types
    of resource limits, distinguishing between soft and hard limits. Then we looked
    at how a user (or system administrator) can query and set the per-process resource
    limits using appropriate CLI frontends (`ulimit(1)`, `prlimit(1)`).
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we explored the programming interfaces (APIs)—practically speaking,
    the `prlimit(2)` system call—in detail. Two detailed code examples, querying the
    limits and setting a limit on CPU usage, rounded out the discussion.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about the crucial, dynamic memory-management
    APIs and their correct usage. We'll go well beyond the basics of using the typical
    `malloc()` API, delving into a few subtle and important inner details.
  prefs: []
  type: TYPE_NORMAL
