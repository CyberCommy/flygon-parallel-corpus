- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Diving into Variables, Types, and Methods
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入变量、类型和方法
- en: The initial steps into any programming language are plagued with a fundamental
    issue—you can understand the words being typed out, but not the meaning behind
    them. Normally, this would be cause for a paradox, but programming is a special
    case.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 进入任何编程语言的初始步骤都会受到一个基本问题的困扰——你可以理解打出的字，但不知道它们背后的含义。通常情况下，这会导致悖论，但编程是一个特殊情况。
- en: C# is not its own language; it's written in English. The discrepancy between
    the words you use every day and the code in Visual Studio comes from missing context,
    which is something that has to be learned all over again. You know how to say
    and spell the words used in C#, but what you don't know is where, when, why, and,
    most importantly, how they make up the syntax of the language.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: C#并不是一种独立的语言；它是用英语编写的。你每天使用的词语和在Visual Studio中的代码之间的差异来自于缺少上下文，这是需要重新学习的东西。你知道如何说和拼写C#中使用的词语，但你不知道的是它们在语言的语法中是如何组成的，以及最重要的是如何组成的。
- en: 'This chapter marks our departure from programming theory and the beginning
    of our journey into actual coding. We''ll talk about accepted formatting, debugging
    techniques, and putting together more complex examples of variables and methods.
    There''s a lot of ground to cover, but by the time you reach the last quiz, you''ll
    be comfortable with the following high-level topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章标志着我们离开了编程理论，开始了我们进入实际编码的旅程。我们将讨论接受的格式化、调试技术，并组合更复杂的变量和方法示例。有很多内容要涵盖，但当你达到最后的测验时，你将对以下高级主题感到舒适：
- en: Writing proper C#
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 写正确的C#
- en: Debugging your code
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试你的代码
- en: Understanding variables
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解变量
- en: Introducing operators
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引入运算符
- en: Defining methods
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义方法
- en: Let's get started!
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Writing proper C#
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 写正确的C#
- en: Lines of code function like sentences, meaning they need to have some sort of
    separating or ending character. Every line of C#, called a statement, *must* end
    with a semicolon to separate them for the code compiler to process.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 代码行就像句子一样，意味着它们需要有某种分隔或结束字符。每一行C#代码，称为语句，*必须*以分号结尾，以便编译器对其进行处理。
- en: 'However, there''s a catch that you need to be aware of. Unlike the written
    word we''re all familiar with, a C# statement doesn''t technically have to be
    on a single line; whitespace and newlines are ignored by the code compiler. For
    example, a simple variable could be written like this:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你需要注意一个问题。与我们熟悉的书面语言不同，C#语句在技术上不一定要在一行上；空格和换行符会被代码编译器忽略。例如，一个简单的变量可以这样写：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Alternatively, it could also be written as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，它也可以这样写：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: These two code snippets are both perfectly acceptable to Visual Studio, but
    the second option is highly discouraged in the software community as it makes
    code extremely hard to read. The idea is to write your programs as efficiently
    and clearly as possible.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个代码片段对Visual Studio来说都是完全可以接受的，但第二个选项在软件社区中是极为不鼓励的，因为它使得代码极其难以阅读。理念是尽可能高效和清晰地编写你的程序。
- en: There will be times when a statement will be too long to reasonably fit on a
    single line, but those are few and far between. Just make sure that it's formatted
    in a way someone else could understand, and don't forget the semicolon.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候一条语句会太长，无法合理地放在一行上，但这种情况很少。只要确保它的格式能让别人理解，并且不要忘记分号。
- en: 'The second formatting rule you need to drill into your coding muscle memory
    is the use of curly brackets or braces: `{}`. Methods, classes, and interfaces
    all need a set of curly brackets after their declaration. We''ll talk about each
    of these in-depth later on, but it''s important to get the standard formatting
    in your head early on.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要牢记的第二个格式化规则是使用花括号：`{}`。方法、类和接口在声明后都需要一对花括号。我们稍后会详细讨论这些内容，但是早点把标准格式化记在脑海中是很重要的。
- en: 'The traditional practice in C# is to include each bracket on a new line, as
    shown in the following method:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: C#的传统做法是将每个括号放在新的一行，就像下面的方法所示：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'However, you might see the first curly bracket located on the same line as
    the declaration out in the wild. It''s all down to personal preference:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你可能会看到第一个花括号与声明在同一行的情况。这完全取决于个人偏好：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: While this isn't something to tear your hair out over, the important thing is
    to be consistent. In this book, we'll stick with "pure" C# code, which will always
    put each bracket on a new line, while C# examples that have to do with Unity and
    game development will often follow the second example.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这不是什么让你抓狂的事情，但重要的是要保持一致。在本书中，我们将坚持使用“纯粹”的C#代码，它总是将每个括号放在新的一行，而与Unity和游戏开发有关的C#示例通常会遵循第二个例子。
- en: Good, consistent formatting style is paramount when starting in programming,
    but so is being able to see the fruits of your work. In the next section, we'll
    talk about how to print out variables and information straight to the Unity console.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 良好、一致的格式化风格在编程初学者中至关重要，但能够看到你的工作成果也同样重要。在下一节中，我们将讨论如何将变量和信息直接打印到Unity控制台。
- en: Debugging your code
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试你的代码
- en: While we're working through practical examples, we'll need a way to print out
    information and feedback to the **Console** window in the Unity editor. The programmatic
    term for this is debugging, and both C# and Unity provide helper methods to make
    this process easier for developers. You already debugged your code from the last
    chapter, but we didn't go into much detail about how it actually works. Let's
    fix that.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们通过实际示例进行工作时，我们需要一种方法将信息和反馈打印到Unity编辑器中的**控制台**窗口。这个程序术语称为调试，C#和Unity都提供了辅助方法，使开发人员更容易进行这个过程。你已经从上一章调试了你的代码，但我们并没有详细讨论它是如何工作的。让我们来解决这个问题。
- en: 'Whenever I ask you to debug or print something out, use one of the following
    methods:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我要求你调试或打印出某些东西时，使用以下方法之一：
- en: 'For simple text or individual variables, use the standard `Debug.Log()` method.
    The text needs to be inside a set of parentheses, and variables can be used directly
    with no added characters; for example:'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于简单的文本或单个变量，使用标准的`Debug.Log()`方法。文本需要放在一对括号内，变量可以直接使用，不需要添加其他字符；例如：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This will produce the following in the **Console** panel:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在**控制台**面板中产生以下结果：
- en: '![](img/B17573_03_01.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_03_01.png)'
- en: 'Figure 3.1: Observing Debug.Log output'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1：观察Debug.Log输出
- en: 'For more complex debugging, use `Debug.LogFormat()`. This will let you place
    variables inside the printed text by using placeholders. These are marked with
    a pair of curly brackets, each containing an index. An index is a regular number,
    starting at 0 and increasing sequentially by 1\. In the following example, the
    `{0}` placeholder is replaced with the `CurrentAge` value, `{1}` with `FirstName`,
    and so on:'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于更复杂的调试，使用`Debug.LogFormat()`。这将允许您在打印的文本中使用占位符来放置变量。这些占位符用一对花括号标记，每个花括号包含一个索引。索引是一个常规数字，从0开始，依次递增1。在下面的示例中，`{0}`占位符被`CurrentAge`的值替换，`{1}`被`FirstName`替换，依此类推：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This will produce the following in the **Console** panel:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在**控制台**面板中产生以下结果：
- en: '![](img/B17573_03_02.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_03_02.png)'
- en: 'Figure 3.2: Observing Debug.LogFormat output'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2：观察Debug.LogFormat输出
- en: You might have noticed that we're using **dot notation** in our debugging techniques,
    and you'd be right! Debug is the class we're using, and `Log()` and `LogFormat()`
    are different methods that we can use from that class. More on this at the end
    of this chapter.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到我们在调试技术中使用了**点符号**，没错！Debug是我们使用的类，`Log()`和`LogFormat()`是我们可以从该类中使用的不同方法。本章末尾将详细介绍这一点。
- en: With the power of debugging under our belts, we can safely move on and do a
    deeper dive into how variables are declared, as well as the different ways that
    syntax can play out.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 有了调试的能力，我们可以安全地继续深入了解变量声明的方式，以及语法可以如何发挥作用。
- en: Understanding variables
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解变量
- en: In the previous chapter, we saw how variables are written and touched on the
    high-level functionality that they provide. However, we're still missing the syntax
    that makes all of that possible.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看到了变量的写法，并简要介绍了它们提供的高级功能。然而，我们仍然缺少使所有这些成为可能的语法。
- en: Declaring variables
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明变量
- en: 'Variables don''t just appear at the top of a C# script; they have to be declared
    according to certain rules and requirements. At its most basic level, a variable
    statement needs to satisfy the following requirements:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 变量不会只是出现在C#脚本的顶部；它们必须根据特定的规则和要求进行声明。在最基本的层面上，变量声明需要满足以下要求：
- en: The type of data the variable will store needs to be specified
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要指定变量将存储的数据类型
- en: The variable has to have a unique name
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量必须有一个唯一的名称
- en: If there is an assigned value, it must match the specified type
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果有一个赋值，它必须与指定的类型匹配
- en: The variable declaration needs to end with a semicolon
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量声明需要以分号结束
- en: 'The result of adhering to these rules is the following syntax:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 遵守这些规则的结果是以下语法：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Variables need unique names to avoid conflicts with words that have already
    been taken by C#, which are called keywords. You can find the full list of protected
    keywords at [https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/index](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/index).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 变量需要唯一的名称，以避免与C#已经使用的关键字发生冲突。您可以在[https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/index](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/index)找到受保护关键字的完整列表。
- en: This is simple, neat, and efficient. However, a programming language wouldn't
    be useful in the long run if there was only one way of creating something as pervasive
    as variables. Complex applications and games have different use cases and scenarios,
    all of which have unique C# syntax.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单，整洁，高效。然而，如果只有一种方式创建如此普遍的变量，那么编程语言在长期内将毫无用处。复杂的应用程序和游戏有不同的用例和场景，所有这些都有独特的C#语法。
- en: Type and value declarations
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类型和值的声明
- en: 'The most common scenario for creating variables is one that has all of the
    required information available when the declaration is made. For instance, if
    we knew a player''s age, storing it would be as easy as doing the following:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 创建变量最常见的情况是在声明时已经有了所有必需的信息。例如，如果我们知道玩家的年龄，存储它就像这样简单：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here, all of the basic requirements have been met:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，所有基本要求都得到了满足：
- en: A data type is specified, which is `int` (short for integer)
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定了数据类型，即`int`（整数的缩写）
- en: A unique name is used, which is `CurrentAge`
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用了一个唯一的名称，即`CurrentAge`
- en: '`32` is an integer, which matches the specified data type'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`32`是一个整数，与指定的数据类型匹配'
- en: The statement ends with a semicolon
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该语句以分号结束
- en: However, there will be scenarios where you'll want to declare a variable without
    knowing its value right away. We'll talk about this topic in the following section.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时候你会想要声明一个变量，但并不知道它的值。我们将在接下来的部分讨论这个话题。
- en: Type-only declarations
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 仅类型声明
- en: 'Consider another scenario—you know the type of data you want a variable to
    store and its name, but not its value. The value will be computed and assigned
    somewhere else, but you still need to declare the variable at the top of the script.
    This situation is perfect for a type-only declaration:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑另一种情况——你知道你想要一个变量存储的数据类型和它的名称，但不知道它的值。值将在其他地方计算和赋值，但你仍然需要在脚本的顶部声明变量。这种情况非常适合仅类型声明：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Only the type (`int`) and unique name (`CurrentAge`) are defined, but the statement
    is still valid because we''ve followed the rules. With no assigned value, default
    values will be assigned according to the variable''s type. In this case, `CurrentAge`
    will be set to `0`, which matches the `int` type. As soon as the actual value
    of the variable becomes available, it can easily be set in a separate statement
    by referencing the variable name and assigning it a value:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 只有类型（`int`）和唯一名称（`CurrentAge`）被定义，但语句仍然有效，因为我们遵循了规则。没有分配的值，将根据变量的类型分配默认值。在这种情况下，`CurrentAge`将被设置为`0`，这与`int`类型匹配。一旦变量的实际值变得可用，就可以通过引用变量名并为其分配一个值来轻松地在单独的语句中设置它：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You can find a complete list of all C# types and their default values at [https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/default-values](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/default-values).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/default-values](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/default-values)找到所有C#类型及其默认值的完整列表。
- en: At this point, you might be asking why, so far, our variables haven't included
    the `public` keyword, called an *access modifier*, which we saw in earlier scripting
    examples. The answer is that we didn't have the necessary foundation to talk about
    them with any clarity. Now that we have that foundation, it's time to revisit
    them in detail.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，您可能会问为什么到目前为止，我们的变量还没有包括`public`关键字，即*访问修饰符*，这是我们在早期脚本示例中看到的。答案是我们没有必要的基础来清楚地谈论它们。现在我们有了这个基础，是时候详细讨论它们了。
- en: Using access modifiers
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用访问修饰符
- en: Now that the basic syntax is no longer a mystery, let's get into the finer details
    of variable statements. Since we read code from left to right, it makes sense
    to begin our variable deep dive with the keyword that traditionally comes first—an
    access modifier.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在基本语法不再是一个谜，让我们深入了解变量语句的细节。由于我们从左到右阅读代码，因此从传统上来说，从关键字开始进行变量深入研究是有意义的。
- en: 'Take a quick look back at the variables we used in the preceding chapter in
    `LearningCurve` and you''ll see they had an extra keyword at the front of their
    statements: `public`. This is the variable''s access modifier. Think of it as
    a security setting, determining who and what can access the variable''s information.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 快速回顾一下我们在前一章中在`LearningCurve`中使用的变量，您会发现它们在语句的开头有一个额外的关键字：`public`。这就是变量的访问修饰符。将其视为安全设置，确定谁和什么可以访问变量的信息。
- en: Any variable that isn't marked `public` is defaulted to `private` and won't
    show up in the Unity Inspector panel.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 任何没有标记为`public`的变量都默认为`private`，并且不会显示在Unity Inspector面板中。
- en: 'If you include a modifier, the updated syntax recipe we put together at the
    beginning of this chapter will look like this:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果包括一个修饰符，我们在本章开头组合的更新语法配方将如下所示：
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: While explicit access modifiers aren't necessary when declaring a variable,
    it's a good habit to get into as a new programmer. That extra word goes a long
    way toward readability and professionalism in your code.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明变量时，明确的访问修饰符并不是必需的，但作为新程序员，养成这样的习惯是很好的。这个额外的词在代码的可读性和专业性方面有很大帮助。
- en: 'There are four main access modifiers available in C#, but the two you''ll be
    working with most often as a beginner are the following:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: C#中有四种主要的访问修饰符，但作为初学者，您最常使用的两种是以下两种：
- en: '**Public**: This is available to any script without restriction.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Public**：对任何脚本都是可用的，没有限制。'
- en: '**Private**: This is only available in the class they''re created in (which
    is called the containing class). Any variable without an access modifier defaults
    to private.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Private**：仅在创建它们的类中可用（称为包含类）。任何没有访问修饰符的变量默认为私有。'
- en: 'The two advanced modifiers have the following characteristics:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 两个高级修饰符具有以下特点：
- en: '**Protected**: Accessible from their containing class or types derived from
    it'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Protected**：可从包含类或从中派生的类型访问'
- en: '**Internal**: Only available in the current assembly'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Internal**：仅在当前程序集中可用'
- en: There are specific use cases for each of these modifiers, but until we get to
    the advanced chapters, don't worry about **protected** and **internal**.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 每个修饰符都有特定的用例，但在我们进入高级章节之前，不要担心**protected**和**internal**。
- en: Two combined modifiers also exist, but we won't be using them in this book.
    You can find more information about them at [https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/access-modifiers](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/access-modifiers).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 两种组合修饰符也存在，但在本书中我们不会使用它们。您可以在[https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/access-modifiers](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/access-modifiers)找到更多关于它们的信息。
- en: Let's try out some access modifiers of our own! Just like information in real
    life, some data needs to be protected or shared with specific people. If there's
    no need for a variable to be changed in the **Inspector** window or accessed from
    other scripts, it's a good candidate for a private access modifier.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试一些自己的访问修饰符！就像现实生活中的信息一样，有些数据需要受到保护或与特定人分享。如果变量在**Inspector**窗口中不需要更改或从其他脚本中访问，那么它就是私有访问修饰符的一个很好的选择。
- en: 'Perform the following steps to update `LearningCurve`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤来更新`LearningCurve`：
- en: Change the access modifier in front of `CurrentAge` from `public` to `private`
    and save the file.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`CurrentAge`前面的访问修饰符从`public`更改为`private`并保存文件。
- en: Go back into Unity, select the Main Camera, and take a look at what changed
    in the `LearningCurve`section:![](img/B17573_03_03.png)
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回Unity，选择主摄像机，并查看`LearningCurve`部分中的更改！[](img/B17573_03_03.png)
- en: 'Figure 3.3: LearningCurve script component attached to the Main Camera'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3：附加到主摄像机的LearningCurve脚本组件
- en: Since `CurrentAge` is now private, it's no longer visible in the **Inspector**
    window and can only be accessed within the `LearningCurve` script in code. If
    we click play, the script will still work exactly as it did before.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`CurrentAge`现在是私有的，它不再在**检视器**窗口中可见，只能在`LearningCurve`脚本中的代码中访问。如果我们点击播放，脚本仍然会像以前一样正常工作。
- en: This is a good start on our journey into variables, but we still need to know
    more about what kinds of data they can store. This is where data types come in,
    which we'll look at in the next section.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们进入变量的旅程的一个良好开端，但我们仍然需要了解它们可以存储什么类型的数据。这就是数据类型的作用，我们将在下一节中进行讨论。
- en: Working with types
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用类型
- en: Assigning a specific type to a variable is an important choice, one that trickles
    down into every interaction a variable has over its entire lifespan. Since C#
    is what's called a *strongly-typed* or *type-safe* language, every variable has
    to have a data type without exception. This means that there are specific rules
    when it comes to performing operations with certain types, and regulations when
    converting a given variable type into another.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 将特定类型分配给变量是一个重要的选择，它会影响变量在整个生命周期中的每次交互。由于C#是所谓的*强类型*或*类型安全*语言，每个变量都必须有一个数据类型，没有例外。这意味着在执行特定类型的操作时有特定的规则，并且在将给定变量类型转换为另一个类型时有规定。
- en: Common built-in types
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 常见的内置类型
- en: 'All data types in C# trickle down (or *derive*, in programmatic terms) from
    a common ancestor: `System.Object`. This hierarchy, called the **Common Type System**
    (**CTS**), means that different types have a lot of shared functionality. The
    following table lays out some of the most common data type options and the values
    they store:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: C#中的所有数据类型都从一个共同的祖先`System.Object`（在编程术语中称为*派生*）派生下来。这个层次结构称为**公共类型系统**（**CTS**），意味着不同类型有很多共享功能。下表列出了一些最常见的数据类型选项以及它们存储的值：
- en: '![](img/B17573_03_04.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_03_04.png)'
- en: 'Figure 3.4: Common data types for variables'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4：变量的常见数据类型
- en: 'In addition to specifying the kind of value a variable can store, types contain
    added information about themselves, including the following:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 除了指定变量可以存储的值的类型之外，类型还包含有关自身的其他信息，包括以下内容：
- en: Required storage space
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所需的存储空间
- en: Minimum and maximum values
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小和最大值
- en: Allowed operations
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许的操作
- en: Location in memory
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存中的位置
- en: Accessible methods
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可访问的方法
- en: Base (derived) type
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本（派生）类型
- en: If this seems overwhelming, take a deep breath. Working with all of the types
    C# offers is a perfect example of using documentation over memorization. Pretty
    soon, using even the most complex custom types will feel like second nature.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这看起来令人不知所措，请深呼吸。使用C#提供的所有类型是使用文档而不是记忆的完美示例。很快，即使是最复杂的自定义类型的使用也会变得轻而易举。
- en: You can find a complete list of all of the C# built-in types and their specifications
    at [https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/types/index](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/types/index).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/types/index](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/types/index)找到所有C#内置类型及其规格的完整列表。
- en: Before the list of types becomes a sticking point, it's best to experiment with
    them. After all, the best way to learn something new is to use it, break it, and
    then learn to fix it.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在类型列表成为难点之前，最好先尝试它们。毕竟，学习新东西的最佳方式是使用它，打破它，然后学会修复它。
- en: 'Go ahead and open up `LearningCurve`and add a new variable for each type in
    the preceding chart from the *Common built-in types* section. The names and values
    you use are up to you; just make sure they''re marked as public so we can see
    them in the Inspector window. If you need inspiration, take a look at my code:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`LearningCurve`并根据前面图表中*常见内置类型*部分的每种类型添加一个新变量。您使用的名称和值由您决定；只需确保它们标记为公共，以便我们可以在检视器窗口中看到它们。如果需要灵感，可以看看我的代码：
- en: '[PRE11]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: When dealing with string types, the actual text value needs to be inside a pair
    of double quotes, while float values need to end with a lowercase `f`, as you
    can see with `FirstName` and `Pi`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理字符串类型时，实际文本值需要放在一对双引号中，而浮点值需要以小写`f`结尾，就像`FirstName`和`Pi`一样。
- en: All our different variable types are now visible. Take note of the `bool` variable
    that Unity displays as a checkbox (true is checked and false is unchecked).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的不同变量类型现在都是可见的。请注意Unity显示为复选框的`bool`变量（选中为true，未选中为false）。
- en: '![](img/B17573_03_05.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_03_05.png)'
- en: 'Figure 3.5: LearningCurve script component with common variable types'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5：带有常见变量类型的LearningCurve脚本组件
- en: Remember, any variables you declare as private won't show up in the Inspector
    window. Before we move on to conversions, we need to touch on a common and powerful
    application of the string data type; namely, the creation of strings that have
    variables interspersed at will.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，您声明为私有的任何变量都不会显示在检视器窗口中。在我们继续进行转换之前，我们需要提及字符串数据类型的一个常见且强大的应用，即创建随意插入变量的字符串。
- en: While number types behave as you'd expect from grade school math, strings are
    a different story. It's possible to insert variables and literal values directly
    into text by starting with a `$` character, which is called string interpolation.
    You've already used an interpolated string in your `LogFormat()` debugging; adding
    the `$` character lets you use them anywhere!
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然数字类型的行为与小学数学中的预期相同，但字符串则是另一回事。可以通过以`$`字符开头直接在文本中插入变量和文字值，这称为字符串插值。您已经在`LogFormat()`调试中使用了插值字符串；添加`$`字符可以让您随时使用它们！
- en: 'Let''s create a simple interpolated string of our own inside `LearningCurve`
    to see this in action. Print out the interpolated string inside the `Start()`
    method directly after `ComputeAge()` is called:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`LearningCurve`中创建一个简单的插值字符串，以便看到它的效果。在`ComputeAge()`之后直接在`Start()`方法中打印插值字符串：
- en: '[PRE12]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Thanks to the `$` character and curly brackets, the value of `FirstName` is
    treated as a value and is printed out inside the interpolated string. Without
    this special formatting, the string would just include `FirstName` as text instead
    of the variable value.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`$`字符和花括号，`FirstName`的值被视为一个值，并在插值字符串中打印出来。如果没有这种特殊格式，字符串将只包括`FirstName`作为文本，而不是变量值。
- en: '![](img/B17573_03_06.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_03_06.png)'
- en: 'Figure 3.6: Console showing debug log output'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.6：控制台显示调试日志输出
- en: It's also possible to create interpolated strings using the `+` operator, which
    we'll talk about in the *Introducing operators* section.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以使用`+`运算符创建插值字符串，我们将在*介绍运算符*部分讨论。
- en: Type conversions
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类型转换
- en: 'We''ve already seen that variables can only hold values of their declared types,
    but there will be situations where you''ll need to combine variables of different
    types. In programming terminology, these are called conversions, and they come
    in two main flavors:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到变量只能保存其声明类型的值，但会有情况需要组合不同类型的变量。在编程术语中，这些称为转换，有两种主要类型：
- en: '**Implicit** conversions take place automatically, usually when a smaller value
    will fit into another variable type without any rounding. For example, any integer
    can be implicitly converted into a `double` or `float` value without additional
    code:'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**隐式**转换通常在较小的值适合到另一个变量类型中时自动进行，通常不需要四舍五入。例如，任何整数都可以隐式转换为`double`或`float`值而无需额外的代码：'
- en: '[PRE13]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The output in the **Console** pane can be seen in the following screenshot:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '**控制台**窗格中的输出可以在以下截图中看到：'
- en: '![](img/B17573_03_07.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_03_07.png)'
- en: 'Figure 3.7: Implicit type conversion debug log output'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.7：隐式类型转换调试日志输出
- en: '**Explicit** conversions are needed when there is a risk of losing a variable''s
    information during the conversion. For example, if we wanted to convert a `double`
    value into an `int` value, we would have to explicitly cast (convert) it by adding
    the destination type in parentheses before the value we want to convert.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**显式**转换是在转换过程中存在丢失变量信息风险时需要的。例如，如果我们想要将`double`值转换为`int`值，我们必须通过在要转换的值之前加上目标类型的括号来显式地进行转换。'
- en: 'This tells the compiler that we are aware that data (or precision) might be
    lost:'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这告诉编译器，我们知道数据（或精度）可能会丢失：
- en: '[PRE14]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In this explicit conversion, `3.14` would be rounded down to `3`, losing the
    decimal values:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个显式转换中，`3.14`将被四舍五入为`3`，丢失小数值：
- en: '![](img/B17573_03_08.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_03_08.png)'
- en: 'Figure 3.8: Explicit type conversion debug log output'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.8：显式类型转换调试日志输出
- en: C# provides built-in methods for explicitly converting values to common types.
    For example, any type can be converted into a string value with the `ToString()`
    method, while the `Convert` class can handle more complicated conversions. You
    can find more info about these features under the *Methods* section at [https://docs.microsoft.com/en-us/dotnet/api/system.convert?view=netframework-4.7.2](https://docs.microsoft.com/en-us/dotnet/api/system.convert?view=netframework-4.7.2).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: C#提供了用于显式转换值为常见类型的内置方法。例如，任何类型都可以使用`ToString()`方法转换为字符串值，而`Convert`类可以处理更复杂的转换。您可以在[https://docs.microsoft.com/en-us/dotnet/api/system.convert?view=netframework-4.7.2](https://docs.microsoft.com/en-us/dotnet/api/system.convert?view=netframework-4.7.2)的*方法*部分找到有关这些功能的更多信息。
- en: So far, we've learned that types have rules regarding their interactions, operations,
    and conversion, but how do we handle a situation where we need to store a variable
    of an unknown type? This might sound crazy, but think about a data-download scenario—you
    know the information is coming into your game, but you're not sure what form it
    will take. We'll discuss how to handle this in the following section.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经了解到类型在交互、操作和转换方面有规则，但是当我们需要存储未知类型的变量时，我们该如何处理呢？这听起来很疯狂，但想想数据下载的情景——你知道信息正在进入你的游戏，但不确定它将采取什么形式。我们将在接下来的部分讨论如何处理这种情况。
- en: Inferred declarations
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 推断声明
- en: 'Luckily, C# can *infer* a variable''s type from its assigned value. For example,
    the `var` keyword can let the program know that the type of the data, `CurrentAge`,
    needs to be determined by its value of `32`, which is an integer:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，C#可以从分配的值中*推断*出变量的类型。例如，`var`关键字可以让程序知道数据`CurrentAge`的类型需要根据其值`32`来确定，这是一个整数：
- en: '[PRE15]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: While this is handy in certain situations, don't be suckered into the lazy programming
    habit of using inferred variable declarations for everything. This adds a lot
    of guesswork to your code, where it should be crystal clear.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在某些情况下这很方便，但不要被懒惰的编程习惯所迷惑，使用推断变量声明来处理所有事情。这会给你的代码增加很多猜测，而应该是清晰明了的。
- en: Before we wrap up our discussion on data types and conversion, we do need to
    briefly touch on the idea of creating custom types, which we'll do next.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们结束关于数据类型和转换的讨论之前，我们确实需要简要涉及创建自定义类型的想法，我们将在下一步中进行。
- en: Custom types
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自定义类型
- en: When we're talking about data types, it's important to understand early on that
    numbers and words (referred to as *literal values*) are not the only kinds of
    values a variable can store. For instance, a class, struct, or enumeration can
    be stored as variables. We will introduce these topics in *Chapter 5*, *Working
    with Classes, Structs, and OOP*, and explore them in greater detail in *Chapter
    10*, *Revisiting Types, Methods, and Classes*.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论数据类型时，早期理解数字和单词（称为*文字值*）不是变量可以存储的唯一种类的值是很重要的。例如，类、结构或枚举可以存储为变量。我们将在*第5章*，*使用类、结构和面向对象编程*中介绍这些主题，并在*第10章*，*重新审视类型、方法和类*中更详细地探讨它们。
- en: 'Types are complicated, and the only way to get comfortable with them is by
    using them. However, here are some important things to keep in mind:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 类型很复杂，唯一熟悉它们的方法是使用它们。然而，这里有一些重要的事情需要记住：
- en: All variables need to have a specified type (be it explicit or inferred)
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有变量都需要指定类型（无论是显式还是推断）
- en: Variables can only hold values of their assigned type (a `string` value can't
    be assigned an `int` variable)
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a variable needs to be assigned or combined with a variable of a different
    type, a conversion needs to take place (either implicit or explicit)
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The C# compiler can infer a variable's type from its value using the `var` keyword,
    but should only be used when the type isn't known when it's created
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That's a lot of nitty-gritty detail we've just jammed into a few sections, but
    we're not done yet. We still need to understand how naming conventions work in
    C#, as well as where the variables live in our scripts.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: Naming variables
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Picking names for your variables might seem like an afterthought in light of
    everything we've learned about access modifiers and types, but it shouldn't be
    a straightforward choice. Clear and consistent naming conventions in your code
    will not only make it more readable but will also ensure that other developers
    on your team understand your intentions without having to ask.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: 'The first rule when it comes to naming a variable is that the name you give
    it should be meaningful; the second rule is that you use Pascal case. Let''s take
    a common example from games and declare a variable to store a player''s health:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If you find yourself declaring a variable like this, alarm bells should be going
    off in your head. Whose health? Is it storing the maximum or minimum value? What
    other code will be affected when this value changes? These are all questions that
    should be easily answered by a meaningful variable name; you don't want to find
    yourself confused by your code in a week or a month.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: 'With that said, let''s try to make this a bit better using a Pascal case name:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Remember, Pascal case starts each word in the variable name with an uppercase
    letter.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: That's much better. With a little thought, we've updated the variable name with
    meaning and context. Since there is no technical limit in terms of how long a
    variable name can be, you might find yourself going overboard and writing out
    ridiculously descriptive names, which will give you problems just as much as a
    short, non-descriptive name would.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: As a general rule, make a variable name as descriptive as it needs to be—no
    more, no less. Find your style and stick to it.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: Understanding variable scope
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''re getting to the end of our dive into variables, but there''s still one
    more important topic we need to cover: scope. Similar to access modifiers, which
    determine which outside classes can grab a variable''s information, the variable
    scope is the term used to describe where a given variable exists and its access
    point within its containing class.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three main levels of variable scope in C#:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '**Global** scope refers to a variable that can be accessed by an entire program;
    in this case, a game. C# doesn''t directly support global variables, but the concept
    is useful in certain cases, which we''ll cover in *Chapter 10*, *Revisiting Types,
    Methods, and Classes.*'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Class** or **member** scope refers to a variable that is accessible anywhere
    in its containing class.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Local** scope refers to a variable that is only accessible inside the specific
    block of code it''s created in.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Take a look at the following screenshot. You don''t need to put this into `LearningCurve`
    if you don''t want to; it''s only for visualization purposes at this point:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17573_03_09.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.9: Diagram of different scopes in the LearningCurve script'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: When we talk about code blocks, we're referring to the area inside any set of
    curly brackets. These brackets serve as a kind of visual hierarchy in programming;
    the farther right-indented they are, the deeper they are nested in the class.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s break down the class and local scope variables in the preceding screenshot:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '`CharacterClass` is declared at the very top of the class, which means we can
    reference it by name anywhere inside `LearningCurve`. You might hear this concept
    referred to as variable visibility, which is a good way of thinking about it.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CharacterHealth` is declared inside the `Start()` method, which means it is
    only visible inside that block of code. We can still access `CharacterClass` from
    `Start()` with no issue, but if we attempted to access `CharacterHealth` from
    anywhere but `Start()`, we would get an error.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CharacterName` is in the same boat as `CharacterHealth`; it can only be accessed
    from the `CreateCharacter()` method. This was just to illustrate that there can
    be multiple, even nested, local scopes in a single class.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you spend enough time around programmers, you''ll hear discussions (or arguments,
    depending on the time of day) about the best place to declare a variable. The
    answer is simpler than you might think: variables should be declared with their
    use in mind. If you have a variable that needs to be accessed throughout a class,
    make it a class variable. If you only need a variable in a specific section of
    code, declare it as a local variable.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: Note that only class variables can be viewed in the Inspector window, which
    isn't an option for local or global variables.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: With naming and scope in our toolbox, let's transport ourselves back to middle
    school math class and relearn how arithmetic operations work all over again!
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: Introducing operators
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Operator symbols in programming languages represent the *arithmetic*, *assignment*,
    *relational*, and *logical* functionality that types can perform. Arithmetic operators
    represent basic math functions, while assignment operators perform math and assignment
    functions together on a given value. Relational and logical operators evaluate
    conditions between multiple values, such as *greater than*, *less than*, and *equal
    to*.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: C# also offers bitwise and miscellaneous operators, but these won't come into
    play for you until you're well on your way to creating more complex applications.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: At this point, it only makes sense to cover arithmetic and assignment operators,
    but we'll get to relational and logical functionality when it becomes relevant
    in the next chapter.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: Arithmetic and assignments
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You''re already familiar with the arithmetic operator symbols from school:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '`+` for addition'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-` for subtraction'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/` for division'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*` for multiplication'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'C# operators follow the conventional order of operations, that is, evaluating
    parentheses first, then exponents, then multiplication, then division, then addition,
    and finally subtraction. For instance, the following equations will provide different
    results, even though they contain the same values and operators:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Operators work the same when applied to variables as they do with literal values.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: 'Assignment operators can be used as a shorthand replacement for any math operation
    by using any arithmetic and equals symbol together. For example, if we wanted
    to multiply a variable, you could use the following code:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The second, alternative, way to do this is shown here:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The equals symbol is also considered an assignment operator in C#. The other
    assignment symbols follow the same syntax pattern as our preceding multiplication
    example: `+=`, `-=`, and `/=` for add and assign, subtract and assign, and divide
    and assign, respectively.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: 'Strings are a special case when it comes to operators as they can use the addition
    symbol to create patchwork text, as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This will produce the following when logged in to the **Console** panel:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17573_03_10.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.10: Using operators on strings'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: This approach tends to produce clunky code, making string interpolation the
    preferred method for putting together different bits of text in most cases.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: Take note that arithmetic operators don't work on all data types. For example,
    the `*` and `/` operators don't work on string values, and none of these operators
    work on Booleans. Having learned that types have rules that govern what kind of
    operations and interactions they can have, let's give it a shot in practice in
    the next section.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s do a little experiment: we''ll try to multiply our `string` and `float`
    variables together, as we did earlier with our numbers:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们做一个小实验：我们将尝试将我们的`string`和`float`变量相乘，就像我们之前对数字做的那样：
- en: '![](img/B17573_03_11.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_03_11.png)'
- en: 'Figure 3.11: Visual Studio incorrect type operation error message'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.11：Visual Studio不正确的类型操作错误消息
- en: Look at Visual Studio and you'll see we've got an error message letting us know
    that a `string` type and a `float` type can't be multiplied. This error will also
    show up in the Unity **Console**, and won't let the project build.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 看看 Visual Studio，您会看到我们收到了一个错误消息，告诉我们`string`类型和`float`类型不能相乘。这个错误也会显示在 Unity
    **控制台**中，并且不会让项目构建。
- en: '![](img/B17573_03_12.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_03_12.png)'
- en: 'Figure 3.12: Console showing operator errors on incompatible data types'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.12：控制台显示不兼容数据类型的运算符错误
- en: Whenever you see this type of error, go back and inspect your variable types
    for incompatibilities.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 每当您看到这种类型的错误时，回去检查变量类型是否不兼容。
- en: We must clean up this example, as the compiler won't allow us to run our game
    at this point. Choose between a pair of backslashes (`//`) at the beginning of
    the line `Debug.Log(FirstName*Pi)`, or delete it altogether.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须清理这个示例，因为编译器现在不允许我们运行游戏。在`Debug.Log(FirstName*Pi)`行的开头选择一对反斜杠(`//`)，或者将其完全删除。
- en: That's as far as we need to go in terms of variables and types for the moment.
    Be sure to test yourself on this chapter's quiz before moving on!
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们在变量和类型方面需要了解的全部内容。在继续之前，请务必在本章的测验中进行测试！
- en: Defining methods
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义方法
- en: In the previous chapter, we briefly touched on the role methods play in our
    programs; namely, that they store and execute instructions, just like variables
    store values. Now, we need to understand the syntax of method declarations and
    how they drive action and behavior in our classes.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们简要介绍了方法在我们的程序中扮演的角色；即，它们存储和执行指令，就像变量存储值一样。现在，我们需要理解方法声明的语法以及它们如何在我们的类中驱动行为和动作。
- en: 'As with variables, method declarations have their basic requirements, which
    are as follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 与变量一样，方法声明具有其基本要求，如下所示：
- en: The type of data that will be returned by the method
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法将返回的数据类型
- en: A unique name, starting with a capital letter
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个以大写字母开头的唯一名称
- en: A pair of parentheses following the method name
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法名后面跟着一对括号
- en: A pair of curly brackets marking the method body (where instructions are stored)
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一对花括号标记方法体（其中存储指令）
- en: 'Putting all of these rules together, we get a simple method blueprint:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有这些规则放在一起，我们得到一个简单的方法蓝图：
- en: '[PRE22]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Let''s break down the default `Start()` method in `LearningCurve` as a practical
    example:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解`LearningCurve`中的默认`Start()`方法作为一个实际示例：
- en: '[PRE23]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In the preceding output, we can see the following:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的输出中，我们可以看到以下内容：
- en: The method starts with the `void` keyword, which is used as the method's return
    type if it doesn't return any data.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法以`void`关键字开头，如果它不返回任何数据，则用作方法的返回类型。
- en: The method has a unique name within the class. You can use the same name in
    different classes, but you should aim to always make your names unique no matter
    what.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法在类中具有唯一的名称。您可以在不同的类中使用相同的名称，但无论如何，您都应该始终使您的名称唯一。
- en: The method has a pair of parentheses after its name to hold any potential parameters.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法在其名称后面有一对括号，用于保存任何潜在的参数。
- en: The method body is defined by a set of curly brackets.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法体由一组花括号定义。
- en: In general, if you have a method that has an empty method body, it's good practice
    to delete it from the class. You always want to be pruning your scripts of unused
    code.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，如果一个方法有一个空的方法体，最好将其从类中删除。您总是希望修剪您的脚本中未使用的代码。
- en: Like variables, methods can also have security levels. However, they can also
    have input parameters, both of which we'll be discussing next!
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 与变量一样，方法也可以具有安全级别。但是，它们也可以有输入参数，我们将在下一节讨论这两个方面！
- en: Declaring methods
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明方法
- en: Methods can also have the same four access modifiers that are available to variables,
    as well as input parameters. Parameters are variable placeholders that can be
    passed into methods and accessed inside them. The number of input parameters you
    can use isn't limited, but each one needs to be separated by a comma, show its
    data type, and have a unique name.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 方法也可以有与变量相同的四个访问修饰符，以及输入参数。参数是可以传递到方法中并在其中访问的变量占位符。您可以使用的输入参数数量没有限制，但每个参数都需要用逗号分隔，显示其数据类型，并具有唯一的名称。
- en: Think of method parameters as variable placeholders whose values can be used
    inside the method body.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 将方法参数视为变量占位符，其值可以在方法体内使用。
- en: 'If we apply these options, our updated blueprint will look like this:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们应用这些选项，我们的更新后的蓝图将如下所示：
- en: '[PRE24]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: If there is no explicit access modifier, the method defaults to private. A private
    method, like a private variable, cannot be called from other scripts.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有显式的访问修饰符，方法默认为私有。私有方法，就像私有变量一样，不能从其他脚本中调用。
- en: 'To call a method (meaning to run or execute its instructions), we simply use
    its name, followed by a pair of parentheses, with or without parameters, and cap
    it off with a semicolon:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用方法（即运行或执行其指令），我们只需使用其名称，后面跟一对括号，带有或不带有参数，并以分号结束：
- en: '[PRE25]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Like variables, every method has a fingerprint that describes its access level,
    return type, and parameters. This is called its method signature. Essentially,
    a method's signature marks it as unique to the compiler so Visual Studio knows
    what to do with it.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 与变量一样，每个方法都有一个指纹，描述其访问级别、返回类型和参数。这称为方法签名。基本上，方法的签名将其标记为编译器的唯一标识，因此 Visual Studio
    知道如何处理它。
- en: Now that we understand how methods are structured, let's create one of our own.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们了解了方法的结构，让我们创建一个自己的方法。
- en: 'The *Methods are placeholders too* section in the previous chapter had you
    blindly copy a method called `ComputeAge()` into `LearningCurve` without you knowing
    what you were getting into. This time, let''s purposefully create a method:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: Declare a `public` method with a void return type called `GenerateCharacter():`
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Add a simple `Debug.Log()` inside the new method and print out a character
    name from your favorite game or movie:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Call `GenerateCharacter()` inside the `Start()` method and hit play:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: When the game starts up, Unity automatically calls `Start()`, which, in turn,
    calls our `GenerateCharacter()` method and prints the result to the Console window.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: If you have read enough documentation, you'll see different terminology related
    to methods. Throughout the rest of this book, when a method is created or declared,
    I'll refer to this as **defining** a method. Similarly, I'll refer to running
    or executing a method as **calling** that method.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: The power of naming is integral to the entirety of the programming landscape,
    so it shouldn't be a surprise that we're going to revisit naming conventions for
    methods before moving on.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: Naming conventions
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Like variables, methods need unique, meaningful names to distinguish them in
    code. Methods drive actions, so it's a good practice to name them with that in
    mind. For example, `GenerateCharacter()` sounds like a command, which reads well
    when you call it in a script, whereas a name such as `Summary()` is bland and
    doesn't paint a very clear picture of what the method will accomplish. Like variables,
    method names are written in Pascal case.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: Methods as logic detours
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We've seen that lines of code execute sequentially in the order they're written,
    but bringing methods into the picture introduces a unique situation. Calling a
    method tells the program to take a detour into the method instructions, run them
    one by one, and then resume sequential execution where the method was called.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following screenshot and see whether you can figure out
    in what order the debug logs will be printed out to the console:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17573_03_13.png)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.13: Considering the order of debug logs'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the steps that occur:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '`Choose a character` prints out first because it''s the first line of code.'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When `GenerateCharacter()` is called, the program jumps to line 23, prints
    out `Character: Spike`, and then resumes execution at line 17.'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`A fine choice` prints out last, after all the lines in `GenerateCharacter()`
    have finished running.'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B17573_03_14.png)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.14: Console showing the output of character building code'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: Now, methods in themselves wouldn't be very useful beyond simple examples like
    these if we couldn't add parameter values to them, which is what we'll do next.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: Specifying parameters
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Chances are your methods aren''t always going to be as simple as `GenerateCharacter()`.
    To pass in additional information, we''ll need to define parameters that our method
    can accept and work with. Every method parameter is an instruction and needs to
    have two things:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: An explicit type
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A unique name
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does this sound familiar? Method parameters are essentially stripped-down variable
    declarations and perform the same function. Each parameter acts like a local variable,
    only accessible inside their specific method.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: You can have as many parameters as you need. Whether you're writing custom methods
    or using built-in ones, the parameters that are defined are what the method requires
    to perform its specified task.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: 'If parameters are the blueprint for the types of values a method can accept,
    then arguments are the values themselves. To break this down further, consider
    the following:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: The argument that's passed into a method needs to match the parameter type,
    just like a variable type and its value
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arguments can be literal values (for instance, the number 2) or variables declared
    elsewhere in the class
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Argument names and parameter names don't need to match to compile.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's move on and add some method parameters to make `GenerateCharacter()`
    a bit more interesting.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s update `GenerateCharacter()` so that it can take in two parameters:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: 'Add two method parameters: one for a character''s name of the `string` type,
    and another for a character''s level of the `int` type:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Update `Debug.Log()` so that it uses these new parameters:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Update the `GenerateCharacter()` method call in `Start()` with your arguments,
    which can be either literal values or declared variables:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Your code should look like the following:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17573_03_15.png)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.15: Updating the GenerateCharacter() method'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: Here, we defined two parameters, `name` (string) and `level` (int), and used
    them inside the `GenerateCharacter()` method, just like local variables. When
    we called the method inside `Start()`, we added argument values for each parameter
    with corresponding types. In the preceding screenshot, you can see that using
    the literal string value in quotations produced the same result as using `characterLevel`.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17573_03_16.png)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.16: Console showing the output from method parameters'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: Going even further with methods, you might be wondering how we can pass values
    from inside the method and back out again. This brings us to our next section
    on return values.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: Specifying return values
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Aside from accepting parameters, methods can return values of any C# type. All
    of our previous examples have used the `void` type, which doesn't return anything,
    but being able to write instructions and pass back computed results is where methods
    shine.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: According to our blueprints, method return types are specified after the access
    modifier. In addition to the type, the method needs to contain the `return` keyword,
    followed by the return value. A return value can be a variable, a literal value,
    or even an expression, as long as it matches the declared return type.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: Methods that have a return type of `void` can still use the return keyword with
    no value or expression assigned. Once the line with the return keyword is reached,
    the method will stop executing. This is useful in cases where you want to avoid
    certain behaviors or guard against program crashes.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, add a return type to `GenerateCharacter()` and learn how to capture it
    in a variable. Let''s update the `GenerateCharacter()` method so that it returns
    an integer:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the return type in the method declaration from `void` to `int`, and
    set the return value to `level += 5` using the `return` keyword:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '`GenerateCharacter()` will now return an integer. This is computed by adding
    `5` to the level argument. We haven''t specified how, or if, we want to use this
    return value, which means that right now, the script won''t do anything new.'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the question becomes: how do we capture and use the newly added return
    value? Well, we''ll discuss that very topic in the following section.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: Using return values
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When it comes to using return values, there are two approaches available:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: Create a local variable to capture (store) the returned value.
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the calling method itself as a stand-in for the returned value, using it
    just like a variable. The calling method is the actual line of code that fires
    the instructions, which, in our example, would be `GenerateCharacter("Spike",
    CharacterLevel)`. You can even pass a calling method into another method as an
    argument if need be.
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first option is preferred in most programming circles for its readability.
    Throwing around method calls as variables can get messy fast, especially when
    we use them as arguments in other methods.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: Let's give this a try in our code by capturing and debugging the return value
    that `GenerateCharacter()` returns.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re going to use both ways of capturing and using return variables with
    two simple debug logs:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new local variable in the `Start` method of the `int` type, called
    `NextSkillLevel`, and assign it to the return value of the `GenerateCharacter()`
    method call we already have in place:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Add two debug logs, with the first printing out `NextSkillLevel` and the second
    printing out a new calling method with argument values of your choice:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Comment out the debug log inside `GenerateCharacter()` with two forward slashes
    (`//`) to make the console output less cluttered. Your code should look like the
    following:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Save the file and hit play in Unity. To the compiler, the `NextSkillLevel` variable
    and the `GenerateCharacter()` method caller represent the same information, namely
    an integer, which is why both logs show the number `37`:![](img/B17573_03_17.png)
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 3.17: Console output from the character generation code'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: That was a lot to take in, especially given the exponential possibilities of
    methods with parameters and return values. However, we'll ease off the throttle
    here for a minute and consider some of Unity's most common methods to catch a
    little breathing room.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: But first, see if you can handle a challenge in the next *Hero's trial*!
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: Hero's trial – methods as arguments
  id: totrans-313
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you're feeling brave, why not try creating a new method that takes in an
    `int` parameter and simply prints it out to the console? No return type is necessary.
    When you've got that, call the method in `Start`, pass in a `GenerateCharacter`
    method call as its argument, and take a look at the output.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: Dissecting common Unity methods
  id: totrans-315
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''re now at a point where we can realistically discuss the most common default
    methods that come with any new Unity C# script: `Start()` and `Update()`. Unlike
    the methods we define ourselves, methods belonging to the `MonoBehaviour` class
    are called automatically by the Unity engine according to their respective rules.
    In most cases, it''s important to have at least one `MonoBehaviour` method in
    a script to kick off your code.'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: You can find a complete list of all available MonoBehaviour methods and their
    descriptions at [https://docs.unity3d.com/ScriptReference/MonoBehaviour.html](https://docs.unity3d.com/ScriptReference/MonoBehaviour.html).
    You can also find the order in which each method is executed at [https://docs.unity3d.com/Manual/ExecutionOrder.html](https://docs.unity3d.com/Manual/ExecutionOrder.html).
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: Just like stories, it's always a good idea to start at the beginning. So, naturally,
    we should take a look at every Unity script's first default method—`Start()`.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: The Start method
  id: totrans-319
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Unity calls the `Start()` method on the first frame where a script is enabled
    for the first time. Since `MonoBehaviour` scripts are almost always attached to
    *GameObjects* in a scene, their attached scripts are enabled at the same time
    they are loaded when you hit play. In our project, `LearningCurve`is attached
    to the **Main Camera** *GameObject*, which means that its `Start()` method runs
    when the main camera is loaded into the scene. `Start()` is primarily used to
    set up variables or perform logic that needs to happen before `Update()` runs
    for the first time.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: The examples we've worked on so far have all used `Start()`, even though they
    weren't performing setup actions, which isn't normally the way it would be used.
    However, it only fires once, making it an excellent tool to use for displaying
    one-time-only information on the console.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: 'Other than `Start()`, there''s one other major Unity method that you''ll run
    into by default: `Update()`. Let''s familiarize ourselves with how it works in
    the following section before we finish off this chapter.'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: The Update method
  id: totrans-323
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you spend enough time looking at the sample code in the Unity Scripting Reference
    ([https://docs.unity3d.com/ScriptReference/](https://docs.unity3d.com/ScriptReference/)),
    you'll notice that a vast majority of the code is executed using the `Update()`
    method. As your game runs, the Scene window is displayed many times per second,
    which is called the frame rate or **frames per second** (**FPS**).
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: After each frame is displayed, the `Update()` method is called by Unity, making
    it one of the most executed methods in your game. This makes it ideal for detecting
    mouse and keyboard input or running gameplay logic.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: 'If you''re curious about the FPS rating on your machine, hit play in Unity
    and click the **Stats** tab in the upper-right corner of the **Game** view:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17573_03_18.jpg)'
  id: totrans-327
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.18: Unity editor showing the Stats panel with graphics FPS count'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: You'll be using the `Start()` and `Update()` methods in the lion's share of
    your initial C# scripts, so get acquainted with them. That being said, you've
    reached the end of this chapter with a pocketful of the most fundamental building
    blocks programming with C# has to offer.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-330
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter has been a fast descent from the basic theory of programming and
    its building blocks into the strata of real code and C# syntax. We've seen good
    and bad forms of code formatting, learned how to debug information in the Unity
    console, and created our first variables.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: C# types, access modifiers, and variable scope weren't far behind, as we worked
    with member variables in the Inspector window and started venturing into the realm
    of methods and actions.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: Methods helped us to understand written instructions in code, but more importantly,
    how to properly harness their power into useful behaviors. Input parameters, return
    types, and method signatures are all important topics, but the real gift they
    offer is the potential for new kinds of actions to be performed.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: You're now armed with the two fundamental building blocks of programming; almost
    everything you'll do from now on will be an extension or application of these
    two concepts.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll take a look at a special subset of C# types called
    collections, which can store groups of related data, and learn how to write decision-based
    code.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: Pop quiz – variables and methods
  id: totrans-336
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the proper way to write a variable name in C#?
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you make a variable appear in Unity's Inspector window?
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the four access modifiers available in C#?
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When are explicit conversions needed between types?
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the minimum requirements for defining a method?
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the purpose of the parentheses at the end of the method name?
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does a return type of `void` mean in a method definition?
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How often is the `Update()` method called by Unity?
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: JOIN us on Discord!
  id: totrans-345
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Read this book alongside other users, Unity/C# experts, and Harrison Ferrone.
    Ask questions, provide solutions to other readers, chat with the author via *Ask
    Me Anything sessions* and much more.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: Join Now!
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/csharpunity2021](https://packt.link/csharpunity2021)'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code_9781801813945.png)'
  id: totrans-349
  prefs: []
  type: TYPE_IMG
