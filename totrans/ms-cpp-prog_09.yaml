- en: Debugging Techniques
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Effective debugging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging strategies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging your application using GDB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging memory leaks with Valgrind
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Effective debugging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Debugging is an art rather than a science, and it is a very big topic in itself.
    Strong debugging skills are the strengths of a good developer. All expert developers
    have some common traits, of which strong problem-solving and debugging skills
    top all. The first step in fixing a bug is to reproduce the issue. It is crucial
    to capture the steps involved in reproducing the bug very efficiently. Experienced
    QA engineers will know the importance of capturing detailed steps to reproduce,
    as developers will find it difficult to fix an issue if they can't reproduce it.
  prefs: []
  type: TYPE_NORMAL
- en: From my point of view, a bug that can't be reproduced can't be fixed. One could
    make guesses and beat around the bush but can't be sure whether the issue has
    really been fixed without being able to reproduce the bug in the first place.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following details will help developers reproduce and debug the issue more
    quickly:'
  prefs: []
  type: TYPE_NORMAL
- en: Detailed steps to reproduce the issue
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Screenshot images of the bug
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Priority and severity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inputs and scenarios that reproduce the issue
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Expected and actual output
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Error logs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application logs and traces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dump files in case the application crashes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Environment details
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OS details
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Software versions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some commonly used debugging techniques are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Use of the `cout`/`cerr` print statements comes in really handy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Core dumps, mini dumps, and full dumps help analyze the bug remotely
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using debugging tools to execute the code step by step by inspecting variables,
    arguments, intermediate values, and so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test frameworks help prevent the issue in the first place
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance analysis tools can be of great help in finding performance issues
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tools that deduct memory leaks, resource leaks, deadlocks, and so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `log4cpp` open source C++ library is an elegant and useful log utility which
    helps add debug messages that support debugging, which can be disabled in the
    release mode or in the production environment.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging strategies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Debugging strategies help a great deal in quickly reproducing, debugging, detecting,
    and fixing issues efficiently. The following list explains some high-level debugging
    strategies:'
  prefs: []
  type: TYPE_NORMAL
- en: Using a defect tracking system, such as JIRA, Bugzilla, TFS, YouTrack, Teamwork,
    and others
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application crashes or freezes must include core dumps, mini dumps, or full
    dumps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application trace logs are a great aid and help in all scenarios
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enabling multilevel error logs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Capturing application trace logs in debug and release modes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Debugging tools help narrow down the issue through step-by-step execution, with
    breakpoints, variable inspection, and so on. Though debugging the issue step by
    step may be a time-consuming task, it is definitely a sure-shot way of nailing
    down the issue, and I can say that it pretty much always works.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a list of debugging tools for C++:'
  prefs: []
  type: TYPE_NORMAL
- en: '**GDB**: This is an open source CLI debugger'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Valgrind**: This is an open source CLI, good for memory leaks, deadlocks,
    racing detection, and so on'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Affinic debugger**: This is a commercial GUI tool for GDB'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GNU DDD**: This is an open source graphical debugger for GDB, DBX, JDB, XDB,
    and so on'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GNU Emacs GDB mode**: This is an open source tool with minimal graphical
    debugger support'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**KDevelop**: This is an open source tool with graphical debugger support'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Nemiver**: This is an open source tool that works well in the GNOME desktop
    environment'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SlickEdit**: This is good for debugging multithreaded and multiprocessor
    code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In C++, there are quite a lot of open source and commercially licensed debugging
    tools. However, in this book, we will explore the GDB and Valgrind open source
    command-line interface tools.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging your application using GDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Classic, old-fashioned C++ developers use print statements to debug code. However,
    debugging with print tracing messages is a time-consuming task, as you need to
    put quite a lot of effort into writing print statements at multiples places, recompiling,
    and executing the application.
  prefs: []
  type: TYPE_NORMAL
- en: The old-style debugging approach requires many such iterations and, typically,
    every iteration requires adding more print statements in order to narrow down
    the issue. Once the issues are fixed, we need to clean up the code and remove
    the print statements, as too many print statements tend to slow down application
    performance. Also, the debug print messages will distract and are irrelevant for
    the end customers using your product the production environment.
  prefs: []
  type: TYPE_NORMAL
- en: The C++ debug `assert()` macro statement that comes with the `<cassert>` header
    can be used for debugging.  The C++ `assert()` macros can be disabled in release
    mode and are only enabled in debug mode.
  prefs: []
  type: TYPE_NORMAL
- en: Debug tools are there to rescue you from such tedious efforts. The GDB debugger
    is an open source CLI tool, which is the debugger for C++ in the Unix/Linux world.
    For Windows platforms, Visual Studio is the most popular one-stop IDE with inbuilt
    debugging facilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the program is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'However, our expected output is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The bug is obvious; let''s go easy with GDB learning. Let''s first compile
    the program in debug mode, that is, with the debugging metadata and symbol table
    enabled, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: GDB commands quick reference
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following GDB quick tips chart will help you find the GDB commands for
    debugging your applications:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Command** | **Short command** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `gdb yourappln.exe` | `-` | Opening an application in GDB for debugging |'
  prefs: []
  type: TYPE_TB
- en: '| `break main` | `b main` | Set the breakpoint to the `main` function |'
  prefs: []
  type: TYPE_TB
- en: '| `run` | `r` | Executes the program till it reaches the breakpoint for step-by-step
    execution |'
  prefs: []
  type: TYPE_TB
- en: '| `next` | `n` | Executes the program one step at a time |'
  prefs: []
  type: TYPE_TB
- en: '| `step` | `s` | Steps into the function to execute the function step by step
    |'
  prefs: []
  type: TYPE_TB
- en: '| `continue` | `c` | Continues the execution of the program until the next
    breakpoint; if no breakpoints are set, it will continue the execution of the application
    normally |'
  prefs: []
  type: TYPE_TB
- en: '| `backtrace` | `bt` | Prints the entire call stack |'
  prefs: []
  type: TYPE_TB
- en: '| `quit` | `q` or`Ctrl + d`  | Exits GDB |'
  prefs: []
  type: TYPE_TB
- en: '| `-help` | `-h` | Displays the available options and briefly displays their
    use |'
  prefs: []
  type: TYPE_TB
- en: 'With the preceding basic GDB quick reference, let''s start debugging our faulty
    application to detect the bug. Let''s first start GDB with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, let''s add a breakpoint at `main()` to perform step-by-step execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'After launching our application with `gdb`, the `b main` command will add a
    breakpoint to the first line of the `main()` function. Now let''s try to execute
    the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As you may have observed, the program execution has paused at line number `46`
    in our `main()` function, since we added a breakpoint to the `main()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, let''s execute the application step by step, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s add two more breakpoints at line numbers `29` and `33`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'From this, you will understand that the breakpoints can be added by the function
    name or by the line numbers as well. Let''s now let the program continue its execution
    until it reaches one of the breakpoints that we have set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the program execution paused at line number `29`, as it gets
    invoked whenever the `sort` function needs to decide whether the two items must
    be swapped in the process of sorting the vector entries in an ascending order.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s explore how to inspect or print the variables, `this->number` and `rhsObject.number`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Did you see the way the `<` and `>` operators are implemented? The operator
    checks for the *less than* operation, while the actual implementation checks for
    the *greater than* operation, and a similar bug is observed in the `>` operator-overloaded
    method as well. Please check the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'While the `sort()` function is supposed to be sorting the `vector` entries
    in an ascending order, the output shows that it is sorting them in a descending
    order, and the preceding code is the root cause of the issue. Hence, let''s fix
    the issue, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'With these changes, let''s compile and run the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the output that you''ll get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Cool, we fixed the bug! Needless to say, you will have recognized how useful
    the GDB debugging tool is.  While we have only scratched the surface of  the GDB
    tool's capability, it offers many powerful debugging features. However, in this
    chapter, it would be impractical to cover every single feature the GDB tool supports;
    hence, I would strongly recommend you explore GDB documentation for further learning
    at [https://sourceware.org/gdb/documentation/](https://sourceware.org/gdb/documentation/).
  prefs: []
  type: TYPE_NORMAL
- en: Debugging memory leaks with Valgrind
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Valgrind is a collection of open source C/C++ debugging and profiling tools
    for the Unix and Linux platforms. The collection of tools that Valgrind supports
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Cachegrind**: This is the cache profiler'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Callgrind**: This works in a similar manner to the cache profiler but supports
    the caller-callee sequence'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Helgrind**: This helps in detecting thread synchronization issues'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DRD**: This is the thread error detector'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Massif**: This is the heap profiler'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lackey**: This provides basic performance-related statistics and measurements
    about your application'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**exp-sgcheck**: This detects stack overruns; it is generally useful in finding
    issues that Memcheck can''t find'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**exp-bbv**: This is useful for computer architecture R&D-related work'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**exp-dhat**: This is another heap profiler'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Memcheck**: This helps in detecting memory leaks and crashes related to memory
    issues'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we will only be exploring Memcheck, as demonstrating every
    Valgrind tool is not in the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: The Memcheck tool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The default tool that Valgrind uses is Memcheck.  The Memcheck tool can detect
    quite an exhaustive list of issues, and some of them are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Accessing outside the boundary of array, stack, or heap overruns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use of uninitialized memory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing the already released memory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory leaks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mismatched use of `new` and `free` or `malloc` and `delete`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's have a look at some such issues in the next subsections.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting memory access outside the boundary of an array
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following example demonstrates memory access outside the boundary of an
    array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The following output shows the valgrind debug session that precisely points
    to memory access outside the boundary of the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As you will notice, the application crashed with core dump due to illegal memory
    access.  In the preceding output, the Valgrind tool accurately points to the line
    that caused the crash.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting memory access to already released memory locations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following example code demonstrates memory access to the already released
    memory locations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s compile the preceding program and learn how Valgrind reports the illegal
    memory access that attempts to access an already released memory location:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Valgrind precisely points to the line number (`14`) that attempts to access
    the memory location that got released at line number `12`.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting uninitialized memory access
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following example code demonstrates the use of uninitialized memory access
    and how the same can be detected using Memcheck:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now compile and detect the uninitialized memory access issue using Memcheck:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The lines highlighted in bold in the preceding output clearly point to the
    exact line where the uninitialized variable is accessed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code snippet is shown for your reference; however, Valgrind will
    not show the code details.  The bottomline is that Valgrind precisely points to
    the line that accesses the uninitialized variable, which is normally difficult
    to detect using other means.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting memory leaks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s take a simple program that has some memory leaks and explore how the
    Valgrind tool, with the help of Memcheck, can help us detect memory leaks. As
    Memcheck is the default tool used by Valgrind, it is not necessary to explicitly
    call out the Memcheck tool while issuing the Valgrind command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code implements a singly linked list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: As you may have observed, the preceding class declaration has methods to `append()`
    a new node, `print()` the list, and a `size()` method that returns the number
    of nodes in the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s explore the `list.cpp` source file that implements the `append()` method,
    the `print()` method, the constructor, and the destructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code demonstrates the `main()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s compile the program and attempt to detect memory leaks in the preceding
    program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: From the preceding output, it is evident that 80 bytes are leaked by our application.
    While `definitely lost` and `indirectly lost` indicate the memory leaked by our
    application, `still reachable` does not necessarily indicate our application,
    and it could be leaked by third-party libraries or C++ runtime libraries. It may
    be possible that they are not really memory leaks, as the C++ runtime library
    might use memory pools.
  prefs: []
  type: TYPE_NORMAL
- en: Fixing the memory leaks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s try to fix the memory leak issue by adding the following code in the
    `List::~List()` destructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'From the following output, you will observe that the memory leak has been fixed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are still not convinced with the `still reachable` issue reported in
    the preceding output, let''s try the following code in `simple.cpp` to understand
    if this is something in our control:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the `main()` function does nothing but return `0`, and Valgrind
    reports that this program too has the same section: `still reachable": 72, 704
    bytes in 1 blocks`.  Hence, what really matters in the `Valgrind` leak summary
    is whether there are leaks reported under any or all of the following sections:
    `definitely lost`, `indirectly lost`, and `possibly lost`.'
  prefs: []
  type: TYPE_NORMAL
- en: Mismatched use of new and free or malloc and delete
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: These types of issues are rare but the possibility of them occurring can't be
    ruled out. It may so happen that when a legacy C-based tool is ported to C++,
    that some memory allocation is allocated by mistake but is freed up using the
    `delete` keyword or vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example demonstrates detecting the issue using Valgrind:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The following output demonstrates a Valgrind session that detects mismatched
    usage of `free` and `delete`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about various C++ debugging tools and the applications
    of the Valgrind tool, such as detecting uninitialized variable access and detecting
    memory leaks. You also learned about the GDB tool and detecting issues that arise
    due to illegal memory access of the already released memory locations.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will be learning about code smells and clean code practices.
  prefs: []
  type: TYPE_NORMAL
