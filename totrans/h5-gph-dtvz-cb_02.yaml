- en: Chapter 2. Advanced Drawing in Canvas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Drawing arcs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drawing curves with a control point
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a Bezier curve
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating images into our art
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drawing with text
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding pixel manipulation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is the last chapter where we will dig deep into canvas as the remaining
    chapters will focus on building charts and interactivity.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will continue to master our skills with canvas by adding
    curves, images, text, and even pixel manipulation to our tool belt.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing arcs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are three types of curves we can create in canvas—using the arc, quadratic
    curves, and Bezier curves. Let's get started.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you recall in [Chapter 1](ch01.html "Chapter 1. Drawing Shapes in Canvas"),
    *Drawing Shapes in Canvas*, in our first recipe we used the arc method to create
    perfect circles. The arc method is much more than just that. We can actually create
    any partial curve in a circular shape. If you don't recall drawing circles, I
    strongly encourage you to scan through [Chapter 1](ch01.html "Chapter 1. Drawing
    Shapes in Canvas"), *Drawing Shapes in Canvas* again, and while you are there,
    you will find the template for creating the HTML documents as well. We are exclusively
    going to focus on the JavaScript code in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s jump into it and create our first noncircle that has curves:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Access the `pacman` canvas element and fetch its width and height by using
    the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `radian` variable (one degree in radians):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Get the canvas context and fill its background in black by using the following
    code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Begin a new path before starting to draw:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Change fill style color:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Move the pointer to the center of the screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Draw a curve that starts at 40 degrees and ends at 320 degrees (with a radius
    of 40) in the center of the screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Close the shape by drawing a line back to the starting point of our shape:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Close the path and fill the shape:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: You have just created a PacMan.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For the first time, we take advantage and create a pie-type shape, known as
    PacMan (you can see how this can be very useful when we get into creating the
    pie graph). Very simple—again we connect to that idea of radians:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice how our 4th and 5th parameters—instead of being a complete circle by
    starting from 0 and ending at `2*Math.PI`—are setting the angle to start the arc
    at radian 40 and end at radian 320 (leaving 80 degrees open to create the mouth
    of a PacMan ). All that is left is to start drawing from the center of the circle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We start by moving our pointer to the center of our circle. We then create the
    arc. As our arc isn't a complete shape it's continuing where we left off—drawing
    a line from the center of the arc to the starting point (40 degrees). We complete
    the action by drawing a line back to the center of the arc to complete the shape.
    Now we are ready to fill it and complete our work.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/3707OT_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now that we have got arcs out of the way, you can see how useful this will be
    for creating pie charts.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing curves with a control point
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If the world was just two points with a perfect arc this would be the end of
    the book, but alas or lucky for us, there are still many more complex shapes to
    learn and explore. There are many curves that are not perfectly aligned curves.
    Till now all the curves that we created were part of a perfect circle, but not
    any more. In this recipe, we will explore quadratic curves. The quadratic curves
    enable us to create curves that are not circular, by adding a third point—a controller
    to control the curve. You can easily understand this by looking at the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Drawing curves with a control point](img/3707OT_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A **quadratic curve** is a curve that has one control point. Consider the case
    when creating a line, we draw it between two points (A and B in this illustration).
    When we want to create a quadratic curve, we use an external gravity controller
    that defines the direction of the curve while the middle line (the dotted line)
    defines how far will the curve reach.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As done in previous recipes, we are skipping the HTML part here too—not that
    it's not needed, it just repeats itself in every recipe and if you need to refresh
    yourself on how to get the HTML setup, please take a look at the *Graphics with
    2D Canvas* recipe in [Chapter 1](ch01.html "Chapter 1. Drawing Shapes in Canvas"),
    *Drawing Shapes in Canvas*.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this example, we will create a closed shape that looks like a very basic
    eye. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We always need to start with extracting our canvas element, setting up our
    width and height variables, and defining a radian (as we find it useful to have
    one around):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, fill our canvas with a solid color and after that begin a new shape by
    triggering the `beginPath` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the line width and stroke color for our eye shape:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Move our drawing pointer to the left-centered point as we will need to draw
    a line from left to right in the center of the screen and back (only with a curve):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Draw two quadratic curves from our initial point to the other side of the canvas
    and back to the initial point by using an anchor point, which is in the extreme
    top followed by the extreme bottom of the canvas area:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Close the path. Fill the shape and use the `stroke` method on the shape (`fill`
    for filling the content and `stroke` for outlines):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Great job! You have just created your first shape by using the `quadraticCurveTo`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s look at this method closely:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: As we are already at the origin point (point A), we input two other points—the
    control point and point B.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In our sample, we create a contained shape—the starting point to create an eye.
    Play with the controller to see how it affects the direction and size of the curve.
    The thumb rule is that the closer to the vertical line the less steep the curve
    will be, and the further away it is from the center point the more curved shape
    would be to the offset.
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/3707OT_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Creating a Bezier curve
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've just learned that with the quadratic curve we have one control point.
    Although we can do many things with one control point, we don't really have full
    control over the curve. So let's take it one step further by adding one more control
    point. Adding a second control point actually adds the relationship between these
    two points as well making it three control factors. If we include the actual anchor
    points (we have got two of them), we end up with five points that control the
    shape of the curve. That does sound complicated; it's because the more control
    we get the more complicated it is to actually understand how it works. It's really
    not easy to figure out complicated curves by code alone and as such we actually
    use other tools to help us figure out the right curves.
  prefs: []
  type: TYPE_NORMAL
- en: To prove the preceding point, we can find a very complex shape and start with
    that one (don't worry, later on in this recipe, we will practice on a very simple
    shape to make the concept clear). We will pick to draw the flag of Canada and
    mainly the maple leaf.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a Bezier curve](img/3707OT_02_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe is difficult to understand, but we will break it down into details
    in the following *How it works...* section. So if you are new to curves, I strongly
    encourage you to start learning from this *How it works...* section before implementing
    it.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s create the flag of Canada. Let''s jump right into the JavaScript code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the canvas and context:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Fill the background to match the background of the Canadian flag:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Begin a new path and move the pointer to `84,19`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Draw curves and lines to create the maple leaf:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Close the path and fill the shape:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Now, you have created the flag of Canada. I don't know if you already know why
    it works or how we got to the apparently random numbers that we put into our curves
    to create the flag, but you've created the flag of Canada! Don't worry, we are
    about to decrypt the magic of curves right away in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we can explain the details of how the Canadian flag works, we should
    take a step back and create a simpler example. In this short example, we will
    create an oval shape by using the `bezierCurveTo` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s it. The following is the outcome you get out of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/3707OT_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If you get this, you are in great shape. We will now explain how this works
    and then move into how we figured out all the points for the Canadian flag. We
    are taking advantage of the full canvas again and we are keeping our controllers
    under control by setting two of our controllers to be the corners of the canvas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Play around with the controllers to see how much more control you get by using
    two dots—this is very useful when you need more detailed control over a curve.
  prefs: []
  type: TYPE_NORMAL
- en: This is the heart of the full example of our full flag. I strongly encourage
    you to explore the effects of changing the values of the control points to get
    a better understanding and sensitivity to it. It's time for us to get back to
    our flag and see how we structured it.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s time to take our most complex drawing style—Bezier curves—and put them
    to action with something a bit more interesting than an oval. I have a confession:
    when I decided to create the flag of Canada from scratch I got scared. I was thinking
    "How am I going to get this done? This is going to take me hours," and then it
    hit me... it was clear that this flag needs to be created with a lot of Bezier
    points but how would I know where the points should be? So for a shape this advanced,
    I opened up my graphics editor (in my case, Flash Editor) and added pivot points
    to the maple shape:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/3707OT_02_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you closely look at the previous diagram, I basically traced the flag of
    Canada and placed a black dot on every sharp corner. Then I created a canvas and
    drew lines to see if the base shape I got was in the right overall position (by
    the way, I got the dots just by selecting the dots in Flash to see if their (x,
    y) coordinates as Flash and canvas coordinate systems are the same).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: I got a shape that was far from what I was looking for. But now I knew that
    my shape was getting formed in the right direction. What were missing were the
    curves to connect between the dots. If you look at the preceding diagram again,
    you will notice that I've placed two blue points between each sharp corner to
    define where the curves would be and how sharp or soft they would be. I then moved
    back into canvas and then updated the values to have the two control points. I
    added all the curves and switched from creating strokes to creating a fill.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Bingo! I just got an almost perfect flag and I feel this is enough for this
    sample.
  prefs: []
  type: TYPE_NORMAL
- en: Don't try to create very complex shapes on your own just yet. Maybe there are
    a few people out there who can do that, but for the rest of us the best way to
    do it is to trace the elements by using a visual editor of some sort. We can then
    grab the graphic information and update the values in canvas as I've done with
    the Canadian flag example.
  prefs: []
  type: TYPE_NORMAL
- en: At this stage, we have covered the most complex shapes that we can cover in
    canvas. The rest of the chapter is dedicated to other ways of manipulating content
    on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating images into our art
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lucky for us, we don't need to start from scratch always and we can leave the
    more complex art for external images. Let's figure out how we can integrate images
    into our canvas.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We've been in a flag theme in this chapter and getting another flag under our
    belt sounds real good to me right now. So let's turn our heads to Haiti and get
    their flag up and running. To create this flag, we need to have the image of the
    symbol that is placed in the center of the flag.
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/3707OT_02_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the source files, you will find an image of the center graphic (at `img/haiti.png`).
    By the way, when integrating art into canvas it's always best to avoid resizing
    the image whenever possible via code to preserve the image quality.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will prepare the background to match the flag and then put the entire image
    above it in the center of the canvas/flag:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow the basic steps that we need to access the canvas. Set the width, height,
    and the actual context:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Draw the background elements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new `Image` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Create an `onLoad` function (that will be called when the image is loaded):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Set the source of the image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Yes, it's that easy to add images into canvas, but let's review more deeply
    what we have just done.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The steps involved in creating an image are downloading its data and then creating
    a new image container in the same way as it is done in canvas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to create a listener that will be triggered when the image
    is loaded and ready to be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The last step in the loading process is to tell canvas what image should be
    loaded. In our case we are loading `img/haiti.png`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Loading an image and having it ready to be used is only the first step. If we
    ran our application without actually telling canvas what to do with it, nothing
    would happen beyond the loading of the image.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, when our listener is triggered, we add the image as it is to the
    center of the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: That is all it takes to integrate an image into a canvas project.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are more operations that we can do with images in canvas beyond using
    them as backgrounds. We can define exactly what parts of the image we want (scaling).
    We can resize and manipulate the full image (scaling). We can even pixel manipulate
    our images. There are many things that we can do with images, but in the next
    few topics we will cover some of the more often used ones.
  prefs: []
  type: TYPE_NORMAL
- en: Scaling images
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can scale the image by adding two more parameters to the `drawImage` function,
    which sets the width and height of our image. Try the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: In the previous sample, we are loading the same image but we are forcing a resized
    image (note that the positions are not going to be in the actual center of the
    stage).
  prefs: []
  type: TYPE_NORMAL
- en: Adding even more control
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can control many aspects of an image. If you need more control than the
    preceding sample, you would need to input the full number of possible coordinates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the order has changed (notice that!). Now, the first two parameters
    after `this` are the local x and y coordinates of the image followed by the width
    and height (creating the crop that we were talking about) followed by the position
    on the canvas and its controlling information (x, y, width, and height).
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code line means we want to take the image from its internal position
    of (25,25) and we want to slice a 20 x 20 rectangle out of there. We then want
    to position this new cropped image at (0,0) that is, the top corner of the canvas
    and we want that output to be a 50 x 50 rectangle.
  prefs: []
  type: TYPE_NORMAL
- en: Using images as a fill
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can use our loaded image as a way to fill up objects as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'After the image is loaded (always after the image is loaded, you start manipulating
    it), we create a pattern that repeats based on our image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then use this pattern as our fill. So in this case, we are calling the
    `createStar` that we created in an earlier task—drawing a star in the center of
    the screen—by using the following pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: This ends our flag obsession to move on to shapes that just don't appear in
    flags. By the way, at this stage you should be able to create all the flags in
    the world and take advantage of integrating images when it's just not fun to draw
    it yourself from scratch—such as detailed country logos.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing with text
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I agree, we've been working on some complicated things. Now, its time for us
    to lay back, kick off the shoes, and do something a bit easier.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The good news is, if you are on this page, you should already know the basics
    of getting a canvas up and running. So there isn't much more that you need to
    do besides picking the font, size, and position of your text.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here, we aren't covering how you can embed fonts that aren't created within
    JavaScript, but instead, via CSS, we will use a basic font and hope for the best
    in this sample.
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/3707OT_02_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this example, we are going to create a text field. In this process, we are
    going to use gradients and shadows for the first time. Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Gain access to the canvas 2D API:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a gradient style and fill the background with it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a gradient to be used by the text:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the font to be used and set the style:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Add shadow details before drawing the text:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Use `fillText` to fill the shape and `strokeText` for outlines of the shape
    (notice that I call the text a shape; this is because as soon as we draw it, it
    will just be a part of our canvas and not live text):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: That's it, we just integrated our first drawn text into canvas.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Until now, we were stuck with the solid colors. We will now break out of that
    and move to a new world of gradient colors. Refer to the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'There are a few steps involved with creating a gradient. The first step is
    defining its scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Contrary to many other languages, it's really easy to define the rotation and
    size of a gradient in canvas. If you have worked with Photoshop before, you will
    find this really easy (even if you haven't, it will be easy).
  prefs: []
  type: TYPE_NORMAL
- en: 'All you need to do is define where you want the gradient to start and where
    you want it to end. You can send two dots into the method `createLinearGradient`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: In this transition, we are using only two colors. Position them at a value between
    0 and 1\. These values are ratios, so we are, in other words, requesting to spread
    the color transition from the start of the gradient area all the way to the end.
    We could add more colors, but our goal is to bind them all within the ratio 0
    to 1\. The more colors you add, the more playing around you would need to do with
    the values sent into the first parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'You just completed creating a gradient. Time to use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: In this part again, we will use the `fillStyle` method and then create a rectangle.
  prefs: []
  type: TYPE_NORMAL
- en: Please note the importance of the range of values that you may send to the `addColorStop`
    method. As you add more colors into your gradient, the more noticeable the importance
    of the values sent here will be. The points are not counters but ratios of colors
    in our sample. The transition is between the two colors' range from 0 to 1 or
    in other words they transition all the way through from our first point that we
    send into the `createLinearGradient` method all the to the last point. As we are
    working with two colors, this is the perfect ratio for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although we are not getting into radial gradients, they should be really easy
    for you as we have already learned a lot about radial shapes and gradients. The
    signature of this method is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The only difference here is that our shape is a radial shape. We also want to
    add the starting radius and ending radius into it. You might be wondering why
    we need two or even more radii. So why can't we figure out the radius based on
    the distance between the two dots (start point and end point)? I hope you are
    wondering about that and if you are not, wonder about it for a second before reading
    the next paragraph.
  prefs: []
  type: TYPE_NORMAL
- en: We have a separate control over the radius, mainly to enable us to separate
    the radius and to enable us to move the focal point within the drawing without
    changing the actual art or recalculating the ratios of colors. A really great
    way to see this in use is when drawing the moon. The moon's gradients over time
    will change or more accurately the radius of the colors and position of the radius
    would change over time depending on the moon's position compared to the sun.
  prefs: []
  type: TYPE_NORMAL
- en: We are not done yet. We just mastered everything that we need to know about
    gradients and it's time for us to integrate some text into it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: We set the global font value and then create a new text element. The `fillText`
    method gets three parameters; the first is the text to be used while the other
    two are the x and y positions of the new element.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: In our example, we are giving our text drawing both a fill and an outline. The
    two functions are called separately. The `fillText` method is used to fill the
    content of the shape while the `strokeText` method is called to outline the text.
    We can use any one of them or both of the methods and they can get the exactly
    same parameters.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are some more options that you can explore.
  prefs: []
  type: TYPE_NORMAL
- en: Using gradients in your text
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you can do anything to any graphical element in canvas, you can do it to
    text as well—for example, in our sample we are using a gradient for our text.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we are updating our gradient. Our last gradient was too big for
    such a small text area. As such, we are drawing a line from around the start of
    our text going horizontally for 110 pixels.
  prefs: []
  type: TYPE_NORMAL
- en: Adding shadows and glows
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can add a shadow/glow to any filled element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: You can control the position of the offset of the shadow. In our case, we want
    it to be a glow, so we placed our shadow exactly under our element. When setting
    the blur values to a shadow, try using values that are powers of 2 for efficiency
    (its easier to render values that are powers of 2).
  prefs: []
  type: TYPE_NORMAL
- en: Notice that when we defined our shadow color, we opted to use an RGBA as we
    wanted to set that alpha value to 50 percent.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding pixel manipulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you have mastered drawing in canvas, it's time for us to turn to a
    new aspect of working with canvas. In canvas, you can manipulate pixels. It's
    not only a vector drawing tool, but a very smart pixel editor (raster).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we are about to start reading data that is present on the canvas, we
    need to understand how security works when it comes to pixels. In an effort to
    protect content that isn't yours, there are security issues involved in working
    with data that isn't hosted on the same host as yours. We will not cover these
    security issues in this section and will be always working with images in the
    same domain as our code (or all locally).
  prefs: []
  type: TYPE_NORMAL
- en: Your first step is to find an image that you wish to work with (I've added an
    old image of my own into the source files). In this sample, we will recreate a
    pixel fade-out animation—really cool and useful for slides.
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/3707OT_02_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s get our code working and then break it down to see how it works. Perform
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a few helper global variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Create an `init` function (for the rest of the steps, all code will be in this
    function):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a context variable for the 2D Canvas API:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the `onload` listener logic:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the image source:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new function called `fadeOutImage`. This image will transition our
    image in:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Your outcome should look something like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/3707OT_02_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will skip explaining things that we have already covered in earlier samples
    such as how to load images and how to work with the `drawImage` method (covered
    in the *Integrating images into our art* recipe discussed earlier in this chapter).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: We will see the usage of these variables in our code, but all these variables
    have been saved as global variables so there is no need to redefine them in our
    functions. By defining these variables once, we improve the efficiency of our
    application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The real new logic starts within the `onLoad` listener. Right after we draw
    our image onto the canvas, our new logic is added. It is highlighted in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: We are now taking advantage of storing information in our canvas area and storing
    it globally. The first variable we are storing is `imageData`. This variable contains
    all the information of our canvas. We get this variable by calling the `context.getImageData`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: The `getImageData` function returns every single pixel for a rectangular area.
    We need to set it by defining the area we want. In our case, we want the full
    canvas area as our image is set in the full canvas area.
  prefs: []
  type: TYPE_NORMAL
- en: The returned object (`imageData`) stores the direct access to the pixel data
    information in its data property (`imageData.data`) and this is our main focus
    while working directly with pixels. This object contains all the color information
    for each pixel in our canvas. The information is stored in four cells (red, green,
    blue, and alpha). In other words, if there are 100 pixels in total in our application,
    we would expect our array to contain 400 cells in the `imageData.data` array.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last thing left to do before finishing the logic in our `onLoad` listener
    is to trigger our animation that will transition our image; to do that we will
    add an interval as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Our animation is triggered after every 25 milliseconds until it's completed.
    The logic that fades our view happens within our `fadeOutImage` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have got all the prep work done, it''s time to delve into the `fadeoutImage`
    function. Here, we will be doing the actual pixel manipulation logic. The first
    step in this function is to create a variable that will count how many changes
    our `imageData.data` array has made. When we hit the required number of changes,
    we terminate our interval (or in a real application maybe animate the next image):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'We now start to run through all the pixels by using a `for` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Each pixel stores RGBA values, thus, every pixel gets four positions in our
    array and as such we are jumping four steps at a time to move between pixels.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: When we are done with manipulating our data, it's time for us to update our
    canvas. To do that we just need to send our new data back into our context. The
    second and third parameters are for the x and y starting point.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: When we have no more changes (you can adjust that to fit your wishes such as
    when there are less than 100 pixels changed), we terminate the interval and trigger
    an alert.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our `for` loop, we will lower the values of red, green, and blue until they
    get to 0\. In our case, as we are counting changes we also add the counter into
    the loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Earlier we mentioned that each pixel gets four cells of information in the array.
    The first three cells store the RGB values, while the fourth stores the alpha
    channel. As such I thought it would be important to notice that we are skipping
    position `i+3` as we don't want the alpha channel to get affected. Every element
    in the `pixelData` array is a value between `0` and `255`. In other words, if
    that pixel's value was `#ffffff` (white), all three RGB cells would be equal to
    `255`. By the way, it would take 255 calls to our function to get the values down
    to `0` as the value in the cells would start from `255` and go down by 1 each
    time.
  prefs: []
  type: TYPE_NORMAL
- en: We always skip the position `i+3`, as we don't want to change anything in our
    array. Our values are between `255` and `0`; in other words, if our image has
    a value `#ffffff` (totally white pixel), it would go down `255` times for our
    function to get `0`.
  prefs: []
  type: TYPE_NORMAL
- en: Making an image grayscale
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To make an image or our canvas grayscale, we need to take all of our colors
    (red, green, blue) into account and mix them together. After mixing them together,
    get to a brightness value, which we can then apply to all the pixels. Let''s see
    it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we are taking the red (`pixelData[i]`), green (`pixelData[i+1]`),
    and blue (`pixelData[i+2]`), and using a one third of each to combine together
    to get one color and then we are assigning them all with this new averaged value.
  prefs: []
  type: TYPE_NORMAL
- en: Try only changing two out of the three values and see what comes out.
  prefs: []
  type: TYPE_NORMAL
- en: Pixel reversing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Color reversing an image is very easy as all we need to do is flip its value
    pixel by pixel by taking the maximum possible value (`255`) and subtracting the
    current value from it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: There you go! We visited a few options of pixel manipulation, but the limit
    is really just up to your imagination. Experiment, you never know what might come
    out of it!
  prefs: []
  type: TYPE_NORMAL
