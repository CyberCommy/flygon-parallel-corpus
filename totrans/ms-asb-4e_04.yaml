- en: '*Chapter 3*: Protecting Your Secrets with Ansible'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Secrets are meant to stay secret. Whether they are login credentials to a cloud
    service or passwords to database resources, they are secret for a reason. Should
    they fall into the wrong hands, they can be used to discover trade secrets, customers'
    private data, create infrastructure for nefarious purposes, or worse. All of this
    could cost you and your organization a lot of time, money, and headaches! When
    the second edition of this book was published, it was only possible to encrypt
    your sensitive data in external vault files, and all data had to exist entirely
    in either an encrypted or unencrypted form. It was also only possible to use one
    single Vault password per playbook run, meaning it was not possible to segregate
    your secret data and use different passwords for items of different sensitivities.
    All that has now changed, with multiple Vault passwords permissible at playbook
    runtime, as well as the possibility of embedding encrypted strings in otherwise
    plain **YAML Ain't Markup Language** (**YAML**) files.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will describe how to take advantage of these new features,
    and thus keep your secrets safe with Ansible, by covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Encrypting data at rest
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating and editing encrypted files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Executing `ansible-playbook` with encrypted files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mixing encrypted data with plain YAML
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Protecting secrets while operating
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To follow the examples presented in this chapter, you will need a Linux machine
    running **Ansible 4.3** or newer. Almost any flavor of Linux should do—for those
    interested in specifics, all the code presented in this chapter was tested on
    Ubuntu Server 20.04 **Long Term Support** (**LTS**), unless stated otherwise,
    and on Ansible 4.3\. The example code that accompanies this chapter can be downloaded
    from GitHub at this **Uniform Resource Locator** (**URL**): [https://github.com/PacktPublishing/Mastering-Ansible-Fourth-Edition/tree/main/Chapter03](https://github.com/PacktPublishing/Mastering-Ansible-Fourth-Edition/tree/main/Chapter03).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the Code in Action: [https://bit.ly/2Z4xB42](https://bit.ly/2Z4xB42)'
  prefs: []
  type: TYPE_NORMAL
- en: Encrypting data at rest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a configuration management system or an orchestration engine, Ansible has
    great power. To wield that power, it is necessary to entrust secret data to Ansible.
    An automation system that prompts the operator for passwords at each connection
    is not very efficient —indeed, it's hardly fully automated if you have to sit
    there and type in passwords over and over! To maximize the power of Ansible, secret
    data must be written to a file that Ansible can read and from which it can utilize
    the data.
  prefs: []
  type: TYPE_NORMAL
- en: This creates a risk, though! Your secrets are sitting there on your filesystem
    in plaintext. This is a physical as well as a digital risk. Physically, the computer
    could be taken from you and pored over for secret data. Digitally, any malicious
    software that can break the boundaries set upon it is capable of reading any data
    to which your user account has access. If you utilize a source control system,
    the infrastructure that houses the repository is just as much at risk.
  prefs: []
  type: TYPE_NORMAL
- en: Thankfully, Ansible provides a facility to protect your data at rest. That facility
    is **Vault**. This facility allows for the encryption of text files so that they
    are stored at rest in an encrypted format. Without the key or a significant amount
    of computing power, the data is indecipherable, yet can still be used within Ansible
    plays as easily as unencrypted data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The key lessons to learn when dealing with encrypting data at rest include
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Valid encryption targets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Securing differing data with multiple passwords and vault **identifiers** (**IDs**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating new encrypted files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encrypting existing unencrypted files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Editing encrypted files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing the encryption password on files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decrypting encrypted files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encrypting data inline in an otherwise unencrypted YAML file (for example, a
    playbook)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running `ansible-playbook` while referencing encrypted files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vault IDs and passwords
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before the release of **Ansible 2.4**, it was only possible to use one Vault
    password at a time. While you could have multiple secrets for multiple purposes
    stored in several locations, only one password could be used. This was obviously
    fine for smaller environments, but as the adoption of Ansible has grown, so has
    the requirement for better and more flexible security options. For example, we
    have already discussed the potential for Ansible to manage both a development
    and production environment through the use of groups in the inventory. It is realistic
    to expect that these environments would have different security credentials. Similarly,
    you would expect core network devices to have different credentials from servers.
    In fact, it is a good security practice to do so.
  prefs: []
  type: TYPE_NORMAL
- en: Given this, it seems unreasonable to then protect any secrets under a single
    master password using Vault. Ansible 2.4 introduced the concept of Vault IDs as
    a solution, and while at present, the old single password commands are all still
    valid, it is recommended to use Vault IDs when working with Ansible on the command
    line. Each Vault ID must have one single password associated with it, but multiple
    secrets can share the same ID.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ansible Vault passwords can come from one of the following three sources:'
  prefs: []
  type: TYPE_NORMAL
- en: A user-entered string, which Ansible will prompt for when it is required
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A flat text file containing the Vault password in plain unencrypted text (obviously,
    it is vital this file is kept secure!)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An executable that fetches the password (for example, from a credential management
    system) and outputs it on a single line for Ansible to read
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The syntax for each of these three options is broadly similar. If you only
    have one vault credential and hence aren''t using IDs (although you could if you
    wanted to, and this is strongly recommended as you might later wish to add a second
    vault ID), you would, therefore, enter the following line of code to run a playbook
    and prompt for the Vault password:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to obtain the Vault password from a text file, you would run the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, if you are using an executable script, you would run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are working with IDs, simply add the ID in front of the password source,
    followed by the `@` character—if the ID for your vault is `prod`, for example,
    the three preceding examples become the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Multiple combinations of these can be combined into one command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We will use the `vault-id` command-line options throughout the rest of this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Things Vault can encrypt
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Vault feature can be used to encrypt any **structured data** used by Ansible.
    This can either be almost any YAML (or **JavaScript Object Notation** (**JSON**))
    file that Ansible uses during its operation or even a single variable within an
    otherwise unencrypted YAML file, such as a playbook or role. Examples of encrypted
    files that Ansible can work with include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`group_vars/` files'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`host_vars/` files'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`include_vars` targets'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`vars_files` targets'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--extra-vars` targets'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Role variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Role defaults
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Task files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handler files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Source files for the `copy` module (these are an exception in this list—they
    don't have to be YAML-formatted)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a file can be expressed in YAML and read by Ansible, or if a file is to be
    transported with the `copy` module, it is a valid file for encryption in Vault.
    Because the entire file will be unreadable at rest, care should be taken to not
    be overzealous in picking which files to encrypt. Any source control operations
    with the files will be done with the encrypted content, making it very difficult
    to peer-review.
  prefs: []
  type: TYPE_NORMAL
- en: As a best practice, the smallest possible amount of data should be encrypted,
    which may even mean moving some variables into a file all by themselves. It is
    for this reason that Ansible 2.3 added the `encrypt_string` feature to `ansible-vault`,
    allowing for individual secrets to be placed inline with otherwise unencrypted
    YAML, saving the user from encrypting the entire file. We will cover this later
    in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and editing encrypted files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create new files, Ansible provides a program called `ansible-vault`. This
    program is used to create and interact with Vault-encrypted files. The subcommand
    to create encrypted files is `create`, and you can see the options available under
    this subcommand by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this command is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – The options available when creating an Ansible Vault instance'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_03_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.1 – The options available when creating an Ansible Vault instance
  prefs: []
  type: TYPE_NORMAL
- en: To create a new file, you'll need to know two things ahead of time. The first
    is the password `ansible-vault` will be using to encrypt the file, and the second
    is the filename itself. Once provided with this information, `ansible-vault` will
    launch a text editor (as defined in the `EDITOR` environment variable—this defaults
    to `vi` or `vim` in many cases). Once you save the file and exit the editor, `ansible-vault`
    will use the supplied password as a key to encrypt the file with the `AES256`
    cipher.
  prefs: []
  type: TYPE_NORMAL
- en: Let's walk through a few examples of creating encrypted files. First, we'll
    create one and be prompted for a password, then we will provide a `password` file,
    and lastly, we'll create an executable to deliver the password.
  prefs: []
  type: TYPE_NORMAL
- en: Password prompt
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Getting `ansible-vault` to request a password from the user at runtime is the
    easiest way to get started with vault creation, so let''s go through a simple
    example and create a vault containing a variable we want to encrypt. Run the following
    command to create a new vault, and to be prompted for the password:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2 – Creating a new Ansible Vault instance while being prompted for
    the password'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_03_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.2 – Creating a new Ansible Vault instance while being prompted for
    the password
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the passphrase is entered, our editor opens and we''re able to put content
    into the file, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3 – Adding content to the new Ansible Vault instance using the vim
    editor'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_03_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.3 – Adding content to the new Ansible Vault instance using the vim
    editor
  prefs: []
  type: TYPE_NORMAL
- en: On my system, the configured editor is **Vim**. Your system may be different,
    and you may wish to set your preferred editor as the value for the `EDITOR` environment
    variable if you are not happy with the default selection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we save the file. If we try to read the content using the following command,
    we''ll see that they are in fact encrypted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'There is just a small header hint for Ansible to use later, as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.4 – Showing the content of our new Ansible Vault instance, which
    are encrypted at rest'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_03_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.4 – Showing the content of our new Ansible Vault instance, which are
    encrypted at rest
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from the headers, `AES256` is used for vault encryption, meaning
    that as long as you use a good password when creating your vault, your data is
    very secure.
  prefs: []
  type: TYPE_NORMAL
- en: Password file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To use `ansible-vault` with a password file, you first need to create such
    a file. Simply echoing a password into a file can do this. Once complete, you
    can now reference this file when calling `ansible-vault` to create another encrypted
    file. Try this out by running the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This should look something like the output shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.5 – Creating an Ansible Vault instance using a password file'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_03_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.5 – Creating an Ansible Vault instance using a password file
  prefs: []
  type: TYPE_NORMAL
- en: When you run the preceding commands, you will note that you are not prompted
    for a password—this time, the password for the vault is the `my long password`
    string, which has been read from the content of `password_file`. The default editor
    will open, and data can be written just like before after this point, though.
  prefs: []
  type: TYPE_NORMAL
- en: Password script
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This last example uses a password script. This is useful for designing a system
    where a password can be stored in a central system for storing credentials and
    shared with contributors to the playbook tree. Each contributor could have their
    own password for the shared credentials store, where the Vault password would
    be retrieved from. Our example will be far more straightforward: just a simple
    output to `STDOUT` with a password. This file will be saved as `password.sh`.
    Create this file now with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'For Ansible to use this script, it must be marked as executable—run the following
    command against it so that it is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, you can create a new vault secured with the `a long password` as output
    by our simple script, by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The output from this process should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.6 – Creating an Ansible Vault instance using a simple password script'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_03_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.6 – Creating an Ansible Vault instance using a simple password script
  prefs: []
  type: TYPE_NORMAL
- en: 'Try this for yourself and see how it works—you should find that `ansible-vault`
    creates a vault with the `a long password` password, as written to `STDOUT` by
    the script. You could even try editing using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: You should now see enter `a long password` when prompted—and you can now edit
    the vault successfully!
  prefs: []
  type: TYPE_NORMAL
- en: Encrypting existing files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The previous examples all dealt with creating new encrypted files using the
    `create` subcommand. But what if we want to take an established file and encrypt
    it? A subcommand exists for this as well. It is named `encrypt`, and you can see
    the options for this subcommand by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will look similar to that shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.7 – The options available for the Ansible Vault encrypt subcommand'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_03_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.7 – The options available for the Ansible Vault encrypt subcommand
  prefs: []
  type: TYPE_NORMAL
- en: As with `create`, `encrypt` expects a `password` (or password file or executable)
    and the path to a file to be encrypted. Once the appropriate password is received,
    an editor opens up, this time with our original content in plaintext already visible
    to us.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the file to be encrypted must already exist.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s demonstrate this by encrypting an existing file we have from [*Chapter
    1*](B17462_01_Final_JC_ePub.xhtml#_idTextAnchor015), *The System Architecture
    and Design of Ansible*, called `Chapter01/example09/a_vars_file.yaml`. Copy this
    file to a convenient location and then encrypt it with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this process should look something like that shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.8 – Encrypting an existing variables file with Ansible Vault'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_03_08.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.8 – Encrypting an existing variables file with Ansible Vault
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we can see the file content before and after the call to `encrypt`,
    whereafter the content are indeed encrypted. Unlike the `create` subcommand, `encrypt`
    can operate on multiple files, making it easy to protect all the important data
    in one action. Simply list all the files to be encrypted, separated by spaces.
  prefs: []
  type: TYPE_NORMAL
- en: Attempting to encrypt already encrypted files will result in an error.
  prefs: []
  type: TYPE_NORMAL
- en: Editing encrypted files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once a file has been encrypted with `ansible-vault`, it cannot be directly
    edited. Opening the file in an editor would result in the encrypted data being
    shown. Making any changes to the file would damage the file, and Ansible would
    be unable to read the content correctly. We need a subcommand that will first
    decrypt the content of a file, allow us to edit those content, and then encrypt
    the new content before saving it back to the file. Such a subcommand exists in
    `edit`, and you can see the options available to you for this subcommand by running
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should look similar to that shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.9 – The options available for the edit subcommand of Ansible Vault'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_03_09.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.9 – The options available for the edit subcommand of Ansible Vault
  prefs: []
  type: TYPE_NORMAL
- en: 'As we''ve already seen, our editor will open with our content in plaintext
    visible to us. All of our familiar `vault-id` options are back, as before, as
    well as the file(s) to edit. As such, we can now edit the file we just encrypted
    using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that `ansible-vault` opens our editor with a temporary file as the file
    path. When you save and exit the editor, the temporary file gets written, and
    then `ansible-vault` will encrypt it and move it to replace the original file.
    The following screenshot shows the unencrypted content of our previously encrypted
    vault available for editing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.10 – Editing our previously encrypted Ansible Vault'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_03_10.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.10 – Editing our previously encrypted Ansible Vault
  prefs: []
  type: TYPE_NORMAL
- en: The temporary file you can see in the editor window (`…/tmp6ancaxcu.yaml`) will
    be removed once the file is successfully encrypted by `ansible-vault`.
  prefs: []
  type: TYPE_NORMAL
- en: Password rotation on encrypted files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Over time, as contributors come and go, it is a good idea to rotate the password
    used to encrypt your secrets. Encryption is only as good as the protection of
    the password. `ansible-vault` provides a `rekey` subcommand that allows us to
    change the password, and you can explore the options available with this subcommand
    by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should look similar to that shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.11 – The options available with the Ansible Vault rekey subcommand'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_03_11.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.11 – The options available with the Ansible Vault rekey subcommand
  prefs: []
  type: TYPE_NORMAL
- en: 'The `rekey` subcommand operates much like the `edit` subcommand. It takes in
    an optional password, file, or executable, and one or more files to rekey. You
    then need to use the `--new-vault-id` parameter to define a new password (and
    ID if required), which again can be through a prompt, file, or executable. Let''s
    rekey our `a_vars_file.yaml` file in the following example, and change the ID
    to `dev` by running the following command—for now, we''ll prompt for the new password,
    though we know we can obtain the original password using our password script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should look like that shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.12 – Rekeying an existing Ansible Vault and changing the ID at the
    same time'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_03_12.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.12 – Rekeying an existing Ansible Vault and changing the ID at the
    same time
  prefs: []
  type: TYPE_NORMAL
- en: Remember that all the encrypted files **with the same ID** need to have a matching
    password (or key). Be sure to rekey all the files with the same ID at the same
    time.
  prefs: []
  type: TYPE_NORMAL
- en: Decrypting encrypted files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If at some point, the need to encrypt data files goes away, `ansible-vault`
    provides a subcommand that can be used to remove encryption for one or more encrypted
    files. This subcommand is (surprisingly) named `decrypt`, and you can view the
    options for this subcommand by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should look similar to that shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.13 – The options available using the decrypt subcommand of Ansible
    Vault'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_03_13.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.13 – The options available using the decrypt subcommand of Ansible
    Vault
  prefs: []
  type: TYPE_NORMAL
- en: 'Once again, we have our familiar `--vault-id` options, and then one or more
    file paths to decrypt. Let''s decrypt the file we rekeyed just now, by running
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'If successful, your decryption process should look something like that shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.14 – Decrypting an existing vault'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_03_14.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.14 – Decrypting an existing vault
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will see how to execute `ansible-playbook` when referencing
    encrypted files.
  prefs: []
  type: TYPE_NORMAL
- en: Executing ansible-playbook with encrypted files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To make use of our encrypted content, we first need to be able to inform `ansible-playbook`
    of how to access any encrypted data it might encounter. Unlike `ansible-vault`,
    which exists solely to deal with file encryption or decryption, `ansible-playbook`
    is more general-purpose, and it will not assume it is dealing with encrypted data
    by default. Fortunately, all of our familiar `--vault-id` parameters from the
    previous examples work just the same in `ansible-playbook` as they do in `ansible-vault`.
    Ansible will hold the provided passwords and IDs in memory for the duration of
    the playbook execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now create a simple playbook named `show_me.yaml` that will print out
    the value of the variable inside of `a_vars_file.yaml`, which we encrypted in
    a previous example, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s run the playbook and see what happens. Note how we use the `--vault-id`
    parameter in exactly the same way as we did with `ansible-vault`; continuity is
    maintained between the two tools, so you are able to apply everything you learned
    earlier in the chapter about using `--vault-id`. If you didn''t already complete
    this step earlier, encrypt your variables file with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'With this done, now run the playbook with the following command—note the presence
    of the `--vault-id` parameter, similar to before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'When you have completed this, your output should look something like that shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.15 – Running a simple playbook including an encrypted Ansible Vault
    instance'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_03_15.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.15 – Running a simple playbook including an encrypted Ansible Vault
    instance
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the playbook runs successfully and prints out the unencrypted
    value of the variable, even though the source variable file we included was an
    encrypted Ansible Vault instance. Naturally, you wouldn't print a secret value
    to the terminal in a real playbook run, but this demonstrates how easy it is to
    access data from a vault.
  prefs: []
  type: TYPE_NORMAL
- en: In all our examples so far, we have created vaults as external entities—files
    that live outside of the playbooks themselves. However, it is possible to add
    encrypted vault data to an otherwise unencrypted playbook, which reduces the number
    of files we need to track and edit. Let's have a look at how this is achieved
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Mixing encrypted data with plain YAML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before the release of Ansible 2.3, secure data had to be encrypted in a separate
    file. For the reasons we discussed earlier, it is desirable to encrypt as little
    data as possible. This is now possible (and also saves a need for too many individual
    files as part of a playbook) through the use of the `encrypt_string` subcommand
    of `ansible-vault`, which produces an encrypted string that can be placed into
    an Ansible YAML file. Let''s start with the following basic playbook as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We can run this code (insecure though it is!) with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'When this playbook runs, the output should look similar to that shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.16 – Running an unencrypted playbook containing sensitive data'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_03_16.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.16 – Running an unencrypted playbook containing sensitive data
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, it obviously isn''t clever to leave a secure password in plaintext like
    this. So, rather than leave it like this, we will encrypt it using the `encrypt_string`
    subcommand of `ansible-vault`. If you want to see the options available to you
    when running this subcommand, you can execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this command should look similar to that shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.17 – The options available for the encrypt_string subcommand of
    Ansible Vault'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_03_17.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.17 – The options available for the encrypt_string subcommand of Ansible
    Vault
  prefs: []
  type: TYPE_NORMAL
- en: 'So, if we wanted to create an encrypted block of text for our `my_secret` variable
    with the `secure_password` encrypted string, using the `test` Vault ID and the
    `password.sh` script we created earlier for the password, we would run the following
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of these commands will give you the encrypted string to include
    in your existing playbook, and an example is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.18 – Encrypting a variable to a secure string using Ansible Vault'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_03_18.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.18 – Encrypting a variable to a secure string using Ansible Vault
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now copy and paste that output into our playbook, ensuring our variable
    is no longer human-readable, as demonstrated in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.19 – Replacing the unencrypted variable with the encrypted string
    data in our existing playbook'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_03_19.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.19 – Replacing the unencrypted variable with the encrypted string data
    in our existing playbook
  prefs: []
  type: TYPE_NORMAL
- en: 'Even though we have now embedded an Ansible Vault encrypted variable directly
    inside our playbook, we can run this playbook using the appropriate `--vault-id`
    just like we did before—the following command will be used here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'You will observe the playbook running and see that the information can be accessed
    just as any other vault data can, and your output should look like that shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.20 – Running an Ansible playbook containing an encrypted string'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_03_20.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.20 – Running an Ansible playbook containing an encrypted string
  prefs: []
  type: TYPE_NORMAL
- en: You can see that the playbook runs exactly as it did the first time we tested
    it when all the data was open for the world to see! Now, however, we have successfully
    mixed our encrypted data with an otherwise unencrypted YAML playbook, all without
    a need to create a separate Vault file.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will delve deeper into some of the operational aspects
    of running playbooks in conjunction with Ansible Vault.
  prefs: []
  type: TYPE_NORMAL
- en: Protecting secrets while operating
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section of this chapter, we covered how to protect your secrets
    at rest on the filesystem. However, that is not the only concern when operating
    Ansible with secrets. That secret data is going to be used in tasks as module
    arguments, loop inputs, or any number of other things. This may cause the data
    to be transmitted to remote hosts, logged to local or remote log files, or even
    displayed onscreen. This section of the chapter will discuss strategies for protecting
    your secrets during operation.
  prefs: []
  type: TYPE_NORMAL
- en: Secrets transmitted to remote hosts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we learned in [*Chapter 1*](B17462_01_Final_JC_ePub.xhtml#_idTextAnchor015),
    *The System Architecture and Design of Ansible*, Ansible combines module code
    and arguments and writes this out to a temporary directory on the remote host.
    This means your secret data is transferred over the wire *and* written to the
    remote filesystem. Unless you are using a connection plugin other than **Secure
    Shell** (**SSH**) or **Secure Sockets Layer** (**SSL**)-encrypted **Windows Remote
    Management** (**WinRM**), the data over the wire is already encrypted, preventing
    your secrets from being discovered by simple snooping. If you are using a connection
    plugin other than SSH, be aware of whether or not data is encrypted while in transit.
    Using any connection method that is not encrypted is strongly discouraged.
  prefs: []
  type: TYPE_NORMAL
- en: Once the data is transmitted, Ansible may write this data out in clear form
    to the filesystem. This can happen if pipelining (which we learned about in [*Chapter
    1*](B17462_01_Final_JC_ePub.xhtml#_idTextAnchor015), *The System Architecture
    and Design of Ansible*) is not in use, or if Ansible has been instructed to leave
    remote files in place via the `ANSIBLE_KEEP_REMOTE_FILES` environment variable.
    Without pipelining, Ansible will write out the module code, plus arguments, into
    a temporary directory that is to be deleted immediately after execution. Should
    there be a loss of connectivity between writing out the file and executing it,
    the file will be left on the remote filesystem until manually removed. If Ansible
    is explicitly instructed to keep remote files in place, then even if pipelining
    is enabled, Ansible will write and leave a remote file in place. Care should be
    taken with these options when dealing with highly sensitive secrets, even though
    typically, only the user Ansible authenticates with on the remote host (or becomes
    via privilege escalation) should have access to the leftover file. Simply deleting
    anything in the `~/.ansible/tmp/` path for the remote user will suffice to clean
    secrets.
  prefs: []
  type: TYPE_NORMAL
- en: Secrets logged to remote or local files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When Ansible operates on a host, it will attempt to log the action to `syslog`
    (if verbosity level 3 or more is used). If this action is being done by a user
    with appropriate rights, it will cause a message to appear in the `syslog` file
    of the host. This message includes the module name and the arguments passed along
    to that command, which could include your secrets. To prevent this from happening,
    a play-and-task key exists, called `no_log`. Setting `no_log` to `true` will prevent
    Ansible from logging the action to `syslog`.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible can also be instructed to log its actions locally. This is controlled
    either through `log_path` in the Ansible config file or through an environment
    variable called `ANSIBLE_LOG_PATH`. By default, logging is off and Ansible will
    only log to `STDOUT`. Turning logging on in the `config` file causes Ansible to
    log its activities to the file defined in the `logpath` `config` setting.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, setting the `ANSIBLE_LOG_PATH` variable to a path that can be
    written to by the user running `ansible-playbook` will also cause Ansible to log
    actions to this path. The verbosity of this logging matches that of the verbosity
    shown onscreen. By default, no variables or return details are displayed onscreen.
    With a verbosity level of 1 (`-v`), return data is displayed onscreen (and potentially
    in the local log file). With verbosity turned up to level 3 (`-vvv`), the input
    parameters may also be displayed. Since this can include secrets, the `no_log`
    setting applies to the onscreen display as well. Let''s take our previous example
    of displaying an encrypted secret and add a `no_log` key to the task to prevent
    showing its value, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We will execute this playbook in the same manner as we have before (but with
    added verbosity, as specified with the `-v` flag) by running the following command—remember
    to encrypt the variables file first if you need to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We should see that our secret data is protected, even though we deliberately
    attempted to print it using `ansible.builtin.debug`, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.21 – Encrypting a variables file and running a playbook with the
    sensitive data protected'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_03_21.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.21 – Encrypting a variables file and running a playbook with the sensitive
    data protected
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, Ansible censored itself to prevent showing sensitive data. The
    `no_log` key can be used as a directive for a play, a role, a block, or a task.
  prefs: []
  type: TYPE_NORMAL
- en: That concludes our look at operational usage of Ansible Vault, and indeed the
    topic of Ansible Vault—it is hoped that this chapter has proved useful in teaching
    you how to secure your sensitive data when performing automation with Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered how Ansible can deal with sensitive data effectively
    and securely, harnessing the latest Ansible features, including securing differing
    data with different passwords and mixing encrypted data with plain YAML. We have
    also shown how this data is stored at rest and how this data is treated when utilized,
    and that with a little care and attention, Ansible can keep your secrets secret.
  prefs: []
  type: TYPE_NORMAL
- en: You learned how to use the `ansible-vault` tool to protect sensitive data by
    creating, editing, and modifying encrypted files, and the variety of methods available
    for providing the Vault password, including prompting the user, obtaining the
    password from a file, and running a script to retrieve it. You also learned how
    to mix encrypted strings with plain YAML files, and how this simplifies playbook
    layout. Finally, you learned the operational aspects of using Ansible Vault, thus
    preventing Ansible from leaking data to remote log files or onscreen displays.
  prefs: []
  type: TYPE_NORMAL
- en: In our next chapter, we will explore how the power of Ansible is now available
    for Windows hosts, and how to harness this.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ansible Vault encrypts your data at rest using which encryption technology?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) Triple DES/3DES
  prefs: []
  type: TYPE_NORMAL
- en: b) MD5
  prefs: []
  type: TYPE_NORMAL
- en: c) AES
  prefs: []
  type: TYPE_NORMAL
- en: d) Twofish
  prefs: []
  type: TYPE_NORMAL
- en: 'Ansible Vault instances must always exist as separate files to the playbook
    itself:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) True
  prefs: []
  type: TYPE_NORMAL
- en: b) False
  prefs: []
  type: TYPE_NORMAL
- en: 'You can ingest data from more than one Ansible Vault instance when running
    a playbook:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) True
  prefs: []
  type: TYPE_NORMAL
- en: b) False
  prefs: []
  type: TYPE_NORMAL
- en: 'When executing a playbook that makes use of Vault-encrypted data, you can provide
    the password:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) Interactively at playbook launch
  prefs: []
  type: TYPE_NORMAL
- en: b) Using a plaintext file containing just the password
  prefs: []
  type: TYPE_NORMAL
- en: c) Using a script to retrieve the password from another source
  prefs: []
  type: TYPE_NORMAL
- en: d) All of the above
  prefs: []
  type: TYPE_NORMAL
- en: 'Ansible will never print vault data to the terminal during a playbook run:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) True
  prefs: []
  type: TYPE_NORMAL
- en: b) False
  prefs: []
  type: TYPE_NORMAL
- en: 'You can prevent Ansible from inadvertently printing vault data to the terminal
    during a playbook run using the following task parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) `no_print`
  prefs: []
  type: TYPE_NORMAL
- en: b) `no_vault`
  prefs: []
  type: TYPE_NORMAL
- en: c) `no_log`
  prefs: []
  type: TYPE_NORMAL
- en: 'An interrupted playbook run could leave sensitive unencrypted data on a remote
    host:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) True
  prefs: []
  type: TYPE_NORMAL
- en: b) False
  prefs: []
  type: TYPE_NORMAL
- en: What is used to differentiate different vaults (which may have different passwords)
    at runtime?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) Vault names
  prefs: []
  type: TYPE_NORMAL
- en: b) Vault IDs
  prefs: []
  type: TYPE_NORMAL
- en: c) Vault specifiers
  prefs: []
  type: TYPE_NORMAL
- en: d) None of the above
  prefs: []
  type: TYPE_NORMAL
- en: You can edit an existing encrypted vault using which Ansible command?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) `ansible-vault vi`
  prefs: []
  type: TYPE_NORMAL
- en: b) `ansible-vault change`
  prefs: []
  type: TYPE_NORMAL
- en: c) `ansible-vault update`
  prefs: []
  type: TYPE_NORMAL
- en: d) `ansible-vault edit`
  prefs: []
  type: TYPE_NORMAL
- en: Why might you not want to mix sensitive and non-sensitive data in a vault?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) Doing so makes it difficult to run `diff` commands and see changes in a **version
    control system** (**VCS**).
  prefs: []
  type: TYPE_NORMAL
- en: b) Only sensitive data is allowed in Ansible Vault.
  prefs: []
  type: TYPE_NORMAL
- en: c) Ansible Vault has a limited capacity.
  prefs: []
  type: TYPE_NORMAL
- en: d) Ansible Vault makes it difficult to access secured data.
  prefs: []
  type: TYPE_NORMAL
