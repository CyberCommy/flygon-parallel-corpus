- en: Basic GUI Development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, we write programs that are all about raw functionality. However,
    we often write programs that are generally used by us or other users who expect
    the process of their interaction with us to be streamlined. In this chapter, we
    will see the basic functions of the **Graphical User Interface **(**GUI**) in
    NetBeans. A couple of things that define truly amazing software programs are their
    GUI and user experience. You will learn how to create an application window with
    the `JFrame` class by setting its size, adding labels to it, and closing the application
    on the whole. Then comes the topic of the GUI editor, that is, palette; here,
    we'll see a working instance of palette and the components available in it. Finally,
    you'll learn how to trigger events by adding a button and adding functionality
    to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Swing GUIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A visual GUI editor tool – palette
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Event handling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Swing GUIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: NetBeans is a powerful program that offers a lot of functionality, and we access
    this functionality through a GUI and the menus and buttons provided by NetBeans.
    In theory, we could have chosen to operate NetBeans as a command-line program,
    but in order to use NetBeans like that, we would have to memorize or look up a
    large library of specific commands for every action we would want to take. A powerful
    and well-written application has a streamlined interface that will guide us toward
    important functionality and make it easy for us to access it. The JDK contains
    a Java extension library, the `swing` library, which makes it very easy for us
    to wrap our own code in GUIs like the one NetBeans has.
  prefs: []
  type: TYPE_NORMAL
- en: The JFrame class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To start off on this track, we''re going to write a program that will open
    up a new GUI window. The steps are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the heart of the `swing` Java GUIs is the `JFrame` class. In our case, this
    class will be the actual window object that our operating system will handle and
    that we could move around our screen. We can create a new `JFrame` class as we
    might create any other object. We can even pass some parameters to this `JFrame`
    class''s creation. If we just give it a string parameter, we''ll be telling the
    `JFrame` class what to present as its name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we''ve declared a `JFrame` class, it''s simply going to exist in Java''s
    memory like any other object. It won''t present itself to the user until we explicitly
    tell it to. It will simply be a function call to the `setVisible` function and
    we will assign the value `true` to this function, pretty easy right:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'There''s one more thing we should do before we make JFrame window visible and
    that''s to call the `pack` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'When we create more complicated frames, they may contain a lot of information,
    and in a GUI, much of this information takes up visible space. The `pack` method
    basically prebuilds the physical relationships between the objects in the frame
    and ensures that the frame doesn''t behave oddly when it actually appears visible
    to the user. So we''ve written a really simple program so far – only three lines
    of code and no real thought required on our part:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run this program, it might appear that nothing has happened, but something
    has. In the top left-hand corner of the screen, a new window has appeared. If
    we click on the right-hand side of this window, we can, in theory, drag it around
    or just resize the window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6e502859-8e4b-4bb0-b330-c85e7d2c2665.png)'
  prefs: []
  type: TYPE_IMG
- en: This is a fully fledged window that our operating system can now handle, allowing
    us to move around; it even supports dynamic resizing. You'll see that our header
    has also been appended to our window. So that's super basic.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the size of our window
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now let's see what else we can do with our existing `JFrame` class. When our
    JFrame window appeared, it was very small and hard to see. A program window of
    such a size is never really going to be useful to anyone, so let's see what powers
    `frame` gives us in terms of setting the window's size. Often, we're going to
    use the `setPreferredSize` method to apply a size to our `JFrame` class. There
    is also a `setSize` method, but this method will not give us exactly what we expect
    it to at all times. This is because right now our `JFrame` class is set to be
    resizable, and it's not appropriate for us to explicitly assign a size to it;
    rather, we should instruct it that given no other input from the user, meaning
    resizing JFrame window, the window should be a certain size.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can store, manipulate, and create size information using the `Dimension`
    class. To construct a new dimension, we can simply give it a width and height.
    So let''s set `JFrame` class''s preferred size, the size it would like to be until
    we stretch it, to `400 x 400`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Dimension` class lives in another library, so we''ll have to import the `java.awt.*;`
    package, then we should be able to build and compile our project and once again
    open up our new GUI:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c0714f29-7547-4158-ae40-3f7895cf4d19.png)'
  prefs: []
  type: TYPE_IMG
- en: Now we get a nice squared GUI to start with; however, it's still pretty useless
    as there's nothing contained within this GUI.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a label
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now let''s take a quick look at how to add elements to our GUI from a programming
    standpoint. Quite possibly the simplest element that we could put inside `JFrame`
    is `JLabel`. Labels are responsible for containing text, and instantiating them
    is extremely simple. We simply tell them what text they should contain. Of course,
    in more complicated programs and GUIs, this text can become dynamic and may change,
    but for now, let''s just get some text to display:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Simply declaring that we have a `JLabel` class is not enough. We have not yet
    associated this label object in any way with our existing frame. Our frame, as
    you can probably tell by the vast array of methods and members it exposes, has
    a whole lot of components, and we need to know in which of these components we
    need to place our new `JLabel` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'One of the components within our `JFrame` class is `contentPane`; that''s the
    area that we visibly see inside the window where things normally go in a program''s
    GUI. This seems like a reasonable place for us to add a new component, in this
    case, `label`. Once again, let''s build our program, kill the old instance, and
    run the new program:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9ceda3ee-3b74-470a-b2be-eddfffad4092.png)'
  prefs: []
  type: TYPE_IMG
- en: There we go! Now we have text in our GUI; we've successfully added an element
    to the content of our JFrame window.
  prefs: []
  type: TYPE_NORMAL
- en: Closing our application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One thing that''s kind of annoying is that our program is continuing to run
    even after we close the associated GUI. That''s a little silly. When I press the
    close button on the NetBeans GUI, NetBeans closes itself and stops running as
    a process on my system. We can instruct our frame to terminate the associated
    process using its `setDefaultCloseOperation` method. This method has the return
    type `void` and takes an integer as a value. This integer is an enumerator, and
    there''s lots of options available to us. All of these options are statically
    declared by the `JFrame` class, and the one we''re probably looking for is `EXIT_ON_CLOSE`,
    which will exit our application when we close our window. Build and run the program,
    and terminate the GUI, and there goes our process, which is not quietly running
    in the background anymore:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: That's our basic introduction to GUIs in Java. Creating a GUI is complicated,
    but it is exciting as well because it's visual and immediate; also, it is really
    powerful.
  prefs: []
  type: TYPE_NORMAL
- en: As our program stands right now as shown in the following code block, it's functional,
    but were we to extend it, we might eventually run into some very odd and confusing
    issues. What we've done now flies in the face of the recommended practices when
    creating a new GUI. These recommended practices are in place to protect us from
    some very low-level issues that can occur when our programs become multithreaded.
  prefs: []
  type: TYPE_NORMAL
- en: 'What does it mean when we say that our program is multithreaded? Well, when
    we create our GUI, when we cause it to come into being, our program goes from
    performing a single task, which is simply executing the `main` method from start
    to finish, to performing multiple tasks. This is because we are now executing
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: However, in addition, the code is also managing the new window we've created
    and any functionality performed by that window. To protect ourselves from the
    complexities of multithreaded code, it's recommended that we create our new Swing
    GUI by allowing one of the Swing utilities to construct this GUI for us asynchronously.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to make this happen, we''re actually going to need to pull all of
    the code we''ve written out of our `main` method and place it in one place where
    we can reference it from our `main` method. This will be a new function as shown
    in the following code line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We can just paste all of this code back to our new function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The SwingUtilities class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s take a look at how Swing recommends we cause our GUI to come into
    being. As I said, the `swing` package provides us some functionality that will
    perform this vast amount of work and thinking for us. The `SwingUtilities` class
    has a static `invokeLater` method that will create our GUI when no other thread
    really needs to be processed or when all of the other thinking is done for a bit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This `invokeLater` method expects us to pass in a `Runnable` object to it,
    so we''re going to have to create one of the `Runnable` objects for ourselves:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Runnable` objects are those that can be converted into a thread of their
    own. They have a method that we''re going to override, called `run`, and the `SwingUtilities.invokeLater`
    method will call the `run` method of `Runnable` when appropriate. When this occurs,
    all we want it to do is call our `MakeGUI` method and begin executing the code
    that we''ve just tested out, the one that will create a GUI. We''ll add the `Override`
    notation to be good Java programmers and pass our new `Runnable` object to the
    `invokeLater` method of `SwingUtilities`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the preceding program and there we go! The functionality is exactly the
    same, and what we''ve done could arguably be overkill for a program this small;
    however, it''s really good for us to take a look at what we should expect to see
    in a larger software project, where things such as multithreading could become
    a concern. We went through this a bit quickly, so let''s stop and take a look
    at this section once again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: What we've done in this bit of code is create an anonymous class. While it looks
    like we've created a new `Runnable` object, we've really created a new subclass
    of the `Runnable` object with its own special overridden version of the `run`
    method, and we just put it right in the middle of our code. This is a powerful
    methodology that allows us to cut down on the amount of code needed. Of course,
    if we overuse it, our code can quickly become very complicated for us or another
    programmer to read and understand.
  prefs: []
  type: TYPE_NORMAL
- en: A visual GUI editor tool – palette
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Java programming language, a GUI extension library such as `Swing`, and
    a development environment – a powerful one such as NetBeans – can be a really
    strong combo. Now we're going to take a look at how to create GUIs using a GUI
    editor like the one found in NetBeans.
  prefs: []
  type: TYPE_NORMAL
- en: To follow along, I highly recommend that you utilize the NetBeans IDE for this
    section.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, to get started, let''s create a Java application like we normally would
    and give it a name and we''re good to go. We''re going to start off by simply
    deleting the default Java file that NetBeans provides and instead ask NetBeans
    to create a new file. We''re going to ask it to create a JFrame Form for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7d295170-a12e-45ef-9cdf-9a4e8cde07a6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We''ll give this JFrame form a name and keep it in the same package. When NetBeans
    creates this file, even though it''s a `.java` file, the window that pops up will
    look really different to us. In fact, our file is still just Java code. Click
    on the Source tab to see the code as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/99501467-d025-4a83-b179-fc4612e6cf97.png)'
  prefs: []
  type: TYPE_IMG
- en: How palette works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can see the Java code that comprises our file in the Source code tab; there's
    actually a whole lot of code in this file if we expand it out. It's all been generated
    for us by the NetBeans GUI editor called Palette as shown in the following screenshot.
    Changes we make to this Java file will affect our `Design` file and vice versa.
    From this `Design` file, we have access to a drag and drop editor, and we can
    also edit the properties of individual elements without having to jump into our
    Java code, that is, the `Source` file. Eventually, in pretty much any application
    we ever create, we're going to have to drop into our Java code to provide the
    backend programming functionality to the pieces we put into our editor; for now,
    let's just take a quick look at how the editor works.
  prefs: []
  type: TYPE_NORMAL
- en: 'I''d like to set up the framework for a password protection dialog. This isn''t
    going to be too complicated, so we''ll make the JFrame form a little smaller than
    it is right now. Then, take a look at some of the Swing Controls available; there''s
    a whole lot of them. In fact, courtesy of NetBeans, we can use some other GUI
    extension systems as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/873a5355-84b0-4a53-8575-362b7d63fafb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following are the steps for setting up the framework for a password protection
    dialog:'
  prefs: []
  type: TYPE_NORMAL
- en: Let's just stick with Swing Controls and stay pretty basic. Label is about as
    basic as you can get. Our password dialog is going to need some text:![](img/a16451a4-5988-4b39-9d35-b2817feac122.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, a password dialog is also going to need some user interaction. We're going
    to need not only a password, but also a username for the user. To get the username,
    we will have to decide between a couple of options under Swing Controls:![](img/55194655-5992-418a-8d1d-e6b6c975b19f.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: TextArea is a good one. It lets the user put text in a box, unlike Label, which
    only developers can edit. The user can click on the box and type some text into
    it. Unfortunately, this box is pretty big, and if we click on it and try to make
    it smaller, we'll get scroll bars to allow the user to bounce around its size.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could modify the default sizes of this box when the scroll bars appear by
    changing any number of its properties that we can access from the editor. However,
    a much simpler solution would be to simply use Text Field, which doesn''t have
    all of the multiline functionality of our box. Also, put Label next to Text Field
    and you''ll notice that the graphical editor helps line things up. If we properly
    double-click on fields such as Label, we can edit their text right there:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c7f3d1c1-bc6b-468d-a71d-067bea20b62c.png)'
  prefs: []
  type: TYPE_IMG
- en: One of the cool things about modern GUIs is that there's some really specialized
    controls. One of these is Password Field. In many ways, it's going to act just
    like our TextField control, except that it's going to replace whatever text the
    user puts in there visually with dots so that someone looking over their shoulder
    will not be able to learn their password. If you fail to double-click on an editable
    element, it will bring you back to the source.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re going to edit the two components – the text and password fields – that
    our user can place text in so that they don''t appear to our user with their default
    values initially. We can double-click on the password field, or we can just edit
    the properties of our controls:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/09bad6b6-2965-4cf9-815f-1b666cc7b99b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, the text value of our Text Field control can be modified to nothing at
    all to start off with, and we can do the same thing with our password. You''ll
    notice that the text value of our password actually has text in it, but it is
    just displayed as a bunch of dots. However, programmers can access this value
    to validate the user''s password. There''s a whole lot of other options in the
    Properties tab: we can do things such as change the font and the foreground and
    background colors, give it borders, and all that.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When we run our program, you will see that it actually does exist and that
    the user can put values into these fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5252847a-208d-427e-84be-3e1cd8f8de03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Of course, we haven''t written any backend code to do anything useful with
    them yet, but the GUI itself is up and working. There''s nothing magical happening
    here. If we jump into the source of this code and drop down to its `main` method,
    we''ll see the code where the GUI is actually created and displayed to the user
    (see the following screenshot):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cfa02b3a-44c3-4a72-8105-967356878cba.png)'
  prefs: []
  type: TYPE_IMG
- en: The important thing to realize is when we access the elements within our source
    code, all of this methodology is also available to us through raw Java. That's
    all I really wanted to show you in this section, just the raw power and how quickly
    we set up a GUI window for the system using the NetBeans graphical editor.
  prefs: []
  type: TYPE_NORMAL
- en: Event handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the best things about working in Java is how powerful its GUI extension
    libraries are and just how quickly we can get a program up and running that not
    only has functional code, but also has a slick, professional-looking user interface
    to back it up that would help anyone interact with our program. That''s what we''re
    going to do now: connect the design interface for basic username and password
    validation with some backend code that we''re going to write which will actually
    check two text fields to see whether they''re the ones we''re looking for.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To start off, we have the basic GUI with a text field where someone can put
    a username and password, which will just show up as stars:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/646c18ba-71b4-4b60-8c02-efa1ba424d8f.png)'
  prefs: []
  type: TYPE_IMG
- en: Adding a button
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The source code for this GUI is so far completely autogenerated. We haven't
    touched it at all yet; it's just reflecting the design decisions we've made here.
    Before we can start writing backend code to do username and password validation,
    our user is going to need a way to tell us that they've put in a username and
    password and they'd like it to be validated. This seems like an apt job for the
    all-powerful button. So let's add a button to our GUI from the Swing Controls
    menu. We'll change its text to `Submit` in the Properties option, and the user
    will need to click on this button to submit their information. Now, when the button
    is clicked, we'd like it to perform some programming logic. We want to check the
    username and password fields for this section because we're just learning and
    doing things simply and easily; we'll just check them against some hardcoded text.
  prefs: []
  type: TYPE_NORMAL
- en: The question is how do we get from GUI to functional Java code? Generally, we're
    going to do this through the **event-driven** programming mode, where the interactions
    that our user has with the GUI determine what Java code is executed and what backend
    logic occurs. Another way to think of this is that we can set up pieces of our
    Java code, or methods, to listen for specific GUI-related events to occur and
    then execute when they do. You'll notice that our GUI components, or controls
    like our button, have a field under their properties called Events. These are
    all the things that could occur in relation to our control here. In theory, we
    could bind each one of these events to a method in our Java source code, and when
    a particular event occurs, either because of user interaction or other code we
    wrote, our related Java method would be called.
  prefs: []
  type: TYPE_NORMAL
- en: Adding functionality to our button
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To let users click on our button field and perform some coded action, we''re
    going to assign an event handler to our `actionPerformed` event. If we click on
    this field, we get an option already. Our GUI designer is suggesting we add a
    handler, namely `jButton1ActionPerformed`. That''s an awful name for a method
    that''s going to sit in our code; `jBbutton1` is pretty nondescript. However,
    it has been chosen because it is the variable name assigned to `jButton` when
    it''s created in the actual Java code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'If we scroll down in the source code, we''ll see the actual declaration there.
    I''m sure we can change these settings, but NetBeans will let us know that we
    probably shouldn''t modify this directly. This is because the designer is going
    to modify it too. So we''ll just change the name of our button from the non-descriptive
    `jButton1` to `SubmitButton`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: When we make this change, we'll see that NetBeans will update our source code
    and there's a `SubmitButton` object bouncing around. This is a variable that starts
    with a capital letter, so we'll make one more change in the Events section by
    changing it to `submitButton`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now the suggested action performed by NetBeans is `submitButtonActionPerformed`.
    When we head down to our source code, we''ll see that an event would have been
    created and linked to `jButton` in a massive block of generated code that NetBeans
    has created to mimic our GUI, which we''ve been creating through their tools.
    If we search for our `submitButtonActionPerformed` method in the source code,
    we''ll actually see it added to the generated code in the source code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `submitButtonActionPerformed` method has been added as the final call of
    `ActionListener` placed in `submitButton`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '`ActionListener`, of course, has one job and one job only and that''s to see
    whether our button has been clicked. If clicked, it will call our `submitButtonActionPerformed`
    method. So, in this `submitButtonActionPerformed` method, we can put some good
    old functional Java code. For this, we need to do two things:'
  prefs: []
  type: TYPE_NORMAL
- en: Check the value of the password field
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check the value of the username field
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Only `ActionEvent` (as seen in the preceding code block) is passed into our
    `submitButtonActionPerformed` method. While there''s a lot of interesting and
    useful methodologies attached to this event, the context of the action that caused
    our method to be called, it''s not going to give us what we really need. What
    we really need is our password field and our text field, which fortunately are
    private members of our current class. The steps for validating the value of our
    text fields are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start with the username, that is, `jTextField1`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We should probably rename this when we get the chance, but we''ll just roll
    with it for now because we only have one text field:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/72f5504b-bdad-42e3-a5ea-abd2e589fe14.png)'
  prefs: []
  type: TYPE_IMG
- en: If you remember, in the editor under Properties tab, this text field had a text
    property. We got rid of the text in this because we didn't want our username text
    field to start with any text. We want it to be blank so that users would know
    they have to put their own information there.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, it stands to reason if that''s the property exposed to us in the designer,
    there should be a related property exposed by the object itself, and there is,
    namely `getText()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: When we call `getText`, of course, we return the text currently stored in our
    text field, and we'll make our super secret username the very "creative" word
    `username`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This is a conditional statement, and we''re going to want to make another conditional
    statement. We want to ask our program whether the text field and password field
    – which is going to expose a similar method, `getPassword` in this case – are
    both equal to the hardcoded string. Our secret password will be `java`. Note that
    `getPassword` actually returns a character array, not a string, so to keep things
    simple, let''s just assign the password value to a string and then we''re good
    to utilize it as a string. Put `if` in front of our conditional statement, within
    parentheses, and we''re good to go:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Now we need to give our user some indication whether or not they've succeeded
    in providing the proper username and password. OK, what to do if the user has
    successfully input a good username and a good password? Well, I think it would
    be cool if we showed a pop-up dialog here.
  prefs: []
  type: TYPE_NORMAL
- en: '`JOptionPane` provides us with the `showMessageDialog` method, which is a pretty
    cool way to impart really important and immediate information to the user. It''ll
    show a pop-up box, and it''s pretty lightweight and easy to use. You may have
    to fix the imports on this one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The only heavyweight information `MessageDialog` needs to create itself is
    a GUI component to attach itself to, to be its parent. We could acquire `button
    evt` through `ActionEvent`, but this doesn''t make a lot of sense because the
    dialog is not tied just to the button; it''s tied to the entirety of what this
    GUI is about, which is validating a username and password. So it''d be nice if
    we could tie the message dialog box to JFrame form itself, the GUI''s top-level
    element, and in fact we can:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'If we scroll up a bit to our source code section to check exactly where we''re
    writing code, we''ll see that we''re in a class, called `MyGUI`, that extends
    the `JFrame` class. This entire class is associated with the `JFrame` class we''re
    working with. So, to pass `JFrame` as a variable to our `showMessageDialog` method,
    we simply use the `this` keyword. Now just type in a message to show the user
    upon password and username validation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s run our program and see what we''ve built. The dialogue box appears,
    which we''ve seen before and which we expect, and then perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Type in our valid username, that is, `username`.
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Type in our valid password, that is `java`.
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Then, hit the Submit button.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9fec4b08-91f9-4b42-8b45-a5be7830e506.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We get a dialog box that looks like the following screenshot. We can freely
    move this box in our JFrame instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/25daa1f0-039a-4e94-9c79-6c17cd0d5def.png)'
  prefs: []
  type: TYPE_IMG
- en: Just to test things out, let's put in some gobbledygook. We get nothing no matter
    how many times we click on Submit. Also, a good username and no password also
    gets us nothing, pretty cool! We've only scratched the surface of what is possible
    with Java GUIs and, of course, Java itself.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Java GUIs for our programs is easy and, in many cases, painless. Sometimes,
    the event handling model that GUIs force us to implement to some degree can even
    make creating our Java programs, which are heavily reliant on user interaction,
    easier than it would otherwise be.
  prefs: []
  type: TYPE_NORMAL
- en: The other important thing that I cannot stress enough is that even though the
    GUI designer is awesome, it's possible for us to create this exact same project
    by simply sitting down and writing the Java code in the Source code section.
  prefs: []
  type: TYPE_NORMAL
- en: I'm not saying we shouldn't use the GUI designer – especially because there's
    a lot of code and a lot of well-written code that's been generated for us by the
    GUI designer, which can save us a whole lot of time – but there's absolutely no
    magic happening here at all. This is all Java code making use of the `Swing` extension
    library.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we saw the basic functions of GUI in NetBeans. You learned
    how to create an application window with the `JFrame` class by setting its size,
    adding labels to it, and closing the application. Then, we dived into the topic
    of the GUI editor, palette. We saw a working palette and the components available
    in it. Lastly, you learned how to trigger events by adding a button and adding
    functionality to it.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you'll learn about XML.
  prefs: []
  type: TYPE_NORMAL
