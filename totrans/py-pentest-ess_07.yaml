- en: Foot Printing a Web Server and a Web Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have read four chapters that are related, from the data link layer
    to the transport layer. Now, we move on to application-layer penetration testing.
    In this chapter, we will go through the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The concept of foot printing a web server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing information gathering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTTP header checking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Information gathering of a website from smartwhois.com by the BeautifulSoup
    parser
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Banner grabbing of a website
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hardening of a web server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The concept of foot printing a web server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The concept of penetration testing cannot be explained or performed in a single
    step; therefore, it has been divided into several steps. Foot printing is the
    first step in pentesting, where an attacker tries to gather information about
    a target. In today's world, e-commerce is growing rapidly. Due to this, web servers
    have become a prime target for hackers. In order to attack a web server, we must
    first know what a web server is. We also need to know about the web-server hosting
    software, hosting operating system, and what applications are running on the web
    server. After getting this information, we can build our exploits. Obtaining this
    information is known as foot printing a web server.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing information gathering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will try to glean information about the web software, operating
    system, and applications that run on the web server, by using error-handling techniques.
    From a hacker's point of view, it is not that useful to gather information from
    error handling. However, from a pentester's point of view, it is very important
    because in the pentesting final report that is submitted to the client, you have
    to specify the error-handling techniques.
  prefs: []
  type: TYPE_NORMAL
- en: 'The logic behind error handling is to try to produce an error in a web server,
    which returns the code `404`, and to see the output of the error page. I have
    written a small code to obtain the output. We will go through the following code
    line by line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'I have imported three modules, `re`, `random`, and `urllib`, that are responsible
    for regular expressions, generating random numbers, and URL-related activities,
    respectively. The `url1 = raw_input("Enter the URL ")` statement asks for the
    URL of the website and stores this URL in the `url1` variable. Then, the `u =
    chr(random.randint(97,122))` statement creates a random character. The next statement
    adds this character to the URL and stores it in the `url2` variable. Then, the
    `http_r = urllib.urlopen(url2)` statement opens the `url2` page, and this page
    is stored in the `http_r` variable. The `content= http_r.read()` statement transfers
    all the contents of the web page into the content variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding piece of code defines the `i` variable flag and an empty list
    whose significance we will discuss later. The `a_tag` variable takes a value of `"<*address>"`.
    A `file_text` variable is a file object that opens the `result.txt` file in the
    append mode. The `result.txt` file stores the results. The while `flag ==0:` statement
    indicates that we want the `while` loop to run at least once. The `http_r.code`
    statement returns the status code from the web server. If the page is not found,
    it will return a `404` code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The preceding piece of code writes the output of the page in the `result.txt`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `for match in re.finditer(a_tag,content)`: statement finds the `a_tag`
    pattern, which means the `<address>` tag in the error page, since we are interested
    in the information between the `<address>` `</address>` tag. The `s= match.start()`
    and `e= match.end()` statements indicate the starting and ending points of the
    `<address>` tag and `list1.append(s)`. The `list1.append(e)` statement stores
    these points in the list so that we can use them later. The `i` variable becomes
    greater than `0`, which indicates the presence of the `<address>` tag in the error
    page. This means that the code is not good. The `if len(list1)>0`: statement indicates
    that if the list has at least one element, then variables `a` and `b` will be
    points of interest. The following diagram shows these points of interest:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/62de1d49-6b25-4653-a067-899b5f80106a.png)'
  prefs: []
  type: TYPE_IMG
- en: Fetching address tag values
  prefs: []
  type: TYPE_NORMAL
- en: The `print content[a:b]` statement reads the output between the **a** and **b**
    points and sets `flag = 1` to break the `while` loop. The `elif http_r.code ==
    200:` statement indicates that if the HTTP status code is `200`, then it will
    print the `"Web page is using custom Error page"` message. In this case, if code
    `200` returns for the error page, it means the error is being handled by the custom
    page.
  prefs: []
  type: TYPE_NORMAL
- en: Now it is time to run the output, and we will run it twice.
  prefs: []
  type: TYPE_NORMAL
- en: 'The outputs when the server signature is on and when the server signature is
    off:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4e36a9eb-7264-4acc-a547-99b18b1d56ab.png)'
  prefs: []
  type: TYPE_IMG
- en: The two outputs of the program
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding screenshot shows the output when the server signature is on.
    By viewing this output, we can say that the web software is Apache, the version
    is 2.2.3, and the operating system is Red Hat. In the next output, no information
    from the server means the server signature is off. Sometimes someone uses a web
    application firewall, such as mod-security, which gives a fake server signature.
    In this case, you need to check the `result.txt` file for the full, detailed output.
    Let''s check the output of `result.txt`, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7ed8bc70-6e70-48b6-8ea7-d934ac05996e.png)'
  prefs: []
  type: TYPE_IMG
- en: Output of result.txt
  prefs: []
  type: TYPE_NORMAL
- en: When there are several URLs, you can make a list of all these URLs and supply
    them to the program, and this file will contain the output of all the URLs.
  prefs: []
  type: TYPE_NORMAL
- en: Checking the HTTP header
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By viewing the header of the web pages, you can get the same output. Sometimes,
    the server error output can be changed by programming. However, checking the header
    might provide lots of information. A very small code can give you some very detailed
    information, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `print http_r.headers` statement provides the header of the web server.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/16d61af6-6978-4c44-bbcf-839c5bc0a245.png)'
  prefs: []
  type: TYPE_IMG
- en: Getting header information
  prefs: []
  type: TYPE_NORMAL
- en: 'You will notice that we have taken two outputs from the program. In the first
    output, we entered `http://www.juggyboy.com/` as the URL. The program provided
    lots of interesting information, for example `Server: Microsoft-IIS/6.0` and `X-Powered-By:
    ASP.NET`; it infers that the website is hosted on a Windows machine, the web software
    is IIS 6.0, and ASP.NET is used for web application programming.'
  prefs: []
  type: TYPE_NORMAL
- en: In the second output, I delivered my local machine's IP address, which is `http://192.168.0.5/`.
    The program revealed some secret information, such as the web software is Apache
    2.2.3, it is running on a Red Hat machine, and PHP 5.1 is used for web application
    programming. In this way, you can obtain information about the operating system,
    web server software, and web applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s look at what output we will get if the server signature is off:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/497d0456-eb7f-42a2-9c56-93bf1da1758f.png)'
  prefs: []
  type: TYPE_IMG
- en: When the server signature is off
  prefs: []
  type: TYPE_NORMAL
- en: From the preceding output, we can see that Apache is running. However, it shows
    neither the version nor the operating system. For web application programming,
    PHP has been used, but sometimes, the output does not show the programming language.
    For this, you have to parse the web pages to get any useful information, such
    as hyperlinks.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to get the details on headers, open dir of headers, as shown in
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Information gathering of a website from whois.domaintools.com
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Consider a situation where you want to glean all the hyperlinks from a web page.
    In this section, we will do this by programming. On the other hand, this can also
    be done manually by viewing the source of the web page. However, that will take
    some time.
  prefs: []
  type: TYPE_NORMAL
- en: So let's get acquainted with a very beautiful parser called lxml.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see the code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following modules will be used:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'When you enter the desired website, the `request` module obtains the data of
    the website:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The following piece of code gets the table from the website data:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The following `for` loop removes the space and null string from the table data:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code lines find the index of the `''IP Address''` string:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The next lines find the location of the website:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, I am printing just the IP address and location of the
    website. The following output shows I have used the program three times on three
    different websites: my college''s website, my website and the publisher''s website.
    In the three outputs, we are getting the IP address and location:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/51ee9d73-67e8-4d9c-9bfa-a59462590424.png)'
  prefs: []
  type: TYPE_IMG
- en: Email address gathering from a web page
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will learn how to find the email addresses from a web page.
    In order to find the email addresses, we will use the regular expressions. The
    approach is very simple: first, get all the data from a given web page, then use
    email regular expression to obtain email addresses.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is very simple. The `html_page` variable contains all the
    web page data. The `r'\b[\w.-]+?@\w+?\.\w+?\b'` regular expression represents
    the email address.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s see the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/951e4517-bfe3-40b6-8c77-d0cd5e690e4d.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding result is absolutely correct. The given URL web page was made
    by me for testing purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Banner grabbing of a website
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will grab the HTTP banner of a website. Banner grabbing,
    or OS fingerprinting, is a method to determine the operating system that is running
    on a target web server. In the following program, we will sniff the packets of
    a website on our computer, as we did in [Chapter 3](4cbd4179-2d24-454b-b279-bcdae27210e2.xhtml),
    *Sniffing and Penetration Testing*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for the banner grabber is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Since you have read [Chapter 3](4cbd4179-2d24-454b-b279-bcdae27210e2.xhtml),
    *Sniffing and Penetration Testing*, you should be familiar with this code. The
    `banner = pkt[0][54:533]` statement is new here. Before `pkt[0][54:]`, the packet
    contains TCP, IP, and Ethernet information. After doing some trail and error,
    I found that the banner-grabbing information resides between `[54:533]`.You can
    do trail and error by taking slices `[54:540], [54:545], [54:530]`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get the output, you have to open the website in a web browser while the
    program is running, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/31b27118-6e4f-4b18-baea-1919aed3d685.png)'
  prefs: []
  type: TYPE_IMG
- en: Banner grabbing
  prefs: []
  type: TYPE_NORMAL
- en: So, the preceding output shows that the server is Microsoft-IIS.6.0, and ASP.NET
    is the programming language being used. We get the same information as we received
    in the header-checking process. Try this code and get some more information with
    different status codes.
  prefs: []
  type: TYPE_NORMAL
- en: By using the previous code, you can prepare information-gathering reports for
    yourself. When I apply information-gathering methods to websites, I generally
    find lots of mistakes made by clients. In the next section, you will see the most
    common mistakes found on a web server.
  prefs: []
  type: TYPE_NORMAL
- en: Hardening of a web server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, let''s shed some light on common mistakes observed on a web
    server. We will also discuss some points to harden the web server:'
  prefs: []
  type: TYPE_NORMAL
- en: Always hide your server signature.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If possible, set a fake server signature to mislead attackers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handle the errors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If possible, use a virtual environment (jailing) to run the application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Try to hide the programming language page extensions, because it will be difficult
    for the attacker to see the programming language of the web applications.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Update the web server with the latest patch from the vendor. It avoids any chance
    of exploitation of the web server. The server can at least be secured for known
    vulnerabilities.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don't use a third-party patch to update the web server. A third-party patch
    may contain trojans or viruses.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do not install other applications on the web server. If you install an OS, such
    as RHEL or Windows, don't install other unnecessary software, such as Office or
    editors, because they might contain vulnerabilities.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Close all ports except `80` and `443`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don't install any unnecessary compilers, such as gcc, on the web server. If
    an attacker compromised a web server and they wanted to upload an executable file,
    the IDS or IPS can detect that file. In this situation, the attacker will upload
    the code file (in the form of a text file) on the web server and will execute
    the file on the web server. This execution can damage the web server.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set a limit on the number of active users in order to prevent a DDoS attack.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enable the firewall on the web server. The firewall does many things, such as
    closing the port and filtering the traffic.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about the importance of a web server signature,
    and that obtaining the server signature is the first step in hacking.
  prefs: []
  type: TYPE_NORMAL
- en: '"Give me six hours to chop down a tree and I will spend the first four sharpening
    the axe."'
  prefs: []
  type: TYPE_NORMAL
- en: – Abraham Lincoln
  prefs: []
  type: TYPE_NORMAL
- en: The same thing applies in our case. Before the start of an attack on a web server,
    it is better to check exactly which services are running on it. This is done by
    foot printing the web server. Error-handling techniques are a passive process.
    Header checking and banner grabbing are active processes to gather information
    about the web server. In this chapter, we have also learned about the BeautifulSoup
    parser. Sections such as hyperlinks, tags, and IDs can be obtained from BeautifulSoup.
    In the last section, we covered some guidelines for hardening a web server. If
    you follow those guidelines, you can make your web server difficult to attack.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn about client-side validation and parameter
    tampering. You will learn how to generate and detect DoS and DDOS attacks.
  prefs: []
  type: TYPE_NORMAL
