- en: Using Pipes and Redirection in Scripts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll explain a very important aspect of Bash: *redirection*.
    We''ll start by describing the different types of input and output redirections,
    and how they are related to Linux file descriptors. After the basics of redirection
    are covered, we will continue with some advanced uses.'
  prefs: []
  type: TYPE_NORMAL
- en: Next up are *pipes*, which is a concept used heavily within shell scripting.
    We present a few practical examples of pipes. Finally, we show how *here documents*
    work, which also have some great uses.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following commands will be introduced in this chapter: `diff`, `gcc`, `fallocate`,
    `tr`, `chpasswd`, `tee`, and `bc`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Input/output redirection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pipes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here documents
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All scripts for this chapter can be found on GitHub at the following link:
    [https://github.com/tammert/learn-linux-shell-scripting/tree/master/chapter_12](https://github.com/tammert/learn-linux-shell-scripting/tree/master/chapter_12).
    For all other exercises, your Ubuntu 18.04 virtual machine is still your best
    friend.'
  prefs: []
  type: TYPE_NORMAL
- en: Input/output redirection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will discuss redirection in Linux in detail.
  prefs: []
  type: TYPE_NORMAL
- en: 'Simply put, redirection is pretty much exactly as the word implies: the redirecting
    of *something* to *something else*. For example, we''ve already seen that we can
    use the output of one command as the input for the next command, using pipes.
    Pipes are implemented in Linux using the `|` sign.'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, that might raise the question: how does Linux deal with input and
    output in the first place? We''ll begin our journey into redirection with some
    theory on **file descriptors**, which are what make all redirection possible!'
  prefs: []
  type: TYPE_NORMAL
- en: File descriptors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You might be tired of hearing it, but it is still no less true: in Linux, everything
    is a file. We''ve seen that a file is a file, a directory is a file, even hard
    disks are files; but now, we''ll take this one step further: your keyboard, which
    you use for *input*, is also a file!'
  prefs: []
  type: TYPE_NORMAL
- en: 'Complementary to that, your Terminal, which commands use as *output*, is, guess
    what: a file.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find these files, as with most special files, within your Linux filesystem
    tree. Let''s check our virtual machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Out of the four files we find here, three are important: `/dev/fd/0`, `/dev/fd/1`,
    and `/dev/fd/2`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you might suspect from the heading of this text, **fd** stands for **f**ile
    **d**escriptor. These file descriptors are used internally to bind input and output
    from and to the user to a Terminal. You can actually see how this is done with
    the file descriptors: they are symbolically linked to `/dev/pts/0`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this instance, **pts** stands for **pseudo Terminal slave**, which is the
    definition given to SSH connections. Look at what happens when we look at `/dev/fd`
    from three different locations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Each of these connections has their own `/dev/` mount (which is of `udev` type,
    stored in memory), which is why we do not see output from one connection into
    the other one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we''ve been talking about input and output. But, as you have no doubt
    seen, there are three file descriptors allocated in the preceding examples. In
    a Linux (or Unix/Unix-like system), there are three default **streams** which
    are exposed by default through file descriptors:'
  prefs: []
  type: TYPE_NORMAL
- en: The *standard input* stream, `stdin`, by default bound to `/dev/fd/0`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *standard output* stream, `stdout`, by default bound to `/dev/fd/1`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *standard error* stream, `stderr`, by default bound to `/dev/fd/2`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As far as these three streams go, `stdin` and `stdout` should be rather straightforward:
    input and output. However, as you might have deduced, output is actually split
    into *normal* output and *error* output. Normal output is sent to the `stdout`
    file descriptor, while error output is often sent to `stderr`.'
  prefs: []
  type: TYPE_NORMAL
- en: Since both of these are symbolically linked to the Terminal, you will see them
    there no matter what. However, as we will see later on in this chapter, as soon
    as we start redirecting, this difference becomes important.
  prefs: []
  type: TYPE_NORMAL
- en: You might see some other file descriptors, such as the 255 in the first example.
    Besides their use in supplying input and output to the Terminal, file descriptors
    are also used when Linux opens a file in the filesystem. This other use of file
    descriptors is outside of the scope for this book; we have, however, included
    a link in the *Further reading* section for those interested.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a normal interaction, text you type in a Terminal gets written to `stdin`
    on `/dev/fd/0`, which a command can read. Using that input, the command usually
    does something (otherwise, we wouldn''t need the command!) and writes the output
    to `stdout` or `stderr`. where it will be read by the Terminal for display to
    you. So in short:'
  prefs: []
  type: TYPE_NORMAL
- en: A *Terminal* **writes** to `stdin` and **reads** from `stdout` or `stderr`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A *command* **reads** from `stdin` and **writes** to `stdout` or `stderr`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Besides the file descriptors Linux uses internally, there are also a few file
    descriptors reserved for when you want to create really advanced scripts; these
    are 3 through 9\. Any others *might* be used by the system, but these are guaranteed
    free for your use. As this is, as stated, very advanced and not used too often,
    we will not go into detail. However, we've found some further reading which might
    be interesting, which is included at the end of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Redirecting output
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that the theory on input, output, and file descriptors should be clear,
    we're going to see how we can use these techniques in our command-line and scripting
    adventures.
  prefs: []
  type: TYPE_NORMAL
- en: It is in fact pretty hard to write shell scripts without using redirection;
    we've actually used redirection a couple of times in the book before this chapter,
    because we really needed it to get our stuff done at that time (`file-create.sh`
    in [Chapter 8](41d3c327-f6d6-4ec5-8ec9-127e493bdd05.xhtml), *Variables and User
    Input*, for example).
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's get some real experience with redirection out of the way!
  prefs: []
  type: TYPE_NORMAL
- en: stdout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Most output from commands will be *standard output*, written to `stdout` on
    `/dev/fd/1`. By using the `>` symbol, we can redirect this out with the following
    syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: A redirect will always be made to a file (however, as we know, not all files
    are equal, so after the regular examples, we'll show you some Bash magic where
    non-regular files are concerned). If the file does not exist, it will be created.
    If it does exist, it will be **overwritten**.
  prefs: []
  type: TYPE_NORMAL
- en: 'In its simplest form, everything that would normally be printed to your Terminal
    can be redirected to a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As you know, `cat` prints the whole file content to your Terminal. In reality,
    it actually sends the whole content to `stdout`, which is bound to `/dev/fd/1`,
    which is bound to your Terminal; this is why you see it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if we redirect the content of the file back to another file, we''ve essentially
    made a great effort to... copy a file! From the file sizes you can see that it
    is actually the same file. If you''re unsure, you can use the `diff` command to
    see if the files are the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: If `diff` does not return any output, and it has an exit code of `0`, there
    are no differences in the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back to the redirection example. We used `>` to redirect the output to the
    file. In reality, `>` is shorthand for `1>`. You might recognize this `1`: it
    refers to the file descriptor `/dev/fd/1`. As we''ll see when we''re dealing with
    `stderr`, which is on `/dev/fd/2`, we will use `2>` instead of `1>` or `>`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, however, let''s build a simple script to illustrate this a little bit
    further:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now, when we run this, `read` will prompt us to input some text. This will be
    saved in the `user_input` variable. Then, we'll use `echo` to send the content
    of the `user_input` variable to `stdout`. But, instead of it reaching the Terminal
    on `/dev/pts/0` via `/dev/fd/1`, we redirect it to the `redirect-to-file.txt` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'All in all, it looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, this works as advertised. However, if we run it again, we see two things
    that can go wrong with this script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The first thing that goes wrong, which we've warned about before, is that relative
    paths might mess up where the file is written.
  prefs: []
  type: TYPE_NORMAL
- en: You might have envisioned that the file was created right next to the script;
    this will only happen if your *current working directory* is in the directory
    where the script is. Because we call it from lower in the tree, the output is
    written there (since that is the current working directory).
  prefs: []
  type: TYPE_NORMAL
- en: The other problem is that each time we type something in, we remove the old
    content of the file! After we type `Hello`, we see that the file is six bytes
    (one byte for each character, plus a newline), and after we typed `Bye`, we now
    see that the file is only four bytes (three characters plus the newline).
  prefs: []
  type: TYPE_NORMAL
- en: This might be the desired behavior, but more often than not it is much nicer
    if the output is *appended* to the file, instead of replacing it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s solve both issues in a new version of the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we run it (from wherever), we''ll see that new text gets appended to
    the first sentence, `I like dogs! And cats. Maybe a gecko?` in the `/home/reader/chapter_12/redirect-to-file.txt` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: So, `cd $(dirname $0)` helped us with our relative paths, and a `>>` instead
    of `>` ensured appending instead of overwriting. As you might expect, `>>` is
    again short for `1>>`, as we will see when we start redirecting `stderr` streams
    in a bit.
  prefs: []
  type: TYPE_NORMAL
- en: 'A little while back, we promised you some Bash magic. While not exactly magic,
    it might hurt your head just a little:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: So, we've managed to print our file using `cat` a total of four times. We could
    have done that with `for` as well, you might be thinking, but the lesson is not
    the amount of times we printed the message, but how we did it!
  prefs: []
  type: TYPE_NORMAL
- en: First, we just used `cat`; nothing special there. Next, we used `cat` in combination
    with a redirection of `stdout` to `/dev/pts/0`, our Terminal. Again, the message
    is printed.
  prefs: []
  type: TYPE_NORMAL
- en: The third and fourth times, we sent the redirected `stdout` of `cat` to `/dev/fd/1`
    and `/dev/fd/2`. Since these are symlinked to `/dev/pts/0`, it's not really surprising
    that these also end up on our Terminal.
  prefs: []
  type: TYPE_NORMAL
- en: How then do we actually differentiate between `stdout` and `stderr`?
  prefs: []
  type: TYPE_NORMAL
- en: stderr
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you were confused by the preceding example, that was probably because you
    misunderstood the flow that `stderr` messages take (and we don't blame you, we
    confused ourselves there!). While we sent the output of the `cat` command to `/dev/fd/2`,
    we used `>`, which sends `stdout` and not `stderr`.
  prefs: []
  type: TYPE_NORMAL
- en: So in our example, we just abused the `stderr` file descriptor to print to the
    Terminal; bad practice. We promise not to do it again. Now then, how can we *actually*
    work with `stderr` messages?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This interaction should illustrate some things. First, when `cat /root/` throws
    a `Permission denied` error, it sends it to `stderr` instead of `stdout`. We can
    see this, because when we do the same command but we try to redirect the *standard*
    *output* with `1> error-file`, we still see the output *in the Terminal* and we
    also see that `error-file` is empty.
  prefs: []
  type: TYPE_NORMAL
- en: When instead we use `2> error-file`, which redirects `stderr` instead of regular
    `stdout`, we do not see the error message in our Terminal anymore.
  prefs: []
  type: TYPE_NORMAL
- en: Even better, we now see that `error-file` has 31 bytes of content, and when
    we print it with `cat`, we once again see our redirected error message! As mentioned
    before, and in the same spirit as `1>>`, if you'd like to *append* instead of
    *overwrite* the `stderr` stream to a file, use `2>>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, because it is hard to find a command that prints both `stdout` and `stderr`
    in the same command, we''ll create our own: a very simple C program which prints
    two lines of text, one to `stdout` and one to `stderr`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As a sneak preview into programming and compiling, look at this (don''t worry
    if you don''t fully understand this):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `gcc stderr.c -o stderr` command compiles the source code found in `stderr.c`
    to the binary `stderr`.
  prefs: []
  type: TYPE_NORMAL
- en: '`gcc` is the GNU Compiler Collection, and is not always installed by default.
    If you want to follow along with this example and you''re getting an error about
    not being able to find `gcc`, install it using `sudo apt install gcc -y`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run our program, we get two lines of output. Because this is not a Bash
    script, we cannot execute it with `bash stderr`. We need to make the binary executable
    with `chmod`, and run it with `./stderr`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s see what happens when we start redirecting part of this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Because we only redirected `stdout` (last reminder: `>` equals `1>`) to the
    fully-qualified file `/tmp/stdout`, the `stderr` message was still printed to
    the Terminal.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The other way around gives similar results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Now, when we only redirect `stderr` using `2> /tmp/stderr`, we see the `stdout`
    message appear in our Terminal and the `stderr` is correctly redirected to the `/tmp/stderr` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'I''m sure you''re asking yourself this question right now: how can we redirect
    **all output**, both `stdout` and `stderr`, to a file? If this was a book about
    Bash 3.x, we''d be having a difficult conversation. That conversation would entail
    us redirecting `stderr` to `stdout`, after which we could use `>` to send all
    output (because we already diverted `stderr` to `stdout` in the first place) to
    a single file.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Even though that is the logical way to do it, the redirection of `stderr` to
    `stdout` is actually present at the end of the command. The command ends up like
    this: `./stderr > /tmp/output 2>&1`. Not *too complex*, but hard enough that you
    never really remember it in one go (you can trust us on this).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, in Bash 4.x we have a new redirection command available to us
    that can do the same thing, but in a much more understandable fashion: `&>`.'
  prefs: []
  type: TYPE_NORMAL
- en: Redirect all output
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In most situations, output that is sent to `stderr` instead of `stdout` will
    contain words that make it clear you're dealing with an error. This will include
    examples such as `permission denied`, `cannot execute binary file`, `syntax error
    near unexpected token`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Because of this, it is often not really necessary to split output into `stdout`
    and `stderr` (but, obviously, sometimes it will be great functionality). In these
    cases, the addition to Bash 4.x that allows us to redirect both `stdout` and `stderr`
    with a single command is perfect. This redirection, which you can use with the
    syntax `&>`, does not work differently to the earlier examples we have seen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s review our previous example and see how this makes our lives easier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Excellent! With this syntax, we no longer have to worry about the different
    output streams. This is especially practical when working with commands that are
    new to you; in this case, you might miss interesting error messages because they
    got lost when the `stderr` stream is not saved.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the risk of sounding repetitive, the syntax for appending both `stdout`
    and `stderr` to a file is again an extra `>`: `&>>`.'
  prefs: []
  type: TYPE_NORMAL
- en: Go ahead and try it out with the previous example. We won't print it here, because
    it should be obvious by now how this works.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unsure about whether to redirect all output, or just `stdout` or `stderr`?
    Our advice: start with redirecting **both** to the same file. If in your use case
    this gives too much noise (either masking errors or normal log messages), you
    could always decide to redirect either of them to a file, and get the other printed
    in your Terminal. Often, in practice, `stderr` messages need the context provided
    by `stdout` messages to make sense of the error anyway, so you may as well have
    them conveniently located in the same file!'
  prefs: []
  type: TYPE_NORMAL
- en: Special output redirection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While sending all output is often a nice thing to do, another thing you will
    find yourself doing on a regular basis is redirecting errors (which you expect
    on some commands) to a special device: `/dev/null`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `null` kind of gives away the functionality: it''s somewhere between a
    trash can and a black hole.'
  prefs: []
  type: TYPE_NORMAL
- en: /dev/null
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In reality, all data sent (actually, written) to `/dev/null` will be discarded,
    but nonetheless generate a *write operation succeeded* back to the calling command.
    In this case, that would be the redirection.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is important, because look what happens when a redirection is unable to
    complete successfully:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This operation fails (because the `reader` user obviously can't write in the
    home directory of the `root` superuser).
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at what happens when we try the same thing with `/dev/null`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: That's all there is to it. All the output is gone (both `stdout` and `stderr`,
    because of the `&>` redirection), but the command still reports the desirable
    exit status of `0`. When we make sure that the data is gone, we use `cat /dev/null`,
    which results in nothing.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll show you a practical example that you will no doubt find yourself using
    often in your scripting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This script contains only constructs we've introduced before, apart from the
    `/dev/null` redirection of `stderr`. While this `find.sh` script is in fact nothing
    more than a simple wrapper around the `find` command, it makes a big difference.
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at what happens when we use `find` to look for the file `find.sh` file
    (because why not!):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We've cut out about 95% of the output, since you would probably agree there
    isn't much merit in five pages of `Permission denied` errors. Because we're running
    `find` as a normal user, we do not have access to many parts of the system. These
    errors reflect this.
  prefs: []
  type: TYPE_NORMAL
- en: We did actually locate our script, as highlighted earlier, but it could take
    a few minutes of scrolling before you encounter it. This is exactly what we meant
    about error output drowning relevant output.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s look for the same file with our wrapper script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: There we go! Same result, but without all those pesky errors confusing us. Since
    the `Permission denied` errors are sent to the `stderr` stream, we *deleted* them
    using `2> /dev/null` after the `find` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'This actually brings us to another point: you can use redirection to silence
    commands as well. We''ve seen many commands that incorporate a `--quiet` or `-q`
    flag. Some commands, though, such as `find`, do not have this flag.'
  prefs: []
  type: TYPE_NORMAL
- en: You could argue that it would be weird for `find` to have this flag (why search
    for files when you don't want to know where it is, right?), but there might be
    other commands in which exit codes present enough information, but do not have
    a `--quiet` flag; those are great candidates for redirection of everything to
    `/dev/null`.
  prefs: []
  type: TYPE_NORMAL
- en: All commands are different. While most have an available `--quiet` flag by now,
    there will always be cases in which this does not work for you. Perhaps the `--quiet`
    flag only silences `stdout` and not `stderr`, or perhaps it only reduces output.
    In any case, knowledge about redirecting all output to `/dev/null` when you're
    really not interested in that output (only in the exit status) is a very good
    thing to have!
  prefs: []
  type: TYPE_NORMAL
- en: /dev/zero
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another special device we can use is `/dev/zero`. When we redirect output to
    `/dev/zero`, it does exactly the same as `/dev/null`: the data disappears. However,
    in practice, `/dev/null` is most often used for this purpose.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, why have this special device then? Because `/dev/zero` can also be used
    to read null bytes. Out of all possible 256 bytes, the null byte is the first:
    the hexadecimal `00`. A null byte is often used to signify the termination of
    a command, for example.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can also use these empty bytes to allocate bytes to the disk:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: By using `head -c 1024`, we specify we want the *first 1024 characters from*
    `/dev/zero`. Because `/dev/zero` only supplies null bytes, these will all be the
    same, but we know for sure that there will be `1024` of them.
  prefs: []
  type: TYPE_NORMAL
- en: 'We redirect those to a file using `stdout` redirection, and we then see a file
    with a size of 1024 bytes (how surprising). Now, if we `cat` this file, we see
    nothing! Again, this should not be a surprise, because null bytes are exactly
    that: empty, void, null. The Terminal has no way of representing them, so it does
    not.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Should you ever need to do this in a script, there is another option for you:
    `fallocate`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the preceding output, this command does exactly what we
    already accomplished with our `/dev/zero` read and redirection (we wouldn't be
    surprised if `fallocate` was actually a fancy wrapper around reading from `/dev/zero`,
    but we can't say this for sure).
  prefs: []
  type: TYPE_NORMAL
- en: Input redirection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Two other famous special devices, `/dev/random` and `/dev/urandom`, are best
    discussed in tandem with the next bit of redirection: *input redirection*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Input normally comes from your keyboard, passed through by the Terminal to
    the command. The easiest example for this is the `read` command: it reads from
    `stdin` until it encounters a newline (when the *Enter* key is pressed) and then
    saves the input to the `REPLY` variable (or anything custom, should you have given
    that argument). It looks a bit like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Easy. Now, let's say we run this command non-interactively, which means we cannot
    use a keyboard and Terminal to supply the information (not a real use case for
    `read`, but this makes for a nice example).
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we can use input redirection (of `stdin`) to supply the input
    to `read`. This is achieved with the `<` character, which is shorthand for `<0`.
    Remember that the `stdin` file descriptor was `/dev/fd/0`? Not a coincidence.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use `read` in a non-interactive manner by redirecting `stdin` to read
    from a file, instead of the Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: To show that we're not cheating and reusing the already stored answer in the
    `${answer}` variable, we've renamed the variable in which the reply for `read`
    is stored to `${new_answer}`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, at the end of the command we redirected `stdin` from the `answer-file` file,
    which we created first using `echo` + redirection of `stdout`. This was as simple
    as adding `< answer-file` after the command.
  prefs: []
  type: TYPE_NORMAL
- en: This redirection makes `read` read from the file until a newline is encountered
    (which is conveniently what `echo` always ends a string with).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the basics of input redirection should be clear, let''s get back to
    our special devices: `/dev/random` and `/dev/urandom`. These two special files
    are pseudo-random number generators, which is a complicated word for something
    that generates *almost* random data.'
  prefs: []
  type: TYPE_NORMAL
- en: In the case of these special devices, they gather *entropy* (a complicated word
    for something like randomness) from things like device drivers, mouse movements,
    and other things that are mostly random.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a slight difference between `/dev/random` and `/dev/urandom`: when
    there is not enough entropy in the system, `/dev/random` stops generating random
    output, while `/dev/urandom` keeps going.'
  prefs: []
  type: TYPE_NORMAL
- en: If you really need full entropy, `/dev/random` might be the better choice (in
    all honesty, you're probably taking other measures in that situation anyway), but
    most often, `/dev/urandom` is the better choice in your scripting, since blocking
    can create incredible wait times. This comes from first-hand experience and can
    be very inconvenient!
  prefs: []
  type: TYPE_NORMAL
- en: For our examples, we'll only show `/dev/urandom`; output from `/dev/random`
    is similar.
  prefs: []
  type: TYPE_NORMAL
- en: In practice, `/dev/urandom` spits out bytes *randomly*. While some bytes are
    in the printable ASCII character range (1-9, a-z, A-Z), others are used for whitespaces
    (0x20) or newlines (0x0A).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see the randomness by using `head -1` to grab ''the first line'' from
    `/dev/urandom`. Since a line is terminated by a newline, the command `head -1
    /dev/urandom` will print everything until the first newline: this can be a few
    or a lot of characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The first instance we ran printed a lot more characters (not all of them readable)
    than the second time around; this can be directly linked to the randomness of
    the bytes generated. The second time we ran `head -1 /dev/urandom`, we encountered
    the newline byte, 0x0A, faster than the first iteration.
  prefs: []
  type: TYPE_NORMAL
- en: Generating a password
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, you might be wondering what use random characters might have. A prime example
    is generating passwords. Long, random passwords are always good; they're resistant
    to brute-force attacks, cannot be guessed, and, if not reused, are **very** secure.
    And let's be honest, how cool is it to generate a random password using the entropy
    from your own Linux system?
  prefs: []
  type: TYPE_NORMAL
- en: 'Even better, we can use input redirection from `/dev/urandom` to accomplish
    this, together with the `tr` command. A simple script would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The header and input checks, even the one with the regular expression checking
    for a digit, should be clear by now.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we use the `tr` command with redirected input from `/dev/urandom` to grab
    readable characters in our set of a-z, A-Z, and 0-9\. These are *piped* to `head`
    (more on pipes later in this chapter), which causes the first *x* characters for
    be printed to the user (as specified in the argument to the script).
  prefs: []
  type: TYPE_NORMAL
- en: To make sure the Terminal formatting is correct, we throw in a quick `echo`
    without an argument; this just prints a newline. And just like this, we've built
    our own *private*, *secure*, and *offline* password generator. Using input redirection,
    even!
  prefs: []
  type: TYPE_NORMAL
- en: Advanced redirecting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've now seen both input and output redirection, and some practical uses for
    both. We have not, however, combined both forms of redirection yet, and this is
    very much possible!
  prefs: []
  type: TYPE_NORMAL
- en: You will probably not use this too often, though; most commands accept the input
    as an argument, and often supply a flag that allows you to specify a file to output
    to. But knowledge is power, and if you ever come across a command that does not
    have these arguments, you know you can solve this yourself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try the following on your command line, and try to understand why you get the
    results that you see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we can use both `<` and `>` on the same line to redirect both
    the input and output. First, we use `grep` with input redirection in the `grep
    'stderr' < stderr.c` command (which is technically what `grep 'stderr' stderr.c`
    does as well). We see the output in our Terminal.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we add `> /tmp/grep-file` right behind that command, which means we'll
    redirect our `stdout` to that `/tmp/grep-file` file. We no longer see the output
    in the Terminal, but when we `cat` the file we get it back, so it was successfully
    written to the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we''re in the advanced part of this chapter, we will demonstrate that
    it actually doesn''t matter where the input redirection is placed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Here, we specified the input redirection at the beginning of our command. For
    us, this feels like the more logical approach when you consider the flow, but
    this causes the actual command (`grep`) to appear roughly halfway through the
    command, which messes up the readability.
  prefs: []
  type: TYPE_NORMAL
- en: This is mostly a moot point because, in practice, we have found very little
    use for both input and output redirection; even in this example, we would just
    write the command as `grep 'stdout' stderr.c > /tmp/grep-file-stdout` and the
    confusing construction is gone.
  prefs: []
  type: TYPE_NORMAL
- en: But really understanding what is going on with input and output, and how some
    commands do some of the heavy lifting for you, is worth your time! These are exactly
    the kind of issues you're going to encounter in more complex scripts, and fully
    understanding this will save you a lot of troubleshooting time.
  prefs: []
  type: TYPE_NORMAL
- en: Redirecting redirections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We already gave you a sneak preview of the process of redirecting redirections.
    The most famous example, which was mostly used before Bash 4.x, is redirecting
    the `stderr` stream to the `stdout` stream. By doing this, you can redirect *all*
    output with just the `>` syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can achieve it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Remember, you no longer need this syntax with Bash 4.x, but if you ever want
    to use your own custom file descriptors as input/output streams, this will be
    useful knowledge. By ending the command with `2>&1`, we're writing all `stderr`
    output (`2>`) to the `stdout` descriptor (`&1`).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also do it the other way around:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: So now, we're redirecting the `stderr` stream to the `passwd` file. However,
    the `head -1 /etc/passwd` command only delivers an `stdout` stream; we're seeing
    it printed to the Terminal instead of to the file.
  prefs: []
  type: TYPE_NORMAL
- en: When we use `1>&2` (which could also be written as `>&2`) we're redirecting
    `stdout` to `stderr`. Now it is written to the file and we can `cat` it there!
  prefs: []
  type: TYPE_NORMAL
- en: Remember, this is advanced information, which is mostly useful for your theoretical
    understanding and when you start working with your own custom file descriptors.
    For all other output redirections, play it safe and use the `&>` syntax as we
    discussed earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Command substitution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While not strictly redirection in the Linux sense, *command substitution* in
    our eyes is a form of functional redirection: you use the output of a command
    as an argument to another command. If we needed to use output as input for the
    next command, we''d use a pipe (as we''ll see in a few pages), but sometimes we
    just need that output at a very specific location in our command.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is where command substitution is used. We''ve already seen command substitution
    in some of our scripts: `cd $(dirname $0)`. Simply put, this does something like
    `cd` to the result of `dirname $0`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`dirname $0` gives back the directory where the script is located (since `$0`
    is the fully-qualified path of the script), so when we use this with scripts,
    we''ll make sure all operations are always carried out relative to the directory
    where the script is located.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we did not have command substitution, we''d need to store the output somewhere
    before we could use it again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'While this *sometimes* works, there are some pitfalls here:'
  prefs: []
  type: TYPE_NORMAL
- en: You need to write a file somewhere where you have write permissions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You need to clean up the file after the `cd`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You need to make sure the file does not conflict with other scripts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To cut a long story short, this is a far from ideal solution, and best avoided.
    And since Bash supplies command substitution, there is no real drawback to using
    it. As we've seen, the command substitution in `cd $(dirname $0)` handles this
    for us, without the need for us to track files or variables or any other complicated
    constructions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Command substitution is actually used quite a lot in Bash scripting. Take a
    look at the following example, in which we use command substitution to instantiate
    and populate a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: For this example, we reused the logic in our earlier `password-generator.sh`
    script. This time, we do not give the user the option to supply a length; we keep
    it simple and assume a length of 20 (which is, at least in 2018, a pretty good
    length for a password).
  prefs: []
  type: TYPE_NORMAL
- en: We use command substitution to write the result (the random password) to a variable,
    which we then `echo` to the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'We actually could have done this in a single line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: However, as we have discussed many times by now, *readability counts* (still!).
    We feel that first writing to a variable with a descriptive name, before we actually
    use it, increases the readability of the script.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, if we wanted to use the same random value more than once, we need
    a variable anyway. So in this case, the extra verbosity in our script helps us
    and is desirable.
  prefs: []
  type: TYPE_NORMAL
- en: The predecessor to `$(..)` was the use of backticks, which is the [PRE35]
  prefs: []
  type: TYPE_NORMAL
- en: <(command)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: reader@ubuntu:~/scripts/chapter_12$ diff <(ls /tmp/) <(ls /home/)
  prefs: []
  type: TYPE_NORMAL
- en: 1,11c1
  prefs: []
  type: TYPE_NORMAL
- en: < directory-file
  prefs: []
  type: TYPE_NORMAL
- en: < grep-file
  prefs: []
  type: TYPE_NORMAL
- en: < grep-file-stdout
  prefs: []
  type: TYPE_NORMAL
- en: < passwd
  prefs: []
  type: TYPE_NORMAL
- en: < shadow
  prefs: []
  type: TYPE_NORMAL
- en: '---'
  prefs: []
  type: TYPE_NORMAL
- en: reader
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: reader@ubuntu:/tmp$ echo 'Fly into the distance' > file
  prefs: []
  type: TYPE_NORMAL
- en: reader@ubuntu:/tmp$ grep 'distance' < file
  prefs: []
  type: TYPE_NORMAL
- en: Fly into the distance reader@ubuntu:/tmp$ echo 'Fly into the distance' | grep
    'distance'Fly into the distance
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: command-with-output | command-using-input
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: reader@ubuntu:~/scripts/chapter_12$ cat /etc/shadow | grep 'denied'
  prefs: []
  type: TYPE_NORMAL
- en: 'cat: /etc/shadow: Permission denied'
  prefs: []
  type: TYPE_NORMAL
- en: reader@ubuntu:~/scripts/chapter_12$ cat /etc/shadow | grep 'denied' > /tmp/empty-file
  prefs: []
  type: TYPE_NORMAL
- en: 'cat: /etc/shadow: Permission denied #Printed to stderr on terminal.'
  prefs: []
  type: TYPE_NORMAL
- en: reader@ubuntu:~/scripts/chapter_12$ cat /etc/shadow | grep 'denied' 2> /tmp/error-file
  prefs: []
  type: TYPE_NORMAL
- en: 'cat: /etc/shadow: Permission denied #Printed to stderr on terminal.'
  prefs: []
  type: TYPE_NORMAL
- en: reader@ubuntu:~/scripts/chapter_12$ cat /tmp/empty-file
  prefs: []
  type: TYPE_NORMAL
- en: reader@ubuntu:~/scripts/chapter_12$ cat /tmp/error-file
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: reader@ubuntu:~/scripts/chapter_12$ cat /etc/shadow |& grep 'denied'
  prefs: []
  type: TYPE_NORMAL
- en: 'cat: /etc/shadow: Permission denied'
  prefs: []
  type: TYPE_NORMAL
- en: reader@ubuntu:~/scripts/chapter_12$ cat /etc/shadow |& grep 'denied' > /tmp/error-file
  prefs: []
  type: TYPE_NORMAL
- en: reader@ubuntu:~/scripts/chapter_12$ cat /tmp/error-file
  prefs: []
  type: TYPE_NORMAL
- en: 'cat: /etc/shadow: Permission denied'
  prefs: []
  type: TYPE_NORMAL
- en: reader@ubuntu:~/scripts/chapter_12$ cat /etc/shadow |& grep 'denied' 2> /tmp/error-file
  prefs: []
  type: TYPE_NORMAL
- en: 'cat: /etc/shadow: Permission denied'
  prefs: []
  type: TYPE_NORMAL
- en: reader@ubuntu:~/scripts/chapter_12$ cat /tmp/error-file
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: reader@ubuntu:~/scripts/chapter_12$ vim piped-passwords.sh
  prefs: []
  type: TYPE_NORMAL
- en: reader@ubuntu:~/scripts/chapter_12$ cat piped-passwords.sh
  prefs: []
  type: TYPE_NORMAL
- en: '#!/bin/bash'
  prefs: []
  type: TYPE_NORMAL
- en: '#####################################'
  prefs: []
  type: TYPE_NORMAL
- en: 'Author: Sebastiaan Tammer'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Version: v1.0.0'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Date: 2018-11-10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Description: Generate a password, using only pipes.'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Usage: ./piped-passwords.sh'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '#####################################'
  prefs: []
  type: TYPE_NORMAL
- en: password=$(head /dev/urandom | tr -dc 'a-zA-Z0-9' | head -c20)
  prefs: []
  type: TYPE_NORMAL
- en: 'echo "Your random password is: ${password}"'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: reader@ubuntu:~/scripts/chapter_12$ vim password-setter.sh
  prefs: []
  type: TYPE_NORMAL
- en: reader@ubuntu:~/scripts/chapter_12$ cat password-setter.sh
  prefs: []
  type: TYPE_NORMAL
- en: '#!/bin/bash'
  prefs: []
  type: TYPE_NORMAL
- en: '#####################################'
  prefs: []
  type: TYPE_NORMAL
- en: 'Author: Sebastiaan Tammer'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Version: v1.0.0'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Date: 2018-11-10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Description: Set a password using chpasswd.'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Usage: ./password-setter.sh'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '#####################################'
  prefs: []
  type: TYPE_NORMAL
- en: NEW_USER_NAME=bob
  prefs: []
  type: TYPE_NORMAL
- en: Verify this script is run with root privileges.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: if [[ $(id -u) -ne 0 ]]; then
  prefs: []
  type: TYPE_NORMAL
- en: echo "Please run as root or with sudo!"
  prefs: []
  type: TYPE_NORMAL
- en: exit 1
  prefs: []
  type: TYPE_NORMAL
- en: fi
  prefs: []
  type: TYPE_NORMAL
- en: We only need exit status, send all output to /dev/null.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: id ${NEW_USER_NAME} &> /dev/null
  prefs: []
  type: TYPE_NORMAL
- en: Check if we need to create the user.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: if [[ $? -ne 0 ]]; then
  prefs: []
  type: TYPE_NORMAL
- en: User does not exist, create the user.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: useradd -m ${NEW_USER_NAME}
  prefs: []
  type: TYPE_NORMAL
- en: fi
  prefs: []
  type: TYPE_NORMAL
- en: Set the password for the user.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: echo "${NEW_USER_NAME}:password" | chpasswd
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: sudo apt upgrade -y | tee /tmp/upgrade.log
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: sudo apt upgrade -y |& tee /tmp/upgrade.log
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: reader@ubuntu:~/scripts/chapter_12$ sudo apt upgrade -y |& tee /tmp/upgrade.log
  prefs: []
  type: TYPE_NORMAL
- en: 'WARNING: apt does not have a stable CLI interface. Use with caution in scripts.'
  prefs: []
  type: TYPE_NORMAL
- en: Reading package lists...
  prefs: []
  type: TYPE_NORMAL
- en: <SNIPPED>
  prefs: []
  type: TYPE_NORMAL
- en: 0 upgraded, 0 newly installed, 0 to remove and 0 not upgraded.
  prefs: []
  type: TYPE_NORMAL
- en: reader@ubuntu:~/scripts/chapter_12$ cat /tmp/upgrade.log
  prefs: []
  type: TYPE_NORMAL
- en: 'WARNING: apt does not have a stable CLI interface. Use with caution in scripts.'
  prefs: []
  type: TYPE_NORMAL
- en: Reading package lists...
  prefs: []
  type: TYPE_NORMAL
- en: <SNIPPED>
  prefs: []
  type: TYPE_NORMAL
- en: 0 upgraded, 0 newly installed, 0 to remove and 0 not upgraded.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: cat << EOF
  prefs: []
  type: TYPE_NORMAL
- en: input
  prefs: []
  type: TYPE_NORMAL
- en: more input
  prefs: []
  type: TYPE_NORMAL
- en: the last input
  prefs: []
  type: TYPE_NORMAL
- en: EOF
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: reader@ubuntu:~/scripts/chapter_12$ cat << EOF
  prefs: []
  type: TYPE_NORMAL
- en: input
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: more input
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: the last input
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: EOF
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: input
  prefs: []
  type: TYPE_NORMAL
- en: more input
  prefs: []
  type: TYPE_NORMAL
- en: the last input
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: reader@ubuntu:~/scripts/chapter_12$ cat << end-of-file
  prefs: []
  type: TYPE_NORMAL
- en: The delimiting identifier is end-of-file
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: But it only stops when end-of-file is the only thing on the line
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: end-of-file does not work, since it has text after it
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: end-of-file
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The delimiting identifier is end-of-file
  prefs: []
  type: TYPE_NORMAL
- en: But it only stops when end-of-file is the only thing on the line
  prefs: []
  type: TYPE_NORMAL
- en: end-of-file does not work, since it has text behind it
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: reader@ubuntu:~/scripts/chapter_12$ wall << EOF
  prefs: []
  type: TYPE_NORMAL
- en: Hi guys, we're rebooting soon, please save your work!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: It would be a shame if you lost valuable time...
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: EOF
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Broadcast message from reader@ubuntu (pts/0) (Sat Nov 10 16:21:15 2018):'
  prefs: []
  type: TYPE_NORMAL
- en: Hi guys, we're rebooting soon, please save your work!
  prefs: []
  type: TYPE_NORMAL
- en: It would be a shame if you lost valuable time...
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: reader@ubuntu:~/scripts/chapter_12$ cat << EOF
  prefs: []
  type: TYPE_NORMAL
- en: Hi, this is $USER!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: EOF
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Hi, this is reader!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: reader@ubuntu:~/scripts/chapter_12$ cat << 'EOF'
  prefs: []
  type: TYPE_NORMAL
- en: Hi, this is $USER!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: EOF
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Hi, this is $USER!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: reader@ubuntu:/tmp$ head /home/reader/scripts/chapter_11/while-interactive.sh
  prefs: []
  type: TYPE_NORMAL
- en: '#!/bin/bash'
  prefs: []
  type: TYPE_NORMAL
- en: '#####################################'
  prefs: []
  type: TYPE_NORMAL
- en: 'Author: Sebastiaan Tammer'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Version: v1.1.0'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Date: 2018-10-28'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Description: A simple riddle in a while loop.'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Usage: ./while-interactive.sh'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '#####################################'
  prefs: []
  type: TYPE_NORMAL
- en: reader@ubuntu:/tmp$ bash /home/reader/scripts/chapter_11/while-interactive.sh
    << EOF
  prefs: []
  type: TYPE_NORMAL
- en: 'a mouse  #Try 1.'
  prefs: []
  type: TYPE_NORMAL
- en: 'the sun  #Try 2.'
  prefs: []
  type: TYPE_NORMAL
- en: 'keyboard #Try 3.'
  prefs: []
  type: TYPE_NORMAL
- en: EOF
  prefs: []
  type: TYPE_NORMAL
- en: 'Incorrect, please try again. #Try 1.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Incorrect, please try again. #Try 2.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Correct, congratulations!    #Try 3.'
  prefs: []
  type: TYPE_NORMAL
- en: Now we can continue after the while loop is done, awesome!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: reader@ubuntu:/tmp$ echo "2^8" | bc
  prefs: []
  type: TYPE_NORMAL
- en: '256'
  prefs: []
  type: TYPE_NORMAL
- en: reader@ubuntu:/tmp$ echo "4*4" > math
  prefs: []
  type: TYPE_NORMAL
- en: reader@ubuntu:/tmp$ bc math
  prefs: []
  type: TYPE_NORMAL
- en: bc 1.07.1
  prefs: []
  type: TYPE_NORMAL
- en: Copyright 1991-1994, 1997, 1998, 2000, 2004, 2006, 2008, 2012-2017 Free Software
    Foundation, Inc.
  prefs: []
  type: TYPE_NORMAL
- en: This is free software with ABSOLUTELY NO WARRANTY.
  prefs: []
  type: TYPE_NORMAL
- en: For details type `warranty'.
  prefs: []
  type: TYPE_NORMAL
- en: '16'
  prefs: []
  type: TYPE_NORMAL
- en: ^C
  prefs: []
  type: TYPE_NORMAL
- en: (interrupt) use quit to exit.
  prefs: []
  type: TYPE_NORMAL
- en: quit
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: reader@ubuntu:/tmp$ bc <<< 2^8
  prefs: []
  type: TYPE_NORMAL
- en: '256'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: There we go. Just a simple here string as input (which is sent to `stdin` of
    the command), and we get the same functionality as an `echo` with a pipe. However,
    now it is just a single command, instead of a chain. Simple but effective, just
    the way we like it!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter explained almost everything there is to know about *redirection*
    on Linux. We began with a general description of what redirection is, and how
    *file descriptors* are used to facilitate redirections. We learned that file descriptors
    0, 1, and 2 are used for `stdin`, `stdout`, and `stderr`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: We then got acquainted with the syntax for redirections. This included `>`,
    `2>`, `&>`, and `<`, and their appending syntaxes, `>>`, `2>>`, `&>>`, and `<<`.
  prefs: []
  type: TYPE_NORMAL
- en: We discussed a few special Linux devices, `/dev/null`, `/dev/zero`, and `/dev/urandom`.
    We showed examples of how we could use these devices to remove output, generate
    null bytes, and generate random data. In the advanced redirecting section, we
    showed that we could bind `stdout` to `stderr` and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, we learned about *command substitution* and *process substitution*,
    which allows us to use the result of a command in an argument to another command,
    or as a file.
  prefs: []
  type: TYPE_NORMAL
- en: Next up were *pipes*. Pipes are simple, but very powerful, Bash constructs,
    which are used to connect the `stdout` (and possibly `stderr`) of one command
    to the `stdin` of another. This allows us to chain commands, manipulating the
    data streams further as we go, through as many commands as we want.
  prefs: []
  type: TYPE_NORMAL
- en: We also introduced `tee`, which allows us to send a stream to both our Terminal
    and a file, a construction often used for log files.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we explained *here documents* and *here strings*. These concepts allow
    us to send multiline and single-line input directly from the Terminal into the
    `stdin` of other commands, something that would otherwise require an `echo` or
    `cat`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following commands were introduced in this chapter: `diff`, `gcc`, `fallocate`,
    `tr`, `chpasswd`, `tee`, and `bc`.'
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are file descriptors?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What do the terms `stdin`, `stdout`, and `stderr` mean?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do `stdin`, `stdout`, and `stderr` map to the default file descriptors?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between the output redirections `>`, `1>`, and `2>`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between `>` and `>>`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can both `stdout` and `stderr` be redirected at the same time?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which special devices can be used to act as a black hole for output?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does a pipe do, with regards to redirections?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can we send output to both the Terminal and a log file?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a typical use case for a here string?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Read more about file descriptors at the following link**: [https://linuxmeerkat.wordpress.com/2011/12/02/file-descriptors-explained/](https://linuxmeerkat.wordpress.com/2011/12/02/file-descriptors-explained/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Find information about advanced scripts with file descriptors at the following
    link**: [https://bash.cyberciti.biz/guide/Reads_from_the_file_descriptor_(fd)](https://bash.cyberciti.biz/guide/Reads_from_the_file_descriptor_(fd)).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Read more about command substitution at the following link**: [http://www.tldp.org/LDP/abs/html/commandsub.html](http://www.tldp.org/LDP/abs/html/commandsub.html).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Find information about here documents at the following link**: [https://www.tldp.org/LDP/abs/html/here-docs.html](https://www.tldp.org/LDP/abs/html/here-docs.html).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
