- en: Chapter 4. Data Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Go is a strongly-typed language, which means any language element that stores
    (or expression that produces) a value has a type associated with it. In this chapter,
    readers will learn about the features of the type system as they explore the common
    data types supported by the language as outlined in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Go types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Numeric types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Boolean type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pointers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type declaration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type conversion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Go types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To help launch the conversation about types, let us take a peek at the types
    available. Go implements a simple type system that provides programmers direct
    control over how memory is allocated and laid out. When a program declares a variable,
    two things must take place:'
  prefs: []
  type: TYPE_NORMAL
- en: The variable must receive a type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The variable will also be bound to a value (even when none is assigned)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This allows the type system to allocate the number of bytes necessary to store
    the declared value. The memory layout for declared variables maps directly to
    their declared types. There is no type boxing or automatic type conversion that
    takes place. The space you expect to be allocated is actually what gets reserved
    in memory.
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate this fact, the following program uses a special package called
    `unsafe` to circumvent the type system and extract memory size information for
    declared variables. It is important to note that this is purely illustrative as
    most programs do not commonly make use of the `unsafe` package.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch04/alloc.go
  prefs: []
  type: TYPE_NORMAL
- en: 'When the program is executed, it prints out the amount of memory (in bits)
    consumed by each declared variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: From the preceding output, we can see that variable `a` (of type `uint8`) will
    be stored using eight bits (or one byte), variable `b` using 32 bits (or four
    bytes), and so on. With the ability to influence memory consumption coupled with
    Go's support for pointer types, programmers are able to strongly control how memory
    is allocated and consumed in their programs.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the types listed in the following table. They include
    basic types such as numeric, Boolean, and strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Type** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `string` | Type for storing text values |'
  prefs: []
  type: TYPE_TB
- en: '| `rune` | An integer type (int32) used to represent characters. |'
  prefs: []
  type: TYPE_TB
- en: '| `byte`, `int`, `int8`, `int16`, `int32`, `int64`, `rune`, `uint`, `uint8`,
    `uint16`, `uint32`, `uint64`, `uintptr` | Types for storing integral values. |'
  prefs: []
  type: TYPE_TB
- en: '| `float32`, `float64` | Types for storing floating point decimal values. |'
  prefs: []
  type: TYPE_TB
- en: '| `complex64`, `complex128` | Types that can represent complex numbers with
    both real and imaginary parts. |'
  prefs: []
  type: TYPE_TB
- en: '| `bool` | Type for Boolean values. |'
  prefs: []
  type: TYPE_TB
- en: '| `*T`, pointer to type T | A type that represents a memory address where a
    value of type T is stored. |'
  prefs: []
  type: TYPE_TB
- en: The remaining types supported by Go, such as those listed in the following table,
    include composite, interface, function, and channels. They are covered later in
    chapters dedicated to their respective topics.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Type** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| Array `[n]T` | An ordered collection of fixed size `n` of numerically indexed
    sequence of elements of a type `T`. |'
  prefs: []
  type: TYPE_TB
- en: '| Slice`[]T` | A collection of unspecified size of numerically indexed sequence
    of elements of type `T`. |'
  prefs: []
  type: TYPE_TB
- en: '| `struct{}` | A structure is a composite type composed of elements known as
    fields (think of an object). |'
  prefs: []
  type: TYPE_TB
- en: '| `map[K]T` | An unordered sequence of elements of type `T` indexed by a key
    of arbitrary type `K`. |'
  prefs: []
  type: TYPE_TB
- en: '| `interface{}` | A named set of function declarations that define a set of
    operations that can be implemented by other types. |'
  prefs: []
  type: TYPE_TB
- en: '| `func (T) R` | A type that represents all functions with a given parameter
    type `T` and return type `R`. |'
  prefs: []
  type: TYPE_TB
- en: '| `chan T` | A type for an internal communication channel to send or receive
    values of type `T`. |'
  prefs: []
  type: TYPE_TB
- en: Numeric types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Go's numeric types include support for integral and decimal values with a variety
    of sizes ranging from 8 to 64 bits. Each numeric type has its own layout in memory
    and is considered unique by the type system. As a way of enforcing this, and to
    avoid any sort of confusion when porting Go on different platforms, the name of
    a numeric type reflects its size requirement. For instance, type `*int16*` indicates
    an integer type that uses 16 bits for internal storage*.* This means that numberic
    values must be explicitly be converted when crossing type boundaries in assignments,
    expressions, and operations.
  prefs: []
  type: TYPE_NORMAL
- en: The following program is not all that functional, since all values are assigned
    to the blank identifier. However, it illustrates all of the numeric data types
    supported in Go.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch04/nums.go
  prefs: []
  type: TYPE_NORMAL
- en: Unsigned integer types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following table lists all available types that can represent unsigned integers
    and their storage requirements in Go:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Type** | **Size** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `uint8` | Unsigned 8-bit | Range 0 - 255 |'
  prefs: []
  type: TYPE_TB
- en: '| `uint16` | Unsigned 16-bit | Range 0 - 65535 |'
  prefs: []
  type: TYPE_TB
- en: '| `uint32` | Unsigned 32-bit | Range 0 - 4294967295 |'
  prefs: []
  type: TYPE_TB
- en: '| `uint64` | Unsigned 64-bit | Range 0 - 18446744073709551615 |'
  prefs: []
  type: TYPE_TB
- en: '| `uint` | Implementation specific | A pre-declared type designed to represent
    either the 32 or 64-bit integers. As of version 1.x of Go, `uint` represents a
    32-bit unsigned integer. |'
  prefs: []
  type: TYPE_TB
- en: '| `byte` | Unsigned 8-bit | Alias for the `unit8` type. |'
  prefs: []
  type: TYPE_TB
- en: '| `uintptr` | Unsigned | An unsigned integer type designed to store pointers
    (memory addresses) for the underlying machine architecture. |'
  prefs: []
  type: TYPE_TB
- en: Signed integer types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following table lists all available types that can represent signed integers
    and their storage requirements in Go:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Type** | **Size** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `int8` | Signed 8-bit | Range -128 - 127 |'
  prefs: []
  type: TYPE_TB
- en: '| `int16` | Signed 16-bit | Range -32768 - 32767 |'
  prefs: []
  type: TYPE_TB
- en: '| `int32` | Signed 32-bit | Range -2147483648 - 2147483647 |'
  prefs: []
  type: TYPE_TB
- en: '| `int64` | Signed 64-bit | Range -9223372036854775808 - 9223372036854775807
    |'
  prefs: []
  type: TYPE_TB
- en: '| `int` | Implementati specific | A pre-declared type designed to represent
    either the 32 or 64-bit integers. As of version 1.x of Go, `int` represents a
    32-bit signed integer. |'
  prefs: []
  type: TYPE_TB
- en: Floating point types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Go supports the following types for representation of decimal values using
    IEEE standards:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Type** | **Size** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `float32` | Signed 32-bit | IEEE-754 standard representation of single precision
    floating point values. |'
  prefs: []
  type: TYPE_TB
- en: '| `float64` | Signed 64-bit | IEEE-754 standard representation of double-precision
    floating point values. |'
  prefs: []
  type: TYPE_TB
- en: Complex number types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Go also supports representation of complex numbers with both imaginary and
    real parts as shown by the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Type** | **Size** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `complex64` | float32 | Represents complex numbers with real and imaginary
    parts stored as `float32` values. |'
  prefs: []
  type: TYPE_TB
- en: '| `complex128` | float64 | Represents complex numbers with real and imaginary
    parts stored as `float64` values. |'
  prefs: []
  type: TYPE_TB
- en: Numeric literals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Go supports the natural representation of integer values using a sequence of
    digits with a combination of a sign and decimal point (as seen in the previous
    example). Optionally, Go integer literals can also represent hexadecimal and octal
    numbers as illustrated in the following program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch04/intslit.go
  prefs: []
  type: TYPE_NORMAL
- en: 'Hexadecimal values are prepended with the `0x` or (`0X`) prefix while octal
    values start with the number 0 as shown in the previous example. Floating point
    values can be represented using both decimal and exponential notations as shown
    in the following examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch04/floats.go
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous program shows several representations of floating point literals
    in Go. Numbers can include an optional exponent portion indicated by `e` (or `E`)
    at the end of the number. For instance, `1.616199e-35` in the code represents
    numerical value 1.616199 x 10^(-35). Lastly, Go supports literals for expressing
    complex numbers as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch04/complex.go
  prefs: []
  type: TYPE_NORMAL
- en: In the previous example, variable `a` is assigned a complex number with both
    a real and an imaginary part. The imaginary literal is a floating point number
    followed by the letter `i`. Notice that Go also offers two built-in functions,
    `real()` and `imag(),` to deconstruct complex numbers into their real and imaginary
    parts respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Boolean type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Go, Boolean binary values are stored using the `bool` type. Although a variable
    of type `bool` is stored as a 1-byte value, it is not, however, an alias for a
    numeric value. Go provides two pre-declared literals, `true` and `false`, to represent
    Boolean values as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch04/bool.go
  prefs: []
  type: TYPE_NORMAL
- en: Rune and string types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to start our discussion about the `rune` and `string` types, some background
    context is in order. Go can treat character and string literal constants in its
    source code as Unicode. It is a global standard whose goal is to catalog symbols
    for known writing systems by assigning a numerical value (known as code point)
    to each character.
  prefs: []
  type: TYPE_NORMAL
- en: By default, Go inherently supports UTF-8 which is an efficient way of encoding
    and storing Unicode numerical values. That is all the background needed to continue
    with this subject. No further detail will be discussed as it is beyond the scope
    of this book.
  prefs: []
  type: TYPE_NORMAL
- en: The rune
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So, what exactly does the `rune` type have to do with Unicode? The rune is
    an alias for the *int32* type. It is specifically intended to store Unicode integer
    values encoded as UTF-8\. Let us take a look at some rune literals in the following
    program:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The rune](img/B03676_04_runes.go-snippet.jpg)'
  prefs: []
  type: TYPE_IMG
- en: golang.fyi/ch04/rune.go
  prefs: []
  type: TYPE_NORMAL
- en: 'Each variable in the previous program stores a Unicode character as a `rune`
    value. In Go, the `rune` may be specified as a string literal constant surrounded
    by single quotes. The literal may be one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A printable character (as shown with variables `char1`, `char2`, and `char3`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A single character escaped with backslash for non-printable control values as
    tab, linefeed, newline, and so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\u` followed by Unicode values directly (`\u0369`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\x` followed by two hex digits'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A backslash followed by three octal digits (`\045`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Regardless of the `rune` literal value within the single quotes, the compiler
    compiles and assigns an integer value as shown by the printout of the previous
    variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The string
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Go, a string is implemented as a slice of immutable byte values. Once a
    string value is assigned to a variable, the value of that string is never changed.
    Typically, string values are represented as constant literals enclosed within
    double quotes as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The string](img/B03676_04_strings.go-snippet.jpg)'
  prefs: []
  type: TYPE_IMG
- en: golang.fyi/ch04/string.go
  prefs: []
  type: TYPE_NORMAL
- en: The previous snippet shows variable `txt` being assigned a string literal containing
    seven characters including two embedded Chinese characters. As referenced earlier,
    the Go compiler will automatically interpret string literal values as Unicode
    characters and encode them using UTF-8\. This means that under the cover, each
    literal character is stored as a `rune` and may end up taking more than one byte
    for storage per visible character. In fact, when the program is executed, it prints
    the length of `txt` as `11`, instead of the expected seven characters for the
    string, accounting for the additional bytes used for the Chinese symbols.
  prefs: []
  type: TYPE_NORMAL
- en: Interpreted and raw string literals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following snippet (from the previous example) includes two string literals
    assigned to variable `txt2` and `txt3` respectively. As you can see, these two
    literals have the exact same content, however, the compiler will treat them differently:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: golang.fyi/ch04/string.go
  prefs: []
  type: TYPE_NORMAL
- en: 'The literal value assigned to variable `txt2` is enclosed in double quotes.
    This is known as an interpreted string. An interpreted string may contain normal
    printable characters as well as backslash-escaped values which are parsed and
    interpreted as `rune` literals. So, when `txt2` is printed, the escape values
    are translated as the following string:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Interpreted and raw string literals](img/B03676-04-bingslife-snippet.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Each symbol, in the interpreted string, corresponds to an escape value or a
    printable symbol as summarized in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| ![Interpreted and raw string literals](img/B03676-water-chinese.jpg) | **<space>**
    | **brings** | **<space>** | **life** | . |'
  prefs: []
  type: TYPE_TB
- en: '| \u6C34 | \x20 | brings | \x20 | \x6c\x69\x66\x65 | . |'
  prefs: []
  type: TYPE_TB
- en: On the other hand, the literal value assigned to variable `txt3` is surrounded
    by the grave accent characters [PRE9]
  prefs: []
  type: TYPE_NORMAL
- en: \u6C34\x20brings\x20\x6c\x69\x66\x65.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: package main
  prefs: []
  type: TYPE_NORMAL
- en: import "fmt"
  prefs: []
  type: TYPE_NORMAL
- en: var valPtr *float32
  prefs: []
  type: TYPE_NORMAL
- en: var countPtr *int
  prefs: []
  type: TYPE_NORMAL
- en: var person *struct {
  prefs: []
  type: TYPE_NORMAL
- en: name string
  prefs: []
  type: TYPE_NORMAL
- en: age  int
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: var matrix *[1024]int
  prefs: []
  type: TYPE_NORMAL
- en: var row []*int64
  prefs: []
  type: TYPE_NORMAL
- en: func main() {
  prefs: []
  type: TYPE_NORMAL
- en: fmt.Println(valPtr, countPtr, person, matrix, row)
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: package main
  prefs: []
  type: TYPE_NORMAL
- en: import "fmt"
  prefs: []
  type: TYPE_NORMAL
- en: func main() {
  prefs: []
  type: TYPE_NORMAL
- en: var a int = 1024
  prefs: []
  type: TYPE_NORMAL
- en: var aptr *int = &a
  prefs: []
  type: TYPE_NORMAL
- en: fmt.Printf("a=%v\n", a)
  prefs: []
  type: TYPE_NORMAL
- en: fmt.Printf("aptr=%v\n", aptr)
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: var a int = 1024
  prefs: []
  type: TYPE_NORMAL
- en: var aptr *int = &a
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: a=1024
  prefs: []
  type: TYPE_NORMAL
- en: aptr=0xc208000150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: var aptr *int = &1024
  prefs: []
  type: TYPE_NORMAL
- en: fmt.Printf("a ptr1 = %v\n", aptr)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: package main
  prefs: []
  type: TYPE_NORMAL
- en: import "fmt"
  prefs: []
  type: TYPE_NORMAL
- en: func main() {
  prefs: []
  type: TYPE_NORMAL
- en: structPtr := &struct{ x, y int }{44, 55}
  prefs: []
  type: TYPE_NORMAL
- en: pairPtr := &[2]string{"A", "B"}
  prefs: []
  type: TYPE_NORMAL
- en: fmt.Printf("struct=%#v, type=%T\n", structPtr, structPtr)
  prefs: []
  type: TYPE_NORMAL
- en: fmt.Printf("pairPtr=%#v, type=%T\n", pairPtr, pairPtr)
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: package main
  prefs: []
  type: TYPE_NORMAL
- en: import "fmt"
  prefs: []
  type: TYPE_NORMAL
- en: func main() {
  prefs: []
  type: TYPE_NORMAL
- en: intptr := new(int)
  prefs: []
  type: TYPE_NORMAL
- en: '*intptr = 44'
  prefs: []
  type: TYPE_NORMAL
- en: p := new(struct{ first, last string })
  prefs: []
  type: TYPE_NORMAL
- en: p.first = "Samuel"
  prefs: []
  type: TYPE_NORMAL
- en: p.last = "Pierre"
  prefs: []
  type: TYPE_NORMAL
- en: fmt.Printf("Value %d, type %T\n", *intptr, intptr)
  prefs: []
  type: TYPE_NORMAL
- en: fmt.Printf("Person %+v\n", p)
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: package main
  prefs: []
  type: TYPE_NORMAL
- en: import (
  prefs: []
  type: TYPE_NORMAL
- en: '"fmt"'
  prefs: []
  type: TYPE_NORMAL
- en: '"strings"'
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: func main() {
  prefs: []
  type: TYPE_NORMAL
- en: a := 3
  prefs: []
  type: TYPE_NORMAL
- en: double(&a)
  prefs: []
  type: TYPE_NORMAL
- en: fmt.Println(a)
  prefs: []
  type: TYPE_NORMAL
- en: p := &struct{ first, last string }{"Max", "Planck"}
  prefs: []
  type: TYPE_NORMAL
- en: cap(p)
  prefs: []
  type: TYPE_NORMAL
- en: fmt.Println(p)
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: func double(x *int) {
  prefs: []
  type: TYPE_NORMAL
- en: '*x = *x * 2'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: func cap(p *struct{ first, last string }) {
  prefs: []
  type: TYPE_NORMAL
- en: p.first = strings.ToUpper(p.first)
  prefs: []
  type: TYPE_NORMAL
- en: p.last = strings.ToUpper(p.last)
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '*x * 2'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '*(*x) * 2'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 3 * 2 = 6
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '*(*x) = 6'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: type truth bool
  prefs: []
  type: TYPE_NORMAL
- en: type quart float64
  prefs: []
  type: TYPE_NORMAL
- en: type gallon float64
  prefs: []
  type: TYPE_NORMAL
- en: type node string
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: package main
  prefs: []
  type: TYPE_NORMAL
- en: import "fmt"
  prefs: []
  type: TYPE_NORMAL
- en: type fahrenheit float64
  prefs: []
  type: TYPE_NORMAL
- en: type celsius float64
  prefs: []
  type: TYPE_NORMAL
- en: type kelvin float64
  prefs: []
  type: TYPE_NORMAL
- en: func fharToCel(f fahrenheit) celsius {
  prefs: []
  type: TYPE_NORMAL
- en: return celsius((f - 32) * 5 / 9)
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: func fharToKel(f fahrenheit) celsius {
  prefs: []
  type: TYPE_NORMAL
- en: return celsius((f-32)*5/9 + 273.15)
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: func celToFahr(c celsius) fahrenheit {
  prefs: []
  type: TYPE_NORMAL
- en: return fahrenheit(c*5/9 + 32)
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: func celToKel(c celsius) kelvin {
  prefs: []
  type: TYPE_NORMAL
- en: return kelvin(c + 273.15)
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: func main() {
  prefs: []
  type: TYPE_NORMAL
- en: var c celsius = 32.0
  prefs: []
  type: TYPE_NORMAL
- en: f := fahrenheit(122)
  prefs: []
  type: TYPE_NORMAL
- en: fmt.Printf("%.2f \u00b0C = %.2f \u00b0K\n", c, celToKel(c))
  prefs: []
  type: TYPE_NORMAL
- en: fmt.Printf("%.2f \u00b0F = %.2f \u00b0C\n", f, fharToCel(f))
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: package main
  prefs: []
  type: TYPE_NORMAL
- en: import "fmt"
  prefs: []
  type: TYPE_NORMAL
- en: type signal int
  prefs: []
  type: TYPE_NORMAL
- en: func main() {
  prefs: []
  type: TYPE_NORMAL
- en: var count int32
  prefs: []
  type: TYPE_NORMAL
- en: var actual int
  prefs: []
  type: TYPE_NORMAL
- en: var test int64 = actual + count
  prefs: []
  type: TYPE_NORMAL
- en: var sig signal
  prefs: []
  type: TYPE_NORMAL
- en: var event int = sig
  prefs: []
  type: TYPE_NORMAL
- en: fmt.Println(test)
  prefs: []
  type: TYPE_NORMAL
- en: fmt.Println(event)
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: type signal int
  prefs: []
  type: TYPE_NORMAL
- en: func main() {
  prefs: []
  type: TYPE_NORMAL
- en: var count int32
  prefs: []
  type: TYPE_NORMAL
- en: var actual int
  prefs: []
  type: TYPE_NORMAL
- en: var test int32 = int32(actual) + count
  prefs: []
  type: TYPE_NORMAL
- en: var sig signal
  prefs: []
  type: TYPE_NORMAL
- en: var event int = int(sig)
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: var i int
  prefs: []
  type: TYPE_NORMAL
- en: var i2 int32 = int32(i)
  prefs: []
  type: TYPE_NORMAL
- en: var re float64 = float64(i +   int(i2))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: var cn64 complex64
  prefs: []
  type: TYPE_NORMAL
- en: var cn128 complex128 =   complex128(cn64)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: type signal int
  prefs: []
  type: TYPE_NORMAL
- en: var sig signal
  prefs: []
  type: TYPE_NORMAL
- en: var event int = int(sig)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: a := string(72)
  prefs: []
  type: TYPE_NORMAL
- en: b := string(int32(101))
  prefs: []
  type: TYPE_NORMAL
- en: c := string(rune(108))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: msg0 := string([]byte{'H','i'})
  prefs: []
  type: TYPE_NORMAL
- en: msg1 := string([]rune{'Y','o','u','!'})
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: data0 := []byte("Hello")
  prefs: []
  type: TYPE_NORMAL
- en: data0 := []int32("World!")
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, the conversion rules also work when the target type and converted
    value are pointers that reference the same types. Besides these scenarios in the
    previous table, Go types cannot be explicitly converted. Any attempt to do so
    will result in a compilation error.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter presented its readers with an introduction the Go type system.
    The chapter opened with an overview of types and dove into a comprehensive exploration
    of the basic built-in types such as numeric, Boolean, string, and pointer types.
    The discussion continued by exposing the reader to other important topics such
    as named type definition. The chapter closed with coverage of the mechanics of
    type conversion. In coming chapters, you will get a chance to learn more about
    other types such as composite, function, and interface.
  prefs: []
  type: TYPE_NORMAL
