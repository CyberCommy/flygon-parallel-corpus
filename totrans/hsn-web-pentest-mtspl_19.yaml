- en: Web Application Fuzzing - Logical Bug Hunting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, we have learned about Metasploit basics, the Metasploit
    modules that can be used in web application penetration testing, performing reconnaissance
    and enumeration using Metasploit modules, different modules supported by Metasploit
    for different technologies and different **Content Management Systems** (**CMSes**),
    and the different exploitation techniques used. In this chapter, we'll be learning
    about another important aspect of web application penetration testing – web application
    fuzzing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Web application fuzzing is not exactly a mandatory phase in a generic penetration
    test case. However, it is a crucial step in finding logical vulnerabilities. Based
    on how a web application server responds to certain requests, the fuzzer can be
    used to understand the behavior of the server to find flaws that are unseen by
    the tester''s eyes. Metasploit comes with three web fuzzer modules that can be
    used to test memory overflows in forms and other fields in a web application.
    In this chapter, we will be learning about fuzzing by covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What is fuzzing?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fuzzing terminology
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fuzzing attack types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to web app fuzzing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identifying web application attack vectors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scenarios
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are the technical requirements for this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Wfuzz: [https://github.com/xmendez/wfuzz](https://github.com/xmendez/wfuzz)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ffuf: [https://github.com/ffuf/ffuf](https://github.com/ffuf/ffuf)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Burp Suite: [https://portswigger.net/burp](https://portswigger.net/burp)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is fuzzing?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Fuzzing, also known as fuzz testing, is a type of black box software testing
    that is used to find implementation bugs by using malformed/semi-malformed data
    in an automated way. Fuzz testing was developed by Professor Barton Miller and
    his students at the University of Wisconsin-Madison in 1989 (their ongoing work
    can be found at [http://www.cs.wisc.edu/~bart/fuzz/](http://www.cs.wisc.edu/~bart/fuzz/)).
    When performing fuzz testing, the application/software response is observed, and,
    based on changes in its behavior (crashing or hanging), implementation bugs are
    discovered. In a nutshell, the fuzzing process is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8753a263-90ef-485f-b20f-913481827b94.png)'
  prefs: []
  type: TYPE_IMG
- en: We need to identify the targets and the input vectors (in the case of system
    applications) and the endpoints (in the case of web applications) that need to
    be fuzzed. After a proper input seed is generated (random fuzz data), the malformed/semi-malformed
    fuzz data will be given as input to the fuzzer for testing.
  prefs: []
  type: TYPE_NORMAL
- en: Meanwhile, we need to understand the application's behavior throughout fuzz
    testing by monitoring and analyzing the server/application responses (web server
    responses in the case of web application fuzzing, and application diagnostic information/trace
    information in the case of system application fuzzing, which includes FTP servers,
    SSH servers, and SMTP servers). To better understand fuzz testing, let's first
    learn some common terminology used in fuzzing.
  prefs: []
  type: TYPE_NORMAL
- en: Fuzzing terminology
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To have a better understanding of fuzzing and fuzzing techniques, let''s have
    a look at different fuzzing terminology that will help us to grasp the fuzzing
    concepts and techniques that are used in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Fuzzer:** A fuzzer is a program/tool that injects malformed/semi-malformed
    data into the server/web application and observes the behavior of the application
    to detect bugs. The malformed/semi-malformed data used by the fuzzer is generated
    using a generator.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Generator:** A generator uses a combination of fuzzing vectors and some random
    data. The generated data is then fed to the fuzzer, which injects this malformed
    data into the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fuzz vectors:** A fuzz vector is a known-to-be-dangerous value that is used
    by the fuzzer. By observing the behavior of the application, the fuzzer can inject
    different fuzz vectors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Input seeds:** These are valid input samples that are used by the fuzzer
    for testing. An input seed can be any test file that contains the data format
    to be used by the fuzzer. The generator will then generate the data based on the
    input seed that will be used by the fuzzer. If the input seed is chosen carefully,
    we can find a great number of bugs in an application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Instrumentation:** This is a technique used by the to measure the application''s
    performance and diagnostic information, including any errors. During fuzzing,
    the instrumentation technique will temporarily take control of the application/software
    that is being fuzzed at runtime, just like an interceptor, to look for errors
    from the trace information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have learned some new terminology, let's have a look at the attack
    types with which we can perform fuzz testing.
  prefs: []
  type: TYPE_NORMAL
- en: Fuzzing attack types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The fuzzer will generally try a combination of attacks using numbers (signed/unsigned
    integers or floats), chars (URLs or command-line inputs), user-input text, pure
    binary sequences, and so on. A list of fuzz vectors can be generated from these
    types. For example, for integers, the fuzz vectors could be zero, a negative value,
    or a very big integer value; for chars, the fuzz vectors could be escaped characters,
    Unicode characters, URL-encoded characters, special characters, or a sequence
    of all of the characters. Once the list of fuzz vectors is generated, the fuzzer
    will use the list to perform fuzzing on the application.
  prefs: []
  type: TYPE_NORMAL
- en: Application fuzzing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For a desktop-based application, a fuzzer can perform fuzzing on its interface
    (a combination of button sequences, text inputs, and so on), command-line options
    (if applicable), and import/export capabilities provided by the application.
  prefs: []
  type: TYPE_NORMAL
- en: For web-based applications, a fuzzer can perform fuzzing on its URLs, user input
    forms, HTTP request headers, HTTP POST data, HTTP protocols, and HTTP methods.
  prefs: []
  type: TYPE_NORMAL
- en: Protocol fuzzing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A protocol fuzzer will forge network packets and send them to the server. If
    there's a bug in the protocol stack, it will be revealed using protocol fuzzing.
  prefs: []
  type: TYPE_NORMAL
- en: File-format fuzzing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: File-format fuzzing is generally used in those cases where a program is importing/exporting
    data streams in and out of files. To perform file-format fuzzing, you have to
    generate multiple input seeds with different file formats and save them in a single
    file. The fuzzer will then use the saved file as an input to the server/application,
    recording any kind of crash that may occur. We will now move on to the next section,
    which will introduce us to web app fuzzing.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to web app fuzzing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have a clear understanding of the fuzzing concept, the terminology,
    and the attack types, let''s start with web application-based fuzzing. As mentioned
    before, web application-based fuzzing is done by using URLs, forms, headers, and
    methods as the primary fuzz vectors. In this chapter, we will be using the following
    tools for fuzzing an HTTP-based web application: **Wfuzz**, **Ffuf**, and **Burp
    Suite**. Before moving forward, let''s install the tools outlined in this section
    to hunt logical bugs.'
  prefs: []
  type: TYPE_NORMAL
- en: Fuzzer installation (Wfuzz)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Wfuzz is a Python-based web application fuzzer that uses the replacive technique
    to replace the **FUZZ** keyword in the command with the fuzz vectors given to
    the fuzzer. This fuzzer can perform complex web security attacks in different
    web application components, such as parameters, authentication, forms, directories/files,
    and headers. Wfuzz is also equipped with a variety of modules, including iterators,
    encoders, payloads, printers, and scripts. Depending upon the web application,
    we can use these modules to perform successful fuzz testing:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can install the **Wfuzz** tool by cloning the GitHub repository, as we can
    see in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00825c4a-b2d7-4054-a19a-4f8b6994cc3a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Before running the tool, we need to install it by executing the `python setup.py
    install` command. This will install all the files on the system, as we can see
    in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/1492d0b0-63ec-4ada-9280-e72ec91f8832.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To confirm whether the tool has been successfully installed or not, let''s
    execute the `wfuzz -h` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/581aa7f1-8303-4042-8dde-df6df3c07d25.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's now install the second tool that we'll use in this chapter, **Fuzz Faster
    U Fool** (**ffuf**).
  prefs: []
  type: TYPE_NORMAL
- en: Fuzzer installation (ffuf)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Fuzz Faster U Fool** (**ffuf**) is a web application fuzzer written in Go
    that has the functionality of Gobuster as well as **Wfuzz**. We can either clone
    the GitHub repository from [https://github.com/ffuf/ffuf](https://github.com/ffuf/ffuf)
    or we can download the pre-compiled version from [https://github.com/ffuf/ffuf/releases](https://github.com/ffuf/ffuf/releases).
    Let''s install it by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can either clone the repository using the `git clone https://github.com/ffuf/ffuf`
    command or using `go get https://github.com/ffuf/ffuf`. Let''s clone the repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/af630c71-8b5e-4211-9f37-0e92a8464fac.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s install it by executing the `go build .` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e46d7e4e-5684-4d71-b910-443fe397ccab.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Upon a successful build, we can see that a compiled program, `ffuf`, is created
    in the same directory. We can run the program as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/cb00e1fb-fdd3-4205-9b0c-eb81fa9cbca2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Our third and final tool for this chapter will be the infamous Burp Suite Intruder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/df47d7d4-86be-4bda-9cb6-4a5dcc14185f.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that we have installed all the tools required for us to perform fuzzing,
    let's try to understand the fuzzing inputs and vectors that we'll be using while
    performing fuzzing on web applications.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying web application attack vectors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Attack vectors are the regions/sections of a web application where the fuzzer
    can inject malformed/semi-malformed data. For a web application, the following
    are the sections where we can perform fuzzing:'
  prefs: []
  type: TYPE_NORMAL
- en: HTTP request verbs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTTP request URIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTTP request headers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTTP `POST` data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Older versions of the HTTP protocol
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's try to understand each section and all the fuzz vectors we can use for
    web application fuzzing.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP request verbs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Request verbs are also known as request methods, which are used by a web application
    client to indicate the desired action to be performed for a given resource on
    the server. Each of the methods used depends upon the resources required by the
    client from the server. Some of the most common HTTP verbs are `GET`, `POST`,
    `OPTIONS`, `HEAD`, `PUT`, `DELETE`, `TRACE`, `PATCH`, and `CONNECT`.
  prefs: []
  type: TYPE_NORMAL
- en: Fuzzing HTTP request methods can help us to identify the changes in a web application's
    responses based on different methods being supplied by the fuzzer. We can also
    identify the methods allowed by the web application server, which can be used
    to check a few attack test cases.
  prefs: []
  type: TYPE_NORMAL
- en: Fuzzing HTTP methods/verbs using Wfuzz
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Fuzzing HTTP methods is quite easy and, at the same time, quite helpful. Let''s
    try to fuzz the HTTP verbs on a simple web application using **Wfuzz**. Fuzzing
    HTTP request methods can be done by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the following command in the Terminal to get started with **Wfuzz**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the output of the preceding command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/1c9e8a86-a359-4122-a1e2-d74a3e45217d.png)'
  prefs: []
  type: TYPE_IMG
- en: The `-z` option is used to input the payload. In this case, we used a list (`-z`
    <list name>) of common HTTP request methods (`GET`, `POST`, `HEAD`, `OPTIONS`,
    `TRACE`, and `PUT`).
  prefs: []
  type: TYPE_NORMAL
- en: The `-X` option is used to provide the HTTP request method to be used by the
    fuzzer. If the `-X` option is not provided, the fuzzer will use the HTTP `GET`
    request method for fuzzing by default.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's see how we can fuzz HTTP verbs using **ffuf**.
  prefs: []
  type: TYPE_NORMAL
- en: Fuzzing HTTP methods/verbs using ffuf
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can also fuzz request headers using **ffuf.**
  prefs: []
  type: TYPE_NORMAL
- en: 'We can execute the following command to fuzz the request headers using a wordlist:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the output of the preceding command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6f847355-66fa-4600-8ecd-1ecb67235780.png)'
  prefs: []
  type: TYPE_IMG
- en: As we can see in the preceding screenshot, the fuzzer found a few HTTP methods
    that are acceptable to the web application server. Let's try to fuzz the same
    case using Burp Suite.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note: The `-c` option in **ffuf** is given to add color to the HTTP response
    code. It helps us to identify hidden files and directories faster.'
  prefs: []
  type: TYPE_NORMAL
- en: Fuzzing HTTP methods/verbs using Burp Suite Intruder
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'HTTP verbs can also be fuzzed using Burp Suite Intruder by clicking the Intruder
    tab and opening the Positions sub-tab. Burp Suite will automatically mark any
    value matching the `[parameter]=[value]` format with the **§** payload marker.
    Anything within the payload marker will be considered a fuzz vector by Burp Suite.
    Burp Suite Intruder supports four attack types: Sniper, Battering Ram, Pitchfork,
    and Cluster Bomb. To learn more about the attack types, please refer to [https://portswigger.net/burp/documentation/desktop/tools/intruder/positions.](https://portswigger.net/burp/documentation/desktop/tools/intruder/positions)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s clear the fuzz vector position by clicking the Clear § button, as we
    can see in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f53cdd70-96a5-4e7b-8124-dd97ed63447f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To fuzz the HTTP request methods, let''s add the payload marker (**§**) by
    clicking the Add § button, as we can see in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0a140795-64f2-454d-8db1-4597c0f1b93a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that the payload marker is set, we need to define the payloads that should
    be used by Intruder for fuzzing. This can be done by clicking on the Payloads
    tab (as we can see in the following screenshot). In this case, we''ll be using
    a wordlist that contains some of the common HTTP request methods. The wordlist
    can be used by first setting the Payload type to `Simple list` and then loading
    the list by clicking the Load … button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e8a6247d-7d36-4cea-b666-ba4b9ab5a1c8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once the wordlist is loaded, we can click on the Start attack button to begin
    the fuzzing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9749d679-1c7b-44d7-a7ff-23f3e70a5f25.png)'
  prefs: []
  type: TYPE_IMG
- en: 'A new window will open with the fuzzing results, as we can see in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c26bd352-5b18-44af-87a4-a37065e6462e.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding screenshot, we can observe that the server responds with HTTP
    `400` (**Bad Request**) and HTTP `405` (**Method Not Allowed**) codes when HTTP
    CONNECT and TRACE methods are used, respectively. This shows us the behavior of
    the web application server regarding these two request headers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note: We can use other custom lists freely available online for fuzzing HTTP
    methods as well.'
  prefs: []
  type: TYPE_NORMAL
- en: HTTP request URIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To begin HTTP request URI fuzzing, we first need to understand the URI structure.
    A URI has the following universally acceptable structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Fuzzing an HTTP request URl path using Wfuzz
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To fuzz the URI path with the help of Wfuzz, let''s execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the output of the preceding command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e43be872-33ab-4b77-8005-195e6fbe5352.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Using the `--hc` switch, we can filter out the results based on the HTTP codes.
    In this case, we have filtered the HTTP `404` (**Not Found**) code, as we can
    see in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0b541a0f-1df0-4d38-9f37-5eacbdfe27d4.png)'
  prefs: []
  type: TYPE_IMG
- en: We can do the same thing using **ffuf**.
  prefs: []
  type: TYPE_NORMAL
- en: Fuzzing an HTTP request URl path using ffuf
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To fuzz the URI path, let''s execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the output of the preceding command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0db80f3c-d17b-4db1-b8e7-75e5da2ecd4f.png)'
  prefs: []
  type: TYPE_IMG
- en: In both of the preceding cases, the `FUZZ` keyword is replaced with the wordlist
    entries that are used for fuzzing the directory names. As we can see in the preceding
    screenshot, the server responded with HTTP `301` when the fuzzer requested css,
    img, js, and setup. Observing the size of the response and the words, we can conclude
    that the fuzzer was able to find directories in the web application server.
  prefs: []
  type: TYPE_NORMAL
- en: Fuzzing an HTTP request URl path using Burp Suite Intruder
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have used **Wfuzz** and **ffuf** to fuzz the URI path, let''s try
    the same in Burp Suite Intruder. The concept here is the same. Let''s place a
    payload marker (as shown in the following screenshot) for the fuzzer to send data to
    the vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6babe9a4-8114-4323-b048-3265b0b2d1de.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s set Payload type to `Simple list` and import a wordlist using the Load
    … button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/df043969-85ec-4ed1-b308-41b6e6983672.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on the Start attack button (as shown in the preceding screenshot) and
    Intruder will try to fuzz the URI path with the custom wordlist given to it. The
    result for the fuzzer will be displayed in another window with the HTTP response
    codes and the Length, which we can see in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8bd12f1d-54ea-41fc-958f-b504201833d3.png)'
  prefs: []
  type: TYPE_IMG
- en: As we can see in the preceding screenshot, we were able to fuzz the URI path
    (directories) of the web application server. Now, let's see how we can fuzz URI
    filenames and file extensions using the same tools.
  prefs: []
  type: TYPE_NORMAL
- en: Fuzzing HTTP request URl filenames and file extensions using Wfuzz
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Wfuzz can also fuzz the filenames and file extensions of the web application
    server:'
  prefs: []
  type: TYPE_NORMAL
- en: '`wfuzz -c --hc=404 -z file,SecLists/Discovery/Web-Content/raft-small-files-lowercase.txt
    http://192.168.2.19:8090/xvwa/FUZZ.php` (filename fuzzing)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`wfuzz -c --hc=404 -z list,php-asp-aspx-jsp-txt http://192.168.2.19:8090/xvwa/home.FUZZ`
    (file extension fuzzing)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fuzzing HTTP request URl filenames and file extensions using ffuf
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To fuzz the HTTP request URI filenames and file extensions, the following commands
    can be used for the ffuf fuzzer:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ffuf -c -w <wordlist> -u http://192.168.2.19:8090/xvwa/FUZZ.php` (filename
    fuzzing)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ffuf -c -w <wordlist> -u http://192.168.2.19:8090/xvwa/home.FUZZ` (file extension
    fuzzing)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fuzzing HTTP request URl filenames and file extensions using Burp Suite Intruder
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The payload marker is placed before the file extension to fuzz filenames (as
    we can see in the following screenshot):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cb4d3bdb-ef88-4da7-b5b9-d86b0a8efc4f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The payload marker is placed after the filename to fuzz file extensions (as
    we can see in the following screenshot):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b8eb76a9-67ad-4b49-a23e-fec14ac3b464.png)'
  prefs: []
  type: TYPE_IMG
- en: The cool thing about Wfuzz and Burp Suite Intruder is the ability to fuzz multiple
    payload locations using multiple fuzz vectors.
  prefs: []
  type: TYPE_NORMAL
- en: Fuzzing an HTTP request URl using Wfuzz (GET parameter + value)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Wfuzz has the built-in functionality to fuzz multiple payload locations by
    adding the **FUZZ**, **FUZ2Z**, **FUZ3Z**... keywords. Let''s say we want to fuzz
    the `GET` parameter name and the value of the web application server. As we cannot
    use the same wordlist in both fuzz vectors, we will use the **FUZZ** and **FUZ2Z**
    keywords to perform fuzzing. Let''s execute the following command in Wfuzz:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As we can see in the preceding command, we have fed **Wfuzz** two wordlists, `parameter_wordlist`
    and `value_wordlist`, using the `-z` option (yes, we can use the `-z`, `-H`, and
    `-b` options repeatedly) and the `[parameter]=[value]` is shown in `/?FUZZ=FUZ2Z`
    format. Upon executing this command, the fuzzer will use the first entry in `parameter_wordlist`,
    replace it with the `FUZZ` keyword, and then loop through all the `value_wordlist`
    entries via `FUZ2Z`. And like this, the fuzzer will fuzz through both wordlists.
    Let's now see how we can achieve the same thing using Intruder.
  prefs: []
  type: TYPE_NORMAL
- en: Fuzzing an HTTP request URl using Burp Suite Intruder (GET parameter + value)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Burp Suite, the different attack types help us with this kind of test case.
    To fuzz through two wordlists simultaneously, we''ll be using the cluster bomb
    attack type in Intruder:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin with, let''s set the Attack type to Cluster bomb and set the payload
    marker as /?§§=§§ (as shown in the following screenshot):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/438502f0-3dda-4096-81b9-b473985b4974.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As we''ll be using two payload sets in this case, let''s set our first Payload
    set (parameter name) and change the Payload type to Simple list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/1ddec7f4-1858-44c1-8b17-b64ad292725b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that our first payload set is configured, let''s configure our second payload
    set (parameter value). After setting Payload set to `2`, let''s change Payload
    type to `Numbers`. As the parameter value is in the integer format (in this case),
    let''s set the range from `1` to `5` and set Step to `1`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/739393b1-0221-4070-bc95-af0d19774bbf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Our Intruder is now configured for fuzzing through multiple payload sets. Let''s
    begin the fuzz testing by clicking on the Start attack button (as we can see in
    the preceding screenshot). We will then see the following screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c7d02540-96f8-4fe4-b29a-3b334581b6ed.png)'
  prefs: []
  type: TYPE_IMG
- en: Success!
  prefs: []
  type: TYPE_NORMAL
- en: As we can see from the preceding screenshot, Intruder was able to find an item parameter
    name with some parameter values. How can we differentiate between the found parameter
    name and values from other entries in the wordlist? By observing the response
    length.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try to fuzz three fuzz vectors using **Wfuzz** (directories, files,
    and file extensions). This would definitely take a lot of time as it combines
    different payload sets simultaneously. To fuzz the directories, filenames, and
    file extensions, we can execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the output of the preceding command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/55074e56-707a-49f3-9699-47f0bfffd6ab.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The result can be filtered based on the number of characters (`--hh`), words
    (`--hw`), or lines (`--hl`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/984a6a22-925e-48ae-9f28-1ae8590564a3.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that we have some idea of how to fuzz HTTP request URIs, let's understand
    how we can fuzz HTTP headers.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP request headers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Fuzzing request headers is conceptually the same as fuzzing URIs. The only difference
    is that the number of vulnerabilities found by fuzzing the request headers will
    be higher than when fuzzing URIs because these headers are sent to the web application
    server and the server processes these headers internally. This means we have a
    larger scope for finding vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are different types of HTTP headers at play:'
  prefs: []
  type: TYPE_NORMAL
- en: Standard HTTP headers (`Cookie`, `User-Agent`, `Accept`, `Host`, and so on)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Non-standard HTTP headers (`X-Forwarded-For`, `X-Requested-With`, `DNT`, and
    so on)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom headers (any other header beginning with `X-` except the non-standard
    headers)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's try to understand how can we fuzz each type of header using the same fuzzers
    as in the rest of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Fuzzing standard HTTP headers using Wfuzz, ffuf, and Burp Suite
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Standard HTTP headers are commonly used by web servers to process client requests.
    While performing a web application penetration test, it's recommended to understand
    the workings of the web application and how the web application server processes
    request headers (standard and non-standard). Having a better understanding of
    the web application can help us define some pretty decent fuzz vectors that would
    greatly increase the probability of finding logical flaws in the web application.
    In this topic, we'll be going through some custom test cases to understand how
    to fuzz a web application.
  prefs: []
  type: TYPE_NORMAL
- en: Scenario 1 – Cookie header fuzzing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following scenario. We have a PHP file, `- cookie_test.php`.
    We request this file with the `Cookie` flag as `lang=en_us.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f907ce35-6c74-40d8-974d-31c5852ff288.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The server responds with the message Language in use: *English*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4325003b-aaaa-4a0d-9d78-8e8297ce34c8.png)'
  prefs: []
  type: TYPE_IMG
- en: From the `en_us.php` file, we may think that the `cookie` parameter is including
    the file from the server (file inclusion) and executing the file, which, in turn,
    is printing the message from the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now see how we can fuzz the `cookie` header using **Wfuzz**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a43071e4-195f-4331-bd11-9c1795df1329.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As we can see in the preceding screenshot, the `-b` option is used to provide
    the `cookie` value, and we used `lang=FUZZ`. Using fuzz vectors based on web application
    attacks, we were able to find the payloads, using which the server responds with
    a different response length. Here, we used one of the payloads found by the fuzzer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1dd33b80-ed49-433d-aa23-1b25d9468162.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We were able to confirm the existence of a file inclusion vulnerability:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/79d44d89-396a-4c6b-815d-3891d9b87eb7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The same can be done using **ffuf** by executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'For Burp Suite, we just need to add the payload marker to the `Cookie` header:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9e5382b2-b171-43c6-ad2f-a07ee8040a83.png)'
  prefs: []
  type: TYPE_IMG
- en: Similarly, we can fuzz a user-defined `Cookie` header using the same tools.
    Let's have a look into this.
  prefs: []
  type: TYPE_NORMAL
- en: Scenario 2 – User-defined cookie header fuzzing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This scenario is different to the previous one. In this scenario, we''ll request
    the `cookie_test.php` file from the server with the `lang=en_us` cookie value
    attached to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3a3c04d4-653c-44ab-9315-ea001db10402.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The server responds with Unauthorized Access!, as we can see in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/85a9f71c-fedd-418d-b148-cd4b521dc0ad.png)'
  prefs: []
  type: TYPE_IMG
- en: 'With just the normal request, the server echoes the defined cookie back to
    us:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/59da639e-6499-4421-8134-404060b7b223.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s say our goal is to access the `home.php` file but it''s restricted right
    now, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/de682f84-8bbc-46f9-9fab-5ca80d9f92ae.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As there is no login authentication page where we can authenticate to the server,
    we have to assume that the authentication is being done either on the `User-Agent`
    part or on the `Cookie` part. Let''s assume that the authentication is being done
    by checking the cookie values. A user-defined cookie value can be used by the
    client to connect to the server and successfully authenticate. To fuzz a blind
    user-defined cookie value, let''s execute the following command using wfuzz:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the output of the preceding command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c1a68f1e-ec7a-4c7c-b1bd-c1ffe7849747.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Wow! As we can see in the preceding screenshot, the server responded with a
    different page when a user-defined cookie with the value `Cookie: admin=admin;`
    was inserted. Let''s use the same user-defined cookie parameter name and value
    to request the same page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3f9648d5-8084-47b5-9a56-4113c07cb214.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As we can see in the following screenshot, the server is redirecting us to
    the `home.php` page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f4c616a2-02f6-41cd-ac4a-6443cdcd1531.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Fuzzing the user-defined cookie parameter name and value, we were able to authenticate
    using the `cookie_test.php` page to access the `home.php` page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2c01f185-880d-4931-b857-8387489d6b28.png)'
  prefs: []
  type: TYPE_IMG
- en: The same method could be used to find a variety of vulnerabilities, such as
    SQL injections, XSS, and RCE.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note: It all depends on the web application and how the web application processes
    the `Cookie` header. If the `Сookie` header is just used to provide a temporary
    session by the server to the client, there''s not much we can do other than test
    session-based vulnerabilities.'
  prefs: []
  type: TYPE_NORMAL
- en: Other standard headers can also be fuzzed, including `User-Agent`, `Host`, `Accept`,
    and `Content-Type`. In the case of fuzzing non-standard HTTP headers, we can use
    a wordlist to check the server response for each and every header requested by
    the fuzzer. Sometimes, by using these non-standard headers, such as X-Forwarded-For
    and others, we can bypass the IP-based access restriction placed on the application
    by the server.
  prefs: []
  type: TYPE_NORMAL
- en: Fuzzing a custom header using Wfuzz, ffuf, and Burp Suite
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a number of web applications, the developer introduces some custom HTTP headers
    that are then parsed when a request is processed. From generating a user-specific
    token to allowing access control through such custom headers, these headers have
    a different level of functionality altogether. In such scenarios, sometimes, the
    developer forgets to sanitize the user input, which, in turn, could become a target
    for exploitation. Let's see how we can fuzz custom headers using Wfuzz, ffuf,
    and Burp Suite.
  prefs: []
  type: TYPE_NORMAL
- en: Scenario 3 – Custom header fuzzing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this scenario, we have an application running on PHP – `custom_header.php`.
    We request the following page from the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0045ba2f-03b2-4731-aea7-517f538ed962.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The server responds with an Unauthorized Access! message and two unknown headers
    – `X-isAdmin: false` and `X-User: Joe` (as we can see in the following screenshot):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7e7db2c9-1969-459a-ac0a-942f9daee7d1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The message from the server is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/35912b35-cb43-45a7-aa6c-48e8c18811d4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'By observing these two custom headers, we can assume that the server is processing
    these headers as well. The first header, that is, `X-isAdmin`, looks like a custom
    header accepting Boolean values: `true` or `false`. The other header, `X-User`,
    maybe accepts the user''s first name, so the value is in a string format. Let''s
    use **Wfuzz** to fuzz through these headers and find out what can we do about
    it. Let''s execute the following command in **Wfuzz**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the output of the preceding command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/20e2586b-6999-4ada-99a0-690b403b5702.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can use the `-H` flag at multiple locations in the HTTP request. Now that
    we''re getting the same responses from the server, let''s filter out the results
    based on character length (the `--hh` flag):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/681defe9-2e9e-455d-938d-346f0e7fbb76.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Incredible! We found the value for `X-isAdmin: true` and `X-User: Billy`. This
    means that Billy is the admin here. Using this custom header in the HTTP request,
    let''s see whether we can access the page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7ffc3c57-317f-4354-8074-c4dd4636f9b0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As we can see in the following screenshot, we were able to authenticate with
    the page using custom HTTP headers and following the authentication, the server
    redirects us to the `home.php` page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3b970bdd-0872-4c20-b139-d72256846f17.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `home.php` page looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d0a8de11-cdfe-4262-860b-7595ffcc0674.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that we have some clarity regarding fuzzing HTTP request headers, we can
    use similar fuzzing techniques on HTTP `POST` parameters as well, which we can
    see in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5214d1b6-2d45-4bea-add1-52fcb68f7847.png)'
  prefs: []
  type: TYPE_IMG
- en: In the same way, we can also fuzz the HTTP `POST` parameters to find APIs supported
    by the application and the acceptable values supported by those API parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Performing fuzz testing on web application attack vectors can provide us with
    more insights into web application penetration testing. It's always a good practice
    to log each request and response when the fuzzer finds something interesting.
    Lastly, fuzz testing is quite effective if elaborative fuzzing data is provided
    to the fuzzer. In most cases, fuzz testing can find code execution and other technical
    vulnerabilities that a generic web application scanner cannot.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we first learned about the basics of fuzzing and the different
    types of fuzzing attacks. Then, we moved deeper into web application fuzzing and
    looked at the installation of **Wfuzz** and **ffuf**. After that, we performed
    fuzzing on HTTP request verbs and request URIs. Toward the end of the chapter,
    we looked at three scenarios: cookie header fuzzing, user-defined cookie header
    fuzzing, and custom header fuzzing. Having learned about fuzz testing, you can
    now understand the behavior of a web application, which will help you to find
    technical as well as logical vulnerabilities. You can use fuzz testing as part
    of your regular penetration testing while doing bug bounties, or while playing
    challenging **Capture The Flags** (**CTFs**).'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at the key points that must be included in
    penetration testing reports.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Can I perform fuzzing on SSL-based web applications?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Are these fuzzers (the ones mentioned in this chapter) supported in Windows?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do I need to perform fuzzing in all web application penetration tests?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What kinds of vulnerabilities will I find if I perform fuzzing?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Wfuzz download page: [https://github.com/xmendez/wfuzz](https://github.com/xmendez/wfuzz)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ffuf download page: [https://github.com/ffuf/ffuf](https://github.com/ffuf/ffuf)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Burp Suite official site: [https://portswigger.net/burp](https://portswigger.net/burp)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Understanding the basics of fuzzing: [https://owasp.org/www-community/Fuzzing](https://owasp.org/www-community/Fuzzing)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Learning about web application attack vectors: [https://www.blackhat.com/presentations/bh-dc-07/Sutton/Presentation/bh-dc-07-Sutton-up.pdf](https://www.blackhat.com/presentations/bh-dc-07/Sutton/Presentation/bh-dc-07-Sutton-up.pdf)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
