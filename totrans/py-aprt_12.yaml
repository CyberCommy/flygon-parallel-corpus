- en: Chapter 7 - Comprehensions, iterables, and generators
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The abstract notion of a *sequence of objects* is ubiquitous in programming.
    It can be used to model such widely different concepts as simple strings, lists
    of complex objects, and indefinitely long sensor output streams. It probably won’t
    surprise you to learn that Python includes some very powerful and elegant tools
    for working with sequences. In fact, Python’s support for creating and manipulating
    sequences is one of the highlights of the language for many people.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we’ll look at three key tools that Python provides for working
    with sequences: comprehensions, iterables, and generators. *Comprehensions* comprise
    a dedicated syntax for creating various types of sequences declaratively. *Iterables*
    and the *iteration protocols* form the core abstraction and API for sequences
    and iteration in Python; they allow you define new sequence types and exert fine-grained
    control over iteration. Finally, *generators* allow us to define lazy sequences
    imperatively, a surprisingly powerful technique in many circumstances.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Let’s jump right in to comprehensions.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Comprehensions
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Comprehensions in Python are a concise syntax for describing lists, sets or
    dictionaries in a declarative or functional style. This short-hand is readable
    and expressive, meaning that comprehensions are very effective at communicating
    intent to human readers. Some comprehensions almost read like natural language,
    making them nicely self-documenting.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: List comprehensions
  id: totrans-6
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As hinted at above, a *list comprehension* is a short-hand way of creating
    a list. It’s an expression using a succinct syntax that describes *how list elements
    are defined*. Comprehensions are much easier to demonstrate than they are to explain,
    so let’s bring up a Python REPL. First we’ll create a list of words by splitting
    a string:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now comes the list comprehension. The comprehension is enclosed in square brackets
    just like a literal list, but instead of literal elements it contains a fragment
    of declarative code which describes how to construct the elements of the list:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here the new list is formed by binding the name `word` to each value in `words`
    in turn and then evaluating `len(word)` to create the corresponding value in the
    new list. In other words, this constructs a new list containing the lengths of
    the string in `words`; it’s hard to imagine a much more effective way of expressing
    that new list!
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: List comprehension syntax
  id: totrans-12
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The general form for a list comprehension is:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: That is, for each `item` in the `iterable` on the right we evaluate the expression
    `expr(item)` on the left (which is almost always, but not necessarily, in terms
    of the item). We use the result of that expression as the next element of the
    list we are constructing.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: 'The comprehension above is the declarative equivalent of the following imperative
    code:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Elements of a list comprehension
  id: totrans-18
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Note that the source object over which we iterate in a list comprehension doesn’t
    need to be a list itself. It can be any object with implements the iterable protocol
    ^([15](chap21.xhtml#fn-cover-iterable-protocol-later)), such as a tuple.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: 'The expression part of the comprehension can be any Python expression. Here
    we find the number of decimal digits in each of the first 20 factorials using
    `range()` — which is an iterable object — to generate the source sequence:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Note also that the type of the object produced by list comprehensions is nothing
    more or less than a regular `list`:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: It’s important to keep this fact in mind as we look at other kinds of comprehensions
    and consider how to perform iteration over infinite sequences.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Set comprehensions
  id: totrans-25
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Sets support a similar comprehension syntax using, as you might expect, curly
    braces. Our previous “number of digits in factorials” result contained duplicates,
    but by building a set instead of a list we can eliminate them:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Like list comprehensions, set comprehension produce standard `set` objects:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note that, since sets are unordered containers, the resulting set is not *necessarily*
    stored in a meaningful order.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: Dictionary comprehensions
  id: totrans-31
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The third type of comprehension is the dictionary comprehension. Like the set
    comprehension syntax, the dictionary comprehension also uses curly braces. It
    is distinguished from the set comprehension by the fact that we now provide two
    colon-separated expressions — the first for the key and the second for the value
    — which will be evaluated in tandem for each new item in the resulting dictionary.
    Here’s a dictionary we can play with:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'One nice use for a dictionary comprehension is to invert a dictionary so we
    can perform efficient lookups in the opposite direction:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note that dictionary comprehensions do not operate directly on dictionary sources!^([16](chap21.xhtml#fn-dictionary-sources))
    If we want both keys and values from a source dictionary, then we should use the
    `items()` method coupled with tuple unpacking to access the keys and values separately.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: 'Should your comprehension produce some identical keys, later keys will overwrite
    earlier keys. In this example we map the first letters of words to the words themselves,
    but only the last h-word is kept:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Comprehension complexity
  id: totrans-39
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Remember that there’s no limit to the complexity of the expression you can
    use in any of the comprehensions. For the sake of your fellow programmers, though,
    you should avoid going overboard. Instead, extract complex expressions into separate
    functions to preserve readability. The following is close to the limit of being
    reasonable for a dictionary comprehension:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This uses the `glob` module to find all of the Python source files in a directory.
    It then creates a dictionary of paths to file sizes from those files.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: Filtering comprehensions
  id: totrans-43
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: All three types of collection comprehension support an optional filtering clause
    which allows us to choose which items of the source are evaluated by the expression
    on the left. The filtering clause is specified by adding `if <boolean expression>`
    after the sequence definition of the comprehension; if the boolean expression
    returns false for an item in the input sequence, then no value is evaluated for
    that item in the result.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: 'To make this interesting, we’ll first define a function that determines if
    its input is a prime number:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can now use this in the filtering clause of a list comprehension to produce
    all primes less than 100:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Combining filtering and transformation
  id: totrans-49
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'We have a slightly odd-looking `x for x` construct here because we’re not applying
    any transformation to the filtered values; the expression in terms of `x` is simply
    `x` itself. There’s nothing to stop us, however, from combining a filtering predicate
    with a transforming expression. Here’s a dictionary comprehension which maps numbers
    with exactly three divisors to a tuple of those divisors:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '* * *'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: Moment of zen
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '![](images/m07----zen-simple-is-better-than-complex.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
- en: Comprehensions are often more readable than the alternative. However it’s possible
    to over-use comprehensions. Sometimes a long or complex comprehension may be *less*
    readable than the equivalent for-loop. There is no hard-and-fast rule about when
    one form should be preferred, but be conscientious when writing your code and
    try to choose the best form for your situation.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: Above all your comprehensions should ideally be purely functional — that is
    they should have no side effects. If you need to create side effects, such as
    printing to the console during iteration, use another construct such as a for-loop
    instead.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: Iteration protocols
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Comprehensions and for-loops are the most frequently used language features
    for performing iteration. The both take items one by one from a source and do
    something with each in turn. However, both comprehensions and for-loops iterate
    over the whole sequence by default, whereas sometimes more fine-grained control
    is needed. In this section we’ll see how you can exercise this kind of fine-grained
    control by investigating two important concepts on top of which a great deal of
    Python language behavior is constructed: *iterable* objects and *iterator* objects,
    both of which are reflected in standard Python protocols.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: The *iterable protocol* defines an API that iterable objects must implement.
    That is, if you want to be able to iterate over an object using for-loops or comprehensions,
    that object must implement the iterable protocol. Built-in classes like `list`
    implement the iterable protocol. You can pass an object that implements the iterable
    protocol to the built-in `iter()` function to get an *iterator* for the iterable
    object.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '*Iterator*s, for their part, support the *iterator protocol*. This protocol
    requires that we can pass the iterator object to the built-in `next()` function
    to fetch the next value from the underlying collection.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: An example of the iteration protocols
  id: totrans-62
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As usual, a demonstration at the Python REPL will help all of these concepts
    crystallize into something you can work with. We start with a list of the names
    of the seasons as our iterable object:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We then ask our iterable object to give us an iterator using the `iter()` built-in:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next we request a value from the iterator using the `next()` built-in:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Each call to `next()` moves the iterator through the sequence:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: But what happens when we reach the end?
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In a spectacular display of liberalism, Python raises a `StopIteration` exception.
    Those of you coming from other programming languages with a more straight-laced
    approach to exceptions may find this mildly outrageous, but, really, what could
    be more exceptional than reaching the end of a collection? It only has one end
    after all!
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: This attempt at rationalizing the Python language design decision makes even
    more sense when one considers that the iterable series may be a potentially infinite
    stream of data. Reaching the end in that case really *would* be something to write
    home about, or indeed raise an exception for.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: A more practical example of the iteration protocols
  id: totrans-75
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'With for-loops and comprehensions at our fingertips, the utility of these lower
    level iteration protocols may not be obvious. To demonstrate a more concrete use,
    here’s a little utility function which, when passed an iterable object, returns
    the first item from that series or, if the series is empty, raises a `ValueError`:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This works as expected on any iterable object, in this case both a `list` and
    a `set`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: It’s worth noting that the higher-level iteration constructs, such as for-loops
    and comprehensions, are built directly upon this lower-level iteration protocol.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: Generator functions
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now we come on to *generator functions*^([17](chap21.xhtml#fn-just-generator)),
    one of the most powerful and elegant features of the Python programming language.
    Python generators provide the means for describing iterable series with code in
    functions. These sequences are evaluated lazily, meaning they only compute the
    next value on demand. This important property allows them to model infinite sequences
    of values with no definite end, such as streams of data from a sensor or active
    log files. By carefully designing generator functions we can make generic stream
    processing elements which can be composed into sophisticated pipelines.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: The `yield` keyword
  id: totrans-83
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Generators are defined by any Python function which uses the `yield` keyword
    at least once in its definition. They may also contain the `return` keyword with
    no arguments, and just like any other function, there is an implicit `return`
    at the end of the definition.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: To understand what generators do, let’s start with a simple example at the Python
    REPL. Let’s define the generator, and then we’ll examine how the generator works.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: 'Generator functions are introduced by `def`, just as for a regular Python function:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now let’s call `gen123()` and assign its return value to `g`:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As you can see, `gen123()` is called just like any other Python function. But
    what has it returned?
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Generators are iterators
  id: totrans-92
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`g` is a generator object. Generators are, in fact, Python *iterators*, so
    we can use the iterator protocol to retrieve – or yield – successive values from
    the series:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Take note of what happens now that we’ve yielded the last value from our generator.
    Subsequent calls to `next()` raise a `StopIteration` exception, just like any
    other Python iterator:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Because generators are iterators, and because iterators must also be iterable,
    they can be used in all the usual Python constructs which expect iterable objects,
    such as for-loops:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Be aware that each call to the generator function returns a new generator object:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Also note how each generator object can be advanced independently:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: When is generator code executed?
  id: totrans-103
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s take a closer look at how — and crucially *when* — the code in the body
    of our generator function is executed. To do this, we’ll create a slightly more
    complex generator that traces its execution with good old-fashioned print statements:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'At this point the generator object has been created and returned, but none
    of the code within the body of the generator function has yet been executed. Let’s
    make an initial call to `next()`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: See how, when we request the first value, the generator body runs up to and
    including the first `yield` statement. The code executes just far enough to literally
    `yield` the next value.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'When we request the next value from the generator, execution of the generator
    function *resumes* at the point it left off, and continues running until the next
    `yield`:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: After the final value has returned the next request causes the generator function
    to execute until it returns at the end of the function body, which in turn raises
    the expected `StopIteration` exception.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Now that we’ve seen how generator execution is initiated by calls to `next()`
    and interrupted by `yield` statements, we can progress to placing more complex
    code in our generator function body.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: Maintaining explicit state in the generator function
  id: totrans-115
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now we’ll look at how our generator functions, which resume execution each time
    the next value is requested, can maintain state in local variables. In the process
    of doing so, our generators will be both more interesting and more useful. We’ll
    be showing two generators which demonstrate lazy evaluation, and later we’ll combine
    them into a generator pipeline.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: 'The first stateful generator: `take()`'
  id: totrans-117
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The first generator we’ll look at is `take()` which retrieves a specified number
    of elements from the front of a sequence:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Note that the function defines a generator because it contains at least one
    `yield` statement. This particular generator also contains a `return` statement
    to terminate the stream of yielded values. The generator uses a counter to keep
    track of how many elements have been yielded so far, returning when a request
    is made for any elements beyond that requested count.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: 'Since generators are lazy, and only produce values on request, we’ll drive
    execution with a for-loop in a `run_take()` function:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Here we create a source `list` named `items` which we pass to our generator
    function along with a count of `3`. Internally, the for-loop will use the iterator
    protocol to retrieve values from the `take()` generator until it terminates.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: 'The second stateful generator: `distinct()`'
  id: totrans-124
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Now let’s bring our second generator into the picture. This generator function,
    called `distinct()`, eliminates duplicate items by keeping track of which elements
    it’s already seen in a `set`:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In this generator we also make use of a control flow construct we have not
    previously seen: the `continue` keyword. The `continue` statement finishes the
    current iteration of the loop and begins the next iteration immediately. When
    executed in this case execution will be transferred back to the `for` statement,
    but as with `break` it can also be used with while-loops.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, the `continue` is used to skip any values which have already
    been yielded. We can add a `run_distinct()` function to exercise `distinct()`
    as well:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Understand these generators!
  id: totrans-130
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: At this point you should spend some time exploring these two generators before
    moving on. Make sure you understand how they work and how control flows in and
    out of them as they maintain state. If you’re using an IDE to run these example,
    you can use the debugger to follow control flow by putting breakpoints in the
    generators and in the code that uses them. You can accomplish the same by using
    Python’s built-in `pdb` debugger (which we cover later) or even just by using
    old-fashioned print statements.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: However you do it, make sure you’re really comfortable with how these generators
    work before moving to the next sections.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: Lazy generator pipelines
  id: totrans-133
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that you understand the generators individually, we’ll arrange both of
    them into a lazy pipeline. We’ll be using `take()` and `distinct()` together to
    fetch the first three unique items from a collection:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Notice that the `distinct()` generator only does just enough work to satisfy
    the demands of the `take()` generator which is iterating over it - it never gets
    as far as the last two items in the source list because they are not needed to
    produce the first three unique items. This lazy approach to computation is very
    powerful, but the complex control flows it produces can be difficult to debug.
    It’s often useful during development to force evaluation of all of the generated
    values, and this is most easily achieved by inserting a call to the `list()` constructor:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This interspersed call to `list()` causes the `distinct()` generator to exhaustively
    process its source items before `take()` does its work. Sometimes when you’re
    debugging lazily evaluated sequences, this can give you the insight you need to
    understand what’s going on.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: Laziness and the infinite
  id: totrans-139
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Generators are lazy, meaning that computation only happens just-in-time when
    the next result is requested. This interesting and useful property of generators
    means they can be used to model infinite sequences. Since values are only produced
    as requested by the caller, and since no data structure needs to be built to contain
    the elements of the sequence, generators can safely be used to produce never-ending
    (or just very large) sequences like:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: sensor readings
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: mathematical sequences (e.g. primes, factorials, etc.) ^([18](chap21.xhtml#fn-no-fibonacci))
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the contents of a multi-terabyte file
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating the Lucas series
  id: totrans-144
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Allow us to present a generator function for the Lucas series^([19](chap21.xhtml#fn-machete-order)):'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The Lucas series starts with `2, 1`, and each value after that is the sum of
    the two preceding values. So the first few value of the sequence are:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The first `yield` produces the value `2`. The function then initializes `a`
    and `b` which hold the “previous two values” needed as the function proceeds.
    Then the function enters an infinite while-loop where:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: It yields the value of `b`
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`a` and `b` are updated to hold the new “previous two” values using a neat
    application of tuple unpacking'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now that we have a generator, it can be used like any other iterable object.
    For instance, to print the Lucas numbers you could use a loop like this:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Of course, since the Lucas sequence is infinite this will run forever, printing
    out values until your computer runs out of memory. Use Control-C to terminate
    the loop.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Generator expressions
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Generator expressions are a cross between comprehensions and generator functions.
    They use a similar syntax as comprehensions, but they result in the creation of
    a *generator object* which produces the specified sequence lazily. The syntax
    for generator expressions is very similar to list comprehensions:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: It is delimited by parentheses instead of the brackets used for list comprehensions.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: 'Generator expressions are useful for situations where you want the lazy evaluation
    of generators with the declarative concision of comprehensions. For example, this
    generator expression yields a list of the first one-million square numbers:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'At this point, none of the squares have been created; we’ve just captured the
    specification of the sequence into a generator object:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We can force evaluation of the generator by using it to create a (long!) `list`:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This list obviously consumes a significant chunk of memory - in this case about
    40 MB for the list object and the integer objects contained therein.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: Generator objects only run once
  id: totrans-166
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Notice that a generator object is just an iterator and, once run exhaustively
    in this way, will yield no more items. Repeating the previous statement returns
    an empty list:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Generators are single use objects. Each time we call a generator *function*
    we create a new generator object. To recreate a generator from a generator expression
    we must execute the expression itself once more.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: Iteration without memory
  id: totrans-170
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Let’s raise the stakes by computing the sum of the first *ten* million squares
    using the built-in `sum()` function which accepts an iterable series of numbers.
    If we were to use a list comprehension we could expect this to consume around
    400 MB of memory. Using, a generator expression memory usage will be insignificant:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This produces a result in a second or so and uses almost no memory.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: Optional parentheses
  id: totrans-174
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Looking carefully, you see that in this case we didn’t supply separate enclosing
    parentheses for the generator expression in addition to those needed for the `sum()`
    function call. This elegant ability to have the parentheses used for the function
    call also serve for the generator expression aids readability. You can include
    the second set of parentheses if you wish.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: Using an if-clause in generator expressions
  id: totrans-176
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'As with comprehensions, you can include an if-clause at the end of the generator
    expression. Reusing our admittedly inefficient `is_prime()` predicate, we can
    determine the sum of those integers from the first thousand which are prime like
    this:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Note that is is not the same thing as computing the sum of the first 1000 primes,
    which is a more awkward question because we don’t know in advance how many integers
    we need to test before we clock up a thousand primes.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: “Batteries included” iteration tools
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So far we’ve covered the many ways Python offers for creating iterable objects.
    Comprehensions, generators, and any object that follows the iterable or iterator
    protocols can be used for iteration, so it should be clear that iteration is a
    central feature of Python.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Python provides a number of built-in functions for performing common iterator
    operations. These functions form the core of a sort of *vocabulary* for working
    with iterators, and they can be combined to produce powerful statements in very
    concise, readable code. We’ve met some of these functions already, including `enumerate()`
    for producing integer indices and `sum()` for computing summation of numbers.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: Introducing `itertools`
  id: totrans-183
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In addition to the built-in functions, the `itertools` module contains a wealth
    of useful functions and generators for processing iterable streams of data.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll start demonstrating these functions by solving the first thousand primes
    problem using built-in `sum()` with two generator functions from `itertools`:
    `islice()` and `count()`.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: 'Earlier we made our own `take()` generator function for lazily retrieving the
    start of the sequence. We needn’t have bothered, however, because `islice()` allows
    us to perform lazy slicing similar to the built-in list slicing functionality.
    To get the first 1000 primes we need to do something like:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'But how to generate `all_primes`? Previously, we’ve been using `range()` to
    create the raw sequences of integers to feed into our primality test, but ranges
    must always be finite, that is, bounded at both ends. What we’d like is an open
    ended version of `range()`, and that is exactly what `itertools.count()` provides.
    Using `count()` and `islice()`, our first thousand primes expression can be written
    out as:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This returns a special `islice` object which is iterable. We can convert it
    to a list using the list constructor.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Answering our question about the sum of the first thousand primes is now easy,
    remembering to recreate the generators:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Sequences of booleans
  id: totrans-194
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Two other very useful built-ins which facilitate elegant programs are `any()`
    and `all()`. They’re equivalent to the logical operators `and` and `or` but for
    iterable series of `bool` values,
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Here we’ll use `any()` together with a generator expression to answer the question
    of whether there are any prime numbers in the range 1328 to 1360 inclusive:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'For a completely different type of problem we can check that all of these city
    names are proper nouns with initial upper-case letters:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Merging sequences with `zip`
  id: totrans-201
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The last built-in we’ll look at is `zip()`, which, as its name suggests, gives
    us a way to synchronise iterations over two iterable series. For example, let’s
    `zip` together two columns of temperature data, one from Sunday and one from Monday:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'We can see that `zip()` yields tuples when iterated. This in turn means we
    can use it with tuple unpacking in the for-loop to calculate the average temperature
    for each hour on these days:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: More than two sequences with `zip()`
  id: totrans-206
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In fact, `zip()` can accept any number of iterable arguments. Let’s add a third
    time-series and use other built-ins to calculate statistics for corresponding
    times:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Note how we’ve used string formatting features to control the numeric column
    width to four characters.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: Lazily concatenating sequences with `chain()`
  id: totrans-210
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Perhaps, though, we’d like one long temperature series for Sunday, Monday and
    Tuesday. Rather than creating a new list by eagerly combining the three lists
    of temperatures, we can *lazily* concatenate iterables using `itertools.chain()`:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '`temperatures` is an iterable object that first yields the values from `sunday`,
    followed by those from `monday`, and finally those from `tuesday`. Since it’s
    lazy, though, it never creates a single list that contains all of the elements;
    in fact, it never creates an intermediate list of any sort!'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now check that all of those temperatures are above freezing point, without
    the memory impact of data duplication:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Pulling it all together
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before we summarize, let’s pull a few pieces of what we have made together
    and leave your computer computing the Lucas primes:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: When you’ve seen enough of these, we recommend you spend some time exploring
    the `itertools` module. The more you familiarize yourself with Python’s existing
    support for iterables, the more elegant and concise your own code will become.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Comprehensions are a concise syntax for describing lists, sets and dictionaries.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comprehensions operate on a iterable source object and apply an optional predicate
    filter and a mandatory expression, both of which are usually in terms of the current
    item.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Iterables objects are objects over which we can iterate item-by-item.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We retrieve an iterator from an iterable object using the built-in `iter()`
    function.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Iterators produce items one-by-one from the underlying iterable series each
    time they are passed to the built-in `next()` function.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Iterators raise a `StopIteration` exception when the collection is exhausted.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generators
  id: totrans-227
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Generator functions allow us to describe sequences using imperative code.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成器函数允许我们使用命令式代码描述序列。
- en: Generator functions contain at least one use of the `yield` keyword.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成器函数至少包含一次使用`yield`关键字。
- en: Generators are iterators. When the iterator is advanced with `next()` the generator
    starts or resumes execution up to and including the next `yield`.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成器是迭代器。当迭代器使用`next()`进行推进时，生成器会开始或恢复执行，直到包括下一个`yield`为止。
- en: Each call to a generator function creates a new generator object.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对生成器函数的每次调用都会创建一个新的生成器对象。
- en: Generators can maintain explicit state in local variables between iterations.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成器可以在迭代之间的局部变量中维护显式状态。
- en: Generators are lazy and so can model infinite series of data.
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成器是懒惰的，因此可以模拟无限的数据系列。
- en: Generator expressions have a similar syntactic form to list comprehensions and
    allow for a more declarative and concise way of creating generator objects.
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成器表达式具有类似的语法形式，可以更声明式和简洁地创建生成器对象。
- en: Iteration tools
  id: totrans-235
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 迭代工具
- en: Python includes a rich set of tools for dealing with iterable series, both in
    the form of built-in functions such as `sum()`, `any()` and `zip()` as well as
    in the `itertools` module.
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python包括一套丰富的工具，用于处理可迭代系列，包括内置函数如`sum()`、`any()`和`zip()`，以及`itertools`模块中的工具。
