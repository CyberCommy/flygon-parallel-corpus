- en: Chapter 5. Changing Data and Structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data is not static, it changes often. This chapter focuses on editing and deleting
    data and its supporting structures—tables and databases.
  prefs: []
  type: TYPE_NORMAL
- en: The chapter is divided into two main parts. The first part covers all aspects
    of changing data. First we examine how to edit data, that is, how to enter the
    edit mode, how to edit more than one row at once, and how to benefit from inline
    editing. Next we see how to delete rows of data and how to delete tables and databases.
  prefs: []
  type: TYPE_NORMAL
- en: The second part explains how to modify the structure of tables. We examine how
    to add a column to a table; we then explore various column types such as `TEXT,
    BLOB, ENUM, DATE`, and `BIT` column types. Finally, we examine the management
    of indexes.
  prefs: []
  type: TYPE_NORMAL
- en: Changing data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we cover the various ways of editing and deleting data.
  prefs: []
  type: TYPE_NORMAL
- en: Entering edit mode
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When we browse a table or view results from a search on any single-table query,
    small icons and links appear on the left or right of each table row as shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Entering edit mode](img/7782_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The row can be edited with one of the pencil-shaped icons **(Edit)** and deleted
    with the red icon **(Delete)**. The exact form and location of these controls
    are governed by:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We can decide whether to display them on the left side, the right side, or on
    both sides. The `$cfg['PropertiesIconic']` parameter can have the values `TRUE,
    FALSE`, or `both. TRUE` displays icons only, `FALSE` displays **Edit, Inline Edit,
    Copy**, and **Delete** (or their translated equivalent) as links, and `both` displays
    the icon and the text, as seen in the preceding screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: The small checkbox beside each row is explained in the *Multi-row editing* and
    the *Deleting multiple rows* sections later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Clicking on the **Edit** icon or link brings the following panel, which is
    similar to the data entry panel (except for the lower part):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Entering edit mode](img/7782_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this panel, we can change data by typing directly (or by cutting and pasting
    via the normal operating system mechanisms). We can also revert to the original
    contents using the **Reset** button.
  prefs: []
  type: TYPE_NORMAL
- en: By default, the lower drop-down menus are set to **Save** (so that we make changes
    to this row) and **Go back to previous page** (so that we can continue editing
    another row on the previous results page). We might want to stay on the current
    page after clicking on **Go** —in order to save and then continue editing—we can
    choose **Go back to this page**. If we want to insert yet another new row after
    saving the current row, we just have to choose **Insert another new row** before
    saving. The **Insert as new row** choice (below the **Save** choice) is explained
    in the *Duplicating rows of data* section later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Moving to next field with the tab key
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: People who prefer to use the keyboard can use the *Tab* key to go to the next
    field. Normally, the cursor goes from left to right and from top to bottom, so
    it would travel into the fields in the **Function** column (more on this in a
    moment). However, to ease data navigation in phpMyAdmin, the normal order of navigation
    has been altered. The *Tab* key first goes through each field in the **Value**
    column, and then through each one in the **Function** column.
  prefs: []
  type: TYPE_NORMAL
- en: Moving with arrows
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another way of moving between fields is with the *Ctrl* + *arrow* keys. This
    method might be easier than using the *Tab* key when many fields are on screen.
    For this to work, the `$cfg['CtrlArrowsMoving']` parameter must be set to `true`,
    which is the default value.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In some situations, this technique cannot be used for moving between fields.
    For example, the Google Chrome browser does not support *Ctrl* + *arrow*. Also,
    on Mac OS X 10.5 with Spaces enabled, *Ctrl* + *arrow* is the default shortcut
    to switch between virtual desktops.
  prefs: []
  type: TYPE_NORMAL
- en: Handling NULL values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If the table's structure permits a `NULL` value inside a column, a small checkbox
    appears in the column's **Null** column. Selecting this puts a `NULL` value in
    the column. Whenever data is typed into this column's **Value**, the **Null**
    checkbox is cleared automatically. (This is possible in JavaScript-enabled browsers.)
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following screenshot, we have modified the structure of the **phone**
    column in the `author` table, to permit a `NULL` value (refer to the *Editing
    column attribute* section in this chapter). The **Null** checkbox is not selected
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Handling NULL values](img/7782_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The corresponding data is erased after selecting the **Null** box.
  prefs: []
  type: TYPE_NORMAL
- en: Applying a function to a value
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: MySQL language offers some functions that we may apply to data before saving.
    Some of these functions appear in a drop-down menu beside each column, if `$cfg['ShowFunctionFields']`
    is set to `TRUE`.
  prefs: []
  type: TYPE_NORMAL
- en: The function list is defined in the `$cfg['Functions']` array. As usual, the
    default values for these arrays are located in `libraries/config.default.php`.
    We may change them by copying the needed section into `config.inc.php`. If we
    do so, as these values can change from version to version, we should take care
    of merging our changes with the values of the new version. The most commonly used
    functions for a certain data type are displayed first in the list. Some restrictions
    are defined in the `$cfg['RestrictColumnTypes']` and `$cfg['RestrictFunctions']`
    arrays.
  prefs: []
  type: TYPE_NORMAL
- en: 'As depicted in the following screenshot, we could apply the **UPPER** function
    to the **title** column when saving this row, which would convert the title to
    uppercase characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Applying a function to a value](img/7782_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To gain some screen space, this feature may be disabled by setting `$cfg['ShowFunctionFields']`
    to `FALSE`. Moreover, the **Function** column header is clickable, so we can disable
    this feature on the fly.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the feature is disabled—either by clicking or via the configuration parameter—a
    **Show : Function** link appears in order to display this **Function** column
    with a single click as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Applying a function to a value](img/7782_05_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A similar feature is available for the **Type** column header, either by clicking
    on it or by configuring `$cfg['ShowFieldTypesInDataEditView']`.
  prefs: []
  type: TYPE_NORMAL
- en: Duplicating rows of data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: During the course of data maintenance (for permanent duplication or for test
    purposes), we often have to generate a copy of a row. If this is done in the same
    table, we must respect the rules of key uniqueness.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of row duplication. Our author has written volume 2 of his
    book about cinema. Hence, the columns that need a slight change are the ISBN,
    title, and page count. We bring the existing row on screen, change these three
    columns, and choose **Insert as new row**, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Duplicating rows of data](img/7782_05_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'When we click on **Go**, another row is created with the modified information,
    leaving the original row unchanged, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Duplicating rows of data](img/7782_05_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A shortcut link exists to achieve the same operation. When browsing the table,
    clicking on **Copy** for a specific row brings the edit panel for this row and
    selects **Insert as new row** instead of **Save**.
  prefs: []
  type: TYPE_NORMAL
- en: Multi-row editing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The multi-row edit feature enables us to use checkboxes on the rows we want
    to edit, and use the **Change** link (or the pencil-shaped icon) in the **With
    selected** menu. The **Check All / Uncheck All** links can also be used to quickly
    check or uncheck all the boxes. We can also click anywhere on the row's data to
    activate the corresponding checkbox. To select a range of checkboxes, we can click
    the first checkbox of the range, and then *Shift* + Click on the last checkbox
    of the range.
  prefs: []
  type: TYPE_NORMAL
- en: '![Multi-row editing](img/7782_05_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Upon clicking on **Change**, an edit panel containing all the chosen rows appears.
    The editing process may continue while the data from these rows is seen, compared,
    and changed. When we mark some rows with the checkboxes, we can also perform two
    other actions on them—**Delete** (refer to the *Deleting multiple rows* section
    in this chapter) and **Export** (refer to [Chapter 6)](ch06.html "Chapter 6. Exporting
    Structure and Data (Backup)").
  prefs: []
  type: TYPE_NORMAL
- en: Editing the next row
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sequential editing is possible on tables that have a primary key on an integer
    column. Our `author` table meets the criteria. Let us see what happens when we
    start editing the row having the **id** value **1:**
  prefs: []
  type: TYPE_NORMAL
- en: '![Editing the next row](img/7782_05_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The editing panel appears, and we can edit author number **1**. However, in
    the drop-down menu, the **Edit next row** choice is available. If chosen, the
    next author—the first one whose primary key value is greater than the current
    primary key value—will be available for edit.
  prefs: []
  type: TYPE_NORMAL
- en: Inline row editing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Version 3.4 introduces inline row editing, that is, keeping in view the other
    rows of the results set while editing. This feature is available if `$cfg[''AjaxEnable'']`
    is set to `true`, via either `config.inc.php` or the user preferences. Clicking
    on **Inline Edit** for a row shows the following dialog:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Inline row editing](img/7782_05_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After editing the columns that need changes, we click on **Save**. Aborting
    the changes is also possible by using the **Hide** link.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'phpMyAdmin''s interface enables us to delete the following data:'
  prefs: []
  type: TYPE_NORMAL
- en: Single rows of data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiple rows of a table
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the rows in a table
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the rows in multiple tables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deleting a single row
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can use the red **Delete** icon beside each row to delete the row. If the
    value of `$cfg['Confirm']` is set to `TRUE`, every MySQL `DELETE` statement has
    to be confirmed before execution. This is the default, as it might not be prudent
    to allow a row to be deleted with just one click!
  prefs: []
  type: TYPE_NORMAL
- en: 'The form of the confirmation varies depending on the browser''s ability to
    execute JavaScript. A JavaScript-based confirmation pop up would resemble the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Deleting a single row](img/7782_05_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If JavaScript has been disabled in our browser, a distinct panel appears.
  prefs: []
  type: TYPE_NORMAL
- en: The actual `DELETE` statement will use whatever information is needed to ensure
    the deletion of only the intended row. In our case, a primary key had been defined
    and was used in the `WHERE` clause. In the absence of a primary key, a longer
    `WHERE` clause will be generated based on the value of each column. The generated
    `WHERE` clause might even prevent the correct execution of the `DELETE` operation,
    especially if there are `TEXT` or `BLOB` column types. This is because the HTTP
    transaction, used to send the query to the web server, may be limited in length
    by the browser or the server. This is another reason why defining a primary key
    is strongly recommended.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting multiple rows
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let us say we examine a page of rows and decide that some rows have to be destroyed.
    Instead of deleting them one-by-one with the **Delete** link or icon and as sometimes
    the decision to delete must be made while examining a group of rows, there are
    checkboxes beside rows in `Table` view mode as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Deleting multiple rows](img/7782_05_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: These are used with the **Delete** icon in the **With selected** menu. A confirmation
    screen appears listing all the rows that are about to be deleted.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting all of the rows in a table
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To completely erase all the rows in a table (leaving its structure intact),
    we first display the database **Structure** page by selecting the related database
    from the navigation panel. We then use the **Empty** icon or link located on the
    same line as the table we want to empty, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Deleting all of the rows in a table](img/7782_05_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We get a message confirming the `TRUNCATE` statement (the MySQL statement used
    to quickly empty a table). For our exercise, we won't delete this precious data!
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Deleting data, either row-by-row or by emptying a table, is a permanent action.
    No recovery is then possible except by restoring a backup.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting all rows in multiple tables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A checkbox is present on the left of each table name. We can choose some tables.
    Then, in the **With selected** menu, choose the **Empty** operation as shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Deleting all rows in multiple tables](img/7782_05_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Of course, this decision must not be taken lightly!
  prefs: []
  type: TYPE_NORMAL
- en: Deleting tables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Deleting a table erases the data and the table's structure. In the `Database`
    view, we can delete a specific table by using the red **Drop** icon for that table.
    The same mechanism also exists for deleting more than one table (with the drop-down
    menu and the **Drop** action).
  prefs: []
  type: TYPE_NORMAL
- en: Deleting databases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can delete an entire database (including all its tables) by going to the
    **Databases** page in `Server` view, selecting the checkbox beside the unwanted
    database and clicking on the **Drop** link:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Deleting databases](img/7782_05_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: By default, `$cfg['AllowUserDropDatabase']` is set to `FALSE`. So, this panel
    does not permit unprivileged users to drop a database until this setting is manually
    changed to `TRUE`.
  prefs: []
  type: TYPE_NORMAL
- en: To help us think twice, a special message—You **are about to DESTROY a complete
    database!—appears** before a database is deleted.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The database `mysql`, containing all user and privilege definitions, is highly
    important. Therefore, the checkbox is deactivated for this database, even for
    administrators.
  prefs: []
  type: TYPE_NORMAL
- en: Changing table structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When developing an application, requirements about data structure often change
    because of new or modified needs. Developers must accommodate these changes through
    judicious table structure editing. This section explores the subject of changing
    the structure of tables. Specifically, it shows how to add a column to an existing
    table and edit the attributes of a column. We then build on these notions to introduce
    more specialized column types, and to explain their handling through phpMyAdmin.
    Finally, we will cover the topic of index management.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a column
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Suppose that we need a new column to store a book's language and, by default,
    the books on which we keep data are written in English. We call the column **language**,
    which will contain code composed of two characters **(en** by default).
  prefs: []
  type: TYPE_NORMAL
- en: In the **Structure** page of the `Table` view for the `book` table, we can find
    the **Add column** dialog. Here, we specify how many new columns we want, and
    where they will go.
  prefs: []
  type: TYPE_NORMAL
- en: The positions of the new columns in the table matter only from a developer's
    point of view. We usually group the columns logically, so that we can find them
    more easily in the list of columns. The exact position of the columns will not
    play a role in the intended results (output from the queries), as these results
    can be adjusted regardless of the table structure. Usually, the most important
    columns (including the keys) are located at the beginning of the table. However,
    it is a matter of personal preference.
  prefs: []
  type: TYPE_NORMAL
- en: We want to put the new column **At End of Table**. So, we check the corresponding
    radio button and click on **Go**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding a column](img/7782_05_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Other possible choices would be **At Beginning of Table** and **After** (where
    we would have to choose from the drop-down menu, the column after which the new
    one must go).
  prefs: []
  type: TYPE_NORMAL
- en: 'We see the familiar panel for entering column''s attributes. We fill it in.
    However, as we want to enter a default value this time, we do the following two
    actions:'
  prefs: []
  type: TYPE_NORMAL
- en: Change the **Default** drop-down menu from **None** to **As defined:**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Enter the default value: **en**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We then click on **Save**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding a column](img/7782_05_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Vertical mode
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The previous panel appeared in vertical mode because the default for `$cfg['DefaultPropDisplay']`
    is `3`. This means that for three columns or less, the vertical mode is used,
    and for more than three, horizontal mode would be automatically selected. Here,
    we can use a number of our choosing.
  prefs: []
  type: TYPE_NORMAL
- en: If we set `$cfg['DefaultPropDisplay']` to`'vertical'`, the panel to add new
    columns (along with the panel to edit a column's structure) will be always presented
    in vertical order. This parameter can also take a value of`'horizontal'` to force
    a horizontal mode.
  prefs: []
  type: TYPE_NORMAL
- en: Editing column attribute
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'On the **Structure** page, we can make further changes to our table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Editing column attribute](img/7782_05_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This panel does not allow every possible change to columns. It specifically
    allows:'
  prefs: []
  type: TYPE_NORMAL
- en: Changing one column structure, using the **Change** link on a specific column
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removing a column, using **Drop** operation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a column to an existing **Primary** key
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting a non-unique **Index** or a **Unique** index on a column
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting a **FULLTEXT** index (offered only if the column type allows it)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are quick links that may be useful in some situations, but they do not
    replace the full index management panel. Both of these are explained in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We can use the checkboxes to choose columns. Then, with the appropriate **With
    selected** icons, we can edit the columns with **Change** or do a multiple column
    deletion with **Drop**. The **Check All / Uncheck All** option permits us to easily
    check or uncheck all boxes.
  prefs: []
  type: TYPE_NORMAL
- en: TEXT column type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will now explore how to use the **TEXT** column type and the relevant configuration
    values to adjust for the best possible phpMyAdmin behavior. First, we add to the
    **book** table a **TEXT** column called **description**.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three configuration directives that control the layout of the text
    area that will be displayed in **Insert** or **Edit** mode for the **TEXT** column
    type. The number of display columns and rows for each column is defined by:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives (by default) space to work on a **TEXT** column type as shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![TEXT column type](img/7782_05_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The settings impose only a visual limit on the text area, and a vertical scroll
    bar is created by the browser if necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although **MEDIUMTEXT, TEXT**, and **LONGTEXT** column types can accommodate
    more than 32 KiB of data, some browsers cannot always edit them with the text
    area—the mechanism offered by HTML. In fact, experimentation has convinced the
    phpMyAdmin development team to have the product display a warning message if the
    contents are larger than 32 KiB. The message warns users that the contents may
    not be editable.
  prefs: []
  type: TYPE_NORMAL
- en: The last configuration directive, `$cfg['LongtextDoubleTextarea']`, has an impact
    for **LONGTEXT** column types only. The default value of `TRUE` doubles the available
    editing space.
  prefs: []
  type: TYPE_NORMAL
- en: BLOB (Binary Large Object) column type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**BLOB** column types are generally used to hold binary data (such as images
    and sounds), even though the MySQL documentation implies that **TEXT** column
    types could be used for this purpose. The MySQL 5.1 manual says: "In some cases,
    it may be desirable to store binary data such as media files in BLOB or TEXT columns".
    However, another phrase: "BLOB columns are treated as binary strings (byte strings)",
    seems to indicate that binary data should really be stored in **BLOB** columns.
    Thus, phpMyAdmin''s intention is to work with the **BLOB** column type to hold
    all binary data.'
  prefs: []
  type: TYPE_NORMAL
- en: We will see in [Chapter 16](ch16.html "Chapter 16. Transforming Data using MIME")
    that there are special mechanisms available to go further with **BLOB** column
    type, including being able to view some images directly from within phpMyAdmin.
  prefs: []
  type: TYPE_NORMAL
- en: First, we add a **BLOB** column type named **cover_photo** to our `book` table.
    If we now browse the table, we can see the length information, **[BLOB - 0B]**,
    for each **BLOB** column type.
  prefs: []
  type: TYPE_NORMAL
- en: '![BLOB (Binary Large Object) column type](img/7782_05_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is because the **Show BLOB** display option (do you remember the **Options**
    slider?) has no check mark by default. So, it blocks the display of **BLOB** contents
    in Browse mode. This behavior is intentional. Usually, we cannot do anything with
    binary data represented in plain text.
  prefs: []
  type: TYPE_NORMAL
- en: Uploading binary content
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If we edit one row, we see the **Binary do - not edit** warning and a **Browse…**
    button. The exact caption on this button depends on the browser. Even though editing
    is not allowed, we can easily upload a text or binary file's contents into this
    **blob** column.
  prefs: []
  type: TYPE_NORMAL
- en: Let us choose an image file using the **Browse** button—for example, the `logo_left.png`
    file in a test copy of the `phpMyAdmin/themes/pmahomme/img` directory located
    on our client workstation. We now click on **Go**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Uploading binary content](img/7782_05_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We need to keep in mind some limits for the upload size. Firstly, the **blob**
    column size is limited to 64 KiB, but in [Chapter 16](ch16.html "Chapter 16. Transforming
    Data using MIME") we will change the type of this column to accommodate bigger
    images. Hence, phpMyAdmin reminds us of this limit with the **Max: 64KiB** warning.
    Also, there could be limits inherent to PHP itself (refer to [Chapter 7](ch07.html
    "Chapter 7. Importing Structure and Data") for more details). We have now uploaded
    an image inside this column for a specific row.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Uploading binary content](img/7782_05_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We notice that **BLOB - 4.9KiB** is a link; it permits to download any binary
    data to our workstation should the need arise.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we put a check mark for the **Show BLOB Contents** display option, we now
    see the following in the **BLOB** column type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Uploading binary content](img/7782_05_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To really see the image from within phpMyAdmin, refer to [Chapter 16](ch16.html
    "Chapter 16. Transforming Data using MIME").
  prefs: []
  type: TYPE_NORMAL
- en: 'The `$cfg[''ProtectBinary'']` parameter controls what can be done while editing
    binary columns **(BLOB**s and any other column with the `binary` attribute). The
    default value **blob** blocks the **BLOB** columns from being edited but allows
    us to edit other columns marked `binary` by MySQL. A value of `all` would block
    even `binary` columns from being edited. A value of `FALSE` would protect nothing,
    thus allowing us to edit all the columns. If we try the last choice, we see the
    following in the **Edit** panel for this row:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Uploading binary content](img/7782_05_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The content of this `BLOB` column type has been converted in hexadecimal and
    the **UNHEX** function is selected by default. We probably don't want to edit
    this image data in hexadecimal but this is the best way of safely representing
    binary data on screen. The reason for this hexadecimal representation is that
    the **Show binary contents as HEX display** option (in **Browse** mode) is currently
    marked. But we did not mark this option; it was checked because the `$cfg['DisplayBinaryAsHex']`
    directive is `TRUE` by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'Should we decide instead to not mark this option, we would see the following
    pure binary data for this image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Uploading binary content](img/7782_05_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There are chances that this is not our favorite image editor! In fact, data
    may be corrupted even if we save this row without touching the **BLOB** column
    type. But the possibility of setting `$cfg['ProtectBinary']` to `FALSE` exists,
    as some users put text in their **BLOB** columns, and they need to be able to
    modify this text. This is why phpMyAdmin can be configured to allow editing of
    **BLOB** columns.
  prefs: []
  type: TYPE_NORMAL
- en: MySQL **BLOB** data types are actually similar to their corresponding **TEXT**
    data types. However, we should keep in mind that a **BLOB** has no character set,
    whereas a **TEXT** column type has a character set that impacts sorting and comparison.
  prefs: []
  type: TYPE_NORMAL
- en: ENUM and SET column types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Both ENUM and SET column types are intended to represent a list of possible
    values. The difference is that the user can choose only one value from a defined
    list of values with **ENUM**, and more than one value with **SET**. With **SET**,
    all the multiple values go into one cell; but multiple values do not imply the
    creation of more than one row of data.
  prefs: []
  type: TYPE_NORMAL
- en: 'We add a column named **genre** to the `book` table and define it as an **ENUM**.
    For now, we choose to put short codes in the value list and make one of them,
    **F**, into the default value as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ENUM and SET column types](img/7782_05_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the value list, we have to enclose each value within single quotes, unlike
    in the default value field. Starting with version 3.4.0, an editor targeted for
    `ENUM/SET` columns is available. With this editor, we don''t need to bother enclosing
    values within single quotes. Clicking on **Get more editing space** brings this
    editor into action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ENUM and SET column types](img/7782_05_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In our design, these values stand for **Fantasy, Child**, and **Novel**. However,
    for now, we want to see the interface''s behavior with short code. In the **Insert**
    panel, we now see a radio box interface as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ENUM and SET column types](img/7782_05_28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If we decide to have more self-describing values, we can go back to **Structure**
    mode and change the values definition for the **genre** column. We also have to
    change the default value to one of the possible values, to avoid getting an error
    message while trying to save this column structure's modification.
  prefs: []
  type: TYPE_NORMAL
- en: '![ENUM and SET column types](img/7782_05_29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'With the modified value list, the **Insert** panel now looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ENUM and SET column types](img/7782_05_30.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Observe that the radio buttons have been replaced by a drop-down list because
    the possible values are larger in length.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want more than one possible value selected, we have to change the column
    type to **SET**. The same value list may be used. However, using our browser''s
    multiple value selector (control-click on a Windows or Linux desktop, command-click
    on a Mac), we can select more than one value as shown in the screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ENUM and SET column types](img/7782_05_31.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In a normalized data structure, we would store only the **genre** code in the
    `book` table and would rely on another table to store the description for each
    code. We would not be using **SET** or **ENUM** in this case.
  prefs: []
  type: TYPE_NORMAL
- en: DATE, DATETIME, and TIMESTAMP column types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We could use a normal character column to store date or time information. But
    **DATE, DATETIME**, and **TIMESTAMP** are more efficient for this purpose. MySQL
    checks the contents to ensure valid date and time information, and offers special
    functions to work on these columns.
  prefs: []
  type: TYPE_NORMAL
- en: Calendar pop up
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As an added benefit, phpMyAdmin offers a calendar pop up for easy data entry.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start by adding a **DATE** column type **—date_published—** to our
    `book` table. If we go into **Insert** mode, we should now see the new column
    where we could type a date. A **Calendar** icon is also available. This icon brings
    a pop-up window, synchronized to this **DATE** column type. If there is already
    a value in the column, the pop up is displayed accordingly. In our case, there
    is no value in the column, so the calendar shows the current date as shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Calendar pop up](img/7782_05_32.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Small arrows permit easy scrolling through months and years. A simple click
    on the date we want transports it to our **date_published** column. For a **DATETIME**
    or **TIMESTAMP** column type, the pop up offers the ability to edit the time part.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If we type a date or time value, a validation is done if our browser is JavaScript-enabled;
    incorrect values are highlighted in red.
  prefs: []
  type: TYPE_NORMAL
- en: TIMESTAMP option
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Starting with MySQL 4.1.2, there are more options that can affect a **TIMESTAMP**
    column type. Let us add to our `book` table, a column named **stamp** of type
    **TIMESTAMP**. In the **Default** drop-down, we could choose **CURRENT_TIMESTAMP**;
    but we won't for this exercise. However, in the **Attributes** column, we choose
    **on update CURRENT_TIMESTAMP**. More details are available at [http://dev.mysql.com/doc/refman/5.5/en/timestamp.html](http://dev.mysql.com/doc/refman/5.5/en/timestamp.html).
  prefs: []
  type: TYPE_NORMAL
- en: '![TIMESTAMP option](img/7782_05_33.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Bit column type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'MySQL 5.0.3 introduced true bit columns. These take the same amount of space
    in the database as the number of bits in their definition. Let us say we have
    the following three pieces of information about each book, and each piece can
    only be true (1) or false (0):'
  prefs: []
  type: TYPE_NORMAL
- en: Book is hard cover
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Book contains a CD-ROM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Book is available only in electronic format
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will use a single **BIT** column to store these three pieces of information.
    Therefore, we add a column having a length of **3** (which means 3 bits) to the
    `book` table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Bit column type](img/7782_05_34.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To construct and subsequently interpret the values we store in this column,
    we have to think in binary, respecting the position of each bit within the column.
    To indicate that a book is hard cover, does not contain a CD-ROM, and is available
    only in electronic format, we would use a value of `101`.
  prefs: []
  type: TYPE_NORMAL
- en: 'phpMyAdmin handles `BIT` columns in a binary way. For example, if we edit one
    row and set a value of `101` to the **some_bits** column, the following query
    is sent at save time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The highlighted part of this query shows that the column really receives a binary
    value. At browse time, the exact value (which in decimal is `5` —a meaningless
    value for our purpose) is redisplayed in its binary form `101`, which helps to
    interpret each discrete bit value. More details about the notation for bit values
    are available at [http://dev.mysql.com/doc/refman/5.5/en/bit-type.html](http://dev.mysql.com/doc/refman/5.5/en/bit-type.html).
  prefs: []
  type: TYPE_NORMAL
- en: Managing indexes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Properly maintained indexes are crucial for data retrieval speed. phpMyAdmin
    has a number of index management options, which will be covered in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Single-column indexes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We have already seen how the **Structure** panel offers a quick way to create
    an index on a single column, thanks to some links such as **Add primary key, Add
    index**, and **Add unique index**. Under the columns list, there is a section
    of the interface available to manage indexes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Single-column indexes](img/7782_05_35.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This section has links to edit or delete every index. Here, the **Column** part
    lists only one column per index, and we can see that the whole column participates
    in the index. This is because there is no size information after each column name,
    contrary to what will be seen in our next example.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will now add an index on the title. However, we want to restrict the length
    of this index to reduce the space used by the on-disk index structure. The **Create
    an index on 1 columns** option is appropriate. So, we click on **Go**. In the
    next screen, we specify the index details as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Single-column indexes](img/7782_05_36.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We fill in the following information in the options of this panel:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Index name:** A name we invent, that describes the purpose of this index'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Index type:** We can choose **INDEX**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Column:** We select the column that is used as the index, which is **title**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Size:** We enter **30** instead of 100 (the complete length of the column)
    to save space in the table''s physical portion that holds index data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After saving this panel, we can confirm from the following screenshot that
    the index is created and does not cover the entire length of the **title** column:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Single-column indexes](img/7782_05_37.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Multi-column indexes and index editing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the next example, we assume that in a future application we will need to
    find the books written by a specific author in a specific language. It makes sense
    to expand our **author_id** index, adding the **language** column to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We click on the **Edit** link (small-pencil icon) on the line containing the
    **author_id** index; this shows the current state of this index. The interface
    has room to add another column to this index. We could use the **Add to index
    1 column(s)** feature should we need to add more than one column. In the selector,
    we pick **language**. This time we do not have to enter a size, as the whole column
    will be used in the index. For better documentation, we change the **Index name
    (author_language** is appropriate) as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Multi-column indexes and index editing](img/7782_05_38.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We save this index modification. In the list of indexes, we can confirm our
    index modification.
  prefs: []
  type: TYPE_NORMAL
- en: FULLTEXT indexes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This special type of index allows for full text searches. It is supported only
    on `MyISAM` tables for the **VARCHAR** and **TEXT** column types, but MySQL 5.6
    should be offering this feature for `InnoDB` too. We can use the **Add FULLTEXT
    index** link in the columns list or go to the index management panel and choose
    **FULLTEXT** in the drop-down menu.
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing indexes with EXPLAIN
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, we want to get some information about the index that MySQL
    uses for a specific query, and the performance impact of not having defined an
    index.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us assume we want to use the following query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We want to know, which books written by the author whose `id` is `2`, are in
    the `es` language—our code for Spanish.
  prefs: []
  type: TYPE_NORMAL
- en: To enter this query, we use the **SQL** tab from the database or the table menu,
    or the SQL Query window (refer to [Chapter 11)](ch11.html "Chapter 11. Entering
    SQL Statements"). We enter this query in the query box and click **Go**. Whether
    the query finds any results, is not important right now.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You could obtain the same query by following explanations from [Chapter 8](ch08.html
    "Chapter 8. Searching Data") to produce a search for **author_id 2** and language
    **es**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Optimizing indexes with EXPLAIN](img/7782_05_39.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We will now use the **[Explain SQL]** link to get information about which index
    (if any) has been used for this query:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Optimizing indexes with EXPLAIN](img/7782_05_40.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We can see that the **EXPLAIN** command has been passed to MySQL, telling us
    that the **key** used is **author_language**. Thus, we know that this index will
    be used for this type of query. If this index had not existed, the result would
    have been quite different.
  prefs: []
  type: TYPE_NORMAL
- en: '![Optimizing indexes with EXPLAIN](img/7782_05_41.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here, **key (NULL)** and the **type (ALL)** mean that no index would be used,
    and all rows would need to be examined to find the desired data. Depending on
    the total number of rows, this could have a serious impact on the performance.
    We can ascertain the exact impact by examining the query timing that phpMyAdmin
    displays on each result page **(Query took x sec)**, and comparing it with or
    without the index. However, the difference in time can be minimal if we only have
    limited test data, compared to a real table in production. For more details about
    the `EXPLAIN` output format, please refer to [http://dev.mysql.com/doc/refman/5.5/en/explain-output.html](http://dev.mysql.com/doc/refman/5.5/en/explain-output.html).
  prefs: []
  type: TYPE_NORMAL
- en: Detecting index problems
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To help users maintain an optimal index strategy, phpMyAdmin tries to detect
    some common index problems. For example, let us access the `book` table and add
    an index on the **isbn** column. When we display this table''s structure, we get
    a warning as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Detecting index problems](img/7782_05_42.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The intention here is to warn us about an inefficient index structure when considering
    the whole table. We don't need to have two indexes on the same column.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter examined data-changing concepts, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: Editing data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Including the `NULL` column and using the *Tab* key
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying a function to a value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Duplicating rows of data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deleting data, tables, and databases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We also got an overview of structure-changing techniques such as:'
  prefs: []
  type: TYPE_NORMAL
- en: How to add columns, including special column types such as TEXT, BLOB, ENUM,
    and SET
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use a calendar pop up for DATE, DATETIME, and TIMESTAMP column types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to upload binary data into a BLOB column
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to manage indexes (multi-column and full-text), and get feedback from MySQL
    about which indexes are used in a specific query
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to export a table's structure and data
    for backup purposes, or to use as a gateway to another application.
  prefs: []
  type: TYPE_NORMAL
