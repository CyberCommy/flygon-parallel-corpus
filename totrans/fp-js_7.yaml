- en: Chapter 7. Functional and Object-oriented Programming in JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will often hear that JavaScript is a blank language, where blank is either
    object-oriented, functional, or general-purpose. This book has focused on JavaScript
    as a functional language and has gone to great lengths to prove that it is. But
    the truth is that JavaScript is a general-purpose language, meaning it's fully
    capable of multiple programming styles. Like Python and F#, JavaScript is multi-paradigm.
    But unlike those languages, JavaScript's OOP side is prototype-based while most
    other general-purpose languages are class-based.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this final chapter, we will relate both functional and object-oriented programming
    to JavaScript, and see how the two paradigms can complement each other and coexist
    side-by-side. In this chapter the following topics will be covered:'
  prefs: []
  type: TYPE_NORMAL
- en: How can JavaScript be both functional and OOP?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JavaScript's OOP – using prototypes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to mix functional and OOP in JavaScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functional inheritance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functional mixins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Better code is the goal. Functional and object-oriented programming are just
    means to this end.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript – the multi-paradigm language
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If object-oriented programming means treating all variables as objects, and
    functional programming means treating all functions as variables, then can't functions
    be treated like objects? In JavaScript, they can.
  prefs: []
  type: TYPE_NORMAL
- en: 'But saying that functional programming means treating functions as variables
    is somewhat inaccurate. A better way to put it is: functional programming means
    treating everything as a value, especially functions.'
  prefs: []
  type: TYPE_NORMAL
- en: A better way still to describe functional programming may be to call it declarative.
    Independent of the imperative branch of programming styles, *declarative programming*
    expresses the logic of computation required to solve the problem. The computer
    is told what the problem is rather than the procedure for how to solve it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Meanwhile, object-oriented programming is derived from the imperative programming
    style: the computer is given step-by-step instructions for how to solve the problem.
    OOP mandates that the instructions for computation (methods) and the data they
    work on (member variables) be organized into units called objects. The only way
    to access that data is through the object''s methods.'
  prefs: []
  type: TYPE_NORMAL
- en: So how can these two styles be integrated together?
  prefs: []
  type: TYPE_NORMAL
- en: The code inside the object's methods is typically written in an imperative style.
    But what if it was in a functional style? After all, OOP doesn't exclude immutable
    data and higher-order functions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Perhaps a purer way to mix the two would be to treat objects both as functions
    and as traditional, class-based objects at the same time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maybe we can simply include several ideas from functional programming—such as
    promises and recursion—into our object-oriented application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OOP covers topics such as encapsulation, polymorphism, and abstraction. So does
    functional programming, it just goes about it in a different way. So maybe we
    can include several ideas from object-oriented programming in our functional-oriented
    application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The point is: OOP and FP can be mixed together and there are several ways to
    do it. They''re not exclusive of each other.'
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript's object-oriented implementation – using prototypes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JavaScript is a class-less language. That's not to mean it is less fashionable
    or more blue-collar than other computer languages; class-less means it doesn't
    have a class structure in the same way that object-oriented languages do. Instead,
    it uses prototypes for inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although this may be baffling to programmers with backgrounds in C++ and Java,
    prototype-based inheritance can be much more expressive than traditional inheritance.
    The following is a brief comparison between the differences between C++ and JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '| C++ | JavaScript |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Strongly typed | Loosely typed |'
  prefs: []
  type: TYPE_TB
- en: '| Static | Dynamic |'
  prefs: []
  type: TYPE_TB
- en: '| Class-based | Prototype-based |'
  prefs: []
  type: TYPE_TB
- en: '| Classes | Functions |'
  prefs: []
  type: TYPE_TB
- en: '| Constructors | Functions |'
  prefs: []
  type: TYPE_TB
- en: '| Methods | Functions |'
  prefs: []
  type: TYPE_TB
- en: Inheritance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we go much further, let''s make sure we fully understand the concept
    of inheritance in object-oriented programming. Class-based inheritance is demonstrated
    in the following pseudo-code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `Polygon` class is the parent class the other classes inherit from. It defines
    just one member variable, the number of sides, which is set in the `init()` function.
    The `Rectangle` subclass inherits from the `Polygon` class and adds two more member
    variables, `length` and `width`, and a method, `getArea()`. It doesn't need to
    define the `numSides` variable because it was already defined by the class it
    inherits from, and it also overrides the `init()` function. The `Square` class
    carries on this chain of inheritance even further by inheriting from the `Rectangle`
    class for its `getArea()` method. By simply overriding the `init()` function again
    such that the length and width are the same, the `getArea()` function can remain
    unchanged and less code needs to be written.
  prefs: []
  type: TYPE_NORMAL
- en: In a traditional OOP language, this is what inheritance is all about. If we
    wanted to add a color property to all the objects, all we would have to do is
    add it to the `Polygon` object without having to modify any of the objects that
    inherit from it.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript's prototype chain
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Inheritance in JavaScript comes down to prototypes. Each object has an internal
    property known as its prototype, which is a link to another object. That object
    has a prototype of its own. This pattern can repeat until an object is reached
    that has `undefined` as its prototype. This is known as the prototype chain, and
    it''s how inheritance works in JavaScript. The following diagram explain the inheritance
    in JavaScirpt:'
  prefs: []
  type: TYPE_NORMAL
- en: '![JavaScript''s prototype chain](../images/00011.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: When running a search for an object's function definition, JavaScript "walks"
    the prototype chain until it finds the first definition of a function with the
    right name. Therefore, overriding it is as simple as providing a new definition
    on the prototype of the subclass.
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance in JavaScript and the Object.create() method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Just as there are many ways to create objects in JavaScript, there are also
    many ways to replicate class-based, classical inheritance. But the one preferred
    way to do it is with the `Object.create()` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This syntax may seem unusual to many but, with a little practice, it will become
    familiar. The `prototype` keyword must be used to gain access to the internal
    property, `[[Prototype]]`, which all objects have. The `Object.create()` method
    declares a new object with a specified object for its prototype to inherit from.
    In this way, classical inheritance can be achieved in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `Object.create()` method was introduced in ECMAScript 5.1 in 2011, and it
    was billed as the new and preferred way to create objects. This was just one of
    many attempts to integrate inheritance into JavaScript. Thankfully, this method
    works pretty well.
  prefs: []
  type: TYPE_NORMAL
- en: We saw this structure of inheritance when building the `Maybe` classes in [Chapter
    5](part0032_split_000.html#page "Chapter 5. Category Theory"), *Category Theory*.
    Here are the `Maybe`, `None`, and `Just` classes, which inherit from each other
    just like the preceding example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This shows that class inheritance in JavaScript can be an enabler of functional
    programming.
  prefs: []
  type: TYPE_NORMAL
- en: A common mistake is to pass a constructor into `Object.create()` instead of
    a `prototype` object. This problem is compounded by the fact that an error will
    not be thrown until the subclass tries to use an inherited member function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The function won't be found if the `inheritedMethod()` method has been attached
    to the `Foo.prototype` class. If the `inheritedMethod()` method is attached directly
    to the instance with `this.inheritedMethod = function(){...}` in the `Bar` constructor,
    then this use of `Parent` as an argument of `Object.create()`could be correct.
  prefs: []
  type: TYPE_NORMAL
- en: Mixing functional and object-oriented programming in JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Object-oriented programming has been the dominant programming paradigm for
    several decades. It is taught in Computer Science 101 classes around the world,
    while functional programming is not. It is what software architects use to design
    applications, while functional programming is not. And it makes sense too: OOP
    makes it easy to conceptualize abstract ideas. It makes it easier to write code.'
  prefs: []
  type: TYPE_NORMAL
- en: So, unless you can convince your boss that the application needs to be all functional,
    we're going to be using functional programming in an object-oriented world. This
    section will explore ways to do this.
  prefs: []
  type: TYPE_NORMAL
- en: Functional inheritance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Perhaps the most accessible way to apply functional programming to JavaScript
    applications is to use a mostly functional style within OOP principles, such as
    inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: 'To explore how this might work, let''s build a simple application that calculates
    the price of a product. First, we''ll need some product classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then organize them within a `Store` class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `calculateTotal()` method uses the array's `reduce()` function to cleanly
    sum together the prices of the products.
  prefs: []
  type: TYPE_NORMAL
- en: This works just fine, but what if we need a dynamic way to calculate the markup
    value? For this, we can turn to a concept called **Strategy Pattern**.
  prefs: []
  type: TYPE_NORMAL
- en: Strategy Pattern
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Strategy Pattern is a method for defining a family of interchangeable algorithms.
    It is used by OOP programmers to manipulate behavior at runtime, but it is based
    on a few functional programming principles:'
  prefs: []
  type: TYPE_NORMAL
- en: Separation of logic and data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Composition of functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions as first-class objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And a couple of OOP principles as well:'
  prefs: []
  type: TYPE_NORMAL
- en: Encapsulation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inheritance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In our example application for calculating product cost, explained previously,
    let's say we want to give preferential treatment to certain customers, and that
    the markup will have to be adjusted to reflect this.
  prefs: []
  type: TYPE_NORMAL
- en: 'So let''s create some customer classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Each `Customer` class encapsulates the algorithm. Now we just need the `Store`
    class to call the `Customer` class's `calculateTotal()` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `Customer` classes do the calculating, the `Product` classes hold the data
    (the prices), and the `Store` class maintains the context. This achieves a very
    high level of cohesion and a very good mixture of object-oriented programming
    and functional programming. JavaScript's high level of expressiveness makes this
    possible and quite easy.
  prefs: []
  type: TYPE_NORMAL
- en: Mixins
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In a nutshell, mixins are classes that can allow other classes to use their
    methods. The methods are intended to be used solely by other classes, and the
    `mixin` class itself is never to be instantiated. This helps to avoid inheritance
    ambiguity. And they're a great means of mixing functional programming with object-oriented
    programming.
  prefs: []
  type: TYPE_NORMAL
- en: Mixins are implemented differently in each language. Thanks to JavaScript's
    flexibility and expressiveness, mixins are implemented as objects with only methods.
    While they can be defined as function objects (that is, `var mixin = function(){...};`),
    it would be better for the structural discipline of the code to define them as
    object literals (that is, `var mixin = {...};`). This will help us to distinguish
    between classes and mixins. After all, mixins should be treated as processes,
    not objects.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with declaring some mixins. We'll extend our `Store` application
    from the previous section, using mixins to expand on the classes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re not limited to just this. Many more mixins can be added, like colors
    or fabric material. We''ll have to rewrite our `Shirt` classes a little bit, as
    shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Now we're ready to use mixins.
  prefs: []
  type: TYPE_NORMAL
- en: Classical mixins
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You''re probably wondering just how these mixins get mixed with the classes.
    The classical way to do this is by copying the mixin''s functions into the receiving
    object. This can be done with the following extension to the `Shirt` prototype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'And now the mixins can be added as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: However, there is a major problem. When the price of `p1` is calculated again,
    it comes back as `15`, the price of a large item. It should be the value for a
    small one!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The problem is that the `Shirt` object's `prototype.getPrice()` method is getting
    rewritten every time a mixin is added to it; this is not very functional at all
    and not what we want.
  prefs: []
  type: TYPE_NORMAL
- en: Functional mixins
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There's another way to use mixins, one that is more aligned with functional
    programming.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of copying the methods of the mixin to the target object, we need to
    create a new object that is a clone of the target object with the mixin's methods
    added in. The object must be cloned first, and this is achieved by creating a
    new object that inherits from it. We'll call this variation `plusMixin`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Here comes the fun part! Now we can get really functional with the mixins. We
    can create every possible combination of products and mixins.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: To make it more object-oriented, we can rewrite the `Store` object with this
    functionality. We'll also add a display function to the `Store` object, not the
    products, to keep the interface logic and the data separated.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: And all we have to do is create a `Store` object and call its `displayProducts()`
    method to generate a list of products and prices!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'These lines need to be added to the `product` classes and mixins to get the
    preceding output to work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: And, just like that, we have an e-commerce application that is highly modular
    and extendable. New shirt styles can be added absurdly easily—just define a new
    `Shirt` subclass and add to it the `Store` class's array `product` classes. Mixins
    are added in just the same way. So now when our boss says, "Hey, we have a new
    type of shirt and a coat, each available in the standard colors, and we need them
    added to the website before you go home today", we can rest assured that we'll
    not be staying late!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JavaScript has a high level of expressiveness. This makes it possible to mix
    functional and object-oriented programming. Modern JavaScript is not solely OOP
    or functional—it is a mixture of the two. Concepts such as Strategy Pattern and
    mixins are perfect for JavaScript's prototype structure, and they help to prove
    that today's best practices in JavaScript share equal amounts of functional programming
    and object-oriented programming.
  prefs: []
  type: TYPE_NORMAL
- en: If you were to take away only one thing from this book, I would want it to be
    how to apply functional programming techniques to real-world applications. And
    this chapter showed you how to do exactly that.
  prefs: []
  type: TYPE_NORMAL
- en: Appendix A. Common Functions for Functional Programming in JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This Appendix covers common functions for functional programming in JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Array Functions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Binding Functions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Category Theory:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Composition:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Currying:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Functors:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Lenses:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Maybes:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Mixins:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Partial Application:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Trampolining:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Type Safeties:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Y-combinator:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Appendix B. Glossary of Terms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This appendix covers some of the important terms that are used in this book:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Anonymous function**: A function that has no name and is not bound to any
    variables. It is also known as a Lambda Expression.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Callback**: A function that can be passed to another function to be used
    in a later event.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Category**: In terms of Category Theory, a category is a collection of objects
    of the same type. In JavaScript, a category can be an array or object that contains
    objects that are all explicitly declared as numbers, strings, Booleans, dates,
    objects, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Category Theory**: A concept that organizes mathematical structures into
    collections of objects and operations on those objects. The data types and functions
    used in computer programs form the categories used in this book.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Closure**: An environment such that functions defined within it can access
    local variables that are not available outside it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Coupling**: The degree to which each program module relies on each of the
    other modules. Functional programming reduces the amount of coupling within a
    program.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Currying**: The process of transforming a function with many arguments into
    a function with one argument that returns another function that can take more
    arguments, as needed. Formally, a function with *N* arguments can be transformed
    into a function chain of *N* functions, each with only one argument.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Declarative programming**: A programming style that expresses the computational
    logic required to solve the problem. The computer is told what the problem is
    rather than the procedure required to solve it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Endofunctor**: A functor that maps a category to itself.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Function composition**: The process of combining many functions into one
    function. The result of each function is passed as an argument to the next, and
    the result of the last function is the result of the whole composition.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Functional language**: A computer language that facilitates functional programming.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Functional programming**: A declarative programming paradigm that focuses
    on treating functions as mathematical expressions and avoids mutable data and
    changes in state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Functional reactive programming**: A style of functional programming that
    focuses on reactive elements and variables that change over time in response to
    events.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Functor**: A mapping between categories.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Higher-order function**: A function that takes either one or more functions
    as input, and returns a function as its output.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Inheritance**: An object-oriented programming capability that allows one
    class to inherit member variables and methods from another class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lambda expressions**: See Anonymous function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lazy evaluation**: A computer language evaluation strategy that delays the
    evaluation of an expression until its value is needed. The opposite of this strategy
    is called eager evaluation or greedy evaluation. Lazy evaluation is also known
    as call by need.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Library**: A set of objects and functions that have a well-defined interface
    that allows a third-party program to invoke their behavior.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Memoization**: The technique of storing the results of expensive function
    calls. When the function is called later with the same arguments, the stored result
    is returned rather than computing the result again.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Method chain**: A pattern in which many methods are invoked side by side
    by directly passing the output of one method to the input of the next. This avoids
    the need to assign the intermediary values to temporary variables.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mixin**: An object that can allow other objects to use its methods. The methods
    are intended to be used solely by other objects, and the mixin object itself is
    never to be instantiated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Modularity**: The degree to which a program can be broken down into independent
    modules of code. Functional programming increases the modularity of programs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Monad**: A structure that provides the encapsulation required by functors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Morphism**: A pure function that only works on a certain category and always
    returns the same output when given a specific set of inputs. Homomorphic operations
    are restricted to a single category, while polymorphic operations can operate
    on multiple categories.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Partial application**: The process of binding values to one or more arguments
    of a function. It returns a partially applied function, which in turn accepts
    the remaining, unbound arguments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Polyfill**: A function used to augment prototypes with new functions. It
    allows us to call our new functions as methods of the previous function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pure function**: A function whose output value depends only on the arguments
    that are the input to the function. Thus, calling a function, *f*, twice with
    the same value of an argument, *x*, will produce the same result, *f(x)*,every
    time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Recursive function**: A function that calls itself. Such functions depend
    on solutions to smaller instances of the same problem to compute the solution
    to the larger problem. Like iteration, recursion is another way to repeatedly
    call the same block of code. But, unlike iteration, recursion requires that the
    code block define the case in which the repeating code calls should terminate,
    known as the base case.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reusability**: The degree to which a block of code, usually a function in
    JavaScript, can be reused in other parts of the same program or in other programs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Self-invoking function**: An anonymous function that is invoked immediately
    after it has been defined. In JavaScript, this is achieved by placing a pair of
    parentheses after the function expression.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Strategy pattern**: A method used to define a family of interchangeable algorithms.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tail recursion**: A stack-based implementation of recursion. For every recursive
    call, there is a new frame in the stack.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Toolkit**: A small software library that provides a set of functions for
    the programmer to use. Compared to a library, a toolkit is simpler and requires
    less coupling with the program that invokes it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Trampolining**: A strategy for recursion that provides tail-call elimination
    in programming languages that do not provide this feature, such as JavaScript.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Y-combinator**: A fixed-point combinator in Lambda calculus that eliminates
    explicit recursion. When it is given as input to a function that returns a recursive
    function, the Y-combinator returns the fixed point of that function, which is
    the transformation from the recursive function to a non-recursive function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
