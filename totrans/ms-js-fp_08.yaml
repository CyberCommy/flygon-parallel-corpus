- en: Connecting Functions - Pipelining and Composition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 7](44b5eafa-dc7f-45e4-8b9e-9bb5bb9b02ec.xhtml), *Transforming Functions
    - Currying and Partial Application*, we saw several different ways to build new
    functions by applying higher-order functions. In this chapter, we will go to the
    core of FP and see how to create sequences of function calls, so their combination
    will produce a more complex result out of several simpler components. We will
    include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Pipelining**, a way to join functions together in similar way to Unix/Linux
    pipes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Chaining***,* which may be considered a variant of pipelining, but restricted
    to objects'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Composing**, which is a classic operation with its origins in basic computer
    theory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Along the way, we will be touching on related concepts, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Pointfree style**, which is often used with pipelining and composition'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging of composed or piped functions, for which we'll whip up some auxiliary
    tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing of composed or piped functions, which won't prove to be of high complexity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pipelining
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Pipelining and composition are techniques for setting up functions to work
    in sequence, so the output from a function becomes the input to the next function.
    There are two ways of looking at this: from a computer point of view and from
    a mathematical point of view. Usually, most FP texts start with the latter, but
    since I assume that most readers are closer to computers than to math, let''s
    start with the former.'
  prefs: []
  type: TYPE_NORMAL
- en: Piping in Unix/Linux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Unix/Linux, the execution of a command and passing its output as an input
    to a second command, whose output will yet the input of a third command, and so
    on, is called a *pipeline*. This is quite common, and an application of the philosophy
    of Unix, as explained in a Bell Laboratories article, written by the creator of
    the pipelining concept himself, Doug McIlroy:'
  prefs: []
  type: TYPE_NORMAL
- en: Make each program do one thing well. To do a new job, build afresh rather than
    complicating old programs by adding new *features*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Expect the output of every program to become the input to another, as yet unknown,
    program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Given the historical importance of Unix, I'd recommend reading some of the seminal
    articles describing the (then new) operating system, in the *Bell System Technical
    Journal*, July 1978, at [http://emulator.pdp-11.org.ru/misc/1978.07_-_Bell_System_Technical_Journal.pdf](http://emulator.pdp-11.org.ru/misc/1978.07_-_Bell_System_Technical_Journal.pdf).
    The two quoted rules are in the *Style* section, in the *Foreword* article.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider a simple example to get started. Suppose I want to know how
    many LibreOffice text documents there are in a directory. There are many ways
    to do this, but this will do. We will execute three commands, piping (that''s
    the meaning of the `|` character) each command''s output as input to the next
    one. Suppose we `cd /home/fkereki/Documents` and then do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'What does this mean? How does it work? (Ignore the dollar sign: it''s just
    the console prompt.) We have to analyze the process step by step:'
  prefs: []
  type: TYPE_NORMAL
- en: The first part of the pipeline, `ls -1`, lists all the files in the directory
    (`/home/fkereki/Documents`, as per our `cd` command), in a single column, one
    file name per line
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The output from the first command is provided as input to `grep "odt$"`, which
    filters (lets pass) only those lines that finish with `"odt"`, the standard file
    extension for LibreOffice Writer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The filtered output is provided to the counting command, `wc -l`, which counts
    how many lines there are in its input
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can find pipelines in Section 6.2, *Filters*, of the *UNIX Time-Sharing
    System* article by Dennis Ritchie and Ken Thompson, also in the issue of the Bell
    Laboratories journal that I mentioned above.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the point of view of FP, this is a key concept. We want to build up more
    complex operations out of simple, single-purpose, shorter functions. Pipelining
    is the way the Unix shell uses to apply that concept, simplifying the job of executing
    a command, taking its output, and providing it as an input to yet another command.
    We will be applying similar concepts in our own functional style in JS, as we''ll
    see; check out Figure 8.1:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/bedb088b-2623-4076-b6ad-b5aab8b78d93.jpg)Figure 8.1\. Pipelines
    in JS are similar to Unix/Linux pipelines. The output of each function becomes
    the input for the next.'
  prefs: []
  type: TYPE_NORMAL
- en: By the way (and, no, rest assured, this isn't turning into a shell tutorial!)
    you can also make pipelines to accept parameters. For example, if I happened to
    often desire to count how many files I had with this or that extension, I could
    create a function such as `cfe`, standing for *count for extension:*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'I could then use `cfe` as a command, giving it the desired extension as an
    argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We will also want to write similar parametric pipelines: we are not constrained
    to only have fixed functions in our flow, but rather have full liberty as to what
    we want to include.'
  prefs: []
  type: TYPE_NORMAL
- en: Revisiting an example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can start tying ends together by revisiting a problem from earlier chapters.
    Remember having to calculate the average latitude and longitude for some geographic
    data, which we saw in the *Extracting data from objects* section of [Chapter 5](3cf24154-32aa-4bcd-bfbe-e9de8fe35096.xhtml),
    *Programming Declaratively - A Better Style*? Basically, we started with some
    data like the following and the problem was to calculate the average latitude
    and longitude of the given points:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'With what we now know, we can write a solution in terms of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Being able to extract the latitude (and, afterward, the longitude) from each
    point
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using that function to create an array of latitudes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pipelining the resulting array to the average function we wrote in the *Calculating
    an average* section, of the aforementioned chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To do the first task, we can use the `myMap()` function from the *Parameters
    order* section, of [Chapter 7](44b5eafa-dc7f-45e4-8b9e-9bb5bb9b02ec.xhtml), *Transforming
    Functions - Currying and Partial Application*, plus the `getField()` function
    from the *Getting a property from an object* section of [Chapter 6](9f36fbcb-da30-4a75-9b47-01cd3427633e.xhtml),
    *Producing Functions - Higher-Order Functions*, plus a bit of currying to fix
    some values. Written out in long, our solution could be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, you can always yield to the temptation of going for a couple of
    *one-liners*, but mind: is it really clearer, better?'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Whether this makes sense to you will depend on your experience with FP. In any
    case, no matter which solution you take, the fact remains that adding pipelining
    (and later on, composition) to your set of tools can help you write tighter, declarative,
    simpler to understand code, so let's now turn to seeing how we can pipeline functions
    in the right way.
  prefs: []
  type: TYPE_NORMAL
- en: Creating pipelines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We want to be able to generate a pipeline of several functions. We can go at
    this in two different ways: by building the pipeline *by hand*, in a problem-specific
    way, or by seeking to use more generic constructs, that can be applied with generality.
    Let''s see both types of solution.'
  prefs: []
  type: TYPE_NORMAL
- en: Building pipelines by hand
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s go with a Node.js example, similar to the command-line pipeline we built
    earlier in this chapter. We need a function to read all files in a directory and
    we can do that (in a not very recommendable way, because of the synchronous call,
    normally not good in a server environment) with something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Filtering the `odt` files is quite simple. We start with the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'So, we can now write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Better still, we can applying currying, and go for pointfree style, as seen
    in the *An unnecessary mistake* section of [Chapter 3](89a2ff2f-a67d-4a21-a2f5-cd54bed7198a.xhtml),
    *Starting Out with Functions - A Core Concept*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, to count elements in an array, we can simply write the following code.
    Since `.length` is not a function, we cannot apply our demethodizing trick:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'With these functions available, we could write something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If you wanted to get rid of all the intermediate variables, you could also
    go for a *one-liner* definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This gets to the crux of the matter: both implementations of our file-counting
    function have disadvantages. The first definition uses several intermediate variables
    to hold results and makes a multiline function out of what was a single line of
    code in the Linux shell. The second, much shorter, definition, on the other hand,
    is quite harder to understand, insofar as we are writing the steps of the computation
    in seemingly reverse order! Our pipeline has to read files first, then filter
    them, and finally count -- but those functions appear *the other way round* in
    our definition!'
  prefs: []
  type: TYPE_NORMAL
- en: We certainly can implement pipelining by hand, as we have seen, but it will
    be better if we can go for a more declarative style. Let's then move on to try
    to build a better pipeline in a more clear and understandable way, trying to apply
    some of the concepts we have already seen.
  prefs: []
  type: TYPE_NORMAL
- en: Using other constructs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If we think in functional terms, what we have is a list of functions and we
    want to apply them sequentially, starting with the first, then applying the second
    to whatever the first function produced as its result, and then applying the third
    to the second function''s results, and so on. If we were just fixing a pipeline
    of two functions, this could do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This is not so useless as it may seem because we can compose longer pipelines
    -- though, I''ll admit, it requires too much writing! We can write our three functions''
    pipeline in two different, equivalent ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We are taking advantage of the fact that piping is an associative operation.
    In mathematics, the associative property is the one that says that we can compute
    *1+2+3* either by adding *1+2* first and then adding that result to 3, or by adding
    1 to the result of adding *2+3*: in other terms, *1+2+3* is the same as *(1+2)+3*
    or *1+(2+3)*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'How does this work? Following in detail the execution of a given call will
    be useful; it''s quite easy to get confused with so many calls! The first implementation
    can be followed step by step, until the final result that fortunately matches
    what we already knew:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The second implementation also comes to the same final result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'OK, so we now know that we can make do with just a basic *pipe of two* higher-order
    function... but we''d really like to be able to work in a shorter, more compact
    way. A first implementation could be along the lines of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This does work -- and the way of specifying our file-counting pipeline is much
    clearer since now the functions are given in their proper order. However, the
    implementation itself of the `pipeline()` function is not very functional and
    rather goes back to old, imperative, loop by hand methods. We can do better using
    `.reduce()`, as in [Chapter 5](3cf24154-32aa-4bcd-bfbe-e9de8fe35096.xhtml), *Programming
    Declaratively - A Better Style*.
  prefs: []
  type: TYPE_NORMAL
- en: If you check some FP libraries, the function that we are here calling `pipeline()`
    may also be known as `flow()` - because data flows from the left to the right-or
    `sequence()` - alluding to the fact that operations are performed in ascending
    sequence - but the semantics are the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'The idea is to start evaluation with the first function, pass the result to
    the second, then that result to the third, and so on. We can then achieve our
    pipelining with shorter code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This code is more declarative, and you could have even gone one better by writing
    it using our `pipeTwo()` function, which does the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: You can understand this code also by realizing that, basically, it uses the
    associative property that we mentioned, and it first pipes the first function
    to the second; then, it pipes the result of this to the third function, and so
    on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Which version is better? I would say that the version that refers to the `pipeTwo()`
    function is clearer: if you know how `.reduce()` works, you can readily understand
    that our pipeline goes through the functions two at a time, starting from the
    first -- and that matches what you know about how pipes work. The other versions
    that we wrote are more or less declarative, but possibly not so simple to understand.'
  prefs: []
  type: TYPE_NORMAL
- en: Debugging pipelines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s turn to a practical question: how do you debug your code? With
    pipelining, you cannot really see what''s passing on from function to function,
    so how do you do it? We have two answers for that: one (also) comes from the Unix/Linux
    world and the other (most appropriately for this book) uses wrappers to provide
    some logs.'
  prefs: []
  type: TYPE_NORMAL
- en: Using tee
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first solution we''ll use implies adding a function to the pipeline, which
    will just log its input. We want to implement something similar to the `tee` Linux
    command, which can intercept the standard data flow in a pipeline and send a copy
    to an alternate file or device. Remembering that `/dev/tty` is the usual console,
    we may execute something as follows and get an onscreen copy of everything that
    passes through the `tee` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We could write a similar function with ease:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: If you are aware of the uses of the comma operator, you can be quite more concise,
    and just write `const tee = (arg) => (console.log(arg), arg)` -- do you see why?
    Check [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comma_Operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comma_Operator)
    for the answer!
  prefs: []
  type: TYPE_NORMAL
- en: 'Our logging function will receive a single argument, list it, and pass it on
    to the next function in the pipe. We can see it working:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We could do even better if our `tee()` function could receive a logger function
    as a parameter, as we did in the *Logging in a functional way* section of [Chapter
    6](9f36fbcb-da30-4a75-9b47-01cd3427633e.xhtml), *Producing Functions - Higher-Order
    Functions*; it's just a matter of doing the same kind of change we managed there.
    The same good design concepts are applied again!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Be aware that there might be a binding problem when passing `console.log` in
    that way. It would be safer to write `console.log.bind(console)`, just as a precaution.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, this would just be a particular enhancement: let''s now consider an
    even more generic tapping function, with more possibilities than just doing a
    bit of logging.'
  prefs: []
  type: TYPE_NORMAL
- en: Tapping into a flow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you wish, you could write an enhanced `tee()` function that could produce
    more debugging information, possibly send the reported data to a file or remote
    service, and so on--there are many possibilities you can explore. You could also
    explore a more general solution, of which `tee()` would just be a particular case
    and which would also allow creating personalized tapping functions. See Figure
    8.2:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/b07f36e2-f002-4d72-ae32-abf179920530.jpg)Figure 8.2\. Tapping allows
    you to apply some function to inspect data as it flows through the pipeline.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When working with pipelines, you might want to put a logging function in the
    middle of it, or you might want some other kind of *snooping* function -- possibly
    storing data somewhere, or calling a service, or some other kind of side effect.
    We could have a generic `tap()` function, which would behave in this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This is probably a candidate for a *trickiest-looking-code-in-the-book* award,
    so let''s explain it. We want to produce a function, that given a function `fn()`
    and an argument `x`, will evaluate `fn(x)` (to produce whatever sort of side of
    effect we may be interested in) but return `x` (so the pipeline goes on without
    interference). The comma operator has exactly that behavior: if you write code
    like `(a, b, c)`, JS will evaluate the three expressions in order and will use
    the last value as the expression''s value.'
  prefs: []
  type: TYPE_NORMAL
- en: The comma has several uses in JS and you can read more about its usage as an
    operator at [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comma_Operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comma_Operator).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now take advantage of currying to produce several different tapping
    functions. The one we wrote in the previous section, `tee()`, could also be written
    in the following fashion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: By the way, you could have also written `tap()` without currying... but you'll
    admit it loses something of its mystery!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: You'll recognize this way of currying as we saw it in the *Currying by hand*
    section of [Chapter 7](44b5eafa-dc7f-45e4-8b9e-9bb5bb9b02ec.xhtml), *Transforming
    Functions - Currying and Partial Application*.
  prefs: []
  type: TYPE_NORMAL
- en: Using a logging wrapper
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The second idea we mentioned is based on the `addLogging()` function that we
    wrote in the *Logging* section of [Chapter 6](9f36fbcb-da30-4a75-9b47-01cd3427633e.xhtml),
    *Producing Functions - Higher-Order Functions*. The idea was to wrap a function
    with some logging functionality so that on entry, the arguments would be printed
    and on exit, the result of the function would be shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We can trivially verify that the `pipeline()` function is doing its thing correctly
    -- whatever a function produces as a result is given as input to the next function
    in the line and we can also understand what''s happening with each call. Of course,
    you need not add logging to *every* function in the pipeline: you would probably
    do in the places where you suspected an error was occurring.'
  prefs: []
  type: TYPE_NORMAL
- en: Chaining and fluent interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you work with objects or arrays, there is another way of linking the execution
    of several calls together, by applying *chaining*. For example, when you work
    with arrays, if you apply a `.map()` or `.filter()` method, the result is a new
    array, to which you can apply a new further method, and so forth. We have already
    used such methods, as when we defined the `range()` function back in the *Working
    with ranges* section of [Chapter 5](3cf24154-32aa-4bcd-bfbe-e9de8fe35096.xhtml),
    *Programming Declaratively - A* B*etter* S*tyle*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: First, we created a new array; then, we applied the `.fill()` method to it,
    which updated the array in place (side effect...) and returned the updated array,
    to which we finally applied a `.map()` method. The latter method did generate
    a new array, to which we could have applied further mappings, filtering, or any
    other available method.
  prefs: []
  type: TYPE_NORMAL
- en: 'This style of continuous chained operation is also used in fluent APIs or interfaces.
    To give just one example, the graphic `D3.js` library (see [https://d3js.org/](https://d3js.org/)
    for more on it) frequently uses this style -- and the following example, taken
    from [https://bl.ocks.org/mbostock/4063269](https://bl.ocks.org/mbostock/4063269)
    shows it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Each method works on the previous object and either provides access to a new
    object to which future method calls will apply (such as the `.selectAll()` or
    `.append()` methods) or updates the current one (as with the `.attr()` attribute
    setting calls). This style is not unique and several other well-known libraries
    (jQuery comes to mind, just to start) also apply it.
  prefs: []
  type: TYPE_NORMAL
- en: Can we automate this? In this case, the answer is *possibly, but I'd rather
    not*. In my opinion, using `pipeline()` or `compose()` is just as well, and manages
    the same result. With object chaining, you are limited to returning new objects
    or arrays or something to which methods can be applied. (Remember, if you are
    working with standard types, such as strings or numbers, you cannot add methods
    to them unless you mess with their prototype, which isn't recommended!) With composition,
    however, you can return any kind of value; the only restriction is that the next
    function in line must be expecting the data type that you are providing.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, if you are writing your own API, then you can provide a
    fluent interface by just having each method `return this` -- unless, of course,
    it needs to return something else! If you were working with some other people''s
    API, you could also do some trickery by using a proxy, but be aware there could
    be cases in which your proxied code might fail: maybe another proxy is being used,
    or there are some getters or setters that somehow cause problems, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: You may want to read up on proxy objects at [https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Proxy](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Proxy)
    -- they are very powerful and allow for interesting metaprogramming functionalities,
    but they can also trap you with technicalities and they will also cause an (albeit
    slight) slowdown in your proxied code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go for a basic example. We could have a `City` class, with name, latitude
    (`lat`) and longitude (`long`) attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We could use this class as follows, with details for my native city, Montevideo,
    Uruguay:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'If we wanted to allow a fluent handling of the setters, we could set up a proxy
    to detect such calls and provide the missing `return this`. How can we do that?
    If the original method doesn''t return anything, JS will include by default a
    `return undefined` statement, so we can detect whether that''s what the method
    is returning and substitute `return this` instead. Of course, this is a problem:
    what would we do if we had a method that could legally return an `undefined` value
    on its own, because of its semantics? We could have some kind of *exceptions list*,
    to tell our proxy not to add anything in those cases, but let''s not get into
    that.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for our handler is as follows. Whenever a method of an object is invoked,
    a get is implicitly called and we catch it. If we are getting a function, then
    we wrap it with some code of our own, that will call the original method and then
    decide whether to return its value or a reference to the proxied object instead.
    If we weren''t getting a function, then we directly return the requested property''s
    value. Our `chainify()` function will take care of assigning the handler to an
    object and creating the needed proxy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'With this, we can *chainify* any object, so we''ll get a chance to inspect
    any called methods. As I''m writing this, I''m currently living in Pune, India,
    so let''s reflect that change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice the following:'
  prefs: []
  type: TYPE_NORMAL
- en: We changed `myCity` to be a proxified version of itself
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are calling several setters in fluent fashion and they are working fine since
    our proxy is taking care of providing the need this value for the following call
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The calls to `.getCoords()` and `.getName()` are intercepted, but nothing special
    is done, because they already return a value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is this worth it? That's up to you -- but remember my comment that there may
    be cases in which this approach fails, so be wary!
  prefs: []
  type: TYPE_NORMAL
- en: Pointfree style
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you join functions together, either in pipeline fashion as here, or with
    composition as we''ll be seeing later in this chapter, you don''t need any intermediate
    variables to hold the results that will become arguments to the next function
    in line: they are implicit. Similarly, you can write functions without mentioning
    their parameters, and this is called pointfree style.'
  prefs: []
  type: TYPE_NORMAL
- en: Pointfree style is also called tacit programming -- and pointless programming
    by detractors! The term *point* itself means a function parameter and pointfree
    refers to not naming those parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Defining pointfree functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can easily recognize a pointfree function definition because it doesn''t
    need either the `function` keyword or the `=>` symbol. We can revisit some of
    the previous functions we wrote in this chapter and check that out. For example,
    the definition of our original file-counting functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code could be rewritten as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The new definitions do not make reference to the parameter for the newly defined
    functions. You can deduce it by examining the first function in the pipeline (`getDir()`,
    in this case) and seeing what it receives as arguments. (Using type signatures
    as we''ll see in [Chapter 12](0d82d215-9bfc-436b-b09d-8ed2e2ebd441.xhtml), *Building
    Better Containers - Functional Data Types*, would be a good help in terms of documentation.)
    Similarly, the definition for `getLat()` is pointfree:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'What should be the equivalent full style definition? You''d have to examine
    the `getField()` function (we just saw it in the *Revisiting an example* section),
    to decide that it expects an object as an argument. However, making that need
    explicit by writing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'This wouldn''t make much sense: if you were willing to write all this, you
    might simply stick with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Then you could simply not care about currying or anything like it!
  prefs: []
  type: TYPE_NORMAL
- en: Converting to pointfree style
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'On the other hand, you had better pause a bit, and not try to write *everything*
    in pointfree code, whatever it might cost. For example, consider the `isNegativeBalance()`
    function we wrote back in [Chapter 6](9f36fbcb-da30-4a75-9b47-01cd3427633e.xhtml),
    *Producing Functions - Higher-Order Functions*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Can we write this in pointfree style? Yes, we can, and we''ll see how -- but
    I''m not sure we''d want to code this way! We can consider building a pipeline
    of two functions: one will extract the balance from the given object and the next
    will check whether it''s negative, so we will write our alternative version of
    the balance-checking function in a fashion like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'To extract the balance attribute from a given object, we can use `getField()`
    and a bit of currying, and then write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'For the second function, we could write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'There goes our pointfree goal! Instead, we can use the `binaryOp()` function,
    also from the same earlier cited chapter, plus some more currying, to write the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: I wrote the test the other way around (*0>x* instead of *x<0*) just for ease
    of coding. An alternative would have been using the enhanced functions I mentioned
    in the *A handier implementation* section of the same chapter -- a bit less complex!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'So, finally, we could write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we could write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Do you really think that's an advance? Our new versions of `isNegativeBalance()`
    don't make a reference to their argument and are fully pointfree, but the idea
    of using pointfree style should be to help improve the clarity and readability
    of your code, and not to produce obfuscation and opaqueness! I doubt anybody would
    look at our new versions of the function and consider them to be an advantage
    over the original, for any possible reason.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you find that your code is becoming harder to understand, and that''s only
    due to your intent on using poin-free programming, stop and roll back your changes.
    Remember our doctrine for the book: we want to do FP, but we don''t want to go
    overboard with it -- and using pointfree style is not a requirement!'
  prefs: []
  type: TYPE_NORMAL
- en: Composing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Composing* is quite similar to pipelining, but has its roots in mathematical
    theory. The concept of composition is simple - a sequence of function calls, in
    which the output of one function is the input for the next one - but the order
    is reversed from the one in pipelining. In the latter, the first function to be
    applied is the leftmost one, but in composition, you start with the rightmost
    one. Let''s investigate this a bit more.'
  prefs: []
  type: TYPE_NORMAL
- en: When you define the composition of, say, three functions, as (*f∘* *g∘* *h*)
    and apply it to *x*, this is equivalent to what you would write as *f*(*g*(*h*(*x*))).
    It's important to note that, as with pipelining, the arity of the first function
    to be applied can be anything, but all the other functions must be unary. Also,
    apart from the difference as to the sequence of function evaluations, composing
    is an important tool in FP, because it also abstracts implementation details (putting
    your focus on what you need to accomplish, rather than on the specific details
    for achieving that) thus letting you work in a more declarative fashion.
  prefs: []
  type: TYPE_NORMAL
- en: If it helps, you can read (*f∘* *g∘* *h*) as *f after g after h*, so it becomes
    clear that *h* is the first function to be applied, and *f* is the last.
  prefs: []
  type: TYPE_NORMAL
- en: Given the similarity to pipelining, it will be no surprise that implementing
    composition won't be very hard. However, there will still be some important and
    interesting details.
  prefs: []
  type: TYPE_NORMAL
- en: Some examples of composition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It may not be a surprise to you, but we have already seen several examples of
    composition -- or, at the very least, cases in which the solutions we achieved
    were functionally equivalent to using composition. Let's review some of these,
    and also work with some new examples.
  prefs: []
  type: TYPE_NORMAL
- en: Unary operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the *Logically negating a function* section of [Chapter 6](9f36fbcb-da30-4a75-9b47-01cd3427633e.xhtml),
    *Producing Functions - Higher-Order Functions*, we wrote a `not()` function that,
    given another function, would logically invert its result. We used that function
    in order to negate a check for negative balances; sample code could be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'In another section of that very same chapter, *Turning operations into functions*,
    I left you the challenge of writing a `unaryOp()` function that would provide
    unary functions equivalent to common JS operators. So, if you are able to write
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, assuming the existence of a `compose()` function, you could have also
    written the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Which one do you prefer? It's a matter of taste, really -- but I think the second
    version makes it clearer what we are trying to do. With the `not()` function,
    you have to check what it does in order to understand the general code. With composition,
    you still need to know what `logicalNot()` is, but the global construct is open
    to see.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see just one more example in the same vein, you could have managed to get
    the same results as in the *Inverting results* section, in the same chapter. Remember,
    we had a function that could compare strings according to the Spanish language
    rules, but we wanted to invert the sense of the comparison, to sort in descending
    order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Counting files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can also go back to our pipeline. We had written a single-line function
    to count the `odt` files in a given path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Disregarding (at least for the moment) the observation that this code is not
    so clear as the pipeline version that we got to develop later, we could have also
    written this function with composition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: We could have also written the function in pointfree fashion, without specifying
    the `path` parameter, with `const countOdtFiles2 = compose(count, filterOdt, getDir)`
    but I wanted to better parallel the previous definition.
  prefs: []
  type: TYPE_NORMAL
- en: 'It would also be possible to see this written in *one-liner* fashion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Even if it's not so clear as the pipeline version (and that's just my opinion,
    which may be biased by my liking of Linux!), this declarative implementation makes
    it clear that we depend on combining three distinct functions to get our result
    -- that's easy to see, and applies the idea of building large solutions out of
    simpler pieces of code.
  prefs: []
  type: TYPE_NORMAL
- en: Finding unique words
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Finally, let''s go for another example, which, I agree, could also have been
    used for pipelining. Suppose you have a text, and you want to extract all unique
    words from it: how would you go about it? If you think about it in steps (instead
    of trying to create a full solution in a single bit step) you would probably come
    up with a solution similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: Ignore all non-alphabetic characters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Put everything in uppercase
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Split the text into words
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a set of words
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why a set? Because it automatically discards repeated values; check out [https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Set](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Set)
    for more on this. By the way, we will be using the `Array.from()` method to produce
    an array out of our set; see [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, in FP way, let''s solve each problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'With these functions, the result can be written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Since you don't get to see the arguments to any of the composed functions, you
    really don't need to show the parameter for `getUniqueWords()` either, and so
    pointfree style is a natural in this case.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can test our function out; let''s apply this function to the first two sentences
    of Abraham Lincoln''s address at Gettysburg, from November 19, 1863, and print
    out the 43 different words (trust me, I counted them!) they comprised:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Of course, you might have written `getUniqueWords()` in possibly shorter ways,
    but the point I'm making is that by composing your solution out of several shorter
    steps, your code is clearer and easier to grasp. However, if you wish to say that
    a pipelined solution seems better, then it's just a matter of opinion!
  prefs: []
  type: TYPE_NORMAL
- en: Composing with higher order functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s pretty obvious that composing by hand could easily be done in a similar
    fashion as we saw above with pipelining. For example, the unique word counting
    function that we wrote a couple of sections earlier, could be written in simple
    JS style:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, it could be written more concisely (and more obscurely!) in
    *one-liner* style:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: However, as with pipelining, let's go look for a more general solution, that
    won't require writing a special function each time we want to compose some other
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Composing two functions is quite easy, and requires just a small change with
    regard to our `pipeTwo()` function, which we saw earlier in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The only difference is that, with piping, you apply the leftmost function first,
    and with composing, you start with the rightmost one. This variation suggests
    we could have used the `flipTwo()` higher-order function from the *Parameters
    order* section of [Chapter 7](44b5eafa-dc7f-45e4-8b9e-9bb5bb9b02ec.xhtml), *Transforming
    Functions - Currying and Partial Application.* Is it clearer?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'In any case, if we wanted to compose more than two functions, we could have
    also taken advantage of the associative property, to write something like the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Even though this works, let's go for a better solution -- and we can provide
    at least two. The first way has to do with the fact that pipelining and composing
    work *in reverse* of each other. We apply functions from left to right when pipelining
    and from right to left when composing. Thus, we can achieve the same result as
    with composition, by reversing the order of functions and doing pipelining instead;
    a very functional solution, which I really like!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: The only tricky part is the usage of the spread operator before calling `pipeline()`.
    After reversing the `fns` array, we must once again spread its elements, to correctly
    call `pipeline()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other solution, less declarative, is by using `.reduceRight()` so instead
    of reversing the list of functions, we reverse the order of processing them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Why/how does this work? Let''s follow the inner working of this call. We can
    replace `pipeTwo()` with its definition, to make this clearer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: OK, let's see!
  prefs: []
  type: TYPE_NORMAL
- en: Since no initial value is provided, the first time `f()` is `removeNonAlpha()`
    and `g()` is `toUpperCase()`, so the first intermediate result is a function `(...args)
    => toUpperCase(removeNonAlpha(...args))`; let's call it `step1()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second time, `f()` is `step1()` from the previous step, and `g()` is `splitInWords()`,
    so the new result is a function `(...args) => splitInWords(step1(...args)))`,
    which we can call `step2()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third time around, in the same fashion, we get `(...args) => arrayToSet(step2(...args))))`,
    which we call `step3()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, the last time, the result is `(...args) => setToList(step3(...args))`,
    a function `step4()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The final result correctly works out to be a function that receives `(...args)`,
    and starts by applying `removeNonAlpha()` to it, then `toUpperCase()`, and so
    on, finishing by applying `setToList()`.
  prefs: []
  type: TYPE_NORMAL
- en: It may be a surprise that we can also make this work with `.reduce()` -- can
    you see why? The reasoning is similar to what we did, so we'll let it be *an exercise
    for the reader*!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: After working out how `compose3()` works, you might want to write a version
    of `pipeline()` that uses `.reduceRight()`, just for symmetry, to round things
    out!
  prefs: []
  type: TYPE_NORMAL
- en: We can end this section by mentioning that in terms of testing and debugging,
    we can apply the same ideas as for debugging; only remember that composition *goes
    the other way*! We won't gain anything by providing yet more examples of the same
    kind, so let's consider now a common way of chaining operations when using objects
    and see if it's advantageous or not, given our growing FP knowledge and experience.
  prefs: []
  type: TYPE_NORMAL
- en: Testing composed functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's finish this chapter by giving some consideration to testing for pipelined
    or composed functions. Given that the mechanism for both operations is similar,
    we will give examples for both of them and they won't differ, other than the logical
    differences due to the left-to-right or right-to-left order of function evaluation.
  prefs: []
  type: TYPE_NORMAL
- en: 'When it comes to pipelining, we can start by seeing how to test the `pipeTwo()`
    function, because the setup will be similar for `pipeline()`. We need to create
    some spies and then check whether they were called the right number of times and
    whether they received the correct arguments each time. We will set the spies so
    they will provide a known answer to a call, so we can see if the output of a function
    becomes the input of the next in the pipeline:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: There isn't much to test, given that our function always receives two functions
    as parameters. The only difference between tests is that one shows a pipeline
    applied to a single argument and the other shows application to several arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving on to `pipeline()`, tests would be quite similar. We can, though, add
    a test for a single-function pipeline (border case!) and another with four functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, for composition, the style is the same (except that the order of function
    evaluation is reversed) so let''s just see a single test -- I just changed the
    order of the functions in the preceding test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, to test the `chainify()` function, I opted to use the `City` object
    I created above -- I didn''t want to mess with mocks, stubs, spies, and the like,
    but rather wanted to ensure that the code worked in normal conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'The final result of all the tests is shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/227d5add-a038-4d6d-815d-844f02424a28.png)Figure 8.3\. A successful
    run of testing for composed functions.'
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '8.1\. **Headline capitalization**. Let''s define *headline-style capitalization*
    to require that a sentence is all written in lowercase, except the first letter
    of each word. (The real definition of this style is more complicated, so let''s
    simplify it for this question.) Write a function `headline(sentence)` that will
    receive a string as an argument and return an appropriately capitalized version.
    Spaces separate words. Build this function by composing smaller functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '8.2\. **Pending tasks**. A web service returns a result such as follows, showing,
    person by person, all their assigned tasks. Tasks may be finished (`done===true`)
    or pending (`done===false`). Your goal is to produce an array with the IDs of
    the pending tasks for a given person, identified by name, which should match the
    `responsible` field. Solve this by using composition or pipelining:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Make sure your code doesn't throw an exception if, for example, the person you
    are looking for doesn't appear in the web service result!
  prefs: []
  type: TYPE_NORMAL
- en: In the last chapter of the book, *Going Further On*, we will see a different
    way of solving this, by using `Maybe` monads, that will greatly simplify the problem
    of dealing with possibly missing data.
  prefs: []
  type: TYPE_NORMAL
- en: 8.3\. **Thinking in abstract terms**. Suppose you are looking through somewhat
    old code and you find a function that looks like the following one. (I'm keeping
    names vague and abstract, so you can focus on the structure and not on the actual
    functionality.) Can you transform this to Pointfree style?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have seen ways of creating new functions by joining several
    other functions in different ways, through pipelining (with a variant that we
    don't recommend, chaining) and composition.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](0f9ddfc4-d3d9-40a9-941b-edbec62cc890.xhtml), *Designing Functions
    - Recursion*, we will move on to function design, and study the usage of recursion,
    which classically is a basic tool in functional programming and allows for very
    clean algorithm designs.
  prefs: []
  type: TYPE_NORMAL
