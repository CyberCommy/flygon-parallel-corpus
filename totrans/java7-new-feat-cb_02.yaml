- en: Chapter 2. Locating Files and Directories Using Paths
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Path object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interoperability between java.io.File and java.nio.file.Files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting a relative path into an absolute path
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removing redundancies by normalizing a path
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Combining paths using path resolution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a path between two locations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting between path types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Determining whether two paths are equivalent
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing symbolic links
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A filesystem is a way of organizing data on a computer. Normally, it consists
    of one or more top-level directories, each of which contains a hierarchy of files.
    The top-level directory is frequently referred to as the root. In addition, the
    filesystem is stored on a media, which is referred to as the file store.
  prefs: []
  type: TYPE_NORMAL
- en: Java 7 introduces a number of new classes and interfaces to make working with
    filesystems easier and more efficient. These have largely supplemented older classes
    found in the `java.io` package.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this and subsequent chapters, we will demonstrate how a filesystem can be
    managed using the directory structure, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introduction](img/5627_2_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The ovals represent a directory/folder, while rectangles represent files. Unix-based
    systems and Windows systems differ in their support of a root node. Unix systems
    support a single root node, while Windows systems permit more than one root node.
    The location of a directory or file is described using a path. The elements, directories
    and files of the path are separated by either a forward or backward slash. In
    Unix, a forward slash is used. In Windows, a backward slash is used.
  prefs: []
  type: TYPE_NORMAL
- en: The music files were obtained from [http://freepd.com/70s%20Sci%20Fi/](http://freepd.com/70s%20Sci%20Fi/).
    The `status.txt` is intended to hold simple status information, while the `users.txt`
    is assumed to hold a list of users. The `users.txt` file in the music directory
    is a symbolic link to the actual file in the `docs` directory as reflected with
    the red line. These files will be used in various examples throughout this chapter.
    Of course, you can use any file or file structure that you wish.
  prefs: []
  type: TYPE_NORMAL
- en: 'Symbolic links are more common in Unix-based platforms. To create a symbolic
    link for the `users.txt` file in the music directory, use the following command
    in the command console: `mklink users.txt c:\home\docs\users.txt`. This requires
    administrator privileges to execute.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter is concerned with the management of paths as represented by the
    `java.nio.file.Path` class. A `Path` object is used extensively by classes in
    the `java.nio` package and is composed of several parts that are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A root which is the base of the path, such as a C drive
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A separator used to separate the names that make up directories and files of
    the path
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The names of the intermediate directories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A terminal element, which can be a file or directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These are discussed and illustrated in the *Understanding paths* recipe. The
    following are the classes dealing with files and directories:'
  prefs: []
  type: TYPE_NORMAL
- en: '`java.nio. file.Paths` contains static methods for the creation of a `Path`
    object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.nio. file.Path` interface contains numerous methods for working with
    paths'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.nio. file.FileSystems` is the primary class used to access a filesystem'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.nio. file.FileSystem` represents a filesystem, such as the /on a UNIX
    system or the C drive on a Windows platform'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.nio. file.FileStore` represents the actual storage device and provides
    device-specific information'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.nio. file.attribute.FileStoreAttributeView` provides access to file information'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last two classes are discussed in more depth in later chapters. To gain
    access to a file or directory, we will typically use the `FileSystems` class'
    `getDefault` method to retrieve a reference to the filesystem accessible by the
    JVM. To get access to a specific drive, we can use the `getFileSystem` method
    with a **Uniform Resource Identifier** (**URI**) object representing the drive
    or directory of interest.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `FileSystems` class provides techniques to create or access a filesystem.
    In this chapter, we are interested in how the class supports the creation of `Path`
    objects. Once we have reference to a file system object, we can obtain a `Path`
    object using any one of several methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`getPath:` This uses a system-dependent path to obtain a `Path` object. The
    `Path` object is used to locate and access the file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getPathMatcher:` This creates a `PathMatcher`. It performs various matching
    type operations on a file and is covered in the *Getting filesystem information*
    recipe in [Chapter 5.](ch05.html "Chapter 5. Managing Filesystems")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getRootDirectories:` This is used to obtain a list of root directories. This
    method is illustrated in the *Getting filesystem information* recipe in [Chapter
    5.](ch05.html "Chapter 5. Managing Filesystems")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The creation and general use of `Path` objects is introduced in the *Understanding
    paths* recipe. This knowledge is used in subsequent recipes and other chapters,
    so be sure to understand the basic processes covered in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: You can still use the older `java.io` package elements. A path representing
    a `java.io.File` object can be created using the `File` class's `toPath` method.
    This is discussed in the *Interoperability between java.io.File and java.nio.file.Files*
    recipe and can be useful when maintaining older code.
  prefs: []
  type: TYPE_NORMAL
- en: Paths can be either relative or absolute. These types of paths and techniques
    for dealing with them are discussed in the *Working with relative and absolute
    paths* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Paths can contain redundancies and extraneous elements. Removal of these elements
    is called **normalization.** The *Removing redundancies in a path by normalizing
    the path* recipe examines the techniques available to simplify these types of
    paths.
  prefs: []
  type: TYPE_NORMAL
- en: Paths can be combined to form a new composite path. This is known as resolving
    a path and is addressed in the *Combining paths using path resolution* recipe.
    This technique can be useful for creating new paths, where parts of the path are
    available from different sources.
  prefs: []
  type: TYPE_NORMAL
- en: When a reference is needed for a file, that path is sometimes relative to the
    current location or some other location. The *Creating a path between two locations*
    recipe illustrates the creation of such a path. The process is called **relativizing.**
  prefs: []
  type: TYPE_NORMAL
- en: Not only are there relative and absolute paths, but there are also other ways
    of representing a path such as with a `java.net.URI` object. When a `Path` object
    is created, it is not necessary that the actual path exists. For example, the
    `Path` may be created to create a new filesystem element. The *Converting between
    path types* recipe looks at methods used to convert between these different types
    of paths.
  prefs: []
  type: TYPE_NORMAL
- en: Paths are system-dependent. That is, a path on one system such as UNIX is different
    from one found on a Windows system. Comparing two paths found on the same platform
    may or may not be the same. This is examined in the *Determining whether two paths
    are equivalent* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Path object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A path to a directory or file is needed to identify that resource. The focus
    of this recipe is on how to obtain a `Path` object for typical file and directory
    operations. Paths are used for most of the recipes in this and many of the subsequent
    chapters that deal with files and directories.
  prefs: []
  type: TYPE_NORMAL
- en: There are several methods that create or return a `Path` object. Here, we will
    examine those methods used to create a `Path` object and how to use its methods
    to further our understanding of the path concept as used in Java.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to create a `Path` object, we need to use either one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The `FileSystem` class' `getPath` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Paths` class' `get` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will use the `getPath` method first. The `get` method is explained in the
    *There's more* section of this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a console application with a `main` method. In the `main` method, add
    the following code sequence that creates a `Path` object for the file `status.txt`.
    We will use several `Path` class'' methods to examine the path created as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice the use of the forward slashes in the `path` string. This approach will
    work on any platform. However, on Windows you can also use back slashes shown
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: While either approach will work for a Windows platform, the use of forward slashes
    is more portable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Execute the program. Your output should appear as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**toString: \home\docs\status.txt**'
  prefs: []
  type: TYPE_NORMAL
- en: '**getFileName: status.txt**'
  prefs: []
  type: TYPE_NORMAL
- en: '**getRoot: \**'
  prefs: []
  type: TYPE_NORMAL
- en: '**getNameCount: 3**'
  prefs: []
  type: TYPE_NORMAL
- en: '**getName(0): home**'
  prefs: []
  type: TYPE_NORMAL
- en: '**getName(1): docs**'
  prefs: []
  type: TYPE_NORMAL
- en: '**getName(2): status.txt**'
  prefs: []
  type: TYPE_NORMAL
- en: '**subpath(0,2): home\docs**'
  prefs: []
  type: TYPE_NORMAL
- en: '**getParent: \home\docs**'
  prefs: []
  type: TYPE_NORMAL
- en: '**false**'
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Path` object was created using invocation chaining, starting with the `FileSystems`
    class' `getDefault` method. This returns a `FileSystem` object representing the
    filesystem available to the JVM. The `FileSystem` object normally refers to the
    working directory of the current user. Next, the `getPath` method was executed
    using a string representing the file of interest.
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the code used various methods to display information about the path.
    As detailed in the introduction of this chapter, we can display information about
    the parts of the path using methods of the `Path` class. The `toString` method
    is executed against the path to illustrate what you get by default.
  prefs: []
  type: TYPE_NORMAL
- en: The `getFileName` returned the file name of the `Path` object, and the `getRoot`
    returned the root. The `getNameCount` method returned the number of intermediate
    directories plus one for the filename. The for loop listed the elements of the
    path. In this case, there were two directories and one file giving a count of
    three. The three elements make up the path.
  prefs: []
  type: TYPE_NORMAL
- en: 'While a simple for loop was used to display these names, we could have also
    used the `iterator` method to list these names, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `Path` object may consist of other paths. Subpaths can be retrieved using
    the `subpath` method. The method possesses two arguments. The first represents
    an initial index and the second argument specifies the last index exclusively.
    In this example, the first argument was set to 0 indicating that the root level
    directory was to be retrieved. The last index was set to 2, which means only the
    top two directories were listed.
  prefs: []
  type: TYPE_NORMAL
- en: The `getParent` method in this case also returned the identical path. However,
    notice that it began with the backslash. This represents the path from the top
    level element following each element except the last one.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are several issues that bear further consideration:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the `Paths` class' `get` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The meaning of the parent path
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Paths class' get method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `Paths` class'' `get` method can also be used to create a `Path` object.
    This method uses a variable number of `String` arguments to construct a path.
    In the following code sequence, a `path` is created starting at the root of the
    current filesystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The output using the `toAbsolutePath` method shows the path constructed. Notice
    the **E** element. The code was executed on a Windows system where the current
    drive was the **E** drive. The `toAbsolutePath` method is discussed in the *Working
    with relative and absolute paths* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: '**Absolute path: E:\home\docs\users.txt**'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we do not use the forward slash in the path''s `String`, then the path is
    created based on the current working directory. Remove the forward slash and execute
    the program. Your output should be similar to the following where, **currentDirectory**,
    is replaced with the one in use when the code is executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Absolute path: currentDirectory\home\docs\users.txt**'
  prefs: []
  type: TYPE_NORMAL
- en: A more flexible approach is to use the resolve method as discussed in the *Combining
    paths using path resolution* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'The conversion of the input arguments to a path is system-dependent. If the
    characters used in the creation of the path are invalid for the filesystem, then
    a `java.nio.file.InvalidPathException` is thrown. For example, in most filesystems
    a null value is an illegal character. To illustrate this, add a back slash 0 to
    the `path` string as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'When executed, the output in part will appear as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Bad path: [/home \docs\users.txt] at position 5**'
  prefs: []
  type: TYPE_NORMAL
- en: The `InvalidPathException` class' `getInput` method returns the concatenated
    string used for creating the path. The `getIndex` method returns the position
    of the offending character, which in this case is the null character.
  prefs: []
  type: TYPE_NORMAL
- en: The meaning of the parent path
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `getParent` method returns the parent path. However, the method does not
    access the filesystem. This means that for a given `Path` object, there may or
    may not be a parent.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following path declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This refers to the `users.txt` file found in the current working directory.
    The `getNameCount` will return 1, and the `getParent` method will return null.
    In reality, the file exists in a directory structure and has a root and a parent.
    Thus, the results of this method may not be useful in some contexts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The use of this method is roughly equivalent to the following use of the `subpath`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `toRealPath` method is discussed in the *Working with relative and absolute
    paths* recipe and in the *Removing redundancies in a path by normalizing the path*
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Interoperability between java.io.File and java.nio.file.Files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Prior to the introduction of the `java.nio` package the classes and interfaces
    of the `java.io` package were the only ones available to Java developers for working
    with files and directories. While most of the capability of the `java.io` package
    has been supplemented by the newer packages, it is still possible to work with
    the older classes, in particular the `java.io.File` class. This recipe discusses
    how this can be accomplished.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To obtain a `Path` object using a `File` class, the following steps need to
    be followed:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `java.io.File` object representing the file of interest
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Apply the `toPath` method to it to obtain a `Path` object
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a console application. Add the following main method where we create
    a `File` object and a `Path` object representing the same file. Next, we compare
    the two objects to determine whether they represent the same file or not:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: When you execute the application, the output will be true.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Two `Path` objects were created. The first `Path` object was declared using
    the Paths class' `get` method. It created a `Path` object to the `users.txt` file
    using a `java.net.URI` object. The second `Path` object, `toPath`, was created
    from a `File` object using the `toPath` method. The Path's `equals` method was
    used to demonstrate that the paths are equivalent.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Notice the use of the forward and backward slashes for the strings used to represent
    the file. The `URI` string uses forward slashes, which is operating system-independent.
    Whereas, the back slash is used for a Windows path.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The creation of a `Path` object is illustrated in the *Understanding paths*
    recipe. Also, the creation of a `URI` object is discussed in the *Working with
    relative and absolute paths* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Converting a relative path into an absolute path
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A path can be expressed either as an absolute path or a relative path. Both
    are common and are useful in different situations. The `Path` class and related
    classes support the creation of both absolute and relative paths.
  prefs: []
  type: TYPE_NORMAL
- en: A relative path is useful for specifying the location of a file or directory
    in relationship to the current directory location. Typically, a single dot or
    two dots are used to indicate the current directory or next higher level directory
    respectively. However, the use of a dot is not required when creating a relative
    path.
  prefs: []
  type: TYPE_NORMAL
- en: An absolute path starts at the root level and lists each directory separated
    by either forward slashes or backward slashes, depending on the operating system,
    until the desired directory or file is reached.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will determine the path separator used for the current system
    and learn how to convert a relative path to an absolute path. This is useful when
    handling user input for filenames. Related to absolute and relative paths is the
    URI representation of a path. We will learn how to use the `Path` class' `toUri`
    method to return this representation for a given path.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following methods are frequently used when dealing with absolute and relative
    paths:'
  prefs: []
  type: TYPE_NORMAL
- en: The `getSeparator` method determines the file separator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `subpath` method obtains a part or all parts/elements of a path
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `toAbsolutePath` method obtains the absolute path for a relative path
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `toUri` method obtains the URI representation of a path
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will address each of the previous methods one at a time. Start by creating
    a console application using the following `main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the program. On a Windows platform, the output should appear as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**The separator is \**'
  prefs: []
  type: TYPE_NORMAL
- en: '**subpath: home\docs\users.txt**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Absolute path: E:\home\docs\users.txt**'
  prefs: []
  type: TYPE_NORMAL
- en: '**URI: file:///E:/home/docs/users.txt**'
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `getDefault` method returned a `FileSystem` object representing the filesystem
    currently accessible to the JVM. The `getSeparator` method is executed against
    this object, returning a backslash character indicating that the code was executed
    on a Windows machine.
  prefs: []
  type: TYPE_NORMAL
- en: A `Path` object was created for the `users.txt` file and the `subpath` method
    was executed against it. This method is discussed in more detail in the *Understanding
    paths* recipe. The `subpath` method always returns a relative path.
  prefs: []
  type: TYPE_NORMAL
- en: Next, a path was created using the `get` method. Since the forward slash was
    used with the first argument, the path started at the root of the current filesystem.
    In this example, the path provided is relative.
  prefs: []
  type: TYPE_NORMAL
- en: The URI representation of a path is related to absolute and relative paths.
    The `Path` class' `toUri` method returns this representation for a given path.
    A `URI` object is used to represent a resource on the Internet. In this case,
    it returned a string in the form of a URI scheme for files.
  prefs: []
  type: TYPE_NORMAL
- en: The absolute path can be obtained using the `Path` class' `toAbsolutePath` method.
    An absolute path contains the root element and all of the intermediate elements
    for the path. This can be useful when users are requested to enter the name of
    a file. For example, if the user is asked to supply a filename to save results,
    the filename can be added to an existing path representing a working directory.
    The absolute path can then be obtained and used as necessary.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Bear in mind that the `toAbsolutePath` method works regardless of whether the
    path references a valid file or directory. The file used in the previous example
    does not need to exist. Consider the use of a bogus file as shown in the following
    code. The assumption is that the file, `bogusfile.txt`, does not exist in the
    specified directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'When the program is executed, the output will appear as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The separator is \**'
  prefs: []
  type: TYPE_NORMAL
- en: '**File exists: false**'
  prefs: []
  type: TYPE_NORMAL
- en: '**subpath: home\docs\bogusfile.txt**'
  prefs: []
  type: TYPE_NORMAL
- en: '**File exists: false**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Absolute path: E:\home\docs\bogusfile.txt**'
  prefs: []
  type: TYPE_NORMAL
- en: '**URI: file:///E:/home/docs/bogusfile.txt**'
  prefs: []
  type: TYPE_NORMAL
- en: If we want to know whether this is a real path or not, we can use the `toRealPath`
    method as discussed in the *Removing redundancies in a path by normalizing the
    path* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Redundancies in a path can be removed using the `normalize` method as discussed
    in the *Removing redundancies in a path by normalizing the path* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: When symbolic links are used for files, then the path may not be the real path
    for the file. The `Path` class' `toRealPath` method will return the real absolute
    path for the file. This is demonstrated in the *Removing redundancies in a path
    by normalizing the path* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Removing redundancies by normalizing a path
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When the "." or ".." notation is used in defining a path, their use may introduce
    redundancies. That is, the path described may be simplified by removing or otherwise
    altering the path. This recipe discusses the use of the `normalize` method to
    affect this type of conversion. By simplifying a path, it avoids errors and can
    improve the performance of the application. The `toRealPath` method also performs
    normalization and is explained in the *There's more ..*. section of this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The basic steps used for removing redundancies in a path include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Identifying paths that may contain redundancies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `normalize` method to remove the redundancies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The directory structure from the introduction is duplicated here for convenience:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/5627_2_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'First consider the following paths:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: These contain redundancies or extraneous parts. In the first example, the path
    starts at `home` and then goes down a directory level to `docs` directory. The
    `.`. notation then leads back up to the `home` directory. This then proceeds down
    the `music` directory and to the `mp3` file. The `docs/.`. element is extraneous.
  prefs: []
  type: TYPE_NORMAL
- en: In the second example, the path starts at `home` and then encounters a single
    period. This represents the current directory, that is, the `home` directory.
    Next, the path goes down the `music` directory and then encounters the `mp3` file.
    The `/`. is redundant and is not needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new console application and add the following `main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the application. You should get the following output, though the root
    directory may differ depending on the configuration of your system:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Absolute path: E:\home\docs\..\music\Space Machine A.mp3**'
  prefs: []
  type: TYPE_NORMAL
- en: '**URI: file:///E:/home/docs/../music/Space%20Machine%20A.mp3**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Normalized Path: \home\music\Space Machine A.mp3**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Normalized URI: file:///E:/home/music/Space%20Machine%20A.mp3**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Absolute path: E:\home\.\music\ Robot Brain A.mp3**'
  prefs: []
  type: TYPE_NORMAL
- en: '**URI: file:///E:/home/./music/%20Robot%20Brain%20A.mp3**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Normalized Path: \home\music\ Robot Brain A.mp3**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Normalized URI: file:///E:/home/music/%20Robot%20Brain%20A.mp3**'
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Paths` class'' `get` method was used to create two paths using the redundant
    extraneous paths discussed previously. The code that follows the `get` methods
    displayed the absolute path and the URI equivalent to illustrate the actual path
    created. Next, the `normalize` method was used and was then chained with the `toUri`
    method to further illustrate the normalization process. Notice that the redundancy
    and extraneous path elements are gone. The `toAbsolutePath` and `toUri` methods
    are discussed in the *Working with relative and absolute paths* recipe.'
  prefs: []
  type: TYPE_NORMAL
- en: The `normalize` method does not check to see if the files or path are valid.
    The method simply performs a syntactic operation against the path. If a symbolic
    link was part of the original path, then the normalized path may no longer be
    valid. Symbolic links are discussed in the *Managing symbolic links* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Path` class' `toRealPath` will return a path representing the actual path
    to the file. It does check to see if the path is valid and will return a `java.nio.file.NoSuchFileException`
    if the file does not exist.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the previous example to use the `toRealPath` method with a non-existent
    file as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the application. The result should contain the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Absolute path: \\Richard-pc\e\home\docs\..\music\NonExistentFile.mp3**'
  prefs: []
  type: TYPE_NORMAL
- en: '**The file does not exist!**'
  prefs: []
  type: TYPE_NORMAL
- en: The `toRealPath` method normalizes the path. It also resolves any symbolic links,
    though there were none in this example.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The creation of a `Path` object is discussed in the *Understanding paths* recipe.
    Symbolic links are discussed in the *Managing symbolic links* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Combining paths using path resolution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `resolve` method is used to combine two paths, where one contains a root
    element and the other is a partial path. This is useful when creating paths that
    can vary, such as those used in the installation of an application. For example,
    there may be a default directory where an application is installed. However, the
    user may be able to select a different directory or drive. Using the `resolve`
    method to create a path allows the application to be configured independent of
    the actual installation directory.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The use of the `resolve` method involves two basic steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `Path` object that uses a root element
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Execute the `resolve` method against this path with a second partial path
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A partial path is one where only a part of the full path is provided and does
    not contain a root element.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new application. Add the following `main` method to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the code. You should get the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**rootPath: \home\docs**'
  prefs: []
  type: TYPE_NORMAL
- en: '**partialPath: users.txt**'
  prefs: []
  type: TYPE_NORMAL
- en: '**resolvedPath: \home\docs\users.txt**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Resolved absolute path: E:\home\docs\users.txt**'
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following three paths were created:'
  prefs: []
  type: TYPE_NORMAL
- en: '`\home\docs:` This is the root path'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`users.txt:` This is the partial path'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\home\docs\users.txt:` This is the resulting resolved path'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The resolved path was created by using the `partialPath` variable as an argument
    to the `resolve` method executed against the `rootPath` variable. These paths
    along with the absolute path of the `resolvedPath` were then displayed. The absolute
    path included the root directory, though this may differ on your system.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `resolve` methods are overloaded, one using a `String` argument and the
    second using a `Path` argument. The `resolve` method can also be misused. In addition,
    there is also an `overloadedresolveSibling` method that works similar to the `resolve`
    method except it removes the last element of the root path. These issues are addressed
    here.
  prefs: []
  type: TYPE_NORMAL
- en: Using a String argument with the resolve method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `resolve` method is overloaded with one that accepts a `String` argument.
    The following statement will achieve the same results as in the previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The path separator can also be used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Using these statements with the earlier code results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '**rootPath: \home\docs**'
  prefs: []
  type: TYPE_NORMAL
- en: '**partialPath: users.txt**'
  prefs: []
  type: TYPE_NORMAL
- en: '**resolvedPath: \home\docs\backup\users.txt**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Resolved absolute path: E:\home\docs\backup\users.txt**'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the resolved path is not necessarily a valid path as the backup
    directory may or may not exist. The `toRealPath` method in the *Removing redundancies
    in a path by normalizing the path* recipe can be used to determine if it is valid
    or not.
  prefs: []
  type: TYPE_NORMAL
- en: Improper use of the resolve method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are three uses of the `resolve` method that can result in unexpected
    behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: Incorrect order of the root and partial paths
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a partial path twice
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the root path twice
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If we reverse the order in which the `resolve` method is used, that is apply
    the root path to the partial path, only the root path is returned. This is illustrated
    with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'When the code is executed, we get the following results:'
  prefs: []
  type: TYPE_NORMAL
- en: '**rootPath: \home\docs**'
  prefs: []
  type: TYPE_NORMAL
- en: '**partialPath: users.txt**'
  prefs: []
  type: TYPE_NORMAL
- en: '**resolvedPath: \home\docs**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Resolved absolute path: E:\home\docs**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Only the root path is returned here. The partial path is not appended to the
    root path. Using the partial path twice as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'will result in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '**rootPath: \home\docs**'
  prefs: []
  type: TYPE_NORMAL
- en: '**partialPath: users.txt**'
  prefs: []
  type: TYPE_NORMAL
- en: '**resolvedPath: users.txt\users.txt**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Resolved absolute path: currentWorkingDIrectory\users.txt\users.txt**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice the resolved path is incorrect and that the absolute path uses the current
    working directory. Using the root path twice as shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'results in the same output as when using the paths in the reverse order:'
  prefs: []
  type: TYPE_NORMAL
- en: '**rootPath: \home\docs**'
  prefs: []
  type: TYPE_NORMAL
- en: '**partialPath: users.txt**'
  prefs: []
  type: TYPE_NORMAL
- en: '**resolvedPath: \home\docs**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Resolved absolute path: E:\home\docs**'
  prefs: []
  type: TYPE_NORMAL
- en: Whenever an absolute path is used as the argument of the `resolve` method, that
    absolute path is returned. If an empty path is used as an argument to the method,
    the root path is returned.
  prefs: []
  type: TYPE_NORMAL
- en: Using the resolveSibling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `resolveSibling` method is overloaded taking either a `String` or a `Path`
    object. With the `resolve` method, the partial path is appended to the end of
    the root path. The `resolveSibling` method differs from the `resolve` method in
    that the last element of the root path is removed before the partial path is appended.
    Consider the following code sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'When executed we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '**rootPath: \home\music**'
  prefs: []
  type: TYPE_NORMAL
- en: '**resolvedPath: \home\music\tmp\Robot Brain A.mp3**'
  prefs: []
  type: TYPE_NORMAL
- en: '**rootPath: \home\music**'
  prefs: []
  type: TYPE_NORMAL
- en: '**resolvedPath: \home\tmp\Robot Brain A.mp3**'
  prefs: []
  type: TYPE_NORMAL
- en: Notice the resolved path differs in the presence of the directory `music`. When
    the `resolve` method is used, the directory is present. It is absent when the
    `resolveSibling` method is used. If there is no parent path, or the argument of
    the method is an absolute path, then the argument passed to the method is returned.
    If the argument is empty then the parent is returned.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The creation of a `Path` object is discussed in the *Understanding paths* recipe.
    Also, the `toRealPath` method is explained in the *Removing redundancies in a
    path by normalizing the path* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a path between two locations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To relativize a path means to create a path based on two other paths such that
    the new path represents a way of navigating from one of the original paths to
    the other. This technique finds a relative path from one location to another.
    For example, the first path could represent an application default directory.
    The second path could represent a target directory. A relative path created from
    these directories could facilitate operations against the target.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To use the `relativize` method to create a new path from one path to another,
    we need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `Path` object that represents the first path.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `Path` object that represents the second path.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Apply the `relativize` method against the first path using the second path as
    its argument.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new console application and use the following `main` method. This
    method creates two `Path` objects, and shows the relative path between them as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the application. Your results should be similar to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**From firstPath to secondPath: ..\..\docs**'
  prefs: []
  type: TYPE_NORMAL
- en: '**From secondPath to firstPath: ..\music\Future Setting A.mp3**'
  prefs: []
  type: TYPE_NORMAL
- en: '**From firstPath to secondPath: ..**'
  prefs: []
  type: TYPE_NORMAL
- en: '**From secondPath to firstPath: Future Setting A.mp3**'
  prefs: []
  type: TYPE_NORMAL
- en: '**From firstPath to secondPath: ..\..\docs\users.txt**'
  prefs: []
  type: TYPE_NORMAL
- en: '**From secondPath to firstPath: ..\..\music\Future Setting A.mp3**'
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the first example, a relative path was created from the `Future Setting A.mp3`
    file to the `docs` directory. The `music` and `docs` directories are assumed to
    be siblings. The `.`. notation means to move up one directory. This chapter's
    introduction illustrated the assumed directory structure for this example.
  prefs: []
  type: TYPE_NORMAL
- en: The second example demonstrates creating a path from within the same directory.
    The path from `firstpath` to `secondPath` is actually a potential error. Depending
    on how this is used, we could end up in the directory above the `music` directory
    since the path returned is `.`. meaning to move up one directory level. The third
    example is similar to the first example except both of the paths contain file
    names.
  prefs: []
  type: TYPE_NORMAL
- en: 'The relative path created by this method may not be a valid path. This is illustrated
    by using the potentially non-existent `tmp` directory, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should appear as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**From firstPath to secondPath: ..\..\docs\tmp\users.txt**'
  prefs: []
  type: TYPE_NORMAL
- en: '**From secondPath to firstPath: ..\..\..\music\Future Setting A.mp3**'
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are three other cases that we need to consider:'
  prefs: []
  type: TYPE_NORMAL
- en: Both paths are equal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One path contains a root
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both paths contain a root
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both paths are equal
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When both paths are equal, the `relativize` method will return an empty path
    as illustrated with the following code sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**From firstPath to secondPath:**'
  prefs: []
  type: TYPE_NORMAL
- en: '**From secondPath to firstPath:**'
  prefs: []
  type: TYPE_NORMAL
- en: While this is not necessarily an error, note that it does not return a single
    dot which is frequently used to represent the current directory.
  prefs: []
  type: TYPE_NORMAL
- en: One path contains a root
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If only one of the paths contains a root element, then it may not be possible
    to construct a relative path. Whether it is possible or not is system-dependent.
    In the following example, the first path contains the root element `c:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'When this code sequence is executed on Windows 7, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exception in thread "main" java.lang.IllegalArgumentException: ''other''
    is different type of Path**'
  prefs: []
  type: TYPE_NORMAL
- en: '**From firstPath to secondPath: .**.'
  prefs: []
  type: TYPE_NORMAL
- en: '**From secondPath to firstPath: Future Setting A.mp3**'
  prefs: []
  type: TYPE_NORMAL
- en: '**atsun.nio.fs.WindowsPath.relativize(WindowsPath.java:388)**'
  prefs: []
  type: TYPE_NORMAL
- en: '**atsun.nio.fs.WindowsPath.relativize(WindowsPath.java:44)**'
  prefs: []
  type: TYPE_NORMAL
- en: '**atpackt.RelativizePathExample.main(RelativizePathExample.java:25)**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Java Result: 1**'
  prefs: []
  type: TYPE_NORMAL
- en: Notice the reference to **other** in the output. This refers to the argument
    of the `relativize` method.
  prefs: []
  type: TYPE_NORMAL
- en: Both paths contain a root
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The ability of the `relativize` method to create a relative path when both
    paths contain a root element is also system-dependent. This situation is illustrated
    in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'When executed on Windows 7, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '**From firstPath to secondPath: ..\..\docs\users.txt**'
  prefs: []
  type: TYPE_NORMAL
- en: '**From secondPath to firstPath: ..\..\music\Future Setting A.mp3**'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The creation of a `Path` object is discussed in the *Understanding paths* recipe.
    Symbolic links results are system-dependent and are discussed in more depth in
    the *Managing symbolic links* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Converting between path types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Path` interface represents a path within a filesystem. This path may or
    may not be a valid path. There are times when we may want to use an alternative
    representation of a path. For example, a file can be loaded into most browsers
    using a `URI` for the file. The `toUri` method provides this representation of
    a path. In this recipe we will also see how to obtain an absolute path and a real
    path for a `Path` object.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are three methods that provide alternative path representations:'
  prefs: []
  type: TYPE_NORMAL
- en: The `toUri` method returns the `URI` representation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `toAbsolutePath` method returns the absolute path
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `toRealPath` method returns the real path
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new console application. Within the `main` method, we will use each
    of the previous methods. Add the following `main` method to the application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'If not already present, add a `users.txt` file in the working directory of
    your application. Execute the program. Your output should be similar to the following,
    except the **..**. in this output should reflect the location of the `users.txt`
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**URI path: file:///.../ConvertingPathsExample/users.txt**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Absolute path...\ConvertingPathsExample\users.txt**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Real path: ...\ConvertingPathsExample\users.txt**'
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A `users.txt` file was added to the working directory of the Java application.
    This file should contain a list of usernames. The `get` method returned a `Path`
    object representing this file. Each of the three methods were then executed against
    this object.
  prefs: []
  type: TYPE_NORMAL
- en: The `toUri` and `toAbsolutePath` methods returned paths as expected for that
    method type. The path returned is dependent on the application's working directory.
    The `toRealPath` method should have returned the same output as the `toAbsolutePath`
    method. This is to be expected, since the `users.txt` file was not created as
    a symbolic link. Had this been a symbolic link, then a different path representing
    the actual path to the file would have been displayed.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since it is possible that a `Path` object may not actually represent a file,
    the use of the `toRealPath` method may throw a `java.nio.file.NoSuchFileException`
    if the file does not exist. Use an invalid file name, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should appear as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**URI path: file:///.../ConvertingPathsExample/invalidFileName.txt**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Absolute path: ...\ConvertingPathsExample\invalidFileName.txt**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Sep 11, 2011 6:40:40 PM packt.ConvertingPathsExample main**'
  prefs: []
  type: TYPE_NORMAL
- en: '**SEVERE: null**'
  prefs: []
  type: TYPE_NORMAL
- en: '**java.nio.file.NoSuchFileException: ...\ConvertingPathsExample\invalidFileName.txt**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that the `toUri` and `toAbsolutePath` work regardless of whether the
    specified file exists or not. In situations where we want to use these methods,
    we can test whether the file exists or not using the `Files` class'' `exists`
    method. The previous code sequence has been modified to use the `exists` method
    shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The `java.nio.fil.LinkOption` enumeration was added in Java 7\. It is used to
    specify whether symbolic links should be followed or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'When executed, the output should appear as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**URI path: file:///.../ConvertingPathsExample/invalidFileName.txt**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Absolute path: ...\ConvertingPathsExample\invalidFileName.txt**'
  prefs: []
  type: TYPE_NORMAL
- en: '**The file does not exist**'
  prefs: []
  type: TYPE_NORMAL
- en: Determining whether two paths are equivalent
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At times it may be necessary to compare paths. The `Path` class allows you to
    test the paths for equality using the `equals` method. You can also use the `compareTo`
    method to compare two paths lexicographically using an implementation of the `Comparable`
    interface. Finally, the `isSameFile` method can be used to determine if two `Path`
    objects will locate the same file.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to compare two paths, you must:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `Path` object that represents the first path.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `Path` object that represents the second path.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Apply either the `equals, compareTo`, or `isSameFile` methods to the paths as
    needed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new console application and add a `main` method. Declare three `Path`
    object variables such as `path1, path2` and `path3`. Set the first two to the
    same file and the third one to a different path. All the three files must exist.
    Follow this with calls to three comparison methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Add three static methods as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the application. Your output should be similar to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**\home\docs\users.txt and \home\docs\users.txt are equal**'
  prefs: []
  type: TYPE_NORMAL
- en: '**\home\docs\users.txt and \home\music\Future Setting A.mp3 are NOT equal**'
  prefs: []
  type: TYPE_NORMAL
- en: '**\home\docs\users.txt and \home\docs\users.txt are identical**'
  prefs: []
  type: TYPE_NORMAL
- en: '**\home\docs\users.txt and \home\music\Future Setting A.mp3 are NOT identical**'
  prefs: []
  type: TYPE_NORMAL
- en: '**\home\docs\users.txt and \home\docs\users.txt are the same file**'
  prefs: []
  type: TYPE_NORMAL
- en: '**\home\docs\users.txt and \home\music\Future Setting A.mp3 are NOT the same
    file**'
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the `testEquals` method, we determined whether the path objects were considered
    to be equal. The `equals` method will return true if they are equal. However,
    the definition of equality is system-dependent. Some filesystems will use the
    case, among other factors, to determine if the paths are equal.
  prefs: []
  type: TYPE_NORMAL
- en: The `testCompareTo` method used the `compareTo` method to compare the paths
    alphabetically. If the paths are identical, the method returns a zero. The method
    returns an integer less than zero if the path is less than the argument and a
    value greater than zero if the path follows the argument lexicographically.
  prefs: []
  type: TYPE_NORMAL
- en: The `testSameFile` method determines whether the paths locate the same file.
    The `Path` objects are first tested to see if they are the same object. If they
    are, the method will return true. If the `Path` objects are not equal, the method
    then determines whether the paths locate the same file. The method will return
    false if the `Path` objects were generated by different filesystem providers.
    A try block was used since the method may throw an `IOException.`
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `equals` and `compareTo` methods will not successfully compare paths from
    different filesystems. However, as long as the files are on the same filesystem,
    the files in question do not have to exist and the filesystem is not accessed.
    The `isSameFile` method may require access to the files if the path objects being
    tested are not found to be equal. In this case, the files must exist otherwise
    the method will return false.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Files` class' `exists` and `notExists` methods can be used to determine
    whether a file or directory exists or not. This is covered in the *Getting file
    and directory information* recipe in [Chapter 3](ch03.html "Chapter 3. Obtaining
    File and Directory Information"), *Obtaining File and Directory Information*.
  prefs: []
  type: TYPE_NORMAL
- en: Managing symbolic links
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Symbolic links are used to create a reference to a file that actually exists
    in a different directory. In the introduction, a file hierarchy was detailed that
    listed the file, `users.txt`, twice; once in the `docs` directory and a second
    time in the `music` directory. The actual file is located in the `docs` directory.
    The `users.txt` file in the `music` directory is a symbolic link to the real file.
    To a user they appear to be different files. In reality, they are the same. Modification
    of either file results in the real file being changed.
  prefs: []
  type: TYPE_NORMAL
- en: From a programmer's perspective, we are often interested in knowing which files
    are symbolic links and which are not. In this recipe we will discuss the methods
    available in Java 7 to work with symbolic links. It is important to understand
    how a method behaves when used with a symbolic link.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While several methods may behave differently based on whether a `Path` object
    represents a symbolic link or not, in this chapter only the `toRealPath, exists`,
    and `notExists` methods take an optional `LinkOption` enumeration argument. This
    enumeration has only a single element: `NOFOLLOW_LINKS`. If the argument is not
    used then the methods default to following symbolic links.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new console application. Use the following `main` method where we create
    several `Path` objects representing both the real and the symbolic `users.txt`
    file. The behavior of several of this chapter's `Path-related` methods is illustrated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The behavior of these methods can differ based on the underlying operating
    system. When the code is executed on a Windows platform, we get the following
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**false**'
  prefs: []
  type: TYPE_NORMAL
- en: '**true**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Normalized: C:\home\music\users.txt**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Absolute path: C:\home\.\music\users.txt**'
  prefs: []
  type: TYPE_NORMAL
- en: '**URI: file:///C:/home/./music/users.txt**'
  prefs: []
  type: TYPE_NORMAL
- en: '**toRealPath (Do not follow links): C:\home\music\users.txt**'
  prefs: []
  type: TYPE_NORMAL
- en: '**toRealPath: C:\home\docs\users.txt**'
  prefs: []
  type: TYPE_NORMAL
- en: '**From firstPath to secondPath: ..\..\..\docs\status.txt**'
  prefs: []
  type: TYPE_NORMAL
- en: '**From secondPath to firstPath: ..\..\home\music\users.txt**'
  prefs: []
  type: TYPE_NORMAL
- en: '**exists (Do not follow links): true**'
  prefs: []
  type: TYPE_NORMAL
- en: '**exists: true**'
  prefs: []
  type: TYPE_NORMAL
- en: '**notExists (Do not follow links): false**'
  prefs: []
  type: TYPE_NORMAL
- en: '**notExists: false**'
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `path1` and `path2` objects were created which referenced the real file
    and the symbolic link respectively. The `Files` class' `isSymbolicLink` method
    was executed against these objects indicating which path referenced the real file.
  prefs: []
  type: TYPE_NORMAL
- en: The `Path` object was created using an extraneous dot notation. The result of
    the `normalize` method executed against the symbolic link returns a normalized
    path to the symbolic link. The use of the `toAbsolutePath` and `toUri` methods
    results in a path to the symbolic link and not the real file.
  prefs: []
  type: TYPE_NORMAL
- en: The `toRealPath` method possesses an optional `LinkOption` argument. We used
    this to obtain a path to the real file. This method is useful when you need the
    real path, which is often not returned by the other methods executed against a
    symbolic link.
  prefs: []
  type: TYPE_NORMAL
- en: The `firstPath` and `secondPath` objects were used to explore how the `relativize`
    method works with symbolic links. In these examples, the symbolic links were used.
    The last set of examples used the `exists` and `notExists` methods. The use of
    symbolic links did not affect the results of these methods.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The use of symbolic files as they affect other filesystem methods is discussed
    in subsequent chapters.
  prefs: []
  type: TYPE_NORMAL
