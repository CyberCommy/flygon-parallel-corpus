- en: Windows Exploit Development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Windows memory layout
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Buffer overflow attacks with saved return pointer overwrites
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Structured Exception Handling (SEH)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Egg hunters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will go through some Windows-based vulnerabilities and the exploit
    techniques using Python. The solution for the exploit development tasks is to
    replace the program instructions with our instructions to manipulate the application
    behavior. We will be using an Immunity Debugger for debugging the applications.
    As the victim machine will be a Windows machine, we require a machine with Window
    XP OS installed on it. We are using the old XP version for the ease of exploiting,
    and the sample applications with vulnerabilities will work in XP.
  prefs: []
  type: TYPE_NORMAL
- en: Windows memory layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Windows OS memory has a number of sections that can be considered as the
    high-level components. To write exploits and take advantage of vulnerable programs,
    we have to understand the memory structure and its sections.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before starting the exploit script writing, we have to get an idea about the
    structure of the Windows memory layout.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at the memory structure for an executable:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00073.gif)'
  prefs: []
  type: TYPE_IMG
- en: As we use a stack and heap in most cases of exploits, we can start with these.
  prefs: []
  type: TYPE_NORMAL
- en: The stack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The stack is used for short-term local storage in an ordered manner. Each thread
    in an application has a stack. A unique stack with a fixed size is assigned for
    a thread or a function when it is called. The size of the stack is defined when
    the application or thread starts. Also, this stack gets destroyed when this function
    or thread gets finished. The stack is mainly used to store local variables, save
    function return pointers, function argument exception handler records, and much
    more.
  prefs: []
  type: TYPE_NORMAL
- en: 'The stack builds up the data from bottom of the stack to the top, from a high
    memory address to a low memory address:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00074.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The heap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The heap is used dynamically for allocation memory. The heap is used in a situation
    when the application is unaware of the data it will receive or process. So, the
    heap is used to store global variables and values assigned in a disorganized manner.
    The heap is freed only when the application is terminated.
  prefs: []
  type: TYPE_NORMAL
- en: 'The heap grows opposite to the stack. It grows from the lower addresses to
    the higher addresses:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00075.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Program image and dynamic link libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The program image is the location where the actual executable is stored in memory.
    The executables will be in **portable executable** (**PE**) format and include
    the executable and the DLL. Within this section, there are some items defined,
    such as the PE header, `.text`, `.rdata`, `.data`, and so on. The PE header defines
    the header information for the rest of the executable and `.text` includes the
    code segments. `.rdata` is the read only data segment and `.rsrc` is the section
    in which resources such as icons, menus, and fonts for the executable are stored.
  prefs: []
  type: TYPE_NORMAL
- en: Process Environment Block (PEB)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we run an application, an instance of that executable will run as a process
    and provide the required resources to run that application. The process attribute
    in which the non-kernel components of the running process are stored is PEB. Also,
    PEB resides in the user-accessible memory.
  prefs: []
  type: TYPE_NORMAL
- en: For more details on PEB structures, follow this link: [https://msdn.microsoft.com/en-us/library/windows/desktop/aa813706(v=vs.85).aspx](https://msdn.microsoft.com/en-us/library/windows/desktop/aa813706(v=vs.85).aspx)
  prefs: []
  type: TYPE_NORMAL
- en: Thread Environment Block (TEB)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some process may have one or more threads. In that case, each process starts
    with a single primary thread and creates more additional threads when required.
    Also, all these threads share the same virtual addresses. Each thread has its
    own resources which include the exception handlers, local storage, and much more.
    So, like PEB, each thread has TEB. TEB also resides in the process address space.
  prefs: []
  type: TYPE_NORMAL
- en: You can read more on processes and threads in the following article: [https://msdn.microsoft.com/en-us/library/windows/desktop/ms681917(v=vs.85).aspx](https://msdn.microsoft.com/en-us/library/windows/desktop/ms681917(v=vs.85).aspx)
    Also, more on TEB structures can be found here: [https://msdn.microsoft.com/en-us/library/windows/desktop/ms686708(v=vs.85).aspx](https://msdn.microsoft.com/en-us/library/windows/desktop/ms686708(v=vs.85).aspx)
  prefs: []
  type: TYPE_NORMAL
- en: We require a Windows XP machine installed with an Immunity Debugger for analyzing
    a sample application.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are the steps to understand the basic usage of Immunity Debugger:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the Immunity Debugger in the Windows machine.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then load a program to analyze in the Immunity Debugger. From the menu, select
    File | Open and select the application to monitor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00076.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can view the memory map by opening the Memory map. You can open it from
    the menu View | Memory or by hitting the *Alt* + *M* keys:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00077.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'This will open up the following pane:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00078.gif)'
  prefs: []
  type: TYPE_IMG
- en: This is the memory map for the application opened in the Immunity Debugger.
    This includes all stacks, heaps , DLLs, and the executable.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can view the stack as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00079.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'DLLs can be identified as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00080.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'A program image and its contents will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00081.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'DLLs, TEB, and PEB will be identified as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00082.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'We can get the memory dump of PEB and TEB by right-clicking on the address
    and selecting the Dump option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00083.gif)'
  prefs: []
  type: TYPE_IMG
- en: Buffer overflow with saved return pointer overwrite
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will discuss exploiting an application with buffer overflow
    vulnerability and with a saved return pointer overwrite.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can use **FreeflotFTP** as the vulnerable application. You can get the application
    from: [https://rejahrehim.com/assets/sample-package/ftp_server_sample.zip](https://rejahrehim.com/assets/sample-package/ftp_server_sample.zip).
  prefs: []
  type: TYPE_NORMAL
- en: The vulnerable machine environment is Windows XP. So run Windows XP in a real
    or virtual environment and install the Immunity Debugger in it.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Mona
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We need to install Mona, a `pycommand` module for the Immunity Debugger. To
    do this, download the `mona.py` from: [https://github.com/corelan/mona](https://github.com/corelan/mona).
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, add the `mona.py` to the `pyCommands` folder inside `Immunity Debugger`
    application folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00084.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow the steps to create an exploit for buffer overflow attack:'
  prefs: []
  type: TYPE_NORMAL
- en: In a Windows machine, start the Immunity Debugger and open the vulnerable application
    in it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As it is an FTP server, we can try to crash the application by connecting it
    from another machine.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can write a script to connect to the FTP server with Python. To do this,
    create an `ftp_exploit.py` and open it in your editor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates a large chunk of data and posts to the FTP server in the Windows
    machine. By sending this, the program will crash:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00085.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Here you can see that the EIP register is overwritten by the buffer we provided.
    Also, ESP and EDI registers also contain our buffer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we have to analyze the crash. To do this, we need to replace the `A`
    in the payload with a pattern. We can generate patterns with the following script:
    [https://github.com/Svenito/exploit-pattern](https://github.com/Svenito/exploit-pattern).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Download the script
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to generate a pattern with exactly the same payload as we provided
    before. With the script download, generate the pattern with 1,000 characters.
    Copy the generated pattern:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00086.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Update the Python scripts with the pattern as the payload. So, replace the
    following line in the script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'With the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now restart the application in the Immunity Debugger which is running in the
    test machine:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00087.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Then run the Python script again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00088.gif)'
  prefs: []
  type: TYPE_IMG
- en: This will also crash the application, but the EIP register is updated with a
    part of the patterns we injected
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can use the `mona` for analyzing the crash. Run the following command
    in the Immunity Debugger console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00089.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: From this we can identify that the EIP register is overwritten by the 4-bytes
    after the 247th.
  prefs: []
  type: TYPE_NORMAL
- en: So now we can update the pattern which could exactly overwrite the EIP register
    with the data we want.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'So, we can try writing A for the first 247 and then 4 B for EIP register and
    add the padding with C, as we need 1,000\. Then update the Python script with
    the new payload:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Restart the application inside the debugger and run the Python script again.
    This will also crash the application. But, check the registers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00090.gif)'
  prefs: []
  type: TYPE_IMG
- en: Now the EIP is overwritten by the value we provided. Here it is `42424242,`
    which is `BBBB`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we have to replace `BBBB` with the pointer to redirect the execution flow
    to the ESP register. We can make use of `mona` to find this pointer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00091.gif)'
  prefs: []
  type: TYPE_IMG
- en: We can use the first pointer from the list, which is `77def069`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now craft the payload with the pointer we selected. Make sure to reverse the
    byte order to match the Little Endian architecture of the CPU. Update the Python
    script with the following value in the `evil`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now restart the application in the Immunity Debugger and set a break point
    at `77def069`. You can go to the address with the Go to option in the Immunity
    Debugger:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00092.jpeg)![](img/00093.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Set the Breakpoint as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00094.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Select the Memory, on access option.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then run the Python script. This will break the application at the breakpoint
    and we can view the registers as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00095.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now we can generate the shell code from Metasploit and include it in the payload:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00096.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Update the script with the shell code. Then the script will be as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Restart the application in the debugger and run the Python script. This will
    inject the shell code. Now we can try connecting to the victim machine with `nc`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00097.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Structured Exception Handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The **Structured Exception Handling** (**SEH**) is a protection mechanism to
    prevent the buffer overflows. SEH uses a linked list as it contains a sequence
    of data records. When an exception occurs, the OS will go through this list and
    check for the suitable exception function. For this, the exception handler requires
    a pointer to the current exception registration record (SEH) and another pointer
    to the next exception registration record (nSEH). As the Windows stack grows downwards,
    the order will be reversed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00098.gif)'
  prefs: []
  type: TYPE_IMG
- en: So, if we can overwrite the SEH with a `POP POP RETN` instruction, the POP will
    remove four bytes from the top of the stack and the RETN will return an execution
    to the top of the stack. As the SEH is located at `esp+8`, we can increment the
    stack with eight bytes and return to the new pointer at the top of the stack.
    Then we will be executing nSEH. So, we can add a four-byte opcode to jump to another
    memory location where we can include the shell.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we are going to work with another vulnerable application: DVD
    X Player 5.5 PRO. You can download it from: [https://rejahrehim.com/assets/sample-package/dvd_player_sample.zip](https://rejahrehim.com/assets/sample-package/dvd_player_sample.zip).'
  prefs: []
  type: TYPE_NORMAL
- en: As in the previous recipe, we need a victim machine, Windows XP, installed with
    the Immunity Debugger and `mona.py`. Also, install the downloaded application,
    DVD X Player 5.5 PRO, in the Windows machine.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are the steps to create an exploit script for SEH attack:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start the Immunity Debugger in the Windows machine and attach the vulnerable
    application to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00099.jpeg)![](img/00100.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Create a Python file called `dvd_exploit.py` to exploit or the DVD player and
    open it in your editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As we are creating an exploit based on a file format, we will be creating a
    playlist file (`.plf`) with a long buffer in it and allow the DVD player to read
    it. Due to the long buffer, the DVD player will crash with the buffer overflow.
    So, the victim needs to open the playlist file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Then create the playlist file by running the Python script and open it with
    the player:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This will create a `evil.plf` file
  prefs: []
  type: TYPE_NORMAL
- en: Open it in the DVD player. Then the player will crash.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Check the registers for the crash. Also pass the crash with the *Shift* + *F9*
    keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00101.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'Here in the register, there are many zeros because the SEH zeroed them. And
    then we can check the SEH chain to verify that we have overwritten the SEH:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00102.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, we can generate a pattern and update the script to generate the playlist
    file. We have downloaded a script to generate the pattern for the previous recipe.
    We can use the same script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the `pattern` in the Python script and generate the payload file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the generated playlist file in the application. It will crash. Now we
    can use the `mona.py` to analyze the crash and get us the details. To do this,
    run the following command in the Immunity Debugger console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00103.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: From this we can infer that SEH is the 4 bytes after 608.
  prefs: []
  type: TYPE_NORMAL
- en: 'So we can craft our test payload so that it will be like `buffer = "A"*604
    + [nSEH] + [SEH] + "D"*1384`. We can add `BBBB` for nSEH and `CCCC` for SEH:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Then our script will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Run the script and generate the playlist file and open it with the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now we need to get a valid pointer, as we need to overwrite SEH with a pointer.
    To do this, we can use `mona.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00104.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Select `s` pointer from this one. Here we can select the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can update the `buffer` in the script to write this to the SEH:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, our script will be as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the script and generate the playlist file and a breakpoint at the SEH.
    Then, load it in to the DVD player application. Now check the SEH memory location.
    We can find that the pointer we put in the SEH is converted to opcode:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00105.gif)'
  prefs: []
  type: TYPE_IMG
- en: Next we can insert an opcode to make a short jump from nSEH to our padding area
    with the `D`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now we can generate a shell code with Metasploit and update the script to include
    the shell code. We can use the same shell code generated for the previous recipe.
    Now our exploit code will be as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Now generate the payload file with the script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the application in the debugger and load the payload.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now we can run the `nc` command to connect to the system:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Egg hunters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the buffer overflow, we hijack the execution flow and redirect to a CPU register
    that contains part of our buffer and the instructions in that buffer will be executed.
    But, if the buffer size is very small we can't inject any payload. So we can't
    exploit the vulnerability. In such cases, we have to check two possible options.
    First check if the location of the buffer, before overwriting the EIP register,
    is located in the memory. The other option is a buffer segment in a different
    region of the memory and nearby so that we can jump to the offset.
  prefs: []
  type: TYPE_NORMAL
- en: An egg hunter is created with a set of instructions that are translated to opcode.
    So, the egg hunters can be used to search the entire memory range, including the
    stack and heap, for the final stage shell code and redirect the execution flow
    to the shell code.
  prefs: []
  type: TYPE_NORMAL
- en: Egg hunters include a user-defined four-byte tag, which will be used to search
    through the memory until it finds this tag repeated twice. When it finds the tag,
    it will redirect the execution flow to just after the tag where our shell code
    resides.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We require another application for demonstrating this method of creating an
    exploit. Here we use the Kolibri v2.0 HTTP Server. This can be downloaded from: [https://rejahrehim.com/assets/sample-package/Kolibri_sample.zip](https://rejahrehim.com/assets/sample-package/Kolibri_sample.zip).
  prefs: []
  type: TYPE_NORMAL
- en: Our victim machine is a Windows XP 32 bit machine. Make sure to install the
    Immunity Debugger with `mona.py` in it.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are the steps to generate an exploit script with egg hunters:'
  prefs: []
  type: TYPE_NORMAL
- en: We have to create a new exploit file. So create `kolibri_exploit.py` and open
    it in your editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can start with a big buffer submitting to the server. So add the following
    code. Make sure to update the IP address with the correct IP address of your vulnerable
    machine:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Open the vulnerable application with the debugger as File | Open and select
    the `kolibri.exe`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then run the exploit script we created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This will crash the application as usual:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00106.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Then change the `A` buffer with the pattern. We can use the pattern generator
    to create a pattern. Update the code with the pattern. Our script will be as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Restart the application and run the script again. This will also crash the
    application. Then use `mona` to get the details about registers. To do this, provide
    the following command in the Immunity Debugger console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00107.gif)'
  prefs: []
  type: TYPE_IMG
- en: From this we can identify that the EIP can be overwritten by four bytes after
    515 bytes
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on the information, we can update the buffer as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can get an address to redirect the execution flow to the ESP register.
    For that we can make use of `mona.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00108.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can select one of the pointers from this and place it in our buffer. We
    can select the following pointer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Also, we will place the egg hunter in the buffer and make a short jump to that.
    To do this, we have to include the opcode for the short jump at the end. So, update
    the buffer accordingly with the pointer and the opcode for the short jump. The
    opcode short jump can be calculated as follows. The short jump opcode starts with
    `\xEB` followed by the distance we need to jump. Here we have to jump 60 bytes
    back.
  prefs: []
  type: TYPE_NORMAL
- en: 'So convert the -60 decimal to Hex with the calculator:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00109.jpeg)![](img/00110.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, combining these two, the opcode will be `\xEB\xC4` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, our script will be as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now restart the application and the debugger and run the script again. With
    this execution, the flow will redirect to ESP from EIP, as ESP contains our short
    jump and it will jump back 60 bytes to end up in the area where we put the `A`
    buffer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00111.gif)'
  prefs: []
  type: TYPE_IMG
- en: Now we can generate an egg hunter with `mona.py` and include it in the script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Issue the following commands in the Immunity Debugger console and copy the
    generated egg hunter code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00112.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'Update the script with the egg hunter code. Now our script will be as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now generate the shell code with Metasploit and include the shell in the script
    to push the shell code to the server. So our final script with the shell code
    will be as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Now restart the application in the debugger and run the script to exploit.
    Check the exploit with the `nc` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
