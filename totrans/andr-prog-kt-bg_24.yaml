- en: Chapter 24. Design Patterns, Multiple Layouts, and Fragments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have come a long way since the start, when we were just setting up Android
    Studio. Back then, we went through everything step by step, but as we have proceeded,
    we have tried to show you not just how to add *x* to *y* or feature A to app B,
    but to enable you to use what you have learned in your own way in order to bring
    your own ideas to life.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter is more focused on your future apps than any other chapter in this
    book has been so far. We will look at a few features of Kotlin and Android that
    you can use as a framework or template to make even more exciting and complex
    apps while keeping the code manageable. Furthermore, I will suggest areas of further
    study that are barely touched on in this book, given its limited scope.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn about the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Patterns and the model-view-controller
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Android design guidelines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting started with real-world designs and handling multiple different devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An introduction to fragments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's get started.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the model-view-controller pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**The phrases model, view**, and **controller** reflect the separation of the
    different parts of our app into distinct sections, called **layers**. Android
    apps commonly use the model-view-controller **pattern**. A pattern is simply a
    recognized way to structure code and other application resources, such as layout
    files, images, and databases.'
  prefs: []
  type: TYPE_NORMAL
- en: Patterns are useful to us because, by conforming to a pattern, we can be more
    confident that we are doing things right, and will be less likely to have to undo
    lots of hard work because we have coded ourselves into an awkward situation.
  prefs: []
  type: TYPE_NORMAL
- en: There are many patterns in computer science, but just an understanding of the
    MVC pattern will be enough to create some professionally built Android apps.
  prefs: []
  type: TYPE_NORMAL
- en: We have been partly using MVC already, so let's look at each of the three layers
    in turn.
  prefs: []
  type: TYPE_NORMAL
- en: Model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The model refers to the data that drives our app and any logic/code that specifically
    manages it and makes it available to the other layers. For example, in our Note
    to self app, the `Note` class, along with its JSON code, was the data and logic.
  prefs: []
  type: TYPE_NORMAL
- en: View
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The view of the Note to self app was all the widgets in all the different layouts.
    Anything the user can see or interact with on the screen is typically part of
    the view. You probably also remember that the widgets came from the `View` class
    hierarchy of the Android API.
  prefs: []
  type: TYPE_NORMAL
- en: Controller
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The controller is the bit between the view and the model. It interacts with
    both and keeps them separate. It contains what is known as the **application logic**.
    If a user taps a button, the application layer decides what to do about it. When
    the user clicks **OK** to add a new note, the application layer listens for the
    interaction on the view layer. It captures the data contained in the view and
    passes it to the model layer.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Design patterns are a huge topic. There are many different design patterns,
    and if you want a beginner-friendly introduction to the topic in general, I would
    recommend *Head First Design Patterns*. Even though this book''s examples are
    described in another language, Java, it will still be very useful to you. If you
    want to really dive into the world of design patterns, then you can try *Design
    Patterns: Elements of Reusable Object-Oriented Software*, which is recognized
    as a kind of design pattern oracle, but is a much harder read.'
  prefs: []
  type: TYPE_NORMAL
- en: As this book progresses, we will also begin to utilize more of the object-oriented
    programming features we have discussed but not fully benefited from so far. We
    will do so step by step.
  prefs: []
  type: TYPE_NORMAL
- en: Android design guidelines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: App design is a vast topic – so vast that it could only begin to be taught in
    a book dedicated solely to the topic. Also, like programming, you can only start
    to get good at app design with constant practice, review, and improvement.
  prefs: []
  type: TYPE_NORMAL
- en: So, what exactly do I mean by design? I am talking about where you put the widgets
    on the screen, which widgets, what color they should be, how big they should be,
    how to transition between screens, the best way to scroll a page, when and which
    animation interpolators to use, what screens your app should be divided into,
    and much more besides this.
  prefs: []
  type: TYPE_NORMAL
- en: This book will hopefully leave you well-qualified to be able to *implement*
    all your chosen answers to these questions and many more besides. Unfortunately,
    it does not have the space, and the author probably doesn't have the skill to
    teach you how to *make* those choices.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You might be wondering, "What should I do?". Keep making apps and don't let
    a lack of design experience and knowledge stop you! Even release your apps to
    the app store. Keep in mind, however, that there is a whole other topic—design—that
    needs some attention if your apps are going to truly be world class.
  prefs: []
  type: TYPE_NORMAL
- en: In even medium-sized development companies, the designer is rarely also the
    programmer, and even very small companies will often outsource the design of their
    app (or designers might outsource the coding).
  prefs: []
  type: TYPE_NORMAL
- en: Designing is both an art and a science, and Google has demonstrated that it
    recognizes this with high-quality support for both existing and aspiring designers.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I highly recommend you visit and bookmark the web page [https://developer.android.com/design/](https://developer.android.com/design/).
    It is quite detailed and comprehensive, is totally Android focused, and has a
    ton of digital resources in the form of images, color palettes, and guidelines.
  prefs: []
  type: TYPE_NORMAL
- en: Make understanding design principles a short-term goal. Make improving your
    actual design skills an ongoing task. Visit and read design-focused websites and
    try and implement the ideas that you find exciting.
  prefs: []
  type: TYPE_NORMAL
- en: Most important of all, however, don't wait until you are a design expert before
    you start to make apps. Keep bringing your ideas to life and publishing them.
    Make a point of making the design of each app a little better than the last.
  prefs: []
  type: TYPE_NORMAL
- en: We will see in the up coming chapters, and have seen to a certain extent already,
    that the Android API makes a whole bunch of super-stylish UIs available to us
    that we can then take advantage of with very little code or design skill. These
    UIs go a long way to making your apps look like they have been designed by a professional.
  prefs: []
  type: TYPE_NORMAL
- en: Real-world apps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have built a dozen or more apps of various complexity. Most were
    designed and tested on a phone.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, in the real world, our apps need to work well on any device, and
    must be able to handle what happens when in either portrait or landscape view
    (on all devices).
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, it is often not enough for our apps to just work and look "OK"
    on different devices. Often, our apps will need to behave differently and appear
    with a significantly different UI based on whether the device is a phone, a tablet,
    or has landscape/portrait orientation.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Android supports apps for large screen TVs, smart watches via the wear API,
    virtual and augmented reality, and "things" for the internet of things. We will
    not be covering the latter two aspects in this book, but by the end of it, it
    is the author's hope that you will be sufficiently prepared to venture into these
    topics should you choose to.
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at the following screenshot of the BBC News app running on an Android
    phone in portrait orientation. Look at the basic layout, but also note that the
    categories of news (**Top Stories**, **World**, **UK**) are all visible and allow
    the user to scroll to see more categories or to swipe left and right between the
    stories within each category:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Real-world apps](img/B12806_24_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We will see how we can implement a swiping/paging UI using the `ImagePager`
    and `FragmentPager` classes in the next chapter, but before we can do that, we
    need to understand some more fundamentals, which we will explore in this chapter.
    For now, the purpose of the previous screenshot is not so much to show you the
    specific UI features, but to allow you to compare it to the following screenshot.
    Look at the exact same app running on a tablet in landscape orientation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Real-world apps](img/B12806_24_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note that the stories (the data layer) are identical, but that the layout (the
    view layer) is very different. The user is not only given the option to select
    categories from a menu of tabs at the top of the app, but they are also invited
    to add their own tabs through the **Add Topics** option.
  prefs: []
  type: TYPE_NORMAL
- en: Again, the point of this image is to show you not so much the specific UI, or
    even how we might implement one like it, but that they are so different that they
    could easily be mistaken for totally different apps.
  prefs: []
  type: TYPE_NORMAL
- en: Android allows us to design real-world apps like this where not only the layout
    is different for varying device types/orientations/sizes, but so is the behavior,
    that is, the application layer. Android's secret weapon that makes this possible
    is the `Fragment` class.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Google says:**'
  prefs: []
  type: TYPE_NORMAL
- en: '*"A Fragment represents a behavior or a portion of user interface in an Activity.
    You can combine multiple fragments in a single activity to build a multi-pane
    UI and reuse a fragment in multiple activities.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*You can think of a fragment as a modular section of an activity, which has
    its own lifecycle, receives its own input events, and which you can add or remove
    while the activity is running (sort of like a "sub activity" that you can reuse
    in different activities).*'
  prefs: []
  type: TYPE_NORMAL
- en: '*A fragment must always be embedded in an activity, and the fragment''s lifecycle
    is directly affected by the host activity''s lifecycle."*'
  prefs: []
  type: TYPE_NORMAL
- en: We can design multiple different layouts in different XML files, and will do
    so soon. We can also detect things such as device orientation and screen resolution
    in code so that we can then make decisions about layout dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: Let's try this out using device detection, and then we will have our first look
    at fragments.
  prefs: []
  type: TYPE_NORMAL
- en: Device detection mini app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The best way to learn about detecting and responding to devices and their varying
    attributes (screens, orientations, and so on) is to make a simple app. Let''s
    do this by going through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new **Empty Activity** project and call it `Device Detection`. Leave
    all the other settings as their defaults.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `activity_main.xml` file in the **Design** tab and delete the default
    **Hello world!** `TextView`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag a **Button** to the top of the screen and set its **onClick** property
    to `detectDevice`. We will code this function in a minute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag two **TextView** widgets onto the layout, one below the other, and set
    their **id** properties to `txtOrientation` and `txtResolution`, respectively.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Check that you have a layout that looks something like the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I have stretched my widgets (mainly horizontally) and increased the `textSize`
    attributes to `24sp` to make them clearer on the screen, but this is not required
    for the app to work correctly.
  prefs: []
  type: TYPE_NORMAL
- en: '![Device detection mini app](img/B12806_24_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Click the **Infer Constraints** button to secure the positions of the UI elements.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, we will do something new: we will build a layout specifically for landscape
    orientation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In Android Studio, make sure that the `activity_main.xml` file is selected
    in the editor and locate the **Orientation for preview** button, as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Device detection mini app](img/B12806_24_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Click it and then select **Create landscape variation**.
  prefs: []
  type: TYPE_NORMAL
- en: 'You now have a new layout XML file with the same name, but orientated in landscape
    mode. The layout appears blank in the editor, but as we will see, this is not
    the case. Look at the `layout` folder in the project explorer and note that there
    are indeed two files named `activity_main`, and one of them (the new one we just
    created) is postfixed with **(land)**. This is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Device detection mini app](img/B12806_24_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Select this new file (the one postfixed with **(land)**) and now look at the
    component tree. It is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Device detection mini app](img/B12806_24_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It would appear that the layout already contains all our widgets—we just cannot
    see them in the design view. The reason for this anomaly is that when we created
    the landscape layout, Android Studio copied the portrait layout, including all
    the constraints. The portrait constraints rarely match the landscape constraints.
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, click the **Remove all constraints** button; it''s the
    button to the left of the **Infer constraints** button. The UI is now unconstrained.
    This is what mine looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Device detection mini app](img/B12806_24_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The layout is a bit jumbled up, but at least we can see it now. Rearrange it
    to make it look neat and tidy. This is how I rearranged mine:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Device detection mini app](img/B12806_24_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Click the **Infer constraints** button to lock the layout in the new positions.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a basic layout for two different orientations, we can turn
    our attention to our Kotlin code.
  prefs: []
  type: TYPE_NORMAL
- en: Coding the MainActivity class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We already have a mechanism that calls a function called `detectDevice`, and
    all we need to do to make this demo app is code that function. After the `onCreate`
    function in the `MainActivity` class, add the function that handles our button
    click and runs our detection code, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Import the following three classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This code works by declaring and initializing an object of the `Display` type
    called `display`. This object (`display`) now holds a whole bunch of data about
    the specific display properties of the device.
  prefs: []
  type: TYPE_NORMAL
- en: The value stored in the `rotation` property is output into the top `TextView`
    widget.
  prefs: []
  type: TYPE_NORMAL
- en: The code then initializes an object of the `Point` type called `xy`. The `getSize`
    function then loads up the screen resolution into `xy`. The results are then used
    to output the horizontal (`xy.x`) and vertical (`xy.y`) resolution into the `TextView`.
  prefs: []
  type: TYPE_NORMAL
- en: Each time the button is clicked, the two `TextView` widgets will be updated.
  prefs: []
  type: TYPE_NORMAL
- en: Unlocking the screen orientation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before we run the app, we want to make sure that the device isn''t locked in
    portrait mode (most new phones are, by default). From the app drawer of the emulator
    (or the device you will be using), tap the **Settings** app and choose **Display**,
    and then use the switch to set **Auto-rotate screen** to on. I have shown this
    setting in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Unlocking the screen orientation](img/B12806_24_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Running the app
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, you can run the app and click the button, as shown in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Running the app](img/B12806_24_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Rotate the device using one of the rotate buttons on the emulator control panel
    to landscape, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Running the app](img/B12806_24_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can also use *CTRL* + *F11* on a PC, or *CTRL* + *FN* + *F11* on a macOS
    device.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, click the button again and you will see the landscape layout in action,
    as shown in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Running the app](img/B12806_24_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The first thing you will probably notice is that when you rotate the screen,
    it briefly goes blank. This is the activity restarting and going through `onCreate`
    again. This is just what we need. It calls `setContentView` on the landscape version
    of the layout, and the code in `MainActivity` refers to widgets with the same
    ID, so the exact same code works.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Just for a moment, consider how we might handle things if we needed different
    behavior as well as layouts between the two orientations. Don't spend too long
    pondering this because we will discuss it later on in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: If the `0` and `1` results are less than obvious to you, they refer to `public
    const` variables of the `Surface` class, where `Surface.ROTATION_0` equals zero
    and `Surface.ROTATION_180` equals one.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that if you rotated the screen to the left, then your value will be `1`,
    the same as mine, but if you rotated it to the right, you would have seen the
    value `3`. If you rotate the device to portrait mode (upside down), you will get
    the value `4`.
  prefs: []
  type: TYPE_NORMAL
- en: We could use a `when` block and execute different code based on the results
    of these detection tests and load up different layouts. But as we have just seen,
    Android makes things simpler than this by allowing us to add specific layouts
    to folders with configuration qualifiers, such as **land**.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration qualifiers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already seen configuration qualifiers, such as `layout-large` or `layout-xhdpi`,
    in [Chapter 3](ch03.html "Chapter 3. Exploring Android Studio and the Project
    Structure") , *Exploring Android Studio and the Project Structure*. Here, we will
    refresh and expand our understanding of them.
  prefs: []
  type: TYPE_NORMAL
- en: We can begin by alleviating our reliance on the controller layer to influence
    app layout by using configuration qualifiers. There are configuration qualifiers
    for size, orientation, and pixel density. To take advantage of a configuration
    qualifier, we simply design a layout in the usual way, optimized for our preferred
    configuration, and then place that layout in a folder with a name that Android
    recognizes as being for that particular configuration.
  prefs: []
  type: TYPE_NORMAL
- en: For example, in the previous app, putting a layout in the `land` folder tells
    Android to use that layout when the device is in landscape orientation.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is likely that the preceding statement seems slightly ambiguous. This is
    because the Android Studio project explorer window shows us a file and folder
    structure that doesn''t exactly correspond to reality—it is trying to simplify
    things and "help" us. If you select the **Project Files** option from the drop-down
    list at the top of the project explorer window and then examine the project''s
    contents, you will indeed see that there is a layout and `layout-land` folder,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuration qualifiers](img/B12806_24_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Switch back to the **Android** layout or leave it on the **Project Files** view,
    whichever you prefer.
  prefs: []
  type: TYPE_NORMAL
- en: If we want to have a different layout for landscape and portrait, we can create
    a folder called `layout-land` in the `res` folder (or use the shortcut we used
    in the previous app) and place our specially designed layout within it.
  prefs: []
  type: TYPE_NORMAL
- en: When the device is in portrait orientation, the regular layout from the `layout`
    folder will be used, and when it is in landscape orientation, the layout from
    the `layout-land` folder will be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we are designing for different sizes of screen, we place layouts into folders
    with the following names:'
  prefs: []
  type: TYPE_NORMAL
- en: '`layout-small`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`layout-normal`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`layout-large`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`layout-xlarge`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If we are designing for screens with different pixel densities, we can place
    XML layouts into folders with names such as these:'
  prefs: []
  type: TYPE_NORMAL
- en: '`layout-ldpi` for low-DPI devices'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`layout-mdpi` for medium-DPI devices'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`layout-hdpi` for high-DPI devices'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`layout-xhdpi` for extra-high-DPI devices'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`layout-xxhdpi` for extra-extra-high-DPI devices'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`layout-xxxhdpi` for extra-extra-extra-high-DPI devices'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`layout-nodpi` for devices with a DPI you have not otherwise catered for'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`layout-tvdpi` for TVs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What exactly qualifies as low, high, or extra-high DPI and so on can be found
    at the link in the following information box. The point being made here is simply
    where to store the layouts.
  prefs: []
  type: TYPE_NORMAL
- en: It is worth mentioning that what we have just discussed is a long way from the
    whole story regarding configuration qualifiers, and that, as with design, it is
    worth putting this on your list of things to study further.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As is so often the case, the Android developer site has lots of detailed information
    on handling layouts for different devices. Go to [https://developer.android.com/guide/practices/screens_support](https://developer.android.com/guide/practices/screens_support)
    for more information.
  prefs: []
  type: TYPE_NORMAL
- en: The limitation of configuration qualifiers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What the previous app and our discussion on configuration qualifiers have shown
    us is certainly very useful in a number of situations. Unfortunately, however,
    configuration qualifiers and detecting attributes in code only solves the problem
    in the view layer of our MVC pattern.
  prefs: []
  type: TYPE_NORMAL
- en: As we've discussed, our apps sometimes need to have different *behaviors*, as
    well as layouts. This perhaps implies multiple branches of our Kotlin code in
    the controller layer (`MainActivity`, in our previous app) and might summon nightmarish
    visions of having huge great `if` or `when` blocks with specific code for each
    different scenario.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, this is not how it's done. For such situations—in fact, for most
    apps—Android has **fragments**.
  prefs: []
  type: TYPE_NORMAL
- en: Fragments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Fragments will likely become a staple of almost every app you make. They are
    so useful, there are so many reasons to use them, and—once you get used to them—they
    are so simple, that there is almost no reason not to use them.
  prefs: []
  type: TYPE_NORMAL
- en: Fragments are reusable elements of an app, just like any class, but, as we mentioned
    previously, they have special features—such as the ability to load their own view/layout,
    as well as their very own lifecycle functions—which make them perfect for achieving
    the goals we discussed in the Real-world apps section.
  prefs: []
  type: TYPE_NORMAL
- en: Let's dig a bit deeper into fragments, one feature at a time.
  prefs: []
  type: TYPE_NORMAL
- en: Fragments have a life cycle too
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can set up and control fragments, very much like we do with activities, by
    overriding the appropriate lifecycle functions.
  prefs: []
  type: TYPE_NORMAL
- en: The onCreate function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the `onCreate` function, we can initialize variables and do almost all the
    things we typically do in the `Activity onCreate` function. The big exception
    to this is initializing our UI.
  prefs: []
  type: TYPE_NORMAL
- en: The onCreateView function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the `onCreateView` function, we will, as the name suggests, get a reference
    to any of our UI widgets, set up lambdas to listen for clicks, and more besides,
    as we will soon see.
  prefs: []
  type: TYPE_NORMAL
- en: The onAttach and onDetach functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `onAttach` and `onDetach` functions are called just before the `Fragment`
    instance is put into use/taken out of use.
  prefs: []
  type: TYPE_NORMAL
- en: The onStart, onPause, and onStop functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the `onStart`, `onPause`, and `onStop` functions, we can take certain actions,
    such as creating or deleting objects or saving data, just like we did with their
    activity-based counterparts.
  prefs: []
  type: TYPE_NORMAL
- en: There are other fragment lifecycle functions as well, but we know enough to
    start using fragments already. If you want to study the details of the fragment
    lifecycle, you can do so on the Android developer website at [https://developer.android.com/guide/components/fragments](https://developer.android.com/guide/components/fragments).
  prefs: []
  type: TYPE_NORMAL
- en: This is all fine, but we need a way to create our fragments in the first place
    and configure them to respond to these functions.
  prefs: []
  type: TYPE_NORMAL
- en: Managing fragments with FragmentManager
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `FragmentManager` class is part of the `Activity` class. We use it to initialize
    a `Fragment` instance, add `Fragment` instances to the layout, and end a `Fragment`.
    We briefly saw `FragmentManager` before when we initialized our `FragmentDialog`
    instances in the Note to self app.
  prefs: []
  type: TYPE_NORMAL
- en: It is very hard to learn much about Android without bumping into the `Fragment`
    class, just as it is tough to learn much about Kotlin without constantly bumping
    into OOP, classes, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The highlighted code in the following code snippet is a reminder of how we
    used the `FragmentManager` (which is already a part of the `Activity` class) that''s
    being passed in as an argument to create the pop-up dialog:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: At the time, I asked you not to concern yourself with the arguments of the function
    call. The second argument of the call is an ID for the `Fragment`. We will soon
    see how we can use `FragmentManager` and the `Fragment` ID more extensively.
  prefs: []
  type: TYPE_NORMAL
- en: The `FragmentManager` does exactly what its name suggests. What is important
    here is that an `Activity` only has one `FragmentManager`, but it can take care
    of many `Fragment` instances. This is just what we need in order to have multiple
    behaviors and layouts within a single app.
  prefs: []
  type: TYPE_NORMAL
- en: The `FragmentManager` also calls the various lifecycle functions of the fragments
    it is responsible for. This is distinct from the `Activity` lifecycle functions,
    which are called by Android, yet it is also closely related because the `FragmentManager`
    calls many of the `Fragment` lifecycle functions *in response to* the `Activity`
    lifecycle functions being called. As usual, we don't need to worry too much about
    when and how it does this, provided we respond appropriately in each situation.
  prefs: []
  type: TYPE_NORMAL
- en: Our first fragment app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's build a fragment in its simplest possible form so that we can understand
    what is going on, before we start producing `Fragment` objects all over the place
    that are of genuine use.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I urge all readers to go through and build this project. There is a lot of jumping
    around from file to file, and just reading the instructions alone can make it
    seem more complex than it really is. Certainly, you can copy and paste the code
    from the download bundle, but please also follow the steps, and create your own
    projects and classes. Fragments are not too tough, but their implementation, like
    their name suggests, is a little fragmented.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new project called `Simple Fragment` using the **Empty Activity** template
    and leave the rest of the settings at their defaults.
  prefs: []
  type: TYPE_NORMAL
- en: Note that there is the option to create a project with a fragment, but we will
    learn more by doing things ourselves from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: Switch to `activity_main.xml` and delete the default **Hello world!** `TextView`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, make sure that the root `ConstraintLayout` is selected by left-clicking
    it in the **Component tree** window, and then change its **id** property to `fragmentHolder`.
    We will now be able to get a reference to this layout in our Kotlin code, and,
    as the **id** property implies, we will be adding a fragment to it.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will create a layout that will define our fragment's appearance. Right-click
    the `layout` folder and choose **New | Layout resource file**. In the **File name:**
    field, type `fragment_layout` and left-click **OK**. We have just created a new
    layout of the `LinearLayout` type.
  prefs: []
  type: TYPE_NORMAL
- en: Add a single **Button** widget anywhere on the layout and make its **id** property
    `button`.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a simple layout for our fragment to use, let's write some Kotlin
    code to make the actual fragment.
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can create a `Fragment` instance by simply dragging and dropping
    one from the palette, but doing things that way is much less flexible and controllable,
    and flexibility and control are the big benefits of using fragments, as we will
    see throughout this and the next three chapters. By creating a class that extends
    `Fragment`, we can make as many fragments from it as we like.
  prefs: []
  type: TYPE_NORMAL
- en: In the project explorer, right-click the folder that contains the `MainActivity`
    file. From the context menu, create a new Kotlin class called `SimpleFragment`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our new `SimpleFragment` class, change the code to inherit from `Fragment`.
    As you type the code, you will be asked to choose the specific `Fragment` class
    to import, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Our first fragment app](img/B12806_24_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Choose the top option (as shown in the preceding screenshot), which is the regular
    `Fragment` class.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We will need all of the following import statements in this class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This is what the code looks like at this stage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, add a single `String` property called `myString` and initialize it, as
    shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: When using `Fragment`, we need to handle the layout in the `onCreateView` function.
    Let's override that now and learn how we can set the view and get a reference
    to our `Button`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to the `SimpleFragment` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'To understand the previous block of code, we must first look at the `onCreateView`
    signature. Note that in the first instance, the signature states that it must
    return an object of the `View` type, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have the three parameters. Let''s look at the first two:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We need a `LayoutInflater`, as we cannot call `setContentView` because `Fragment`
    provides no such function. In the body of `onCreateView`, we use the `inflate`
    function of `inflater` to inflate our layout contained in `fragment_layout.xml`
    and initialize `view` (an object of the `View type`) with the result.
  prefs: []
  type: TYPE_NORMAL
- en: We use `container`, which was passed into `onCreateView`, as an argument in
    the `inflate` function as well. The `container` variable is a reference to the
    layout in `activity_main.xml`.
  prefs: []
  type: TYPE_NORMAL
- en: It might seem obvious that `activity_main.xml` is the containing layout, but,
    as we will see later in this chapter, the `ViewGroup container` argument allows
    *any* `Activity` with *any* layout to be the container for our fragment. This
    is exceptionally flexible and makes our `Fragment` code reusable to a significant
    extent.
  prefs: []
  type: TYPE_NORMAL
- en: The third argument we pass into `inflate` is `false`, which means that we don't
    want our layout added immediately to the containing layout. We will do this ourselves
    soon from another part of the code.
  prefs: []
  type: TYPE_NORMAL
- en: The third parameter of `onCreateView` is `Bundle savedInstanceState`, which
    is there to help us maintain the data that our fragments hold.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have an inflated layout contained in `view`, we can use this to
    get a reference to our `Button` widget from the layout and listen for clicks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we use `view` as the return value to the calling code, as required.
    We can set this up as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can add a lambda to listen for clicks on our button in the usual manner.
    In the `onClick` function, we display a pop-up `Toast` message to demonstrate
    that everything is working as expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this code just before the `return` statement in `onCreateView`, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note the use of the `activity` property in `makeText`, which is a reference
    to the `Activity` that contains the `Fragment`. This is required to display a
    `Toast` message.
  prefs: []
  type: TYPE_NORMAL
- en: We can't run our app just yet; it will not work because there is one more step
    required. We need to create an instance of `SimpleFragment` and initialize it
    appropriately. This is where `FragmentManager` will get introduced.
  prefs: []
  type: TYPE_NORMAL
- en: The following code uses the `supportFragmentManager` property of `Activity`.
    It creates a new `Fragment`, based on our `SimpleFragment` class, using the `findFragmentByID`
    function, and passes in the ID of the layout (within the `Activity`) that will
    hold it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this code to the `onCreate` function of `MainActivity.kt`, just after the
    call to `setContentView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, run the app and gaze in wonder at our clickable button that displays a
    message with the `Toast` class, and which took two layouts and two whole classes
    to create:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Our first fragment app](img/B12806_24_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you remember doing this way back in [Chapter 2](ch02.html "Chapter 2. Kotlin,
    XML, and the UI Designer"), *Kotlin, XML, and the UI Designer*, and with far less
    code, then it is clear that we need a fragment reality check to answer the question,
    "Why?"!
  prefs: []
  type: TYPE_NORMAL
- en: Fragment reality check
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, what does this fragment stuff really do for us? Our first fragment mini-app
    would have the same appearance and functionality had we not bothered with the
    fragment at all.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, using the fragment has made the whole thing more complicated! Why would
    we want to do this?
  prefs: []
  type: TYPE_NORMAL
- en: We kind of know the answer to this already; it just isn't especially clear based
    on what we have seen so far. We know that a fragment, or fragments, can be added
    to the layout of an activity.
  prefs: []
  type: TYPE_NORMAL
- en: We know that a fragment not only contains its own layout (view), but also its
    very own code (controller), which, although hosted by an activity, is virtually
    independent.
  prefs: []
  type: TYPE_NORMAL
- en: Our quick app only showed one fragment in action, but we could have an activity
    that hosts two or more fragments. We then effectively have two almost independent
    controllers displayed on a single screen. This sounds like it could be useful.
  prefs: []
  type: TYPE_NORMAL
- en: What is most useful about this, however, is that when the activity starts, we
    can detect attributes of the device our app is running on, perhaps a phone or
    tablet, in portrait or landscape mode. We can then use this information to decide
    to display either just one or two of our fragments simultaneously.
  prefs: []
  type: TYPE_NORMAL
- en: This not only helps us achieve the kind of functionality we discussed in the
    Real- world apps section, at the start of this chapter, but it also allows us
    to do so using the exact same fragment code for both possible scenarios!
  prefs: []
  type: TYPE_NORMAL
- en: This really is the essence of fragments. We create a whole app by pairing up
    both functionality (controller) and appearance (view) into a bunch of fragments
    that we can reuse in different ways, almost without a care.
  prefs: []
  type: TYPE_NORMAL
- en: The missing link is that if all these fragments are fully-functioning, independent
    controllers, then we need to learn a bit more about how we can implement our model
    layer.
  prefs: []
  type: TYPE_NORMAL
- en: It is, of course, possible to foresee a few stumbling blocks, so take a look
    at the following frequently asked question.
  prefs: []
  type: TYPE_NORMAL
- en: Frequently asked question
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Q) If we simply have an `ArrayList`, as we did with the Note to self app, where
    will it go? How would we share it between fragments (assuming both/all fragments
    need access to the same data)?
  prefs: []
  type: TYPE_NORMAL
- en: A) There is an entirely more elegant solution we can use to create a model layer
    (both the data itself and the code to maintain the data). We will see this when
    we explore `NavigationDrawer` in [Chapter 26](ch26.html "Chapter 26. Advanced
    UI with Navigation Drawer and Fragment"), *Advanced UI with Navigation Drawer
    and Fragments*, and Android databases in [Chapter 27](ch27.html "Chapter 27. Android
    Databases"), *Android Databases*.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have a broad understanding of what fragments are meant for and how
    we can begin to use them, we can start to go deeper into how they are used. In
    the next chapter, we will make a couple of apps that use multiple fragments in
    different ways.
  prefs: []
  type: TYPE_NORMAL
