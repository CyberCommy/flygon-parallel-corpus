- en: Developing GUI Applications in C++
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: A brief overview of Qt
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Qt Framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing Qt on Ubuntu
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing Qt Core application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing a Qt GUI application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using layouts in the Qt GUI application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding signals and slots for event handling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using multiple layouts in the Qt application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Qt is a cross-platform application framework developed in C++. It is supported
    on various platforms, including Windows, Linux, Mac OS, Android, iOS, Embedded
    Linux, QNX, VxWorks, Windows CE/RT, Integrity, Wayland, X11, Embedded Devices,
    and so on. It is primarily used as a **human-machine-interface** (**HMI**) or
    **Graphical User Interface** (**GUI**) framework; however, it is also used to
    develop a **command-line interface** (**CLI**) applications. The correct way of
    pronouncing Qt is *cute*. The Qt application framework comes in two flavors: open
    source and with a commercial license.'
  prefs: []
  type: TYPE_NORMAL
- en: Qt is the brainchild of Haavard Nord and Eirik Chambe-Eng, the original developers,
    who developed it back in the year 1991.
  prefs: []
  type: TYPE_NORMAL
- en: As C++ language doesn't support GUI natively, you must have guessed that there
    is no event management support in C++ language out of the box. Hence, there was
    a need for Qt to support its own event handling mechanism, which led to the signals
    and slots technique. Under the hood, signals and slots use the **observer design
    pattern** that allows Qt objects to talk to each other. Does this sound too hard
    to understand? No worries! Signals are nothing but events, such as a button click
    or window close, and slots are event handlers that can supply a response to these
    events in the way you wish to respond to them.
  prefs: []
  type: TYPE_NORMAL
- en: To make our life easier in terms of Qt application development, Qt supports
    various macros and Qt-specific keywords. As these keywords will not be understood
    by C++, Qt has to translate them and the macros into pure C++ code so that the
    C++ compiler can do its job as usual. To make this happen in a smoother fashion,
    Qt supports something called **Meta-Object Compiler**, also known as **moc**.
  prefs: []
  type: TYPE_NORMAL
- en: Qt is a natural choice for C++ projects as it is out-and-out C++ code; hence,
    as a C++ developer, you will feel at home when you use Qt in your application.
    A typical application will have both complex logic and impressive UI. In small
    product teams, typically one developer does multiple stuff, which is good and
    bad.
  prefs: []
  type: TYPE_NORMAL
- en: Generally, professional developers have good problem-solving skills. Problem-solving
    skills are essential to solve a complex problem in an optimal fashion with a good
    choice of data structures and algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: Developing an impressive UI requires creative design skills. While there are
    a countable number of developers who are either good at problem-solving or creative
    UI design, not all developers are good at both. This is where Qt stands out.
  prefs: []
  type: TYPE_NORMAL
- en: Say a start-up wants to develop an application for their internal purposes.
    For this, a simple GUI application would suffice, where a decent looking HMI/GUI
    might work for the team as the application is meant for internal purposes only.
    In such scenarios, the entire application can be developed in C++ and the Qt Widgets
    framework. The only prerequisite is that the development team must be proficient
    in C++.
  prefs: []
  type: TYPE_NORMAL
- en: However, in cases where a mobile app has to be developed, an impressive HMI
    becomes mandatory. Again, the mobile app can be developed with C++ and Qt Widgets.
    But now there are two parts to this choice. The good part is that the mobile app
    team has to be good at just C++. The bad part of this choice is that there is
    no guarantee that all good C++ developers will be good at designing a mobile app's
    HMI/GUI.
  prefs: []
  type: TYPE_NORMAL
- en: Let's assume the team has one or two dedicated Photoshop professionals who are
    good at creating catchy images that can be used in the GUI and one or two UI designers
    who can make an impressive HMI/GUI with the images created by the Photoshop experts.
    Typically, UI designers are good at frontend technologies, such as JavaScript,
    HTML, and CSS. Complex business logic can be developed in the powerful Qt Framework,
    while the HMI/GUI can be developed in QML.
  prefs: []
  type: TYPE_NORMAL
- en: QML is a declarative scripting language that comes along with the Qt application
    framework. It is close to JavaScript and has Qt-specific extensions. It is good
    for rapid application development and allows UI designers to focus on HMI/GUI
    and C++ developers to focus on the complex business logic that can be developed
    in Qt Framework.
  prefs: []
  type: TYPE_NORMAL
- en: Since both the C++ Qt Framework and QML are part of the same Qt application
    framework, they go hand in hand seamlessly.
  prefs: []
  type: TYPE_NORMAL
- en: Qt is a vast and powerful framework; hence this chapter will focus on the basic
    essentials of Qt to get you started with Qt. If you are curious to learn more,
    you may want to check out my other upcoming book that I'm working on, namely *Mastering
    Qt and QML Programming*.
  prefs: []
  type: TYPE_NORMAL
- en: Qt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Qt Framework is developed in C++, hence it is guaranteed that it would be
    a cake walk for any good C++ developer. It supports CLI and GUI-based application
    development. At the time of writing this chapter, the latest version of the Qt
    application framework is Qt 5.7.0\. By the time you read this book, it is possible
    that a different version of Qt will be available for you to download. You can
    download the latest version from [https://www.qt.io](https://www.qt.io).
  prefs: []
  type: TYPE_NORMAL
- en: Installing Qt 5.7.0 in Ubuntu 16.04
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this chapter, I'll be using Ubuntu 16.04 OS; however, the programs
    that are listed in this chapter should work on any platform that supports Qt.
  prefs: []
  type: TYPE_NORMAL
- en: For detailed installation instructions, refer to [https://wiki.qt.io/install_Qt_5_on_Ubuntu](https://wiki.qt.io/install_Qt_5_on_Ubuntu).
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, you should have a C++ compiler installed on your system. If
    this is not the case, first ensure that you install a C++ compiler, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'From the Ubuntu Terminal, you should be able to download Qt 5.7.0, as shown
    in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Provide execute permission to the downloaded installer, as shown in the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: I strongly recommend that you install Qt along with its source code. You can
    get help directly from the source code if you prefer to look up Qt Help the geeky
    way.
  prefs: []
  type: TYPE_NORMAL
- en: 'Launch the installer as shown in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'As Qt makes use of OpenGL, make sure you install the following before you start
    writing your first program in Qt. To install `libfontconfig1`, run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'To install `mesa-common-dev`, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, you should have a working Qt setup. You can verify the installation
    by issuing the following command in the Linux Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0b2f4ba7-cd86-4d65-b782-d184577597a1.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.1
  prefs: []
  type: TYPE_NORMAL
- en: 'In case the `qmake` command isn''t recognized, make sure you export the `bin`
    path of the Qt installation folder, as shown in the preceding screenshot. Additionally,
    creating a soft link might be useful too. The command for this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The path where Qt is installed on your system might vary from mine, so please
    substitute the Qt path accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Qt Core
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Qt Core is one of the modules supported by Qt. This module has loads of useful
    classes, such as `QObject`, `QCoreApplication`, `QDebug`, and so on. Almost every
    Qt application will require this module, hence they are linked implicitly by the
    Qt Framework. Every Qt class inherits from `QObject`, and the `QObject` class
    offers event handling support to Qt applications. `QObject` is the critical piece
    that supports the event handling mechanism; interestingly, even console-based
    applications can support event handling in Qt.
  prefs: []
  type: TYPE_NORMAL
- en: Writing our first Qt console application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you get a similar output to that shown in *Figure 5.1*, you are all set
    to get your hands dirty. Let''s write our first Qt application, as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '**![](img/17772c64-4752-40a0-afd1-fea5113595c4.png)**'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.2
  prefs: []
  type: TYPE_NORMAL
- en: In the first line, we have included the QDebug header from the **QtCore** module.
    If you observe closely, the `qDebug()` function resembles the C++ `cout ostream`
    operator. The `qDebug()` function is going to be your good friend in the Qt world
    while you are debugging your code. The `QDebug` class has overloaded the C++ `ostream`
    operator in order to add support for Qt data types that aren't supported by the
    C++ compiler.
  prefs: []
  type: TYPE_NORMAL
- en: In old school fashion, I'm kind of obsessed with the Terminal to achieve pretty
    much anything while coding as opposed to using some fancy **Integrated Development
    Environments** (**IDEs**). You may either love or hate this approach, which is
    quite natural. The good part is there is nothing going to stand between you and
    Qt/C++ as you are going to use plain and simple yet powerful text editors, such
    as Vim, Emacs, Sublime Text, Atom, Brackets, or Neovim, so you will learn almost
    all the essentials of how Qt projects and qmake work; IDEs make your life easy,
    but they hide a lot of the essential stuff that every serious developer must know.
    So it's a trade-off. I leave it to you to decide whether to use your favorite
    plain text editor or Qt Creator IDE or any other fancy IDE. I'm going to stick
    with the refactored Vim editor called Neovim, which looks really cool. *Figure
    5.2* will give you an idea of the Neovim editor's look and feel.
  prefs: []
  type: TYPE_NORMAL
- en: Let's get back to business. Let's see how to compile this code in the command
    line the geeky way. Well, before that, you may want to know about the qmake tool.
    It is a proprietary `make` utility of Qt. The `qmake` utility is nothing more
    than a make tool, but it is aware of Qt-specific stuff so it knows about moc,
    signals, slots, and so on, which a typical `make` utility will be unaware of.
  prefs: []
  type: TYPE_NORMAL
- en: The following command should help you create a `.pro` file. The name of the
    `.pro` file will be decided by the `qmake` utility, based on the project folder
    name. The `.pro` file is the way the Qt Creator IDE combines related files as
    a single project. Since we aren't going to use Qt Creator, we will use the `.pro`
    file to create `Makefile` in order to compile our Qt project just like a plain
    C++ project.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9fcbc0ba-f1d9-437e-a94d-e1741ace3f10.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.3
  prefs: []
  type: TYPE_NORMAL
- en: 'When you issue the `qmake -project` command, qmake will scan through the current
    folder and all the subfolders under the current folder and include the headers
    and source files in `Ex1.pro`. By the way, the `.pro` file is a plain text file
    that can be opened using any text editor, as shown in *Figure 5.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/27b49cc7-7480-4e85-8544-2b986d05d07c.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.4
  prefs: []
  type: TYPE_NORMAL
- en: 'Now it''s time to create `Makefile` taking `Ex1.pro` as an input file. As the
    `Ex1.pro` file is present in the current directory, we don''t have to explicitly
    supply `Ex1.pro` as an input file to autogenerate `Makefile`. The idea is that
    once we have a `.pro` file, all we would need to do is generate `Makefile` from
    the `.pro` file issuing command: `qmake`. This will do all the magic of creating
    a full-blown `Makefile` for your project that you can use to build your project
    with the `make` utility, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b90c5b0d-ed70-4da8-b9f1-072a57b6710b.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.5
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the point we have been waiting for, right? Yes, let''s execute our
    first Qt Hello World program, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1b64726c-933d-4a3a-a527-f691d3feaa60.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.6
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You have completed your first Qt application. In this exercise,
    you learned how to set up and configure Qt in Ubuntu and how to write a simple
    Qt console application and then build and run it. The best part is you learned
    all of this from the command line.
  prefs: []
  type: TYPE_NORMAL
- en: Qt Widgets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Qt Widgets is an interesting module that supports quite a lot of widgets, such
    as buttons, labels, edit, combo, list, dialog, and so on. `QWidget` is the base
    class of all of the widgets, while `QObject` is the base class of pretty much
    every Qt class. While many programming languages refer to as UI controls, Qt refers
    to them as widgets. Though Qt works on many platforms, its home remains Linux;
    widgets are common in the Linux world.
  prefs: []
  type: TYPE_NORMAL
- en: Writing our first Qt GUI application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our first console application is really cool, isn''t it? Let''s continue exploring
    further. This time, let''s write a simple GUI-based Hello World program. The procedure
    will remain almost the same, except for some minor changes in `main.cpp`. Refer
    to the following for the complete code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/07a381bd-7684-4715-b758-d9378575f02f.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.7
  prefs: []
  type: TYPE_NORMAL
- en: Wait a minute. Let me explain the need for `QApplication` in line number 23
    and line number 29\. Every Qt GUI application must have exactly one instance of
    the `QApplication` instance. `QApplication` provides support for command-line
    switches for our application, hence the need to supply the **argument count**
    (**argc**) and the **argument value** (**argv**). GUI-based applications are event-driven,
    so they must respond to events or, to be precise, signals in the Qt world. In
    line number 29, the `exec` function starts the `event` loop, which ensures the
    application waits for user interactions until the user closes the window. The
    idea is that all the user events will be received by the `QApplication` instance
    in an event queue, which will then be notified to its `Child` widgets. The event
    queue ensures all the events deposited in the queue are handled in the same sequence
    that they occur, that is, **first in, first out** (**FIFO**).
  prefs: []
  type: TYPE_NORMAL
- en: In case you are curious to check what would happen if you comment line 29, the
    application will still compile and run but you may not see any window. The reason
    being the `main` thread or the `main` function creates an instance of `QWidget`
    in line number 25, which is the window that we see when we launch the application.
  prefs: []
  type: TYPE_NORMAL
- en: In line number 27, the window instance is displayed, but in the absence of line
    number 29, the `main` function will terminate the application immediately without
    giving a chance for you to check your first Qt GUI application. It's worth trying,
    so go ahead and see what happens with and without line number 29.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s generate `Makefile`, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bf08a1bd-9471-45b3-968e-bbed8c9f8978.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.8
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s try to compile our project with the `make` utility, as shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0d446036-e622-4d5e-8c30-f8f2344e52e0.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.9
  prefs: []
  type: TYPE_NORMAL
- en: 'Interesting, right? Our brand new Qt GUI program fails to compile. Did you
    notice the fatal error? No big deal; let''s understand why this happened. The
    reason is that we have not yet linked the Qt Widgets module, as the `QApplication`
    class is part of the Qt Widgets module. In that case, you may wonder how your
    first Hello World program compiled without any issue. In our first program, the `QDebug`
    class was part of the **QtCore** module that got linked implicitly, whereas other
    modules had to be linked explicitly. Let''s see how to get this done:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/31f35928-8459-43d6-8dc6-a686bd6a22ec.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.10
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to add `QT += widgets` to the `Ex2.pro` file so that the `qmake` utility
    understands that it needs to link Qt Widgets''s **shared object** (the `.so` file)
    in Linux, also known as the **Dynamic Link Library** (the `.dll` file) in Windows,
    while creating the final executable. Once this is taken care of, we must `qmake` so
    that `Makefile` could reflect the new change in our `Ex2.pro` file, as demonstrated
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9fc484e6-678d-4f37-bfc0-dd8861b9e6e9.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.11
  prefs: []
  type: TYPE_NORMAL
- en: 'Cool. Let''s check our first GUI-based Qt app now. In my system, the application
    output looks as shown in *Figure 5.12;* you should get a similar output as well if
    all goes well at your end:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9b9a237a-4c8d-43c2-809b-827f2e0558ff.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.12
  prefs: []
  type: TYPE_NORMAL
- en: 'It would be nice if we set the title of our window as `Hello Qt`, right? Let''s
    do this right away:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8b0e0f02-dc79-4f13-9f03-835d7126d6a5.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.13
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the code presented at line number 26 to ensure you build your project with
    the `make` utility before you test your new change:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/60c83655-7c91-4928-a48b-d833d29478d8.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.14
  prefs: []
  type: TYPE_NORMAL
- en: Layouts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Qt is cross-platform application framework, hence it supports concepts such
    as layouts for developing applications that look consistent in all platforms,
    irrespective of the different screen resolutions. When we develop GUI/HMI-based
    Qt applications, an application developed in one system shouldn't appear different
    on another system with a different screen size and resolution. This is achieved
    in the Qt Framework via layouts. Layouts come in different flavors. This helps
    a developer design a professional-looking HMI/GUI by organizing various widgets
    within a window or dialog. Layouts differ in the way they arrange their child
    widgets. While one arranges its child widgets in a horizontal fashion, another
    will arrange them in a vertical or grid fashion. When a window or dialog gets
    resized, the layouts resize their child widgets so they don't get truncated or
    go out of focus.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a GUI application with a horizontal layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's write a Qt application that has a couple of buttons in the dialog. Qt
    supports a variety of useful layout managers that act as an invisible canvas where
    many `QWidgets` can be arranged before they are attached to a window or dialog.
    Each dialog or window can have only one layout. Every widget can be added to only
    one layout; however, many layouts can be combined to design a professional UI.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start writing the code now. In this project, we are going to write code
    in a modular fashion, hence we are going to create three files with the names
    `MyDlg.h`, `MyDlg.cpp`, and `main.cpp`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The game plan is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a single instance of `QApplication`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a custom dialog by inheriting `QDialog`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create three buttons.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a horizontal box layout.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the three buttons to the invisible horizontal box layout.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the horizontal box layout's instance as our dialog's layout.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Show the dialog.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start the event loop on `QApplication`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is important that we follow clean code practices so that our code is easy
    to understand and can be maintained by anyone. As we are going to follow industry
    best practices, let's declare the dialog in a header file called `MyDlg.h`, define
    the dialog in the source file called `MyDlg.cpp`, and use `MyDlg.cpp` in `main.cpp`
    that has the `main` function. Every time `MyDlg.cpp` requires a header file, let's
    make it a practice to include all the headers only in `MyDlg.h`; with this, the
    only header we will see in `MyDlg.cpp` is `MyDlg.h`.
  prefs: []
  type: TYPE_NORMAL
- en: By the way, did I tell you Qt follows the camel casing coding convention? Yes,
    I did mention it right now. By now, you will have observed that all Qt classes
    start with the letter *Q* because Qt inventors loved the letter "Q" in Emacs and
    they were so obsessed with that font type that they decided to use the letter
    Q everywhere in Qt.
  prefs: []
  type: TYPE_NORMAL
- en: 'One last suggestion. Wouldn''t it be easy for others to locate the dialog class
    if the name of the file and the name of the class were similar? I can hear you
    say yes. All set! Let''s start coding our Qt application. First, refer to the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/01449c0c-d8cc-49ab-88f5-c93ee98feea1.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.15
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding screenshot, we declared a class with the name `MyDlg`. It
    has one layout, three buttons, and a constructor. Now refer to this screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/388777d7-05fd-4a99-b1c9-52737aa5a452.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.16
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see in the preceding screenshot, we defined the `MyDlg` constructor
    and instantiated the layout and the three buttons. In lines 27 through 29, we
    added three buttons to the layout. In line number 31, we associated the layout
    to our dialog. That''s all it takes. In the following screenshot, we defined our `main` function,
    which creates an instance of `QApplication`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/edcd8936-3b7f-4d0f-bad0-39ecf9eee797.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.17
  prefs: []
  type: TYPE_NORMAL
- en: 'We followed this up by creating our custom dialog instance and displaying the
    dialog. Finally, at line 27, we started the `event` loop so that `MyDlg` could
    respond to user interactions. Refer to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8584c26a-43b1-4414-9e26-8460a5c0c24f.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.18
  prefs: []
  type: TYPE_NORMAL
- en: The preceding screenshot demonstrates the build and execution procedures, and
    there is our cute application. Actually, you can try playing with the dialog to
    understand the horizontal layout better. First, stretch the dialog horizontally
    and notice all the buttons' width increase; then, see whether you can reduce the
    dialog's width to notice all the buttons' width decrease. That's the job of any
    layout manager. A layout manager arranges widgets and retrieves the size of the
    window and divides the height and width equally among all its child widgets. Layout
    managers keep notifying all their child widgets about any resize events. However,
    it is up to the respective child widget to decide whether they want to resize
    themselves or ignore the layout resize signals.
  prefs: []
  type: TYPE_NORMAL
- en: To check this behavior, try stretching out the dialog vertically. As you increase
    the height of the dialog, the dialog's height should increase, but the buttons
    will not increase their height. This is because every Qt Widget has its own preferred
    size policy; as per their size policy, they may respond or ignore certain layout
    resize signals.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want the buttons to stretch vertically as well, `QPushButton` offers
    a way to get this done. In fact, `QPushButton` extends from `QWidget` just like
    any other widget. The `setSizePolicy()` method comes to `QPushButton` from its
    base class, that is, `QWidget`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ccfeabfa-d590-4456-9b8b-f6f6f3258623.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.19
  prefs: []
  type: TYPE_NORMAL
- en: Did you notice line number 37? Yes, I have set the window title within the constructor
    of `MyDlg` to keep our `main` function compact and clean.
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure you have built your project using the `make` utility before launching
    your application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/89368655-a31e-4011-a774-cb04fd88e28b.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.20
  prefs: []
  type: TYPE_NORMAL
- en: 'In the highlighted section, we have overridden the default size policy of all
    the buttons. In line number 27, the first parameter `QSizePolicy::Expanding` refers
    to the horizontal policy and the second parameter refers to the vertical policy.
    To find other possible values of `QSizePolicy`, refer to the assistant that comes
    in handy with the Qt API reference, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7cb0d5de-7fbf-4099-b8da-a548569f6208.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.21
  prefs: []
  type: TYPE_NORMAL
- en: Writing a GUI application with a vertical layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, you learned how to use a horizontal box layout. In
    this section, you will see how to use a vertical box layout in your application.
  prefs: []
  type: TYPE_NORMAL
- en: As a matter of fact, the horizontal and vertical box layouts vary only in terms
    of how they arrange the widgets. For instance, the horizontal box layout will
    arrange its child widgets in a horizontal fashion from left to right, whereas
    the vertical box layout will arrange its child widgets in a vertical fashion from
    top to bottom.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can copy the source code from the previous section, as the changes are
    minor in nature. Once you have copied the code, your project directory should
    look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c79ef261-34b6-44bc-b475-a8cf4b911e2d.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.22
  prefs: []
  type: TYPE_NORMAL
- en: 'Let me demonstrate the changes starting from the `MyDlg.h` header file, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/314e2d11-bb5a-49e1-8e07-e22b7882adc9.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.23
  prefs: []
  type: TYPE_NORMAL
- en: 'I have replaced `QHBoxLayout` with `QVBoxLayout`; that is all. Yes, let''s
    proceed with file changes related to `MyDlg.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bf52c7e3-ddaa-4000-824a-20c60dde8836.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.24
  prefs: []
  type: TYPE_NORMAL
- en: 'There are no changes to be done in `main.cpp`; however, I have shown `main.cpp`
    for your reference, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2819fa5e-adc9-47af-a302-7025f39bcbbb.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.25
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we need to do is autogenerate `Makefile` and then make and run the
    program as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/24383093-c366-4be3-a4d2-ee8c3645aadb.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.26
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s execute our brand new program and check the output. The following output
    demonstrates that `QVBoxLayout` arranges the widgets in a vertical top to bottom
    fashion. When the window is stretched, all the buttons'' width will increase/decrease
    depending on whether the window is stretched out or stretched in:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ad04f0f0-a3ba-4de1-b4fc-eed6927d8360.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.27
  prefs: []
  type: TYPE_NORMAL
- en: Writing a GUI application with a box layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous sections, you learned how to make use of `QHBoxLayout` and `QVBoxLayout`.
    Actually, these two classes are the convenience classes for `QBoxLayout`**.**
    In the case of `QHBoxLayout`, the `QHBoxLayout` class has subclassed `QBoxLayout`
    and configured `QBoxLayout::Direction` to `QBoxLayout::LeftToRight`, whereas the `QVBoxLayout`
    class has subclassed `QBoxLayout` and configured `QBoxLayout::Direction` to `QBoxLayout::TopToBottom`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Apart from these values, `QBoxLayout::Direction` supports various other values,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`QBoxLayout::LeftToRight`: This arranges the widgets from left to right'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QBoxLayout::RightToLeft`: This arranges the widgets from right to left'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QBoxLayout::TopToBottom`: This arranges the widgets from top to bottom'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`QBoxLayout::BottomToTop`: This arranges the widgets from bottom to top'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's write a simple program using `QBoxLayout` with five buttons.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the `MyDlg.h` header file. I have declared five button pointers
    in the `MyDlg` class and a `QBoxLayout` pointer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2edce8e9-ff7e-472a-80b3-12bf0af60d34.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.28
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at our `MyDlg.cpp` source file. If you notice line number
    21 in the following screenshot, the `QBoxLayout` constructor takes two arguments.
    The first argument is the direction in which you wish to arrange the widgets and
    the second argument is an optional argument that expects the parent address of
    the layout instance.
  prefs: []
  type: TYPE_NORMAL
- en: As you may have guessed, the `this` pointer refers to the `MyDlg` instance pointer,
    which happens to be the parent of the layout.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4aa8c13b-aefc-4cff-883c-be180daac1e9.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.29
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, as you may have guessed, the `main.cpp` file isn''t going to change
    from our past exercises, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e999e104-0a48-435e-a458-f18c473c668b.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.30
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s compile and run our program, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/742ca3a6-8db9-470b-b9d9-5e95f7b1d9a8.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.31
  prefs: []
  type: TYPE_NORMAL
- en: 'If you notice the output, it looks like a horizontal box layout output, right?
    Exactly, because we have set the direction to `QBoxLayout::LeftToRight`. If you
    modify the direction to, say, `QBoxLayout::RightToLeft`, then Button 1 would appear
    on the right-hand side, Button 2 would appear on the left-hand side of Button
    1, and so on. Hence, the output would look as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If the direction is set to `QBoxLayout::RightToLeft`, you''ll see the following
    output:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/e7d530e9-3822-4e9e-a26c-f9e335475df6.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.32
  prefs: []
  type: TYPE_NORMAL
- en: 'If the direction is set to `QBoxLayout::TopToBottom`, you''ll see the following
    output:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/01f3d529-5758-4182-a6f7-d9f4c497ee36.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.33
  prefs: []
  type: TYPE_NORMAL
- en: 'If the direction is set to `QBoxLayout::BottomToTop`, you''ll see the following
    output:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/2b8fd5b6-2899-4fb3-81ba-c85dfbb3c7c9.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.34
  prefs: []
  type: TYPE_NORMAL
- en: In all the preceding scenarios, the buttons are added to the layout exactly
    in the same sequence, starting from Button 1 through Button 5, respectively. However,
    depending on the direction chosen in the `QBoxLayout` constructor, the box layout
    will arrange the buttons, hence the difference in the output.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a GUI application with a grid layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A grid layout allows us to arrange widgets in a tabular fashion. It is quite
    easy, just like a box layout. All we need to do is indicate the row and column
    where each widget must be added to the layout. As the row and column index starts
    from a zero-based index, the value of row 0 indicates the first row and the value
    of column 0 indicates the first column. Enough of theory; let's start writing
    some code.
  prefs: []
  type: TYPE_NORMAL
- en: Let's declare 10 buttons and add them in two rows and five columns. Other than
    the specific `QGridLayout` differences, the rest of the stuff will remain the
    same as the previous exercises, so go ahead and create `MyDlg.h`**, **`MyDl.cpp`,
    and `main.cpp` if you have understood the concepts discussed so far.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let me present the `MyDlg.h` source code in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/863326d6-1360-4ce2-b3b8-a1bf5b3725b3.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.35
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the code snippet of `MyDlg.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0e8dfc86-ee70-4c4f-a55f-1ea4fa1cedd9.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.36
  prefs: []
  type: TYPE_NORMAL
- en: The `main.cpp` source file content will remain the same as our previous exercises;
    hence, I have skipped the `main.cpp` code snippet. As you are familiar with the
    build process, I have skipped it too. If you have forgotten about this, just check
    the previous sections to understand the build procedure.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have typed the code correctly, you should get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b0fe0162-c162-4aa2-aeca-f548532f7789.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.37
  prefs: []
  type: TYPE_NORMAL
- en: Actually, the grid layout has more stuff to offer. Let's explore how we can
    make a button span across multiple cells. I guarantee what you are about to see
    is going to be more interesting.
  prefs: []
  type: TYPE_NORMAL
- en: 'I''m going to modify `MyDlg.h` and `MyDlg.cpp` and keep `main.cpp` the same
    as the previous exercises:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/41efa017-2b43-49b6-b2fd-bb0afcf8c63e.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.38
  prefs: []
  type: TYPE_NORMAL
- en: 'Here goes our `MyDlg.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ef957ac5-1cbe-4a32-87ff-6c183038f0f7.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.39
  prefs: []
  type: TYPE_NORMAL
- en: Notice the lines 35 through 38\. Let's discuss the `addWidget()` function in
    detail now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In line number 35, the `pLayout->addWidget ( pBttn1, 0, 0, 1, 1 )` code does
    the following things:'
  prefs: []
  type: TYPE_NORMAL
- en: The first three arguments add Button 1 to the grid layout at the first row and
    first column
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fourth argument `1` instructs that Button 1 will occupy just one row
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fifth argument `1` instructs that Button 1 will occupy just one column
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hence, it's clear that `pBttn1` should be rendered at cell (0, 0) and it should
    occupy just one grid cell
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In line number 36, the `pLayout->addWidget ( pBttn2, 0, 1, 1, 2 )` code does
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The first three arguments add `Button 2` to the grid layout at the first row
    and second column
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fourth argument instructs that `Button 2` will occupy one row
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fifth argument instructs that `Button 2` will occupy two columns (that is,
    the second column and the third column in the first row)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At the bottom line, Button 2 will be rendered at cell (0,1) and it should occupy
    one row and two columns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In line number 37, the `pLayout->addWidget ( pBttn3, 0, 3, 2, 1 )` code does
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The first three arguments add Button 3 to the grid layout at the first row and
    fourth column
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fourth argument instructs that Button 3 will occupy two rows (that is, the
    first row and the fourth column and the second row and the fourth column)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fifth argument instructs that Button 3 will occupy one column
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In line number 38, the `pLayout->addWidget ( pBttn4, 1, 0, 1, 3 )` code does
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The first three arguments add Button 4 to the grid layout at the second row
    and first column
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fourth argument instructs that Button 4 will occupy one row
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fifth argument instructs that Button 4 will occupy three columns (that is,
    the second row first, then the second and third column)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Check out the output of the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bf9c1280-349d-42fd-958d-6ee93db547b9.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.40
  prefs: []
  type: TYPE_NORMAL
- en: Signals and slots
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Signals and slots are an integral part of the Qt Framework. So far, we have
    written some simple but interesting Qt applications, but we haven't handled events.
    Now it's time to understand how to support events in our application.
  prefs: []
  type: TYPE_NORMAL
- en: Let's write a simple application with just one button. When the button is clicked,
    check whether we can print something on the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `MyDlg.h` header demonstrates how the `MyDlg` class shall be declared:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6d340f6a-76c4-4889-8adf-8670c32149a3.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.41
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot demonstrates how the `MyDlg` constructor shall be
    defined to add a single button to our dialog window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e476f68c-0cd6-4fc5-b722-e5f5178465cf.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.42
  prefs: []
  type: TYPE_NORMAL
- en: 'The `main.cpp` looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/46510322-00a5-434a-ae4a-3b47fdbc6a36.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.43
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s build and run our program and later add support for signals and slots.
    If you have followed the instructions correctly, your output should resemble the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/92f395d6-c157-4c55-92bf-c2faccdb77d0.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.44
  prefs: []
  type: TYPE_NORMAL
- en: If you click on the button, you will notice that nothing happens, as we are
    yet to add support for signals and slots in our application. Okay, it's time to
    reveal the secret instruction that will help you make the button respond to a
    button-click signal. Hold on, it's time for some more information. Don't worry, it's
    related to Qt.
  prefs: []
  type: TYPE_NORMAL
- en: Qt signals are nothing but events, and slot functions are event handler functions.
    Interestingly, both signals and slots are normal C++ functions; only when they
    are marked as signals or slots, will the Qt Framework understand their purpose
    and provide the necessary boilerplate code.
  prefs: []
  type: TYPE_NORMAL
- en: Every widget in Qt supports one or more signal and may also optionally support
    one or more slot. So let's explore which signals `QPushButton` supports before
    we write any further code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s make use of the Qt assistant for API reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ce2e7532-cc6b-48e1-8d08-6d0e7e04c7fe.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.45
  prefs: []
  type: TYPE_NORMAL
- en: 'If you observe the preceding screenshot, it has a Contents section that seems
    to cover Public Slots, but we don''t see any signals listed there. That''s a lot
    of information. If the Contents section doesn''t list out signals, `QPushButton` wouldn''t
    support signals directly. However, maybe its base class, that is, `QAbstractButton`,
    would support some signals. The `QPushButton` class section gives loads of useful
    information, such as the header filename, which Qt module must be linked to the
    application--that is, qmake entries that must be added to `.pro`--and so on. It
    also mentions the base class of `QPushButton`. If you scroll down further, your
    Qt assistant window should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fe870f4e-5b3c-43ad-93ad-664b4a496456.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.46
  prefs: []
  type: TYPE_NORMAL
- en: If you observe the highlighted section under Additional Inherited Members, apparently
    the Qt assistant implies that `QPushButton` has inherited four signals from `QAbstractButton`.
    So we need to explore the signals supported by `QAbstractButton` in order to support
    the signals in `QPushButton`.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ad8ebd1d-7061-4c54-8b6b-1c27cf8d5b17.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.47
  prefs: []
  type: TYPE_NORMAL
- en: With the help of the Qt assistant, as shown in the preceding screenshot, it
    is evident that the `QAbstractButton` class supports four signals that are also
    available for `QPushButton`, as `QPushButton` is a child class of `QAbstractButton`.
    So let's use the `clicked()` signal in this exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to make some minor changes in `MyDlg.h` and `MyDlg.cpp` in order to
    use the `clicked()` signal. Hence, I have presented these two files with changes
    highlighted in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f915e03d-bbc3-4d57-90b6-37bd752bec05.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.48
  prefs: []
  type: TYPE_NORMAL
- en: As you are aware, the `QDebug` class is used for debugging purposes. It offers
    functionalities to Qt applications that are similar to `cout`, but they aren't
    really required for signals and slots. We are using them here just for debugging
    purposes. In *Figure 5.48*, line number 34, void `MyDlg::onButtonClicked()` is
    our slot function that we are intending to use as an event handler function that
    must be invoked in response to the button click.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot should give you an idea of what changes you will have
    to perform in `MyDlg.cpp` for signal and slot support:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/89b96bab-3c35-42b4-a1f4-2734ea8a7228.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.49
  prefs: []
  type: TYPE_NORMAL
- en: If you observe line 40 through 42 in the preceding screenshot, the `MyDlg::onButtonClicked()`
    method is a slot function that must be invoked whenever the button is clicked.
    But unless the button's `clicked()` signal is mapped to the `MyDlg::onButtonClicked()` slot,
    the Qt Framework wouldn't know that it must invoke `MyDlg::onButtonClicked()`
    when the button is clicked. Hence, in line numbers 32 through 37, we have connected
    the button signal `clicked()` with the `MyDlg` instance's `onButtonClicked()`
    slot function. The connect function is inherited by `MyDlg` from `QDialog`. This,
    in turn, has inherited the function from its ultimate base class, called `QObject`.
  prefs: []
  type: TYPE_NORMAL
- en: The mantra is that every class that would like to participate in signal and
    slot communication must be either `QObject` or its subclass. `QObject` offers
    quite a good amount of signal and slot support, and `QObject` is part of the `QtCore`
    module. What's amazing is that the Qt Framework has made signal and slot available
    to even command-line applications. This is the reason signals and slots support
    is built into the ultimate base class `QObject`, which is part of the **QtCore**
    module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, let''s build and run our program and see whether the signals work in
    our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/88c3c117-2e98-44c0-96b8-c94ccc793062.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.50
  prefs: []
  type: TYPE_NORMAL
- en: Interestingly, we don't get a compilation error, but when we click on the button,
    the highlighted warning message appears automatically. This is a hint from the
    Qt Framework that we have missed out on an important procedure that is mandatory
    to make signals and slots work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s recollect the procedure we followed to autogenerate `Makefile` in our
    headers and source files:'
  prefs: []
  type: TYPE_NORMAL
- en: The `qmake -project` command ensures that all the header files and source files
    that are present in the current folder are included in the `.pro` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `qmake` command picks up the `.pro` file present in the current folder and
    generates `Makefile` for our project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `make` commandwill invoke the `make` utility. It then executes `Makefile`
    in the current directory and builds our project based on the make rules defined
    in `Makefile`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In step 1, the `qmake` utility scans through all our custom header files and
    checks whether they need signal and slot support. Any header file that has the `Q_OBJECT`
    macro hints the `qmake` utility that it needs signal and slot support. Hence we
    must use the `Q_OBJECT` macro in our `MyDlg.h` header file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c609e242-3a7c-47a3-bf36-102d9a114c53.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.51
  prefs: []
  type: TYPE_NORMAL
- en: Once the recommended changes are done in the header file, we need to ensure
    that the `qmake` command is issued. Now the `qmake` utility will open the `Ex8.pro`
    file to get our project headers and source files. When `qmake` parses `MyDlg.h`
    and finds the `Q_OBJECT` macro, it will learn that our `MyDlg.h` requires signals
    and slots, then it will ensure that the moc compiler is invoked on `MyDlg.h` so
    that the boilerplate code can be autogenerated in a file called `moc_MyDlg.cpp`. This
    will then go ahead and add the necessary rules to `Makefile` so that the autogenerated
    `moc_MyDlg.cpp` file gets built along with the other source files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you know the secrets of Qt signals and slots, go ahead and try out
    this procedure and check whether your button click prints the Button clicked ... message.
    I have gone ahead and built our project with the changes recommended. In the following
    screenshot, I have highlighted the interesting stuff that goes on behind the scenes;
    these are some of the advantages one would get when working in the command line
    versus using fancy IDEs:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cc70f3aa-1d19-46b0-8387-b536c9a354ae.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.52
  prefs: []
  type: TYPE_NORMAL
- en: 'Now it''s time that we test the output of our cool and simple application that
    supports signals and slots. The output is presented in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/603ec985-f698-49bf-9ee8-63f7550d9bae.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.53
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You can pat your back. You have learned enough to do cool stuff
    in Qt.
  prefs: []
  type: TYPE_NORMAL
- en: Using stacked layout in Qt applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you have learned about signals and slots, in this section, let's explore
    how to use a stacked layout in an application that has multiple windows; each
    window could be either a **QWidget** or **QDialog.** Each page may have its own
    child widgets. The application we are about to develop will demonstrate the use
    of a stacked layout and how to navigate from one window to the other within the
    stacked layout.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/935df883-b771-4cf5-96bd-b4cbd5d7165c.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.54
  prefs: []
  type: TYPE_NORMAL
- en: This application is going to require a decent amount of code, hence it is important
    that we ensure our code is structured carefully so that it meets both the structural
    and functional quality, avoiding code smells as much as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Let's create four widgets/windows that could be stacked up in a stacked layout,
    where each page could be developed as a separate class split across two files: `HBoxDlg.h`
    and `HBoxDlg.cpp` and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with `HBoxDlg.h`. As you are familiar with layouts, in this exercise,
    we are going to create each dialog with one layout so that while navigating between
    the subwindows, you can differentiate between the pages. Otherwise, there will
    be no connection between the stacked layout and other layouts as such.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2aea2186-e099-4660-bc7e-111cfc2fd449.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.55
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet is from the `HBoxDlg.cpp` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/aeb95ddf-262e-4055-8cbc-1e1294272f7d.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.56
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, let''s write `VBoxDlg.h` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dba374ca-cccd-4d62-a17c-e0443e24f94e.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.57
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create the third dialog `BoxDlg.h` with a box layout, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6aa043a4-7eee-4cdf-a456-13a2ccadf497.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.58
  prefs: []
  type: TYPE_NORMAL
- en: 'The respective `BoxDlg.cpp` source file will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c299d866-fdd1-4e52-9b7d-2ee0b5fb5d9a.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.59
  prefs: []
  type: TYPE_NORMAL
- en: 'The fourth dialog that we would like to stack up is `GridDlg`, so let''s see
    how `GridDlg.h` can be written, which is illustrated in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/75120737-fe0e-402a-b218-18eb21906a61.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.60
  prefs: []
  type: TYPE_NORMAL
- en: 'The respective `GridDlg.cpp` will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d73646f0-1461-4759-ac87-4b4c3c6dde92.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.61
  prefs: []
  type: TYPE_NORMAL
- en: Cool, we are done with creating four widgets that can be stacked up in `MainDlg`.
    `MainDlg` is the one that's going to use `QStackedLayout`, so the crux of this
    exercise is understanding how a stacked layout works.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how `MainDlg.h` shall be written:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/29eecb61-f873-4be2-8df3-6df5d52f26a6.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.62
  prefs: []
  type: TYPE_NORMAL
- en: In `MainDlg`, we have declared three slot functions, one for each button, in
    order to support the navigation logic among the four windows. A stacked layout
    is similar to a tabbed widget, except that a tabbed widget will provide its own
    visual way to switch between the tabs, whereas in the case of a stacked layout,
    it is up to us to provide the switching logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `MainDlg.cpp` will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2faacb2d-ee1a-4fb8-950a-a28a9eb4d3e0.png)Figure 5.63'
  prefs: []
  type: TYPE_NORMAL
- en: You can choose a box layout to hold the three buttons, as we prefer buttons aligned
    to the right. However, in order to ensure that extra spaces are consumed by some
    invisible glue, we have added a stretch item at line number 44.
  prefs: []
  type: TYPE_NORMAL
- en: Between lines 30 through 33, we have added all the four subwindows in a stacked
    layout so that windows can be made visible one at a time. The `HBox` dialog is
    added at index 0, the `VBox` dialog is added at index 1, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lines 53 through 58 demonstrate how the previous button''s clicked signal is
    wired with its corresponding `MainDlg::onPrevPage()` slot function. Similar connections
    must be configured for next and exit buttons:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/61a0e9cf-28b8-450b-9c2a-be944501b388.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.64
  prefs: []
  type: TYPE_NORMAL
- en: The `if` condition in line 78 ensures that the switching logic happens only
    if we are in the second or later subwindows. As the horizontal dialog is at index
    0, we can't navigate to the previous window in cases where the current window
    happens to be a horizontal dialog. A similar validation is in place for switching
    to the next subwindow in line 85.
  prefs: []
  type: TYPE_NORMAL
- en: The stacked layout supports the `setCurrentIndex()` method to switch to a particular
    index position; alternatively, you could try the `setCurrentWidget()` method as
    well if it works better in your scenario.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `main.cpp` looks short and simple, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7b477938-f928-40d0-8dae-73b39d05d476.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.65
  prefs: []
  type: TYPE_NORMAL
- en: The best part of our `main` function is that irrespective of the complexity
    of the application logic, the `main` function doesn't have any business logic.
    This makes our code clean and easily maintainable.
  prefs: []
  type: TYPE_NORMAL
- en: Is code coverage metrics good or bad?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Code coverage tools help developers identify gaps in their automated test cases.
    No doubt, many times it will give a clue about missing test scenarios, which would
    eventually further strengthen the automated test cases. But when an organization
    starts enforcing code coverage as a measure to check the effectiveness of test
    coverage, it sometimes drives the developers in the wrong direction. From my practical
    consulting experience, what I have learned is that many developers start writing
    test cases for constructors and private and protected functions to show higher
    code coverage. In this process, developers start chasing numbers and lose the
    ultimate goal of TDD.
  prefs: []
  type: TYPE_NORMAL
- en: In a particular source with a class that has 20 methods, it is possible that
    only 10 methods qualify for unit testing while the other methods are complex functionality.
    In such a case, the code coverage tools will show only 50 percent code coverage,
    which is absolutely fine as per the TDD philosophy. However, if the organization
    policy enforces a minimum 75 percent code coverage, then the developers will have
    no choice other than testing the constructor, destructor, private, protected,
    and complex functions for the sake of showing good code coverage.
  prefs: []
  type: TYPE_NORMAL
- en: The trouble with testing private and protected methods is that they tend to
    change more often as they are marked as implementation details. When private and
    protected methods change badly, that calls for modifying test cases, which makes
    the developer's life harder in terms of maintaining the test cases.
  prefs: []
  type: TYPE_NORMAL
- en: Hence, code coverage tools are very good developer tools to find test scenario
    gaps, but it should be left to a developer to make a wise choice of whether to
    write a test case or ignore writing test cases for certain methods, depending
    on the complexity of the methods. However, if code coverage is used as project
    metrics, it more often tends to drive developers to find wrong ways to show better
    coverage, leading to bad test case practices.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a simple math application combining multiple layouts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, let''s explore how to write a simple math application. As
    part of this exercise, we will use `QLineEdit` and `QLabel` widgets and `QFormLayout`.
    We need to design a UI, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4100769e-5138-49d9-a251-44d61f3dec11.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.66
  prefs: []
  type: TYPE_NORMAL
- en: '`QLabel` is a widget typically used for static text, and `QLineEdit` will allow
    a user to supply a single line input. As shown in the preceding screenshot, we
    will use `QVBoxLayout` as the main layout in order to arrange `QFormLayout` and
    `QBoxLayout` in a vertical fashion. `QFormLayout` comes in handy when you need
    to create a form where there will be a caption on the left-hand side followed
    by some widget on its right. `QGridLayout` might also do the job, but `QFormLayout`
    is easy to use in such scenarios.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this exercise, we will create three files, namely `MyDlg.h`, `MyDlg.cpp`,
    and `main.cpp`. Let''s start with the `MyDlg.h` source code and then move on to
    other files:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/96ddfeef-c109-419e-b4d9-de12497f3db1.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.67
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding figure, three layouts are declared. The vertical box layout
    is used as the main layout, while the box layout is used to arrange the buttons
    in the right-aligned fashion. The form layout is used to add the labels, that
    is, line edit widgets. This exercise will also help you understand how one can
    combine multiple layouts to design a professional HMI.
  prefs: []
  type: TYPE_NORMAL
- en: Qt doesn't have any documented restriction in the number of layouts that can
    be combined in a single window. However, when possible, it is a good idea to consider
    designing an HMI with a minimal number of layouts if you are striving to develop
    a small memory footprint application. Otherwise, there is certainly no harm in
    using multiple layouts in your application.
  prefs: []
  type: TYPE_NORMAL
- en: In the following screenshot, you will get an idea of how the `MyDlg.cpp` source
    file shall be implemented. In the `MyDlg` constructor, all the buttons are instantiated
    and laid out in the box layout for right alignment. The form layout is used to
    hold the `QLineEdit` widgets and their corresponding `QLabel` widgets in a grid-like
    fashion. `QLineEdit` widgets typically help supply a single line input; in this
    particular exercise, they help us supply a number input that must be added, subtracted,
    and so on, depending on the user's choice.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1bd457e2-cdac-4911-81d9-d95b62776cfc.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.68
  prefs: []
  type: TYPE_NORMAL
- en: The best part of our `main.cpp` source file is that it remains pretty much the
    same, irrespective of the complexity of our application. In this exercise, I would
    like to tell you a secret about `MyDlg`. Did you notice that the `MyDlg` constructor
    is instantiated in the stack as opposed to the heap? The idea is that when the
    `main()` function exits, the stack used by the `main` function gets unwinded,
    eventually freeing up all the stack variables present in the stack. When `MyDlg`
    gets freed up, it results in calling the `MyDlg` destructor. In the Qt Framework,
    every widget constructor takes an optional parent widget pointer, which is used
    by the topmost window destructor to free up its child widgets. Interestingly,
    Qt maintains a tree-like data structure to manage the memory of all its child
    widgets. So, if all goes well, the Qt Framework will take care of freeing up all
    its child widgets' memory locations "automagically".
  prefs: []
  type: TYPE_NORMAL
- en: This helps Qt developers focus on the application aspect, while the Qt Framework
    will take care of memory management.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5a6cf1b9-cb5f-4713-a512-8663c1b63ae6.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.69
  prefs: []
  type: TYPE_NORMAL
- en: 'Aren''t you excited to check the output of our new application? If you build
    and execute the application, then you are supposed to get an output similar to
    the following screenshot**.** Of course, we are yet to add signal and slot support,
    but it''s a good idea to design the GUI to our satisfaction and then shift our
    focus to event handling:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/077b1f99-c166-4c60-832f-0930639075ab.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.70
  prefs: []
  type: TYPE_NORMAL
- en: 'If you observe closely, though the buttons are laid out on `QBoxLayout` in
    the right to left direction, the buttons aren''t aligned to the right. The reason
    for this behavior is when the window is stretched out, the box layout seems to
    have divided and allocated the extra horizontal space available among all the
    buttons. So let''s go ahead and throw in a stretch item to the leftmost position
    on the box layout such that the stretch will eat up all the extra spaces, leaving
    the buttons no room to expand. This will get us the right-aligned effect. After
    adding the stretch, the code will look as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5a935fb3-e5d6-4f0d-be92-494731b793a2.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.71
  prefs: []
  type: TYPE_NORMAL
- en: 'Go ahead and check whether your output looks as shown in the following screenshot.
    Sometimes, as developers, we get excited to see the output in a rush and forget
    to compile our changes, so ensure the project is built again. If you don''t see
    any change in output, no worries; just try to stretch out the window horizontally
    and you should see the right-aligned effect, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/735e0a2a-dc8e-4854-a628-7624502e50a9.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.72
  prefs: []
  type: TYPE_NORMAL
- en: Now since we have a decent-looking application, let's add signal and slot support
    to add the response to button clicks. Let's not rush and include the add and subtract
    functionalities for now. We will use some `qDebug()` print statements to check
    whether the signals and slots are connected properly and then gradually replace
    them with the actual functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you remember the earlier signal and slot exercise, any Qt window that is
    interested in supporting signals and slots must be `QObject` and should include
    the `Q_OBJECT` macro in the `MyDlg.h` header file, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9836047f-2b2b-4b2f-95cd-d3fc669ab05e.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.73
  prefs: []
  type: TYPE_NORMAL
- en: In lines starting from 41 through 45, four slot methods are declared in the
    private section. Slot functions are regular C++ functions that could be invoked
    directly just like other C++ functions. However, in this scenario, the slot functions
    are intended to be invoked only with `MyDlg`. Hence they are declared as private
    functions, but they could be made public if you believe that others might find
    it useful to connect to your public slot.
  prefs: []
  type: TYPE_NORMAL
- en: 'Cool, if you have come this far, it says that you have understood the things
    discussed so far. Alright, let''s go ahead and implement the definitions for the
    slot functions in `MyDlg.cpp` and then connect the `clicked()` button''s signals
    with the respective slot functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9ee7de87-238a-4583-9434-4a81be20275b.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.74
  prefs: []
  type: TYPE_NORMAL
- en: 'Now it''s time to wire up the signals to their respective slots. As you may
    have guessed, we need to use the `connect` function in the `MyDlg` constructor,
    as shown in the following screenshot, to get the button clicks to the corresponding
    slots:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/12f256c1-54b9-41ea-bc82-cac4025cc12c.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.75
  prefs: []
  type: TYPE_NORMAL
- en: 'We are all set. Yes, it''s showtime now. As we have taken care of most of the
    stuff, let''s compile and check the output of our little Qt application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/08f502c2-1d47-4b80-bd4c-6b2ef28bbaa9.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.76
  prefs: []
  type: TYPE_NORMAL
- en: 'Oops! We got some linker error. The root cause of this issue is that we forgot
    to invoke `qmake` after enabling signal and slot support in our application. No
    worries, let''s invoke `qmake` and `make` and run our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0736093f-595d-4648-b932-3a7a4cfa7b37.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.77
  prefs: []
  type: TYPE_NORMAL
- en: 'Great, we have fixed the issue. The make utility doesn''t seem to make any
    noise this time and we are able to launch the application. Let''s check whether
    the signals and slots are working as expected. For this, click on the Add button
    and see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d937f0b1-ee83-4f5c-8f13-1c1cad9a8043.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.78
  prefs: []
  type: TYPE_NORMAL
- en: Wow! When we click on the Add button, the `qDebug()` console message confirms
    that the `MyDlg::onAddButtonClicked()` slot is invoked. If you are curious to
    check the slots of other buttons, go ahead and try clicking on the rest of the
    buttons.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our application will be incomplete without business logic. So let''s add business
    logic to the `MyDlg::onAddButtonClicked()` slot function to perform the addition
    and display the result. Once you learn how to integrate the added business logic,
    you can follow the same approach and implement the rest of the slot functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3b2dccec-e47a-48a1-970d-a5f1ec9ee1d1.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.79
  prefs: []
  type: TYPE_NORMAL
- en: In the `MyDlg::onAddButtonClicked()` function, the business logic is integrated.
    In lines 82 and 83, we are trying to extract the values typed by the user in the
    `QLineEdit` widgets. The `text()` function in `QLineEdit` returns `QString`**.**
    The `QString` object provides `toInt()` that comes in handy to extract the integer
    value represented by `QString`. Once the values are added and stored in the result
    variable, we need to convert the result integer value back to `QString`, as shown
    in line number 86, so that the result can be fed into `QLineEdit`, as shown in
    line number 88.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, you can go ahead and integrate the business logic for other math
    operations. Once you have thoroughly tested the application, you can remove the
    `qDebug()` console's output. We added the `qDebug()` messages for debugging purposes,
    hence they can be cleaned up now.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned developing C++ GUI applications using Qt application
    framework. The key takeaway points are listed below.
  prefs: []
  type: TYPE_NORMAL
- en: You learned installing Qt and required tools in Linux.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You learned writing simple console based application with Qt Framework.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You learned writing simple GUI based applications with Qt Framework.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You learned event handling with Qt Signal and Slots mechanism and how Meta Object
    Compiler helps us generate the crucial boiler plate code required for Signal and
    Slots.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You learned using various Qt Layouts in application development to develop an
    appealing HMI that looks great in many Qt supported platforms.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You learned combining multiple layouts in a single HMI to develop professional
    HMI.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You learned quite a lot of Qt Widgets and how they could help you develop impressive
    HMIs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overall you learned developing cross-platform GUI applications using Qt application
    framework.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next chapter, you will be learning multithread programming and IPC in
    C++.
  prefs: []
  type: TYPE_NORMAL
