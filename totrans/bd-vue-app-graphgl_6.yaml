- en: Creating Chat and Message Vuex, Pages, and Routes
  prefs: 
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will finalize the application and create the final parts.
    This chapter will finish the development of the application, making it ready to
    create a final product for deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Here you will learn how to create GraphQL queries and fragments, create the
    Chat Vuex module and business rules, create the contacts page and components used
    in the page, and finally the messages page with the components needed for creating
    the page.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating GraphQL queries and fragments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the Chat Vuex module on your application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the Contacts page of your application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the Messages page of your application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will be using **Node.js**, **AWS Amplify**,and **Quasar
    Framework**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Attention, Windows users! You need to install an `npm` package called `windows-build-tools`
    to be able to install the required packages. To do it, open PowerShell as an administrator
    and execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '`> npm install -g windows-build-tools`'
  prefs: []
  type: TYPE_NORMAL
- en: 'To install **Quasar Framework**, you need to open Terminal (macOS or Linux)
    or Command Prompt/PowerShell (Windows) and execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'To install **AWS Amplify****,** you need to open Terminal (macOS or Linux)
    or Command Prompt/PowerShell (Windows) and execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Creating GraphQL queries and fragments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In GraphQL, it is possible to create a straightforward query to fetch only the
    data you want. By doing this, your code can reduce the usage of your user network
    and processing power. This technique is also known as **fragments**.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to create GraphQL fragments and use them in
    our application.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The prerequisites for this recipe are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The project from the *Creating User pages and routes for your application* recipe
    in [Chapter 5](39414f7b-02f2-400c-a1e0-0a0cbf12151a.xhtml), *Creating the User
    Vuex Module, Pages, and Routes*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Node.js 12+
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Node.js global objects that are required are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@aws-amplify/cli`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@quasar/cli`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To start our GraphQL fragments that will be used on the application, we will
    continue with the project that we created in [Chapter 5](39414f7b-02f2-400c-a1e0-0a0cbf12151a.xhtml)*,
    Creating the User Vuex Module, Pages, and Routes*.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we will create the fragments needed in our application, and
    replace some of the code that we wrote in the last recipes with the fragments
    created here.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the GraphQL fragments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here we will create all the fragments that we will use in our application:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a file named `fragments.js` in the `src/graphql` folder and open it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, we need to import the `graphql` language interpreter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create the `getUser` fragment to fetch the user information. This fragment
    will get basic information about the user. First, we need to start the `graphql` interpreter,
    and then pass the template literal string with our query. Using the `getUser` query
    as the base query, we will create a query schema with only the data that we want
    to fetch from the server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The template literal in the ES2015 specification provides a new feature called
    tagged templates or tag functions. Those are used to pre-process the string on
    the template literal before using the string that is attached to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we will create the `listUsers` fragment to fetch all the users in our
    application. This fragment will use the `listUsers` query from the base queries
    that were created from AWS Amplify. Then it will return all the current users
    in our application with the basic information from them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'To finish the user fragments, we will create the `getUserAndConversations` fragment
    to fetch the user basic information and their last 10 conversations. This fragment
    is based on the `GetUser` query:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'For fetching the user conversations, we will create a fragment named `getConversation`, based
    on the `GetConversation` query, that gets the last 1,000 messages and the conversation
    members from the user in the current conversation ID:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'To create a new message in our API, we need to create a fragment called `createMessage`.
    This fragment is based on the `CreateMessage` mutation. The fragment will receive `id`, `authorId`, `content`, `messageConversationId`,
    and `createdAt`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'To start a new conversation between two users, we need to create a new fragment
    called `createConversation`. This fragment is based on the `CreateConversation` mutation;
    it will receive the `name` of the conversation, and the `members` list of the
    conversation that is being created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we will finish our fragments with the `createConversationLink` fragment,
    which is based on the `CreateConversationLink` mutation. This fragment will link
    the conversations created in our application and generate a unique ID. For this
    to work, this fragment needs to receive the `conversationLinkConversationId` and `conversationLinkUserId`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we will export all the fragments that we created to a JavaScript object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Applying fragments on the User Vuex actions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now we can update the User Vuex actions to use the fragments that we created:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `actions.js` file in the `store/user` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `import` section, we will replace `getUser` and `listUsers` from `src/graphql/queries`,
    with the newly created `src/graphql/fragments`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using the GraphQL query language, we were able to create small queries and mutations,
    called fragments, which can execute parts of the original query or mutation, and
    return the same response but with the data that we requested.
  prefs: []
  type: TYPE_NORMAL
- en: By doing this, the amount of data usage in our application was reduced, and
    the processing power to iterate over the data is reduced too.
  prefs: []
  type: TYPE_NORMAL
- en: The GraphQL fragments work the same as the query or the mutation that is being
    used as the base. This happens because GraphQL uses the same schema, queries,
    and mutations as the base. By doing this, you can use the same variables on the
    search and mutations that were declared on the query or mutation.
  prefs: []
  type: TYPE_NORMAL
- en: Because we used the same name as the base query when we replaced the imported
    code on the User Vuex action, we didn't have to change anything, as the result
    of the request will be the same as the old one.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Find more information about template literal tag functions at [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Find more information about GraphQL queries, mutations, and fragments at [https://graphql.org/learn/queries/](https://graphql.org/learn/queries/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the Chat Vuex module on your application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To create a chat application, we need to create custom business rules for the
    chat part of the application. This part will hold all the logic between fetching
    new messages, sending messages, and starting new conversations between users.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will create the Chat module in the application Vuex, where
    we will store all the messages between the logged user and other users, fetch
    new messages, send new messages, and start new conversations.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The prerequisites for this recipe are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The project from the previous recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Node.js 12+
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Node.js global objects that are required are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@aws-amplify/cli`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@quasar/cli`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To start our Chat Vuex module, we will continue with the project that was created
    in the *Creating GraphQL queries and fragments *recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For the creation of the Chat Vuex module, we will split our tasks into five
    parts: creating the **state**, **mutations**, **getters**, and **actions**, then
    adding the module to Vuex.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Chat Vuex state
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In order to store the data on a Vuex module, we need a state that will have
    the data stored. Here we will create the Chat state:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder called `chat` in the `store` folder and then create a new
    file called `state.js`, and open it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new function called `createState`, which returns a JavaScript object
    with the properties of `conversations`, `messages`, `loading`, and `error`. The `conversations` and `messages` properties
    will be defined as an empty array, the `loading` property will be defined as `false`,
    and `error` is `undefined`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, in order to export the state as a singleton, and make it available
    as a JavaScript object, we need to `export default` the execution of the `createState` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Creating the Chat Vuex mutations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now to save any data on a state, Vuex needs a mutation. For this, we will create
    the Chat mutation that will manage the mutations for this module:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file called `types.js` in the `store/chat` folder, and open it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the file, export a default JavaScript object with properties that are the
    same as the values of the strings. The properties will be `SET_CONVERSATIONS`, `SET_MESSAGES`, `LOADING`,
    and `ERROR`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Create a new file called `mutations.js` in the `store/chat` folder, and open
    it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Import the newly created `types.js` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new function called `setLoading` with `state` as the first argument.
    Inside we will define `state.loading` as `true`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new function called `setError`, with`state` as the first argument,
    and `error` as the second with a default value of `new Error()`. Inside we will
    define the `state.error` as `error` and `state.loading` to `false`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new function called `setConversations`, with the `state` as the first
    argument, and a JavaScript object as the second, with the  `items` property. With
    that, we will define the state conversation with the received array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new function called `setMessages`, with `state` as the first argument
    and a JavaScript object as the second. In this function, we will try to find if
    there are any messages with the `id` equal to  `id` received on  `payload`, and
    then add the messages to the state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, export a default JavaScript object, with the keys being the imported
    mutation types and the values as the functions that correspond to each type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define `MT.LOADING` as `setLoading`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define `MT.ERROR` as `setError`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define `MT.SET_CONVERSATION` as `setConversations`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Define `MT.SET_MESSAGES` as `setMessages`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Creating the Chat Vuex getters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To access the data stored on the state, we need to create the `getters`. Here
    we will create the `getters` for the Chat module:'
  prefs: []
  type: TYPE_NORMAL
- en: In a `getter` function, the first argument that that function will receive will
    always be the current `state` of the Vuex `store`.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file called `getters.js` in the `store/chat` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new function called `getConversations`. This function starts by receiving `state`, `_getters`, `_rootState`,
    and `rootGetters` in the first part of the currying function. Finally, it will
    return a filtered list of the conversations between the user and another user
    on the application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '`_variable` (underscore variable) is a technique used in JavaScript to indicate
    that the function created can have those arguments, but it won''t use them for
    now. In our case, the Vuex getters API always executes every getter call passing
    `state`, `getters`, `rootState`, and `rootGetters`, because with the linter rule,
    we added underscores to the unused arguments.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new function called `getChatMessages`, which is a getter using the
    method call. First, we pass `state`, then return a function receiving `convId`.
    Finally, it will return the list of messages from that conversation ID:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new function called `isLoading`, which returns `state.loading`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new function called `hasError`, which returns `state.error`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, export a `default` JavaScript object with the created functions as
    properties: `getConversations`, `getChatMessages`, `isLoading`, and `hasError`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Creating the Chat Vuex actions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here we will create the Chat module''s Vuex actions:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a file called `actions.js` in the `store/chat` folder, and open it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, we need to import the functions, enums, and classes to be used in this
    part:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import `graphqlOperation` from the `aws-amplify` package.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Import `getUserAndConversations`, `createConversation`, `createConversationLink`, `createMessage` and `getConversation` from
    `src/graphql/fragments.js`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Import the `getCurrentAuthUser` function from `driver/auth.js`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Import `AuthAPI` from `driver/appsync`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Import the Vuex mutation types from `./types.js`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Create an asynchronous function called `newConversation`. In the first argument,
    we will add `_vuex`, and use a JavaScript object as the second argument, receiving `authorId` and `otherUserId` as
    the properties. In this function, we will create a new conversation based on the
    received payload. Then we need to create the relationship between the conversation
    and the users in the conversation. Finally, we return the ID of the conversation
    and the name of it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'For sending a new message to a user, we need to create an `asynchronous` function
    called `newMessage`. This function will receive a deconstructed JavaScript object in
    the first argument with the `commit` variable, and as the second argument, another
    deconstructed JavaScript object with the `message` and `conversationId` properties. Then,
    in the function, we need to fetch the user''s `username` and return the GraphQL `createMessage` mutation,
    passing the variables, with `id` defined as `uid()`, `authorID` as `username`, `content` as `message`, `messageConversationId` as `conversationId`,
    and `createdAt` as `Date.now()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'To get the initial user messages, we need to create the `getMessages` asynchronous
    function. This function will receive a deconstructed JavaScript object in the
    first argument, with the `commit`variable. Inside this function, we need to get
    the `id` of the authenticated user, and then execute the GraphQL `getUserAndConversations` mutation to
    fetch all the current user `conversations`, pass them to the mutations, and return
    them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we need to finish the chat actions, creating the `fetchNewMessages` function.
    This asynchronous function will receive a deconstructed JavaScript object in the
    first argument, with the `commit` variable, and another as the second with the `conversationId` property.
    In this function, we will use the GraphQL `getConversation` query to fetch the
    messages in the conversation by passing the conversation ID. Finally, the received
    array of messages will be added to the state through the Vuex `SET_MESSAGES` mutation
    and return `true`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we will export all the created functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Adding the Chat module to Vuex
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now we will import the created Chat module to the Vuex state management:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file called `index.js` in the `store/chat` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Import the `state.js`, `actions.js`, `mutation.js`, and `getters.js` files
    that we just created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Create `export default` with a JavaScript object, with the properties being `state`, `actions`, `mutations`, `getters`,
    and `namespaced` (defined as `true`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Open the `index.js` file in the `store` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Import the newly created `index.js` file into the `store/chat` folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'On the creation of the Vuex store, add a new property called `modules`, and
    define it as a JavaScript object. Then add the imported user file to this property :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we created the Chat Vuex module. This module includes all business
    logic that is necessary to manage the conversations and messages inside the application.
  prefs: []
  type: TYPE_NORMAL
- en: In the Vuex action, we used the **AppSync API Driver** and the GraphQL fragments
    to create new conversations and messages and fetch them on the API. After being
    fetched, all the messages and conversations are stored on the Vuex state through
    the Vuex mutations.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, all the data is accessible to the user via the Vuex getter. The getters
    were developed as a currying function so it's possible to access the state and
    do a search inside of it when executing it to fetch the conversation messages,
    and using the complete API to fetch the user conversations.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Find more information about the Vuex getters API at [https://vuex.vuejs.org/api/#getters](https://vuex.vuejs.org/api/#getters).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Find more information about Vuex getters method data access at [https://vuex.vuejs.org/guide/getters.html#method-style-access](https://vuex.vuejs.org/guide/getters.html#method-style-access).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the Contacts page of your application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a chat application, it's common to have a start page where the user can select
    from old conversations to continue messaging, or start a new conversation. This
    practice can be used as the main page of the application. In our application,
    it won't be different.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will create a Contacts page that the user can use to start
    a conversation or continue with an old one.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The prerequisites for this recipe are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The project from the previous recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Node.js 12+
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Node.js global objects that are required are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@aws-amplify/cli`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@quasar/cli`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To start our User contact pages, we will continue with the project that was
    created in the *Creating the Chat Vuex module on your application *recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will need to divide our work into two parts: first a new
    component to start a new conversation, and finally, the Contacts page itself.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating the NewConversation component
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First, we need to create the component to start a new conversation between the
    user and another user on the application.
  prefs: []
  type: TYPE_NORMAL
- en: Single file component <script> section
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Here we will create the `<script>` section of our component:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file called `NewConversation.vue` in the `src/components` folder
    and open it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Import `mapActions` and `mapGetters` from `vuex`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Export a `default` JavaScript object with seven properties: `name`, `props`, `data`, `watch`, `computed`, and `methods`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `components` property, import the `AvatarDisplay` component as a lazyload
    component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `props` property, we will add a new property called `value` of type `Boolean` and
    with the default value as `false`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'On the `data` property, we need to define two properties: `userList` as an array, and `pending` as
    a Boolean defined as `false`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `methods` property, first, we will deconstruct `mapActions` from the
    user module calling the `listAllUsers` function. Then we will do the same with
    the chat module for the `newConversation` function. Now we will create an asynchronous
    function called `fetchUser` that sets the component as `pending`, fetches all
    the users, and sets`userList` as the response filtered without the current user.
    Finally, we need to create an asynchronous function called `createConversation`,
    which receives an argument of `otherUserId`, creates a new conversation, and redirects
    the user to the Messages page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'On the `computed` property, first, we will deconstruct `mapGetters` from the
    user module calling `getUser`. Then we will do the same with the chat module for `getConversations`.
    Now we will create a function called `contactList` that returns the current `userList`, filtered
    by the users that the current user has already started a conversation with:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, on the `watch` property, we will add an asynchronous function called `value`,
    which receives an argument called `newVal`. This function checks if the `newVal` value
    is `true`; if so, it will fetch the users list in the API:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Single-file component <template> section
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now let''s create the `<template>` section for the `NewConversation` component:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `QDialog` component with the `value` attribute defined as `value`.
    Also create the event listener `input` defined as the `$emit` function, sending
    the `''input''` event with `$event` as data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside of the `QDialog` component, create a `QCard` component with the `style` attribute
    defined as `min-width: 400px; min-height: 100px;`. Inside the `QCard` component, create
    two `QCardSection` child components. In the first component, add the `class` attribute
    defined as `row items-center q-pb-none`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'On the first `QCardSection` component, add a `div` with the `class` attribute
    as `text-h6`, and the inner HTML as `New Conversation`. Then add a `QSpace` component.
    Finally, add `QBtn` with the `icon` attribute as `close`, the attributes of `flat`, `round`,
    and `dense` as `true`, and add the `v-close-popup` directive:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'In the second `QCardSection` component, create a `QList` component with a `QItem` child.
    In the `QItem` child component, add a `v-for` directive to iterate over `contactList`.
    Then define the `key` variable attribute as `contact.id`, the `class` attribute as `q-my-sm`,
    and `clickable` as `true`**.** Add the `v-ripple` directive. Finally, add an event
    listener on the `click` event, dispatching the `createConversation` method and
    sending `contact.id` as the parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `QItem` component, create a `QItemSection` component with the `avatar` attribute defined
    as `true`. Then create a `QAvatar` component as a child and an `AvatarDisplay` component
    as a child of `QAvatar`. On the `AvatarDisplay` component, add an `avatar-object` dynamic attribute
    as `contact.avatar` and a `name` dynamic attribute as `contact.name`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'After the first `QItemSection` component, create another `QItemSection` as
    a sibling element. Inside this `QItemSection`, add two `QItemLabel` components.
    For the first one, add `contact.name` as the inner HTML, and on the second add
    the `caption` attribute as `true`, and `lines` as `1`, with the inner HTML as `contact.email`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Then create another `QItemSection` component as the third sibling, with the `side` attribute as `true`.
    Inside of it, add a `QIcon` component with the `name` attribute as `add_comment` and `color` as `green`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, as the sibling of the `QList` component, create a `QInnerLoading` component
    with the `showing` attribute defined as `pending`. Inside of it add a `QSpinner` component
    with the `size` attribute as `50px` and the `color` attribute defined as `primary`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the rendered version of your component:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/6d55d973-123f-4f66-9d1d-f3448259fb78.png)'
  prefs: []
  type: TYPE_IMG
- en: Creating the Contacts page
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now it's time to create the Contacts page. This page will be the initial page
    of the application for the authenticated user. Here the user will be able to go
    to the user update page, enter and resume an old conversation, or create a new
    conversation.
  prefs: []
  type: TYPE_NORMAL
- en: Single-file component <script> section
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Here we will create the `<script>` section of the single-file component that
    will be the Contacts page:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `Contacts.vue` file in the `src/pages` folder. In the `<script>` section
    of the file, import `mapActions` and `mapGetters` from `vuex`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Export a `default` JavaScript object with these properties: `name`, `mixins`, `components`, `data`, `mounted`, and `methods`.
    Define the `name` property as `ChatContacts`, and in the `mixins` property, add
    the array to the imported `getAvatar` mixin. In the `components` property, add
    two new properties inside of it, `NewConversation` and `AvatarDisplay`, which
    will receive an anonymous function that returns an imported component. Finally,
    on the `data` property, create an object with the `dialogNewConversation` property and with
    the value of `false`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `computed` property, first, we will deconstruct `mapGetters` from the
    user module by calling `getUser`. Then we will do the same with the chat module
    for `getConversations`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `methods` property, we will deconstruct `mapActions` from the chat module
    by calling the `getMessages` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, on the `mounted` life cycle hook, we need to make it asynchronous
    and add a call to the `getMessage` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Single-file component <template> section
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now, let''s create the `<template>` section for the page:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `QPage` component, then add as a child element a `QList` component
    with the `bordered` attribute defined as `true`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside of the `QList` component, create a `QItem` component with the `v-for` directive
    iterated over `getConversations`. Define the component attributes as follows: `key` as `contact.id`, `to` as
    a JavaScript object with the route destination information, `class` as `q-my-sm`, `clickable` as `true`, and
    then add the `v-ripple` directive:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `QItem` component, create a `QItemSection` component with the `avatar` attribute defined
    as `true`. Then create a `QAvatar` component as a child and an `AvatarDisplay` component
    as a child of `QAvatar`. On the `AvatarDisplay` component, add an `avatar-object` dynamic attribute
    as `contact.avatar` and the `name` dynamic attribute as `contact.name`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'After the first `QItemSection`, create another `QItemSection` as a sibling
    element. Inside this `QItemSection`, add two `QItemLabel` components. On the first,
    add`contact.name` as the inner HTML, and on the second add the `caption` attribute as `true`,
    and `lines` as `1`, with the inner HTML as `contact.email`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Then create another `QItemSection` component as the third sibling, with the
    `side` attribute as `true`. Inside of it add a`QIcon` component with the `name` attribute
    as `chat_bubble` and `color` as `green`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, as a sibling of the `QList` component, create a `QPageSticky` component,
    with the `position` attribute defined as `bottom-right` and `offset` as `[18,
    18]`. Inside of the component, create a new child  `QBtn` component with the `fab` attribute defined
    as `true`, `icon` as `chat`, `color` as `accent`, and the `click` event listener changing `dialogNewConversation` to
    the negation of the current `dialogNewConversation`. Then, add the `NewConversation` component as
    a sibling of `QBtn`, with the `v-model` directive defined as `dialogNewConversation`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a preview of how the page will look:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/123f4c54-4631-4265-ad02-afdca75ceaa9.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Contacts page works as an aggregation of all the Vuex modules created, so
    the user can have a better experience on the application. This page holds all
    the information needed by the user to navigate initially and start to use it.
  prefs: []
  type: TYPE_NORMAL
- en: The similarities between the `NewConversation` component's `<template>` section
    and the Contacts page's `<template>` section are on purpose, so the user has the
    same experience when creating a new conversation and viewing the current contacts
    list.
  prefs: []
  type: TYPE_NORMAL
- en: The usage of mixins was crucial to make the code cleaner with less duplication
    of code and made it simpler to reuse the same code.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Find more information about the Quasar `QBtn` component at [https://quasar.dev/vue-components/button](https://quasar.dev/vue-components/button).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Find more information about the Quasar `QDialog` component at [https://quasar.dev/vue-components/dialog](https://quasar.dev/vue-components/dialog).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Find more information about the Quasar `QInnerLoading` component at [https://quasar.dev/vue-components/inner-loading](https://quasar.dev/vue-components/inner-loading).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Find more information about Quasar `QSpinners` at [https://quasar.dev/vue-components/spinners](https://quasar.dev/vue-components/spinners).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Find more information about the Quasar `QPageSticky` component at [https://quasar.dev/layout/page-sticky](https://quasar.dev/layout/page-sticky).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Find more information about the Quasar `ClosePopup` directive at [https://quasar.dev/vue-directives/close-popup](https://quasar.dev/vue-directives/close-popup).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Find more information about Vue mixins at [https://vuejs.org/v2/guide/mixins.html](https://vuejs.org/v2/guide/mixins.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the Messages page of your application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is a chat application without messages? Just a simple contact list. In
    this final recipe, we will finish the whole cycle of our application, creating
    the possibility for the user to communicate with other users directly.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will create the Chat page, the `ChatInput` component, and
    the Messages layout.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The prerequisites for this recipe are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The project from the previous recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Node.js 12+
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Node.js global objects that are required are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@aws-amplify/cli`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@quasar/cli`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To start our user messages pages, we will continue with the project that was
    created in the *Creating the Contacts page of your application *recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we need to split it into three parts: the creation of the `ChatInput`
    component, the creation of the Messages layout, and finally, the creation of the
    Chat page.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating the ChatInput component
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here we will create the `ChatInput` component. This component's responsibility
    is to receive the new messages inputs from the users and send them to the server.
  prefs: []
  type: TYPE_NORMAL
- en: Single-file component <script> section
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In this part, we will create the `<script>` section for the page:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file called `ChatInput.vue` in the `src/components` folder, and
    open it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Import `mapActions` from the `vuex` package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Export a `default` JavaScript object with the properties of `name`, `data`,
    and `methods`. Define the `name` property as `ChatInput`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'On the `data` property, add a new property called `text`, with an empty string as
    the default value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `methods` property, we will deconstruct `mapActions` from the chat module,
    calling the `newMessage` and `fetchNewMessages` functions. Then we need to create
    a new function called `sendMessage`, which will create a new message on the server
    and fetch new messages from the server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Single-file component <template> section
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'It''s time to create the `<template>` component section of the single-file
    component:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `QInput` component with the `v-model` directive bounded to `text`.
    Then define the `bottom-slots` attribute as `true`, and the `label` attribute defined
    as `"Message"`. Finally, define the `keypress` event listener on the `enter` button,
    executing the `sendMessage` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `QInput` component, create a `Template` component with the `v-slot` directive
    with `after` as the name. Then create a child `QBtn` component with the attributes of `round` and `flat` defined
    as `true`, then `icon` defined as `"send"`. Finally, add an event listener on
    the `@click` event, executing the `sendMessage` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the render of your component:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/e5c54eab-bf8c-4b50-8655-8310886bef1f.png)'
  prefs: []
  type: TYPE_IMG
- en: Creating the Messages layout
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the Chat page, we will need to have a footer component for the user to type
    their messages into, and this will require a lot of modifications to the Chat
    layout we created in the previous recipes. To make it simple and easier to maintain,
    we will create a new layout exclusive to the Chat page and call it the Messages
    layout.
  prefs: []
  type: TYPE_NORMAL
- en: Single-file component <script> section
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now let''s create the `<script>` section of the Messages layout:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file called `Messages.vue` in the `layouts` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Import the `signOut` function from the `src/driver/auth.js` file and the `ChatInput` component
    from `components/ChatInput`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Export a `default` JavaScript object with the `name` property defined as `"ChatLayout"`,
    the `components` property, and another property called `methods`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `components` property, add the imported `ChatInput` component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `methods` property, add a new asynchronous function called `logOff`.
    In this function we will execute the `signOut` function and reload the browser
    after it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Single-file component <template> section
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Here we will create the `<template>` section of the Chat layout:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `QLayout` component with the `view` attribute defined as `"hHh lpR
    fFf"`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `QLayout` component, we need to add a `QHeader` component with an `elevated` attribute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'On the `QHeader` component, we will add a `QToolbar` component with a `QToolbarTitle` component
    as a child element, with a text as a slot place holder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'On the `QToolbar` component, before the `QToolbarTitle` component, we will
    add a `QBtn` component with the attributes of `dense`, `flat`, and `round` defined
    as `true`. The `icon` attribute will show a `back` icon, and the `v-go-back` directive
    is defined as `$route.meta.goBack`, so the destination is defined on the router
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'After the `QToolbarTitle` component, we will add a `QBtn` component with the
    attributes of `dense`, `flat`, and `round` defined as `true`. The `icon` attribute
    we will define as `exit_to_app`, and on the `@click` directive we will pass the `logOff` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'As a sibling of the `QHeader` component, create a `QPageContainer` component
    with a `RouterView` component as a direct child:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, create a `QFooter` component with the `class` attribute defined as `bg-white`.
    Add a child `QToolbar` component with a child `QToolbarTitle` component. Inside
    of the `QToolbarTitle`  component, add the `ChatInput` component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Changing the application routes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'After the creation of the Messages layout, we need to change how the chat page
    route is mounted, so it can use the newly created Messages layout:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `routes.js` file in the `router` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Find the `/chat` route and extract the `Messages` route object. After the `/chat` route,
    create a new JavaScript object with the `path`, `component`, and `children` properties. Define
    the `path` property as `/chat/messages`, then on the `component` property, we
    need to lazy load the newly created `Messages` layout. Finally, put the extracted
    route object on the `children` property, and change the `path` property on the
    newly added object on the `children` array to `:id/name`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Creating the Messages page
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this final part of the recipe, we will create the Messages page. Here, the
    user will be sending messages to their contacts and receiving them.
  prefs: []
  type: TYPE_NORMAL
- en: Single-file component <script> section
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let''s create the `<script>` section of the single-file component:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `Messages.vue` file in the `src/pages` folder. On the `<script>` section
    of the file, import `mapActions` and `mapGetters` from `vuex`, and `date` from `quasar`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Export a `default` JavaScript object with the properties of `name`, `components`,  `data`, `beforeMount`, `beforeDestroy`, `watch`, `computed`, and`methods`.
    Define the `name` property as `MessagesPage`. In the `components` property, add
    a new property inside of it, `AvatarDisplay`, which will receive an anonymous
    function that returns an imported component. Finally, on the `data` property,
    create an object with the `interval` property with the value of `null`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'On the `computed` property, first, we will deconstruct the `mapGetters` function,
    passing the `user` module as the first argument, and `getUser` as the second.
    Then we will do the same with the chat module for `getChatMessages`. Finally,
    create a `currentMessages` function, which gets the messages for the current conversation,
    and return the messages with the `createdAt` date formatted:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'At the `methods` property, deconstruct `mapActions` from the `chat` module
    by calling `fetchNewMessages`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `watch` property, create a property called `currentMessages`, which
    is a JavaScript object, with three properties, `handler`, `deep`, and `immediate`.
    Define the `handler` property as a function with the `newValue` and `oldValue` parameters. This
    function will check if `newValue` is larger than `oldValue`. Then create a timeout,
    that will scroll the screen to the last visible element. The `deep` property is
    defined as `true`, and the `immediate` property as `false`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to make the `beforeMount` life cycle hook asynchronous. Then we need
    to assign `interval` to a new `setInterval`, which will fetch new messages every
    1 second:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, on the `beforeDestroy` life cycle hook, we will clear the `interval` loop
    and define `interval` as `null`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: Single-file component <template> section
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now let's create the `<template>` section of the single-file component
  prefs: []
  type: TYPE_NORMAL
- en: Create a `QPage` component with the `class` attribute defined as `q-pa-md row
    justify-center`, and add a `QChatMessage` component as a child.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `QChatMessage` child component, first, iterate on the `v-for` directive
    over `currentMessages`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define the `ref` and `key` component attributes as `message.id`, `stamp` as `message.createdAt`,
    and `text` as `[message.content]`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then define the `sent` attribute as an evaluation of whether `message.authorId` is
    the same as `getUser.id`, `name` as `message.author.name`, `avatar` as the `getAvatar` method
    passing in `message.author.avatar` and `message.author.name` as arguments.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, define the `class` attribute as `col-12`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, inside the `QChatMessage` component, create a `template` component
    on the `avatar` slot and add the `AvatarDisplay` component. Define the `avatar-object`
    dynamic attribute as `message.author.avatar`, the `name` dynamic attribute as`message.author.name`,
    the `tag` attribute as `''img''`, the `class` attribute as `''q-message-avatar''`,
    and the class dynamic attribute as a ternary operator checking whether `getUser.id`
    is different from `message.authorId`, so it returns `''q-message-avatar--received''`,
    or returns `''q-message-avatar--sent''` if the message is from the sender:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a preview of how the page will look:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/311932f4-95f8-4f1a-98fc-801cbbc2b0d4.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Messages page is a combination of three parts: the layout, the `ChatInput` component,
    and the page. Using this combination, we were able to split our code into different
    responsibilities to increase the ease of maintaining our code.'
  prefs: []
  type: TYPE_NORMAL
- en: In the `ChatInput` component, we used the Chat Vuex module to send messages
    directly, without the need to pass through a container like a page or a layout,
    making the component stateful.
  prefs: []
  type: TYPE_NORMAL
- en: We needed to add the new layout and the router modification because the layout
    of the application needed a component fixed on the footer of the application.
    This footer is the message input, which needs to always be visible to the user.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the Messages page is an auto-refreshing page that fetches new content
    every second, and always displays the new messages for the user.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Find more information about Quasar Framework's `QChatMessage` component at [https://quasar.dev/vue-components/chat](https://quasar.dev/vue-components/chat).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Find more information about Quasar Framework's `date` utils at [https://quasar.dev/quasar-utils/date-utils](https://quasar.dev/quasar-utils/date-utils).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
