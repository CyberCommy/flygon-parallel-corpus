- en: Smart Pointers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, you learned about template programming and the benefits
    of generic programming. In this chapter, you will learn about the following smart
    pointer topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Memory management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Issues with raw pointers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cyclic dependency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Smart pointers:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`auto_ptr`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unique_ptr`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`shared_ptr`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`weak_ptr`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's explore the memory management facilities offered by C++.
  prefs: []
  type: TYPE_NORMAL
- en: Memory management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In C++, memory management is generally a responsibility of the software developers.
    This is because C++ standard does not enforce garbage collection support in C++
    compiler; hence, it is left to the compiler vendor's choice. Exceptionally, the
    Sun C++ compiler comes with a garbage collection library named `libgc`.
  prefs: []
  type: TYPE_NORMAL
- en: C++ language has many powerful features. Of these, needless to say, pointers
    is one of the most powerful and useful features. Having said pointers are very
    useful, they do come with their own weird issues, hence they must be used responsibly.
    When memory management is not taken seriously or not done quite right, it leads
    to many issues, including application crashes, core dumps, segmentation faults,
    intermittent difficulties to debug issues, performance issues, and so on. Dangling
    pointers or rogue pointers sometimes mess with other unrelated applications while
    the culprit application executes silently; in fact, the victim application might
    be blamed many times. The worst part about memory leaks is that at certain times
    it gets really tricky and even experienced developers end up debugging the victim
    code for countless hours while the culprit code is left untouched. Effective memory
    management helps avoid memory leaks and lets you develop high-performance applications
    that are memory efficient.
  prefs: []
  type: TYPE_NORMAL
- en: As the memory model of every operating system varies, every OS may behave differently
    at a different point in time for the same memory leak issue. Memory management
    is a big topic, and C++ offers many ways to do it well. We'll discuss some of
    the useful techniques in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Issues with raw pointers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The majority of the C++ developers have something in common: all of us love
    to code complex stuff. You ask a developer, "Hey dude, would you like to reuse
    code that already exists and works or would you like to develop one yourself?"
    Though diplomatically, most developers will say to reuse what is already there
    when possible, their heart will say, "I wish I could design and develop it myself."
    Complex data structure and algorithms tend to call for pointers. Raw pointers
    are really cool to work with until you get into trouble.'
  prefs: []
  type: TYPE_NORMAL
- en: Raw pointers must be allocated with memory before use and require deallocation
    once done; it is that simple. However, things get complicated in a product where
    pointer allocation may happen in one place and deallocation might happen in yet
    another place. If memory management decisions aren't made correctly, people may
    assume it is either the caller or callee's responsibility to free up memory, and
    at times, the memory may not be freed up from either place. In yet another possibility,
    chances are that the same pointer is deleted multiples times from different places,
    which could lead to application crashes. If this happens in a Windows device driver,
    it will most likely end up in a blue screen of death.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just imagine, what if there were an application exception and the function
    that threw the exception had a bunch of pointers that were allocated with memory
    before the exception occurred? It is anybody''s guess: there will be memory leaks.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a simple example that makes use of a raw pointer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Check out the output of this program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: C++ compiler is really cool. Look at the warning message, it bangs on in regard
    to pointing out the issue. I love the Linux operating system. Linux is quite smart
    in finding rogue applications that misbehave, and it knocks them off right on
    time before they cause any damage to the rest of the applications or the OS. A
    core dump is actually good, while it is cursed instead of celebrating the Linux
    approach. Guess what, Microsoft's Windows operating systems are equally smarter.
    They do bug check when they find some applications doing fishy memory accesses
    and Windows OS as well supports mini-dumps and full dumps which are equivalent
    to core dumps in Linux OS.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the Valgrind tool output to check the memory leak issue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In this output, if you pay attention to the **bold** portion of the text, you
    will notice the Valgrind tool did point out the source code line number that caused
    this core dump. Line number 12 from the `main.cpp` file is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The moment the exception occurs at line number 12 in the `main.cpp` file, the
    code that appears below the exception will never get executed. At line number
    13 in the `main.cpp` file, there appears a `delete` statement that will never
    get executed due to the exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The memory allocated to the preceding raw pointer isn't released as the memory
    pointed by pointers is not freed up during the stack unwinding process. Whenever
    an exception is thrown by a function and the exception isn't handled by the same
    function, stack unwinding is guaranteed. However, only the automatic local variables
    will be cleaned up during the stack unwinding process, not the memory pointed
    by the pointers. This results in memory leaks.
  prefs: []
  type: TYPE_NORMAL
- en: This is one of the weird issues invited by the use of raw pointers; there are
    many other similar scenarios. Hopefully you are convinced now that the thrill
    of using raw pointers does come at a cost. But the penalty paid isn't really worth
    it as there are good alternatives available in C++ to deal with this issue. You
    are right, using a smart pointer is the solution that offers the benefits of using
    pointers without paying the cost attached to raw pointers.
  prefs: []
  type: TYPE_NORMAL
- en: Hence, smart pointers are the way to use pointers safely in C++.
  prefs: []
  type: TYPE_NORMAL
- en: Smart pointers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In C++, smart pointers let you focus on the problem at hand by freeing you from
    the worries of dealing with custom garbage collection techniques. Smart pointers
    let you use raw pointers safely. They take the responsibility of cleaning up the
    memory used by raw pointers.
  prefs: []
  type: TYPE_NORMAL
- en: 'C++ supports many types of smart pointers that can be used in different scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: '`auto_ptr`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unique_ptr`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`shared_ptr`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`weak_ptr`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `auto_ptr` smart pointer was introduced in C++11\. An `auto_ptr` smart pointer
    helps release the heap memory automatically when it goes out of scope. However,
    due to the way `auto_ptr` transfers ownership from one `auto_ptr` instance to
    another, it was deprecated and `unique_ptr` was introduced as its replacement.
    The `shared_ptr` smart pointer helps multiple shared smart pointers reference
    the same object and takes care of the memory management burden. The `weak_ptr` smart
    pointer helps resolve memory leak issues that arise due to the use of `shared_ptr`
    when there is a cyclic dependency issue in the application design.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are other types of smart pointers and related stuff that are not so commonly
    used, and they are listed in the following bullet list. However, I would highly
    recommend that you explore them on your own as you never know when you will find
    them useful:'
  prefs: []
  type: TYPE_NORMAL
- en: '`owner_less`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`enable_shared_from_this`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bad_weak_ptr`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`default_delete`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `owner_less` smart pointer helps compare two or more smart pointers if they
    share the same raw pointed object. The `enable_shared_from_this` smart pointer
    helps get a smart pointer of the `this` pointer. The `bad_weak_ptr` smart pointer
    is an exception class that implies that `shared_ptr` was created using an invalid
    smart pointer. The `default_delete` smart pointer refers to the default destruction
    policy used by `unique_ptr`, which invokes the `delete` statement, while partial
    specialization for array types that use `delete[]` is also supported.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will explore `auto_ptr`, `shared_ptr`, `weak_ptr`, and `unique-ptr` one
    by one.
  prefs: []
  type: TYPE_NORMAL
- en: auto_ptr
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `auto_ptr` smart pointer takes a raw pointer, wraps it, and ensures the
    memory pointed by the raw pointer is released back whenever the `auto_ptr` object
    goes out of scope. At any time, only one `auto_ptr` smart pointer can point to
    an object. Hence, whenever one `auto_ptr` pointer is assigned to another `auto_ptr` pointer,
    the ownership gets transferred to the `auto_ptr` instance that has received the
    assignment; the same happens when an `auto_ptr` smart pointer is copied.
  prefs: []
  type: TYPE_NORMAL
- en: 'It would be interesting to observe the stuff in action with a simple example,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The compilation output of the preceding program is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the C++ compiler warns us as the use of `auto_ptr` is deprecated.
    Hence, I don't recommend the use of the `auto_ptr` smart pointer anymore; it is
    replaced by `unique_ptr`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, we can ignore the warnings and move on, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the preceding program output, both `Object1` and `Object2`,
    allocated in a heap, got deleted automatically. And the credit goes to the `auto_ptr`
    smart pointer.
  prefs: []
  type: TYPE_NORMAL
- en: Code walkthrough - Part 1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As you may have understood from the `MyClass` definition, it has defined the default
    `constructor`, `copy` constructor and destructor, an `assignment` operator, and
    `sayHello()` methods, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The methods of `MyClass` have nothing more than a print statement that indicates
    the methods got invoked; they were purely meant for demonstration purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `main()` function creates two `auto_ptr` smart pointers that point to two
    different `MyClass` objects, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As you can understand, `auto_ptr` is a local object that wraps a raw pointer,
    not a pointer. When the control hits the `return` statement, the stack unwinding
    process gets initiated, and as part of this, the stack objects, that is, `ptr1`
    and `ptr2`, get destroyed. This, in turn, invokes the destructor of `auto_ptr`
    that ends up deleting the `MyClass` objects pointed by the stack objects `ptr1`
    and `ptr2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are not quite done yet. Let''s explore more useful functionalities of `auto_ptr`,
    as shown in the following `main` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Code walkthrough - Part 2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `main()` function code we just saw demonstrates many useful techniques
    and some controversial behaviors of the `auto_ptr` smart pointer. The following
    code creates two instances of `auto_ptr`, namely `ptr1` and `ptr2`, that wrap
    two objects of `MyClass` created in a heap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, the following code demonstrates how the methods supported by `MyClass`
    can be invoked using `auto_ptr`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Hope you observed the `ptr1->sayHello()` statement. It will make you believe
    that the `auto_ptr` `ptr1` object is a pointer, but in reality, `ptr1` and `ptr2`
    are just `auto_ptr` objects created in the stack as local variables. As the `auto_ptr`
    class has overloaded the `->` pointer operator and the `*` dereferencing operator,
    it appears like a pointer. As a matter of fact, all the methods exposed by `MyClass`
    can only be accessed using the `->` pointer operator, while all the `auto_ptr`
    methods can be accessed as you would regularly access a stack object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code demonstrates the internal behavior of the `auto_ptr` smart
    pointer, so pay close attention; this is going to be really interesting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'It appears as though the preceding code is a simple `assignment` statement,
    but it triggers many activities within `auto_ptr`. The following activities happen
    due to the preceding `assignment` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: The `ptr2` smart pointer will give up the ownership of `MyClass` object 2.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MyClass` object 2 will be destructed as `ptr2` has given up its ownership
    of `object 2`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ownership of `object 1` will be transferred to `ptr2`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At this point, `ptr1` is neither pointing to `object 1`, nor it is responsible
    for managing the memory used by `object 1`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following commented line has got some facts to tell you:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As the `ptr1` smart pointer has released its ownership of `object 1`, it is
    illegal to attempt accessing the `sayHello()` method. This is because `ptr1`,
    in reality, isn't pointing to `object 1` anymore, and `object 1` is owned by `ptr2`.
    It is the responsibility of the `ptr2` smart pointer to release the memory utilized
    by `object 1` when `ptr2` goes out of scope. If the preceding code is uncommented,
    it would lead to a core dump.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the following code lets us invoke the `sayHello()` method on `object
    1` using the `ptr2` smart pointer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `return` statement we just saw will initiate the stack unwinding process
    in the `main()` function. This will end up invoking the destructor of `ptr2`,
    which in turn will deallocate the memory utilized by `object 1`. The beauty is
    all this happens automatically. The `auto_ptr` smart pointer works hard for us
    behind the scenes while we are focusing on the problem at hand.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, due to the following reasons, `auto_ptr` is deprecated in `C++11`
    onward:'
  prefs: []
  type: TYPE_NORMAL
- en: An `auto_ptr` object can't be stored in an STL container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `auto_ptr` copy constructor will remove the ownership from the original
    source, that is, ``auto_ptr``
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `auto_ptr` copy `assignment` operator will remove the ownership from the
    original source, which is, `auto_ptr`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The original intention of copy constructor and `assignment` operators are violated
    by `auto_ptr` as the `auto_ptr`  copy constructor and `assignment` operators will
    remove the ownership of the source object from the right-hand side object and
    assign the ownership to the left-hand side object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: unique_ptr
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `unique_ptr` smart pointer works in exactly the same way as `auto_ptr`,
    except that `unique_ptr` addresses the issues introduced by `auto_ptr`. Hence,
    `unique_ptr` is a replacement of `auto_ptr`, starting from `C++11`. The `unique_ptr` smart
    pointer allows only one smart pointer to exclusively own a heap-allocated object.
    The ownership transfer from one `unique_ptr` instance to another can be done only
    via the `std::move()` function.
  prefs: []
  type: TYPE_NORMAL
- en: Hence, let's refactor our previous example to make use of `unique_ptr` in place
    of `auto_ptr`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The refactored code sample is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding program is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding output, you can notice the compiler doesn't report any warning
    and the output of the program is the same as that of `auto_ptr`.
  prefs: []
  type: TYPE_NORMAL
- en: Code walkthrough
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is important to note the differences in the `main()` function, between `auto_ptr`
    and `unique_ptr`. Let''s check out the `main()` function, as illustrated in the
    following code. This code creates two instances of `unique_ptr`, namely `ptr1`
    and `ptr2`, that wrap two objects of `MyClass` created in the heap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, the following code demonstrates how the methods supported by `MyClass`
    can be invoked using `unique_ptr`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Just like `auto_ptr`, the `unique_ptr` smart pointers `ptr1` object has overloaded
    the `->` pointer operator and the `*` dereferencing operator; hence, it appears
    like a pointer.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code demonstrates `unique_ptr` doesn''t support the assignment
    of one `unique_ptr` instance to another, and ownership transfer can only be achieved
    with the `std::move()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The `move` function triggers the following activities:'
  prefs: []
  type: TYPE_NORMAL
- en: The `ptr2` smart pointer gives up the ownership of the `MyClass` object 2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MyClass` object 2 is destructed as `ptr2` gives up its ownership of `object
    2`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ownership of `object 1` is transferred to `ptr2`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At this point, `ptr1` is neither pointing to `object 1`, nor it is responsible
    for managing the memory used by `object 1`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code, if uncommented, will lead to a core dump:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the following code lets us invoke the `sayHello()` method on `object
    1` using the `ptr2` smart pointer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The `return` statement we just saw will initiate the stack unwinding process
    in the `main()` function. This will end up invoking the destructor of `ptr2`,
    which in turn will deallocate the memory utilized by `object 1`. Note that `unique_ptr` objects
    could be stored in STL containers, unlike `auto_ptr` objects.
  prefs: []
  type: TYPE_NORMAL
- en: shared_ptr
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `shared_ptr` smart pointer is used when a group of `shared_ptr` objects
    shares the ownership of a heap-allocated object. The `shared_ptr` pointer releases
    the shared object when all the `shared_ptr` instances are done with the use of
    the shared object. The `shared_ptr` pointer uses the reference counting mechanism
    to check the total references to the shared object; whenever the reference count
    becomes zero, the last `shared_ptr` instance deletes the shared object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s check out the use of `shared_ptr` through an example, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding program is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Code walkthrough
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following code creates an instance of the `shared_ptr` object that points
    to the `MyClass` heap-allocated object. Just like other smart pointers, `shared_ptr`
    also has the overloaded `->` and `*` operators. Hence, all the `MyClass` object
    methods can be invoked as though you are using a raw pointer. The `use_count()`
    method tells the number of smart pointers that refer to the shared object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following code, the scope of the smart pointer `ptr2` is wrapped within
    the block enclosed by flower brackets. Hence, `ptr2` will get destroyed at the
    end of the following code block. The expected `use_count` function within the
    code block is 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following code, the expected `use_count` value is 1 as `ptr2` would
    have been deleted, which would reduce the reference count by 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code will print a Hello message, followed by `use_count` as 2\.
    This is due to the fact that `ptr1` and `ptr3` are now referring to the `MyClass`
    shared object in the heap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The `return 0;` statement at the end of the `main` function will destroy `ptr1`
    and `ptr3`, reducing the reference count to zero. Hence, we can observe the `MyClass`
    destructor print the statement at the end of the output.
  prefs: []
  type: TYPE_NORMAL
- en: weak_ptr
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have discussed the positive side of `shared_ptr` with examples. However,
    `shared_ptr` fails to clean up the memory when there is a circular dependency
    in the application design. Either the application design must be refactored to
    avoid cyclic dependency, or we can make use of `weak_ptr` to resolve the cyclic
    dependency issue.
  prefs: []
  type: TYPE_NORMAL
- en: You can check out my YouTube channel to understand the `shared_ptr` issue and
    how it can be resolved with `weak_ptr`: [https://www.youtube.com/watch?v=SVTLTK5gbDc](https://www.youtube.com/watch?v=SVTLTK5gbDc).
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider there are three classes: A, B, and C. Class A and B have an instance
    of C, while C has an instance of A and B. There is a design issue here. A depends
    on C and C depends on A too. Similarly, B depends on C and C depends on B as well.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding program is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding output, you can observe that even though we used `shared_ptr`,
    the memory utilized by objects A, B, and C were never deallocated. This is because
    we didn't see the destructor of the respective classes being invoked. The reason
    for this is that `shared_ptr` internally makes use of the reference counting algorithm
    to decide whether the shared object has to be destructed. However, it fails here
    because object A can't be deleted unless object C is deleted. Object C can't be
    deleted unless object A is deleted. Also, object C can't be deleted unless objects
    A and B are deleted. Similarly, object A can't be deleted unless object C is deleted
    and object B can't be deleted unless object C is deleted.
  prefs: []
  type: TYPE_NORMAL
- en: The bottom line is that this is a circular dependency design issue. In order
    to fix this issue, starting from C++11, C++ introduced `weak_ptr`. The `weak_ptr` smart
    pointer is not a strong reference. Hence, the object referred to could be deleted
    at any point of time, unlike `shared_ptr`.
  prefs: []
  type: TYPE_NORMAL
- en: Circular dependency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Circular dependency is an issue that occurs if object A depends on B, and object
    B depends on A. Now let''s see how this issue could be fixed with a combination
    of `shared_ptr` and `weak_ptr`, eventually breaking the circular dependency, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding refactored code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about
  prefs: []
  type: TYPE_NORMAL
- en: Memory leak issues that arise due to raw pointers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The issues of `auto_ptr` with respect to assignment and copy constructor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unique_ptr` and it''s advantage'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Role of `shared_ptr` in memory management and its limitation related to cyclic
    dependency.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You also resolving cyclic dependency issues with `weak_ptr`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next chapter, you will learn about developing GUI applications in C++.
  prefs: []
  type: TYPE_NORMAL
