- en: Chapter 3.  More Angular 2 – SPA, Routing, and Data Flows in Depth
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If the previous chapter was about building our first useful app in Angular,
    then this chapter is about adding a whole lot of Angular goodness to it. Within
    the learning curve, we have made a start in exploring a technology platform and
    now we can build some rudimentary apps using Angular. But that's just the start!
    There is a lot more to learn before we can make effective use of Angular in a
    decent-sized application. This chapter takes us one step closer to realizing this
    goal.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: The *7 Minute Workout* app still has some rough edges/limitations that we can
    fix while making the overall app experience better. This chapter is all about
    adding those enhancements and features. And as always, this app-building process
    provides us with enough opportunities to enhance our understanding of the framework
    and learn new things about it.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics we cover in this chapter include:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: '**Exploring Angular Single Page Applications** (**SPA**): We explore Angular''s
    Single Page Application capabilities, which include route navigation, link generation,
    and routing events.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Understanding Dependency Injection**: One of the core platform features.
    In this chapter, we learn how Angular makes effective use of dependency injection
    to inject components and services across the application.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Angular pure (stateless) and impure (stateful) pipes**: We explore the primary
    data transformation construct of Angular, pipes, in more detail as we build some
    new pipes.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cross-component communication**: Since Angular is all about components and
    their interactions, we look at how to do cross-component communication in a parent-child
    and sibling component setup. We learn how Angular template variables and events
    facilitate this communication.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Creating and consuming events**: We learn how a component can expose its
    own events and how to bind to these events from template HTML and from other components.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AS a side note, I expect you are using the *7 Minute Workout* on a regular basis
    and working on your physical fitness. If not take a 7-minute exercise break and
    exercise now. I insist!
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Hope the workout was fun! Now let's get back to some serious business. Let's
    start with exploring Angular Single Page Application (SPA) capabilities.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We are starting from where we left off in [Chapter 2](part0028.xhtml#QMFO1-edca168d36254bda8a21f611a95615c3
    "Chapter 2.  Building Our First App - 7 Minute Workout"), *Building Our First
    App - 7 Minute Workout*. The git branch `checkpoint2.4` can serve as the base
    for this chapter.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从[第2章](part0028.xhtml#QMFO1-edca168d36254bda8a21f611a95615c3 "第2章。构建我们的第一个应用程序-7分钟锻炼")中离开的地方开始，*构建我们的第一个应用程序-7分钟锻炼*。git分支`checkpoint2.4`可以作为本章的基础。
- en: The code is also available on GitHub ([https://github.com/chandermani/angular2byexample](https://github.com/chandermani/angular2byexample))
    for everyone to download. Checkpoints are implemented as branches in GitHub.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码也可在GitHub上获取（[https://github.com/chandermani/angular2byexample](https://github.com/chandermani/angular2byexample)），供所有人下载。检查点在GitHub上作为分支实现。
- en: If you are not using git, download the snapshot of `checkpoint2.4` (a ZIP file)
    from the GitHub location [http://bit.ly/ng2be-checkpoint2-4](http://bit.ly/ng2be-checkpoint2-4).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不使用git，请从GitHub位置[http://bit.ly/ng2be-checkpoint2-4](http://bit.ly/ng2be-checkpoint2-4)下载`checkpoint2.4`的快照（ZIP文件）。首次设置快照时，请参考`trainer`文件夹中的`README.md`文件。
- en: Exploring Single Page Application capabilities
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索单页应用程序的能力
- en: The *7 Minute Workout* starts when we load the app, but it ends with the last
    exercise sticking to the screen permanently. Not a very elegant solution. Why
    don't we add a start and finish page to the app? This makes the app more professional
    and allows us to understand the single-page nomenclature of AngularJS.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*7分钟锻炼*从加载应用程序开始，但以最后一次锻炼永久停留在屏幕上结束。这不是一个非常优雅的解决方案。为什么我们不在应用程序中添加开始和结束页面呢？这使应用程序更专业，并且可以让我们理解AngularJS的单页面命名法。'
- en: The Angular SPA infrastructure
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Angular SPA基础设施
- en: With modern web frameworks such as Angular (Angular 1.x) and Ember, we are now
    getting used to apps that do not perform full page refreshes. But if you are new
    to this scene it's worth mentioning what these SPAs are.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 使用现代Web框架（如Angular（Angular 1.x）和Ember），我们现在习惯于不执行完整页面刷新的应用程序。但是，如果您是新手，值得一提的是这些单页应用程序（SPAs）是什么。
- en: Single Page Applications (SPAs) are browser-based apps devoid of any full page
    refresh. In such apps, once the initial HTML is loaded, any future page navigations
    are retrieved using AJAX as HTML fragments and injected into the already loaded
    view. Google Mail is a great example of a SPA. SPAs make for a great user experience
    as the user gets a desktop app-like feel, with no constant post-backs and page
    refreshes, which are typically associated with traditional web apps.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 单页应用程序（SPAs）是基于浏览器的应用程序，不需要进行完整的页面刷新。在这种应用程序中，一旦加载了初始HTML，任何未来的页面导航都是使用AJAX作为HTML片段检索并注入到已加载的视图中。谷歌邮件是SPA的一个很好的例子。SPAs为用户提供了极佳的用户体验，因为用户可以获得类似桌面应用程序的感觉，而无需不断的后退和页面刷新，这通常与传统Web应用程序相关联。
- en: Like its predecessor, Angular 2 too provides the necessary constructs for SPA
    implementation. Let's understand them and add our app pages too.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 与其前身一样，Angular 2也为SPA实现提供了必要的构造。让我们了解它们并添加我们的应用程序页面。
- en: Angular routing
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Angular路由
- en: Angular supports SPA development using its routing infrastructure. This infrastructure
    tracks browser URLs, enables hyperlink generation, exposes routing events, and
    provides a set of directives/components for view.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Angular使用其路由基础设施支持SPA开发。该基础设施跟踪浏览器URL，启用超链接生成，公开路由事件，并提供一组用于视图的指令/组件。
- en: 'There are four major framework pieces that work together to support the Angular
    routing infrastructure:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 有四个主要的框架部分共同支持Angular路由基础设施：
- en: '**The Router (Router)**: The primary infrastructure piece that actually provides
    component navigation'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**路由器（Router）**：实际提供组件导航的主要基础设施'
- en: '**Routing configuration (Route)**: The component router is dependent upon the
    routing configuration for setting up routes'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**RouterOutlet component**: The `RouterOutlet` component is the placeholder
    container (*host*) where route-specific views are loaded'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**RouterLink directive**: This generates hyperlinks that can be embedded in
    the anchor tags for navigation'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram highlights the roles these components play within the
    routing setup:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '![Angular routing](../Images/image00446.jpeg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
- en: I highly encourage everyone to keep revisiting this diagram as we set up routing
    for *7 Minute Workout*.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '*Router* is the central piece of this complete setup; therefore a quick overview
    of the router will be helpful.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Angular router
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you have worked with any JavaScript framework with SPA support, this is how
    things work. The framework watches the browser URL and serves views based on the
    URL loaded. There are dedicated framework components for this job. In the Angular
    world, this tracking is done by a *framework service*, the router.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Angular, any class, object, or function that provides some generic functionality
    is termed a **service**. Angular does not provide any special construct to declare
    a service as it does for components, directives, and pipes. Anything that can
    be consumed by components/directives/pipes can be termed a service. Router is
    one such service. And there are many more services that are part of the framework.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: If you are from the Angular 1 realm, this is a pleasant surprise-no service,
    factory, provider, value, or constant!
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When building a component try to delegate as much functionality as possible
    to a service. Components should only act as a mediator that helps in synchronizing
    the component model and the view state
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: 'The Angular router is there to:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Enable navigation between components on route change
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pass routing data between component views
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make the state of the currently route available to active/loaded components
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide APIs that allow navigation for component code
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Track the navigation history, allowing us the move back and forward between
    component views using browser buttons
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide life cycle events and guard conditions that allow us to affect navigation
    based on some external factors
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The router also supports some advance routing concepts such as parent-child
    routes. This gives us the ability to define routes at multiple levels inside the
    component tree. The parent component can define routes and child components can
    further add more sub-routes to the parent route definition. This is something
    that we cover in detail in [Chapter 4](part0045.xhtml#1AT9A1-edca168d36254bda8a21f611a95615c3
    "Chapter 4.  Personal Trainer"), *Building Personal Trainer*.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: The router does not work alone. As highlighted in the preceding diagram, it
    depends upon other framework pieces to achieve the desired results. Let's add
    some app pages and work with each piece of the puzzle.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: Routing setup
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For the component router to work, we first need to reference it as the router
    is not part of the core framework.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `package.json` and add a package reference to the router as highlighted
    here:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next install the package from the command line using:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Finally, reference the package in `systemjs.config.js`. This allows SystemJS
    to load the `router` module correctly. Add the router package to the `ngPackageNames`
    array to set up the `packages` configuration:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Also add the `base` reference (highlighted) to the `head` section of `index.html` if
    not present:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The router requires `base href` to be set. The `href` value specifies the base
    URL to use for all relative URLs within an HTML document, including links to CSS,
    scripts, images, and any other resource.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: 'The router uses the **pushstate** mechanism for URL navigation. This allows
    us to use URLs such as:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '`localhost:9000/start`'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`localhost:9000/workout`'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`localhost:9000/finish`'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This may not seem a big deal, but remember that we are doing client-side navigation,
    not the  full-page redirects that we are used to. As the **developer guide** states:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '*Modern HTML 5 browsers support `history.pushState`, a technique that changes
    a browser''s location and history without triggering a server page request. The
    router can compose a "natural" URL that is indistinguishable from one that would
    otherwise require a page load.*'
  id: totrans-65
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Pushstate API and server-side url-rewrites
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The pushstate API used by the router works only when we click on links embedded
    in the view (`<a>` tag) or use the router API. The router intercepts any navigation
    events, loads the appropriate component view, and finally updates the browser
    URL. The request never goes to the server.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: But what if we refresh the browser?
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: The Angular router cannot intercept the browser's refresh event, and hence a
    complete page refresh happens. In such a scenario, the server needs to respond
    to a resource request that only exists on the client side. A typical server response
    is to send the app host file (such as `index.html`) for any arbitrary request
    that may result in a **404 (Not Found)** error. This is what we call server **url-rewrite**.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Angular路由器无法拦截浏览器的刷新事件，因此会发生完整的页面刷新。在这种情况下，服务器需要响应仅存在于客户端的资源请求。典型的服务器响应是对于可能导致**404（未找到）**错误的任何任意请求发送应用主机文件（如`index.html`）。这就是我们所说的服务器**URL重写**。
- en: 'Even our server setup does url-rewrite. Check out the highlighted line in `gulpfile.js`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们的服务器设置也进行了URL重写。查看`gulpfile.js`中的突出显示行：
- en: '[PRE4]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The last configuration parameter to `connect.server` sets the `fallback` URL
    for the app server to `index.html`. This implies requests to any non-existent
    URLs such as `/start`, `/workout`, `/finish` or any other loads the index page.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`connect.server`的最后一个配置参数设置了应用服务器的`fallback` URL为`index.html`。这意味着对任何不存在的URL的请求，如`/start`、`/workout`、`/finish`或其他任何URL，都会加载首页。'
- en: Tip
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Each server platform has a different mechanism to support url-rewrite. We suggest
    you look at the documentation for the server stack you use to enable url-rewrite
    for your Angular apps.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 每个服务器平台都有不同的机制来支持URL重写。我们建议您查看您使用的服务器堆栈的文档，以启用Angular应用程序的URL重写。
- en: We can see the server-side rewrites in action once we add some pages to *7 Minute
    Workout*. Once the new pages are in place, try to refresh the app and see the
    browser's network log; the server sends `index.html` content every time irrespective
    of the URL requested.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们为*7分钟锻炼*添加了一些页面，我们就可以看到服务器端的重写。一旦新页面就位，尝试刷新应用程序并查看浏览器的网络日志；服务器每次都发送`index.html`内容，无论请求的URL是什么。
- en: Tip
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Fall back path and debugging**'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '**回退路径和调试**'
- en: Setting up a fall back path for all non-existing URLs can be detrimental while
    debugging the application. Once the fall back mechanism is in place, there are
    no 404 errors for script/HTML/CSS load failures. This can produce unexpected results
    for any missing reference as the server always returns the `index.html` file.
    Watch out for content returned in the browser network log and the browser console
    for anomalies whenever you add new files to the application.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为所有不存在的URL设置一个回退路径可能会在调试应用程序时产生不利影响。一旦回退机制就位，对于脚本/HTML/CSS加载失败，就不会出现404错误。这可能会对任何缺失的引用产生意外结果，因为服务器总是返回`index.html`文件。每当您向应用程序添加新文件时，请注意浏览器网络日志和浏览器控制台中返回的内容是否有异常。
- en: As part of the preceding router setup, we have learned how router scripts are
    included, how server-side redirects are set up to support the HTML5 push state
    and the need to set up `base href`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 作为前面路由器设置的一部分，我们已经学会了如何包含路由器脚本，如何设置服务器端重定向以支持HTML5推送状态以及设置`base href`的需要。
- en: Before we proceed any further, we need to add some other pages to our app and
    configure the routes.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，我们需要为我们的应用程序添加一些其他页面并配置路由。
- en: Adding start and finish pages
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加开始和完成页面
- en: 'The plan here is to have three pages for *7 Minute Workout*:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的计划是为*7分钟锻炼*创建三个页面：
- en: '**Start page**: This becomes the landing page for the app'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开始页面**：这将成为应用程序的登陆页面'
- en: '**Workout page**: What we have currently'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**锻炼页面**：我们目前拥有的内容'
- en: '**Finish page**: We navigate to this once the workout is complete'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**完成页面**：我们在锻炼完成后导航到这里'
- en: The workout component and its view (`workout-runner.component.ts` and `workout-runner.html`)
    are already there. So let's create `StartComponent` and `FinishComponent`, and
    their view.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 锻炼组件及其视图（`workout-runner.component.ts`和`workout-runner.html`）已经存在。因此，让我们创建`StartComponent`和`FinishComponent`以及它们的视图。
- en: 'Copy the following files from git branch `checkpoint3.1`. The files are located
    in the `start` and `finish` folders, under the `components` folder (the GitHub
    location to download from is [http://bit.ly/ng2be-3-1-components](http://bit.ly/ng2be-3-1-components)):'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 从git分支`checkpoint3.1`复制以下文件。这些文件位于`components`文件夹下的`start`和`finish`文件夹中（从GitHub位置下载的链接是[http://bit.ly/ng2be-3-1-components](http://bit.ly/ng2be-3-1-components)）：
- en: '`start.component.ts`, `start.html`, and `start.module.ts`: This includes the
    `StartComponent` implementation and view template. A standard HTML view, and a
    basic component, which uses the `routerLink` directive to generate a hyperlink.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`start.component.ts`，`start.html`和`start.module.ts`：这包括`StartComponent`的实现和视图模板。一个标准的HTML视图，和一个基本的组件，使用`routerLink`指令生成超链接。'
- en: '`finish.component.ts`, `finish.html`, and `finish.module.ts`: This includes
    the `FinishComponent` implementation and view template. It follows the same pattern
    as `StartComponent`.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`finish.component.ts`，`finish.html`和`finish.module.ts`：这包括`FinishComponent`的实现和视图模板。它遵循与`StartComponent`相同的模式。'
- en: Both the `Start` and `Finish` components have been defined with their own modules.
    The convention we will follow is module per top-level view.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`Start`和`Finish`组件都已经使用自己的模块进行了定义。我们将遵循的约定是每个顶级视图一个模块。'
- en: All three components are ready. Time to define the route configurations!
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 三个组件都已准备就绪。是时候定义路由配置了！
- en: Route configuration
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 路由配置
- en: 'To set up the routes for *7 Minute Workout*, we are going to create a route
    definition file. Create a file called `app.routes.ts` in the `components/app`
    folder defining the top-level routes for the app. Add the following routing setup:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设置*7分钟锻炼*的路由，我们将创建一个路由定义文件。在`components/app`文件夹中创建一个名为`app.routes.ts`的文件，定义应用程序的顶级路由。添加以下路由设置：
- en: '[PRE5]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `routes` variable is an array of `Route` objects. Each `Route` defines
    the configuration of a single route, which contains:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`routes`变量是`Route`对象的数组。每个`Route`定义了单个路由的配置，其中包含：'
- en: '`path`: The target path to match'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`path`：要匹配的目标路径'
- en: '`component`: The component to be loaded when the path is hit'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`component`：当路径被命中时要加载的组件'
- en: 'Such a route definition can be interpreted as: "When the user navigates to
    a path (defined in `path`), load the corresponding component defined in the `component`
    property." Take the first route example; navigating to `http://localhost:9000/start`
    loads the component view for `StartComponent`.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的路由定义可以解释为：“当用户导航到一个路径（在`path`中定义），加载`component`属性中定义的相应组件。”以第一个路由示例为例；导航到`http://localhost:9000/start`会加载`StartComponent`的组件视图。
- en: You may have noticed that the last `Route` definition looks a bit different.
    The `path` looks odd and it does not have a `component` property either. A path
    with `**` denotes a catch-all path or the *wildcard route* for our app. Any navigation
    that does not match one of the first three routes, matches the catch-all route,
    causing the app to navigate to the start page (defined in the `redirectTo` property).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到最后一个`Route`定义看起来有点不同。`path`看起来很奇怪，而且也没有`component`属性。带有`**`的路径表示一个捕获所有路径或我们应用程序的*通配符路由*。任何不匹配前三个路由之一的导航都会匹配捕获所有路由，导致应用程序导航到起始页面（在`redirectTo`属性中定义）。
- en: Note
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We can try this once the routing setup is complete. Type any random route such
    as `http://localhost:9000/abcd` and the app automatically redirects to `http://localhost:9000/start`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦路由设置完成，我们可以尝试这个。输入任意随机路由，如`http://localhost:9000/abcd`，应用程序会自动重定向到`http://localhost:9000/start`。
- en: 'The final call to `RouterModule.forRoot` is used to export this route setup
    as a module. We use the setup (exported as `routing`) inside AppModule to complete
    the route setup. Open `app.module.ts` and import the routing setup as well the
    modules we have created with respect to the `Start` and `Finish` pages:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 最后调用`RouterModule.forRoot`用于将此路由设置导出为模块。我们在AppModule中使用这个设置（导出为`routing`）来完成路由设置。打开`app.module.ts`并导入路由设置以及我们根据`Start`和`Finish`页面创建的模块：
- en: '[PRE6]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now that we have all the required components and all the routes defined, where
    do we inject these components on route change? We just need to define a placeholder
    for that in the host view.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了所有所需的组件和所有定义的路由，我们在路由更改时在哪里注入这些组件呢？我们只需要在宿主视图中为其定义一个占位符。
- en: Rendering component views with router-outlet
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用router-outlet渲染组件视图
- en: 'If we check the current `TrainerAppComponent` template, it has an embedded
    `WorkoutRunnerComponent`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们检查当前的`TrainerAppComponent`模板，它有一个嵌入的`WorkoutRunnerComponent`：
- en: '[PRE7]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This needs to change. Remove the preceding declaration and replace it with:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要改变。删除前面的声明并替换为：
- en: '[PRE8]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`RouterOutlet` is an Angular component directive that acts as a placeholder
    for a child component to load on route change. It integrates with the router to
    load the appropriate component based on the current browser URL and the route
    definition.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`RouterOutlet`是一个Angular组件指令，作为一个占位符，在路由更改时加载子组件。它与路由器集成，根据当前浏览器URL和路由定义加载适当的组件。'
- en: 'The following diagram helps us to easily visualize what is happening with the
    `router-outlet` setup:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表帮助我们轻松地可视化了`router-outlet`的设置发生了什么：
- en: '![Rendering component views with router-outlet](../Images/image00447.jpeg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![使用router-outlet渲染组件视图](../Images/image00447.jpeg)'
- en: We are almost done now; it's time to trigger navigation.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在几乎完成了；是时候触发导航了。
- en: Route navigation
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 路由导航
- en: 'Like standard browser navigation, Angular navigation can happen:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 像标准浏览器导航一样，Angular导航可以发生：
- en: When a user enters a URL directly in the browser
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用户直接在浏览器中输入URL时
- en: On clicking on a link on the anchor tag
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单击锚标签上的链接
- en: On using a script/code to navigate
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用脚本/代码进行导航
- en: If not started, start the app and load `http://localhost:9000` or `http://localhost:9000/start`.
    The start page should be loaded.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果尚未启动，请启动应用程序并加载`http://localhost:9000`或`http://localhost:9000/start`。应该加载开始页面。
- en: Click on the **Start** button of the page and the workout view should be loaded
    at `http://localhost:9000/workout`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 单击页面上的**开始**按钮，训练视图应该加载到`http://localhost:9000/workout`。
- en: Note
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The Angular router also supports the old style of *hash (#)-based routing*.
    When hash-based routing is enabled, the routes appear as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Angular路由器还支持旧式的基于*哈希（#）*的路由。启用基于哈希的路由时，路由如下所示：
- en: '`localhost:9000/#/start`'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`localhost:9000/#/start`'
- en: '`localhost:9000/#/workout`'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`localhost:9000/#/workout`'
- en: '`localhost:9000/#/finish`'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`localhost:9000/#/finish`'
- en: 'The default routing option is *pushState*-based. To change it to hash-based
    routing, the route configuration for the top level routes changes during route
    setup as shown in this example: `export const routing: ModuleWithProviders` `=
    RouterModule.forRoot(routes,` `**{ useHash: true }**` `);`'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '默认的路由选项是基于*pushState*的。要将其更改为基于哈希的路由，顶级路由的路由配置在路由设置期间更改，如本例所示：`export const
    routing: ModuleWithProviders` `= RouterModule.forRoot(routes,` `**{ useHash: true
    }**` `);`'
- en: 'Interestingly, the anchor link in the `StartComponent''s` view definition does
    not have a `href` attribute. Instead, there is a `RouterLink` directive:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，`StartComponent`视图定义中的锚链接没有`href`属性。相反，有一个`RouterLink`指令：
- en: '[PRE9]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This looks like a property binding syntax, where the `RouterLink` directive
    is taking an input parameter of type array. This is an array of route links parameters
    (or the link parameter array).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: The `routerLink` directive, together with the router, uses this link parameter
    array to resolve the correct URL path. In the preceding case, the only element
    in the array is the name of the route.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Notice the **/** prefix in the preceding route path. `/` is used to specify
    an absolute path. The Angular router also supports relative paths, which are useful
    when working with child routes. We will explore the concept of child routes in
    the next few chapters.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: 'Refresh the app and check the rendered HTML for `StartComponent`; the preceding
    anchor tag is rendered as:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Tip
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Avoid hardcoding route links**'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: While you could have directly used `<a href="/workout">`, prefer `routerLink`
    to avoid hardcoding routes.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: Link parameter array
  id: totrans-138
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The link parameter array passed to the `routerLink` directive follows a specific
    pattern:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The first element is always the route path, and the next set of parameters is
    there to replace placeholder tokens defined in a route template.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: 'The route setup for the current *7 Minute Workout* is quite simple, and there
    isn''t a need to pass parameters as part of link generation. But the capability
    is there for non-trivial routes that require dynamic parameters. See this example:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This is how the first route can be generated:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Angular router is quite a beast and supports almost everything that we expect
    of a modern router library. It supports child routes, async routes, lifecycle
    hooks, and some other advanced scenarios. We'll delay discussion on these topics
    until later chapters. This chapter just gets us started with Angular routing,
    but there is more to come!
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: 'The router link parameter can also be an object. Such objects are used to supply
    *optional parameters* to the route. See this example:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note that the generated link contains a semicolon to separate parameters from
    the route and other parameters.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: The last missing part in the implementation is routing to the finish pages once
    the workout completes.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: Using the router service for component navigation
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Navigation from the workout page to the finish page is not triggered manually
    but on completion of the workout. `WorkoutRunnerComponent` needs to trigger this
    transition.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: For this, `WorkoutRunnerComponent` needs to get hold of the component router
    and invoke the `navigate` method on it.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: How does `WorkoutRunnerComponent` get the router instance? Using Angular's *dependency
    injection framework*. We have been shying away from this topic for some time now.
    We have achieved a lot without even knowing that there's a dependency injection
    framework in play all this while.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: Let's wait a tad longer and firstly concentrate on fixing the navigation issue.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: 'For `WorkoutRunnerComponent` to get hold of the router service instance, it
    just needs to declare the service on the constructor. Update the `WorkoutRunnerComponent`
    constructor and add the imports:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Angular now magically injects the current router into the `router` private variable
    when `WorkoutRunnerComponent` is instantiated. The magic it uses is the *dependency
    injection framework*.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s now just a matter of replacing the statement `console.log("Workout complete!");`
    with the call to the `navigation` router:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `navigate` method takes the same link parameter array as the `RouterLink`
    directive. We can verify the implementation by patiently waiting for the workout
    to complete!
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are having a problem with running the code, look at the git branch `checkpoint3.1`
    for a working version of what we have done thus far.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: Or if you are not using git, download the snapshot of `checkpoint3.1` (a ZIP
    file) from [http://bit.ly/ng2be-checkpoint3-1](http://bit.ly/ng2be-checkpoint3-1).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: If you are still wondering how to access route parameters for the current route,
    we have the `ActivatedRoute` service.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Using the ActivatedRoute service to access route params
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are times when the current view requires access to the active route state.
    Information such as the current URL fragment, the current route parameters, and
    other route-related data may come in handy during component implementation.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: The `ActivatedRoute` service is a one-stop shop for all current route-related
    queries. It has a number of properties, including `url` and `params`, that can
    utilize the route's current state.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an example of a parameterized route and how to access a parameter
    passed from a component. Given this route:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'When the user navigates to `/user/5`, the underlying component can access the
    `:id` parameter value by first injecting `ActivatedRoute` into its constructor:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'It then queries the `id` property from the `params` property of the `ActivatedRoute`
    service. Look at this example:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `params` property on `ActivatedObject` is actually an *observable*. We will
    learn more about observables later in the chapter, but for now it is enough to
    understand that observables are objects that raise events and can be subscribed
    to.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: We use the `forEach` function on the `route.params` observable to get the route's
    parameters. The callback object (`params:Params`) contains properties corresponding
    to each route parameter. Check how we retrieve the `id` property and use it.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: 'We have now covered the basic Angular routing infrastructure, but there is
    more to explore in the later chapters. It''s now time to concentrate on a much
    overdue topic: *Dependency Injection*.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: Angular dependency injection
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Angular makes heavy use of dependency injection to manage app and framework
    dependencies. The surprising part is that we could ignore this topic until we
    started our discussion on the router without compromising our understanding of
    how things work. All this while, the Angular dependency injection framework has
    been supporting our implementation. The hallmark of a good dependency injection
    framework is that the consumer can use it without bothering about the internals
    and with little ceremony.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: If you are not sure what dependency injection is or just have a vague idea about
    it, an introduction to DI surely does not hurt anyone.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Dependency injection 101
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For any application, its components (not to be confused with Angular components)
    do not work in isolation. There are dependencies between them. A component may
    use other components to achieve its desired functionalities. **Dependency injection**
    is a pattern for managing such dependencies.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: The DI pattern is popular in many programming languages as it allows us to manage
    dependencies in a loosely coupled manner. With such a framework in place, dependent
    objects are managed by a DI container. This makes dependencies swappable and the
    overall code more decoupled and testable.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: The idea behind DI is that an object does not create\manage its own dependencies.
    Instead, the dependencies are provided from outside. These dependencies are made
    available either through a constructor, which is called **constructor injection**
    (Angular also does this) or by directly setting the object properties, which is
    called **property injection**.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a rudimentary example of DI in action. Consider a class called `Tracker`
    that requires a `Logger` for a logging operation:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The dependency of the class `Logger` is hardwired inside `Tracker`. What if
    we externalize this dependency? So the class becomes:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This innocuous-looking change has a major impact. By adding the ability to
    provide the dependency externally, we can now:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: 'Decouple components and enable extensibility. The DI pattern allows us to alter
    the logging behavior of the `Tracker` class without touching the class itself.
    Here is an example:'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The two `Tracker` objects we just saw have different logging capabilities for
    the same `Tracker` class implementation. `trackerWithDBLog` logs to a DB and `trackerWithMemoryLog`
    to the memory (assuming both `DBLogger` and `MemoryLogger` are derived from `Logger`
    class). Since Tracker is not dependent of specific implementation on a `Logger`
    (`DBLogger` or `MemoryLogger`), this implies `Logger` and `Tracker` are loosely
    coupled. In future we can derive a new `Logger` class implementation and use that
    for logging without changing the `Tracker` implementation.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: 'Mock dependencies: The ability to mock dependencies makes our components more
    testable. The tracker implementation can be tested in isolation (unit testing)
    by providing a mock implementation for Logger such as MockLogger, or by using
    a mocking framework that can easily mock the `Logger` interface.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can now understand how powerful DI is. Once DI is in place, the responsibility
    for resolving the dependencies falls on the calling/consumer code. In the preceding
    example, a class that was earlier instantiating `Tracker` now needs to create
    a `Logger` derivation and inject it into `Tracker` before using it.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Clearly, this flexibility in swapping internal dependencies of a component comes
    at a price. The calling code implementation can become overly complex as it now
    has to manage child dependencies too. This may seem simple at first, but given
    the fact that dependent components may themselves have dependencies, what we are
    dealing with is a complex dependency tree structure.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: To make dependency management less cumbersome for the calling code, there is
    a need for DI containers/frameworks. These containers are responsible for constructing/managing
    dependencies and providing it to our client/consumer code.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: The Angular DI framework manages dependencies for our Angular components, directives,
    pipes, and services.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: Exploring dependency injection in Angular
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Angular employs its very own DI framework to manage dependencies across the
    application. The very first example of visible dependency injection was the injection
    of the component router into `WorkoutRunnerComponent`:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: When the `WorkoutRunnerComponent` class gets instantiated, the DI framework
    internally locates/creates the correct router instance and injects it into the
    caller (in our case, `WorkoutRunnerComponent`).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: While Angular does a good job at keeping the DI infrastructure hidden, it's
    imperative that we understand how Angular DI works. Otherwise, everything may
    seem rather magical.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: 'DI is about creating and managing dependencies, and the framework component
    that does this is dubbed the **injector**. For the injector to manage dependencies,
    it needs to understand the following:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '**The what:** What is the dependency? The dependency could be a class, an object,
    a factory function, or a value. Every dependency needs to be registered with the
    DI framework before it can be injected.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The where/when:** The DI framework needs to know where to inject a dependency
    and when.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The how**: The DI framework also needs to know the recipe for creating the
    dependency when requested.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any injected dependency needs to answer these questions irrespective of whether
    it's a framework construct or artefacts created by us.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: 'Take for example the `Router` instance injection done in `WorkoutRunnerComponent`.
    To answer the what and how parts, we register the `Router` service in the app
    module (`app.module.ts`) via the import statement on the module decorator:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `routing` variable is a module that exports multiple routes together with
    all the Angular-router-related services (technically it re-exports `RouterModule`).
    We export this variable from `app.routes.ts` with this statement:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The where and when are decided based on the component that requires the dependencies.
    The constructor of `WorkoutRunnerComponent` takes a dependency of `Router`. This
    informs the injector to inject the current `Router` instance when `WorkoutRunnerComponent`
    is created as part of route navigation.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Internally, the Injector determines the dependencies of a class based on the
    metadata reflected from it when converting TypeScript to ES5 code (done by the
    TypeScript compiler). The metadata is generated only if we add a decorator such
    as `@Component` or `@RouteConfig` on the class.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: What happens if we inject `Router` into another class? Is the same `Router`
    instance used? The short answer is yes. The Angular injector creates and caches
    dependencies for future reuse, and hence these services are singleton in nature.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While dependencies in an injector are singleton, at any given time, there can
    be multiple injectors active throughout an Angular app. You'll learn about the
    injector hierarchy shortly.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: With the router, there is another layer of complexity. Since Angular supports
    the *child route* concept, each of these routes has its own router instance. Wait
    until we cover child routers in the next chapter so that you can understand the
    intricacies!
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: Let's create an Angular service to track workout history. This process will
    help you understand how dependencies are wired using Angular DI.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: Tracking workout history
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It would be a great addition to our app if we could track the workout history.
    When did we last exercise? Did we complete it? How much time did we spend?
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: Tracing the workout history requires us to track workout progress. Somehow,
    we need to track when the workout starts and when it stops. This tracking data
    then needs to be persisted somewhere.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: One way to implement this history tracking is by extending our `WorkoutRunnerComponent`
    with the desired functionality. But that adds unnecessary complexity to `WorkoutRunnerComponent`
    and that's not its primary job. We need a dedicated history tracking service for
    this job, a service that tracks historical data and shares it throughout the app.
    Let's start building the `WorkoutHistoryTracker` service.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: Building the WorkoutHistoryTracker service
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the `WorkoutHistoryTracker` service, we plan to track the execution of
    the workout. The service also exposes an interface, allowing `WorkoutRunnerComponent`
    to start and stop workout tracking.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `services` folder inside the `src` folder if not there and add a file
    called `workout-history-tracker.ts` with this code:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: There are two classes defined: `WorkoutHistoryTracker` and `WorkoutLogEntry`.
    As the name suggests, `WorkoutLogEntry` defines log data for one workout execution.
    `maxHistoryItems` allows us to configure the maximum number of items to store
    in the `workoutHistory` array, the array that contains the historical data. The
    `get tracking()` method defines a getter property for `workoutTracked` in TypeScript.
    `workoutTracked` is set to `true` during workout execution.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add the start tracking, stop tracking, and exercise complete functions:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `startTracking` function creates a `WorkoutLogEntry` and adds it to the
    `workoutHistory` array. By setting the `currentWorkoutLog` to the newly created
    log entry, we can manipulate it later during workout execution. The `endTracking`
    function and the `exerciseComplete` function just alter `currentWorkoutLog`. The
    `exerciseComplete` function should be called on completion of each exercise that
    is part of the workout.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, add a function that returns the complete historical data:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: That completes the `WorkoutHistoryTracker` implementation; now it's time to
    integrate it into workout execution.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: Integrating with WorkoutRunnerComponent
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `WorkoutRunnerComponent` requires `WorkoutHistoryTracker` to track workout
    history; hence there is a dependency to be fulfilled.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: To make `WorkoutHistoryTracker` discoverable, it needs to be registered with
    the framework. At this point, we are spoilt for choices. There are a number of
    ways to register a dependency and a number of places too! This flexibility makes
    the DI framework very powerful, albeit it adds to the confusion too.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: Let's firstly try to understand the different mechanisms we can use to register
    a dependency using the `WorkoutHistoryTracker` as an example.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: Registering dependencies
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The simplest way to register a dependency is to register it at the root/global
    level. This can be done by passing the dependency type into the `provides` attribute
    (array) in the module decorator.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in this example, adding `WorkoutHistoryTracker` to any module''s `providers`
    array registers the service globally:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Technically speaking, when a service is added to the `providers` array it gets
    registered with the **app's root injector**, irrespective of the Angular module
    it is declared in. Any Angular artefact in any module henceforth can use the service
    (`WorkoutHistoryTracker`). No module imports are required at all.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This behavior is different from component/directive/pipe registration. Such
    artefacts have to be exported from a module for another module to use them.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: 'Providers create dependencies when the Angular injector requests them. These
    providers have the recipe to create these dependencies. While a class seems to
    be the obvious dependency that can be registered, we can also register:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: A specific object/value
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A factory function
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Directly using the class type to register a dependency (as shown in the `bootstrap`
    function) may mostly meet our needs, but at times we need some flexibility with
    our dependency registrations. The expanded version of provider registration syntax
    gives us that flexibility.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: To learn about these variations, we need to explore providers and dependency
    registration in a little more detail.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: Angular providers
  id: totrans-252
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Providers create dependencies that are served by the DI framework.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at the `WorkoutHistoryTracker` dependency registration in the previous
    section:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This syntax is a short-form notation for the following version:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The first property (`provide`) is a token that acts like a key for registering
    a dependency. This key also allows us to locate the dependency during dependency
    injection.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: The second property (`useClass`) is a provider definition object that defines
    the recipe for creating the dependency value. The framework provides a number
    of ways to create these dependencies, as we will see shortly.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: With `useClass`, we are registering class `provider`.  The class `provider` create
    dependencies by instantiating the type of object requested for.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: Value providers
  id: totrans-261
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The class `provider` create class objects and fulfil the dependency, but at
    times we want to register a specific object/primitive with the DI provider instead.
    Value providers solve this use case.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: 'Take an example of `WorkoutHistoryTracker` registered using this technique:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'What is registered is an instance of the `WorkoutHistoryTracker` object created
    by us, instead of letting Angular DI create one. Take such hand-crafted dependencies
    (dependencies created manually) into consideration if there are dependencies further
    down the lineage that too need to be hand-crafted. Take the example of `WorkoutHistoryTracker`
    again. If `WorkoutHistoryTracker` has some dependencies, those too need to be
    fulfilled by manual injection:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Value providers come in handy in specific scenarios. For example, we can register
    a common app configuration using a value provider:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Or register a mock dependency while unit-testing:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Factory providers
  id: totrans-271
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There are times when injection is not a trivial affair. Injection depends upon
    external factors. These factors decide what objects or class instances are created
    and returned. Factory providers do this heavy lifting.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: 'Take an example where we want to have different configurations for dev and
    production releases. We can very well use a factory implementation to select the
    right configuration:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'A factory function can have its own dependencies too. In such a case, the syntax
    changes a bit:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The dependency is passed as a parameter to the factory function and registered
    on the provider definition object property, `deps`.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: Use the `UseFactory` provide if the construction of the dependency is complex
    and not everything can be decided during wire-up.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: While we have a number of options to declare dependencies, consuming dependencies
    is far simpler.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-280
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before continuing further, let's register the `WorkoutHistoryTracker` service
    in a new service module. This new module (`ServicesModule`) will be used to register
    all application-wide services.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: 'Copy the module definition from the git branch `checkpoint3.2` into the `src/services`
    folder locally. You can download it from this GitHub location: [http://bit.ly/ng2be-3-2-services-module-ts](http://bit.ly/ng2be-3-2-services-module-ts).
    Also delete all references to the `LocalStorage` service as we plan to add it
    later in the chapter. Finally, import the module into `AppModule` (`app.module.ts`).'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: Injecting dependencies
  id: totrans-283
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Consuming dependency is easy! More often than not, we use constructor injection
    to consume a dependency.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: Constructor injection
  id: totrans-285
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the `import` statement at the top and update the `WorkoutRunnerComponent''s`
    constructor, as follows:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: As with router, Angular injects `WorkoutHistoryTracker` too when `WorkoutRunnerComponent`
    is created. Easy!
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: Before we continue any further with our integration, let's explore some other
    facts about Angular's DI framework.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: Explicit injection using injector
  id: totrans-290
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We can even do explicit injection using Angular''s `Injector` service. This
    is the same injector Angular uses to support DI. Here is how to inject the `WorkoutHistoryTracker`
    service using `Injector`:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: We inject the `Injector` first and then ask the `Injector` for the `WorkoutHistoryTracker`
    instance explicitly.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: When would someone want to do this? Well, almost never. Avoid this pattern as
    it exposes the DI container to your implementation and adds a bit of noise too.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: Consuming dependency was easy, but how does the DI framework locate these dependencies?
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: Dependency tokens
  id: totrans-296
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember this expanded version of dependency registration shown earlier?
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The `provide` property value is a token. This token is used to identify the
    dependency to inject. Whenever Angular sees this statement:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: It injects the correct dependency based on the class type. This is an example
    of a class token. The class type is used for dependency searching/mapping. Angular
    supports some other tokens too.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: String token
  id: totrans-302
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Instead of a class, we can use a string literal to identify a dependency. We
    can register the `WorkoutHistoryTracker` dependency using a string token, as follows:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'If we now do:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Angular does not like it one little bit and fails to inject the dependency.
    Since the `WorkoutHistoryTracker` seen before was registered with a string token,
    the token needs to be provided during injection too.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: 'To inject a dependency registered using a string token, we need to use the
    `@Inject` decorator. This works perfectly fine:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Tip
  id: totrans-310
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When `@Inject()` is not present, the Injector uses the type name of the parameter
    (class token).
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: 'String tokens are useful when registering instances or objects. The app configuration
    registration examples that we shared earlier can be rewritten using string tokens
    if there is no such class as `AppConfig`:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'And then injected using `@Inject`:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Note
  id: totrans-316
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'While any object can act as a token, the most common token types are class
    and string tokens. Internally, provider turns the token parameter into an instance
    of the `OpaqueToken` class. Look at the framework documentation to learn more
    about `OpaqueToken`:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: '[https://angular.io/docs/ts/latest/api/core/index/OpaqueToken-class.html](https://angular.io/docs/ts/latest/api/core/index/OpaqueToken-class.html).'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: While the `WorkoutHistoryTracker` injection into `WorkoutRunnerComponent` is
    done, its integration is still incomplete.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: Integrating with WorkoutRunnerComponent - continued
  id: totrans-320
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The history tracker instance (`tracker`) needs to be called when the workout
    starts, when an exercise is complete, and when the workout finishes.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this as the first statement in the `start` function:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'In the `startExerciseTimeTracking` function, add the highlighted code after
    the `clearInterval` call:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'And the highlighted code inside the workout to complete the `else` condition
    in the same function:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: History tracking is almost complete except for one case. What if the user manually
    navigates away from the workout page?
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: When that happens, we can always rely on the component's lifecycle hooks/events
    to help us. Workout tracking can be stopped when the `NgOnDestroy` event is fired.
    An appropriate place to perform any clean-up work is before the component is removed
    from the component tree. Let's do it.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this function to `workout-runner.component.ts`:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: While we now have workout history tracking implemented, we don't have a mechanism
    to check the history. The pressing need is for a workout history page/component.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: Adding the workout history page
  id: totrans-333
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The workout history data that we are collecting during the execution of the
    workout can now be rendered in a view. Let's add a History component. The component
    will be available at the `/history` location and can be loaded by clicking on
    a link in the app header section.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the route definition in `app.routes.ts` to include a new route and the
    related import:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The **History** link needs to be added to the app header section. Let''s refactor
    the header section into its own component. Update the `app.component.ts` template
    `navbar` `div` to:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'There is a new `HeaderComponent` here. Copy the definition for the header component
    (`header.component.ts`) from the git branch `checkpoint3.2`, `app` folder (GitHub
    location: [http://bit.ly/ng2be-3-2-header-component-ts](http://bit.ly/ng2be-3-2-header-component-ts)).
    Also add the component to the declarations array in `app.module.ts` as we do for
    any Angular component:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: If you look at `HeaderComponent`, the history link is now there. Let's add the
    workout history component.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: 'The `WorkoutHistoryComponent` implementation is available in the git branch
    `checkpoint3.2`; the folder is `workout-history` (GitHub location: [http://bit.ly/ng2be-3-2-workout-history](http://bit.ly/ng2be-3-2-workout-history)).
    Copy all three files from the folder to a corresponding folder locally. Remember
    to maintain the same folder hierarchy in your local setup too. Make a note that
    `WorkoutHistoryComponent` has been defined in a separate module (`WorkoutHistoryModule`)
    and needs to be imported into `AppModule` (`app.module.ts`). Import `WorkoutHistoryModule`
    into `AppModule` before proceeding further. For now remove all references to `SharedModule`
    from `WorkoutHistoryModule`.'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: 'The `WorkoutHistoryComponent` view code is trivial to say the least: a few
    Angular constructs, including `ngFor` and `ngIf`. The component implementation
    too is pretty straightforward. Inject the `WorkoutHistoryTracker` service dependency
    and set the history data when `WorkoutHistoryComponent` is initialized:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'And this time, we use the `Location` service instead of `Router` to navigate
    away from the history component:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The Location service is used to interact with the browser URL. Depending upon
    the URL strategy, either URL paths (such as `/start`, `/workout`) or URL hash
    segments (such as `#/start`, `#/workout`) are used to track location changes.
    The router service too uses the location service internally to trigger navigation.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-348
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Router versus Location**'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: While the `Location` service allows us to perform navigation, using `Router`
    is a preferred way to perform route navigation. We used the location service here
    because the need was to navigate to the last route without bothering about how
    to construct the route.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: 'We are ready to test our workout history implementation. Load the start page
    and click on the **History** link. The history page is loaded with an empty grid.
    Start a workout and let an exercise complete. Check the history page again; there
    should be a workout listed:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding the workout history page](../Images/image00448.jpeg)'
  id: totrans-352
  prefs: []
  type: TYPE_IMG
- en: Looks good, except for one sore point in this listing. It would be better if
    the historical data were ordered chronologically, with the newest at the top.
    And it would be great if we had filtering capabilities too.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: Sorting and filtering history data using pipes
  id: totrans-354
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [Chapter 2](part0028.xhtml#QMFO1-edca168d36254bda8a21f611a95615c3 "Chapter 2. 
    Building Our First App - 7 Minute Workout"), *Building Our First App - 7 Minute
    Workout*, we explored pipes. We even built our own pipe to format seconds values
    as hh:mm:ss. Since the primary purpose of pipes is to transform data, this can
    be used with any input. For arrays, pipes can be used to sort and filter data.
    We create two pipes, one for each sorting and filtering.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-356
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Angular1 has prebuilt filters (filters are pipes in Angular2), `orderBy` and
    `filter`, for this very purpose. The effort to port these filters in Angular2
    has been stalled for now. See this GitHub issue: [http://bit.ly/ng2-issue-2340](http://bit.ly/ng2-issue-2340).'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with the `orderBy` pipe.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: The orderBy pipe
  id: totrans-359
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `orderBy` pipe we implement is going to order an array of objects based
    on any of the object''s properties. The usage pattern for sorting items in ascending
    order based on the `fieldName` property is going to be:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'And for sorting items in descending order, the usage pattern is:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Make note of the extra hyphen before `fieldName`.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a folder called `shared` in `src/components` and copy all three files
    located in the corresponding location in git branch `checkpoint3.2` (GitHub location:
    [http://bit.ly/ng2be-3-2-shared](http://bit.ly/ng2be-3-2-shared)). There are two
    pipes and a new module definition (`SharedModule`) in this folder. `SharedModule`
    defines components/directives/pipes that that are shared across the application.'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `order-by.pipe.ts` and look at the pipe implementation. While we are not
    going to delve into the pipe''s implementation details, some relevant parts need
    to be highlighted. Look at this pipe outline:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The preceding `field` variable receives the field on which sorting is required.
    Check the code below to understand how the `field` argument is passed.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: If the field has a `-` prefix, we truncate the prefix before sorting the array
    in descending order.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-370
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The pipe also uses the spread operator, which may be new to you. Learn more
    about the spread operator on MDN here: [http://bit.ly/js-spread](http://bit.ly/js-spread).'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: '**To use this pipe in the workout history view, import `SharedModule` into
    `WorkoutHistoryModule`.**'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the template HTML:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The historical data will now be sorted in descending order on `startedOn`.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-376
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Make note of the single quotes around the pipe parameter (`'-startedOn'`). We
    are passing a literal string to the `orderBy` pipe. Instead, pipe parameters can
    be bound to component properties too.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: That's enough for the `orderBy` pipe. Let's implement filtering.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: The search pipe
  id: totrans-379
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `SearchPipe` that we added earlier does a basic equality-based filtering.
    Nothing special.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: Look at the pipe code; the pipe takes two arguments, the first being the field
    to search and the second the value to search. We use the array's `filter` function
    to filter the record, doing a strict equality check.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s update the workout history view and incorporate the search pipe too.
    Open `workout-history.html` and uncomment the div with radio buttons. These radio
    buttons filter workouts based on whether they were completed or not. This is how
    the filter selection HTML looks:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'We can have three filters: `all`, `completed`, and `incomplete` workouts. The
    radio selection sets the component''s property `completed` using the `change`
    event expression. `$event.target` is the radio button that was clicked. We do
    not assign `completed=$event.target.value` as its value is of the string type.
    The `completed` property (on `WorkoutHistoryComponent`) should be of the `boolean`
    type for equality comparison with the `WorkoutLogEntry.completed` property to
    work.'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: 'The `search` pipe can now be added to the `ngFor` directive expression. We
    are going to chain the `search` and `orderBy` pipe. Update the `ngFor` expression
    to:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The `search` pipe first filters the historical data followed by the `orderBy`
    pipe reordering it. Pay close attention to the `search` pipe parameters: the first
    parameter is a string literal denoting the field to search (`''completed''`),
    whereas the second parameter is derived from the component property `completed`.
    Having the ability to bind pipe parameters to component properties allows us great
    flexibility.'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: Go ahead and verify the search capabilities of the history page. Based on the
    radio selection, the history records are filtered, and of course they are sorted
    in reverse chronological order based on the workout start dates.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: While pipe usage with arrays looks simple, it can throw up some surprises if
    we do not understand when pipes are evaluated.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: Pipe gotcha with arrays
  id: totrans-390
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To understand the issue with pipes applied to arrays, let's reproduce the problem.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `search.pipe.ts` and remove the `@Pipe` decorator attribute `pure`. Also
    change the following statement:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'To the following:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Add a button at the end of the radio list (in `workout-history.html`) that
    adds a new log entry to the `history` array:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Add a function to `WorkoutHistoryComponent`:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The preceding function duplicates the first history item and adds back to the
    `history` array. If we load the page and click on the button, a new log entry
    gets added to the history array but it does not show up on the view, unless we
    change the filter (by clicking on the other radios). Interesting!
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-401
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before calling `addLog` make sure at least one history log is already there;
    otherwise the `addLog` function will fail.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: The pipes that we have built thus far are *stateless* (also called pure) in
    nature. They simply transform input data into output. Stateless pipes are revaluated
    any time the pipe input changes (the expression on the left side of pipe symbol)
    or any pipe argument is updated.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: For arrays, this happens on an array assignment/reference change and not on
    the addition or deletion of elements. Switching the filter condition works as
    it causes the search pipe to evaluate again as the search parameter (the `completed`
    status) changes. This behavior is something to be aware of.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: 'What''s the fix? For starters, we can make the history array immutable, which
    implies that it cannot be changed once created. To add a new element we need to
    create a new array with the new value, something like:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Works perfectly, but we are changing our implementation to make it work with
    pipes. Instead, we can change the pipe and mark it stateful.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: The difference between a stateless and stateful pipe is that stateful pipes
    are evaluated by Angular every time the framework does a change detection run,
    which involves checking the complete application for changes. Therefore, with
    stateful pipes, the check is not limited to the pipe input/argument changes.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: 'To make a `search` pipe stateless, just update the `Pipe` decorator with `pure:false`:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: It still does not work! The `search` pipe has one more quirk that needs a fix.
    The **"All"** radio selection does not work perfectly. Add a new workout log,
    and it still does not show up, unless we switch filters.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: 'The fix here is to revert this line in the `search` pipe:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'To the following:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: We changed the `if` condition to return a new array every time (using the spread
    operator), even when `searchTerm` is `null`. If we return the same array reference,
    Angular does not check for a size change in the array and hence does not update
    the UI.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: That completes our History page implementation. You may now be wondering what
    the last few fixes on pipes have to do with how change detection works. Or you
    may be wondering what is change detection? Let's put all of these doubts to rest
    and introduce everyone to Angular's change detection system.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-418
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Angular's change detection will be covered extensively in [Chapter 8](part0080.xhtml#2C9D01-edca168d36254bda8a21f611a95615c3
    "Chapter 8.  Some Practical Scenarios"), *Some Practical Scenarios*. The aim of
    the next section is to introduce the concept of change detection and how Angular
    performs this process.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: Angular change detection overview
  id: totrans-420
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To put it succinctly, change detection is all about tracking changes done to
    the component model during app execution. This helps Angular's databinding infrastructure
    to identify what parts of the view need to be updated. Every databinding framework
    needs to address this issue, and the approach these frameworks take for tracking
    changes differs. It even differs from Angular1 to Angular2.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: To understand how change detection works in Angular, there are a few things
    that we need to keep in mind.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, an Angular app is nothing but a hierarchy of components, from root
    to the leaf.
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Secondly, there is nothing special about the component properties that we bind
    to view; therefore Angular needs an efficient mechanism to know when these properties
    change. It cannot keep polling for changes in these properties.
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And finally to detect changes in a property value Angular does a *strict comparison*
    (`===`) between the previous and current value. For reference types it means only
    the references are compared. No deep comparison is done.
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  id: totrans-426
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For precisely this reason, we had to mark our search pipe as stateful.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: Adding elements to an existing array does not change the array reference and
    hence Angular fails to detect any change to the array. Once the pipe is marked
    as stateful, the pipe is evaluated irrespective of whether the array has changed
    or not.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: Since Angular cannot know when any bound property is updated automatically,
    it instead resorts to checking every bound property when a change detection run
    is triggered. Starting from the root of the component tree, Angular checks each
    bound property for changes down the component hierarchy. If a change is detected
    that component is marked for refresh. It's worth reiterating that changes in a
    bound property do not immediately update the view. Instead, a change detection
    run works in two phases.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: In the first phase it does the component tree walk and marks components that
    need to be refreshed due to model updates
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the second phase, the actual view is synchronized with the underlying model
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  id: totrans-432
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Model changes and view updates are never interleaved during a change detection
    run.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: We now just need to answer two more questions. When is a change detection run
    triggered? And how many times does it run?
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: 'An Angular change detection run is triggered when any of these events are triggered:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: '**User input/ browser events**: We click on a button, enter some text, scroll
    the content. Each of these actions can update the view (and the underlying model).'
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Remote XHR requests**: This is another common reason for view updates. Getting
    data from a remote server to show on the grid and getting user data to render
    a view are examples of this.'
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**setTimeout and setInterval**: As it turns out, we can use `setTimeout` and
    `setInterval` to execute some code asynchronously and at specific intervals. Such
    code can also update the model. For example, a `setInterval` timer may check for
    stock quotes at regular interval and updates the stock price on the UI.'
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And most importantly each component model is checked only once, in a top-down
    fashion, starting from the root component to the tree leaves.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-440
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The last statement is true when Angular is configured to run in production mode.
    In development mode the component tree is traversed twice for changes. Angular
    expects that the model be stable after the first tree walk. If that is not the
    case Angular throws an error in development mode, and ignores the changes in production
    mode.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: We can enable production mode by invoking the `enableProdMode` function before
    the `bootstrap` function call. `import {enableProdMode} from '@angular/core'`
    `enableProdMode();` `platformBrowserDynamic().bootstrapModule(AppModule);`
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: Let's explore some other faÃ§ades of the Angular DI framework, starting with
    hierarchical injectors, a confusing yet very powerful feature of Angular.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: Hierarchical injectors
  id: totrans-444
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An injector in Angular is a dependency container that is responsible for storing
    dependencies and dispensing them when asked for. The provider registration examples
    shown earlier on modules actually register the dependencies with a global Injector.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: Registering component level dependencies
  id: totrans-446
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All of the dependency registration that we have done thus far were done inside
    a module. Angular goes one step further and allows registration of dependencies
    at the component level too. There is a similar providers attribute on the `@Component`
    decorator that allows us to register dependency at the component level.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: 'We could''ve very well registered the `WorkoutHistoryTracker` dependency on
    `WorkoutRunnerComponent`. Something on these lines:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: But whether we should do it or not is something that we are going to discuss
    in this section shortly.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: In the context of this discussion on hierarchical injectors, it's important
    to understand that Angular creates an injector per component (oversimplified).
    Dependency registration done at the component level is available on the component
    and its descendants.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: We also learned that dependencies are singleton in nature. Once created, the
    Injector will always return the same dependency every time. This feature is quite
    evident from the workout history implementation.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: '`WorkoutHistoryTracker` was registered with the `ServicesModule` and then injected
    into two components, `WorkoutRunnerComponent` and `WorkoutHistoryComponent`. Both
    components get the same instance of `WorkoutHistoryTracker`. The next diagram
    highlights this registration and injection:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: '![Registering component level dependencies](../Images/image00449.jpeg)'
  id: totrans-454
  prefs: []
  type: TYPE_IMG
- en: 'To confirm, just add a `console.log` statement in the `WorkoutHistoryTracker`
    constructor:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Refresh the app and open the history page by clicking on the header link. The
    message log is generated once, irrespective of how many times we run the workout
    or open the history page.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: We now see a new interaction/data flow pattern! Think carefully; a service is
    being used to share state between two components. `WorkoutRunnerComponent` is
    generating data and `WorkoutHistoryComponent` is consuming it. And that too without
    any interdependence. We are exploiting the fact that dependencies are singleton
    in nature. This data sharing/interaction/data flow pattern can be used to share
    state between any number of components. Indeed, this is a very powerful weapon
    in our arsenal. Next time, there is a need to share state between unrelated components,
    think of services.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: But what does this have to do with hierarchical injectors? Ok, let's not beat
    around the bush; let's get straight to the point.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: While dependencies registered with the injector are singleton, Injector itself
    is not! At any given point in time, there are multiple injectors active in the
    application. In fact, injectors are created in the same hierarchy as the component
    tree. Angular creates an `Injector` instance for every component in the component
    tree (oversimplification; see the next information box).
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-461
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Angular does not literally create an injector for each component. As explained
    in Angular the developer guide:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: Every component doesn't need its own injector and it would be horribly inefficient
    to create masses of injectors for no good purpose.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
- en: But it is true that every component has an injector (even if it shares that
    injector with another component) and there may be many different injector instances
    operating at different levels of the component tree.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: It is useful to pretend that every component has its own injector.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: 'The component and injector tree looks something like this when a workout is
    running:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: '![Registering component level dependencies](../Images/image00450.jpeg)'
  id: totrans-467
  prefs: []
  type: TYPE_IMG
- en: The insert textbox denotes the component name. The **root injector** is the
    injector created as part of the application bootstrap process.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
- en: What is the significance of this injector hierarchy? To understand the implications,
    we need to understand what happens when a component requests for a dependency.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: Angular DI dependency walk
  id: totrans-470
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Whenever requesting for a dependency, Angular first tries to satisfy the dependency
    from the component''s own injector. If it fails to find the requested dependency,
    it queries the parent component injector for the dependency, and its parent if
    the probing fails again, and so on and so forth till it finds the dependency or
    reaches the root injector. The takeaway: any dependency search is hierarchy-based.'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
- en: Earlier when we registered `WorkoutHistoryTracker`, it was registered with the
    root injector. The `WorkoutHistoryTracker` dependency request from both `WorkoutRunnerComponent`
    and `WorkoutHistoryComponent` was satisfied by the root injector, not their own
    component injectors.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: This hierarchical injector structure brings a lot of flexibility. We can configure
    different providers at different component levels and override the parent provider
    configuration in child components. This only applies to dependencies registered
    on components. If the dependency is added on a module it gets registered on the
    root injector.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
- en: Let's try to override the global `WorkoutHistoryTracker` service in components
    that use it to learn what happens on such overrides. It's going to be fun and
    we will learn a lot!
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `workout-runner.component.ts` and to the `@Component` decorator add a
    `providers` attribute:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Do this in `workout-history.component.ts` too. Now if we refresh the app, start
    a workout, and then load the history page, the grid is empty. Irrespective of
    the times we try to run the workout, the history grid is always empty.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
- en: 'The reason is quite obvious. Post setting the `WorkoutHistoryTracker` provider
    on each `WorkoutRunnerComponent` and `WorkoutHistoryComponent`, the dependency
    is being fulfilled by the respective component injectors themselves. Both component
    injectors create their own instance of `WorkoutHistoryTracker` when requested,
    and hence history tracking is broken. Look at the following diagram to understand
    how the request is fulfilled in both scenarios:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: '![Angular DI dependency walk](../Images/image00451.jpeg)'
  id: totrans-479
  prefs: []
  type: TYPE_IMG
- en: 'A quick question: What happens if we register the dependency in the root component,
    `TrainerAppComponent`, instead of doing it during app bootstrapping? Something
    like:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Interestingly, with this setup too, things work perfectly. That's pretty evident;
    `TrainerAppComponent` is a parent component for `RouterOutlet` that internally
    loads `WorkoutRunnerComponent` and `WorkoutHistoryComponent`. Hence in such a
    setup, the dependency gets fulfilled by the `TrainerAppComponent`'s injector.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-483
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Dependency lookup up on the component hierarchy can be manipulated if an intermediate
    component has declared itself as a host component. We will learn more about it
    in later chapters.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
- en: Hierarchical injectors allow us to register dependencies at a component level,
    avoiding the need to register all dependencies globally.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
- en: This functionality really comes in handy when building an Angular library component.
    Such components can register their own dependencies without requiring the consumer
    of the library to register library-specific dependencies.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-487
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Remember: if you are having trouble loading the right service/dependency, make
    sure you check the component hierarchy for overrides done at any level.'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
- en: We now understand how dependency resolution works in components. But what happens
    if a service has a dependency? Yet another uncharted territory to explore.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-490
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remove the `provider` registration we did in those two components before continuing
    further.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
- en: Dependency injection with @Injectable
  id: totrans-492
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `WorkoutHistoryTracker` has a fundamental flaw; the history is not persisted.
    Refresh the app and the history is lost. We need to add persistence logic to store
    historical data. To avoid any complex setup, we use the browser local storage
    to store historical data.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a `local-storage.ts` file to the `services` folder. And add the following
    class definition:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: A simple wrapper over the browser's `localStorage` object.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
- en: Go ahead and register the `LocalStorage` service in the services module (`services.module.ts`).
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
- en: 'And like any other dependency, inject it in the `WorkoutHistoryTracker` constructor
    (the `workout-history-tracker.ts` file) with the necessary import:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'This is standard DI stuff except that it does not work as expected. If we refresh
    the app now, Angular throws an error:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Strange! The all so awesome DI failed, and for no good reason! Not really; Angular
    is not doing any magic. It needs to know the class dependencies, and the only
    way it can know these is by inspecting the class definition and constructor arguments.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a decorator called `@Injectable()` (remember to add parentheses) above
    `WorkoutHistoryTracker` and add the module import statement:'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Refresh the page and the DI works perfectly. What made it work?
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
- en: By putting in the `@Injectable` decorator, we are forcing the TypeScript transpiler
    to generate metadata for the `WorkoutHistoryTracker` class. This includes details
    about the constructor arguments. Angular DI consumes this generated metadata to
    determine the types of dependency the service has, and in future it fulfils these
    dependencies when the service is created.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
- en: What about components using `WorkoutHistoryTracker`? We have not used `@Injectable`
    there but still the DI works. We don't need to. Any decorator works and there
    is already an `@Component` decorator applied to all components.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-508
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember the decorator needs to be added on the calling class (or client class).
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
- en: The actual integration between the `LocalStorage` service and `WorkoutHistoryTracker`
    is a mundane process.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the constructor for `WorkoutHistoryTracker` as follows:'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'And add a declaration for `storageKey`:'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: The constructor loads the workout logs from the local storage. The `map` function
    call is necessary as everything stored in `localStorage` is a string. Therefore,
    while de-serializing we need to convert the string back to the date value.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this statement last in the `startTracking`, `exerciseComplete`, and `endTracking`
    functions:'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: We save the workout history to local storage every time historical data changes.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
- en: That's it! We have built workout history tracking over `localStorage`. Verify
    it!
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
- en: Before we move on to our big-ticket item, audio support, there are a few minor
    fixes that are needed for a better user experience. The first one is related to
    the **History** link.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
- en: Tracking route changes using the router service
  id: totrans-521
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **History** link in the `Header` component is visible for all routes. It
    will be better if we hide the link on the workout page. We don't want to lose
    an in-progress workout by accidentally clicking on the **History** link. Moreover,
    no one is interested in knowing about the workout history while doing a workout.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
- en: The fix is easy. We just need to determine if the current route is the workout
    route and hide the link. The `Router` service is going to help us with this job.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `header.component.ts` and add the necessary imports for router; update
    the `Header` class definition to:'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: The `showHistoryLink` property determines if the history link is shown to the
    user or not. In the constructor, we inject the `Router` service and register a
    callback on the `events` property using the `subscribe` function.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
- en: The `events` property is an observable. We will learn more about observables
    later in the chapter, but for now it is enough to understand that observables
    are objects that raise events and can be subscribed to. The `subscribe` function
    registers a callback function that is invoked every time the route changes.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
- en: The callback implementation just toggles the `showHistoryLink` state based on
    the current route name. The name we derive from the `url` property of the `router`
    object.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the `showHistoryLink` in the view just update the header template line
    with the anchor tag to:'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: And that's it! The **History** link does not show up on the workout page.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
- en: Another fix/enhancement is related to the video panel on the workout page.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
- en: Fixing the video playback experience
  id: totrans-533
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The current video panel implementation can at best be termed amateurish. The
    size of the default player is small. When we play the video, the workout does
    not pause. The video playback is interrupted on exercise transitions. Also, the
    overall video load experience adds a noticeable lag at the start of every exercise
    routine. This is a clear indication that this approach to video playback needs
    some fixing.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what we are going to do to fix the video panel:'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
- en: Show the image thumbnail for the exercise video instead of loading the video
    player itself
  id: totrans-536
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the user clicks on the thumbnail, load a popup/dialog with a bigger video
    player that can play the selected video
  id: totrans-537
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pause the workout while the video playback is on
  id: totrans-538
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's get on with the job!
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
- en: Using thumbnails for video
  id: totrans-540
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Replace the `ngFor` template html inside `video-player.html` with this snippet:'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: We have abandoned iframe and instead loaded the thumbnail image of the video
    (check the `img` tag). All other content shown here is for styling the image.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-544
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have referenced the Stack Overflow post at [http://bit.ly/so-yt-thumbnail](http://bit.ly/so-yt-thumbnail)
    to determine the thumbnail image URL for our videos.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
- en: Start a new workout; the images should show up, but the playback functionality
    is broken. We need to add the video playback dialog.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
- en: Using the angular2-modal dialog library
  id: totrans-547
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Angular framework does not come with any pre-packaged UI library/controls.
    We need to look outwards and find a community solution for any UI control requirements.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
- en: The library we are going to use is angular2-modal, available on GitHub at [http://bit.ly/angular2-modal](http://bit.ly/angular2-modal).
    Let's install and configure the library.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
- en: 'From the command line (inside the `trainer` folder), run the following command
    to install the library:'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'To integrate angular2-modal within our app, we need to add the package references
    for angular2-modal in `systemjs.config.js`. Copy the updated `systemjs.config.js`
    from git branch `checkpoint3.2` (GitHub location: [http://bit.ly/ng2be-3-2-system-config-js](http://bit.ly/ng2be-3-2-system-config-js))
    in the `trainer` folder and overwriting the local configuration file. The updated
    configurations allow SystemJS to know how to load the modal dialog library when
    it encounters library `import` statements.'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
- en: 'The next few steps highlight the configuration ceremony to be performed before
    angular2-modal can be used:'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
- en: 'In the first step, we configure the root element for angular2-modal. Open `app.component.ts`
    and add the highlighted code:'
  id: totrans-554
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: This step is essential as the modal dialog needs a container component to host
    itself. By passing in the `ViewContainerRef` of `TrainerAppComponent`, we allow
    the dialog to load inside the app root.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to add two modules from the library to `AppModule`. Update
    `app.module.ts` and add this code:'
  id: totrans-557
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: The library is now ready for use.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
- en: While angular2-modal has a number of predefined templates for standard dialogs
    such as alert, prompt, and confirm, these dialogs provide little customization
    in terms of look and feel. To have better control over the dialog UI, we need
    to create a custom dialog, which thankfully the library supports.
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
- en: Creating custom dialogs with angular2-modal
  id: totrans-561
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Custom dialogs in angular2-modal are nothing but Angular components with some
    special library constructs incorporated.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
- en: 'Copy the `video-dialog.component.ts` file from the `workout-runner/video-player`
    folder in git branch `checkpoint3.2` (GitHub location: [http://bit.ly/ng2be-3-2-video-dialog-component-ts](http://bit.ly/ng2be-3-2-video-dialog-component-ts))
    into your local setup. The file contains the custom dialog implementation.'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, update `workout-runner.module.ts` and add a new `entryComponents` attribute
    to the module decorator:'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-565
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: The `VideoDialogComponent` needs to be added to `entryComponents` as it is not
    explicitly used in the component tree.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
- en: The `VideoDialogComponent` is a standard Angular component, with some modal
    dialog, specific implementations that we describe later.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
- en: The `VideoDialogContext` class has been created to pass the `videoId` of the
    YouTube video clicked to the dialog instance. The class inherits from `BSModalContext` a
    configuration class the dialog library uses to alter the behavior and UI of the
    modal dialog.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
- en: To get a better sense of how `VideoDialogContext` is utilized, let's invoke
    the preceding dialog from workout runner.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `ngFor` div in `video-player.html` and add a `click` event handler:'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'The preceding handler invokes the `playVideo` method, passing in the video
    clicked. The `playVideo` function in turn opens the corresponding video dialog.
    Add the `playVideo` implementation to `video-player.component.ts` as highlighted:'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: The `playVideo` function calls the `Modal` class `open` function, passing in
    the dialog component to open and a new instance of the `VideoDialogContext` class
    with the `videoId` of the YouTube video. Before proceeding, delete the `ngOnChange`
    function from the file too.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
- en: The dialog implementation in `video-dialog.component.ts` implements the `ModalComponent<VideoDialogContext>`
    interface, required by the modal library. Look at how the context (`VideoDialogContext`)
    to the dialog is passed to the constructor and how we extract and assign the `videoId`
    property from the context. Then it's just a matter of binding the `videoId` property
    to the template view (see the template HTML) and rendering the YouTube player.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
- en: And we are good to go. Load the app and start the workout. Then click on any
    workout video images. The video dialog should load and now we can watch the video!
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we call the dialog implementation complete, there is one small issue
    that needs to be fixed. When the dialog opens the workout should pause: that''s
    not happening currently. We will fix it in the next section using Angular eventing
    support.'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-578
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are having a problem with running the code, look at git branch `checkpoint3.2`
    for a working version of what we have done thus far.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
- en: Or if you are not using git, download the snapshot of `checkpoint3.2` (a ZIP
    file) from [http://bit.ly/ng2be-checkpoint3-2](http://bit.ly/ng2be-checkpoint3-2).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one last feature that we plan to add to *7 Minute Workout* before
    wrapping up the application and building something new with Angular: audio support.
    It teaches us some new cross-component communication patterns too.'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
- en: Cross-component communication using Angular events
  id: totrans-582
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We touched upon events in the last chapter when learning about Angular's binding
    infrastructure. It's time now to look at eventing in more depth. Let's add audio
    support to *7 Minute Workout*.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
- en: Tracking exercise progress with audio
  id: totrans-584
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For the *7 Minute Workout* app, adding sound support is vital. One cannot exercise
    while constantly staring at the screen. Audio clues helps the user perform the
    workout effectively as he/she can just follow the audio instructions.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how we are going to support exercise tracking using audio clues:'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
- en: A ticking clock sound tracks progress during the exercise
  id: totrans-587
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A half-way indicator sounds, indicating that the exercise is halfway through
  id: totrans-588
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An exercise-completion audio clip plays when the exercise is about to end
  id: totrans-589
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An audio clip plays during the rest phase and informs users about the next exercise
  id: totrans-590
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There will be an audio clip for each of these scenarios.
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
- en: Modern browsers have good support for audio. The HTML5 `<audio>` tag provides
    a mechanism to embed audio clips into html content. We too will use the `<audio>`
    tag to playback our clips.
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
- en: Since the plan is to use the HTML `<audio>` element, we need to create a wrapper
    directive that allows us to control audio elements from Angular. Remember that
    directives are HTML extensions without a view.
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-594
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Git `checkpoint3.3` folder `trainer/static/audio` contains all the audio
    files used for playback; copy them first. If you are not using Git, a snapshot
    of the chapter code is available at [http://bit.ly/ng2be-checkpoint3-3](http://bit.ly/ng2be-checkpoint3-3).
    Download and unzip the content and copy the audio files.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
- en: Building Angular directives to wrap HTML audio
  id: totrans-596
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You may not have realized so far, but we have purposefully shied away from directly
    accessing the DOM for any of our component implementations. There has not been
    a need to do it. Angular data binding infrastructure, including property, attribute,
    and event binding, has helped us manipulate HTML without touching the DOM.
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
- en: For the audio element too, the access pattern should be Angularish. Let's create
    a directive that wraps access to audio elements.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a folder `workout-audio` inside `workout-runner` and add a new file
    `my-audio.directive.ts` to it. Next add the implementation for the `MyAudioDirective`
    directive outlined here to this file:'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-600
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: The `MyAudioDirective` class is decorated with `@Directive`. The `@Directive`
    decorator is similar to the `@Component` decorator except we cannot have an attached
    view. Therefore, no `template` or `templateUrl` is allowed!
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
- en: The preceding `selector` property allows the framework to identify where to
    apply the directive. Using `audio` as the selector makes our directive load for
    every `<audio>` tag used in html.
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-603
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In a standard scenario, directive selectors are attribute-based, which helps
    us identify where the directive has been applied. We deviate from this norm and
    use an element selector for the `MyAudioDirective` directive.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
- en: We want this directive to be loaded for every audio element, and it becomes
    cumbersome to go to each audio declaration and add a directive-specific attribute.
    Hence an element selector.
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
- en: The use of `exportAs` becomes clear when we use this directive in view templates.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
- en: The `ElementRef` object injected in constructor is the Angular element for which
    the directive is loaded. Angular creates the `ElementRef` instance for every component
    and directive when it compiles and executes the html template. When requested
    in the constructor, the DI framework locates the corresponding `ElementRef` and
    injects it. We use `ElementRef` to get hold of the actual audio element in code
    (the instance of `HTMLAudioElement`). The `audioPlayer` property holds this reference.
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
- en: 'The directive now needs to expose an API to manipulate the audio player. Add
    these functions to the `MyAudioDirective` directive:'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-609
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: The `MyAudioDirective` API has two functions (`start` and `stop`) and three
    getters (`currentTime`, `duration`, and a boolean property called `playbackComplete`).
    The implementations for these functions and properties just wrap the audio element
    functions.
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-611
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Learn about these audio functions from the MDN documentation here: [http://bit.ly/html-media-element](http://bit.ly/html-media-element).
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
- en: To understand how we use the audio directive, let's create a new component that
    manages audio playback.
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-614
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember to register the `MyAudioDirective` under `WorkoutRunnerModule` before
    proceeding any further.
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
- en: Creating WorkoutAudioComponent for audio support
  id: totrans-616
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If we go back and look at the audio cues that are required, there are four distinct
    audio cues, and hence we are going to create a component with five embedded `<audio>`
    tags (two audio tags work together for next-up audio).
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `workout-audio` folder and create a file called `workout-audio.html`
    for the component template. Add this HTML snippet:'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-619
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Five `<audio>` tags one for each:'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
- en: '**Ticking audio**: This audio produces the ticking sound and is started as
    soon as the workout starts. Referred using the template variable `ticks`.'
  id: totrans-621
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Next up audio and  exercise audio**: There are two audio tags that work together.
    The first tag with the template variable as nextUp produces the "Next up" sound.
    And the actual exercise audio (`nextUpExercise`).'
  id: totrans-622
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Halfway audio**: The halfway audio plays halfway through the exercise.'
  id: totrans-623
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**About to complete audio**: This audio piece is played to denote the completion
    of an exercise (`aboutToComplete`).'
  id: totrans-624
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Did you notice the usage of the `#` symbol in the view? There are some variable
    assignments prefixed with `#`. In the Angular world, these variables are known
    as template reference variables or at times template variables.
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
- en: 'The platform developer guide describes them thus:'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
- en: '*A template reference variable is a reference to an DOM element or directive
    within a template.*'
  id: totrans-627
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Note
  id: totrans-628
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Don''t confuse them with the template input variables that we have used with
    the `ngFor` directive earlier: `*ngFor="let video of videos"`'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
- en: Template input variables (`video` in this case) allow us to access the model
    object from the view. The value assigned to `video` depends upon the context of
    the `ngFor` directive loop.
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at the last section where we set the `MyAudioDirective` directive''s `exportAs`
    metadata to `MyAudio`. We repeat that same string while assigning the template
    reference variable in the preceding view:'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-632
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: The role of `exportAs` is to define the name that can be used in the view to
    assign this directive to a variable. Remember, a single element/component can
    have multiple directives applied to it. `exportAs` allows us to select which directive
    should be assigned to a template variable.
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
- en: Template variables, once declared, can be accessed from other parts of the view.
    We will take up this discussion shortly. But in our case, we will use template
    variables to refer to the multiple `MyAudioDirective`s from parent component code.
    Let's understand how that works.
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `workout-audio.compnent.ts` file to the `workout-audio` folder with
    the following outline:'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-636
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: The interesting bit here is the `@ViewChild` decorator against the five properties.
    The `@ViewChild` decorator allows us to inject a child component/directive/element
    reference into its parent. The parameter passed is the template variable name,
    which helps DI match the element/directive to inject. When Angular instantiates
    the `WorkoutAudioComponent`, it injects the corresponding audio component based
    on the `@ViewChild` decorator. Let's complete the basic class implementation before
    we look at `@ViewChild` in detail.
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-638
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Without `exportAs` set on the `MyAudioDirective` directive, the `@ViewChild`
    injection injects the related `ElementRef` instance instead of the `MyAudioDirective`
    instance.
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
- en: 'The remaining task is to just play the correct audio component at the right
    time. Add these functions to `WorkoutAudioComponent`:'
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-641
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Having trouble writing these functions? They are available in Git branch `checkpoint3.3`.
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
- en: Next, go ahead and add `WorkoutAudioComponent` to the `declarations` array of
    `WorkoutRunnerModule`.
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two new model classes used in the preceding code. Add their declarations
    to `model.ts,` as follows:'
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-645
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: These are model classes to track progress events. The `WorkoutAudioComponent`
    implementation consumes this data. How the data is produced becomes clear as we
    move along.
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
- en: The `start` and `resume` functions stop and resume audio whenever a workout
    starts, pauses, or completes. The extra complexity in the resume function it to
    tackle cases when the workout was paused during next up, when about to complete,
    or half-way audio playback. We just want to continue from where we left off.
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
- en: The `onExerciseProgress` function should be called to report the workout progress.
    It's used to play the halfway audio and about-to-complete audio based on the state
    of the workout. The parameter passed to it is an object that contains exercise
    progress data.
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
- en: The `onExerciseChanged` function should be called when the exercise changes.
    The input parameter contains the current and next exercise in line, and helps
    `WorkoutAudioComponent` to decide when to play the next-up exercise audio.
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
- en: Make note that these two functions are called by the consumer of the component
    (in this case, `WorkoutRunnerComponent`). We don't invoke them internally.
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
- en: 'We touched upon two new concepts in this section: template reference variables
    and injecting child elements/directives into the parent. It''s worth exploring
    these two concepts in more detail before we continue with the implementation.
    We''ll start with learning more about template reference variables.'
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
- en: Understanding template reference variables
  id: totrans-652
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Template reference variables are created on the view template and are mostly
    consumed from the view. As you have already learned, these variables can be identified
    by the `#` prefix used to declare them.
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the greatest benefits of template variables is that they facilitate
    cross-component communication at the view template level. Once declared, such
    variables can be referenced by sibling elements/components and their children.
    Check out the following snippet:'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-655
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: This snippet declares a template variable, `emailId`, and then references it
    in the interpolation and the button `click` expression.
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
- en: The Angular templating engine assigns the DOM object for `input` (an instance
    of `HTMLInputElement`) to the `emailId` variable. Since the variable is available
    across siblings, we use it in a button's `click` expression.
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
- en: 'Template variables work with components too. We can easily do this:'
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-659
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: In this case, `runner` has a reference to `WorkoutRunnerComponent` object, and
    the button is used to start the workout.
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-661
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `ref-` prefix is the canonical alternative to `#`. The `#runner` variable
    can also be declared as `ref-runner`.
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
- en: Template variable assignment
  id: totrans-663
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There is something interesting about the template variable assignments that
    we have seen thus far. To recap the examples that we have used:'
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  id: totrans-665
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'What got assigned to the variable depended on where the variable was declared.
    This is governed by rules in Angular as described here:'
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
- en: If a directive is present on the element, such as `MyAudioDirective` in the
    first example shown previously, the directive sets the value. The `MyAudioDirective`
    directive sets the `ticks` variable to an instance of `MyAudioDirective`.
  id: totrans-667
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If there is no directive present, either the underlying HTML DOM element is
    assigned or a component object is assigned (as shown in the `email` and `workout-runner`
    example).
  id: totrans-668
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will be employing this technique to implement workout audio component integration
    with the workout runner component. This introduction gives us the head start that
    we need.
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
- en: The other new concept that we promised to cover is child element/directive injection
    using the `ViewChild` and `ViewChildren` decorators.
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
- en: Using the @ViewChild decorator
  id: totrans-671
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `@ViewChild` decorator informs the Angular DI framework to search for the
    child component/directive/element in the component tree and inject them into the
    parent. In the preceding code, the audio element directive (the `MyAudioDirective`
    class) is injected into the `WorkoutAudioComponent` code.
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
- en: 'To establish the context, let''s recheck a view fragment from `WorkoutAudioComponent`:'
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  id: totrans-674
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: Angular injects the directive (`MyAudioDirective`) into the `WorkoutAudioComponent`
    property `ticks`. The mapping is done based on the selector passed to the `@ViewChild`
    decorator.
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
- en: The selector parameter on `ViewChild` can be a string value, in which case Angular
    searches for a matching template variable, as before.
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
- en: 'Or it can be a type. This is valid:'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  id: totrans-678
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: However, it does not work in our case. There are multiple `MyAudioDirective`
    directives loaded in the `WorkoutAudioComponent` view, one for each of the `<audio>`
    tags. In such a scenario, the first match is injected. Not very useful. Passing
    the type selector would have worked if there was only one `<audio>` tag in the
    view.
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-680
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Properties decorated with `@ViewChild` are sure to be set before the `ngAfterViewInit`
    event hook on the component is called. This implies such properties are `null`
    if accessed inside the constructor.
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
- en: Like `@ViewChild`, Angular has a decorator to locate multiple child components/directives: `@ViewChildren`.
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
- en: The @ViewChildren decorator
  id: totrans-683
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`@ViewChildren` works similarly to `@ViewChild` except it''s used when the
    view has multiple child components/directives of one type. Using `@ViewChildren`
    we can get all the `MyAudioDirective` directive instances in `WorkoutAudioComponent`
    , as shown here:'
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  id: totrans-685
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Look carefully; `allAudios` is not an array but a custom object, `QueryList<Type>`.
    `QueryList` is an immutable collection of components/directives that Angular was
    able to locate. The best thing about this list is that Angular will keep this
    list in sync with the state of the view. When directives/components get added/removed
    from the view dynamically this list is updated too. Components/directives generated
    using `ng-for` are a prime example of this dynamic behavior. Consider the preceding
    `@ViewChildren` usage and this view template:'
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  id: totrans-687
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: The number of `MyAudioDirective` directives created by Angular depends upon
    the number of `clips`. When `@ViewChildren` is used, Angular injects the correct
    number of `MyAudioDirective` instances into `allAudio` property and keeps it in
    sync when items are added or removed from the `clips` array.
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
- en: While the usage of `@ViewChildren` allows us to get hold of all `MyAudioDirective`
    directives, it cannot be used to control the playback. You see, we need to get
    hold of individual `MyAudioDirective` instances as the audio playback timing varies.
    Hence we will stick to the `@ViewChild` implementation.
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
- en: Once we get hold of the `MyAudioDirective` directive attached to each audio
    element, it is just a matter of playing the audio tracks at the right time.
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
- en: Integrating WorkoutAudioComponent
  id: totrans-691
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While we have componentized audio playback functionality into `WorkoutAudioComponent`,
    it is and always will be tightly coupled to `WorkoutRunnerComponent` implementation.
    `WorkoutAudioComponent` derives its operational intelligence from `WorkoutRunnerComponent`.
    Hence the two components need to interact. `WorkoutRunnerComponent` needs to provide
    the `WorkoutAudioComponent` state change data, including when the workout started,
    exercise progress, workout stopped, paused, and resumed.
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
- en: One way to achieve this integration would be to use the currently exposed `WorkoutAudioComponent`
    API (stop, resume, and other functions) from `WorkoutRunnerComponent`.
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
- en: 'Something can be done by injecting `WorkoutAudioComponent` into `WorkoutRunnerComponent`
    as we did earlier when we injected `MyAudioDirective` into `WorkoutAudioComponent`.
    Check out this code:'
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  id: totrans-695
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'The `WorkoutAudioComponent` functions then can be invoked from `WorkoutRunnerComponent`
    from different places in the code. For example, this is how `pause` would change:'
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  id: totrans-697
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'And to play the next up audio, we would need to change parts of the `startExerciseTimeTracking`
    function:'
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  id: totrans-699
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: This is a perfectly viable option where `WorkoutAudioComponent` becomes a dumb
    component controlled by `WorkoutRunnerComponent`. The only problem with this solution
    is that it adds some noise to the `WorkoutRunnerComponent` implementation. `WorkoutRunnerComponent`
    now needs to manage audio playback too.
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
- en: There is an alternative, however. `WorkoutRunnerComponent` can expose events
    that are triggered during different times of workout execution, that is, events
    such as workout started, exercise started, and workout paused, and so on and so
    forth. Another advantage of having `WorkoutRunnerComponent` expose events is that
    it allows us to integrate other components with `WorkoutRunnerComponent` in future,
    using the same events.
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
- en: Exposing WorkoutRunnerComponent events
  id: totrans-702
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Angular allows components and directives to expose custom events using the
    `EventEmitter` class. Add these event declarations to `WorkoutRunnerComponent`
    at the end of the variable declaration section:'
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  id: totrans-704
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: The names of the events are self-explanatory, and within our `WorkoutRunnerComponent`
    implementation we need to raise these at the appropriate times.
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
- en: Remember to add `ExerciseProgressEvent` and import to the model module that
    is already declared on top. And add the `Output` and `EventEmitter` imports to
    `@angular/core`.
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
- en: Let's try to understand the role of the `@Output` decorator and the `EventEmitter`
    class.
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
- en: The @Output decorator
  id: totrans-708
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We covered a decent amount of Angular eventing capabilities in [Chapter 2](part0028.xhtml#QMFO1-edca168d36254bda8a21f611a95615c3
    "Chapter 2.  Building Our First App - 7 Minute Workout"), Building Our First App
    - 7 Minute Workout. Specifically, we learned how we can consume any event on a
    component, directive, or DOM element using the `bracketed ()` syntax. How about
    raising our own events?
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
- en: In Angular, we can create and raise our own events, events that signify something
    noteworthy has happened in our component/directive. Using the `@Output` decorator
    and the `EventEmitter` class we can define and raise custom events.
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
- en: Now would be a good time to refresh what we learned about events, by revisiting
    the *Eventing subsection* in the *Angular Event binding infrastructure* section
    from [Chapter 2](part0028.xhtml#QMFO1-edca168d36254bda8a21f611a95615c3 "Chapter 2. 
    Building Our First App - 7 Minute Workout"), *Building Our First App - 7 Minute
    Workout*.
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember, it is through events that components can communicate with the outside
    world. When we declare:'
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  id: totrans-713
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: It signifies that `WorkoutRunnerComponent` exposes an event `exercisePaused`
    (raised when the workout is paused).
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
- en: 'To subscribe to this event, we do:'
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  id: totrans-716
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'This looks absolutely similar to how we did DOM event subscription in the workout
    runner template:'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  id: totrans-718
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: The `@Output` decorator instructs Angular to make this event available for template
    binding. You can create an event without the `@Output` decorator, but such an
    event cannot be referenced in html.
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-720
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `@Output` decorated can also take a parameter, signifying the name of the
    event. If not provided, the decorator uses the property name: `@Output("workoutPaused")
    exercisePaused: EventEmitter<number> = new EventEmitter<number>();`'
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
- en: This declares an event `workoutPaused` instead of `exercisePaused`.
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
- en: Like any decorator, the `@Output` decorator too is there just to provide metadata
    for the Angular framework to work with. The real heavy lifting is done by the
    `EventEmitter` class.
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
- en: Eventing with EventEmitter
  id: totrans-724
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Angular embraces Reactive Programming (also dubbed as **Rx**-style programming)
    to support asynchronous operations and events. If you are hearing this term for
    the first time or don't have much idea about what reactive programming is, you're
    not alone.
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
- en: Reactive programming is all about programming against asynchronous data streams.
    Such a stream is nothing but a sequence of ongoing events ordered based on the
    time they occur. We can imagine a stream as a pipe generating data (in some manner)
    and pushing it to one or more subscribers. Since these events are captured asynchronously
    by subscribers, they are called asynchronous data streams.
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
- en: The data can be anything, ranging from browser/DOM element events, to user input
    to loading remote data loaded using AJAX. With *Rx* style, we consume this data
    uniformly.
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
- en: In the Rx world, there are Observers and Observables, a concept derived from
    the very popular Observer design pattern. Observables are streams that emit data.
    Observers on the other hand subscribe to these events.
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
- en: The `EventEmitter` class in Angular is primarily responsible for providing eventing
    support. It acts both as an observer and observable. We can fire events on it
    and it can be used to listen to events too.
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two functions available on `EventEmitter` that are of interest to
    us:'
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
- en: '`emit`: As the name suggests, use this function to raise events. It takes a
    single argument that is the event data. `emit` is the observable side.'
  id: totrans-731
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`subscribe`: Use this function to subscribe to the events raised by `EventEmitter`.
    `subscribe` is the observer side.'
  id: totrans-732
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's do some event publishing and subscriptions to understand how the preceding
    functions work.
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
- en: Raising events from WorkoutRunnerComponent
  id: totrans-734
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Look at the `EventEmitter` declaration. These have been declared with the `type`
    parameter. The `type` parameter signifies the type of data emitted.
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
- en: Let's add the event implementation to `workout-runner.component.ts` in chronological
    order starting from the top and moving down.
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this statement to the end of the `start` function:'
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  id: totrans-738
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: We use the `EventEmitter`'s `emit`function to raise an event `workoutStarted`,
    with the current workout plan as an argument.
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
- en: 'To `pause`, add this line to raise the `exercisePaused` event:'
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  id: totrans-741
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'To `resume`, add the following line:'
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  id: totrans-743
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: Each time, we pass the current exercise index as an argument to `emit` when
    raising `exercisePaused` and `exerciseResumed` events.
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `startExerciseTimeTracking` function, add the highlighted code after
    the call to `startExercise`:'
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  id: totrans-746
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: The argument passed contains the exercise that is going to start (`next`) and
    the next exercise in line (`this.getNextExercise()`).
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
- en: 'To the same function, add the highlighted code:'
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  id: totrans-749
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: The event is raised when the workout is completed.
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly in the same function, we raise an event that communicates workout progress.
    Add this statement:'
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  id: totrans-752
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: That completes our eventing implementation.
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
- en: As you may have guessed, `WorkoutAudioComponent` now needs to consume these
    events. The challenge here is how to organize these components so that they can
    communicate with each other with the minimum dependency on each other.
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
- en: Component communication patterns
  id: totrans-755
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As the implementation stands now, we have a basic `WorkoutAudioComponent` implementation
    and have augmented `WorkoutRunnerComponent` by exposing workout lifecycle events.
    These two just need to talk to each other now.
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
- en: The first obvious option that comes to mind is to add the `WorkoutAudioComponent`
    declaration to the `WorkoutRunnerComponent` view. `WorkoutAudioComponent` hence
    becomes a child component of `WorkoutRunnerComponent`. However, in such a setup,
    communication between them becomes a bit clunky. Remember, events are a mechanism
    for a component to communicate with the outside world.
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
- en: 'If the parent needs to communicate with its children, it can do this by:'
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
- en: '**Property binding**: The parent component can set up a property binding on
    the child component to push data to the child component. For example:'
  id: totrans-759
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE117]'
  id: totrans-760
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: Property binding in this case works fine. When the workout is paused, the audio
    too is stopped. But not all scenarios can be handled using property bindings.
    Playing the next exercise audio or halfway audio requires a bit more control.
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
- en: '**Calling functions on child components**: The parent component can also call
    functions on the child component if it can get hold of the child component. We
    have already seen how to achieve this using the `@ViewChild` and `@ViewChildren`
    decorators in the `WorkoutAudioComponent` implementation.'
  id: totrans-762
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is one more not-so-good option where the parent component instance can
    be injected into the child component. In such a case, the child component can
    call parent component functions or set up internal event handlers to parent events.
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
- en: We are going to try this approach and then scrap the implementation for a better
    one! A lot of learning can be derived from the not-so-optimal solution we plan
    to implement.
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
- en: Injecting a parent component into a child component
  id: totrans-765
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Add the `WorkoutAudioComponent` to the `WorkoutRunnerComponent` view just before
    the last closing div:'
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  id: totrans-767
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: Next we need to inject `WorkoutRunnerComponent` into `WorkoutAudioComponent`.
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `workout-audio.component.ts` and add the following declaration and a constructor:'
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  id: totrans-770
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'And remember to add these imports:'
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  id: totrans-772
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: We have used some trickery in the construction injection. If we directly try
    to inject `WorkoutRunnerComponent` into `WorkoutAudioComponent` it fails with
    Angular complaining of not being able to find all dependency. Read the code and
    think carefully; there is a subtle dependency cycle issue lurking. `WorkoutRunnerComponent`
    already is dependent on `WorkoutAudioComponent` as we have referenced `WorkoutAudioComponent`
    in the `WorkoutRunnerComponent` view. Now by injecting `WorkoutRunnerComponent`
    in `WorkoutAudioComponent`, we have created a dependency cycle.
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
- en: Cyclic dependencies are challenging for any DI framework. When creating a component
    with a cyclic dependency, the framework has to somehow resolve the cycle. In the
    preceding example, we resolve the circular dependency issue by using an `@Inject`
    decorator and passing in the token created using the `forwardRef()` global framework
    function.
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
- en: Inside the constructor, we attach a handler to the events, using the `EventEmitter`
    subscribe function. The arrow function passed to `subscribe` is called whenever
    the event occurs with a specific event argument. We collect all the subscriptions
    into an array `subscription`. This array comes in handy when we unsubscribe, which
    we need to, to avoid memory leaks.
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
- en: 'The `EventEmmiter`''s subscription (`subscribe` function) takes three arguments:'
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  id: totrans-777
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: The first argument is a callback, which is invoked whenever an event is emitted
  id: totrans-778
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second argument is an error callback function, invoked when the observable
    (the part that is generating events) errors out
  id: totrans-779
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The final argument takes a callback function that is called when the observable
    is done publishing events
  id: totrans-780
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have done enough to make audio integration work. Run the app and start the
    workout. Except for the ticking audio, all other audio clips play at the right
    time. You may have to wait for some time to hear to the other audio clips. What
    is the problem?
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
- en: As it turns out, we never started the ticking audio clip at the start of the
    workout. We can fix it by either setting the `autoplay` attribute on the `ticks`
    audio element or using the `component lifecycle events` to trigger the ticking
    sound. Let's take the second approach.
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
- en: Using component lifecycle events
  id: totrans-783
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We performed the `MyAudioDirective` injection in `WorkoutAudioComponent`:'
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  id: totrans-785
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'This will not be available unit the component''s view has been initialized:'
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
- en: We can verify it by accessing the `ticks` variable inside the constructor; it
    will be null. Angular has still not done its magic and we need to wait for the
    `WorkoutAudioComponent`'s children to be initialized.
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
- en: The component's lifecycle hooks can help us here. The `AfterViewInit` event
    hook is called once the component's view has been initialized and hence is a safe
    place from which to access the component's child directives/elements. Let's do
    it quickly.
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `WorkoutAudioComponent` by adding the interface implementation,
    and the necessary imports, as highlighted:'
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  id: totrans-790
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: Go ahead and test the app. The app has come to life with full-fledged audio
    feedback. Nice!
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
- en: While everything looks fine and dandy on the surface, there is a memory leak
    in the application now. If in the middle of the workout we navigate away from
    the workout page (to the start or finish page) and again return to the workout
    page, multiple audio clips play at random times.
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
- en: It seems that the `WorkoutRunnerComponent` is not getting destroyed on route
    navigation, and due to this, none of the child components are destroyed, including
    `WorkoutAudioComponent`. The net result? A new `WorkoutRunnerComponent` is being
    created every time we navigate to the workout page, but is never removed from
    the memory on navigating away.
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
- en: The primary reason for this memory leak is the event handlers we have added
    in `WorkoutAudioComponent`. We need to unsubscribe from these events when the
    audio component unloads, or else the `WorkoutRunnerComponent` reference will not
    be dereferenced.
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
- en: 'Another component lifecycle event comes to our rescue here: `OnDestroy` ! Add
    this implementation to the `WorkoutAudioComponent` class:'
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  id: totrans-796
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: Also remember to add references to the `OnDestroy` event interface as we did
    for `AfterViewInit`.
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
- en: Hope the `subscription` array that we created during event subscription makes
    sense now. One-shot unsubscribe!
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
- en: This audio integration is now complete. While this approach is not an awfully
    bad way of integrating the two components, we can do better. Child components
    referring to the parent component seems to be undesirable.
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
- en: What if `WorkoutRunnerComponent` and `WorkoutAudioComponent` are organized as
    sibling components?
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-801
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before proceeding, delete the code that we have added to `workout-audio.component.ts`
    from the *Injecting a Parent Component into a Child Component* section onwards.
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
- en: Sibling component interaction using events and template variables
  id: totrans-803
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If `WorkoutAudioComponent` and `WorkoutRunnerComponent` become siblings, we
    can make good use of Angular eventing and template reference variables. Confused?
    Well, to start with, this is how the components should be laid out:'
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  id: totrans-805
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: Does it ring any bells? Starting from this template, can you guess how the final
    template HTML would look? Think about it before you proceed further.
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
- en: 'Still struggling? As soon as we make them sibling components, the power of
    the Angular templating engine comes to the fore. The following template code is
    enough to integrate `WorkoutRunnerComponent` and `WorkoutAudioComponent`:'
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  id: totrans-808
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'The `WorkoutAudioComponent`''s template variable `wa` is being manipulated
    on `WorkoutRunnerComponent''s` template. Quite elegant! We still need to solve
    the biggest puzzle in this approach: Where does the preceding code go? Remember,
    `WorkoutRunnerComponent` is loaded as part of route loading. Nowhere in the code
    have we had a statement like:'
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  id: totrans-810
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: We need to re-organize the component tree and bring in a container component
    that can host `WorkoutRunnerComponent` and `WorkoutAudioComponent`. The router
    then loads this container component instead of `WorkoutRunnerComponent`. Let's
    do it.
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
- en: Create a folder called `workout-container` inside the `workout-runner` folder
    and add two new files, `workout-container.component.ts` and `workout-container.html`.
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
- en: 'Copy the HTML code with the events described before to the template file, and
    add the following declaration to `workout-container.component.ts`:'
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  id: totrans-814
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: The workout container component is ready. Add it to the `declarations` section
    in `workout-runner.module.ts` and export it instead of `WorkoutRunnerComponent`.
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we just need to rewire the routing setup. Open `app.routes.ts`. Change
    the route for the workout page and add the necessary import:'
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  id: totrans-817
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: And we have a working audio integration that is clear, concise, and pleasing
    to the eyes too!
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
- en: It's time now to wrap up the chapter, but not before addressing the video player
    dialog glitch introduced in the earlier sections. The workout does not stop/pause
    when the video player dialog is open.
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
- en: We are not going to detail the fix here, and urge the readers to give it a try
    without consulting the `checkpoint3.3` code.
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
- en: Here is an obvious hint. Use the eventing infrastructure!
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
- en: 'And another one: raise events from `VideoPlayerComponent`, one for each playback
    started and ended.'
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
- en: 'And the last hint: the `open` function on the dialog service (`Modal`) returns
    a promise, which is resolved when the dialog is closed.'
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-824
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are having a problem with running the code, look at git branch `checkpoint3.3`
    for a working version of what we have done thus far.
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
- en: Or if you are not using git, download the snapshot of `checkpoint3.2` (a ZIP
    file) from [http://bit.ly/ng2be-checkpoint3-3](http://bit.ly/ng2be-checkpoint3-3).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time.
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-827
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Bit by bit, piece by piece, we have added a number of enhancements to the *7
    Minute Workout* that are imperative for any professional app. There is still scope
    for new features and improvements, but the core app works just fine.
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
- en: We started the chapter by exploring the Single Page Application (SPA) capabilities
    of Angular. Here we learned about basic Angular routing, setting up routes, using
    route configuration, generating links using the `RouterLink` directive, and using
    the Angular `Router` and `Location` services to perform navigation.
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
- en: From the app perspective, we added start, finish, and workout pages to *7 Minute
    Workout*.
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
- en: We then built a workout history tracker service that was used to track historical
    workout executions. During this process, we learned about Angular **Dependency
    Injection (DI)** in depth. How a dependency is registered, what a dependency token
    is, and how dependencies are singleton in nature are what we learned in this section.
    We also learned about injectors and how hierarchical injectors affect dependency
    probing.
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, we touched upon an important topic: cross component communication,
    primarily using Angular Eventing. We detailed how to create custom events using
    the `@Output` decorator and `EventEmitter`.'
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
- en: The `@ViewChild` and `@ViewChildren` decorator that we touched upon in this
    chapter helped us understand how a parent can get hold of a child component for
    use. Angular DI also allows injecting a parent component into a child.
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
- en: We concluded the chapter by building a `WorkoutAudioComponent` and highlighted
    how sibling component communication can happen using Angular events and template
    variables.
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
- en: What next? We are going to build a new app, *Personal Trainer*. This app will
    allow us to build our own custom workouts. Once we can create our own workout,
    we are going to morph the *7 Minute Workout* app into a generic *Workout Runner*
    app that can run workouts that we build using *Personal Trainer*.
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
- en: For the next chapter, we showcase AngularJS form capabilities while we build
    a UI that allows us to create, update, and view our own custom workouts/exercises.
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
