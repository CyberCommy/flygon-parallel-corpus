- en: Chapter 3.  More Angular 2 – SPA, Routing, and Data Flows in Depth
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If the previous chapter was about building our first useful app in Angular,
    then this chapter is about adding a whole lot of Angular goodness to it. Within
    the learning curve, we have made a start in exploring a technology platform and
    now we can build some rudimentary apps using Angular. But that's just the start!
    There is a lot more to learn before we can make effective use of Angular in a
    decent-sized application. This chapter takes us one step closer to realizing this
    goal.
  prefs: []
  type: TYPE_NORMAL
- en: The *7 Minute Workout* app still has some rough edges/limitations that we can
    fix while making the overall app experience better. This chapter is all about
    adding those enhancements and features. And as always, this app-building process
    provides us with enough opportunities to enhance our understanding of the framework
    and learn new things about it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics we cover in this chapter include:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exploring Angular Single Page Applications** (**SPA**): We explore Angular''s
    Single Page Application capabilities, which include route navigation, link generation,
    and routing events.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Understanding Dependency Injection**: One of the core platform features.
    In this chapter, we learn how Angular makes effective use of dependency injection
    to inject components and services across the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Angular pure (stateless) and impure (stateful) pipes**: We explore the primary
    data transformation construct of Angular, pipes, in more detail as we build some
    new pipes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cross-component communication**: Since Angular is all about components and
    their interactions, we look at how to do cross-component communication in a parent-child
    and sibling component setup. We learn how Angular template variables and events
    facilitate this communication.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Creating and consuming events**: We learn how a component can expose its
    own events and how to bind to these events from template HTML and from other components.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AS a side note, I expect you are using the *7 Minute Workout* on a regular basis
    and working on your physical fitness. If not take a 7-minute exercise break and
    exercise now. I insist!
  prefs: []
  type: TYPE_NORMAL
- en: Hope the workout was fun! Now let's get back to some serious business. Let's
    start with exploring Angular Single Page Application (SPA) capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We are starting from where we left off in [Chapter 2](part0028.xhtml#QMFO1-edca168d36254bda8a21f611a95615c3
    "Chapter 2.  Building Our First App - 7 Minute Workout"), *Building Our First
    App - 7 Minute Workout*. The git branch `checkpoint2.4` can serve as the base
    for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The code is also available on GitHub ([https://github.com/chandermani/angular2byexample](https://github.com/chandermani/angular2byexample))
    for everyone to download. Checkpoints are implemented as branches in GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: If you are not using git, download the snapshot of `checkpoint2.4` (a ZIP file)
    from the GitHub location [http://bit.ly/ng2be-checkpoint2-4](http://bit.ly/ng2be-checkpoint2-4).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring Single Page Application capabilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *7 Minute Workout* starts when we load the app, but it ends with the last
    exercise sticking to the screen permanently. Not a very elegant solution. Why
    don't we add a start and finish page to the app? This makes the app more professional
    and allows us to understand the single-page nomenclature of AngularJS.
  prefs: []
  type: TYPE_NORMAL
- en: The Angular SPA infrastructure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With modern web frameworks such as Angular (Angular 1.x) and Ember, we are now
    getting used to apps that do not perform full page refreshes. But if you are new
    to this scene it's worth mentioning what these SPAs are.
  prefs: []
  type: TYPE_NORMAL
- en: Single Page Applications (SPAs) are browser-based apps devoid of any full page
    refresh. In such apps, once the initial HTML is loaded, any future page navigations
    are retrieved using AJAX as HTML fragments and injected into the already loaded
    view. Google Mail is a great example of a SPA. SPAs make for a great user experience
    as the user gets a desktop app-like feel, with no constant post-backs and page
    refreshes, which are typically associated with traditional web apps.
  prefs: []
  type: TYPE_NORMAL
- en: Like its predecessor, Angular 2 too provides the necessary constructs for SPA
    implementation. Let's understand them and add our app pages too.
  prefs: []
  type: TYPE_NORMAL
- en: Angular routing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Angular supports SPA development using its routing infrastructure. This infrastructure
    tracks browser URLs, enables hyperlink generation, exposes routing events, and
    provides a set of directives/components for view.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are four major framework pieces that work together to support the Angular
    routing infrastructure:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The Router (Router)**: The primary infrastructure piece that actually provides
    component navigation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Routing configuration (Route)**: The component router is dependent upon the
    routing configuration for setting up routes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**RouterOutlet component**: The `RouterOutlet` component is the placeholder
    container (*host*) where route-specific views are loaded'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**RouterLink directive**: This generates hyperlinks that can be embedded in
    the anchor tags for navigation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram highlights the roles these components play within the
    routing setup:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Angular routing](../Images/image00446.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: I highly encourage everyone to keep revisiting this diagram as we set up routing
    for *7 Minute Workout*.
  prefs: []
  type: TYPE_NORMAL
- en: '*Router* is the central piece of this complete setup; therefore a quick overview
    of the router will be helpful.'
  prefs: []
  type: TYPE_NORMAL
- en: Angular router
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you have worked with any JavaScript framework with SPA support, this is how
    things work. The framework watches the browser URL and serves views based on the
    URL loaded. There are dedicated framework components for this job. In the Angular
    world, this tracking is done by a *framework service*, the router.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Angular, any class, object, or function that provides some generic functionality
    is termed a **service**. Angular does not provide any special construct to declare
    a service as it does for components, directives, and pipes. Anything that can
    be consumed by components/directives/pipes can be termed a service. Router is
    one such service. And there are many more services that are part of the framework.
  prefs: []
  type: TYPE_NORMAL
- en: If you are from the Angular 1 realm, this is a pleasant surprise-no service,
    factory, provider, value, or constant!
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When building a component try to delegate as much functionality as possible
    to a service. Components should only act as a mediator that helps in synchronizing
    the component model and the view state
  prefs: []
  type: TYPE_NORMAL
- en: 'The Angular router is there to:'
  prefs: []
  type: TYPE_NORMAL
- en: Enable navigation between components on route change
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pass routing data between component views
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make the state of the currently route available to active/loaded components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide APIs that allow navigation for component code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Track the navigation history, allowing us the move back and forward between
    component views using browser buttons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide life cycle events and guard conditions that allow us to affect navigation
    based on some external factors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The router also supports some advance routing concepts such as parent-child
    routes. This gives us the ability to define routes at multiple levels inside the
    component tree. The parent component can define routes and child components can
    further add more sub-routes to the parent route definition. This is something
    that we cover in detail in [Chapter 4](part0045.xhtml#1AT9A1-edca168d36254bda8a21f611a95615c3
    "Chapter 4.  Personal Trainer"), *Building Personal Trainer*.
  prefs: []
  type: TYPE_NORMAL
- en: The router does not work alone. As highlighted in the preceding diagram, it
    depends upon other framework pieces to achieve the desired results. Let's add
    some app pages and work with each piece of the puzzle.
  prefs: []
  type: TYPE_NORMAL
- en: Routing setup
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For the component router to work, we first need to reference it as the router
    is not part of the core framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `package.json` and add a package reference to the router as highlighted
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Next install the package from the command line using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, reference the package in `systemjs.config.js`. This allows SystemJS
    to load the `router` module correctly. Add the router package to the `ngPackageNames`
    array to set up the `packages` configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Also add the `base` reference (highlighted) to the `head` section of `index.html` if
    not present:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The router requires `base href` to be set. The `href` value specifies the base
    URL to use for all relative URLs within an HTML document, including links to CSS,
    scripts, images, and any other resource.
  prefs: []
  type: TYPE_NORMAL
- en: 'The router uses the **pushstate** mechanism for URL navigation. This allows
    us to use URLs such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '`localhost:9000/start`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`localhost:9000/workout`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`localhost:9000/finish`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This may not seem a big deal, but remember that we are doing client-side navigation,
    not the  full-page redirects that we are used to. As the **developer guide** states:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Modern HTML 5 browsers support `history.pushState`, a technique that changes
    a browser''s location and history without triggering a server page request. The
    router can compose a "natural" URL that is indistinguishable from one that would
    otherwise require a page load.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Pushstate API and server-side url-rewrites
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The pushstate API used by the router works only when we click on links embedded
    in the view (`<a>` tag) or use the router API. The router intercepts any navigation
    events, loads the appropriate component view, and finally updates the browser
    URL. The request never goes to the server.
  prefs: []
  type: TYPE_NORMAL
- en: But what if we refresh the browser?
  prefs: []
  type: TYPE_NORMAL
- en: The Angular router cannot intercept the browser's refresh event, and hence a
    complete page refresh happens. In such a scenario, the server needs to respond
    to a resource request that only exists on the client side. A typical server response
    is to send the app host file (such as `index.html`) for any arbitrary request
    that may result in a **404 (Not Found)** error. This is what we call server **url-rewrite**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even our server setup does url-rewrite. Check out the highlighted line in `gulpfile.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The last configuration parameter to `connect.server` sets the `fallback` URL
    for the app server to `index.html`. This implies requests to any non-existent
    URLs such as `/start`, `/workout`, `/finish` or any other loads the index page.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Each server platform has a different mechanism to support url-rewrite. We suggest
    you look at the documentation for the server stack you use to enable url-rewrite
    for your Angular apps.
  prefs: []
  type: TYPE_NORMAL
- en: We can see the server-side rewrites in action once we add some pages to *7 Minute
    Workout*. Once the new pages are in place, try to refresh the app and see the
    browser's network log; the server sends `index.html` content every time irrespective
    of the URL requested.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Fall back path and debugging**'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a fall back path for all non-existing URLs can be detrimental while
    debugging the application. Once the fall back mechanism is in place, there are
    no 404 errors for script/HTML/CSS load failures. This can produce unexpected results
    for any missing reference as the server always returns the `index.html` file.
    Watch out for content returned in the browser network log and the browser console
    for anomalies whenever you add new files to the application.
  prefs: []
  type: TYPE_NORMAL
- en: As part of the preceding router setup, we have learned how router scripts are
    included, how server-side redirects are set up to support the HTML5 push state
    and the need to set up `base href`.
  prefs: []
  type: TYPE_NORMAL
- en: Before we proceed any further, we need to add some other pages to our app and
    configure the routes.
  prefs: []
  type: TYPE_NORMAL
- en: Adding start and finish pages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The plan here is to have three pages for *7 Minute Workout*:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Start page**: This becomes the landing page for the app'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Workout page**: What we have currently'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Finish page**: We navigate to this once the workout is complete'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The workout component and its view (`workout-runner.component.ts` and `workout-runner.html`)
    are already there. So let's create `StartComponent` and `FinishComponent`, and
    their view.
  prefs: []
  type: TYPE_NORMAL
- en: 'Copy the following files from git branch `checkpoint3.1`. The files are located
    in the `start` and `finish` folders, under the `components` folder (the GitHub
    location to download from is [http://bit.ly/ng2be-3-1-components](http://bit.ly/ng2be-3-1-components)):'
  prefs: []
  type: TYPE_NORMAL
- en: '`start.component.ts`, `start.html`, and `start.module.ts`: This includes the
    `StartComponent` implementation and view template. A standard HTML view, and a
    basic component, which uses the `routerLink` directive to generate a hyperlink.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`finish.component.ts`, `finish.html`, and `finish.module.ts`: This includes
    the `FinishComponent` implementation and view template. It follows the same pattern
    as `StartComponent`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both the `Start` and `Finish` components have been defined with their own modules.
    The convention we will follow is module per top-level view.
  prefs: []
  type: TYPE_NORMAL
- en: All three components are ready. Time to define the route configurations!
  prefs: []
  type: TYPE_NORMAL
- en: Route configuration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To set up the routes for *7 Minute Workout*, we are going to create a route
    definition file. Create a file called `app.routes.ts` in the `components/app`
    folder defining the top-level routes for the app. Add the following routing setup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `routes` variable is an array of `Route` objects. Each `Route` defines
    the configuration of a single route, which contains:'
  prefs: []
  type: TYPE_NORMAL
- en: '`path`: The target path to match'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`component`: The component to be loaded when the path is hit'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Such a route definition can be interpreted as: "When the user navigates to
    a path (defined in `path`), load the corresponding component defined in the `component`
    property." Take the first route example; navigating to `http://localhost:9000/start`
    loads the component view for `StartComponent`.'
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed that the last `Route` definition looks a bit different.
    The `path` looks odd and it does not have a `component` property either. A path
    with `**` denotes a catch-all path or the *wildcard route* for our app. Any navigation
    that does not match one of the first three routes, matches the catch-all route,
    causing the app to navigate to the start page (defined in the `redirectTo` property).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can try this once the routing setup is complete. Type any random route such
    as `http://localhost:9000/abcd` and the app automatically redirects to `http://localhost:9000/start`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final call to `RouterModule.forRoot` is used to export this route setup
    as a module. We use the setup (exported as `routing`) inside AppModule to complete
    the route setup. Open `app.module.ts` and import the routing setup as well the
    modules we have created with respect to the `Start` and `Finish` pages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have all the required components and all the routes defined, where
    do we inject these components on route change? We just need to define a placeholder
    for that in the host view.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering component views with router-outlet
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If we check the current `TrainerAppComponent` template, it has an embedded
    `WorkoutRunnerComponent`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This needs to change. Remove the preceding declaration and replace it with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '`RouterOutlet` is an Angular component directive that acts as a placeholder
    for a child component to load on route change. It integrates with the router to
    load the appropriate component based on the current browser URL and the route
    definition.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram helps us to easily visualize what is happening with the
    `router-outlet` setup:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Rendering component views with router-outlet](../Images/image00447.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We are almost done now; it's time to trigger navigation.
  prefs: []
  type: TYPE_NORMAL
- en: Route navigation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Like standard browser navigation, Angular navigation can happen:'
  prefs: []
  type: TYPE_NORMAL
- en: When a user enters a URL directly in the browser
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On clicking on a link on the anchor tag
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On using a script/code to navigate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If not started, start the app and load `http://localhost:9000` or `http://localhost:9000/start`.
    The start page should be loaded.
  prefs: []
  type: TYPE_NORMAL
- en: Click on the **Start** button of the page and the workout view should be loaded
    at `http://localhost:9000/workout`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Angular router also supports the old style of *hash (#)-based routing*.
    When hash-based routing is enabled, the routes appear as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`localhost:9000/#/start`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`localhost:9000/#/workout`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`localhost:9000/#/finish`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The default routing option is *pushState*-based. To change it to hash-based
    routing, the route configuration for the top level routes changes during route
    setup as shown in this example: `export const routing: ModuleWithProviders` `=
    RouterModule.forRoot(routes,` `**{ useHash: true }**` `);`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Interestingly, the anchor link in the `StartComponent''s` view definition does
    not have a `href` attribute. Instead, there is a `RouterLink` directive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This looks like a property binding syntax, where the `RouterLink` directive
    is taking an input parameter of type array. This is an array of route links parameters
    (or the link parameter array).
  prefs: []
  type: TYPE_NORMAL
- en: The `routerLink` directive, together with the router, uses this link parameter
    array to resolve the correct URL path. In the preceding case, the only element
    in the array is the name of the route.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Notice the **/** prefix in the preceding route path. `/` is used to specify
    an absolute path. The Angular router also supports relative paths, which are useful
    when working with child routes. We will explore the concept of child routes in
    the next few chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Refresh the app and check the rendered HTML for `StartComponent`; the preceding
    anchor tag is rendered as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Avoid hardcoding route links**'
  prefs: []
  type: TYPE_NORMAL
- en: While you could have directly used `<a href="/workout">`, prefer `routerLink`
    to avoid hardcoding routes.
  prefs: []
  type: TYPE_NORMAL
- en: Link parameter array
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The link parameter array passed to the `routerLink` directive follows a specific
    pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The first element is always the route path, and the next set of parameters is
    there to replace placeholder tokens defined in a route template.
  prefs: []
  type: TYPE_NORMAL
- en: 'The route setup for the current *7 Minute Workout* is quite simple, and there
    isn''t a need to pass parameters as part of link generation. But the capability
    is there for non-trivial routes that require dynamic parameters. See this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This is how the first route can be generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Angular router is quite a beast and supports almost everything that we expect
    of a modern router library. It supports child routes, async routes, lifecycle
    hooks, and some other advanced scenarios. We'll delay discussion on these topics
    until later chapters. This chapter just gets us started with Angular routing,
    but there is more to come!
  prefs: []
  type: TYPE_NORMAL
- en: 'The router link parameter can also be an object. Such objects are used to supply
    *optional parameters* to the route. See this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Note that the generated link contains a semicolon to separate parameters from
    the route and other parameters.
  prefs: []
  type: TYPE_NORMAL
- en: The last missing part in the implementation is routing to the finish pages once
    the workout completes.
  prefs: []
  type: TYPE_NORMAL
- en: Using the router service for component navigation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Navigation from the workout page to the finish page is not triggered manually
    but on completion of the workout. `WorkoutRunnerComponent` needs to trigger this
    transition.
  prefs: []
  type: TYPE_NORMAL
- en: For this, `WorkoutRunnerComponent` needs to get hold of the component router
    and invoke the `navigate` method on it.
  prefs: []
  type: TYPE_NORMAL
- en: How does `WorkoutRunnerComponent` get the router instance? Using Angular's *dependency
    injection framework*. We have been shying away from this topic for some time now.
    We have achieved a lot without even knowing that there's a dependency injection
    framework in play all this while.
  prefs: []
  type: TYPE_NORMAL
- en: Let's wait a tad longer and firstly concentrate on fixing the navigation issue.
  prefs: []
  type: TYPE_NORMAL
- en: 'For `WorkoutRunnerComponent` to get hold of the router service instance, it
    just needs to declare the service on the constructor. Update the `WorkoutRunnerComponent`
    constructor and add the imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Angular now magically injects the current router into the `router` private variable
    when `WorkoutRunnerComponent` is instantiated. The magic it uses is the *dependency
    injection framework*.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s now just a matter of replacing the statement `console.log("Workout complete!");`
    with the call to the `navigation` router:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `navigate` method takes the same link parameter array as the `RouterLink`
    directive. We can verify the implementation by patiently waiting for the workout
    to complete!
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are having a problem with running the code, look at the git branch `checkpoint3.1`
    for a working version of what we have done thus far.
  prefs: []
  type: TYPE_NORMAL
- en: Or if you are not using git, download the snapshot of `checkpoint3.1` (a ZIP
    file) from [http://bit.ly/ng2be-checkpoint3-1](http://bit.ly/ng2be-checkpoint3-1).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time.
  prefs: []
  type: TYPE_NORMAL
- en: If you are still wondering how to access route parameters for the current route,
    we have the `ActivatedRoute` service.
  prefs: []
  type: TYPE_NORMAL
- en: Using the ActivatedRoute service to access route params
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are times when the current view requires access to the active route state.
    Information such as the current URL fragment, the current route parameters, and
    other route-related data may come in handy during component implementation.
  prefs: []
  type: TYPE_NORMAL
- en: The `ActivatedRoute` service is a one-stop shop for all current route-related
    queries. It has a number of properties, including `url` and `params`, that can
    utilize the route's current state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an example of a parameterized route and how to access a parameter
    passed from a component. Given this route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'When the user navigates to `/user/5`, the underlying component can access the
    `:id` parameter value by first injecting `ActivatedRoute` into its constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'It then queries the `id` property from the `params` property of the `ActivatedRoute`
    service. Look at this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `params` property on `ActivatedObject` is actually an *observable*. We will
    learn more about observables later in the chapter, but for now it is enough to
    understand that observables are objects that raise events and can be subscribed
    to.
  prefs: []
  type: TYPE_NORMAL
- en: We use the `forEach` function on the `route.params` observable to get the route's
    parameters. The callback object (`params:Params`) contains properties corresponding
    to each route parameter. Check how we retrieve the `id` property and use it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have now covered the basic Angular routing infrastructure, but there is
    more to explore in the later chapters. It''s now time to concentrate on a much
    overdue topic: *Dependency Injection*.'
  prefs: []
  type: TYPE_NORMAL
- en: Angular dependency injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Angular makes heavy use of dependency injection to manage app and framework
    dependencies. The surprising part is that we could ignore this topic until we
    started our discussion on the router without compromising our understanding of
    how things work. All this while, the Angular dependency injection framework has
    been supporting our implementation. The hallmark of a good dependency injection
    framework is that the consumer can use it without bothering about the internals
    and with little ceremony.
  prefs: []
  type: TYPE_NORMAL
- en: If you are not sure what dependency injection is or just have a vague idea about
    it, an introduction to DI surely does not hurt anyone.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency injection 101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For any application, its components (not to be confused with Angular components)
    do not work in isolation. There are dependencies between them. A component may
    use other components to achieve its desired functionalities. **Dependency injection**
    is a pattern for managing such dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: The DI pattern is popular in many programming languages as it allows us to manage
    dependencies in a loosely coupled manner. With such a framework in place, dependent
    objects are managed by a DI container. This makes dependencies swappable and the
    overall code more decoupled and testable.
  prefs: []
  type: TYPE_NORMAL
- en: The idea behind DI is that an object does not create\manage its own dependencies.
    Instead, the dependencies are provided from outside. These dependencies are made
    available either through a constructor, which is called **constructor injection**
    (Angular also does this) or by directly setting the object properties, which is
    called **property injection**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a rudimentary example of DI in action. Consider a class called `Tracker`
    that requires a `Logger` for a logging operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The dependency of the class `Logger` is hardwired inside `Tracker`. What if
    we externalize this dependency? So the class becomes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This innocuous-looking change has a major impact. By adding the ability to
    provide the dependency externally, we can now:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Decouple components and enable extensibility. The DI pattern allows us to alter
    the logging behavior of the `Tracker` class without touching the class itself.
    Here is an example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The two `Tracker` objects we just saw have different logging capabilities for
    the same `Tracker` class implementation. `trackerWithDBLog` logs to a DB and `trackerWithMemoryLog`
    to the memory (assuming both `DBLogger` and `MemoryLogger` are derived from `Logger`
    class). Since Tracker is not dependent of specific implementation on a `Logger`
    (`DBLogger` or `MemoryLogger`), this implies `Logger` and `Tracker` are loosely
    coupled. In future we can derive a new `Logger` class implementation and use that
    for logging without changing the `Tracker` implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Mock dependencies: The ability to mock dependencies makes our components more
    testable. The tracker implementation can be tested in isolation (unit testing)
    by providing a mock implementation for Logger such as MockLogger, or by using
    a mocking framework that can easily mock the `Logger` interface.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can now understand how powerful DI is. Once DI is in place, the responsibility
    for resolving the dependencies falls on the calling/consumer code. In the preceding
    example, a class that was earlier instantiating `Tracker` now needs to create
    a `Logger` derivation and inject it into `Tracker` before using it.
  prefs: []
  type: TYPE_NORMAL
- en: Clearly, this flexibility in swapping internal dependencies of a component comes
    at a price. The calling code implementation can become overly complex as it now
    has to manage child dependencies too. This may seem simple at first, but given
    the fact that dependent components may themselves have dependencies, what we are
    dealing with is a complex dependency tree structure.
  prefs: []
  type: TYPE_NORMAL
- en: To make dependency management less cumbersome for the calling code, there is
    a need for DI containers/frameworks. These containers are responsible for constructing/managing
    dependencies and providing it to our client/consumer code.
  prefs: []
  type: TYPE_NORMAL
- en: The Angular DI framework manages dependencies for our Angular components, directives,
    pipes, and services.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring dependency injection in Angular
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Angular employs its very own DI framework to manage dependencies across the
    application. The very first example of visible dependency injection was the injection
    of the component router into `WorkoutRunnerComponent`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: When the `WorkoutRunnerComponent` class gets instantiated, the DI framework
    internally locates/creates the correct router instance and injects it into the
    caller (in our case, `WorkoutRunnerComponent`).
  prefs: []
  type: TYPE_NORMAL
- en: While Angular does a good job at keeping the DI infrastructure hidden, it's
    imperative that we understand how Angular DI works. Otherwise, everything may
    seem rather magical.
  prefs: []
  type: TYPE_NORMAL
- en: 'DI is about creating and managing dependencies, and the framework component
    that does this is dubbed the **injector**. For the injector to manage dependencies,
    it needs to understand the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The what:** What is the dependency? The dependency could be a class, an object,
    a factory function, or a value. Every dependency needs to be registered with the
    DI framework before it can be injected.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The where/when:** The DI framework needs to know where to inject a dependency
    and when.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The how**: The DI framework also needs to know the recipe for creating the
    dependency when requested.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any injected dependency needs to answer these questions irrespective of whether
    it's a framework construct or artefacts created by us.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take for example the `Router` instance injection done in `WorkoutRunnerComponent`.
    To answer the what and how parts, we register the `Router` service in the app
    module (`app.module.ts`) via the import statement on the module decorator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The `routing` variable is a module that exports multiple routes together with
    all the Angular-router-related services (technically it re-exports `RouterModule`).
    We export this variable from `app.routes.ts` with this statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The where and when are decided based on the component that requires the dependencies.
    The constructor of `WorkoutRunnerComponent` takes a dependency of `Router`. This
    informs the injector to inject the current `Router` instance when `WorkoutRunnerComponent`
    is created as part of route navigation.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Internally, the Injector determines the dependencies of a class based on the
    metadata reflected from it when converting TypeScript to ES5 code (done by the
    TypeScript compiler). The metadata is generated only if we add a decorator such
    as `@Component` or `@RouteConfig` on the class.
  prefs: []
  type: TYPE_NORMAL
- en: What happens if we inject `Router` into another class? Is the same `Router`
    instance used? The short answer is yes. The Angular injector creates and caches
    dependencies for future reuse, and hence these services are singleton in nature.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While dependencies in an injector are singleton, at any given time, there can
    be multiple injectors active throughout an Angular app. You'll learn about the
    injector hierarchy shortly.
  prefs: []
  type: TYPE_NORMAL
- en: With the router, there is another layer of complexity. Since Angular supports
    the *child route* concept, each of these routes has its own router instance. Wait
    until we cover child routers in the next chapter so that you can understand the
    intricacies!
  prefs: []
  type: TYPE_NORMAL
- en: Let's create an Angular service to track workout history. This process will
    help you understand how dependencies are wired using Angular DI.
  prefs: []
  type: TYPE_NORMAL
- en: Tracking workout history
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It would be a great addition to our app if we could track the workout history.
    When did we last exercise? Did we complete it? How much time did we spend?
  prefs: []
  type: TYPE_NORMAL
- en: Tracing the workout history requires us to track workout progress. Somehow,
    we need to track when the workout starts and when it stops. This tracking data
    then needs to be persisted somewhere.
  prefs: []
  type: TYPE_NORMAL
- en: One way to implement this history tracking is by extending our `WorkoutRunnerComponent`
    with the desired functionality. But that adds unnecessary complexity to `WorkoutRunnerComponent`
    and that's not its primary job. We need a dedicated history tracking service for
    this job, a service that tracks historical data and shares it throughout the app.
    Let's start building the `WorkoutHistoryTracker` service.
  prefs: []
  type: TYPE_NORMAL
- en: Building the WorkoutHistoryTracker service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the `WorkoutHistoryTracker` service, we plan to track the execution of
    the workout. The service also exposes an interface, allowing `WorkoutRunnerComponent`
    to start and stop workout tracking.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `services` folder inside the `src` folder if not there and add a file
    called `workout-history-tracker.ts` with this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: There are two classes defined: `WorkoutHistoryTracker` and `WorkoutLogEntry`.
    As the name suggests, `WorkoutLogEntry` defines log data for one workout execution.
    `maxHistoryItems` allows us to configure the maximum number of items to store
    in the `workoutHistory` array, the array that contains the historical data. The
    `get tracking()` method defines a getter property for `workoutTracked` in TypeScript.
    `workoutTracked` is set to `true` during workout execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add the start tracking, stop tracking, and exercise complete functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The `startTracking` function creates a `WorkoutLogEntry` and adds it to the
    `workoutHistory` array. By setting the `currentWorkoutLog` to the newly created
    log entry, we can manipulate it later during workout execution. The `endTracking`
    function and the `exerciseComplete` function just alter `currentWorkoutLog`. The
    `exerciseComplete` function should be called on completion of each exercise that
    is part of the workout.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, add a function that returns the complete historical data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: That completes the `WorkoutHistoryTracker` implementation; now it's time to
    integrate it into workout execution.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating with WorkoutRunnerComponent
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `WorkoutRunnerComponent` requires `WorkoutHistoryTracker` to track workout
    history; hence there is a dependency to be fulfilled.
  prefs: []
  type: TYPE_NORMAL
- en: To make `WorkoutHistoryTracker` discoverable, it needs to be registered with
    the framework. At this point, we are spoilt for choices. There are a number of
    ways to register a dependency and a number of places too! This flexibility makes
    the DI framework very powerful, albeit it adds to the confusion too.
  prefs: []
  type: TYPE_NORMAL
- en: Let's firstly try to understand the different mechanisms we can use to register
    a dependency using the `WorkoutHistoryTracker` as an example.
  prefs: []
  type: TYPE_NORMAL
- en: Registering dependencies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The simplest way to register a dependency is to register it at the root/global
    level. This can be done by passing the dependency type into the `provides` attribute
    (array) in the module decorator.
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in this example, adding `WorkoutHistoryTracker` to any module''s `providers`
    array registers the service globally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Technically speaking, when a service is added to the `providers` array it gets
    registered with the **app's root injector**, irrespective of the Angular module
    it is declared in. Any Angular artefact in any module henceforth can use the service
    (`WorkoutHistoryTracker`). No module imports are required at all.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This behavior is different from component/directive/pipe registration. Such
    artefacts have to be exported from a module for another module to use them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Providers create dependencies when the Angular injector requests them. These
    providers have the recipe to create these dependencies. While a class seems to
    be the obvious dependency that can be registered, we can also register:'
  prefs: []
  type: TYPE_NORMAL
- en: A specific object/value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A factory function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Directly using the class type to register a dependency (as shown in the `bootstrap`
    function) may mostly meet our needs, but at times we need some flexibility with
    our dependency registrations. The expanded version of provider registration syntax
    gives us that flexibility.
  prefs: []
  type: TYPE_NORMAL
- en: To learn about these variations, we need to explore providers and dependency
    registration in a little more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Angular providers
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Providers create dependencies that are served by the DI framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at the `WorkoutHistoryTracker` dependency registration in the previous
    section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This syntax is a short-form notation for the following version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The first property (`provide`) is a token that acts like a key for registering
    a dependency. This key also allows us to locate the dependency during dependency
    injection.
  prefs: []
  type: TYPE_NORMAL
- en: The second property (`useClass`) is a provider definition object that defines
    the recipe for creating the dependency value. The framework provides a number
    of ways to create these dependencies, as we will see shortly.
  prefs: []
  type: TYPE_NORMAL
- en: With `useClass`, we are registering class `provider`.  The class `provider` create
    dependencies by instantiating the type of object requested for.
  prefs: []
  type: TYPE_NORMAL
- en: Value providers
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The class `provider` create class objects and fulfil the dependency, but at
    times we want to register a specific object/primitive with the DI provider instead.
    Value providers solve this use case.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take an example of `WorkoutHistoryTracker` registered using this technique:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'What is registered is an instance of the `WorkoutHistoryTracker` object created
    by us, instead of letting Angular DI create one. Take such hand-crafted dependencies
    (dependencies created manually) into consideration if there are dependencies further
    down the lineage that too need to be hand-crafted. Take the example of `WorkoutHistoryTracker`
    again. If `WorkoutHistoryTracker` has some dependencies, those too need to be
    fulfilled by manual injection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Value providers come in handy in specific scenarios. For example, we can register
    a common app configuration using a value provider:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Or register a mock dependency while unit-testing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Factory providers
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There are times when injection is not a trivial affair. Injection depends upon
    external factors. These factors decide what objects or class instances are created
    and returned. Factory providers do this heavy lifting.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take an example where we want to have different configurations for dev and
    production releases. We can very well use a factory implementation to select the
    right configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'A factory function can have its own dependencies too. In such a case, the syntax
    changes a bit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The dependency is passed as a parameter to the factory function and registered
    on the provider definition object property, `deps`.
  prefs: []
  type: TYPE_NORMAL
- en: Use the `UseFactory` provide if the construction of the dependency is complex
    and not everything can be decided during wire-up.
  prefs: []
  type: TYPE_NORMAL
- en: While we have a number of options to declare dependencies, consuming dependencies
    is far simpler.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before continuing further, let's register the `WorkoutHistoryTracker` service
    in a new service module. This new module (`ServicesModule`) will be used to register
    all application-wide services.
  prefs: []
  type: TYPE_NORMAL
- en: 'Copy the module definition from the git branch `checkpoint3.2` into the `src/services`
    folder locally. You can download it from this GitHub location: [http://bit.ly/ng2be-3-2-services-module-ts](http://bit.ly/ng2be-3-2-services-module-ts).
    Also delete all references to the `LocalStorage` service as we plan to add it
    later in the chapter. Finally, import the module into `AppModule` (`app.module.ts`).'
  prefs: []
  type: TYPE_NORMAL
- en: Injecting dependencies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Consuming dependency is easy! More often than not, we use constructor injection
    to consume a dependency.
  prefs: []
  type: TYPE_NORMAL
- en: Constructor injection
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Add the `import` statement at the top and update the `WorkoutRunnerComponent''s`
    constructor, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: As with router, Angular injects `WorkoutHistoryTracker` too when `WorkoutRunnerComponent`
    is created. Easy!
  prefs: []
  type: TYPE_NORMAL
- en: Before we continue any further with our integration, let's explore some other
    facts about Angular's DI framework.
  prefs: []
  type: TYPE_NORMAL
- en: Explicit injection using injector
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We can even do explicit injection using Angular''s `Injector` service. This
    is the same injector Angular uses to support DI. Here is how to inject the `WorkoutHistoryTracker`
    service using `Injector`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: We inject the `Injector` first and then ask the `Injector` for the `WorkoutHistoryTracker`
    instance explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: When would someone want to do this? Well, almost never. Avoid this pattern as
    it exposes the DI container to your implementation and adds a bit of noise too.
  prefs: []
  type: TYPE_NORMAL
- en: Consuming dependency was easy, but how does the DI framework locate these dependencies?
  prefs: []
  type: TYPE_NORMAL
- en: Dependency tokens
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember this expanded version of dependency registration shown earlier?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The `provide` property value is a token. This token is used to identify the
    dependency to inject. Whenever Angular sees this statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: It injects the correct dependency based on the class type. This is an example
    of a class token. The class type is used for dependency searching/mapping. Angular
    supports some other tokens too.
  prefs: []
  type: TYPE_NORMAL
- en: String token
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Instead of a class, we can use a string literal to identify a dependency. We
    can register the `WorkoutHistoryTracker` dependency using a string token, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'If we now do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Angular does not like it one little bit and fails to inject the dependency.
    Since the `WorkoutHistoryTracker` seen before was registered with a string token,
    the token needs to be provided during injection too.
  prefs: []
  type: TYPE_NORMAL
- en: 'To inject a dependency registered using a string token, we need to use the
    `@Inject` decorator. This works perfectly fine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When `@Inject()` is not present, the Injector uses the type name of the parameter
    (class token).
  prefs: []
  type: TYPE_NORMAL
- en: 'String tokens are useful when registering instances or objects. The app configuration
    registration examples that we shared earlier can be rewritten using string tokens
    if there is no such class as `AppConfig`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'And then injected using `@Inject`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'While any object can act as a token, the most common token types are class
    and string tokens. Internally, provider turns the token parameter into an instance
    of the `OpaqueToken` class. Look at the framework documentation to learn more
    about `OpaqueToken`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://angular.io/docs/ts/latest/api/core/index/OpaqueToken-class.html](https://angular.io/docs/ts/latest/api/core/index/OpaqueToken-class.html).'
  prefs: []
  type: TYPE_NORMAL
- en: While the `WorkoutHistoryTracker` injection into `WorkoutRunnerComponent` is
    done, its integration is still incomplete.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating with WorkoutRunnerComponent - continued
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The history tracker instance (`tracker`) needs to be called when the workout
    starts, when an exercise is complete, and when the workout finishes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this as the first statement in the `start` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `startExerciseTimeTracking` function, add the highlighted code after
    the `clearInterval` call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'And the highlighted code inside the workout to complete the `else` condition
    in the same function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: History tracking is almost complete except for one case. What if the user manually
    navigates away from the workout page?
  prefs: []
  type: TYPE_NORMAL
- en: When that happens, we can always rely on the component's lifecycle hooks/events
    to help us. Workout tracking can be stopped when the `NgOnDestroy` event is fired.
    An appropriate place to perform any clean-up work is before the component is removed
    from the component tree. Let's do it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this function to `workout-runner.component.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: While we now have workout history tracking implemented, we don't have a mechanism
    to check the history. The pressing need is for a workout history page/component.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the workout history page
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The workout history data that we are collecting during the execution of the
    workout can now be rendered in a view. Let's add a History component. The component
    will be available at the `/history` location and can be loaded by clicking on
    a link in the app header section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the route definition in `app.routes.ts` to include a new route and the
    related import:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The **History** link needs to be added to the app header section. Let''s refactor
    the header section into its own component. Update the `app.component.ts` template
    `navbar` `div` to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'There is a new `HeaderComponent` here. Copy the definition for the header component
    (`header.component.ts`) from the git branch `checkpoint3.2`, `app` folder (GitHub
    location: [http://bit.ly/ng2be-3-2-header-component-ts](http://bit.ly/ng2be-3-2-header-component-ts)).
    Also add the component to the declarations array in `app.module.ts` as we do for
    any Angular component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: If you look at `HeaderComponent`, the history link is now there. Let's add the
    workout history component.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `WorkoutHistoryComponent` implementation is available in the git branch
    `checkpoint3.2`; the folder is `workout-history` (GitHub location: [http://bit.ly/ng2be-3-2-workout-history](http://bit.ly/ng2be-3-2-workout-history)).
    Copy all three files from the folder to a corresponding folder locally. Remember
    to maintain the same folder hierarchy in your local setup too. Make a note that
    `WorkoutHistoryComponent` has been defined in a separate module (`WorkoutHistoryModule`)
    and needs to be imported into `AppModule` (`app.module.ts`). Import `WorkoutHistoryModule`
    into `AppModule` before proceeding further. For now remove all references to `SharedModule`
    from `WorkoutHistoryModule`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `WorkoutHistoryComponent` view code is trivial to say the least: a few
    Angular constructs, including `ngFor` and `ngIf`. The component implementation
    too is pretty straightforward. Inject the `WorkoutHistoryTracker` service dependency
    and set the history data when `WorkoutHistoryComponent` is initialized:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'And this time, we use the `Location` service instead of `Router` to navigate
    away from the history component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The Location service is used to interact with the browser URL. Depending upon
    the URL strategy, either URL paths (such as `/start`, `/workout`) or URL hash
    segments (such as `#/start`, `#/workout`) are used to track location changes.
    The router service too uses the location service internally to trigger navigation.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Router versus Location**'
  prefs: []
  type: TYPE_NORMAL
- en: While the `Location` service allows us to perform navigation, using `Router`
    is a preferred way to perform route navigation. We used the location service here
    because the need was to navigate to the last route without bothering about how
    to construct the route.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are ready to test our workout history implementation. Load the start page
    and click on the **History** link. The history page is loaded with an empty grid.
    Start a workout and let an exercise complete. Check the history page again; there
    should be a workout listed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding the workout history page](../Images/image00448.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Looks good, except for one sore point in this listing. It would be better if
    the historical data were ordered chronologically, with the newest at the top.
    And it would be great if we had filtering capabilities too.
  prefs: []
  type: TYPE_NORMAL
- en: Sorting and filtering history data using pipes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [Chapter 2](part0028.xhtml#QMFO1-edca168d36254bda8a21f611a95615c3 "Chapter 2. 
    Building Our First App - 7 Minute Workout"), *Building Our First App - 7 Minute
    Workout*, we explored pipes. We even built our own pipe to format seconds values
    as hh:mm:ss. Since the primary purpose of pipes is to transform data, this can
    be used with any input. For arrays, pipes can be used to sort and filter data.
    We create two pipes, one for each sorting and filtering.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Angular1 has prebuilt filters (filters are pipes in Angular2), `orderBy` and
    `filter`, for this very purpose. The effort to port these filters in Angular2
    has been stalled for now. See this GitHub issue: [http://bit.ly/ng2-issue-2340](http://bit.ly/ng2-issue-2340).'
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with the `orderBy` pipe.
  prefs: []
  type: TYPE_NORMAL
- en: The orderBy pipe
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `orderBy` pipe we implement is going to order an array of objects based
    on any of the object''s properties. The usage pattern for sorting items in ascending
    order based on the `fieldName` property is going to be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'And for sorting items in descending order, the usage pattern is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Make note of the extra hyphen before `fieldName`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a folder called `shared` in `src/components` and copy all three files
    located in the corresponding location in git branch `checkpoint3.2` (GitHub location:
    [http://bit.ly/ng2be-3-2-shared](http://bit.ly/ng2be-3-2-shared)). There are two
    pipes and a new module definition (`SharedModule`) in this folder. `SharedModule`
    defines components/directives/pipes that that are shared across the application.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `order-by.pipe.ts` and look at the pipe implementation. While we are not
    going to delve into the pipe''s implementation details, some relevant parts need
    to be highlighted. Look at this pipe outline:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The preceding `field` variable receives the field on which sorting is required.
    Check the code below to understand how the `field` argument is passed.
  prefs: []
  type: TYPE_NORMAL
- en: If the field has a `-` prefix, we truncate the prefix before sorting the array
    in descending order.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The pipe also uses the spread operator, which may be new to you. Learn more
    about the spread operator on MDN here: [http://bit.ly/js-spread](http://bit.ly/js-spread).'
  prefs: []
  type: TYPE_NORMAL
- en: '**To use this pipe in the workout history view, import `SharedModule` into
    `WorkoutHistoryModule`.**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the template HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The historical data will now be sorted in descending order on `startedOn`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Make note of the single quotes around the pipe parameter (`'-startedOn'`). We
    are passing a literal string to the `orderBy` pipe. Instead, pipe parameters can
    be bound to component properties too.
  prefs: []
  type: TYPE_NORMAL
- en: That's enough for the `orderBy` pipe. Let's implement filtering.
  prefs: []
  type: TYPE_NORMAL
- en: The search pipe
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `SearchPipe` that we added earlier does a basic equality-based filtering.
    Nothing special.
  prefs: []
  type: TYPE_NORMAL
- en: Look at the pipe code; the pipe takes two arguments, the first being the field
    to search and the second the value to search. We use the array's `filter` function
    to filter the record, doing a strict equality check.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s update the workout history view and incorporate the search pipe too.
    Open `workout-history.html` and uncomment the div with radio buttons. These radio
    buttons filter workouts based on whether they were completed or not. This is how
    the filter selection HTML looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'We can have three filters: `all`, `completed`, and `incomplete` workouts. The
    radio selection sets the component''s property `completed` using the `change`
    event expression. `$event.target` is the radio button that was clicked. We do
    not assign `completed=$event.target.value` as its value is of the string type.
    The `completed` property (on `WorkoutHistoryComponent`) should be of the `boolean`
    type for equality comparison with the `WorkoutLogEntry.completed` property to
    work.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `search` pipe can now be added to the `ngFor` directive expression. We
    are going to chain the `search` and `orderBy` pipe. Update the `ngFor` expression
    to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The `search` pipe first filters the historical data followed by the `orderBy`
    pipe reordering it. Pay close attention to the `search` pipe parameters: the first
    parameter is a string literal denoting the field to search (`''completed''`),
    whereas the second parameter is derived from the component property `completed`.
    Having the ability to bind pipe parameters to component properties allows us great
    flexibility.'
  prefs: []
  type: TYPE_NORMAL
- en: Go ahead and verify the search capabilities of the history page. Based on the
    radio selection, the history records are filtered, and of course they are sorted
    in reverse chronological order based on the workout start dates.
  prefs: []
  type: TYPE_NORMAL
- en: While pipe usage with arrays looks simple, it can throw up some surprises if
    we do not understand when pipes are evaluated.
  prefs: []
  type: TYPE_NORMAL
- en: Pipe gotcha with arrays
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To understand the issue with pipes applied to arrays, let's reproduce the problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `search.pipe.ts` and remove the `@Pipe` decorator attribute `pure`. Also
    change the following statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'To the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a button at the end of the radio list (in `workout-history.html`) that
    adds a new log entry to the `history` array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a function to `WorkoutHistoryComponent`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: The preceding function duplicates the first history item and adds back to the
    `history` array. If we load the page and click on the button, a new log entry
    gets added to the history array but it does not show up on the view, unless we
    change the filter (by clicking on the other radios). Interesting!
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before calling `addLog` make sure at least one history log is already there;
    otherwise the `addLog` function will fail.
  prefs: []
  type: TYPE_NORMAL
- en: The pipes that we have built thus far are *stateless* (also called pure) in
    nature. They simply transform input data into output. Stateless pipes are revaluated
    any time the pipe input changes (the expression on the left side of pipe symbol)
    or any pipe argument is updated.
  prefs: []
  type: TYPE_NORMAL
- en: For arrays, this happens on an array assignment/reference change and not on
    the addition or deletion of elements. Switching the filter condition works as
    it causes the search pipe to evaluate again as the search parameter (the `completed`
    status) changes. This behavior is something to be aware of.
  prefs: []
  type: TYPE_NORMAL
- en: 'What''s the fix? For starters, we can make the history array immutable, which
    implies that it cannot be changed once created. To add a new element we need to
    create a new array with the new value, something like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Works perfectly, but we are changing our implementation to make it work with
    pipes. Instead, we can change the pipe and mark it stateful.
  prefs: []
  type: TYPE_NORMAL
- en: The difference between a stateless and stateful pipe is that stateful pipes
    are evaluated by Angular every time the framework does a change detection run,
    which involves checking the complete application for changes. Therefore, with
    stateful pipes, the check is not limited to the pipe input/argument changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make a `search` pipe stateless, just update the `Pipe` decorator with `pure:false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: It still does not work! The `search` pipe has one more quirk that needs a fix.
    The **"All"** radio selection does not work perfectly. Add a new workout log,
    and it still does not show up, unless we switch filters.
  prefs: []
  type: TYPE_NORMAL
- en: 'The fix here is to revert this line in the `search` pipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'To the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: We changed the `if` condition to return a new array every time (using the spread
    operator), even when `searchTerm` is `null`. If we return the same array reference,
    Angular does not check for a size change in the array and hence does not update
    the UI.
  prefs: []
  type: TYPE_NORMAL
- en: That completes our History page implementation. You may now be wondering what
    the last few fixes on pipes have to do with how change detection works. Or you
    may be wondering what is change detection? Let's put all of these doubts to rest
    and introduce everyone to Angular's change detection system.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Angular's change detection will be covered extensively in [Chapter 8](part0080.xhtml#2C9D01-edca168d36254bda8a21f611a95615c3
    "Chapter 8.  Some Practical Scenarios"), *Some Practical Scenarios*. The aim of
    the next section is to introduce the concept of change detection and how Angular
    performs this process.
  prefs: []
  type: TYPE_NORMAL
- en: Angular change detection overview
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To put it succinctly, change detection is all about tracking changes done to
    the component model during app execution. This helps Angular's databinding infrastructure
    to identify what parts of the view need to be updated. Every databinding framework
    needs to address this issue, and the approach these frameworks take for tracking
    changes differs. It even differs from Angular1 to Angular2.
  prefs: []
  type: TYPE_NORMAL
- en: To understand how change detection works in Angular, there are a few things
    that we need to keep in mind.
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, an Angular app is nothing but a hierarchy of components, from root
    to the leaf.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Secondly, there is nothing special about the component properties that we bind
    to view; therefore Angular needs an efficient mechanism to know when these properties
    change. It cannot keep polling for changes in these properties.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And finally to detect changes in a property value Angular does a *strict comparison*
    (`===`) between the previous and current value. For reference types it means only
    the references are compared. No deep comparison is done.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For precisely this reason, we had to mark our search pipe as stateful.
  prefs: []
  type: TYPE_NORMAL
- en: Adding elements to an existing array does not change the array reference and
    hence Angular fails to detect any change to the array. Once the pipe is marked
    as stateful, the pipe is evaluated irrespective of whether the array has changed
    or not.
  prefs: []
  type: TYPE_NORMAL
- en: Since Angular cannot know when any bound property is updated automatically,
    it instead resorts to checking every bound property when a change detection run
    is triggered. Starting from the root of the component tree, Angular checks each
    bound property for changes down the component hierarchy. If a change is detected
    that component is marked for refresh. It's worth reiterating that changes in a
    bound property do not immediately update the view. Instead, a change detection
    run works in two phases.
  prefs: []
  type: TYPE_NORMAL
- en: In the first phase it does the component tree walk and marks components that
    need to be refreshed due to model updates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the second phase, the actual view is synchronized with the underlying model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Model changes and view updates are never interleaved during a change detection
    run.
  prefs: []
  type: TYPE_NORMAL
- en: We now just need to answer two more questions. When is a change detection run
    triggered? And how many times does it run?
  prefs: []
  type: TYPE_NORMAL
- en: 'An Angular change detection run is triggered when any of these events are triggered:'
  prefs: []
  type: TYPE_NORMAL
- en: '**User input/ browser events**: We click on a button, enter some text, scroll
    the content. Each of these actions can update the view (and the underlying model).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Remote XHR requests**: This is another common reason for view updates. Getting
    data from a remote server to show on the grid and getting user data to render
    a view are examples of this.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**setTimeout and setInterval**: As it turns out, we can use `setTimeout` and
    `setInterval` to execute some code asynchronously and at specific intervals. Such
    code can also update the model. For example, a `setInterval` timer may check for
    stock quotes at regular interval and updates the stock price on the UI.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And most importantly each component model is checked only once, in a top-down
    fashion, starting from the root component to the tree leaves.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The last statement is true when Angular is configured to run in production mode.
    In development mode the component tree is traversed twice for changes. Angular
    expects that the model be stable after the first tree walk. If that is not the
    case Angular throws an error in development mode, and ignores the changes in production
    mode.
  prefs: []
  type: TYPE_NORMAL
- en: We can enable production mode by invoking the `enableProdMode` function before
    the `bootstrap` function call. `import {enableProdMode} from '@angular/core'`
    `enableProdMode();` `platformBrowserDynamic().bootstrapModule(AppModule);`
  prefs: []
  type: TYPE_NORMAL
- en: Let's explore some other faÃ§ades of the Angular DI framework, starting with
    hierarchical injectors, a confusing yet very powerful feature of Angular.
  prefs: []
  type: TYPE_NORMAL
- en: Hierarchical injectors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An injector in Angular is a dependency container that is responsible for storing
    dependencies and dispensing them when asked for. The provider registration examples
    shown earlier on modules actually register the dependencies with a global Injector.
  prefs: []
  type: TYPE_NORMAL
- en: Registering component level dependencies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All of the dependency registration that we have done thus far were done inside
    a module. Angular goes one step further and allows registration of dependencies
    at the component level too. There is a similar providers attribute on the `@Component`
    decorator that allows us to register dependency at the component level.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could''ve very well registered the `WorkoutHistoryTracker` dependency on
    `WorkoutRunnerComponent`. Something on these lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: But whether we should do it or not is something that we are going to discuss
    in this section shortly.
  prefs: []
  type: TYPE_NORMAL
- en: In the context of this discussion on hierarchical injectors, it's important
    to understand that Angular creates an injector per component (oversimplified).
    Dependency registration done at the component level is available on the component
    and its descendants.
  prefs: []
  type: TYPE_NORMAL
- en: We also learned that dependencies are singleton in nature. Once created, the
    Injector will always return the same dependency every time. This feature is quite
    evident from the workout history implementation.
  prefs: []
  type: TYPE_NORMAL
- en: '`WorkoutHistoryTracker` was registered with the `ServicesModule` and then injected
    into two components, `WorkoutRunnerComponent` and `WorkoutHistoryComponent`. Both
    components get the same instance of `WorkoutHistoryTracker`. The next diagram
    highlights this registration and injection:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Registering component level dependencies](../Images/image00449.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'To confirm, just add a `console.log` statement in the `WorkoutHistoryTracker`
    constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Refresh the app and open the history page by clicking on the header link. The
    message log is generated once, irrespective of how many times we run the workout
    or open the history page.
  prefs: []
  type: TYPE_NORMAL
- en: We now see a new interaction/data flow pattern! Think carefully; a service is
    being used to share state between two components. `WorkoutRunnerComponent` is
    generating data and `WorkoutHistoryComponent` is consuming it. And that too without
    any interdependence. We are exploiting the fact that dependencies are singleton
    in nature. This data sharing/interaction/data flow pattern can be used to share
    state between any number of components. Indeed, this is a very powerful weapon
    in our arsenal. Next time, there is a need to share state between unrelated components,
    think of services.
  prefs: []
  type: TYPE_NORMAL
- en: But what does this have to do with hierarchical injectors? Ok, let's not beat
    around the bush; let's get straight to the point.
  prefs: []
  type: TYPE_NORMAL
- en: While dependencies registered with the injector are singleton, Injector itself
    is not! At any given point in time, there are multiple injectors active in the
    application. In fact, injectors are created in the same hierarchy as the component
    tree. Angular creates an `Injector` instance for every component in the component
    tree (oversimplification; see the next information box).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Angular does not literally create an injector for each component. As explained
    in Angular the developer guide:'
  prefs: []
  type: TYPE_NORMAL
- en: Every component doesn't need its own injector and it would be horribly inefficient
    to create masses of injectors for no good purpose.
  prefs: []
  type: TYPE_NORMAL
- en: But it is true that every component has an injector (even if it shares that
    injector with another component) and there may be many different injector instances
    operating at different levels of the component tree.
  prefs: []
  type: TYPE_NORMAL
- en: It is useful to pretend that every component has its own injector.
  prefs: []
  type: TYPE_NORMAL
- en: 'The component and injector tree looks something like this when a workout is
    running:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Registering component level dependencies](../Images/image00450.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The insert textbox denotes the component name. The **root injector** is the
    injector created as part of the application bootstrap process.
  prefs: []
  type: TYPE_NORMAL
- en: What is the significance of this injector hierarchy? To understand the implications,
    we need to understand what happens when a component requests for a dependency.
  prefs: []
  type: TYPE_NORMAL
- en: Angular DI dependency walk
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Whenever requesting for a dependency, Angular first tries to satisfy the dependency
    from the component''s own injector. If it fails to find the requested dependency,
    it queries the parent component injector for the dependency, and its parent if
    the probing fails again, and so on and so forth till it finds the dependency or
    reaches the root injector. The takeaway: any dependency search is hierarchy-based.'
  prefs: []
  type: TYPE_NORMAL
- en: Earlier when we registered `WorkoutHistoryTracker`, it was registered with the
    root injector. The `WorkoutHistoryTracker` dependency request from both `WorkoutRunnerComponent`
    and `WorkoutHistoryComponent` was satisfied by the root injector, not their own
    component injectors.
  prefs: []
  type: TYPE_NORMAL
- en: This hierarchical injector structure brings a lot of flexibility. We can configure
    different providers at different component levels and override the parent provider
    configuration in child components. This only applies to dependencies registered
    on components. If the dependency is added on a module it gets registered on the
    root injector.
  prefs: []
  type: TYPE_NORMAL
- en: Let's try to override the global `WorkoutHistoryTracker` service in components
    that use it to learn what happens on such overrides. It's going to be fun and
    we will learn a lot!
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `workout-runner.component.ts` and to the `@Component` decorator add a
    `providers` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Do this in `workout-history.component.ts` too. Now if we refresh the app, start
    a workout, and then load the history page, the grid is empty. Irrespective of
    the times we try to run the workout, the history grid is always empty.
  prefs: []
  type: TYPE_NORMAL
- en: 'The reason is quite obvious. Post setting the `WorkoutHistoryTracker` provider
    on each `WorkoutRunnerComponent` and `WorkoutHistoryComponent`, the dependency
    is being fulfilled by the respective component injectors themselves. Both component
    injectors create their own instance of `WorkoutHistoryTracker` when requested,
    and hence history tracking is broken. Look at the following diagram to understand
    how the request is fulfilled in both scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Angular DI dependency walk](../Images/image00451.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'A quick question: What happens if we register the dependency in the root component,
    `TrainerAppComponent`, instead of doing it during app bootstrapping? Something
    like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Interestingly, with this setup too, things work perfectly. That's pretty evident;
    `TrainerAppComponent` is a parent component for `RouterOutlet` that internally
    loads `WorkoutRunnerComponent` and `WorkoutHistoryComponent`. Hence in such a
    setup, the dependency gets fulfilled by the `TrainerAppComponent`'s injector.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Dependency lookup up on the component hierarchy can be manipulated if an intermediate
    component has declared itself as a host component. We will learn more about it
    in later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Hierarchical injectors allow us to register dependencies at a component level,
    avoiding the need to register all dependencies globally.
  prefs: []
  type: TYPE_NORMAL
- en: This functionality really comes in handy when building an Angular library component.
    Such components can register their own dependencies without requiring the consumer
    of the library to register library-specific dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Remember: if you are having trouble loading the right service/dependency, make
    sure you check the component hierarchy for overrides done at any level.'
  prefs: []
  type: TYPE_NORMAL
- en: We now understand how dependency resolution works in components. But what happens
    if a service has a dependency? Yet another uncharted territory to explore.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remove the `provider` registration we did in those two components before continuing
    further.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency injection with @Injectable
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `WorkoutHistoryTracker` has a fundamental flaw; the history is not persisted.
    Refresh the app and the history is lost. We need to add persistence logic to store
    historical data. To avoid any complex setup, we use the browser local storage
    to store historical data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a `local-storage.ts` file to the `services` folder. And add the following
    class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: A simple wrapper over the browser's `localStorage` object.
  prefs: []
  type: TYPE_NORMAL
- en: Go ahead and register the `LocalStorage` service in the services module (`services.module.ts`).
  prefs: []
  type: TYPE_NORMAL
- en: 'And like any other dependency, inject it in the `WorkoutHistoryTracker` constructor
    (the `workout-history-tracker.ts` file) with the necessary import:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'This is standard DI stuff except that it does not work as expected. If we refresh
    the app now, Angular throws an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Strange! The all so awesome DI failed, and for no good reason! Not really; Angular
    is not doing any magic. It needs to know the class dependencies, and the only
    way it can know these is by inspecting the class definition and constructor arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a decorator called `@Injectable()` (remember to add parentheses) above
    `WorkoutHistoryTracker` and add the module import statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Refresh the page and the DI works perfectly. What made it work?
  prefs: []
  type: TYPE_NORMAL
- en: By putting in the `@Injectable` decorator, we are forcing the TypeScript transpiler
    to generate metadata for the `WorkoutHistoryTracker` class. This includes details
    about the constructor arguments. Angular DI consumes this generated metadata to
    determine the types of dependency the service has, and in future it fulfils these
    dependencies when the service is created.
  prefs: []
  type: TYPE_NORMAL
- en: What about components using `WorkoutHistoryTracker`? We have not used `@Injectable`
    there but still the DI works. We don't need to. Any decorator works and there
    is already an `@Component` decorator applied to all components.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember the decorator needs to be added on the calling class (or client class).
  prefs: []
  type: TYPE_NORMAL
- en: The actual integration between the `LocalStorage` service and `WorkoutHistoryTracker`
    is a mundane process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the constructor for `WorkoutHistoryTracker` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'And add a declaration for `storageKey`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: The constructor loads the workout logs from the local storage. The `map` function
    call is necessary as everything stored in `localStorage` is a string. Therefore,
    while de-serializing we need to convert the string back to the date value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this statement last in the `startTracking`, `exerciseComplete`, and `endTracking`
    functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: We save the workout history to local storage every time historical data changes.
  prefs: []
  type: TYPE_NORMAL
- en: That's it! We have built workout history tracking over `localStorage`. Verify
    it!
  prefs: []
  type: TYPE_NORMAL
- en: Before we move on to our big-ticket item, audio support, there are a few minor
    fixes that are needed for a better user experience. The first one is related to
    the **History** link.
  prefs: []
  type: TYPE_NORMAL
- en: Tracking route changes using the router service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **History** link in the `Header` component is visible for all routes. It
    will be better if we hide the link on the workout page. We don't want to lose
    an in-progress workout by accidentally clicking on the **History** link. Moreover,
    no one is interested in knowing about the workout history while doing a workout.
  prefs: []
  type: TYPE_NORMAL
- en: The fix is easy. We just need to determine if the current route is the workout
    route and hide the link. The `Router` service is going to help us with this job.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `header.component.ts` and add the necessary imports for router; update
    the `Header` class definition to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: The `showHistoryLink` property determines if the history link is shown to the
    user or not. In the constructor, we inject the `Router` service and register a
    callback on the `events` property using the `subscribe` function.
  prefs: []
  type: TYPE_NORMAL
- en: The `events` property is an observable. We will learn more about observables
    later in the chapter, but for now it is enough to understand that observables
    are objects that raise events and can be subscribed to. The `subscribe` function
    registers a callback function that is invoked every time the route changes.
  prefs: []
  type: TYPE_NORMAL
- en: The callback implementation just toggles the `showHistoryLink` state based on
    the current route name. The name we derive from the `url` property of the `router`
    object.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the `showHistoryLink` in the view just update the header template line
    with the anchor tag to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: And that's it! The **History** link does not show up on the workout page.
  prefs: []
  type: TYPE_NORMAL
- en: Another fix/enhancement is related to the video panel on the workout page.
  prefs: []
  type: TYPE_NORMAL
- en: Fixing the video playback experience
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The current video panel implementation can at best be termed amateurish. The
    size of the default player is small. When we play the video, the workout does
    not pause. The video playback is interrupted on exercise transitions. Also, the
    overall video load experience adds a noticeable lag at the start of every exercise
    routine. This is a clear indication that this approach to video playback needs
    some fixing.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what we are going to do to fix the video panel:'
  prefs: []
  type: TYPE_NORMAL
- en: Show the image thumbnail for the exercise video instead of loading the video
    player itself
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the user clicks on the thumbnail, load a popup/dialog with a bigger video
    player that can play the selected video
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pause the workout while the video playback is on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's get on with the job!
  prefs: []
  type: TYPE_NORMAL
- en: Using thumbnails for video
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Replace the `ngFor` template html inside `video-player.html` with this snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: We have abandoned iframe and instead loaded the thumbnail image of the video
    (check the `img` tag). All other content shown here is for styling the image.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have referenced the Stack Overflow post at [http://bit.ly/so-yt-thumbnail](http://bit.ly/so-yt-thumbnail)
    to determine the thumbnail image URL for our videos.
  prefs: []
  type: TYPE_NORMAL
- en: Start a new workout; the images should show up, but the playback functionality
    is broken. We need to add the video playback dialog.
  prefs: []
  type: TYPE_NORMAL
- en: Using the angular2-modal dialog library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Angular framework does not come with any pre-packaged UI library/controls.
    We need to look outwards and find a community solution for any UI control requirements.
  prefs: []
  type: TYPE_NORMAL
- en: The library we are going to use is angular2-modal, available on GitHub at [http://bit.ly/angular2-modal](http://bit.ly/angular2-modal).
    Let's install and configure the library.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the command line (inside the `trainer` folder), run the following command
    to install the library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'To integrate angular2-modal within our app, we need to add the package references
    for angular2-modal in `systemjs.config.js`. Copy the updated `systemjs.config.js`
    from git branch `checkpoint3.2` (GitHub location: [http://bit.ly/ng2be-3-2-system-config-js](http://bit.ly/ng2be-3-2-system-config-js))
    in the `trainer` folder and overwriting the local configuration file. The updated
    configurations allow SystemJS to know how to load the modal dialog library when
    it encounters library `import` statements.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The next few steps highlight the configuration ceremony to be performed before
    angular2-modal can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the first step, we configure the root element for angular2-modal. Open `app.component.ts`
    and add the highlighted code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: This step is essential as the modal dialog needs a container component to host
    itself. By passing in the `ViewContainerRef` of `TrainerAppComponent`, we allow
    the dialog to load inside the app root.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to add two modules from the library to `AppModule`. Update
    `app.module.ts` and add this code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: The library is now ready for use.
  prefs: []
  type: TYPE_NORMAL
- en: While angular2-modal has a number of predefined templates for standard dialogs
    such as alert, prompt, and confirm, these dialogs provide little customization
    in terms of look and feel. To have better control over the dialog UI, we need
    to create a custom dialog, which thankfully the library supports.
  prefs: []
  type: TYPE_NORMAL
- en: Creating custom dialogs with angular2-modal
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Custom dialogs in angular2-modal are nothing but Angular components with some
    special library constructs incorporated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Copy the `video-dialog.component.ts` file from the `workout-runner/video-player`
    folder in git branch `checkpoint3.2` (GitHub location: [http://bit.ly/ng2be-3-2-video-dialog-component-ts](http://bit.ly/ng2be-3-2-video-dialog-component-ts))
    into your local setup. The file contains the custom dialog implementation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, update `workout-runner.module.ts` and add a new `entryComponents` attribute
    to the module decorator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: The `VideoDialogComponent` needs to be added to `entryComponents` as it is not
    explicitly used in the component tree.
  prefs: []
  type: TYPE_NORMAL
- en: The `VideoDialogComponent` is a standard Angular component, with some modal
    dialog, specific implementations that we describe later.
  prefs: []
  type: TYPE_NORMAL
- en: The `VideoDialogContext` class has been created to pass the `videoId` of the
    YouTube video clicked to the dialog instance. The class inherits from `BSModalContext` a
    configuration class the dialog library uses to alter the behavior and UI of the
    modal dialog.
  prefs: []
  type: TYPE_NORMAL
- en: To get a better sense of how `VideoDialogContext` is utilized, let's invoke
    the preceding dialog from workout runner.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `ngFor` div in `video-player.html` and add a `click` event handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding handler invokes the `playVideo` method, passing in the video
    clicked. The `playVideo` function in turn opens the corresponding video dialog.
    Add the `playVideo` implementation to `video-player.component.ts` as highlighted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: The `playVideo` function calls the `Modal` class `open` function, passing in
    the dialog component to open and a new instance of the `VideoDialogContext` class
    with the `videoId` of the YouTube video. Before proceeding, delete the `ngOnChange`
    function from the file too.
  prefs: []
  type: TYPE_NORMAL
- en: The dialog implementation in `video-dialog.component.ts` implements the `ModalComponent<VideoDialogContext>`
    interface, required by the modal library. Look at how the context (`VideoDialogContext`)
    to the dialog is passed to the constructor and how we extract and assign the `videoId`
    property from the context. Then it's just a matter of binding the `videoId` property
    to the template view (see the template HTML) and rendering the YouTube player.
  prefs: []
  type: TYPE_NORMAL
- en: And we are good to go. Load the app and start the workout. Then click on any
    workout video images. The video dialog should load and now we can watch the video!
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we call the dialog implementation complete, there is one small issue
    that needs to be fixed. When the dialog opens the workout should pause: that''s
    not happening currently. We will fix it in the next section using Angular eventing
    support.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are having a problem with running the code, look at git branch `checkpoint3.2`
    for a working version of what we have done thus far.
  prefs: []
  type: TYPE_NORMAL
- en: Or if you are not using git, download the snapshot of `checkpoint3.2` (a ZIP
    file) from [http://bit.ly/ng2be-checkpoint3-2](http://bit.ly/ng2be-checkpoint3-2).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one last feature that we plan to add to *7 Minute Workout* before
    wrapping up the application and building something new with Angular: audio support.
    It teaches us some new cross-component communication patterns too.'
  prefs: []
  type: TYPE_NORMAL
- en: Cross-component communication using Angular events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We touched upon events in the last chapter when learning about Angular's binding
    infrastructure. It's time now to look at eventing in more depth. Let's add audio
    support to *7 Minute Workout*.
  prefs: []
  type: TYPE_NORMAL
- en: Tracking exercise progress with audio
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For the *7 Minute Workout* app, adding sound support is vital. One cannot exercise
    while constantly staring at the screen. Audio clues helps the user perform the
    workout effectively as he/she can just follow the audio instructions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how we are going to support exercise tracking using audio clues:'
  prefs: []
  type: TYPE_NORMAL
- en: A ticking clock sound tracks progress during the exercise
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A half-way indicator sounds, indicating that the exercise is halfway through
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An exercise-completion audio clip plays when the exercise is about to end
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An audio clip plays during the rest phase and informs users about the next exercise
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There will be an audio clip for each of these scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Modern browsers have good support for audio. The HTML5 `<audio>` tag provides
    a mechanism to embed audio clips into html content. We too will use the `<audio>`
    tag to playback our clips.
  prefs: []
  type: TYPE_NORMAL
- en: Since the plan is to use the HTML `<audio>` element, we need to create a wrapper
    directive that allows us to control audio elements from Angular. Remember that
    directives are HTML extensions without a view.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Git `checkpoint3.3` folder `trainer/static/audio` contains all the audio
    files used for playback; copy them first. If you are not using Git, a snapshot
    of the chapter code is available at [http://bit.ly/ng2be-checkpoint3-3](http://bit.ly/ng2be-checkpoint3-3).
    Download and unzip the content and copy the audio files.
  prefs: []
  type: TYPE_NORMAL
- en: Building Angular directives to wrap HTML audio
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You may not have realized so far, but we have purposefully shied away from directly
    accessing the DOM for any of our component implementations. There has not been
    a need to do it. Angular data binding infrastructure, including property, attribute,
    and event binding, has helped us manipulate HTML without touching the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: For the audio element too, the access pattern should be Angularish. Let's create
    a directive that wraps access to audio elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a folder `workout-audio` inside `workout-runner` and add a new file
    `my-audio.directive.ts` to it. Next add the implementation for the `MyAudioDirective`
    directive outlined here to this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: The `MyAudioDirective` class is decorated with `@Directive`. The `@Directive`
    decorator is similar to the `@Component` decorator except we cannot have an attached
    view. Therefore, no `template` or `templateUrl` is allowed!
  prefs: []
  type: TYPE_NORMAL
- en: The preceding `selector` property allows the framework to identify where to
    apply the directive. Using `audio` as the selector makes our directive load for
    every `<audio>` tag used in html.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In a standard scenario, directive selectors are attribute-based, which helps
    us identify where the directive has been applied. We deviate from this norm and
    use an element selector for the `MyAudioDirective` directive.
  prefs: []
  type: TYPE_NORMAL
- en: We want this directive to be loaded for every audio element, and it becomes
    cumbersome to go to each audio declaration and add a directive-specific attribute.
    Hence an element selector.
  prefs: []
  type: TYPE_NORMAL
- en: The use of `exportAs` becomes clear when we use this directive in view templates.
  prefs: []
  type: TYPE_NORMAL
- en: The `ElementRef` object injected in constructor is the Angular element for which
    the directive is loaded. Angular creates the `ElementRef` instance for every component
    and directive when it compiles and executes the html template. When requested
    in the constructor, the DI framework locates the corresponding `ElementRef` and
    injects it. We use `ElementRef` to get hold of the actual audio element in code
    (the instance of `HTMLAudioElement`). The `audioPlayer` property holds this reference.
  prefs: []
  type: TYPE_NORMAL
- en: 'The directive now needs to expose an API to manipulate the audio player. Add
    these functions to the `MyAudioDirective` directive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: The `MyAudioDirective` API has two functions (`start` and `stop`) and three
    getters (`currentTime`, `duration`, and a boolean property called `playbackComplete`).
    The implementations for these functions and properties just wrap the audio element
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Learn about these audio functions from the MDN documentation here: [http://bit.ly/html-media-element](http://bit.ly/html-media-element).
  prefs: []
  type: TYPE_NORMAL
- en: To understand how we use the audio directive, let's create a new component that
    manages audio playback.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember to register the `MyAudioDirective` under `WorkoutRunnerModule` before
    proceeding any further.
  prefs: []
  type: TYPE_NORMAL
- en: Creating WorkoutAudioComponent for audio support
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If we go back and look at the audio cues that are required, there are four distinct
    audio cues, and hence we are going to create a component with five embedded `<audio>`
    tags (two audio tags work together for next-up audio).
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `workout-audio` folder and create a file called `workout-audio.html`
    for the component template. Add this HTML snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Five `<audio>` tags one for each:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ticking audio**: This audio produces the ticking sound and is started as
    soon as the workout starts. Referred using the template variable `ticks`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Next up audio and  exercise audio**: There are two audio tags that work together.
    The first tag with the template variable as nextUp produces the "Next up" sound.
    And the actual exercise audio (`nextUpExercise`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Halfway audio**: The halfway audio plays halfway through the exercise.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**About to complete audio**: This audio piece is played to denote the completion
    of an exercise (`aboutToComplete`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Did you notice the usage of the `#` symbol in the view? There are some variable
    assignments prefixed with `#`. In the Angular world, these variables are known
    as template reference variables or at times template variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'The platform developer guide describes them thus:'
  prefs: []
  type: TYPE_NORMAL
- en: '*A template reference variable is a reference to an DOM element or directive
    within a template.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Don''t confuse them with the template input variables that we have used with
    the `ngFor` directive earlier: `*ngFor="let video of videos"`'
  prefs: []
  type: TYPE_NORMAL
- en: Template input variables (`video` in this case) allow us to access the model
    object from the view. The value assigned to `video` depends upon the context of
    the `ngFor` directive loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at the last section where we set the `MyAudioDirective` directive''s `exportAs`
    metadata to `MyAudio`. We repeat that same string while assigning the template
    reference variable in the preceding view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: The role of `exportAs` is to define the name that can be used in the view to
    assign this directive to a variable. Remember, a single element/component can
    have multiple directives applied to it. `exportAs` allows us to select which directive
    should be assigned to a template variable.
  prefs: []
  type: TYPE_NORMAL
- en: Template variables, once declared, can be accessed from other parts of the view.
    We will take up this discussion shortly. But in our case, we will use template
    variables to refer to the multiple `MyAudioDirective`s from parent component code.
    Let's understand how that works.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `workout-audio.compnent.ts` file to the `workout-audio` folder with
    the following outline:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: The interesting bit here is the `@ViewChild` decorator against the five properties.
    The `@ViewChild` decorator allows us to inject a child component/directive/element
    reference into its parent. The parameter passed is the template variable name,
    which helps DI match the element/directive to inject. When Angular instantiates
    the `WorkoutAudioComponent`, it injects the corresponding audio component based
    on the `@ViewChild` decorator. Let's complete the basic class implementation before
    we look at `@ViewChild` in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Without `exportAs` set on the `MyAudioDirective` directive, the `@ViewChild`
    injection injects the related `ElementRef` instance instead of the `MyAudioDirective`
    instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'The remaining task is to just play the correct audio component at the right
    time. Add these functions to `WorkoutAudioComponent`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: Having trouble writing these functions? They are available in Git branch `checkpoint3.3`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, go ahead and add `WorkoutAudioComponent` to the `declarations` array of
    `WorkoutRunnerModule`.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two new model classes used in the preceding code. Add their declarations
    to `model.ts,` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: These are model classes to track progress events. The `WorkoutAudioComponent`
    implementation consumes this data. How the data is produced becomes clear as we
    move along.
  prefs: []
  type: TYPE_NORMAL
- en: The `start` and `resume` functions stop and resume audio whenever a workout
    starts, pauses, or completes. The extra complexity in the resume function it to
    tackle cases when the workout was paused during next up, when about to complete,
    or half-way audio playback. We just want to continue from where we left off.
  prefs: []
  type: TYPE_NORMAL
- en: The `onExerciseProgress` function should be called to report the workout progress.
    It's used to play the halfway audio and about-to-complete audio based on the state
    of the workout. The parameter passed to it is an object that contains exercise
    progress data.
  prefs: []
  type: TYPE_NORMAL
- en: The `onExerciseChanged` function should be called when the exercise changes.
    The input parameter contains the current and next exercise in line, and helps
    `WorkoutAudioComponent` to decide when to play the next-up exercise audio.
  prefs: []
  type: TYPE_NORMAL
- en: Make note that these two functions are called by the consumer of the component
    (in this case, `WorkoutRunnerComponent`). We don't invoke them internally.
  prefs: []
  type: TYPE_NORMAL
- en: 'We touched upon two new concepts in this section: template reference variables
    and injecting child elements/directives into the parent. It''s worth exploring
    these two concepts in more detail before we continue with the implementation.
    We''ll start with learning more about template reference variables.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding template reference variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Template reference variables are created on the view template and are mostly
    consumed from the view. As you have already learned, these variables can be identified
    by the `#` prefix used to declare them.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the greatest benefits of template variables is that they facilitate
    cross-component communication at the view template level. Once declared, such
    variables can be referenced by sibling elements/components and their children.
    Check out the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: This snippet declares a template variable, `emailId`, and then references it
    in the interpolation and the button `click` expression.
  prefs: []
  type: TYPE_NORMAL
- en: The Angular templating engine assigns the DOM object for `input` (an instance
    of `HTMLInputElement`) to the `emailId` variable. Since the variable is available
    across siblings, we use it in a button's `click` expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'Template variables work with components too. We can easily do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: In this case, `runner` has a reference to `WorkoutRunnerComponent` object, and
    the button is used to start the workout.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `ref-` prefix is the canonical alternative to `#`. The `#runner` variable
    can also be declared as `ref-runner`.
  prefs: []
  type: TYPE_NORMAL
- en: Template variable assignment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There is something interesting about the template variable assignments that
    we have seen thus far. To recap the examples that we have used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'What got assigned to the variable depended on where the variable was declared.
    This is governed by rules in Angular as described here:'
  prefs: []
  type: TYPE_NORMAL
- en: If a directive is present on the element, such as `MyAudioDirective` in the
    first example shown previously, the directive sets the value. The `MyAudioDirective`
    directive sets the `ticks` variable to an instance of `MyAudioDirective`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If there is no directive present, either the underlying HTML DOM element is
    assigned or a component object is assigned (as shown in the `email` and `workout-runner`
    example).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will be employing this technique to implement workout audio component integration
    with the workout runner component. This introduction gives us the head start that
    we need.
  prefs: []
  type: TYPE_NORMAL
- en: The other new concept that we promised to cover is child element/directive injection
    using the `ViewChild` and `ViewChildren` decorators.
  prefs: []
  type: TYPE_NORMAL
- en: Using the @ViewChild decorator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `@ViewChild` decorator informs the Angular DI framework to search for the
    child component/directive/element in the component tree and inject them into the
    parent. In the preceding code, the audio element directive (the `MyAudioDirective`
    class) is injected into the `WorkoutAudioComponent` code.
  prefs: []
  type: TYPE_NORMAL
- en: 'To establish the context, let''s recheck a view fragment from `WorkoutAudioComponent`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: Angular injects the directive (`MyAudioDirective`) into the `WorkoutAudioComponent`
    property `ticks`. The mapping is done based on the selector passed to the `@ViewChild`
    decorator.
  prefs: []
  type: TYPE_NORMAL
- en: The selector parameter on `ViewChild` can be a string value, in which case Angular
    searches for a matching template variable, as before.
  prefs: []
  type: TYPE_NORMAL
- en: 'Or it can be a type. This is valid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: However, it does not work in our case. There are multiple `MyAudioDirective`
    directives loaded in the `WorkoutAudioComponent` view, one for each of the `<audio>`
    tags. In such a scenario, the first match is injected. Not very useful. Passing
    the type selector would have worked if there was only one `<audio>` tag in the
    view.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Properties decorated with `@ViewChild` are sure to be set before the `ngAfterViewInit`
    event hook on the component is called. This implies such properties are `null`
    if accessed inside the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: Like `@ViewChild`, Angular has a decorator to locate multiple child components/directives: `@ViewChildren`.
  prefs: []
  type: TYPE_NORMAL
- en: The @ViewChildren decorator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`@ViewChildren` works similarly to `@ViewChild` except it''s used when the
    view has multiple child components/directives of one type. Using `@ViewChildren`
    we can get all the `MyAudioDirective` directive instances in `WorkoutAudioComponent`
    , as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'Look carefully; `allAudios` is not an array but a custom object, `QueryList<Type>`.
    `QueryList` is an immutable collection of components/directives that Angular was
    able to locate. The best thing about this list is that Angular will keep this
    list in sync with the state of the view. When directives/components get added/removed
    from the view dynamically this list is updated too. Components/directives generated
    using `ng-for` are a prime example of this dynamic behavior. Consider the preceding
    `@ViewChildren` usage and this view template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: The number of `MyAudioDirective` directives created by Angular depends upon
    the number of `clips`. When `@ViewChildren` is used, Angular injects the correct
    number of `MyAudioDirective` instances into `allAudio` property and keeps it in
    sync when items are added or removed from the `clips` array.
  prefs: []
  type: TYPE_NORMAL
- en: While the usage of `@ViewChildren` allows us to get hold of all `MyAudioDirective`
    directives, it cannot be used to control the playback. You see, we need to get
    hold of individual `MyAudioDirective` instances as the audio playback timing varies.
    Hence we will stick to the `@ViewChild` implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Once we get hold of the `MyAudioDirective` directive attached to each audio
    element, it is just a matter of playing the audio tracks at the right time.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating WorkoutAudioComponent
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While we have componentized audio playback functionality into `WorkoutAudioComponent`,
    it is and always will be tightly coupled to `WorkoutRunnerComponent` implementation.
    `WorkoutAudioComponent` derives its operational intelligence from `WorkoutRunnerComponent`.
    Hence the two components need to interact. `WorkoutRunnerComponent` needs to provide
    the `WorkoutAudioComponent` state change data, including when the workout started,
    exercise progress, workout stopped, paused, and resumed.
  prefs: []
  type: TYPE_NORMAL
- en: One way to achieve this integration would be to use the currently exposed `WorkoutAudioComponent`
    API (stop, resume, and other functions) from `WorkoutRunnerComponent`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Something can be done by injecting `WorkoutAudioComponent` into `WorkoutRunnerComponent`
    as we did earlier when we injected `MyAudioDirective` into `WorkoutAudioComponent`.
    Check out this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'The `WorkoutAudioComponent` functions then can be invoked from `WorkoutRunnerComponent`
    from different places in the code. For example, this is how `pause` would change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'And to play the next up audio, we would need to change parts of the `startExerciseTimeTracking`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: This is a perfectly viable option where `WorkoutAudioComponent` becomes a dumb
    component controlled by `WorkoutRunnerComponent`. The only problem with this solution
    is that it adds some noise to the `WorkoutRunnerComponent` implementation. `WorkoutRunnerComponent`
    now needs to manage audio playback too.
  prefs: []
  type: TYPE_NORMAL
- en: There is an alternative, however. `WorkoutRunnerComponent` can expose events
    that are triggered during different times of workout execution, that is, events
    such as workout started, exercise started, and workout paused, and so on and so
    forth. Another advantage of having `WorkoutRunnerComponent` expose events is that
    it allows us to integrate other components with `WorkoutRunnerComponent` in future,
    using the same events.
  prefs: []
  type: TYPE_NORMAL
- en: Exposing WorkoutRunnerComponent events
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Angular allows components and directives to expose custom events using the
    `EventEmitter` class. Add these event declarations to `WorkoutRunnerComponent`
    at the end of the variable declaration section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: The names of the events are self-explanatory, and within our `WorkoutRunnerComponent`
    implementation we need to raise these at the appropriate times.
  prefs: []
  type: TYPE_NORMAL
- en: Remember to add `ExerciseProgressEvent` and import to the model module that
    is already declared on top. And add the `Output` and `EventEmitter` imports to
    `@angular/core`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's try to understand the role of the `@Output` decorator and the `EventEmitter`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: The @Output decorator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We covered a decent amount of Angular eventing capabilities in [Chapter 2](part0028.xhtml#QMFO1-edca168d36254bda8a21f611a95615c3
    "Chapter 2.  Building Our First App - 7 Minute Workout"), Building Our First App
    - 7 Minute Workout. Specifically, we learned how we can consume any event on a
    component, directive, or DOM element using the `bracketed ()` syntax. How about
    raising our own events?
  prefs: []
  type: TYPE_NORMAL
- en: In Angular, we can create and raise our own events, events that signify something
    noteworthy has happened in our component/directive. Using the `@Output` decorator
    and the `EventEmitter` class we can define and raise custom events.
  prefs: []
  type: TYPE_NORMAL
- en: Now would be a good time to refresh what we learned about events, by revisiting
    the *Eventing subsection* in the *Angular Event binding infrastructure* section
    from [Chapter 2](part0028.xhtml#QMFO1-edca168d36254bda8a21f611a95615c3 "Chapter 2. 
    Building Our First App - 7 Minute Workout"), *Building Our First App - 7 Minute
    Workout*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember, it is through events that components can communicate with the outside
    world. When we declare:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: It signifies that `WorkoutRunnerComponent` exposes an event `exercisePaused`
    (raised when the workout is paused).
  prefs: []
  type: TYPE_NORMAL
- en: 'To subscribe to this event, we do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'This looks absolutely similar to how we did DOM event subscription in the workout
    runner template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: The `@Output` decorator instructs Angular to make this event available for template
    binding. You can create an event without the `@Output` decorator, but such an
    event cannot be referenced in html.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `@Output` decorated can also take a parameter, signifying the name of the
    event. If not provided, the decorator uses the property name: `@Output("workoutPaused")
    exercisePaused: EventEmitter<number> = new EventEmitter<number>();`'
  prefs: []
  type: TYPE_NORMAL
- en: This declares an event `workoutPaused` instead of `exercisePaused`.
  prefs: []
  type: TYPE_NORMAL
- en: Like any decorator, the `@Output` decorator too is there just to provide metadata
    for the Angular framework to work with. The real heavy lifting is done by the
    `EventEmitter` class.
  prefs: []
  type: TYPE_NORMAL
- en: Eventing with EventEmitter
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Angular embraces Reactive Programming (also dubbed as **Rx**-style programming)
    to support asynchronous operations and events. If you are hearing this term for
    the first time or don't have much idea about what reactive programming is, you're
    not alone.
  prefs: []
  type: TYPE_NORMAL
- en: Reactive programming is all about programming against asynchronous data streams.
    Such a stream is nothing but a sequence of ongoing events ordered based on the
    time they occur. We can imagine a stream as a pipe generating data (in some manner)
    and pushing it to one or more subscribers. Since these events are captured asynchronously
    by subscribers, they are called asynchronous data streams.
  prefs: []
  type: TYPE_NORMAL
- en: The data can be anything, ranging from browser/DOM element events, to user input
    to loading remote data loaded using AJAX. With *Rx* style, we consume this data
    uniformly.
  prefs: []
  type: TYPE_NORMAL
- en: In the Rx world, there are Observers and Observables, a concept derived from
    the very popular Observer design pattern. Observables are streams that emit data.
    Observers on the other hand subscribe to these events.
  prefs: []
  type: TYPE_NORMAL
- en: The `EventEmitter` class in Angular is primarily responsible for providing eventing
    support. It acts both as an observer and observable. We can fire events on it
    and it can be used to listen to events too.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two functions available on `EventEmitter` that are of interest to
    us:'
  prefs: []
  type: TYPE_NORMAL
- en: '`emit`: As the name suggests, use this function to raise events. It takes a
    single argument that is the event data. `emit` is the observable side.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`subscribe`: Use this function to subscribe to the events raised by `EventEmitter`.
    `subscribe` is the observer side.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's do some event publishing and subscriptions to understand how the preceding
    functions work.
  prefs: []
  type: TYPE_NORMAL
- en: Raising events from WorkoutRunnerComponent
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Look at the `EventEmitter` declaration. These have been declared with the `type`
    parameter. The `type` parameter signifies the type of data emitted.
  prefs: []
  type: TYPE_NORMAL
- en: Let's add the event implementation to `workout-runner.component.ts` in chronological
    order starting from the top and moving down.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this statement to the end of the `start` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: We use the `EventEmitter`'s `emit`function to raise an event `workoutStarted`,
    with the current workout plan as an argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'To `pause`, add this line to raise the `exercisePaused` event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'To `resume`, add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: Each time, we pass the current exercise index as an argument to `emit` when
    raising `exercisePaused` and `exerciseResumed` events.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `startExerciseTimeTracking` function, add the highlighted code after
    the call to `startExercise`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: The argument passed contains the exercise that is going to start (`next`) and
    the next exercise in line (`this.getNextExercise()`).
  prefs: []
  type: TYPE_NORMAL
- en: 'To the same function, add the highlighted code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: The event is raised when the workout is completed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly in the same function, we raise an event that communicates workout progress.
    Add this statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: That completes our eventing implementation.
  prefs: []
  type: TYPE_NORMAL
- en: As you may have guessed, `WorkoutAudioComponent` now needs to consume these
    events. The challenge here is how to organize these components so that they can
    communicate with each other with the minimum dependency on each other.
  prefs: []
  type: TYPE_NORMAL
- en: Component communication patterns
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As the implementation stands now, we have a basic `WorkoutAudioComponent` implementation
    and have augmented `WorkoutRunnerComponent` by exposing workout lifecycle events.
    These two just need to talk to each other now.
  prefs: []
  type: TYPE_NORMAL
- en: The first obvious option that comes to mind is to add the `WorkoutAudioComponent`
    declaration to the `WorkoutRunnerComponent` view. `WorkoutAudioComponent` hence
    becomes a child component of `WorkoutRunnerComponent`. However, in such a setup,
    communication between them becomes a bit clunky. Remember, events are a mechanism
    for a component to communicate with the outside world.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the parent needs to communicate with its children, it can do this by:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Property binding**: The parent component can set up a property binding on
    the child component to push data to the child component. For example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: Property binding in this case works fine. When the workout is paused, the audio
    too is stopped. But not all scenarios can be handled using property bindings.
    Playing the next exercise audio or halfway audio requires a bit more control.
  prefs: []
  type: TYPE_NORMAL
- en: '**Calling functions on child components**: The parent component can also call
    functions on the child component if it can get hold of the child component. We
    have already seen how to achieve this using the `@ViewChild` and `@ViewChildren`
    decorators in the `WorkoutAudioComponent` implementation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is one more not-so-good option where the parent component instance can
    be injected into the child component. In such a case, the child component can
    call parent component functions or set up internal event handlers to parent events.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to try this approach and then scrap the implementation for a better
    one! A lot of learning can be derived from the not-so-optimal solution we plan
    to implement.
  prefs: []
  type: TYPE_NORMAL
- en: Injecting a parent component into a child component
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Add the `WorkoutAudioComponent` to the `WorkoutRunnerComponent` view just before
    the last closing div:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: Next we need to inject `WorkoutRunnerComponent` into `WorkoutAudioComponent`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `workout-audio.component.ts` and add the following declaration and a constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'And remember to add these imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: We have used some trickery in the construction injection. If we directly try
    to inject `WorkoutRunnerComponent` into `WorkoutAudioComponent` it fails with
    Angular complaining of not being able to find all dependency. Read the code and
    think carefully; there is a subtle dependency cycle issue lurking. `WorkoutRunnerComponent`
    already is dependent on `WorkoutAudioComponent` as we have referenced `WorkoutAudioComponent`
    in the `WorkoutRunnerComponent` view. Now by injecting `WorkoutRunnerComponent`
    in `WorkoutAudioComponent`, we have created a dependency cycle.
  prefs: []
  type: TYPE_NORMAL
- en: Cyclic dependencies are challenging for any DI framework. When creating a component
    with a cyclic dependency, the framework has to somehow resolve the cycle. In the
    preceding example, we resolve the circular dependency issue by using an `@Inject`
    decorator and passing in the token created using the `forwardRef()` global framework
    function.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the constructor, we attach a handler to the events, using the `EventEmitter`
    subscribe function. The arrow function passed to `subscribe` is called whenever
    the event occurs with a specific event argument. We collect all the subscriptions
    into an array `subscription`. This array comes in handy when we unsubscribe, which
    we need to, to avoid memory leaks.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `EventEmmiter`''s subscription (`subscribe` function) takes three arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: The first argument is a callback, which is invoked whenever an event is emitted
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second argument is an error callback function, invoked when the observable
    (the part that is generating events) errors out
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The final argument takes a callback function that is called when the observable
    is done publishing events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have done enough to make audio integration work. Run the app and start the
    workout. Except for the ticking audio, all other audio clips play at the right
    time. You may have to wait for some time to hear to the other audio clips. What
    is the problem?
  prefs: []
  type: TYPE_NORMAL
- en: As it turns out, we never started the ticking audio clip at the start of the
    workout. We can fix it by either setting the `autoplay` attribute on the `ticks`
    audio element or using the `component lifecycle events` to trigger the ticking
    sound. Let's take the second approach.
  prefs: []
  type: TYPE_NORMAL
- en: Using component lifecycle events
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We performed the `MyAudioDirective` injection in `WorkoutAudioComponent`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'This will not be available unit the component''s view has been initialized:'
  prefs: []
  type: TYPE_NORMAL
- en: We can verify it by accessing the `ticks` variable inside the constructor; it
    will be null. Angular has still not done its magic and we need to wait for the
    `WorkoutAudioComponent`'s children to be initialized.
  prefs: []
  type: TYPE_NORMAL
- en: The component's lifecycle hooks can help us here. The `AfterViewInit` event
    hook is called once the component's view has been initialized and hence is a safe
    place from which to access the component's child directives/elements. Let's do
    it quickly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `WorkoutAudioComponent` by adding the interface implementation,
    and the necessary imports, as highlighted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: Go ahead and test the app. The app has come to life with full-fledged audio
    feedback. Nice!
  prefs: []
  type: TYPE_NORMAL
- en: While everything looks fine and dandy on the surface, there is a memory leak
    in the application now. If in the middle of the workout we navigate away from
    the workout page (to the start or finish page) and again return to the workout
    page, multiple audio clips play at random times.
  prefs: []
  type: TYPE_NORMAL
- en: It seems that the `WorkoutRunnerComponent` is not getting destroyed on route
    navigation, and due to this, none of the child components are destroyed, including
    `WorkoutAudioComponent`. The net result? A new `WorkoutRunnerComponent` is being
    created every time we navigate to the workout page, but is never removed from
    the memory on navigating away.
  prefs: []
  type: TYPE_NORMAL
- en: The primary reason for this memory leak is the event handlers we have added
    in `WorkoutAudioComponent`. We need to unsubscribe from these events when the
    audio component unloads, or else the `WorkoutRunnerComponent` reference will not
    be dereferenced.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another component lifecycle event comes to our rescue here: `OnDestroy` ! Add
    this implementation to the `WorkoutAudioComponent` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: Also remember to add references to the `OnDestroy` event interface as we did
    for `AfterViewInit`.
  prefs: []
  type: TYPE_NORMAL
- en: Hope the `subscription` array that we created during event subscription makes
    sense now. One-shot unsubscribe!
  prefs: []
  type: TYPE_NORMAL
- en: This audio integration is now complete. While this approach is not an awfully
    bad way of integrating the two components, we can do better. Child components
    referring to the parent component seems to be undesirable.
  prefs: []
  type: TYPE_NORMAL
- en: What if `WorkoutRunnerComponent` and `WorkoutAudioComponent` are organized as
    sibling components?
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before proceeding, delete the code that we have added to `workout-audio.component.ts`
    from the *Injecting a Parent Component into a Child Component* section onwards.
  prefs: []
  type: TYPE_NORMAL
- en: Sibling component interaction using events and template variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If `WorkoutAudioComponent` and `WorkoutRunnerComponent` become siblings, we
    can make good use of Angular eventing and template reference variables. Confused?
    Well, to start with, this is how the components should be laid out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: Does it ring any bells? Starting from this template, can you guess how the final
    template HTML would look? Think about it before you proceed further.
  prefs: []
  type: TYPE_NORMAL
- en: 'Still struggling? As soon as we make them sibling components, the power of
    the Angular templating engine comes to the fore. The following template code is
    enough to integrate `WorkoutRunnerComponent` and `WorkoutAudioComponent`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: 'The `WorkoutAudioComponent`''s template variable `wa` is being manipulated
    on `WorkoutRunnerComponent''s` template. Quite elegant! We still need to solve
    the biggest puzzle in this approach: Where does the preceding code go? Remember,
    `WorkoutRunnerComponent` is loaded as part of route loading. Nowhere in the code
    have we had a statement like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: We need to re-organize the component tree and bring in a container component
    that can host `WorkoutRunnerComponent` and `WorkoutAudioComponent`. The router
    then loads this container component instead of `WorkoutRunnerComponent`. Let's
    do it.
  prefs: []
  type: TYPE_NORMAL
- en: Create a folder called `workout-container` inside the `workout-runner` folder
    and add two new files, `workout-container.component.ts` and `workout-container.html`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Copy the HTML code with the events described before to the template file, and
    add the following declaration to `workout-container.component.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: The workout container component is ready. Add it to the `declarations` section
    in `workout-runner.module.ts` and export it instead of `WorkoutRunnerComponent`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we just need to rewire the routing setup. Open `app.routes.ts`. Change
    the route for the workout page and add the necessary import:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: And we have a working audio integration that is clear, concise, and pleasing
    to the eyes too!
  prefs: []
  type: TYPE_NORMAL
- en: It's time now to wrap up the chapter, but not before addressing the video player
    dialog glitch introduced in the earlier sections. The workout does not stop/pause
    when the video player dialog is open.
  prefs: []
  type: TYPE_NORMAL
- en: We are not going to detail the fix here, and urge the readers to give it a try
    without consulting the `checkpoint3.3` code.
  prefs: []
  type: TYPE_NORMAL
- en: Here is an obvious hint. Use the eventing infrastructure!
  prefs: []
  type: TYPE_NORMAL
- en: 'And another one: raise events from `VideoPlayerComponent`, one for each playback
    started and ended.'
  prefs: []
  type: TYPE_NORMAL
- en: 'And the last hint: the `open` function on the dialog service (`Modal`) returns
    a promise, which is resolved when the dialog is closed.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are having a problem with running the code, look at git branch `checkpoint3.3`
    for a working version of what we have done thus far.
  prefs: []
  type: TYPE_NORMAL
- en: Or if you are not using git, download the snapshot of `checkpoint3.2` (a ZIP
    file) from [http://bit.ly/ng2be-checkpoint3-3](http://bit.ly/ng2be-checkpoint3-3).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Bit by bit, piece by piece, we have added a number of enhancements to the *7
    Minute Workout* that are imperative for any professional app. There is still scope
    for new features and improvements, but the core app works just fine.
  prefs: []
  type: TYPE_NORMAL
- en: We started the chapter by exploring the Single Page Application (SPA) capabilities
    of Angular. Here we learned about basic Angular routing, setting up routes, using
    route configuration, generating links using the `RouterLink` directive, and using
    the Angular `Router` and `Location` services to perform navigation.
  prefs: []
  type: TYPE_NORMAL
- en: From the app perspective, we added start, finish, and workout pages to *7 Minute
    Workout*.
  prefs: []
  type: TYPE_NORMAL
- en: We then built a workout history tracker service that was used to track historical
    workout executions. During this process, we learned about Angular **Dependency
    Injection (DI)** in depth. How a dependency is registered, what a dependency token
    is, and how dependencies are singleton in nature are what we learned in this section.
    We also learned about injectors and how hierarchical injectors affect dependency
    probing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, we touched upon an important topic: cross component communication,
    primarily using Angular Eventing. We detailed how to create custom events using
    the `@Output` decorator and `EventEmitter`.'
  prefs: []
  type: TYPE_NORMAL
- en: The `@ViewChild` and `@ViewChildren` decorator that we touched upon in this
    chapter helped us understand how a parent can get hold of a child component for
    use. Angular DI also allows injecting a parent component into a child.
  prefs: []
  type: TYPE_NORMAL
- en: We concluded the chapter by building a `WorkoutAudioComponent` and highlighted
    how sibling component communication can happen using Angular events and template
    variables.
  prefs: []
  type: TYPE_NORMAL
- en: What next? We are going to build a new app, *Personal Trainer*. This app will
    allow us to build our own custom workouts. Once we can create our own workout,
    we are going to morph the *7 Minute Workout* app into a generic *Workout Runner*
    app that can run workouts that we build using *Personal Trainer*.
  prefs: []
  type: TYPE_NORMAL
- en: For the next chapter, we showcase AngularJS form capabilities while we build
    a UI that allows us to create, update, and view our own custom workouts/exercises.
  prefs: []
  type: TYPE_NORMAL
