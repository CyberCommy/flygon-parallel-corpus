- en: Chapter 3. Building Services, Commands, and Events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the first two chapters, we set up the basic structure of our accommodation
    reservation system. We designed our classes, created our database schema, and
    learned how to test them. Now we need to translate the business requirements into
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Commands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Command handlers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Event handlers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Queued event handlers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Queued commands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Console commands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The command scheduler
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Request routing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned earlier, Laravel 5 has adopted the *command bus pattern*. Laravel
    4 viewed commands as something to be executed from the command line, whereas in
    Laravel 5, a command can be used in any context, allowing excellent reuse of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of the Laravel 4 HTTP request flow:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Request routing](graphics/B04559_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here is an example of the Laravel 5 HTTP request flow:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Request routing](graphics/B04559_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The first image illustrates the Laravel 4 request flow. The request via HTTP
    was handled by the router, and then sent to the controller, where generally, we
    could then talk to either the repository or directory of the model. In Laravel
    5, this is still possible; however, as shown in the second image, we can see that
    the ability to add additional blocks, layers, or modules allows us to separate
    the life cycle of the request into individual isolated pieces. Laravel 4 allowed
    us to put all of our code to handle the request inside the controller, while in
    Laravel 5, we are free to do the same, although now we are also able to easily
    separate the request into various pieces. Some of these concepts are derived from
    **Domain-driven Design** (**DDD**).
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the controller, the command is instantiated using the **Data Transfer
    Object** (**DTO**) paradigm. Then, the command is sent to the command bus, where
    it is handled by a handler class, which has two methods: `__construct()` and `handle()`.
    Inside the handler, we fire or instantiate an event. The event is likewise handled
    in the same way by an event handler method with two methods: `__construct()` and
    `handle()`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The directory structure is very clean and looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: It's rather self-explanatory; the commands and events are in their respective
    directories, while the handlers for each have their own directories.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Laravel 5.1 has changed the name of the `app/Commands` directory to `app/Jobs`
    to ensure that programmers do not get the concepts of the command bus and console
    commands mixed up.
  prefs: []
  type: TYPE_NORMAL
- en: User stories
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The idea for the command component can easily derive from a user story or a
    task required by a user to achieve a goal. The most simple example would be to
    search for a room:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: User stories, deriving from the agile methodology, guarantee that the code written
    closely matches the business requirement. They often follow the pattern "As a…
    I want to… so that...". This defines the `actor`, the `intent`, and the `benefit`.
    It helps us plan how each task will be converted into code. In our example, the
    user stories can transform into tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a hotel website user, I would create a list of the following tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: As a hotel website user, I want to search for a room so that I can select a
    room from a list of results.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As a hotel website user, I want to reserve a room so that I can stay at the
    hotel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As a hotel website user, I want to receive an e-mail with the reservation details
    so that I can have a copy of the reservation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As a hotel website user, I want to be on a waiting list so that I can reserve
    a room when one becomes available.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As a hotel website user, I want to get notified of the room availability so
    that I can reserve a room.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: User stories to code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first task, searching for a room, would most likely be a RESTful call from
    a user or from an external service, so this task would be exposed to our controllers
    and thus, to our RESTful API.
  prefs: []
  type: TYPE_NORMAL
- en: The second task, reserving a room, is a similar action initiated by the user
    or the other service. This task may require the user to be logged in.
  prefs: []
  type: TYPE_NORMAL
- en: 'The third task could depend on the second task. This task requires an interaction
    with another process that sends the user a confirmation e-mail with the details
    of the booking. We can also write this as: *As a hotel website, I want to send
    an e-mail with the reservation details, so that he or she may have a copy of the
    reservation*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The fourth task, getting placed on the waiting list, could be a command that
    is executed after the request to reserve a room is launched; in the case of another
    user reserving the room at the same time. It would most likely be called from
    the application itself, not the user, since the user has no knowledge of the real-time
    accommodation inventory. This could help us handle a race condition. Also, we
    should assume that when the website user is deciding which room to reserve, there
    is no locking mechanism on that room that would guarantee the availability. We
    could also write this as: *As a hotel website, I want to put a user on the waiting
    list so that they can be notified when a room is available*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For the fifth task, as the user is put on a waiting list, the user could also
    be notified of the room as it becomes available. This action checks for the availability
    of the rooms, and then checks for any users on the waiting list. The user story
    can be rewritten as follows: *As a hotel website, I want to notify a waiting list
    user of the availability of the rooms so that he or she may reserve a room*. If
    a room becomes available, the first user on the waiting list will be notified
    of the availability via an e-mail. This command would be executed frequently,
    as if it is a cron job. Luckily, Laravel 5 has a new mechanism to allow commands
    to be executed at a given frequency.'
  prefs: []
  type: TYPE_NORMAL
- en: It becomes apparent that if the user story has to be written with both using
    the website as the actor ("As a hotel website...") or the website user as the
    actor ("As a hotel website user..."), a command is useful and can be launched
    either from the RESTful API (user side) or from within the Laravel application
    itself.
  prefs: []
  type: TYPE_NORMAL
- en: Since our first task most likely involves an external service, we will create
    a route and also a controller to handle the request.
  prefs: []
  type: TYPE_NORMAL
- en: The controller
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first step involves the creation of a route, and the second step involves
    the creation of a controller.
  prefs: []
  type: TYPE_NORMAL
- en: Searching for the room
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First, let''s create a route in the `routes.php` file and map it to the `controller`
    method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The request parameters, such as the start/end dates and location details will
    be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The search parameters will be sent as JSON-encoded objects. They will be sent
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s add a `search` method to our `room` controller to handle the JSON
    input in the case of a request that comes in as an object, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The request facade handles the input variable query, and then decodes its JSON
    structure into an object.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 4](ch04.html "Chapter 4. Creating RESTful APIs"), *Creating RESTful
    APIs*, we will complete the code for the `search` method, but for now, we will
    simply create the architecture of this part of our RESTful API system.
  prefs: []
  type: TYPE_NORMAL
- en: Controller to command
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For the second task, reserving the room, we'll create a command as we'll most
    likely need a follow up action, which we will enable via the publisher subscriber
    pattern. The publisher subscriber pattern is used to represent *publishers* that
    send messages and *subscribers* that listen to these messages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the route to `routes.php` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We map the post to the room controller''s `store` method; this will create
    the reservation. Remember that we created the command like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `ReserveRoomCommand` class looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to add the following attributes to the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, add the following assignments to the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This allows us to carry the values through.
  prefs: []
  type: TYPE_NORMAL
- en: Command to event
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now let''s create an event. Use `artisan` to create an event, `RoomWasReserved`,
    which is to be fired when the room gets created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The `RoomWasReserved` event class looks like the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We'll tell it to use the `MyCompany\Accommodation\Reservation` and `MyCompany\User`
    entities so that we can pass them to the constructor. Inside the constructor,
    we assign them to entities within the `event` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s fire the event from inside the command handler. Laravel provides
    you with a simple `event()` method as a convenience/helper method that will fire
    an event. We''ll inject the `RoomWasReserved` event with the instantiated reservation
    and `user` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The ReserveRoomCommandHandler class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Our `ReserveRoomCommandHandler` class now instantiates a new reservation, uses
    the `createNew` factory method to inject the dependencies, and finally, fires
    the `RoomWasReserved` event as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Event to handler
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now, we need to create the event handler. As you would have expected, the Artisan
    provides a convenient way of doing this, although the syntax is a bit different.
    This time, strangely, the word *make* doesn''t appear in the phrase:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need to connect the event to its listener. We will edit the `app/Providers/EventServiceProvider.php`
    file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the preceding code snippet, we will add the key-value pair to the
    `$listen` array. The full path, as shown, is needed for the key, the event name,
    and the array of handlers. In this case, we only have one handler.
  prefs: []
  type: TYPE_NORMAL
- en: Queued event handlers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If we would like to not have the event handled immediately, but rather, put
    into the queue, we can add `–queued` to the create command as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This interface tells Laravel that the event handler should be queued and not
    executed synchronously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This trait allows us to interact with the queue to be able to do tasks, such
    as delete the job.
  prefs: []
  type: TYPE_NORMAL
- en: The waiting list command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For the fourth task, being placed on a waiting list, we''ll need to create
    another command that would be called from inside the reservation controller. Once
    again, using Artisan, we can easily create the command and its corresponding event
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, in our reservation controller, we would add the check for `roomAvailability`
    and then dispatch the `PlaceOnWaitinglist` command as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The queued commands
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can easily queue the commands by adding `queued` to the `create` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This will use whichever queuing system is available, such as beanstalkd, and
    not immediately run the command. Instead, it will be placed in the queue and run
    later. We''ll need to add an interface to the `Command` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, the `ReserveRoomCommand` class will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see that the `InteractsWithQueue` and `ShouldBeQueued` classes
    have been included, and the `ReserveRoomCommand` class extends the command and
    implements the `ShouldBeQueued` class. Another interesting feature is `SerializesModels`.
    This will serialize any models, which are passed in, to be available later.
  prefs: []
  type: TYPE_NORMAL
- en: The console command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For the fifth task, let''s create a `console` command, which will be executed
    very often:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This will create a command that can be executed from the Artisan command-line
    tool. If you have used Laravel 4, you may be familiar with this type of command.
    These commands are stored in the `Console/Commands/` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'To let Laravel know about it, we will need to add it to `app/Console/Kernel.php`
    in the `$commands` array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The contents will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The `$name` attribute is what will be called from Artisan. For example, if
    we set the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, by running the following command, we can manage the waiting list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The `getArguments()` and `getOptions()` methods are similar methods with the
    same signature, but have different uses.
  prefs: []
  type: TYPE_NORMAL
- en: The `getArguments()` method specifies an array of arguments that must be used
    to launch the command. The `getOptions()` methods are specified with `–` and can
    be `optional`, `repeated`, and with the `VALUE_NONE` option, they can be simply
    used as flags.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will write the command''s main code inside the `fire()` method. If we want
    to dispatch a command from within this command, we''ll add the `DispatchesCommands`
    trait to the class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The command scheduler
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, we will schedule this command to run every 10 minutes. Traditionally, this
    was done by creating a cron job to execute the Laravel console's command. Now,
    Laravel 5 provides a new mechanism to do this—the command scheduler.
  prefs: []
  type: TYPE_NORMAL
- en: 'The new `artisan` command is run as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: By simply adding this command to the cron, Laravel will automatically run all
    of the commands that are in the `Kernel.php` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The commands need to be added to the `Schedule` function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The `inspire` command is a sample command provided by Laravel to demonstrate
    the functionality. We will simply add our command. This will call the `manage:waitinglist`
    command every 5 minutes—it couldn't be much easier than that.
  prefs: []
  type: TYPE_NORMAL
- en: Now we need to modify the `crontab` file to have Artisan run the scheduler.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `crontab` is a file that contains commands to be run at certain times.
    To modify this file, type the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We will use `vi` or whichever the assigned editor is to modify the `cron` table.
    Adding the following line will tell `cron` to run the scheduler every minute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Laravel has evolved in just two short years, moving away from CodeIgniter's
    Model-View-Controller paradigm to adopt modern Domain-driven design's command
    bus and publisher subscriber event listener pattern. Whether or not to use these
    patterns will depend on the amount of separation that is desired between each
    layer. Certainly, even using a self-handling command is a start toward creating
    completely independent blocks of code, which promotes the code into a separate
    handler class, carrying the separation-of-concerns principle even further. By
    reducing the amount of code that resides inside the controller, the command becomes
    even more important.
  prefs: []
  type: TYPE_NORMAL
- en: We have not yet even written the code for each user story to interact with the
    database, and we have only seeded and tested the database, but the structure is
    beginning to become very well designed; each class having a very meaningful name
    and being organized into a useful directory structure.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will fill in the details of how the RESTful controller
    will accept input from another system or from the frontend of the website, and
    then how the model's attributes will be returned to the user to create the interface.
  prefs: []
  type: TYPE_NORMAL
