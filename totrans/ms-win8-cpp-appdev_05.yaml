- en: Chapter 5. Data Binding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the preceding two chapters, we looked at XAML and the way user interface
    elements are constructed and laid out with the help of the layout panels. The
    user interface, however, is just the first step. Some data must be set upon the
    UI to make up an application.
  prefs: []
  type: TYPE_NORMAL
- en: There are several ways of getting data to the controls. The simplest, perhaps,
    and most direct is the one we've been using so far; getting a reference to a control
    and changing the relevant property. If we needed some text to be placed in a `TextBox`,
    we would simply change its `Text` property when needed.
  prefs: []
  type: TYPE_NORMAL
- en: This certainly works and when working with the Win32 API for UI purposes, there
    is really no other way. But this is tedious at best, and involves an unmanageable
    maintenance headache at worst. Data is not the only thing that needs to be taken
    care of. Element states, such as enabled/disabled and checked/unchecked need to
    be examined and perhaps dynamically changed. In WinRT, much of this chore is handled
    with data binding.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding data binding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data binding is essentially simple—one property changes in some object (source)
    and another property in another object (target) reflects the change in some meaningful
    way. Coupled with data templates, data binding provides a compelling and powerful
    way to visualize and interact with data.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Those familiar with WPF or Silverlight will find WinRT data binding very familiar.
    There are some changes, mostly omissions, from WinRT, making data binding a bit
    less powerful than in WPF/Silverlight. Still, it's much better than manually transferring
    and synchronizing data.
  prefs: []
  type: TYPE_NORMAL
- en: Data binding in WinRT leads to one of the well-known patterns for working with
    data and UI in a seamless manner, known as **Model-View-ViewModel** (**MVVM**),
    which we'll briefly discuss at the end of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Data binding concepts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ll start by examining some of the basic terms associated with data binding,
    with the WinRT specifics added:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Source**: The object whose property is monitored for changes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Source path**: The property on the source object to monitor.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Target**: The object whose property is changed when the source changes. In
    WinRT, the target property must be a dependency property (as we''ll see later
    on).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Binding mode**: Indicates the direction of the binding.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Possible values are (all from the `Windows::UI::Xaml::Data::BindingMode` enumeration)
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`OneWay`: Source changes update the target'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TwoWay`: Source and target update each other'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OneTime`: Source updates the target just once'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data binding is specified (most of the time) in XAML, providing a declarative
    and convenient way to connect to data. This has the direct effect of minimizing
    code writing for managing the element state and exchanging data between controls
    and data objects.
  prefs: []
  type: TYPE_NORMAL
- en: Element-to-element binding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first binding scenario we''ll examine is the way in which we can connect
    elements together without writing any code—by performing data binding between
    required properties. Consider the following two elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Suppose we wanted the `FontSize` of the `TextBlock` to be changed, based on
    the current `Value` of the `Slider`. How would we go about doing that?
  prefs: []
  type: TYPE_NORMAL
- en: The obvious approach would be to use events. We can react to the `ValueChanged`
    event of the `Slider` and modify the `FontSize` property value of the `TextBlock`
    to be equal to the `Value` of the `Slider`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This certainly works, but it has a few drawbacks:'
  prefs: []
  type: TYPE_NORMAL
- en: C++ code needs to be written for this to work. This is a shame, because no real
    data is used—this is just UI behavior. Perhaps a designer could take care of that
    if he/she could just use XAML and not code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Such logic may change in the future. creating a maintenance headache—remember
    that a typical user interface will contain many such interactions—the C++ developer
    does not really want to be concerned about every such little detail.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Data binding provides an elegant solution. Here''s the `FontSize` setting of
    `TextBlock` that''s needed to make this idea work, without requiring any C++ code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The data binding expression must be specified on the target property, using
    the `{Binding}` markup extension. The `Path` property indicates the source property
    to look for (`Slider::Value` in this case), and `ElementName` is the property
    to use if the source object is an element on the current page (in this case, the
    `Slider` is named `_slider`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Running this shows the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Element-to-element binding](img/5022_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Dragging the slider changes the text size automatically; this is the power of
    data binding.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `Path` property of `Binding` can be omitted if its value is the first argument.
    This means the previous binding expression is equivalent to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This is more convenient and will be used most of the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same expression can be achieved with a code, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The code assumes `_tb` is the name of the `TextBlock` in question. This is certainly
    more verbose, and is actually used only in specific scenarios (which we'll examine
    in [Chapter 6](ch06.html "Chapter 6. Components, Templates, and Custom Elements"),
    *Components, Templates, and Custom Elements*).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add another element, a `TextBox`, whose `Text` should reflect the current
    font size of the `TextBlock`. We''ll use data binding as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This works. But if we change the actual text of the `TextBox` to a different
    number, the font size does not change. Why?
  prefs: []
  type: TYPE_NORMAL
- en: 'The reason is that the binding is by default one way. To specify a two-way
    binding, we need to change the `Mode` property of the binding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now, changing the `TextBox` and moving the focus to another control (such as
    by pressing *Tab* on the keyboard or touching some other element), changes the
    `FontSize` value of the `TextBlock`.
  prefs: []
  type: TYPE_NORMAL
- en: Object-to-element binding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although an element-to-element binding is sometimes useful, the classic data
    binding scenario involves a source, which is a regular, non-UI object, and a target,
    which is a UI element. The binding expression itself is similar to the element-to-element
    binding case; but naturally the `ElementName` property cannot be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to create an object that can support data binding. This must
    be a WinRT class that''s decorated with the `Bindable` attribute. The bindings
    themselves are on properties (as always). Here''s a simple `Person` class declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code uses auto-implemented properties, which will suffice for
    now.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create such an object in XAML as a resource, and then use the `Binding::Source`
    property to hook up the binding itself. First, two `Person` objects are created
    as resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we can bind these objects to elements as follows (all inside a `StackPanel`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Source` property refers to the object being bound; a `Person` instance
    in this case. Here''s the resulting UI:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Object-to-element binding](img/5022_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note that `Source` is specified in each and every binding expression. Without
    it, the binding would simply fail, as there is no source object to bind to.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the source is identical for all three elements, it would be beneficial
    to be able to specify the source just once, and allow all relevant elements to
    bind to it automatically without needing to specify the source explicitly. Fortunately,
    this is possible using the `FrameworkElement::DataContext` property. The rule
    is simple, if a source is not specified explicitly in a binding expression, a
    `DataContext` that is not a `nullptr` is searched in the visual tree, from the
    target element until one is found or the root of the visual tree is reached (typically
    a `Page` or a `UserControl`). If a `DataContext` is found, it becomes the source
    of the binding. Here''s an example that sets the `DataContext` on a parent `StackPanel`
    to be used by its children (whether immediate or not):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the result (after some font size tweaks):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Object-to-element binding](img/5022_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The binding expressions work correctly, because the implicit source is the `Person`
    object whose key is `p2`. Without the `DataContext`, all these bindings would
    silently fail.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Notice how the data binding expressions are simplified with `DataContext`. They're
    saying something such as, "I don't care what the source is, as long as there's
    a property named `<Fill in property name>` on some `DataContext` that's in scope."
  prefs: []
  type: TYPE_NORMAL
- en: The idea of a `DataContext` is a powerful one and, in fact, using the `Source`
    property is rare.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, setting a `Source` or `DataContext` in XAML to a predefined resource
    is rare as well. Setting the `DataContext` is usually done via code by getting
    relevant data from a data source, such as a local database or a web service. But
    it works regardless of where or how the `DataContext` is set.
  prefs: []
  type: TYPE_NORMAL
- en: Binding failures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Bindings are loosely typed—properties are specified as strings, and can be
    misspelled. For example, writing `FirstNam` instead of `FirstName` in the previous
    examples does not cause any exception to be thrown; the binding silently fails.
    The only other indication that something went wrong can be found in the **Visual
    Studio Output** window (**View** | **Output** from the menu) if the program is
    run under a debugger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This text pinpoints the exact problem, specifying the property name to bind,
    the source object type, and the details about the target. This should help to
    fix the spelling mistake.
  prefs: []
  type: TYPE_NORMAL
- en: Why is no exception thrown? The reason is that a data binding may fail at some
    point in time, and that's ok, because the conditions for this binding have not
    been met yet; there may be some information that is retrieved from a database,
    or from a web service, for instance. When the data is finally available, those
    bindings suddenly begin to work correctly.
  prefs: []
  type: TYPE_NORMAL
- en: This means true debugging of data binding expressions is not possible. A nice
    feature would be the ability to place a breakpoint in the XAML binding expression.
    This is currently unsupported, although it is graphically possible to place a
    breakpoint on a binding, it would simply never fire. This feature is available
    in Silverlight 5; hopefully, it will be supported in a future release of WinRT.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One way to debug data bindings is by using value converters, discussed later
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Change notifications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Data binding supports three modes for binding: one way, two way, and one time.
    Up until now the binding occurred when the page first loads and remains unchanged
    after that. What happens if we change a property value on a `Person` object after
    the bindings are in place?'
  prefs: []
  type: TYPE_NORMAL
- en: 'After adding a simple button, the `Click` event handler does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Since the `Person` instance was defined as a resource (uncommon, but possible),
    it's extracted from the `Resources` property of the page by using the specified
    key (`p1`). Then the `BirthYear` property is incremented.
  prefs: []
  type: TYPE_NORMAL
- en: Running the application shows no visual change. Setting a breakpoint in the
    `Click` handler confirms it's actually called, and the `BirthYear` is changed,
    but the binding seems to have no effect.
  prefs: []
  type: TYPE_NORMAL
- en: 'The reason for this is the way the `BirthYear` property is currently implemented:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This is a trivial implementation that uses a private field behind the scenes.
    The problem is that when the property changes, nobody knows about it; specifically,
    the binding system has no idea anything has happened.
  prefs: []
  type: TYPE_NORMAL
- en: 'To change that, a data object should implement the `Windows::UI::Xaml::Data::INotifyPropertyChanged`
    interface. This interface is queried by the binding system and, if found, registers
    for the `PropertyChanged` event (the only member of that interface). Here''s a
    revised declaration of the `Person` class, focusing on the `BirthYear` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The getter is implemented inline, and the setter is implemented in the CPP
    file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `PropertyChanged` event is raised, accepting a `PropertyChangedEventArgs`
    object that accepts the changed property name. Now, running the application and
    clicking on the button shows an incremented birth year, as expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'This effectively means that every property should be implemented in a similar
    fashion; declaring a private field and raising the `PropertyChanged` event in
    the setter. Here''s a revised `FirstName` property implementation (this time implemented
    inline):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '`_firstName` is a private `String^` field defined within the class as well.'
  prefs: []
  type: TYPE_NORMAL
- en: Binding to collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous examples used a property that binds to a single object. As we've
    seen in the previous chapter, a bunch of controls deriving from `ItemsControl`
    can present information for more than one data item. It stands to reason that
    these controls should bind to a collection of data items, such as a collection
    of the `Person` objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The property to be used for binding purposes is `ItemsSource`. This should
    be set to a collection, typically `IVector<T>`. Here''s an example of some `Person`
    objects bound to a `ListView` (a constructor was added to person for convenient
    initialization):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'To set up the binding, we can use an explicit assignment to the `ListView::ItemsSource`
    property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'An (elegant and preferred) alternative is to bind `ItemsSource` to something
    related to the `DataContext`. For example, the `ListView` markup can start with
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This means that `ItemsSource` is bound to whatever the `DataContext` is (should
    be a collection in this case). The lack of a property path means the object itself.
    With this markup, the binding is done with the following simple code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'To view the actual `Person` objects, `ItemsControl` provides the `ItemTemplate`
    property, which is a `DataTemplate` object that defines how `Person` objects are
    displayed. By default (without a `DataTemplate`), the type name is shown or another
    string representation of the object (if it has one) is used. This is rarely useful.
    A simple alternative is using the `DisplayMemberPath` property to show a specific
    property on the data object (such as `FirstName` for `Person` objects). A much
    more powerful way would be to use a `DataTemplate`, providing a customizable user
    interface for each item connected to the actual object via data binding. Here''s
    an example for our `ListView` of people:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The binding expressions inside the `DataTemplate` reach out to the relevant
    properties on the data object itself. Here''s the resulting `ListView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Binding to collections](img/5022_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Customizing a data view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data templates provide a powerful way to visualize and interact with data, partly
    because of the power of data binding. Sometimes, however, more customization is
    needed. For example, in a list of the `Book` objects, every book that's currently
    on sale should be displayed with a different color, or have some special animation,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The following sections describe some ways of customizing data templates.
  prefs: []
  type: TYPE_NORMAL
- en: Value converters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Value converters are types that implement the `Windows::UI::Xaml::Data::IValueConverter`
    interface. This interface provides a way to convert one value to another value,
    which can be of different types. Suppose we want to show a collection of books,
    but those that are on sale should have a slightly different look. With plain data
    templates, this is difficult, unless there are specific `Book` properties that
    have visual impact (such as a color or brush); this is unlikely, as data objects
    should be concerned about the data and not about how to display the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the definition of the `Book` class (change notifications are not implemented
    to simplify the example):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Value converters provide an elegant solution that keeps the object (`Book`
    in this example) decoupled from the way it''s presented. Here''s a basic `Book`
    data template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This is how the books are shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Value converters](img/5022_05_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Suppose we would like to use a green background for books that are on sale.
    What we don't want to do is add a `Background` property to the `Book` class. Instead,
    a value converter will be used to convert the `IsOnSale` property (a Boolean)
    to a `Brush` object, suitable for a property related to the `Background` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, the declaration of our value converter is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two methods to implement:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Convert`: Used when binding from source to target (the usual way)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ConvertBack`: Relevant for two-way bindings only'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In our case, the binding we use is the one-way binding only, so `ConvertBack`
    can simply return `nullptr` or throw an exception. Here''s the implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Two brushes are created in the constructor; one for regular books (transparent)
    and the other for books on sale (green). The `Convert` method is called with the
    `value` parameter being the `IsOnSale` property of the book in question. How this
    happens will become clear soon enough. The method simply looks at the Boolean
    value and returns the appropriate brush. This conversion is from a Boolean value
    to a `Brush`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step would be to actually create an instance of the converter. This
    is typically done in XAML, making the converter a resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, for the final connection, use an appropriate property to bind to `IsOnSale`
    and supply a converter for the operation. In our case, `Border` (part of the `DataTemplate`)
    will do very nicely:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Without the converter, the binding would simply fail, as there's no way a Boolean
    can be converted to a `Brush` automatically. The converter has been passed the
    value of `IsOnSale` and should return something appropriate to the target property
    for the conversion to succeed.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It's possible to use a `Binding` expression without `Path` (without `IsOnSale`
    in this example). The result is that the entire object (`Book`) is passed as the
    value argument for the converter. This can help in making decisions that are based
    on more than one property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Value converters](img/5022_05_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s add a small image next to a book that is on sale. How would we do that?
    We can certainly add an image, but it must be shown only when the book is on sale.
    We can use a (somewhat classic) converter, changing from Boolean to the `Visibility`
    enumeration and vice versa:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'With this in place, we can create an instance as a resource in the usual way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can add an image to the third column, visible only when needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Value converters](img/5022_05_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Value converters are extremely powerful, because they can leverage code to achieve
    visual changes.
  prefs: []
  type: TYPE_NORMAL
- en: Other parameters for Convert and ConvertBack
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`Convert` and `ConvertBack` accept more parameters, not just the value. Here''s
    the complete list:'
  prefs: []
  type: TYPE_NORMAL
- en: '`value`: The `value` argument (first) is the most important one for the `Convert`/`ConvertBack`
    method. There are three other arguments as well.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`targetType`: This indicates what''s the expected object type that should be
    returned. This can be used for checking if the converter is used correctly (in
    our example, `OnSaleToBrushConverter` would have a `Brush` type as `targetType`
    for the `Convert` method). The other possible use of this argument is in the case
    of a more complex value converter that may deal with multiple return types and
    may need to know about the current request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`parameter`: This is a free parameter that can be passed via the `Binding`
    expression with the `ConverterParameter` property. This can be useful for customizing
    a value converter on a binding expression basis.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`culture`: This receives whatever the `ConverterLanguage` property of the `Binding`
    expression has. This can be used to return different values based on a language,
    which is really just another string that can be passed along to the converter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data template selectors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In more extreme cases, the changes needed from `DataTemplate` may be too dramatic
    for value converters to be useful. If very different templates are needed by different
    objects (in the same collection), data template selectors may be a better alternative.
  prefs: []
  type: TYPE_NORMAL
- en: 'A data template selector is a class that derives from `Windows::UI::Xaml::Controls::DataTemplateSelector`
    (not a control, despite the namespace) and overrides the `SelectTemplateCore`
    method defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The method needs to return a `DataTemplate` that corresponds to the `item` argument.
    In the preceding examples, each item is `Book`; the code would look at some `Book`
    properties and conclude which `DataTemplate` should be used. This could also be
    based in some way on the `container` argument, which is the actual control hosting
    these objects (`ListView` in our example).
  prefs: []
  type: TYPE_NORMAL
- en: Next, an instance of this class is created in XAML (similar to a value converter),
    and the instance is set to the `ItemsControl::ItemTemplateSelector` property.
    If this is set, the `ItemTemplate` cannot be set at the same time, as it would
    conflict with the logic the template selector uses.
  prefs: []
  type: TYPE_NORMAL
- en: Commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The traditional way of connecting a piece of user interface to some logic is
    through events. The canonical example is a button—when clicked, some action is
    undertaken, hopefully accomplishing some goal the user has intended. Although
    WinRT supports this model completely (as other UI frameworks do), it has its drawbacks:'
  prefs: []
  type: TYPE_NORMAL
- en: The event handler is part of the "code behind" where the UI is declared, typically
    a `Page` or a `UserControl`. This makes it difficult to call from other objects
    that may want to invoke the same piece of logic.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The aforementioned button may disappear and be replaced by a different control.
    This would require the event hooking code to potentially change. What if we wanted
    more than one control to invoke the same functionality?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An action may not be allowed at some state—the button (or whatever) needs to
    be disabled or enabled at the right time. This adds management overhead to the
    developer—the need to track the state and change it for all UI elements that invoke
    the same functionality.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An event handler is just a method—there's no easy way to pick it up and save
    it somewhere, such as for undo/redo purposes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's difficult to test application logic without using an actual user interface,
    because logic and UI are intertwined.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These and other more subtle issues make working with event handlers less than
    ideal, especially when application logic is involved. If some event is just intended
    for usability enhancement or for otherwise serving the UI alone, this is not usually
    a concern.
  prefs: []
  type: TYPE_NORMAL
- en: The typical solution to this UI logic coupling is the concept of commands. This
    follows the famous "command design pattern" that abstracts away the application
    logic into distinct objects. Being an object, a command can be invoked from multiple
    locations, saved in lists (for example, for undo purposes), and so on. It can
    even indicate whether it's allowed in certain times or not, freeing other entities
    from taking care of the actual enabling or disabling of controls that may be bound
    to that command.
  prefs: []
  type: TYPE_NORMAL
- en: 'WinRT defines a basic command support with the `Windows::UI::Xaml::Input::ICommand`
    interface. `ICommand` has two methods and an event:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The** `Execute` **method**: This executes the command in question. It accepts
    a parameter that can be anything that can be used as an argument to the command.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The** `CanExecute` **method**: This method indicates whether this command
    is available at this time or not. WinRT uses this as a hint for enabling or disabling
    the command source.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The** `CanExecuteChanged` **event**: This is raised by the command to let
    WinRT know that it should call `CanExecute` again, because the availability of
    the command may have changed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Various controls have a `Command` property (of the type `ICommand`) that can
    be set up (typically using data binding) to point to an object implemented by
    `ICommand` (and a `CommandParameter` that allows passing some information to the
    command). The canonical example being the classic `Button`. When the button is
    clicked, the hooked command's `Execute` method is called. This means no `Click`
    handler is needed to set this up.
  prefs: []
  type: TYPE_NORMAL
- en: 'WinRT does not provide any implementation for `ICommand`. It''s up to the developer
    to create appropriate implementations. Here''s a simple implementation of a command
    that''s used for incrementing the birth year of a person:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'And the implementation is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'To make this work we can create a command source, such as a button and fill
    in the command details as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Creating a command within a `Command` property is unusual, the typical way of
    being bound to an appropriate property on a ViewModel, as we'll see in the next
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to MVVM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Commands are just one aspect of more general patterns for dealing with user
    interface in non-trivial applications. To that end, a number of UI design patterns
    are available, such as **Model View Controller** (**MVC**), **Model View Presenter**
    (**MVP**), and **Model-View-ViewModel** (**MVVM**). All have something in common:
    the separation of the actual UI (view) from the application logic (controller,
    presenter, and view model) and the underlying data (model).'
  prefs: []
  type: TYPE_NORMAL
- en: The MVVM pattern popularized by WPF and Silverlight leverages the power of data
    binding and commands to create decoupling between the UI (View) and the data (Model)
    by using an intermediary (View Model).
  prefs: []
  type: TYPE_NORMAL
- en: MVVM constituents
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MVVM has three participants. The model represents the data or business logic.
    This may consist of types that may be written in standard C++, without any regard
    to WinRT. It's typically neutral; that is, it knows nothing of how it's going
    to be used.
  prefs: []
  type: TYPE_NORMAL
- en: The view is the actual UI. It should display relevant parts of the model and
    provide the required interactive functionality. The view should not have a direct
    knowledge of the model, and this is where data binding comes in. All bindings
    access a property without explicitly knowing what type of object sits at the other
    end. This magic is satisfied at runtime by setting the view's `DataContext` to
    the object providing the data; this is the ViewModel.
  prefs: []
  type: TYPE_NORMAL
- en: 'The ViewModel is the glue that hands out the required data to the view (based
    on the model). The ViewModel is just that—a model for the view. It has several
    responsibilities:'
  prefs: []
  type: TYPE_NORMAL
- en: Expose properties that allow binding in the view. This may be just by accessing
    properties on the model (if it's written with WinRT), but may be more involved
    if the model exposes data in another way (such as with methods) or types that
    need translation, such as `std::vector<T>` that needs to be returned as `IVector<T>`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Expose commands (`ICommand`) to be invoked by elements in the view.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maintain a relevant state for the view.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The entire relationship between model, view, and view model can be summarized
    with the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![MVVM constituents](img/5022_05_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Building an MVVM framework
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It should be clear at this point that MVVM-based applications have a lot of
    elements in common, such as change notifications and commands. It would be beneficiary
    to create a reusable framework that we can simply leverage in many applications.
    Although there are several good frameworks out there (most are free), they are
    based around .NET, meaning they cannot be used in a C++ app because they are not
    exposed as a WinRT component, and even if they did, a C++ app must pay the price
    of the .NET CLR. Building such a framework ourselves is not too difficult and
    will enhance our understanding.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we''ll tackle is the desired ability of objects to implement
    the `INotifyPropertyChanged` interface so that they can raise the `PropertyChanged`
    event when any property is changed. We can achieve this with the following WinRT
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'And the implementation is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The inheritance from `DependencyObject` may seem redundant, but it's actually
    necessary to circumvent one deficiency in current WinRT support—any regular class
    has to be sealed, making it useless as a base class. Any class inheriting from
    `DependencyObject` can remain unsealed—exactly what we want.
  prefs: []
  type: TYPE_NORMAL
- en: The `ObservableObject` class seems very simple and perhaps not worth as a separate
    class. But we can add to it common functionalities that any derived classes can
    benefit from. For example, we can support the `ICustomPropertyProvider` interface—this
    interface allows the object to support dynamic properties that are not statically
    part of the type (the interested reader can find more information in the MSDN
    documentation).
  prefs: []
  type: TYPE_NORMAL
- en: 'Concrete types may use `ObservableObject` with code similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The next thing to take care of is commands. As we''ve seen, we can create a
    command by implementing `ICommand`, and this is sometimes necessary. An alternative
    would be to create a more generic class that uses delegates to call whatever code
    we want in response to the `Execute` and `CanExecute` methods of a command. Here''s
    an example of such a command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The class takes advantage of delegates, accepting two in the constructor; the
    first for executing a command, and the second to indicate whether the command
    is enabled.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a ViewModel that exposes a command to make a book loaned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The command is created in the constructor of a ViewModel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The ViewModel is control (view) free, meaning we can construct it without any
    visible user interface. It exposes properties for data binding to a relevant view
    and commands to execute actions from the view. The actual action would typically
    modify some state in the appropriate model.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is typically a one-to-one mapping between a view and a ViewModel. Although
    sometimes it's possible to share, this is not recommended.
  prefs: []
  type: TYPE_NORMAL
- en: More on MVVM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This was a quick tour of MVVM. Since this is a well-known pattern (thanks to
    its use in WPF and Silverlight), there's a lot of material on the web. Some things
    that can be added include a navigation-aware ViewModel (so that a `Frame` control
    is not accessed directly), a ViewModel locator service that allows easier binding
    between a view, and its corresponding ViewModel, and more.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A good start for more information on MVVM is available on Wikipedia at [http://en.wikipedia.org/wiki/Model_View_ViewModel](http://en.wikipedia.org/wiki/Model_View_ViewModel).
  prefs: []
  type: TYPE_NORMAL
- en: An implementation of a WinRT MVVM framework in C++ is somewhat awkward, as it's
    not (currently) possible to expose such a framework as a Windows Runtime Component,
    but only as a C++ static or dynamic library.
  prefs: []
  type: TYPE_NORMAL
- en: Regardless, the separation between data and view is an important one and will
    benefit all but the simplest of applications.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we saw what data binding is and how to use it. Data binding
    is an extremely powerful concept and its implementation in WinRT is pretty strong.
    Developers coming from a Win32 or MFC background should realize that a different
    approach is required for connecting display to data. Data binding provides a declarative
    model that supports separation between data and display, so the application logic
    only works with the data and will not really care which controls (if any) bind
    to that data.
  prefs: []
  type: TYPE_NORMAL
- en: MVVM concepts make this separation clearer and establish a foundation for incrementally
    enhancing an application without increasing maintenance headaches and logical
    complexity.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll take a look at building reusable WinRT components,
    as well as custom elements.
  prefs: []
  type: TYPE_NORMAL
