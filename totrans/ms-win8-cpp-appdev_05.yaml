- en: Chapter 5. Data Binding
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the preceding two chapters, we looked at XAML and the way user interface
    elements are constructed and laid out with the help of the layout panels. The
    user interface, however, is just the first step. Some data must be set upon the
    UI to make up an application.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: There are several ways of getting data to the controls. The simplest, perhaps,
    and most direct is the one we've been using so far; getting a reference to a control
    and changing the relevant property. If we needed some text to be placed in a `TextBox`,
    we would simply change its `Text` property when needed.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: This certainly works and when working with the Win32 API for UI purposes, there
    is really no other way. But this is tedious at best, and involves an unmanageable
    maintenance headache at worst. Data is not the only thing that needs to be taken
    care of. Element states, such as enabled/disabled and checked/unchecked need to
    be examined and perhaps dynamically changed. In WinRT, much of this chore is handled
    with data binding.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Understanding data binding
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data binding is essentially simple—one property changes in some object (source)
    and another property in another object (target) reflects the change in some meaningful
    way. Coupled with data templates, data binding provides a compelling and powerful
    way to visualize and interact with data.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Those familiar with WPF or Silverlight will find WinRT data binding very familiar.
    There are some changes, mostly omissions, from WinRT, making data binding a bit
    less powerful than in WPF/Silverlight. Still, it's much better than manually transferring
    and synchronizing data.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Data binding in WinRT leads to one of the well-known patterns for working with
    data and UI in a seamless manner, known as **Model-View-ViewModel** (**MVVM**),
    which we'll briefly discuss at the end of this chapter.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: Data binding concepts
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ll start by examining some of the basic terms associated with data binding,
    with the WinRT specifics added:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '**Source**: The object whose property is monitored for changes.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Source path**: The property on the source object to monitor.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Target**: The object whose property is changed when the source changes. In
    WinRT, the target property must be a dependency property (as we''ll see later
    on).'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Binding mode**: Indicates the direction of the binding.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Possible values are (all from the `Windows::UI::Xaml::Data::BindingMode` enumeration)
    as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '`OneWay`: Source changes update the target'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TwoWay`: Source and target update each other'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OneTime`: Source updates the target just once'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data binding is specified (most of the time) in XAML, providing a declarative
    and convenient way to connect to data. This has the direct effect of minimizing
    code writing for managing the element state and exchanging data between controls
    and data objects.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Element-to-element binding
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first binding scenario we''ll examine is the way in which we can connect
    elements together without writing any code—by performing data binding between
    required properties. Consider the following two elements:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Suppose we wanted the `FontSize` of the `TextBlock` to be changed, based on
    the current `Value` of the `Slider`. How would we go about doing that?
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: The obvious approach would be to use events. We can react to the `ValueChanged`
    event of the `Slider` and modify the `FontSize` property value of the `TextBlock`
    to be equal to the `Value` of the `Slider`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: 'This certainly works, but it has a few drawbacks:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: C++ code needs to be written for this to work. This is a shame, because no real
    data is used—this is just UI behavior. Perhaps a designer could take care of that
    if he/she could just use XAML and not code.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Such logic may change in the future. creating a maintenance headache—remember
    that a typical user interface will contain many such interactions—the C++ developer
    does not really want to be concerned about every such little detail.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Data binding provides an elegant solution. Here''s the `FontSize` setting of
    `TextBlock` that''s needed to make this idea work, without requiring any C++ code:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The data binding expression must be specified on the target property, using
    the `{Binding}` markup extension. The `Path` property indicates the source property
    to look for (`Slider::Value` in this case), and `ElementName` is the property
    to use if the source object is an element on the current page (in this case, the
    `Slider` is named `_slider`).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: 'Running this shows the following:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '![Element-to-element binding](img/5022_05_01.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
- en: Dragging the slider changes the text size automatically; this is the power of
    data binding.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `Path` property of `Binding` can be omitted if its value is the first argument.
    This means the previous binding expression is equivalent to the following:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This is more convenient and will be used most of the time.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: 'The same expression can be achieved with a code, such as the following:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The code assumes `_tb` is the name of the `TextBlock` in question. This is certainly
    more verbose, and is actually used only in specific scenarios (which we'll examine
    in [Chapter 6](ch06.html "Chapter 6. Components, Templates, and Custom Elements"),
    *Components, Templates, and Custom Elements*).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add another element, a `TextBox`, whose `Text` should reflect the current
    font size of the `TextBlock`. We''ll use data binding as well:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This works. But if we change the actual text of the `TextBox` to a different
    number, the font size does not change. Why?
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: 'The reason is that the binding is by default one way. To specify a two-way
    binding, we need to change the `Mode` property of the binding:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now, changing the `TextBox` and moving the focus to another control (such as
    by pressing *Tab* on the keyboard or touching some other element), changes the
    `FontSize` value of the `TextBlock`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Object-to-element binding
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although an element-to-element binding is sometimes useful, the classic data
    binding scenario involves a source, which is a regular, non-UI object, and a target,
    which is a UI element. The binding expression itself is similar to the element-to-element
    binding case; but naturally the `ElementName` property cannot be used.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to create an object that can support data binding. This must
    be a WinRT class that''s decorated with the `Bindable` attribute. The bindings
    themselves are on properties (as always). Here''s a simple `Person` class declaration:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The preceding code uses auto-implemented properties, which will suffice for
    now.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create such an object in XAML as a resource, and then use the `Binding::Source`
    property to hook up the binding itself. First, two `Person` objects are created
    as resources:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Next, we can bind these objects to elements as follows (all inside a `StackPanel`):'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `Source` property refers to the object being bound; a `Person` instance
    in this case. Here''s the resulting UI:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '![Object-to-element binding](img/5022_05_02.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
- en: Note that `Source` is specified in each and every binding expression. Without
    it, the binding would simply fail, as there is no source object to bind to.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the source is identical for all three elements, it would be beneficial
    to be able to specify the source just once, and allow all relevant elements to
    bind to it automatically without needing to specify the source explicitly. Fortunately,
    this is possible using the `FrameworkElement::DataContext` property. The rule
    is simple, if a source is not specified explicitly in a binding expression, a
    `DataContext` that is not a `nullptr` is searched in the visual tree, from the
    target element until one is found or the root of the visual tree is reached (typically
    a `Page` or a `UserControl`). If a `DataContext` is found, it becomes the source
    of the binding. Here''s an example that sets the `DataContext` on a parent `StackPanel`
    to be used by its children (whether immediate or not):'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This is the result (after some font size tweaks):'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '![Object-to-element binding](img/5022_05_03.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![对象到元素绑定](img/5022_05_03.jpg)'
- en: The binding expressions work correctly, because the implicit source is the `Person`
    object whose key is `p2`. Without the `DataContext`, all these bindings would
    silently fail.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定表达式工作正常，因为隐式源是`Person`对象，其键是`p2`。如果没有`DataContext`，所有这些绑定都会悄悄失败。
- en: Note
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Notice how the data binding expressions are simplified with `DataContext`. They're
    saying something such as, "I don't care what the source is, as long as there's
    a property named `<Fill in property name>` on some `DataContext` that's in scope."
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 注意数据绑定表达式如何通过`DataContext`简化。它们表达的意思是，“我不在乎源是什么，只要在范围内有一个名为`<填写属性名称>`的`DataContext`属性。”
- en: The idea of a `DataContext` is a powerful one and, in fact, using the `Source`
    property is rare.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`DataContext`的概念是强大的，事实上，很少使用`Source`属性。'
- en: Of course, setting a `Source` or `DataContext` in XAML to a predefined resource
    is rare as well. Setting the `DataContext` is usually done via code by getting
    relevant data from a data source, such as a local database or a web service. But
    it works regardless of where or how the `DataContext` is set.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在XAML中将`Source`或`DataContext`设置为预定义资源也是罕见的。通常通过代码获取相关数据源，如本地数据库或Web服务，来设置`DataContext`。但无论`DataContext`在何处或如何设置，它都能正常工作。
- en: Binding failures
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绑定失败
- en: 'Bindings are loosely typed—properties are specified as strings, and can be
    misspelled. For example, writing `FirstNam` instead of `FirstName` in the previous
    examples does not cause any exception to be thrown; the binding silently fails.
    The only other indication that something went wrong can be found in the **Visual
    Studio Output** window (**View** | **Output** from the menu) if the program is
    run under a debugger:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定是松散类型的——属性被指定为字符串，并且可能拼写错误。例如，在前面的示例中写`FirstNam`而不是`FirstName`不会引发任何异常；绑定会悄悄失败。如果程序在调试器下运行，则可以在**Visual
    Studio输出**窗口（菜单中的**查看** | **输出**）中找到发生错误的唯一指示。
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This text pinpoints the exact problem, specifying the property name to bind,
    the source object type, and the details about the target. This should help to
    fix the spelling mistake.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这段文字准确定位了确切的问题，指定了要绑定的属性名称，源对象类型以及有关目标的详细信息。这应该有助于修复拼写错误。
- en: Why is no exception thrown? The reason is that a data binding may fail at some
    point in time, and that's ok, because the conditions for this binding have not
    been met yet; there may be some information that is retrieved from a database,
    or from a web service, for instance. When the data is finally available, those
    bindings suddenly begin to work correctly.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么没有抛出异常？原因是数据绑定可能在某个时间点失败，这没关系，因为此时尚未满足此绑定的条件；例如，可能有一些信息是从数据库或Web服务中检索的。当数据最终可用时，这些绑定突然开始正常工作。
- en: This means true debugging of data binding expressions is not possible. A nice
    feature would be the ability to place a breakpoint in the XAML binding expression.
    This is currently unsupported, although it is graphically possible to place a
    breakpoint on a binding, it would simply never fire. This feature is available
    in Silverlight 5; hopefully, it will be supported in a future release of WinRT.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着无法真正调试数据绑定表达式。一个很好的功能是能够在XAML绑定表达式中设置断点。目前不支持这一功能，尽管在图形上可以在绑定上设置断点，但它根本不会触发。这个功能在Silverlight
    5中可用；希望它会在未来的WinRT版本中得到支持。
- en: Tip
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: One way to debug data bindings is by using value converters, discussed later
    in this chapter.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 调试数据绑定的一种方法是使用值转换器，稍后在本章中讨论。
- en: Change notifications
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更改通知
- en: 'Data binding supports three modes for binding: one way, two way, and one time.
    Up until now the binding occurred when the page first loads and remains unchanged
    after that. What happens if we change a property value on a `Person` object after
    the bindings are in place?'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 数据绑定支持三种绑定模式：单向，双向和一次性。直到现在，绑定发生在页面首次加载时，并在此后保持不变。如果在绑定已经就位后改变`Person`对象上的属性值会发生什么？
- en: 'After adding a simple button, the `Click` event handler does the following:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加一个简单的按钮后，`Click`事件处理程序执行以下操作：
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Since the `Person` instance was defined as a resource (uncommon, but possible),
    it's extracted from the `Resources` property of the page by using the specified
    key (`p1`). Then the `BirthYear` property is incremented.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`Person`实例被定义为资源（不常见，但可能），它通过使用指定的键（`p1`）从页面的`Resources`属性中提取。然后递增`BirthYear`属性。
- en: Running the application shows no visual change. Setting a breakpoint in the
    `Click` handler confirms it's actually called, and the `BirthYear` is changed,
    but the binding seems to have no effect.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序时没有视觉变化。在`Click`处理程序中设置断点确认它实际上被调用了，并且`BirthYear`已更改，但绑定似乎没有效果。
- en: 'The reason for this is the way the `BirthYear` property is currently implemented:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为`BirthYear`属性当前的实现方式：
- en: '[PRE12]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This is a trivial implementation that uses a private field behind the scenes.
    The problem is that when the property changes, nobody knows about it; specifically,
    the binding system has no idea anything has happened.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使用私有字段在后台实现的琐碎实现。问题在于当属性改变时，没有人知道；具体来说，绑定系统不知道发生了什么。
- en: 'To change that, a data object should implement the `Windows::UI::Xaml::Data::INotifyPropertyChanged`
    interface. This interface is queried by the binding system and, if found, registers
    for the `PropertyChanged` event (the only member of that interface). Here''s a
    revised declaration of the `Person` class, focusing on the `BirthYear` property:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 要改变这一点，数据对象应该实现`Windows::UI::Xaml::Data::INotifyPropertyChanged`接口。绑定系统会查询此接口，如果找到，就会注册`PropertyChanged`事件（该接口的唯一成员）。以下是`Person`类的修订声明，重点是`BirthYear`属性：
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The getter is implemented inline, and the setter is implemented in the CPP
    file, as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: getter是内联实现的，setter在CPP文件中实现如下：
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `PropertyChanged` event is raised, accepting a `PropertyChangedEventArgs`
    object that accepts the changed property name. Now, running the application and
    clicking on the button shows an incremented birth year, as expected.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: 'This effectively means that every property should be implemented in a similar
    fashion; declaring a private field and raising the `PropertyChanged` event in
    the setter. Here''s a revised `FirstName` property implementation (this time implemented
    inline):'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`_firstName` is a private `String^` field defined within the class as well.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: Binding to collections
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous examples used a property that binds to a single object. As we've
    seen in the previous chapter, a bunch of controls deriving from `ItemsControl`
    can present information for more than one data item. It stands to reason that
    these controls should bind to a collection of data items, such as a collection
    of the `Person` objects.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: 'The property to be used for binding purposes is `ItemsSource`. This should
    be set to a collection, typically `IVector<T>`. Here''s an example of some `Person`
    objects bound to a `ListView` (a constructor was added to person for convenient
    initialization):'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'To set up the binding, we can use an explicit assignment to the `ListView::ItemsSource`
    property:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'An (elegant and preferred) alternative is to bind `ItemsSource` to something
    related to the `DataContext`. For example, the `ListView` markup can start with
    this:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This means that `ItemsSource` is bound to whatever the `DataContext` is (should
    be a collection in this case). The lack of a property path means the object itself.
    With this markup, the binding is done with the following simple code:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To view the actual `Person` objects, `ItemsControl` provides the `ItemTemplate`
    property, which is a `DataTemplate` object that defines how `Person` objects are
    displayed. By default (without a `DataTemplate`), the type name is shown or another
    string representation of the object (if it has one) is used. This is rarely useful.
    A simple alternative is using the `DisplayMemberPath` property to show a specific
    property on the data object (such as `FirstName` for `Person` objects). A much
    more powerful way would be to use a `DataTemplate`, providing a customizable user
    interface for each item connected to the actual object via data binding. Here''s
    an example for our `ListView` of people:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The binding expressions inside the `DataTemplate` reach out to the relevant
    properties on the data object itself. Here''s the resulting `ListView`:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '![Binding to collections](img/5022_05_04.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
- en: Customizing a data view
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data templates provide a powerful way to visualize and interact with data, partly
    because of the power of data binding. Sometimes, however, more customization is
    needed. For example, in a list of the `Book` objects, every book that's currently
    on sale should be displayed with a different color, or have some special animation,
    and so on.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: The following sections describe some ways of customizing data templates.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: Value converters
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Value converters are types that implement the `Windows::UI::Xaml::Data::IValueConverter`
    interface. This interface provides a way to convert one value to another value,
    which can be of different types. Suppose we want to show a collection of books,
    but those that are on sale should have a slightly different look. With plain data
    templates, this is difficult, unless there are specific `Book` properties that
    have visual impact (such as a color or brush); this is unlikely, as data objects
    should be concerned about the data and not about how to display the data.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the definition of the `Book` class (change notifications are not implemented
    to simplify the example):'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Value converters provide an elegant solution that keeps the object (`Book`
    in this example) decoupled from the way it''s presented. Here''s a basic `Book`
    data template:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This is how the books are shown:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '![Value converters](img/5022_05_05.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
- en: Suppose we would like to use a green background for books that are on sale.
    What we don't want to do is add a `Background` property to the `Book` class. Instead,
    a value converter will be used to convert the `IsOnSale` property (a Boolean)
    to a `Brush` object, suitable for a property related to the `Background` property.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要为打折的书籍使用绿色背景。我们不想在`Book`类中添加`Background`属性。相反，将使用值转换器将`IsOnSale`属性（布尔值）转换为适用于`Background`属性的`Brush`对象。
- en: 'First, the declaration of our value converter is as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们的值转换器的声明如下：
- en: '[PRE23]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'There are two methods to implement:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方法来实现：
- en: '`Convert`: Used when binding from source to target (the usual way)'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Convert`：从源到目标绑定时使用（通常的方式）'
- en: '`ConvertBack`: Relevant for two-way bindings only'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConvertBack`：仅适用于双向绑定'
- en: 'In our case, the binding we use is the one-way binding only, so `ConvertBack`
    can simply return `nullptr` or throw an exception. Here''s the implementation:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们使用的是单向绑定，所以`ConvertBack`可以简单地返回`nullptr`或抛出异常。这是实现：
- en: '[PRE24]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Two brushes are created in the constructor; one for regular books (transparent)
    and the other for books on sale (green). The `Convert` method is called with the
    `value` parameter being the `IsOnSale` property of the book in question. How this
    happens will become clear soon enough. The method simply looks at the Boolean
    value and returns the appropriate brush. This conversion is from a Boolean value
    to a `Brush`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中创建了两个画笔；一个用于普通书籍（透明），另一个用于打折书籍（绿色）。调用`Convert`方法时，`value`参数是所讨论书籍的`IsOnSale`属性。这将很快变得清楚。该方法只是查看布尔值并返回适当的画笔。这种转换是从布尔值到`Brush`。
- en: 'The next step would be to actually create an instance of the converter. This
    is typically done in XAML, making the converter a resource:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步将是实际创建转换器的实例。这通常是在XAML中完成的，将转换器作为资源：
- en: '[PRE25]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, for the final connection, use an appropriate property to bind to `IsOnSale`
    and supply a converter for the operation. In our case, `Border` (part of the `DataTemplate`)
    will do very nicely:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了最终连接，使用适当的属性绑定到`IsOnSale`并为操作提供一个转换器。在我们的情况下，`Border`（`DataTemplate`的一部分）非常合适：
- en: '[PRE26]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Without the converter, the binding would simply fail, as there's no way a Boolean
    can be converted to a `Brush` automatically. The converter has been passed the
    value of `IsOnSale` and should return something appropriate to the target property
    for the conversion to succeed.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 没有转换器，绑定将会失败，因为没有办法自动将布尔值转换为`Brush`。转换器已经传递了`IsOnSale`的值，并且应该返回适合目标属性的内容以使转换成功。
- en: Note
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It's possible to use a `Binding` expression without `Path` (without `IsOnSale`
    in this example). The result is that the entire object (`Book`) is passed as the
    value argument for the converter. This can help in making decisions that are based
    on more than one property.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用不带`Path`（在此示例中不带`IsOnSale`）的`Binding`表达式。结果是整个对象（`Book`）作为转换器的值参数传递。这有助于基于多个属性做出决策。
- en: 'Here''s the result:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这是结果：
- en: '![Value converters](img/5022_05_06.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![值转换器](img/5022_05_06.jpg)'
- en: 'Let''s add a small image next to a book that is on sale. How would we do that?
    We can certainly add an image, but it must be shown only when the book is on sale.
    We can use a (somewhat classic) converter, changing from Boolean to the `Visibility`
    enumeration and vice versa:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在打折的书旁边添加一个小图片。我们可以添加一张图片，但只有当书打折时才显示。我们可以使用（有点经典的）转换器，从布尔值转换为`Visibility`枚举，反之亦然：
- en: '[PRE27]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'With this in place, we can create an instance as a resource in the usual way:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们可以像通常一样在资源中创建一个实例：
- en: '[PRE28]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Then, we can add an image to the third column, visible only when needed:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以在需要时向第三列添加一张图片：
- en: '[PRE29]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This is the result:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这是结果：
- en: '![Value converters](img/5022_05_07.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![值转换器](img/5022_05_07.jpg)'
- en: Value converters are extremely powerful, because they can leverage code to achieve
    visual changes.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 值转换器非常强大，因为它们可以利用代码实现视觉变化。
- en: Other parameters for Convert and ConvertBack
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Convert和ConvertBack的其他参数
- en: '`Convert` and `ConvertBack` accept more parameters, not just the value. Here''s
    the complete list:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`Convert`和`ConvertBack`接受更多参数，不仅仅是值。以下是完整列表：'
- en: '`value`: The `value` argument (first) is the most important one for the `Convert`/`ConvertBack`
    method. There are three other arguments as well.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`value`：`value`参数（第一个）对于`Convert`/`ConvertBack`方法非常重要。还有其他三个参数。'
- en: '`targetType`: This indicates what''s the expected object type that should be
    returned. This can be used for checking if the converter is used correctly (in
    our example, `OnSaleToBrushConverter` would have a `Brush` type as `targetType`
    for the `Convert` method). The other possible use of this argument is in the case
    of a more complex value converter that may deal with multiple return types and
    may need to know about the current request.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`targetType`：这表示应返回的预期对象类型。这可用于检查转换器是否正确使用（在我们的示例中，`OnSaleToBrushConverter`的`Convert`方法的`targetType`将是`Brush`类型）。此参数的另一个可能用途是在更复杂的值转换器的情况下，可能需要处理多个返回类型并且可能需要了解当前请求。'
- en: '`parameter`: This is a free parameter that can be passed via the `Binding`
    expression with the `ConverterParameter` property. This can be useful for customizing
    a value converter on a binding expression basis.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`parameter`：这是一个自由参数，可以通过`Binding`表达式的`ConverterParameter`属性传递。这对于根据绑定表达式自定义值转换器很有用。'
- en: '`culture`: This receives whatever the `ConverterLanguage` property of the `Binding`
    expression has. This can be used to return different values based on a language,
    which is really just another string that can be passed along to the converter.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`culture`：这接收`Binding`表达式的`ConverterLanguage`属性的内容。这可用于根据语言返回不同的值，这实际上只是可以传递给转换器的另一个字符串。'
- en: Data template selectors
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据模板选择器
- en: In more extreme cases, the changes needed from `DataTemplate` may be too dramatic
    for value converters to be useful. If very different templates are needed by different
    objects (in the same collection), data template selectors may be a better alternative.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: 'A data template selector is a class that derives from `Windows::UI::Xaml::Controls::DataTemplateSelector`
    (not a control, despite the namespace) and overrides the `SelectTemplateCore`
    method defined as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The method needs to return a `DataTemplate` that corresponds to the `item` argument.
    In the preceding examples, each item is `Book`; the code would look at some `Book`
    properties and conclude which `DataTemplate` should be used. This could also be
    based in some way on the `container` argument, which is the actual control hosting
    these objects (`ListView` in our example).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: Next, an instance of this class is created in XAML (similar to a value converter),
    and the instance is set to the `ItemsControl::ItemTemplateSelector` property.
    If this is set, the `ItemTemplate` cannot be set at the same time, as it would
    conflict with the logic the template selector uses.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Commands
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The traditional way of connecting a piece of user interface to some logic is
    through events. The canonical example is a button—when clicked, some action is
    undertaken, hopefully accomplishing some goal the user has intended. Although
    WinRT supports this model completely (as other UI frameworks do), it has its drawbacks:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: The event handler is part of the "code behind" where the UI is declared, typically
    a `Page` or a `UserControl`. This makes it difficult to call from other objects
    that may want to invoke the same piece of logic.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The aforementioned button may disappear and be replaced by a different control.
    This would require the event hooking code to potentially change. What if we wanted
    more than one control to invoke the same functionality?
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An action may not be allowed at some state—the button (or whatever) needs to
    be disabled or enabled at the right time. This adds management overhead to the
    developer—the need to track the state and change it for all UI elements that invoke
    the same functionality.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An event handler is just a method—there's no easy way to pick it up and save
    it somewhere, such as for undo/redo purposes.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's difficult to test application logic without using an actual user interface,
    because logic and UI are intertwined.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These and other more subtle issues make working with event handlers less than
    ideal, especially when application logic is involved. If some event is just intended
    for usability enhancement or for otherwise serving the UI alone, this is not usually
    a concern.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: The typical solution to this UI logic coupling is the concept of commands. This
    follows the famous "command design pattern" that abstracts away the application
    logic into distinct objects. Being an object, a command can be invoked from multiple
    locations, saved in lists (for example, for undo purposes), and so on. It can
    even indicate whether it's allowed in certain times or not, freeing other entities
    from taking care of the actual enabling or disabling of controls that may be bound
    to that command.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: 'WinRT defines a basic command support with the `Windows::UI::Xaml::Input::ICommand`
    interface. `ICommand` has two methods and an event:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '**The** `Execute` **method**: This executes the command in question. It accepts
    a parameter that can be anything that can be used as an argument to the command.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The** `CanExecute` **method**: This method indicates whether this command
    is available at this time or not. WinRT uses this as a hint for enabling or disabling
    the command source.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The** `CanExecuteChanged` **event**: This is raised by the command to let
    WinRT know that it should call `CanExecute` again, because the availability of
    the command may have changed.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Various controls have a `Command` property (of the type `ICommand`) that can
    be set up (typically using data binding) to point to an object implemented by
    `ICommand` (and a `CommandParameter` that allows passing some information to the
    command). The canonical example being the classic `Button`. When the button is
    clicked, the hooked command's `Execute` method is called. This means no `Click`
    handler is needed to set this up.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: 'WinRT does not provide any implementation for `ICommand`. It''s up to the developer
    to create appropriate implementations. Here''s a simple implementation of a command
    that''s used for incrementing the birth year of a person:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'And the implementation is as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'To make this work we can create a command source, such as a button and fill
    in the command details as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Creating a command within a `Command` property is unusual, the typical way of
    being bound to an appropriate property on a ViewModel, as we'll see in the next
    section.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to MVVM
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Commands are just one aspect of more general patterns for dealing with user
    interface in non-trivial applications. To that end, a number of UI design patterns
    are available, such as **Model View Controller** (**MVC**), **Model View Presenter**
    (**MVP**), and **Model-View-ViewModel** (**MVVM**). All have something in common:
    the separation of the actual UI (view) from the application logic (controller,
    presenter, and view model) and the underlying data (model).'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: The MVVM pattern popularized by WPF and Silverlight leverages the power of data
    binding and commands to create decoupling between the UI (View) and the data (Model)
    by using an intermediary (View Model).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: MVVM constituents
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MVVM has three participants. The model represents the data or business logic.
    This may consist of types that may be written in standard C++, without any regard
    to WinRT. It's typically neutral; that is, it knows nothing of how it's going
    to be used.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: The view is the actual UI. It should display relevant parts of the model and
    provide the required interactive functionality. The view should not have a direct
    knowledge of the model, and this is where data binding comes in. All bindings
    access a property without explicitly knowing what type of object sits at the other
    end. This magic is satisfied at runtime by setting the view's `DataContext` to
    the object providing the data; this is the ViewModel.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: 'The ViewModel is the glue that hands out the required data to the view (based
    on the model). The ViewModel is just that—a model for the view. It has several
    responsibilities:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: Expose properties that allow binding in the view. This may be just by accessing
    properties on the model (if it's written with WinRT), but may be more involved
    if the model exposes data in another way (such as with methods) or types that
    need translation, such as `std::vector<T>` that needs to be returned as `IVector<T>`.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Expose commands (`ICommand`) to be invoked by elements in the view.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maintain a relevant state for the view.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The entire relationship between model, view, and view model can be summarized
    with the following diagram:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '![MVVM constituents](img/5022_05_08.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
- en: Building an MVVM framework
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It should be clear at this point that MVVM-based applications have a lot of
    elements in common, such as change notifications and commands. It would be beneficiary
    to create a reusable framework that we can simply leverage in many applications.
    Although there are several good frameworks out there (most are free), they are
    based around .NET, meaning they cannot be used in a C++ app because they are not
    exposed as a WinRT component, and even if they did, a C++ app must pay the price
    of the .NET CLR. Building such a framework ourselves is not too difficult and
    will enhance our understanding.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we''ll tackle is the desired ability of objects to implement
    the `INotifyPropertyChanged` interface so that they can raise the `PropertyChanged`
    event when any property is changed. We can achieve this with the following WinRT
    class:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'And the implementation is as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The inheritance from `DependencyObject` may seem redundant, but it's actually
    necessary to circumvent one deficiency in current WinRT support—any regular class
    has to be sealed, making it useless as a base class. Any class inheriting from
    `DependencyObject` can remain unsealed—exactly what we want.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: The `ObservableObject` class seems very simple and perhaps not worth as a separate
    class. But we can add to it common functionalities that any derived classes can
    benefit from. For example, we can support the `ICustomPropertyProvider` interface—this
    interface allows the object to support dynamic properties that are not statically
    part of the type (the interested reader can find more information in the MSDN
    documentation).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: 'Concrete types may use `ObservableObject` with code similar to the following:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The next thing to take care of is commands. As we''ve seen, we can create a
    command by implementing `ICommand`, and this is sometimes necessary. An alternative
    would be to create a more generic class that uses delegates to call whatever code
    we want in response to the `Execute` and `CanExecute` methods of a command. Here''s
    an example of such a command:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The class takes advantage of delegates, accepting two in the constructor; the
    first for executing a command, and the second to indicate whether the command
    is enabled.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a ViewModel that exposes a command to make a book loaned:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The command is created in the constructor of a ViewModel:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The ViewModel is control (view) free, meaning we can construct it without any
    visible user interface. It exposes properties for data binding to a relevant view
    and commands to execute actions from the view. The actual action would typically
    modify some state in the appropriate model.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is typically a one-to-one mapping between a view and a ViewModel. Although
    sometimes it's possible to share, this is not recommended.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: More on MVVM
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This was a quick tour of MVVM. Since this is a well-known pattern (thanks to
    its use in WPF and Silverlight), there's a lot of material on the web. Some things
    that can be added include a navigation-aware ViewModel (so that a `Frame` control
    is not accessed directly), a ViewModel locator service that allows easier binding
    between a view, and its corresponding ViewModel, and more.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A good start for more information on MVVM is available on Wikipedia at [http://en.wikipedia.org/wiki/Model_View_ViewModel](http://en.wikipedia.org/wiki/Model_View_ViewModel).
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: An implementation of a WinRT MVVM framework in C++ is somewhat awkward, as it's
    not (currently) possible to expose such a framework as a Windows Runtime Component,
    but only as a C++ static or dynamic library.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: Regardless, the separation between data and view is an important one and will
    benefit all but the simplest of applications.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we saw what data binding is and how to use it. Data binding
    is an extremely powerful concept and its implementation in WinRT is pretty strong.
    Developers coming from a Win32 or MFC background should realize that a different
    approach is required for connecting display to data. Data binding provides a declarative
    model that supports separation between data and display, so the application logic
    only works with the data and will not really care which controls (if any) bind
    to that data.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: MVVM concepts make this separation clearer and establish a foundation for incrementally
    enhancing an application without increasing maintenance headaches and logical
    complexity.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll take a look at building reusable WinRT components,
    as well as custom elements.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
