- en: Build a Full Stack Social Media Application with React Native and GraphQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By now, you can almost call yourself an expert with React Native, as you're
    about to start working on the most complex application of the React Native sections.
    A great advantage of mobile applications is that you can send direct notifications
    to the people that have your application installed. That way, you can target users
    when there's an important event taking place in your application or when someone
    hasn't used the application for a while. Also, mobile applications can directly
    use the camera of the device it's running on to take photos and videos.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapter, you created a mobile messaging application that has
    an authentication flow and real-time data and uses GraphQL with React Native.
    These patterns and techniques will also be used in this chapter to create a mobile
    social media application that lets you post images to a social feed and allows
    you to star and comment on these posts. Not only will using the camera be an important
    section in this chapter, but you'll also add the possibility to send notifications
    to the user with Expo.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the camera with React Native and Expo
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refreshing data with React Native and GraphQL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending mobile notifications with Expo
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Project overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A mobile social media application that is using a local GraphQL server to request
    and add posts to the social feed, including using the camera on the mobile device.
    Basic authentication is added using the local GraphQL server and React Navigation,
    while Expo is used for access to the camera (roll) and for sending notifications
    when new comments are added to your posts.
  prefs: []
  type: TYPE_NORMAL
- en: The build time is 2 hours.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The project that we'll create in this chapter builds upon an initial version
    that you can find on GitHub: [https://github.com/PacktPublishing/React-Projects/tree/ch11-initial](https://github.com/PacktPublishing/React-Projects/tree/ch11-initial).
    The complete source code can also be found on GitHub: [https://github.com/PacktPublishing/React-Projects/tree/ch11](https://github.com/PacktPublishing/React-Projects/tree/ch11).
  prefs: []
  type: TYPE_NORMAL
- en: You need to have the application Expo Client installed on a mobile iOS or Android
    device to run the project on a physical device.
  prefs: []
  type: TYPE_NORMAL
- en: It's **highly recommended** to use the Expo Client application to run the project
    from this chapter on a physical device. Receiving notifications is currently only
    supported on physical devices, and running the project on either the iOS simulator
    or Android Studio emulator will result in error messages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, you can install either Xcode or Android Studio on your computer
    to run the application on a virtual device:'
  prefs: []
  type: TYPE_NORMAL
- en: '**For iOS**: Information on how to set up your local machine to run the iOS
    simulator can be found here: [https://docs.expo.io/versions/v36.0.0/workflow/ios-simulator/](https://docs.expo.io/versions/v36.0.0/workflow/ios-simulator/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**For Android**: Information on how to set up your local machine to run the
    emulator from Android Studio can be found here: [https://docs.expo.io/versions/v36.0.0/workflow/android-studio-emulator/](https://docs.expo.io/versions/v36.0.0/workflow/android-studio-emulator/).
    There''s a known issue when running the emulator, which can be prevented by ensuring
    that the following lines are present in your `~/.bash_profile` or `~/.bash_rc`  file:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The value for `ANDROID_SDK_LOCATION` is the path to the Android SDK on your
    local machine and can be found by opening Android Studio and going to **Preferences** | **Appearance
    & Behavior** *|* **System Settings** | **Android SDK**. The path is listed in
    the box that states the Android SDK locationand looks like this: `/Users/myuser/Library/Android/sdk`.
  prefs: []
  type: TYPE_NORMAL
- en: This application was created using **Expo SDK version 33.0.0,** and so, you
    need to ensure that the version of Expo you're using on your local machine is
    similar. As React Native and Expo are frequently updated, make sure that you're
    working with this version so that the patterns described in this chapter behave
    as expected. In case your application doesn’t start or if you encounter errors,
    refer to the Expo documentation to learn more about updating the Expo SDK.
  prefs: []
  type: TYPE_NORMAL
- en: Checking out the initial project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This project consists of two parts, a boilerplate React Native application and
    a GraphQL server. The React Native application can be found in the `client` directory,
    while the GraphQL server is placed in the `server` directory. For this chapter,
    you'll need to have both the application and the server running at all times,
    while you only make code changes to the application in the `client` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started you''ll need to run the following command in both the `client` and `server` directories
    to install all of the dependencies and start both the server and application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: For the mobile application, this command will start Expo after installing the
    dependencies, and it gives you the ability to start your project both from the
    Terminal or your browser. In the Terminal, you can now either use the QR code
    to open the application on your mobile device or open the application in a simulator.
  prefs: []
  type: TYPE_NORMAL
- en: The local GraphQL server for this project is running on `http://localhost:4000/graphql/`, but
    to be able to use this endpoint in the React Native application, you need to find
    the local IP address of your machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'To find your local IP address, you''ll need to do the following depending on
    your operating system:'
  prefs: []
  type: TYPE_NORMAL
- en: '**For Windows**: Open the Terminal (or command prompt) and run this command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This will return a list like the one you see below with data from your local
    machine. In this list, you need to look for the field **IPv4 Address**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/f91e2398-5dc0-4091-ba7e-90f29bf63aac.png)'
  prefs: []
  type: TYPE_IMG
- en: '**For macOS**: Open the Terminal and run this command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'After running this command, the local `Ipv4 Address` of your machine gets returned,
    which looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The local IP address must be used to create the value for `API_URL` in the
    file `client/App.js`, with the prefix `http://` and suffix `/graphql`, making
    it look like `http://192.168.1.107/graphql`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'No matter whether you''ve opened the application from virtual or physical device,
    the application at this point should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/f5b65733-4019-44b8-8c29-afa114d8695f.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This application was created using **Expo SDK version 33.0.0** and therefore
    you need to make sure the version of Expo you're using on your local machine is
    similar. As React Native and Expo are updated frequently, make sure that you're
    working with this version to ensure the patterns described in this chapter are
    behaving as expected. If your application won't start or you're receiving errors,
    make sure to check the Expo documentation to learn more about updating the Expo
    SDK.
  prefs: []
  type: TYPE_NORMAL
- en: 'The initial application consists of seven screens: `AddPost`,  `AuthLoading`, `Login`, 
    `Notifications`, `Post`, `Posts`, and `Settings`. The `Login` screen will be the
    first screen you''ll see when first starting the application, where you can log
    in using the following credentials:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Username**: `test`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Password**: `test`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Posts` screen will be the initial screen when logged in and shows a list
    of posts on which you can tap to continue to the `Post` screen, while the `Settings` screens
    shows a non-functioning logout button. For now, the `AddPost` and `Notification` screens
    aren't visible yet, as you'll add the routing to these screens later on in this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The project structure from this React Native application in the `directory` client is
    as follows, where the structure is similar to the projects you''ve created before
    in this book:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the `assets` directory,  you can find the images that are used as the application
    icon on the home screen once you've installed this application on your mobile
    device, and the image that will serve as the splash screen that is displayed when
    you start the application. For example, configurations in the App Store for the
    name of your application are placed in `app.json`, while `babel.config.js` holds
    specific Babel configurations.
  prefs: []
  type: TYPE_NORMAL
- en: The `App.js` file is the actual entry point of your application, where the `AppContainer.js` file is
    being imported and returned. In `AppContainer`, all of the routes for this application
    are defined and `AppContext` will contain information that should be available
    in the entire application.
  prefs: []
  type: TYPE_NORMAL
- en: 'All of the components for this application are located in the `Screens` and `Components` directories,
    where the first one holds the components that are rendered by the screens. The
    child components for these screens can be found in the `Components` directory, which
    has the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The GraphQL server can be found at the `http://localhost:4000/graphql` URL,
    where GraphQL Playground will be visible. From this playground, you can view the
    schema for the GraphQL server and inspect all of the available queries, mutations,
    and subscriptions. Although you won't be making any code changes to the server,
    it's important to know about the schema and its workings.
  prefs: []
  type: TYPE_NORMAL
- en: 'The server has two queries to retrieve a list of posts or a single post by
    using the `userName` parameter as the identifier. These queries will return the
    `Post` type that has `id`, `userName`, `image`, a counted value of `stars` and
    `comments`, a list of stars of the `stars` type, and a list of `comments` with
    the `Comment` type. The query to retrieve a single post will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: After this, three mutations can be found for the GraphQL server, which are to
    either log in the user, store a push token from Expo, or add a post.
  prefs: []
  type: TYPE_NORMAL
- en: If you're receiving an error stating `Please provide (valid) authentication details`,
    you'll need to log in to the application again. Probably, the JWT from the previous
    application is still available in `AsyncStorage` of Expo, and this will not validate
    on the GraphQL server for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Building a full stack social media application with React Native, Apollo, and
    GraphQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The application that you're going to build in this chapter will use a local
    GraphQL server to retrieve and mutate data that is available in the application.
    This application will display data from a social media feed and let you respond
    to these social media posts.
  prefs: []
  type: TYPE_NORMAL
- en: Using the camera with React Native and Expo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Next to displaying the posts that were created by the GraphQL server, you can
    also add a post yourself using a GraphQL mutation and send a text and an image
    as variables. Uploading images to your React Native application can be done by
    using either the camera to take an image or by selecting an image from your camera
    roll. For both use cases, there are APIs available from React Native and Expo,
    or numerous packages that are installable from `npm`. For this project, you'll
    use the ImagePicker API from Expo, which combines these functionalities into just
    one component.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add the feature to create new posts to your social media application, the
    following changes need to be made to create the new screen to add the post:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The GraphQL mutation that can be used to add a post to the feed you see in
    the `Main` screen sends the image variable to the GraphQL server. This mutation
    has the following form:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The `image` variable is `String` and is the URL to the absolute path of the
    image for this post. This GraphQL mutation needs to be added to the bottom of
    the `client/constants.js` file so it can be used from a `useMutation` Hook later
    on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'With `Mutation` in place, the screen for adding the post must be added to `SwitchNavigator`
    in the `client/AppContainer.js` file. The `AddPost` screen component can be found
    in the `client/Screens/AddPost.js` file and should be added as a modal in the
    navigator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'And of course, the user must be able to open this modal from somewhere in your
    application, for example, from the tab navigator at the bottom of the screen or
    the header. For this scenario, you can add the navigation link to the `AddPost`
    screen in the header—that way, the user can add a new post from the `Posts` screen
    only by tapping a link in the header. This link can be added by setting `navigationOptions`
    in the `client/Screens/Posts.js` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: By setting the `headerRight` field in `navigationOptions`, only the right part
    of the header will be changed and the title that has been set from the navigator
    will keep in place. Tapping the `Add Post` link will now navigate to the `AddPost`
    screen, where a title and button to close the modal are displayed.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you''ve now added the `AddPost` screen, the ImagePicker API from Expo should
    be added to this screen. To add `ImagePicker` to the `AddPost` screen, follow
    the next steps to enable the selection of photos from the camera roll in the `client/Screens/AddPost.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before the user can select photos from the camera roll, the right permission
    should be set for the application when the user is using an iOS device. To request
    permissions, you can use the permissions API from Expo, which should request `CAMERA_ROLL`
    permissions. The permissions API used to be available directly from Expo, but
    has been moved to a separate package called `expo-permissions` that can be installed
    from the Expo CLI by running this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'After this, you can import the permissions API and create the function to check
    whether the right permissions have been granted for the camera roll:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This `getPermissionAsync` function is asynchronous and can be called from a
    `Button` or `Touchable` element. At the bottom of this file, the `UploadImage` component can
    be found, which is a styled `TouchableOpacity` element that can take an `onPress` function.
    This component must be added to the return function of `AddPost` and should call
    the `getPermissionAsync` function when tapped:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: When tapped, a popup requesting permission to access the camera roll will be
    opened on iOS devices. When you don't accept the request, you can't select photos
    from the camera roll.
  prefs: []
  type: TYPE_NORMAL
- en: You can't ask the user for permission a second time; instead, you'd need to
    manually grant the permission to the camera roll. To set this permission again,
    you should go to the setting screen from iOS and select the Expo application.
    On the next screen, you're able to add the permission to access the camera.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the user has granted permission to access the camera roll, you can call
    the ImagePicker API from Expo to open the camera roll. Just like the permissions
    API, this used to be part of Expo''s core, but has now been moved to a separate
    package that you can install using the Expo CLI:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This is again an asynchronous function that takes some configuration fields
    such as the aspect ratio. If the user has selected an image, the ImagePicker API
    will return an object containing the field URI, which is the URL to the image
    on the users'' device that can be used in an `Image` component. This result can
    be stored in a local state by creating one with the `useState` Hook, so it can
    be sent to the GraphQL server later on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'And this `pickImageAsync` function can then be called from the function to
    get the users'' permissions when they''ve been granted for the camera roll:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'As the URL to the image is now stored in the local state to the `imageUrl` constant,
    you can display this URL in an `Image` component. This `Image` component takes `imageUrl`
    as value for the source and has been set to use a 100% `width` and `height`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'With these changes, the `AddPost` screen should look something like the following
    screenshot, which was taken from a device running iOS. There might be slight differences
    in the appearance of this screen if you''re using the Android Studio emulator
    or a device that runs Android:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/cae322ec-d489-4df3-924c-08de3f1fb3ea.png)'
  prefs: []
  type: TYPE_IMG
- en: These changes will make it possible to select a photo from your camera roll,
    but your users should also be able to upload an entirely new photo by using their
    camera. With the ImagePicker from Expo, you can handle both scenarios, as this
    component also has a `launchCameraAsync` method. This asynchronous function will
    launch the camera, and return it the same way as it returns a URL to the image
    from the camera roll.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add the functionality to directly use the camera on the user''s device to
    upload an image, you can make the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'As the user needs to grant your application permission to access the camera
    roll, the user needs to do the same for using the camera. Permission to use the
    camera can be requested by sending `Permissions.CAMERA` with the `Permissions.askAsync` method.
    The check for the granted permission for the camera roll must be extended to also
    check for the camera permission:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This will ask the user for permission to use the camera on iOS, which can also
    be granted manually by going to Settings | Expo.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the permission granted, you can continue by creating the function to launch
    the camera by calling `launchCameraAsync` from `ImagePicker`. The functionality
    is the same as for the `launchCameraAsync` function that you created to open the
    camera roll; therefore, the `pickImageAsync` function can be edited to also be
    able to launch the camera:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: If you now send a parameter to the `addImageAsync` function, `launchCameraAsync` will
    be called. Otherwise, the user will be directed to the camera roll on their device.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the user clicks on the image placeholder, the image roll will be opened
    by default. But you also want to give the user the option to use their camera.
    Therefore, a selection must be made between using the camera or the camera roll
    for uploading the image, which is a perfect use case for implementing an `ActionSheet`
    component. React Native and Expo both have an `ActionSheet` component; it''s advisable
    to use the one from Expo as it will use the native `UIActionSheet` component on
    iOS and a JavaScript implementation for Android. The `ActionSheet` component is
    available from Expo''s `react-native-action-sheet` package, which you can install
    from `npm`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'After this, you need to wrap your top-level component in the `client/App.js` file with
    `Provider` from the package, which is comparable to adding `ApolloProvider`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'And create `ActionSheet` in `client/Screens/AddPost.js` by importing the `connectActionSheet` function
    from `react-native-action-sheet`, which needs to wrap the `AddPost` component before
    you export it. Wrapping the `AddPost` component with `connectActionSheet()` adds
    the `showActionSheetWithOptions` prop to the component, which you''ll use in the
    next step to create `ActionSheet`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'To add `ActionSheet`, a function to open this `ActionSheet` must be added,
    and by using the `showActionSheetWithOptions` prop and the options, `ActionSheet`
    should be constructed. The options are `Camera`, `Camera roll`, and `Cancel`,
    where selecting the first option should call the `addImageAsync` function with
    a parameter, the second should call that function without a parameter, and the
    last option is to close `ActionSheet`. The function to open `ActionSheet` must
    be added to the `getPermissionsAsync` function and be called when the permissions
    for both `Camera` and `Camera roll` are granted:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Tapping the image placeholder will give the user the option to either use `Camera`
    or `Camera roll` to add an image to the `AddPost` component. This can be done
    from `ActionSheet`, which will look different on iOS and Android. In the following
    screenshot, you can see what this will look like when using the iOS simulator
    or a device that runs on iOS:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/341ba1a8-17f2-4761-8fcf-b0f5e3d374ff.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This, however, is not all as the image must still be sent to the server to
    appear in the feed of the application, by adding a `useMutation` Hook from `@apollo/react-hooks`
    and using the returned `addPost` function to send the `imageUrl` variable in a
    document to the GraphQL server. The mutation to add the post has been mentioned
    at the beginning of this section and can be imported from the `client/constants.js` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The image will be added as a post after tapping the `Submit` button, and the
    user will be redirected to the `Main` screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'By setting a query on the `refetchQueries` variable to the `useMutation` Hook,
    the posts on the `Main` screen can be reloaded and the post you''ve just added
    will be displayed in this list. The posts can be retrieved by fetching the `GET_POSTS`
    query from `client/constants.js`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Your post will now be displayed at the top of the `Main` screen, meaning you've
    added the post successfully and other users can view, star, and comment on it.
    As your users might be sending posts while the application is opened, you want
    them to be able to receive these posts. Therefore, the next section will explore
    how to achieve near real-time data from GraphQL.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving near real-time data using GraphQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Other than with the messaging application, you don't want the feed with posts
    to reload every time a new post has been posted by any of the people in your network.
    Besides subscriptions, there are other ways to have (near) real-time data flows
    with GraphQL and Apollo, namely, polling. With polling, you can retrieve a query
    from a `useQuery` Hook once every `n` milliseconds, saving you the complexity
    of setting up subscriptions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Polling can be added to the `useQuery` Hook, like this one in `client/Screens/Posts.js`.
    By setting a `pollInterval` value on the object parameter from the `useQuery` Hook,
    you can specify how often the document with the `GET_POSTS` query should be resent
    by the Hook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This causes your `Posts` component to send a document with the `GET_POSTS` query every
    2 seconds (2,000 milliseconds), and as the GraphQL server is returning mocked
    data, the posts that are displayed will be different on every re-fetch. In comparison
    to subscriptions, polling will resend the documents to retrieve the posts even
    when there is no new data—something that isn't very useful for an application
    displaying mock data or data that changes often.
  prefs: []
  type: TYPE_NORMAL
- en: Next to setting a `pollInterval` variable on the `useQuery` Hook, you can also
    manually call the `refetch` function that sends a document with the query. A common
    interaction for social media feeds is being able to pull down the displayed component
    to refresh the data on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'This pattern can also be added to your application by making the following
    changes to the `Posts` screen component:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `pollInterval` prop can be set to `0`, which disables the polling for now.
    Besides the `loading` and `data` variables, more variables can be retrieved from
    the `useQuery` Hook. One of those variables is the `refetch` function, which you
    can use to manually send the document to the server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'There''s a React Native component to create the pull-to-refresh interaction,
    which is called `RefreshControl` and which you should import from `react-native`.
    Also, you should import a `ScrollView` component as the `RefreshControl` component
    only works with either a `ScrollView` or `ListView` component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This `ScrollView` component should be wrapped around the `PostsList` component,
    which is a styled `FlatList` component that iterates over the posts created by
    the GraphQL server. As a value for the `refreshControl` prop, the `RefreshControl`
    component must be passed to this `ScrollView` and a `style` prop must be set,
    to lock the width to 100%, which makes sure you can only scroll vertically:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'If you now pull down the `Posts` screen, a loading indicator will be displayed
    at the top of the screen that keeps spinning. With the `refreshing` prop, you
    can control whether or not the loading indicator should be displayed by passing
    a value that is created by a `useState` Hook. Besides a `refreshing` prop, the
    function that should be called when the refreshing starts can be passed to the
    `onRefresh` prop. You should pass the `refetch` function to this function, which
    should set the `refreshing` state variable to `true` and call the `refetch` function
    that was returned by the `useQuery` Hook. After the `refetch` function resolves,
    the callback can be used to set the `refreshing` state to `false` again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, when you pull down the `Posts` screen, the loading message returned
    from the `useQuery` Hook interferes with the loading indicator from `RefreshControl`.
    By also checking for the value of `refreshing` in the if-else statement, you can
    prevent this behavior:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'After these last changes, the interaction of pulling to refresh the data is
    implemented for the `Posts` screen, making it possible for your users to retrieve
    the latest data by pulling down the screen. When you''re using iOS as the operating
    system for the virtual or physical device that runs the application, this will
    look something like this screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/b87269bb-aa38-4ac7-b0ee-9295ac618b14.png)'
  prefs: []
  type: TYPE_IMG
- en: In the next section, you'll add notifications to this social media application,
    by using Expo and GraphQL servers.
  prefs: []
  type: TYPE_NORMAL
- en: Sending notifications with Expo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another important feature for a mobile social media application is the ability
    to send users notifications of important events, for example, when their post
    gets starred or a friend has uploaded a new post. Sending notifications can be
    done with Expo and requires you to add both server- and client-side code, as the
    notifications are sent from the server. The client needs to retrieve a local identifier
    for the users' device, which is called the Expo push code. This code is needed
    to identify which device belongs to the user and how a notification should be
    sent to either iOS or Android.
  prefs: []
  type: TYPE_NORMAL
- en: Testing notifications can only be done by using the Expo application on your
    mobile device. iOS and Android simulators cannot receive push notifications, as
    they don't run on an actual device.
  prefs: []
  type: TYPE_NORMAL
- en: 'Retrieving the push code is the first step in sending notifications to your
    users, which consists of the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To be able to send notifications, users should permit your application to push
    these notifications. To ask for this permission, the same permissions API should
    be used to get permission for the camera. The function to request this permission
    can be added in a new file called `registerForPushNotificationsAsync.js`. This
    file must be created in the new `client/utils` directory, in which you can paste
    the following code that also retrieves the push code using the Notifications API:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'When you''re using an iOS device, the `registerForPushNotificationAsync` function
    should be called when the application opens, as you should ask for permission.
    On Android devices, the request for whether or not a user wants you to send them
    notifications is sent during the installation process. This function should, therefore,
    be fired when the user opens the application, after which this function will return
    the Expo push token on Android or launch the popup to ask for permission on iOS.
    As you only want to ask registered users for their token, this is done in the
    `client/Screens/Posts.js` file by using an `useEffect` Hook:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'If you see this error, `Error: The Expo push notification service is supported
    only for Expo projects. Ensure you are logged in to your Expo developer account
    on the computer from which you are loading your project.`*,* it means you need
    to make sure you''re logged in to your Expo developer account. By running `expo
    login` from the Terminal, you can check whether you''re logged in and otherwise,
    it will prompt you to log in again.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Terminal, the Expo push token for this user will now be displayed, which
    looks like `ExponentPushToken[AABBCC123]`. This token is unique for this device
    and can be used to send the notification. To test how a notification will look,
    you can go to the `https://expo.io/dashboard/notifications` URL in the browser
    to find the Expo dashboard. In here, you can enter the Expo push token together
    with a message and a title for the notification; depending on the mobile operating
    system, there are different options you can select, such as the ones that follow:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/ff6cbf7e-aa70-4994-82ac-ba1bed1205d8.png)'
  prefs: []
  type: TYPE_IMG
- en: This will send a notification to your device, with the title `Test` and the
    body `This is a test`, and try to play a sound when the notification is sent.
  prefs: []
  type: TYPE_NORMAL
- en: However, this notification won't be visible on devices running on iOS when the
    application is foregrounded. So, when you're using the Expo application on an
    Apple device, make sure the Expo application is running in the background.
  prefs: []
  type: TYPE_NORMAL
- en: The next part of this section will show how you can also receive notifications
    when the application is running in the foreground.
  prefs: []
  type: TYPE_NORMAL
- en: Handling foreground notifications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Handling notifications when the application is foregrounded is more complex,
    and requires us to add a listener that checks for new notifications and afterward,
    these notifications should be stored somewhere. Expo's Notifications API has a
    listener available that can help you to check for new notifications, while the
    notifications can be stored using Apollo by having a local state. This local state
    extends the data returned by the GraphQL server by adding any new notifications
    that were found by the listener.
  prefs: []
  type: TYPE_NORMAL
- en: When the notifications are stored in the local state, this data can be queried
    and shown in either a component or a screen in your application. Let's create
    a notifications screen that will display these notifications that were sent when
    the application was loaded in the foreground.
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding the support for foreground notifications requires you to make these
    changes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The setup for Apollo Client in `client/App.js` should be extended in a way
    that you could query for notifications and can add new notifications when these
    are spotted by the listener. A new type for `Query` should be created that is
    called `notifications` and returns a list of the `Notification` type. Also, an
    initial value for this `Query` must be added in the form of an empty array that
    will be written to `cache`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you''re able to send a document with the query to retrieve the list of
    notifications including the `id`, `title`, and `body` fields. This query must
    also be defined in the `client/constants.js` file so it can be used from a `useQuery` Hook
    in the next step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `client/Screens` directory, the `Notifications.js` file can be found,
    which must be used as the screen to display the notifications for the user. This
    screen component should be imported in the `client/AppContainer.js` file where
    a new `StackNavigator` object must be created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'After `StackNavigator` for the `Notifications` screen is created, it needs
    to be added to `TabNavigator` so it will be displayed next to the `Posts` and
    `Settings` screens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Notifications` screen is now being displayed in `TabNavigator` and displays
    the text Empty! as there aren''t any notifications to display. To add any notifications
    that have been sent to the user, you need to create a local resolver for the GraphQL
    client. This local resolver will be used to create `Mutation`, which can be used
    to add any new notifications to the local state. You create the local resolver
    by adding the following code to `client/App.js`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This will create the `addNotification` mutation, which takes the `id`, `title`,
    and `body` variables and adds these values to the data for the `Notification`
    type. The notifications that are currently in the local state are requested using
    the `GET_NOTIFICATIONS` query that you created before. By calling the `query` function
    on the GraphQL `client` constant, you send the document containing this query
    to the server. Together with the notification that has been sent together with
    a document containing the mutation, these will be written to the local state by
    `cache.writeData`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This mutation must be added to the `client/constants.js` file, where the other
    GraphQL queries and mutations are also placed. It''s important to also add that `client`
    should be used to resolve this mutation, by using the `@client` tag:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the listener from the `Notifications` API is added to the `client/App.js` file,
    which will look for new notifications when the application is foregrounded. New
    notifications are added to the local state using the preceding mutation from `client/constants.js`.
    The `mutate` function that is called on the client will use the information from
    the Expo notification and adds this to mutation; the mutation will make sure it''s
    added to the local state by writing this information to `cache`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code block, you cannot use the `useMutation` Hook to send the
    `ADD_NOTIFICATION` mutation in a document, as React Apollo Hooks can only be used
    from a component nested within `ApolloProvider`. Therefore, the `mutate` function
    on the `client` object is used, which also provides the functionality to send
    documents with queries and mutations without using a `Query` or `Mutation` component.
  prefs: []
  type: TYPE_NORMAL
- en: 'By importing the `Notifications` API from Expo, the `handleNotification` function
    can access the data object from the notification that was sent. This data object
    is different from the message title and message body you''ve sent using the Expo
    dashboard, therefore you need to also add JSON data when sending the notification
    from `https://expo.io/dashboard/notifications`. A test notification can be sent
    by adding the body in the form:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/4a6c73cf-01ef-4ed0-bc50-809452135e25.png)'
  prefs: []
  type: TYPE_IMG
- en: By submitting the form, a notification with the title `Test` and the body `This
    is a test` will be sent to the user when the application is foregrounded, but
    also when the application is running in the background.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a mobile application that is running in production, you''d expect the notifications
    to be sent from the GraphQL server instead of the Expo dashboard. The local GraphQL
    server that is handling the data flow for this application is already configured
    to send notifications to the user but would need the user''s Expo push token to
    send. This token should be stored in the server and linked to the current user,
    as this token is unique for this device. The token should be sent in a document
    to the GraphQL server from a mutation that would take the token and can get information
    about the user from the headers in the mutation:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, the mutation that will store the Expo push token on the GraphQL server
    must be created in the `client/constants.js` file along with the other queries
    and mutations. The only variable this mutation takes is the push token, as the
    OAuth token that is sent with every document to the GraphQL server is used to
    identify the user:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Sending the document with this mutation with the Expo push token must be done
    from the `client/Posts.js` file where the token is retrieved by calling the `registerForPushNotificationsAsync` function.
    This function will return the push token, which you can send along with the mutation''s
    document. To send this document, the `useMutation` Hook from `@apollo/react-hooks`
    can be used, which you must import together with the `STORE_EXPO_TOKEN` constant:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Before React Apollo Hooks were available, it was complicated to use a mutation
    without the usage of a `Mutation` component, as sending mutations was only possible
    from the `client` object or the `Mutation` component. Accessing the `client` object
    from a React component is possible by importing an `ApolloConsumer` component
    that can read the client value from `ApolloProvider` that wraps your application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `useMutation` Hook can now be called with the `STORE_EXPO_TOKEN` mutation
    with `expoToken` from `registerForPushNotificationsAsync` as a parameter, which
    returns a function to store the token called `storeExpoToken`. This function can
    be called from the callback of the asynchronous `registerForPushNotificationsAsync` function
    with the token as a variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: This Expo push token will be sent to the GraphQL server whenever the `Posts`
    screen gets mounted, something you can force by switching between the `AddPosts`
    and `Posts` screens, for example. When the content of the `Posts` screen gets
    requested from the GraphQL server, the server will send a random notification
    to your application, which you can view from the `Notifications` screen. Also,
    you're still able to send any notification from the Expo dashboard, both when
    the application is in the foreground or the background.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you've created a mobile social media application with React
    Native and Expo that uses a GraphQL server to send and receive data as well for
    authentication. Using Expo, you've learned how to have the application request
    access to use the device's camera or camera roll to add new photos to posts. Also,
    Expo is used to receive notifications from the Expo dashboard or the GraphQL server.
    These notifications will be received by the user no matter whether the application
    is running on the back- or foreground.
  prefs: []
  type: TYPE_NORMAL
- en: In completing this social media application, you've completed the final React
    Native chapter of this book and are now ready to start with the very last chapter. In
    this last chapter, you'll be exploring another use case of React, which is React
    360\. With React 360, you can create 360-degree 2D and 3D experiences by writing
    React components.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Expo camera: [https://docs.expo.io/versions/latest/sdk/camera/](https://docs.expo.io/versions/latest/sdk/camera/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Notifications: [https://docs.expo.io/versions/v33.0.0/sdk/notifications/](https://docs.expo.io/versions/v33.0.0/sdk/notifications/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
