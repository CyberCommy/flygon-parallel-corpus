- en: Behaving Properly - Pure Functions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 3](89a2ff2f-a67d-4a21-a2f5-cd54bed7198a.xhtml), *Starting Out with
    Functions - A Core Concept*, we considered functions as the key elements in FP,
    went into detail about arrow functions, and introduced some concepts such as injection,
    callbacks, polyfilling, and stubbing. Now, in this chapter, we'll have the opportunity
    to revisit or apply some of those ideas, while we also...
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Consider the notion of *purity*, and why we should care about *pure functions*
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examine the concept of *Referential Transparency*
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recognize the problems implied by side effects
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Show some advantages of pure functions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Describe the main causes of impure functions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Find ways to minimize the number of impure functions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Focus on ways of testing both pure and impure functions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pure functions
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Pure functions behave in the same way as mathematical functions and provide
    diverse benefits. A function may be considered to be pure if it satisfies two
    conditions:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '**Given the same arguments, the function always calculates and returns the
    same result**, no matter how many times it''s invoked, or in which conditions
    you call it. This result value cannot depend on any *outside*information or state,
    which could change during the program execution, and cause it to return a different
    value. Nor can the function result depend on I/O results, random numbers, or some
    other external variable, not directly controllable, value.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**When calculating its result, the function doesn''t cause any observable *side
    effect***, including output to I/O devices, mutation of objects, change to program
    state outside of the function, and so on.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you want, you can simply say that pure functions don't depend on, and don't
    modify, anything outside its scope, and do always return the same result for the
    same input arguments.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Another word used in this context is *idempotency*, but it's not exactly the
    same. An idempotent function can be called as many times as desired, and will
    always produce the same result. However, this doesn't imply that the function
    is free from side effects. Idempotency is usually mentioned in the context of
    RESTful services, and a simple example showing the difference between purity and
    idempotency follows. A `PUT` call would cause a database record to be updated
    (a side effect) but if you repeat the call, the element will not be further modified,
    so the global state of the database won't change any further.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: We might also invoke a software design principle, and remind ourselves that
    a function should *do one thing, only one thing, and nothing but that thing*.
    If a function does anything else, and has some hidden functionality, that dependency
    on the state will mean that we won't be able to predict the function's output
    and make things harder for us as developers.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Let's get into these conditions in more detail.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Referential Transparency
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In mathematics, *Referential Transparency* is the property that lets you replace
    an expression with its value, and not change the results of whatever you were
    doing.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: The counterpart of *Referential Transparency*is, appropriately enough, *Referential
    Opacity*. A referentially opaque function cannot guarantee always producing the
    same result, even when called with the same arguments.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: 'To give a simple example, when an optimizing compiler decides to do *constant
    folding* and replace a sentence like:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'with:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'or, even better, directly with:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: to save execution time, it's taking advantage of the fact that all mathematical
    expressions and functions are (by definition) referentially transparent.  On the
    other hand, if the compiler cannot predict the output of a given expression, it
    won't be able to optimize the code in any fashion, and the calculation will have
    to be done at runtime.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: In lambda calculus, if you replace the value of an expression involving a function,
    with the calculated value for the function, that operation is called a β (beta)
    reduction. Note that you can only do this safely with referentially transparent
    functions.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在λ演算中，如果你用函数的计算值替换涉及函数的表达式的值，这个操作被称为β（beta）规约。请注意，你只能安全地对引用透明的函数进行这样的操作。
- en: 'All arithmetic expressions (involving both mathematical operators and functions)
    are referentially transparent: *22*9* can always be replaced by 198\. Expressions
    involving I/O are not transparent, given that their results cannot be known until
    they are executed. For the same reason, expressions involving date- and time-related
    functions, or random numbers, are also not transparent.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 所有算术表达式（涉及数学运算符和函数）都是引用透明的：*22*9*总是可以被198替换。涉及I/O的表达式不是透明的，因为它们的结果在执行之前无法知道。出于同样的原因，涉及日期和时间相关函数或随机数的表达式也不是透明的。
- en: With regard to JS functions, you may produce yourself, it's quite easy to write
    some that won't fulfill the *referential transparency*condition. In fact, a function
    is not even required to return a value, though the JS interpreter will return
    an undefined value in that situation.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 关于JS函数，你可能会自己编写一些不满足*引用透明*条件的函数。事实上，函数甚至不需要返回一个值，尽管JS解释器会在这种情况下返回一个未定义的值。
- en: Some languages distinguish between functions, which are expected to return some
    value, and procedures, which do not return anything, but that's not the case with
    JS. Also, there are some languages that provide means to ensure that functions
    are referentially transparent.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 有些语言区分函数和过程，预期函数返回某个值，而过程不返回任何东西，但JS不是这种情况。此外，有些语言提供手段来确保函数是引用透明的。
- en: 'If you wanted to, you could classify JS functions as:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意的话，你可以将JS函数分类为：
- en: '**pure functions**: that return a value depending only on its arguments, and
    have no side effects whatsoever'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**纯函数**：它们根据其参数返回一个值，并且没有任何副作用'
- en: '**side effects**: that don''t return anything (actually, JS has those functions
    return an `undefined` value, but that''s not relevant here), but do produce some
    kind of side effects'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**副作用**：它们不返回任何东西（实际上，JS让这些函数返回一个`undefined`值，但这在这里并不重要），但会产生某种副作用'
- en: '**functions with side effects**: meaning they return some value (which may
    not only depend on the function arguments and also involve side effects)'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**具有副作用的函数**：意味着它们返回一些值（这些值可能不仅取决于函数参数，还涉及副作用）'
- en: In FP, much emphasis is put upon the first group, referentially transparent
    functions. Not only a compiler can reason about the program behavior (and thus
    be enabled to optimize the generated code), but also the programmer can more easily
    reason about the program and the relationship between its components. In turn,
    this can help prove the correctness of an algorithm, or to optimize the code by
    replacing a function with an equivalent one.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在FP中，非常强调第一组引用透明函数。不仅编译器可以推断程序行为（从而能够优化生成的代码），而且程序员也可以更容易地推断程序和其组件之间的关系。反过来，这可以帮助证明算法的正确性，或者通过用等效函数替换一个函数来优化代码。
- en: Side effects
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 副作用
- en: What are *side effects*? We can define those as some change in state, or some
    interaction with outside elements (the user, a web service, another computer,
    whatever) that occurs during the execution of some calculations or process.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是*副作用*？我们可以将其定义为在执行某些计算或过程期间发生的状态变化或与外部元素（用户、网络服务、另一台计算机等）的交互。
- en: There's a possible misunderstanding as to the scope of this meaning. In common
    daily speech, when you speak of *side effects*, it's a bit like talking of *collateral
    damage*--some *unintended* consequences for a given action. However, in computing,
    we include every possible effect or change outside the function. If you write
    a function that is meant to do a `console.log()` call to display some result,
    that would be considered a side effect, even if it's exactly what you intended
    the function to do in the first place!
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个意义的范围可能存在一些误解。在日常语言中，当你谈论*副作用*时，这有点像谈论*附带损害*--对于给定行动的一些*意外*后果。然而，在计算中，我们包括函数外的每一个可能的效果或变化。如果你编写一个旨在执行`console.log()`调用以显示一些结果的函数，即使这正是你首先打算让函数执行的，它也会被视为副作用！
- en: Usual side effects
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通常的副作用
- en: 'There are (too many!) things that are considered side effects. In JS programming,
    including both front- and back-end coding, the more common ones you may find,
    include:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 有（太多！）被认为是副作用的事情。在JS编程中，包括前端和后端编码，你可能会发现更常见的副作用包括：
- en: Changing global variables.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改变全局变量。
- en: Mutating objects received as arguments.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改变接收的对象。
- en: Doing any kind of I/O, such as showing an alert message or logging some text.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进行任何类型的I/O，比如显示警报消息或记录一些文本。
- en: Working with, and changing, the filesystem.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理和更改文件系统。
- en: Updating a database.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新数据库。
- en: Calling a web service.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用网络服务。
- en: Querying or modifying the DOM.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询或修改DOM。
- en: Triggering any external process.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 触发任何外部进程。
- en: 'And, finally, just calling some other function that happens to produce a side
    effect of its own. You could say that impurity is contagious: a function that
    calls an impure function automatically becomes impure on its own!'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，只是调用一些其他函数，这些函数恰好会产生自己的副作用。你可以说不纯度是具有传染性的：调用不纯的函数的函数会自动变得不纯！
- en: With this definition, let's start considering what can cause functional impurity
    (or *referential opaqueness*, as we saw).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个定义，让我们开始考虑什么会导致函数不纯（或者*引用不透明*，正如我们所看到的）。
- en: Global state
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 全局状态
- en: 'Of all the preceding points, the most common reason is the usage of non-local
    variables, sharing a global state with other parts of the program. Since pure
    functions, by definition, always return the same output value given the same input
    arguments, if a function refers to anything outside its internal state, it automatically
    becomes impure. Furthermore, and this is a hindrance to debugging, to understand
    what a function did, you must understand how the state got its current values,
    and that means understanding all the past history from your program: not easy!'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有前述观点中，最常见的原因是使用非本地变量，与程序的其他部分共享全局状态。由于纯函数根据定义，始终返回相同的输出值，给定相同的输入参数，如果函数引用其内部状态之外的任何东西，它就会自动变得不纯。此外，这对于调试是一个障碍，要理解函数的作用，你必须了解状态如何得到其当前值，这意味着要理解程序的所有过去历史：这并不容易！
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `isOldEnough()`function correctly detects if a person is at least 18 years
    old, but it depends on an external variable for that (the variable is good for
    2017 only). You cannot tell what the function does, unless you know about the
    external variable, and how it got its value. Testing would also be hard; you'd
    have to remember creating the global `limitYear` variable, or all your tests would
    fail to run. Even though the function works, the implementation isn't the best
    possible.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`isOldEnough()`函数正确检测一个人是否至少18岁，但它依赖于一个外部变量（该变量仅适用于2017年）。除非你知道外部变量及其值是如何得到的，否则你无法知道函数的作用。测试也很困难；你必须记住创建全局`limitYear`变量，否则所有的测试都将无法运行。尽管函数可以工作，但实现并不是最佳的。'
- en: 'There is an exception to this rule. Check out the following case: is the `circleArea` function,
    which calculates the area of a circle given its radius, pure or not?'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这个规则有一个例外。看看下面的情况：`circleArea`函数，它根据半径计算圆的面积，是纯的还是不纯的？
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Even though the function is accessing an external state, the fact that `PI`
    is a constant (and thus cannot be modified) would allow substituting it inside
    `circleArea` with no functional change, and so we should accept that the function
    is pure. The function will always return the same value for the same argument,
    and thus fulfills our purity requirements.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管函数正在访问外部状态，但`PI`是一个常数（因此不能被修改），允许在`circleArea`中替换它而不改变功能，因此我们应该接受函数是纯净的。对于相同的参数，函数将始终返回相同的值，因此满足我们的纯度要求。
- en: Even if you were to use `Math.PI` instead of a constant as we defined (a better
    idea, by the way) the argument would still be the same; the constant cannot be
    changed, so the function remains pure.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你使用`Math.PI`而不是我们定义的常数（顺便说一句，这是一个更好的主意），参数仍然是相同的；常数是不能改变的，所以函数保持纯净。
- en: Inner state
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内部状态
- en: 'The notion is also extended to internal variables, in which a local state is
    stored, and then used for future calls. In this case, the external state is unchanged,
    but there are side effects that imply future differences as to the returned values
    from the function. Let''s imagine a `roundFix()` rounding function, that takes
    into account if it has been rounding too much upwards or downwards, so next time
    it will round the other way, to make the accumulated difference closer to zero:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这个概念也适用于内部变量，其中存储了本地状态，然后用于将来的调用。在这种情况下，外部状态没有改变，但是有一些副作用意味着未来从函数返回的值会有所不同。让我们想象一个`roundFix()`四舍五入函数，它考虑到是否已经过多地向上或向下四舍五入，所以下次它将以另一种方式四舍五入，使累积差异更接近零：
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Some comments regarding this function:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个函数的一些评论：
- en: 'The `console.log()` line is just for the sake of this example; it wouldn''t
    be included in the real-world function. It lists the accumulated difference up
    to the point, and the result it will return: the given number rounded up or down.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`console.log()`行只是为了这个例子; 它不会包含在真实世界的函数中。它列出了到目前为止的累积差异，以及它将返回的结果：给定数字四舍五入的结果。'
- en: We are using the IIFE pattern that we saw in the `myCounter()` example, in the *Immediate
    Invocation* section of [Chapter 3](89a2ff2f-a67d-4a21-a2f5-cd54bed7198a.xhtml),
    *Starting Out with Functions - A Core Concept*, in order to get a hidden internal
    variable.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们正在使用IIFE模式，这是我们在“myCounter()”示例中看到的，在[第3章](89a2ff2f-a67d-4a21-a2f5-cd54bed7198a.xhtml)的*立即调用*部分，*从函数开始-核心概念*，以便获得隐藏的内部变量。
- en: 'The `nRounded` calculation could also be written as`Math[accum > 0 ? "ceil":
    "floor"](n)` -- we test `accum` to see what method to invoke (`"ceil"` or `"floor"`)
    and then use the `Object["method"]` notation to indirectly invoke `Object.method()`.
    The way we used it, I think, is more clear, but I just wanted to give you a heads
    up in case you happen to find this other coding style.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nRounded`的计算也可以写成`Math[accum > 0 ? "ceil": "floor"](n)`--我们测试`accum`来看要调用什么方法（“ceil”或“floor”），然后使用`Object["method"]`表示法间接调用`Object.method()`。我们使用的方式更清晰，但我只是想提醒你，如果你碰巧发现这种其他编码风格。'
- en: 'Running this function with just two values (recognize them?) shows that results
    are not always the same for a given input. The *result* part of the console log
    shows how the value got rounded, up or down:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 仅使用两个值（认出它们吗？）运行此函数显示，对于给定的输入，结果并不总是相同。控制台日志的*结果*部分显示了值是如何四舍五入的，向上还是向下：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The first time around, `accum` is zero, so 3.14159 gets rounded down, and `accum`
    becomes `0.14159` in our favor. The second time, since `accum` is positive (meaning
    we have been rounding in our favor) then 2.71828 gets rounded up to 3, and now
    `accum` becomes negative. The third time, the same 2.71828 value gets rounded
    down to 2, because then the accumulated difference was negative; we got different
    values for the same input! The rest of the example is similar; you can get a same
    value rounded up or down, depending on the accumulated differences, because the
    function's result depends on its inner state.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次，`accum`是零，所以3.14159被舍入，`accum`变成了`0.14159`，对我们有利。第二次，因为`accum`是正数（意味着我们一直在我们的利益上四舍五入），所以2.71828被舍入为3，现在`accum`变成了负数。第三次，相同的2.71828值被舍入为2，因为累积的差值是负的；我们得到了相同输入的不同值！其余的例子类似；你可以得到相同的值被舍入为上或下，取决于累积的差异，因为函数的结果取决于它的内部状态。
- en: This usage of internal state, is why many FPers consider that using objects
    is potentially bad. In OOP, we developers are used to storing information (attributes)
    and using them for future calculations. However, this usage is considered impure,
    insofar repeated method calls may return different values, despite the same arguments
    being passed.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这种使用内部状态的方式，是为什么许多FPers认为使用对象可能是不好的。在OOP中，我们开发人员习惯于存储信息（属性）并将它们用于未来的计算。然而，这种用法被认为是不纯的，因为尽管传递相同的参数，重复的方法调用可能返回不同的值。
- en: Argument mutation
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参数突变
- en: 'You also need to be aware of the possibility that an impure function will modify
    its arguments. In JS, arguments are passed by value, except in the case of arrays
    and objects, which are passed by reference. This implies that any modification
    to the parameters of the function, will effect an actual modification of the original
    object or array. This can be furthermore obscured by the fact that there are several
    *mutator* methods, that change the underlying objects by definition. For example,
    say you wanted a function that would find the maximum element of an array of strings
    (of course, if it were an array of numbers, you could simply use `Math.max()`
    with no further ado). A short implementation could be as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要意识到一个不纯的函数可能会修改它的参数。在JS中，参数是按值传递的，除了数组和对象，它们是按引用传递的。这意味着对函数参数的任何修改都会影响原始对象或数组的实际修改。这可能会更加模糊，因为有几种*mutator*方法，它们根据定义改变了底层对象。例如，假设你想要一个函数，它会找到一个字符串数组的最大元素（当然，如果它是一个数字数组，你可以简单地使用`Math.max()`而无需进一步操作）。一个简短的实现可能如下所示：
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The function does provide the correct result (and if you worry about foreign
    languages, we already saw a way around that in the *Injection: Sorting it out* section of [Chapter
    3](89a2ff2f-a67d-4a21-a2f5-cd54bed7198a.xhtml), *Starting Out with Functions -
    A Core Concept*), but it has a defect:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数确实提供了正确的结果（如果你担心外语，我们已经在[第3章](89a2ff2f-a67d-4a21-a2f5-cd54bed7198a.xhtml)的*注入：解决问题*部分看到了解决方法，*从函数开始-核心概念*），但它有一个缺陷：
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Oops, the original array was modified; a side effect by definition! If you were
    to call `maxStrings(countries)` again, instead of returning the same result as
    before, it would produce another value; clearly, not a pure function. In this
    case, a quick solution is to work on a copy of the array (and we can use the spread
    operator to help), but we'll be dealing with more ways of avoiding these sort
    of problems in [Chapter 10](383f5538-72cc-420a-ae77-896776c03f27.xhtml), *Ensuring
    Purity - Immutability:*
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 糟糕的是，原始数组被修改了；这是根据定义的副作用！如果你再次调用`maxStrings(countries)`，而不是返回与之前相同的结果，它会产生另一个值；显然，这不是一个纯函数。在这种情况下，一个快速的解决方法是对数组的副本进行操作（我们可以使用扩展运算符来帮助），但我们将在[第10章](383f5538-72cc-420a-ae77-896776c03f27.xhtml)中处理更多避免这类问题的方法，*确保纯度-不可变性*：
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Troublesome functions
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 麻烦的函数
- en: 'Finally, some functions also cause problems. For instance, `Math.random()`
    is impure: it doesn''t always return the same value -- and it would certainly
    beat its purpose if it did! Furthermore, each call to the function modifies a
    global *seed*value, from which the next *random* value will be calculated.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一些函数也会引起问题。例如，`Math.random()`是不纯的：它不总是返回相同的值--如果它这样做了，它肯定会打破它的目的！此外，对该函数的每次调用都会修改全局*种子*值，从而计算下一个*随机*值。
- en: The fact that *random*numbers are actually calculated by an internal function,
    and thus not random at all (if you know the formula that's used, and the initial
    value of the seed) implies that *pseudorandom* would be a better denomination
    for them.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '*随机*数字实际上是由内部函数计算的，因此根本不是随机的（如果你知道使用的公式和种子的初始值），这意味着*伪随机*可能更合适。'
- en: 'For instance, consider this function that generates random letters (`"A"` to
    `"Z"`):'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑这个生成随机字母（`"A"`到`"Z"`）的函数：
- en: '[PRE10]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The fact that it receives no arguments, but is expected to produce *different*
    results upon each call, clearly points out that this function is impure.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数不接受任何参数，但是预期每次调用都会产生*不同*的结果，这清楚地表明这个函数是不纯的。
- en: Check [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/random](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/random)
    for the explanation for the `getRandomLetter()` function I wrote, and[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)
    for the `.charCodeAt()` method.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 查看我写的`getRandomLetter()`函数的解释，请访问[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/random](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/random)，以及[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)的`.charCodeAt()`方法。
- en: 'Impurity can be inherited by calling functions. If a function uses an impure
    function, it immediately becomes impure itself. We might want to use `getRandomLetter()` in
    order to generate random filenames, with an optional given extension:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 调用函数会继承不纯性。如果一个函数使用了不纯的函数，它立即变得不纯。我们可能想要使用`getRandomLetter()`来生成随机文件名，还可以选择给定的扩展名：
- en: '[PRE11]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In [Chapter 5](3cf24154-32aa-4bcd-bfbe-e9de8fe35096.xhtml), *Programming Declaratively
    - A Better Style*, we will see a more functional way of initializing array `namePart`,
    by using `map()`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](3cf24154-32aa-4bcd-bfbe-e9de8fe35096.xhtml)中，*声明式编程——更好的风格*，我们将看到一种更加函数式的初始化数组`namePart`的方法，使用`map()`。
- en: 'Because of its usage of `getRandomLetter()`, `getRandomFileName()` is also
    impure, though it performs as expected:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它使用了`getRandomLetter()`，`getRandomFileName()`也是不纯的，尽管它的表现如预期：
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Keep this function in mind; we'll see some ways around the unit testing problem
    later in this chapter, and we'll rewrite it a bit to help out with that.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 记住这个函数；我们稍后会在本章解决单元测试问题的一些方法，并稍作修改以帮助解决这个问题。
- en: 'The consideration about impurity also extends to functions that access the
    current time or date, because their results will depend on an outside condition
    (namely the time of the day) that is part of the *global state*of the application.
    We could rewrite our `isOldEnough()` function to remove the dependency upon a
    global variable, but it wouldn''t help much:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 对于访问当前时间或日期的函数，不纯性的考虑也适用，因为它们的结果将取决于外部条件（即一天中的时间），这是应用程序的*全局状态*的一部分。我们可以重写我们的`isOldEnough()`函数，以消除对全局变量的依赖，但这并没有太大帮助：
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'A problem has been removed --the new `isOldEnough2()`function is now *safer*.
    Also, as long as you don''t use it near midnight just before New Year''s Day,
    it will consistently return the same results, so you could say, paraphrasing the
    Ivory Soap slogan from the XIX century, that it''s *about 99.44% pure*. However,
    an inconvenience remains: how would you test it? If you were to write some tests
    that worked fine today, next year they''d start to fail. We''ll have to work a
    bit to solve this, and we''ll see how later on.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 一个问题已经被解决了——新的`isOldEnough2()`函数现在更加*安全*。此外，只要你不在新年前夕的午夜附近使用它，它将始终返回相同的结果，因此你可以说，用19世纪象牙皂的广告语来说，它是*约99.44%纯*。然而，一个不便仍然存在：你该如何测试它？如果你今天写了一些测试，明年它们可能会开始失败。我们将不得不努力解决这个问题，我们稍后会看到如何解决。
- en: 'Several other functions that also are impure are those that cause I/O. If a
    function gets input from some source (a web service, the user himself, a file,
    and so on), obviously the returned result may vary. You should also consider the
    possibility of an I/O error, so the very same function, calling the same service
    or reading the same file, might at some time fail, for reasons outside its control
    (you should assume that your filesystem, database, socket, and so on, could be
    unavailable, and thus a given function call might produce an error instead of
    the expected constant, unvarying, answer). Even a pure output, and generally safe,
    statement such as a `console.log()`, that doesn''t change anything internally
    (at least in a visible way) does cause some effects, because the user does see
    a change: the produced output.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他一些不纯的函数，比如那些引起I/O的函数。如果一个函数从某个来源获取输入（网络服务、用户本身、文件等），显然返回的结果可能会有所不同。你还应该考虑I/O错误的可能性，因此同一个函数，调用同一个服务或读取同一个文件，可能在某个时候失败，原因是超出了它的控制范围（你应该假设你的文件系统、数据库、套接字等可能不可用，因此给定的函数调用可能产生错误，而不是预期的恒定、不变的答案）。即使是一个纯输出的、通常安全的语句，比如`console.log()`，它在内部并不会改变任何东西（至少在可见的方式上），但它确实会产生一些影响，因为用户看到了变化：产生的输出。
- en: Does this imply that we won't ever be able to write a program that requires
    random numbers, handles dates, or does I/O, and also use pure functions? Not at
    all -- but it does mean that some functions won't be pure, and they will have
    some disadvantages that we will have to consider; we'll return to this in a bit.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这是否意味着我们永远无法编写需要随机数、处理日期或进行I/O的程序，并且还使用纯函数？一点也不——但这意味着有些函数不会是纯函数，它们会有一些我们需要考虑的缺点；我们稍后会回到这个问题。
- en: Advantages of pure functions
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 纯函数的优势
- en: The main advantage of using pure functions, derives from the fact that they
    don't have any side effects. When you call a pure function, you need not worry
    about anything, outside of which arguments you are passing to it. Also, more to
    the point, you can be sure that you cannot cause any problems or break anything
    else, because the function will only work with whatever you give it, and not with
    outside sources. But this is not their only advantage; let's see more.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 使用纯函数的主要优势，源于它们没有任何副作用。当你调用一个纯函数时，你不需要担心任何事情，除了你传递给它的参数。而且更重要的是，你可以确信你不会造成任何问题或破坏其他任何东西，因为函数只会处理你给它的东西，而不会处理外部来源。但这并不是它们唯一的优势；让我们看看更多。
- en: Order of execution
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行顺序
- en: 'Another way of looking at what we have been saying in this chapter, is the
    consideration that pure functions can be called *robust*. You know that their
    execution --in whichever order-- won''t ever have any sort of impact on the system.
    This idea may be extended further: you could evaluate pure functions in parallel,
    resting assured that results wouldn''t vary from what you would get in a single-threaded
    execution.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 从这一章中我们所说的另一个角度来看，纯函数可以被称为*健壮*的。你知道它们的执行——无论以哪种顺序——都不会对系统产生任何影响。这个想法可以进一步扩展：你可以并行评估纯函数，放心地得出结果不会与单线程执行中得到的结果有所不同。
- en: Unhappily, JS restricts us very much as to parallel programming. We may make
    do, in very restricted ways, with web workers, but that's about as far as it goes.
    For Node.js developers, the cluster module may help out, though it isn't actually
    an alternative to threads, and only lets you spawn multiple processes letting
    you use all available CPU cores. To sum it up, you don't get facilities such as
    Java's threads, for example, so parallelization isn't really an FP advantage in
    JS terms.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: 'When you work with pure functions, another consideration to keep in mind is
    that there''s no explicit need to specify the order in which they should be called.
    If you work with mathematics, an expression such as *f(2)+f(5)* is always the
    same as *f(5)+f(2)*; this is called the *commutative property*, by the way. However,
    when you deal with impure functions, that can be not true, as shown in the following
    code:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: With impure functions such as shown previously, you cannot assume that calculating
    *f(3)+f(3)* would produce the same result as *2*f(3)*, or that *f(4)-f(4)* would
    actually be zero; check it out! More common mathematical properties down the drain...
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Why should you care? When you are writing code, willingly or not, you are always
    keeping in mind those properties you learnt about, such as the commutative property.
    So, while you might think that both expressions should produce the same result,
    and code accordingly, with impure functions you may be in for a surprise, with
    hard-to-find bugs that are difficult to fix.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Memoization
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since the output of a pure function for a given input is always the same, you
    can cache the function results and avoid a possibly costly re-calculation. This
    process, which implies evaluating an expression only the first time, and caching
    the result for later calls, is called *memoization*.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: 'We will come back to this idea in [Chapter 6](9f36fbcb-da30-4a75-9b47-01cd3427633e.xhtml),
    *Producing Functions - Higher-Order Functions*, but let''s see an example done
    by hand. The Fibonacci sequence is always used for examples, because of its simplicity,
    and its hidden calculation costs. This sequence is defined as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: for *n*=0, *fib*(*n*)=0
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: for *n*=1, *fib*(*n*)=1
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: for *n*>1, *fib*(*n*)=*fib*(*n*-2)+*fib*(*n*-1)
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fibonacci's name actually comes from *filius Bonacci*, or *son of Bonacci*.
    He is best known for having introduced the usage of digits 0-9 as we know them
    today, instead of the cumbersome Roman numbers. He derived the sequence named
    after him as the answer to a puzzle involving rabbits!
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: 'If you do the numbers, the sequence starts with 0, then 1, and from that point
    onwards, each term is the sum of the two previous ones: 1 again, then 2, 3, 5,
    8, 13, 21, and so on. Programming this series by using recursion is simple --
    though we''ll revisit this example in [Chapter 9](0f9ddfc4-d3d9-40a9-941b-edbec62cc890.xhtml),
    *Designing Functions - Recursion*. The following code, a direct translation of
    the definition, will do:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If you really go for oneliners, you could also write `const fib = (n) => (n<=1)
    ? n : fib(n-2)+fib(n-1)`-- do you see why? But, more important... is it worth
    the loss of clarity?'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: 'If you try out this function for growing values of `n`, you''ll soon realize
    there is a problem, and computation starts taking too much time. For example,
    on my machine, these are some timings I took, measured in milliseconds -- of course,
    your mileage may vary. Since the function is quite speedy, I had to run calculations
    100 times, for values of `n` between 0 and 40. Even then, times for small values
    of `n` were really tiny; only from 25 onwards, I got interesting numbers. The
    chart (see Figure 4.1) shows an exponential growth, which bodes ill:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/e2ac008e-f09e-49d5-9d43-78a74620c31c.png)Figure 4.1: Calculation
    times for the fib() recursive function go up exponentially.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: 'If we draw a diagram of all the calls required to calculate `fib(6)`, you''ll
    notice the problem. Each node represents a call to calculate `fib(n)`: we just
    note the value of `n` in the node. Every call, except those for `n`=0 or 1, requires
    further calls; see Figure 4.2:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们绘制出计算`fib(6)`所需的所有调用的图表，你会注意到问题。每个节点代表计算`fib(n)`的调用：我们只在节点中记录`n`的值。除了`n`=0或1的调用外，每个调用都需要进一步的调用；参见图4.2：
- en: '![](assets/ccd25b95-8da3-4bc6-8d25-3eb16a5e4029.png)Figure 4.2: All the required
    calculations for fib(6) show lots of duplication'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/ccd25b95-8da3-4bc6-8d25-3eb16a5e4029.png)图4.2：计算fib(6)所需的所有计算显示出大量重复'
- en: 'The reason for the increasing delays becomes obvious: for example, the calculation
    for `fib(2)` was repeated on four different occasions, and `fib(3)` was itself
    calculated three times. Given that our function is pure, we could have stored
    the calculated values to avoid doing the numbers over and over again. A possible
    version would be as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 延迟增加的原因变得很明显：例如，`fib(2)`的计算在四个不同的场合重复进行，而`fib(3)`本身被计算了三次。鉴于我们的函数是纯函数，我们可以存储计算出的值，避免一遍又一遍地进行数字计算。可能的版本如下：
- en: '[PRE16]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Initially, the cache is empty. Whenever we need to calculate a value of `fib2(n)`,
    we check if it was already calculated before. If that''s not true, we do the calculation,
    but with a twist: instead of immediately returning the value, first we store it
    in the cache, and then we return it. This means that no calculation will be done
    twice: after we have calculated `fib2(n)` for a certain `n`, future calls will
    not repeat the procedure, and simply return the value that was already evaluated
    before.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，缓存是空的。每当我们需要计算`fib2(n)`的值时，我们都会检查它是否已经计算过。如果不是，我们进行计算，但有一个小变化：我们不会立即返回值，而是先将其存储在缓存中，然后再返回。这意味着不会重复进行计算：在我们为特定的`n`计算了`fib2(n)`之后，未来的调用将不会重复这个过程，而只是返回之前已经计算过的值。
- en: 'A couple of short notes:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 一些简短的注释：
- en: We memoizedthe function by hand, but we can do it with a higher-order function,
    and we'll see that later, in [Chapter 6](9f36fbcb-da30-4a75-9b47-01cd3427633e.xhtml),
    *Producing Functions - Higher-Order Functions*. It is perfectly possible to memoize a
    function, without having to change to rewrite it.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们手动进行了函数的记忆化，但我们可以使用高阶函数来实现，我们将在[第6章](9f36fbcb-da30-4a75-9b47-01cd3427633e.xhtml)中看到，*生成函数
    - 高阶函数*。完全可以对函数进行记忆化，而无需改写它。
- en: Using an global variable for the cache isn't a very good practice; we could
    have used an IIFE and a closure to hide cache from sight; do you see how? See
    the `myCounter()` example in the *Immediate invocation* section of [Chapter 3](89a2ff2f-a67d-4a21-a2f5-cd54bed7198a.xhtml),
    *Starting Out with Functions - A Core Concept*, to review how we'd do that.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用全局变量作为缓存不是一个很好的做法；我们可以使用IIFE和闭包来隐藏缓存；你看到了吗？在[第3章](89a2ff2f-a67d-4a21-a2f5-cd54bed7198a.xhtml)的*立即调用*部分中查看`myCounter()`示例，回顾我们如何做到这一点。
- en: Of course, you need not do this for every pure function in your program. You'd
    do this sort of optimization only for frequently called functions, that take a
    certain important time -- if it were otherwise, the added cache management time
    would end costing more than whatever you expected to save!
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你不需要为程序中的每个纯函数都这样做。你只会对频繁调用、需要花费重要时间的函数进行这种优化 - 如果情况不是这样的话，额外的缓存管理时间将会比你期望节省的时间更多！
- en: Self-documentation
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自我文档化
- en: Pure functions have another advantage. Since all the function needs to work
    with is given to it through its parameters, having no kind of hidden dependency
    whatsoever, when you read its source code, you have all you need to understand
    the function's objective.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 纯函数还有另一个优势。由于函数需要处理的一切都通过其参数给出，没有任何隐藏的依赖关系，所以当你阅读其源代码时，你已经拥有了理解函数目标所需的一切。
- en: 'An extra advantage: knowing that a function doesn''t access anything beyond
    its parameters, makes you more confident in using it, since you won''t be accidentally
    producing some side effect, the only thing the function will accomplish, is what
    you already learned through its documentation.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 额外的优势：知道一个函数不会访问除了其参数之外的任何东西，会让你更有信心使用它，因为你不会意外地产生一些副作用，函数将会完成的唯一事情，就是你已经通过文档学到的。
- en: Unit tests (which we'll be covering in the next section) also work as documentation,
    for they provide examples of what the function returns, when given certain arguments.
    Most programmers will agree that the best kind of documentation is full with examples,
    and each unit test can be considered such a sample case.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试（我们将在下一节中介绍）也可以作为文档，因为它们提供了在给定特定参数时函数返回的示例。大多数程序员都会同意，最好的文档是充满示例的，每个单元测试都可以被视为这样一个示例。
- en: Testing
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试
- en: Yet another advantage of pure functions --and one of the most important ones--
    has to do with unit testing. Pure functions have a single responsibility, producing
    their output in terms of their input. So, when you write tests for pure functions,
    your work is much simplified, because there is no context to consider and no state
    to simulate.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 纯函数的另一个优势 - 也是最重要的之一 - 与单元测试有关。纯函数只负责以其输入产生输出。因此，当你为纯函数编写测试时，你的工作会简化得多，因为不需要考虑上下文，也不需要模拟状态。
- en: You can simply focus on providing inputs and checking outputs, because all function
    calls can be reproduced in isolation, with independence from the *rest of the
    world*. We'll see more about testing pure and impure functions, later in this
    very chapter.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以简单地专注于提供输入和检查输出，因为所有函数调用都可以在与*世界其他部分*独立的情况下重现。我们将在本章后面更多地了解测试纯函数和不纯函数。
- en: Impure functions
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不纯函数
- en: If you decided to completely forego all kinds of side effects, your programs
    would only be able to work with hardcoded inputs... and wouldn't be able to show
    you the calculated results! Similarly, most web pages would be useless; you wouldn't
    be able to do any web services calls, or to update the DOM; you'd have static
    pages only. And, for server-side JS, your Node.JS code would be really useless,
    not being able to do any I/O...
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Reducing side effects is a good goal in FP, but we cannot go overboard with
    it! So, let's think how to avoid using impure functions, if possible, and how
    to deal with them if not, looking for the best possible way to contain or limit
    their scope.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding impure functions
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Earlier in this chapter, we saw the more common reasons for impure functions.
    Let's now consider how we can minimize their number, if doing away with all of
    them isn't really feasible.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding the usage of state
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With regard to the usage of global state --both getting and setting it-- the
    solution is well known. The key to this is:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: Provide whatever is needed of the global state to the function, as arguments
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the function needs to update the state, it shall not do it directly, but
    rather produce a new version of the state, and return it
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It will be the responsibility of the caller to take the returned state, if any,
    and update the global state
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is the technique that Redux uses for its reducers. The signature for a
    reducer is `(previousState, action) => newState` meaning that it takes a state
    and an action as parameters, and returns a new state as the result. Most specifically,
    the reducer is not supposed to simply change the `previousState`argument, which
    must remain untouched (we'll see more about this in [Chapter 10](383f5538-72cc-420a-ae77-896776c03f27.xhtml),
    *Ensuring Purity - Immutability*).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: 'With regard to our first version of the `isOldEnough()`function, that used
    a global `limitYear` variable, the change is simple enough: we just have to provide
    `limitYear` as a parameter for the function. With this change, it will become
    pure, since it will produce its result by only using its parameters. Even better,
    we should provide the current year, and let the function do the math, instead
    of forcing the caller to do so:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We'll have to change, obviously, all the calls to provide the needed `limitYear`
    argument (we could also use currying, as we will see in [Chapter 7](44b5eafa-dc7f-45e4-8b9e-9bb5bb9b02ec.xhtml),
    *Transforming Functions - Currying And Partial Application*). The responsibility
    of initializing the value of `limitYear` still remains outside of the function,
    as before, but we have managed to avoid a defect.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also apply this solution to our peculiar `roundFix()`function. As you
    recall, the function worked by accumulating the differences caused by rounding,
    and deciding whether to round up or down depending on the sign of that accumulator.
    We cannot avoid using that state, but we can split off the rounding part from
    the accumulating part. So, our original code (less comments and logging) would
    change from:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'to:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'How would you use this function? Initializing the accumulator, passing it to
    the function, and updating it afterwards, are now the responsibility of the caller
    code. You would have something like:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Note that:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '`accum` is now part of the global state of the application'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since `roundFix2()` needs it, the current accumulator value is provided in each
    call
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The caller is responsible for updating the global state, not `roundFix2()`
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note the usage of the destructuring assignment, in order to allow a function
    to return more than a value, and to easily store each one in a different variable.
    For more on this, check [https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: This new `roundFix2()`function is totally pure, and can be easily tested. If
    you want to hide the accumulator from the rest of the application, you could still
    use a closure as in other examples, but that would again introduce impurity in
    your code; your call!
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: Injecting impure functions
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If a function becomes impure because it needs to call some other function that
    is itself impure, a way around this problem is to inject the required function
    in the call. This technique actually provides more flexibility in your code and
    allows for easier future changes, as well as less complex unit testing.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider the random filename generator function that we saw earlier.
    The problematic part is its usage of `getRandomLetter()` to produce the filename:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'A way to solve this is replacing the impure function, with an injected external
    one:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, we have removed the inherent impurity from this function. If we care to
    provide a predefined pseudorandom function that actually returns fixed, known,
    values, we will be able to easily unit test this function; we''ll be seeing that
    in the following examples. The usage of the function will change, and we would
    have to write:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If this way bothers you, you may want to provide a  default value for the `randomLetterFunc` parameter,
    as with:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Or you may also solve this by partial application, as we'll be seeing in [Chapter
    7](44b5eafa-dc7f-45e4-8b9e-9bb5bb9b02ec.xhtml), *Transforming Functions - Currying
    and Partial Application*.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: This hasn't actually avoided the usage of impure functions. In normal use, you'll
    call `getRandomFileName()`providing it with the random letter generator we wrote,
    so it will behave as an impure function. However, for testing purposes, if you
    provide a function that returns predefined (that is, not random) letters, you'll
    be able to test it as if it were pure, much more easily.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: 'But what about the original problem function, `getRandomLetter()`? We can apply
    the same trick, and write a new version, like the following:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: For normal usage, `getRandomFileName()`would call `getRandomLetter()`without
    providing any parameters, which would imply that the called function would behave
    in its expected random ways. But if we want to test whether the function does
    what we wanted, we can run it with an injected function that will return whatever
    we decide, letting us test it thoroughly.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: This idea is actually very important and has a wide specter of application to
    other problems. For example, instead of having a function directly access the
    DOM, we may provide it with injected functions that would do that. For testing
    purposes, it would be simple to verify that the tested function actually does
    what it needs to do, without really interacting with the DOM (of course, we'd
    have to find some other way to test those DOM-related functions). This can also
    apply to functions that need to update the DOM, generate new elements, and do
    all sorts of manipulations, you just use some intermediary functions.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: Is your function pure?
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s end this section by considering an important question: can you ensure
    a function is actually pure? To show the difficulties of this task, we''ll go
    back to the simple `sum3()`function we saw in earlier chapters. Would you say
    that this function is pure? It certainly looks like it!'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Let's see, the function doesn't access anything but its parameters, doesn't
    even try to modify them (not that it could... or could it?), doesn't do any I/O
    or work with any of the impure functions or methods that we mentioned earlier...
    what could go wrong?
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: 'The answer has to do with checking your assumptions. For example, who says
    the arguments for this function should be numbers? You might say to yourself *OK,
    they could be strings... but the function would still be pure, wouldn''t it?*,
    but for an (assuredly evil!) answer to that, see the following code:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Observe the way we assigned a new function to the `x.valueOf` method, we are
    taking full advantage of the fact that functions are first-class objects. See
    the *An unnecessary mistake* section in [Chapter 3](89a2ff2f-a67d-4a21-a2f5-cd54bed7198a.xhtml),
    *Starting out with functions - A Core Concept*, to see more on this.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Well, `sum3()`ought to be pure... but it actually depends on whatever parameters
    you pass to it! You might console yourself thinking that surely no one would pass
    such arguments, but edge cases are usually where bugs reside. But you need not
    resign yourself to abandoning the idea of pure functions. Adding some type checking
    (TypeScript might come in handy) you could at least prevent some cases -- though
    JS won't ever let you be totally sure that your code is *always* pure!
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Testing - pure versus impure
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have seen how pure functions are conceptually better than impure ones, but
    we cannot set out on a crusade to vanquish all impurity from our code. First,
    no one can deny that side effects can be useful, or at least unavoidable: you
    will need to interact with the DOM or call a web service, and there are no ways
    to do it in a pure way. So, rather on bemoaning the fact that you have to allow
    for impurity, try to structure your code so you can isolate the impure functions,
    and let the rest of your code be the best possible.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: With this in mind, you'll have to be able to write unit tests for all kinds
    of functions, pure or impure. Writing unit tests for functions is different, as
    to its difficulty and complexity, when you deal with pure or impure functions.
    While coding tests for the former is usually quite simple and follows a basic
    pattern, the latter usually require scaffolding and complex setups. So, let's
    finish this chapter by seeing how to go about testing both types of functions.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: Testing pure functions
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Given the characteristics of pure functions that we have already described,
    most of your unit tests could be simply:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: Call the function with a given set of arguments
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Verify that the results match what you expected
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s start with a couple of simple examples. Testing the `isOldEnough()`function
    would have been more complex than needed for the version that required access
    to a global variable. On the other hand, the last version, `isOldEnough3()`, which
    didn''t require anything because it received two parameters, is simple to test:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Another of the pure functions we wrote is equally simple, but for a care about
    precision. If we test the `circleArea`function we must use the Jasmine `.toBeCloseTo()`matcher,
    which allows for approximate equality, when dealing with floating point numbers.
    Other than that, tests are just about the same: call the function with known arguments,
    and check the expected results:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'No difficulty whatsoever! The test run reports success for both suites (see
    Figure 4.3):'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/aa0a1952-14ab-403c-a802-19ad03979492.png)Figure 4.3: A successful
    test run for a pair of simple pure functions'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: So, we don't have to worry about pure functions, so let's move on to the impure
    ones we dealt with by transforming them into pure equivalents.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Testing purified functions
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we considered the `roundFix` special function, which required using state
    to accumulate the differences due to rounding, we produced a new version by providing
    the current state as an added parameter, and by having the function return two
    values: the rounded one, and the updated state:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This function is now pure, but testing it requires validating not only the
    returned values but also the updated states. We can base our tests on the experiments
    we did previously. Once again, we have to use `toBeCloseTo()` for dealing with
    floating point numbers but we can use `toBe()` with integers, which produce no
    rounding errors:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We took care to include several cases, with positive, zero, or negative accumulated
    differences and checking if it rounded up or down on each occasion. We could certainly
    go further, by rounding negative numbers, but the idea is clear: if your function
    takes the current state as a parameter, and updates it, the only difference with
    the pure functions tests are that you will also have to test whether the returned
    state matches your expectations.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: Let's now consider the alternative way of testing, for our pure `getRandomLetter()`variant;
    let's call it `getRandomLetter2()`. This is simple; you just have to provide a
    function that will itself produce *random* numbers. (This kind of function, in
    testing parlance, is called a *stub*). There's no limit to the complexity of a
    stub, but you'll want to keep it simple.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Wecan then do some tests, based on our knowledge of the workings of the function,
    to verify that low values produce an `A`, values close to 1 produce a `Z`, so
    we can have a little confidence that no extra values are produced. Also, a middle
    value (around 0.5) should produce a letter around the middle of the alphabet.
    However, keep in mind that this kind of test is not very good; if we substituted
    an equally valid `getRandomLetter()` variant, it might be the case that the new
    function could work perfectly well, but not pass this test, because of a different
    internal implementation!
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Testing our filename generator can be done in a similar way, by using stubs.
    We can provide a simple stub that will return the letters of `"SORTOFRANDOM"`
    in sequence (this function is quite impure; see why?). So, we can verify that
    the returned filename matches the expected name, and a couple more properties
    of the returned filename, such as its length and its extension:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Testing *purified*impure functions is very much the same as testing originally
    pure functions. Now, we'll have to consider some cases of truly impure functions,
    because, as we said, it's quite certain that at some time or another, you'll have
    to use such functions.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: Testing impure functions
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For starters, we'll go back to our `getRandomLetter()`function. With insider
    knowledge about its implementation (this is called *white box testing*, in opposition
    to *black box testing*, in which we know nothing about the function code itself)
    we can *spy*(a Jasmine term) on the `Math.random()`method, and set a *mock* function
    that will return whatever values we desire.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: 'We can revisit some of the test cases we did in the previous section. In the
    first case, we set `Math.random()`to return 0.0001, and we test that it was actually
    called, and also that the final return was `A`. In the second case, just for variety,
    we set things up so `Math.random()`can be called twice, returning two different
    values. We also verify that there were two calls to the function and that both
    results were `Z`. The third case shows yet a different way of checking how many
    times `Math.random()` (or, rather, our mocked function) was called:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Of course, you wouldn't go around inventing whatever tests came into your head.
    Supposedly, you'll work from the description of the desired `getRandomLetter()`function,
    which was written before you started to code or test it. In our case, I'm making
    do as if that specification did exist, and it pointedly said, for example, that
    values close to 0 should produce an `A`, values close to 1 should return `Z`,
    and the function should return ascending letters for ascending `random` values.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, how would you test the original `getRandomFileName()` function, the one
    that called the impure `getRandomLetter()`function? That''s a much more complicated
    problem.... what kind of expectations do you have? You cannot know the results
    it will give, so you won''t be able to write any `.toBe()` type of tests. What
    you can do, is to test for some properties of the expected results. And, also,
    if your function implies randomness of some kind, you can repeat the tests as
    many times as you want, to have a bigger chance of catching a bug:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We are not passing any random letter generator function to `getFileName()`,
    so it will use the original, impure one. We ran some of the tests a hundred times,
    as extra insurance.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: When testing code, always remember that *absence of evidence*isn't *evidence
    of absence*. Even if our repeated tests succeed, there is no guarantee that, with
    some other random input, they won't produce an unexpected, and hitherto undetected,
    error.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s do another *property*test. Suppose we want to test a shuffling algorithm;
    we may decide to implement the Fisher-Yates version, along the lines of the following.
    As implemented, the algorithm is doubly impure: it doesn''t always produce the
    same result (obviously!) and it modifies its input parameter:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: For more on this algorithm --including some pitfalls for the unwary programmer--
    see [https://en.wikipedia.org/wiki/Fisher-Yates_shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: 'How could you test this algorithm? Given that the result won''t be predictable,
    we can check for properties of its output. We can call it with a known array,
    and then test some properties of it:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We had to write the second part of the unit tests in that way, because, as we
    saw, `shuffle()` modifies the input parameter.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 4.1\. **Minimalistic function**: Functional programmers sometimes tend to write
    code in a minimalistic way. Can you examine this version of the Fibonacci function,
    and explain whether it works, and if so, how?
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '4.2\. **A cheap way**:The following version of the Fibonacci function is quite
    efficient and doesn''t do any unnecessary or repeated computations. Can you see
    how? Suggestion: try to calculate `fib4(6)` by hand, and compare with the example
    given earlier in the book:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 4.3 **A shuffle test:**How would you write unit tests for `shuffle()`, to test
    whether it works correctly with arrays with *repeated* values?
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '4.4\. **Breaking laws:**Using `.toBeCloseTo()` is very practical, but it can
    cause some problems. Some basic mathematics properties are:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: 'a number should equal itself: for any number *a*, *a* should equal *a*'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: If a number *a* equals number *b*, then *b* should equal *a*
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If *a* equals *b*, and *b* equals *c*, then *a* should equal *c*
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If *a* equals *b*, and *c* equals *d*, then *a*+*c* should equal *b*+*d*
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If *a* equals *b*, and *c* equals *d*, then *a***c* should equal *b***d*
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If *a* equals *b*, and *c* equals *d*, then *a*/*c* should equal *b*/*d*
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does `.toBeCloseTo()` also satisfy all these properties?
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have introduced the concept of *pure functions* and studied
    why they matter. We have also seen the problems caused by *side effects*, one
    of the causes of impure functions; considered some ways of *purifying* such impure
    functions, and finally, we have seen several ways of doing unit tests, for both
    pure and impure functions.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 5](a58c196f-ddb4-4d2a-858e-10ce09e0d02f.xhtml), *Programming Declaratively
    - A Better Style*, we''ll show other advantages of FP: how you can program in
    a declarative fashion, at a higher level, for simpler, more powerful code.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
