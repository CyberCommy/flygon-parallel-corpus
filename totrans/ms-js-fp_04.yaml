- en: Behaving Properly - Pure Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 3](89a2ff2f-a67d-4a21-a2f5-cd54bed7198a.xhtml), *Starting Out with
    Functions - A Core Concept*, we considered functions as the key elements in FP,
    went into detail about arrow functions, and introduced some concepts such as injection,
    callbacks, polyfilling, and stubbing. Now, in this chapter, we'll have the opportunity
    to revisit or apply some of those ideas, while we also...
  prefs: []
  type: TYPE_NORMAL
- en: Consider the notion of *purity*, and why we should care about *pure functions*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examine the concept of *Referential Transparency*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recognize the problems implied by side effects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Show some advantages of pure functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Describe the main causes of impure functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Find ways to minimize the number of impure functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Focus on ways of testing both pure and impure functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pure functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Pure functions behave in the same way as mathematical functions and provide
    diverse benefits. A function may be considered to be pure if it satisfies two
    conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Given the same arguments, the function always calculates and returns the
    same result**, no matter how many times it''s invoked, or in which conditions
    you call it. This result value cannot depend on any *outside*information or state,
    which could change during the program execution, and cause it to return a different
    value. Nor can the function result depend on I/O results, random numbers, or some
    other external variable, not directly controllable, value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**When calculating its result, the function doesn''t cause any observable *side
    effect***, including output to I/O devices, mutation of objects, change to program
    state outside of the function, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you want, you can simply say that pure functions don't depend on, and don't
    modify, anything outside its scope, and do always return the same result for the
    same input arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Another word used in this context is *idempotency*, but it's not exactly the
    same. An idempotent function can be called as many times as desired, and will
    always produce the same result. However, this doesn't imply that the function
    is free from side effects. Idempotency is usually mentioned in the context of
    RESTful services, and a simple example showing the difference between purity and
    idempotency follows. A `PUT` call would cause a database record to be updated
    (a side effect) but if you repeat the call, the element will not be further modified,
    so the global state of the database won't change any further.
  prefs: []
  type: TYPE_NORMAL
- en: We might also invoke a software design principle, and remind ourselves that
    a function should *do one thing, only one thing, and nothing but that thing*.
    If a function does anything else, and has some hidden functionality, that dependency
    on the state will mean that we won't be able to predict the function's output
    and make things harder for us as developers.
  prefs: []
  type: TYPE_NORMAL
- en: Let's get into these conditions in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Referential Transparency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In mathematics, *Referential Transparency* is the property that lets you replace
    an expression with its value, and not change the results of whatever you were
    doing.
  prefs: []
  type: TYPE_NORMAL
- en: The counterpart of *Referential Transparency*is, appropriately enough, *Referential
    Opacity*. A referentially opaque function cannot guarantee always producing the
    same result, even when called with the same arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'To give a simple example, when an optimizing compiler decides to do *constant
    folding* and replace a sentence like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'or, even better, directly with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: to save execution time, it's taking advantage of the fact that all mathematical
    expressions and functions are (by definition) referentially transparent.  On the
    other hand, if the compiler cannot predict the output of a given expression, it
    won't be able to optimize the code in any fashion, and the calculation will have
    to be done at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: In lambda calculus, if you replace the value of an expression involving a function,
    with the calculated value for the function, that operation is called a β (beta)
    reduction. Note that you can only do this safely with referentially transparent
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'All arithmetic expressions (involving both mathematical operators and functions)
    are referentially transparent: *22*9* can always be replaced by 198\. Expressions
    involving I/O are not transparent, given that their results cannot be known until
    they are executed. For the same reason, expressions involving date- and time-related
    functions, or random numbers, are also not transparent.'
  prefs: []
  type: TYPE_NORMAL
- en: With regard to JS functions, you may produce yourself, it's quite easy to write
    some that won't fulfill the *referential transparency*condition. In fact, a function
    is not even required to return a value, though the JS interpreter will return
    an undefined value in that situation.
  prefs: []
  type: TYPE_NORMAL
- en: Some languages distinguish between functions, which are expected to return some
    value, and procedures, which do not return anything, but that's not the case with
    JS. Also, there are some languages that provide means to ensure that functions
    are referentially transparent.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you wanted to, you could classify JS functions as:'
  prefs: []
  type: TYPE_NORMAL
- en: '**pure functions**: that return a value depending only on its arguments, and
    have no side effects whatsoever'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**side effects**: that don''t return anything (actually, JS has those functions
    return an `undefined` value, but that''s not relevant here), but do produce some
    kind of side effects'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**functions with side effects**: meaning they return some value (which may
    not only depend on the function arguments and also involve side effects)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In FP, much emphasis is put upon the first group, referentially transparent
    functions. Not only a compiler can reason about the program behavior (and thus
    be enabled to optimize the generated code), but also the programmer can more easily
    reason about the program and the relationship between its components. In turn,
    this can help prove the correctness of an algorithm, or to optimize the code by
    replacing a function with an equivalent one.
  prefs: []
  type: TYPE_NORMAL
- en: Side effects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are *side effects*? We can define those as some change in state, or some
    interaction with outside elements (the user, a web service, another computer,
    whatever) that occurs during the execution of some calculations or process.
  prefs: []
  type: TYPE_NORMAL
- en: There's a possible misunderstanding as to the scope of this meaning. In common
    daily speech, when you speak of *side effects*, it's a bit like talking of *collateral
    damage*--some *unintended* consequences for a given action. However, in computing,
    we include every possible effect or change outside the function. If you write
    a function that is meant to do a `console.log()` call to display some result,
    that would be considered a side effect, even if it's exactly what you intended
    the function to do in the first place!
  prefs: []
  type: TYPE_NORMAL
- en: Usual side effects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are (too many!) things that are considered side effects. In JS programming,
    including both front- and back-end coding, the more common ones you may find,
    include:'
  prefs: []
  type: TYPE_NORMAL
- en: Changing global variables.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mutating objects received as arguments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Doing any kind of I/O, such as showing an alert message or logging some text.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with, and changing, the filesystem.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating a database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calling a web service.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Querying or modifying the DOM.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Triggering any external process.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And, finally, just calling some other function that happens to produce a side
    effect of its own. You could say that impurity is contagious: a function that
    calls an impure function automatically becomes impure on its own!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With this definition, let's start considering what can cause functional impurity
    (or *referential opaqueness*, as we saw).
  prefs: []
  type: TYPE_NORMAL
- en: Global state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Of all the preceding points, the most common reason is the usage of non-local
    variables, sharing a global state with other parts of the program. Since pure
    functions, by definition, always return the same output value given the same input
    arguments, if a function refers to anything outside its internal state, it automatically
    becomes impure. Furthermore, and this is a hindrance to debugging, to understand
    what a function did, you must understand how the state got its current values,
    and that means understanding all the past history from your program: not easy!'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `isOldEnough()`function correctly detects if a person is at least 18 years
    old, but it depends on an external variable for that (the variable is good for
    2017 only). You cannot tell what the function does, unless you know about the
    external variable, and how it got its value. Testing would also be hard; you'd
    have to remember creating the global `limitYear` variable, or all your tests would
    fail to run. Even though the function works, the implementation isn't the best
    possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is an exception to this rule. Check out the following case: is the `circleArea` function,
    which calculates the area of a circle given its radius, pure or not?'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Even though the function is accessing an external state, the fact that `PI`
    is a constant (and thus cannot be modified) would allow substituting it inside
    `circleArea` with no functional change, and so we should accept that the function
    is pure. The function will always return the same value for the same argument,
    and thus fulfills our purity requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Even if you were to use `Math.PI` instead of a constant as we defined (a better
    idea, by the way) the argument would still be the same; the constant cannot be
    changed, so the function remains pure.
  prefs: []
  type: TYPE_NORMAL
- en: Inner state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The notion is also extended to internal variables, in which a local state is
    stored, and then used for future calls. In this case, the external state is unchanged,
    but there are side effects that imply future differences as to the returned values
    from the function. Let''s imagine a `roundFix()` rounding function, that takes
    into account if it has been rounding too much upwards or downwards, so next time
    it will round the other way, to make the accumulated difference closer to zero:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Some comments regarding this function:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `console.log()` line is just for the sake of this example; it wouldn''t
    be included in the real-world function. It lists the accumulated difference up
    to the point, and the result it will return: the given number rounded up or down.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are using the IIFE pattern that we saw in the `myCounter()` example, in the *Immediate
    Invocation* section of [Chapter 3](89a2ff2f-a67d-4a21-a2f5-cd54bed7198a.xhtml),
    *Starting Out with Functions - A Core Concept*, in order to get a hidden internal
    variable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `nRounded` calculation could also be written as`Math[accum > 0 ? "ceil":
    "floor"](n)` -- we test `accum` to see what method to invoke (`"ceil"` or `"floor"`)
    and then use the `Object["method"]` notation to indirectly invoke `Object.method()`.
    The way we used it, I think, is more clear, but I just wanted to give you a heads
    up in case you happen to find this other coding style.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Running this function with just two values (recognize them?) shows that results
    are not always the same for a given input. The *result* part of the console log
    shows how the value got rounded, up or down:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The first time around, `accum` is zero, so 3.14159 gets rounded down, and `accum`
    becomes `0.14159` in our favor. The second time, since `accum` is positive (meaning
    we have been rounding in our favor) then 2.71828 gets rounded up to 3, and now
    `accum` becomes negative. The third time, the same 2.71828 value gets rounded
    down to 2, because then the accumulated difference was negative; we got different
    values for the same input! The rest of the example is similar; you can get a same
    value rounded up or down, depending on the accumulated differences, because the
    function's result depends on its inner state.
  prefs: []
  type: TYPE_NORMAL
- en: This usage of internal state, is why many FPers consider that using objects
    is potentially bad. In OOP, we developers are used to storing information (attributes)
    and using them for future calculations. However, this usage is considered impure,
    insofar repeated method calls may return different values, despite the same arguments
    being passed.
  prefs: []
  type: TYPE_NORMAL
- en: Argument mutation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You also need to be aware of the possibility that an impure function will modify
    its arguments. In JS, arguments are passed by value, except in the case of arrays
    and objects, which are passed by reference. This implies that any modification
    to the parameters of the function, will effect an actual modification of the original
    object or array. This can be furthermore obscured by the fact that there are several
    *mutator* methods, that change the underlying objects by definition. For example,
    say you wanted a function that would find the maximum element of an array of strings
    (of course, if it were an array of numbers, you could simply use `Math.max()`
    with no further ado). A short implementation could be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The function does provide the correct result (and if you worry about foreign
    languages, we already saw a way around that in the *Injection: Sorting it out* section of [Chapter
    3](89a2ff2f-a67d-4a21-a2f5-cd54bed7198a.xhtml), *Starting Out with Functions -
    A Core Concept*), but it has a defect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Oops, the original array was modified; a side effect by definition! If you were
    to call `maxStrings(countries)` again, instead of returning the same result as
    before, it would produce another value; clearly, not a pure function. In this
    case, a quick solution is to work on a copy of the array (and we can use the spread
    operator to help), but we'll be dealing with more ways of avoiding these sort
    of problems in [Chapter 10](383f5538-72cc-420a-ae77-896776c03f27.xhtml), *Ensuring
    Purity - Immutability:*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Troublesome functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Finally, some functions also cause problems. For instance, `Math.random()`
    is impure: it doesn''t always return the same value -- and it would certainly
    beat its purpose if it did! Furthermore, each call to the function modifies a
    global *seed*value, from which the next *random* value will be calculated.'
  prefs: []
  type: TYPE_NORMAL
- en: The fact that *random*numbers are actually calculated by an internal function,
    and thus not random at all (if you know the formula that's used, and the initial
    value of the seed) implies that *pseudorandom* would be a better denomination
    for them.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, consider this function that generates random letters (`"A"` to
    `"Z"`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The fact that it receives no arguments, but is expected to produce *different*
    results upon each call, clearly points out that this function is impure.
  prefs: []
  type: TYPE_NORMAL
- en: Check [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/random](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/random)
    for the explanation for the `getRandomLetter()` function I wrote, and[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)
    for the `.charCodeAt()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Impurity can be inherited by calling functions. If a function uses an impure
    function, it immediately becomes impure itself. We might want to use `getRandomLetter()` in
    order to generate random filenames, with an optional given extension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In [Chapter 5](3cf24154-32aa-4bcd-bfbe-e9de8fe35096.xhtml), *Programming Declaratively
    - A Better Style*, we will see a more functional way of initializing array `namePart`,
    by using `map()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because of its usage of `getRandomLetter()`, `getRandomFileName()` is also
    impure, though it performs as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Keep this function in mind; we'll see some ways around the unit testing problem
    later in this chapter, and we'll rewrite it a bit to help out with that.
  prefs: []
  type: TYPE_NORMAL
- en: 'The consideration about impurity also extends to functions that access the
    current time or date, because their results will depend on an outside condition
    (namely the time of the day) that is part of the *global state*of the application.
    We could rewrite our `isOldEnough()` function to remove the dependency upon a
    global variable, but it wouldn''t help much:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'A problem has been removed --the new `isOldEnough2()`function is now *safer*.
    Also, as long as you don''t use it near midnight just before New Year''s Day,
    it will consistently return the same results, so you could say, paraphrasing the
    Ivory Soap slogan from the XIX century, that it''s *about 99.44% pure*. However,
    an inconvenience remains: how would you test it? If you were to write some tests
    that worked fine today, next year they''d start to fail. We''ll have to work a
    bit to solve this, and we''ll see how later on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Several other functions that also are impure are those that cause I/O. If a
    function gets input from some source (a web service, the user himself, a file,
    and so on), obviously the returned result may vary. You should also consider the
    possibility of an I/O error, so the very same function, calling the same service
    or reading the same file, might at some time fail, for reasons outside its control
    (you should assume that your filesystem, database, socket, and so on, could be
    unavailable, and thus a given function call might produce an error instead of
    the expected constant, unvarying, answer). Even a pure output, and generally safe,
    statement such as a `console.log()`, that doesn''t change anything internally
    (at least in a visible way) does cause some effects, because the user does see
    a change: the produced output.'
  prefs: []
  type: TYPE_NORMAL
- en: Does this imply that we won't ever be able to write a program that requires
    random numbers, handles dates, or does I/O, and also use pure functions? Not at
    all -- but it does mean that some functions won't be pure, and they will have
    some disadvantages that we will have to consider; we'll return to this in a bit.
  prefs: []
  type: TYPE_NORMAL
- en: Advantages of pure functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main advantage of using pure functions, derives from the fact that they
    don't have any side effects. When you call a pure function, you need not worry
    about anything, outside of which arguments you are passing to it. Also, more to
    the point, you can be sure that you cannot cause any problems or break anything
    else, because the function will only work with whatever you give it, and not with
    outside sources. But this is not their only advantage; let's see more.
  prefs: []
  type: TYPE_NORMAL
- en: Order of execution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another way of looking at what we have been saying in this chapter, is the
    consideration that pure functions can be called *robust*. You know that their
    execution --in whichever order-- won''t ever have any sort of impact on the system.
    This idea may be extended further: you could evaluate pure functions in parallel,
    resting assured that results wouldn''t vary from what you would get in a single-threaded
    execution.'
  prefs: []
  type: TYPE_NORMAL
- en: Unhappily, JS restricts us very much as to parallel programming. We may make
    do, in very restricted ways, with web workers, but that's about as far as it goes.
    For Node.js developers, the cluster module may help out, though it isn't actually
    an alternative to threads, and only lets you spawn multiple processes letting
    you use all available CPU cores. To sum it up, you don't get facilities such as
    Java's threads, for example, so parallelization isn't really an FP advantage in
    JS terms.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you work with pure functions, another consideration to keep in mind is
    that there''s no explicit need to specify the order in which they should be called.
    If you work with mathematics, an expression such as *f(2)+f(5)* is always the
    same as *f(5)+f(2)*; this is called the *commutative property*, by the way. However,
    when you deal with impure functions, that can be not true, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: With impure functions such as shown previously, you cannot assume that calculating
    *f(3)+f(3)* would produce the same result as *2*f(3)*, or that *f(4)-f(4)* would
    actually be zero; check it out! More common mathematical properties down the drain...
  prefs: []
  type: TYPE_NORMAL
- en: Why should you care? When you are writing code, willingly or not, you are always
    keeping in mind those properties you learnt about, such as the commutative property.
    So, while you might think that both expressions should produce the same result,
    and code accordingly, with impure functions you may be in for a surprise, with
    hard-to-find bugs that are difficult to fix.
  prefs: []
  type: TYPE_NORMAL
- en: Memoization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since the output of a pure function for a given input is always the same, you
    can cache the function results and avoid a possibly costly re-calculation. This
    process, which implies evaluating an expression only the first time, and caching
    the result for later calls, is called *memoization*.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will come back to this idea in [Chapter 6](9f36fbcb-da30-4a75-9b47-01cd3427633e.xhtml),
    *Producing Functions - Higher-Order Functions*, but let''s see an example done
    by hand. The Fibonacci sequence is always used for examples, because of its simplicity,
    and its hidden calculation costs. This sequence is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: for *n*=0, *fib*(*n*)=0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: for *n*=1, *fib*(*n*)=1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: for *n*>1, *fib*(*n*)=*fib*(*n*-2)+*fib*(*n*-1)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fibonacci's name actually comes from *filius Bonacci*, or *son of Bonacci*.
    He is best known for having introduced the usage of digits 0-9 as we know them
    today, instead of the cumbersome Roman numbers. He derived the sequence named
    after him as the answer to a puzzle involving rabbits!
  prefs: []
  type: TYPE_NORMAL
- en: 'If you do the numbers, the sequence starts with 0, then 1, and from that point
    onwards, each term is the sum of the two previous ones: 1 again, then 2, 3, 5,
    8, 13, 21, and so on. Programming this series by using recursion is simple --
    though we''ll revisit this example in [Chapter 9](0f9ddfc4-d3d9-40a9-941b-edbec62cc890.xhtml),
    *Designing Functions - Recursion*. The following code, a direct translation of
    the definition, will do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'If you really go for oneliners, you could also write `const fib = (n) => (n<=1)
    ? n : fib(n-2)+fib(n-1)`-- do you see why? But, more important... is it worth
    the loss of clarity?'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you try out this function for growing values of `n`, you''ll soon realize
    there is a problem, and computation starts taking too much time. For example,
    on my machine, these are some timings I took, measured in milliseconds -- of course,
    your mileage may vary. Since the function is quite speedy, I had to run calculations
    100 times, for values of `n` between 0 and 40. Even then, times for small values
    of `n` were really tiny; only from 25 onwards, I got interesting numbers. The
    chart (see Figure 4.1) shows an exponential growth, which bodes ill:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/e2ac008e-f09e-49d5-9d43-78a74620c31c.png)Figure 4.1: Calculation
    times for the fib() recursive function go up exponentially.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we draw a diagram of all the calls required to calculate `fib(6)`, you''ll
    notice the problem. Each node represents a call to calculate `fib(n)`: we just
    note the value of `n` in the node. Every call, except those for `n`=0 or 1, requires
    further calls; see Figure 4.2:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ccd25b95-8da3-4bc6-8d25-3eb16a5e4029.png)Figure 4.2: All the required
    calculations for fib(6) show lots of duplication'
  prefs: []
  type: TYPE_NORMAL
- en: 'The reason for the increasing delays becomes obvious: for example, the calculation
    for `fib(2)` was repeated on four different occasions, and `fib(3)` was itself
    calculated three times. Given that our function is pure, we could have stored
    the calculated values to avoid doing the numbers over and over again. A possible
    version would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Initially, the cache is empty. Whenever we need to calculate a value of `fib2(n)`,
    we check if it was already calculated before. If that''s not true, we do the calculation,
    but with a twist: instead of immediately returning the value, first we store it
    in the cache, and then we return it. This means that no calculation will be done
    twice: after we have calculated `fib2(n)` for a certain `n`, future calls will
    not repeat the procedure, and simply return the value that was already evaluated
    before.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A couple of short notes:'
  prefs: []
  type: TYPE_NORMAL
- en: We memoizedthe function by hand, but we can do it with a higher-order function,
    and we'll see that later, in [Chapter 6](9f36fbcb-da30-4a75-9b47-01cd3427633e.xhtml),
    *Producing Functions - Higher-Order Functions*. It is perfectly possible to memoize a
    function, without having to change to rewrite it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using an global variable for the cache isn't a very good practice; we could
    have used an IIFE and a closure to hide cache from sight; do you see how? See
    the `myCounter()` example in the *Immediate invocation* section of [Chapter 3](89a2ff2f-a67d-4a21-a2f5-cd54bed7198a.xhtml),
    *Starting Out with Functions - A Core Concept*, to review how we'd do that.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Of course, you need not do this for every pure function in your program. You'd
    do this sort of optimization only for frequently called functions, that take a
    certain important time -- if it were otherwise, the added cache management time
    would end costing more than whatever you expected to save!
  prefs: []
  type: TYPE_NORMAL
- en: Self-documentation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pure functions have another advantage. Since all the function needs to work
    with is given to it through its parameters, having no kind of hidden dependency
    whatsoever, when you read its source code, you have all you need to understand
    the function's objective.
  prefs: []
  type: TYPE_NORMAL
- en: 'An extra advantage: knowing that a function doesn''t access anything beyond
    its parameters, makes you more confident in using it, since you won''t be accidentally
    producing some side effect, the only thing the function will accomplish, is what
    you already learned through its documentation.'
  prefs: []
  type: TYPE_NORMAL
- en: Unit tests (which we'll be covering in the next section) also work as documentation,
    for they provide examples of what the function returns, when given certain arguments.
    Most programmers will agree that the best kind of documentation is full with examples,
    and each unit test can be considered such a sample case.
  prefs: []
  type: TYPE_NORMAL
- en: Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Yet another advantage of pure functions --and one of the most important ones--
    has to do with unit testing. Pure functions have a single responsibility, producing
    their output in terms of their input. So, when you write tests for pure functions,
    your work is much simplified, because there is no context to consider and no state
    to simulate.
  prefs: []
  type: TYPE_NORMAL
- en: You can simply focus on providing inputs and checking outputs, because all function
    calls can be reproduced in isolation, with independence from the *rest of the
    world*. We'll see more about testing pure and impure functions, later in this
    very chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Impure functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you decided to completely forego all kinds of side effects, your programs
    would only be able to work with hardcoded inputs... and wouldn't be able to show
    you the calculated results! Similarly, most web pages would be useless; you wouldn't
    be able to do any web services calls, or to update the DOM; you'd have static
    pages only. And, for server-side JS, your Node.JS code would be really useless,
    not being able to do any I/O...
  prefs: []
  type: TYPE_NORMAL
- en: Reducing side effects is a good goal in FP, but we cannot go overboard with
    it! So, let's think how to avoid using impure functions, if possible, and how
    to deal with them if not, looking for the best possible way to contain or limit
    their scope.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding impure functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Earlier in this chapter, we saw the more common reasons for impure functions.
    Let's now consider how we can minimize their number, if doing away with all of
    them isn't really feasible.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding the usage of state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With regard to the usage of global state --both getting and setting it-- the
    solution is well known. The key to this is:'
  prefs: []
  type: TYPE_NORMAL
- en: Provide whatever is needed of the global state to the function, as arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the function needs to update the state, it shall not do it directly, but
    rather produce a new version of the state, and return it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It will be the responsibility of the caller to take the returned state, if any,
    and update the global state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is the technique that Redux uses for its reducers. The signature for a
    reducer is `(previousState, action) => newState` meaning that it takes a state
    and an action as parameters, and returns a new state as the result. Most specifically,
    the reducer is not supposed to simply change the `previousState`argument, which
    must remain untouched (we'll see more about this in [Chapter 10](383f5538-72cc-420a-ae77-896776c03f27.xhtml),
    *Ensuring Purity - Immutability*).
  prefs: []
  type: TYPE_NORMAL
- en: 'With regard to our first version of the `isOldEnough()`function, that used
    a global `limitYear` variable, the change is simple enough: we just have to provide
    `limitYear` as a parameter for the function. With this change, it will become
    pure, since it will produce its result by only using its parameters. Even better,
    we should provide the current year, and let the function do the math, instead
    of forcing the caller to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We'll have to change, obviously, all the calls to provide the needed `limitYear`
    argument (we could also use currying, as we will see in [Chapter 7](44b5eafa-dc7f-45e4-8b9e-9bb5bb9b02ec.xhtml),
    *Transforming Functions - Currying And Partial Application*). The responsibility
    of initializing the value of `limitYear` still remains outside of the function,
    as before, but we have managed to avoid a defect.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also apply this solution to our peculiar `roundFix()`function. As you
    recall, the function worked by accumulating the differences caused by rounding,
    and deciding whether to round up or down depending on the sign of that accumulator.
    We cannot avoid using that state, but we can split off the rounding part from
    the accumulating part. So, our original code (less comments and logging) would
    change from:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'How would you use this function? Initializing the accumulator, passing it to
    the function, and updating it afterwards, are now the responsibility of the caller
    code. You would have something like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that:'
  prefs: []
  type: TYPE_NORMAL
- en: '`accum` is now part of the global state of the application'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since `roundFix2()` needs it, the current accumulator value is provided in each
    call
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The caller is responsible for updating the global state, not `roundFix2()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note the usage of the destructuring assignment, in order to allow a function
    to return more than a value, and to easily store each one in a different variable.
    For more on this, check [https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment).
  prefs: []
  type: TYPE_NORMAL
- en: This new `roundFix2()`function is totally pure, and can be easily tested. If
    you want to hide the accumulator from the rest of the application, you could still
    use a closure as in other examples, but that would again introduce impurity in
    your code; your call!
  prefs: []
  type: TYPE_NORMAL
- en: Injecting impure functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If a function becomes impure because it needs to call some other function that
    is itself impure, a way around this problem is to inject the required function
    in the call. This technique actually provides more flexibility in your code and
    allows for easier future changes, as well as less complex unit testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider the random filename generator function that we saw earlier.
    The problematic part is its usage of `getRandomLetter()` to produce the filename:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'A way to solve this is replacing the impure function, with an injected external
    one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have removed the inherent impurity from this function. If we care to
    provide a predefined pseudorandom function that actually returns fixed, known,
    values, we will be able to easily unit test this function; we''ll be seeing that
    in the following examples. The usage of the function will change, and we would
    have to write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'If this way bothers you, you may want to provide a  default value for the `randomLetterFunc` parameter,
    as with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Or you may also solve this by partial application, as we'll be seeing in [Chapter
    7](44b5eafa-dc7f-45e4-8b9e-9bb5bb9b02ec.xhtml), *Transforming Functions - Currying
    and Partial Application*.
  prefs: []
  type: TYPE_NORMAL
- en: This hasn't actually avoided the usage of impure functions. In normal use, you'll
    call `getRandomFileName()`providing it with the random letter generator we wrote,
    so it will behave as an impure function. However, for testing purposes, if you
    provide a function that returns predefined (that is, not random) letters, you'll
    be able to test it as if it were pure, much more easily.
  prefs: []
  type: TYPE_NORMAL
- en: 'But what about the original problem function, `getRandomLetter()`? We can apply
    the same trick, and write a new version, like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: For normal usage, `getRandomFileName()`would call `getRandomLetter()`without
    providing any parameters, which would imply that the called function would behave
    in its expected random ways. But if we want to test whether the function does
    what we wanted, we can run it with an injected function that will return whatever
    we decide, letting us test it thoroughly.
  prefs: []
  type: TYPE_NORMAL
- en: This idea is actually very important and has a wide specter of application to
    other problems. For example, instead of having a function directly access the
    DOM, we may provide it with injected functions that would do that. For testing
    purposes, it would be simple to verify that the tested function actually does
    what it needs to do, without really interacting with the DOM (of course, we'd
    have to find some other way to test those DOM-related functions). This can also
    apply to functions that need to update the DOM, generate new elements, and do
    all sorts of manipulations, you just use some intermediary functions.
  prefs: []
  type: TYPE_NORMAL
- en: Is your function pure?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s end this section by considering an important question: can you ensure
    a function is actually pure? To show the difficulties of this task, we''ll go
    back to the simple `sum3()`function we saw in earlier chapters. Would you say
    that this function is pure? It certainly looks like it!'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Let's see, the function doesn't access anything but its parameters, doesn't
    even try to modify them (not that it could... or could it?), doesn't do any I/O
    or work with any of the impure functions or methods that we mentioned earlier...
    what could go wrong?
  prefs: []
  type: TYPE_NORMAL
- en: 'The answer has to do with checking your assumptions. For example, who says
    the arguments for this function should be numbers? You might say to yourself *OK,
    they could be strings... but the function would still be pure, wouldn''t it?*,
    but for an (assuredly evil!) answer to that, see the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Observe the way we assigned a new function to the `x.valueOf` method, we are
    taking full advantage of the fact that functions are first-class objects. See
    the *An unnecessary mistake* section in [Chapter 3](89a2ff2f-a67d-4a21-a2f5-cd54bed7198a.xhtml),
    *Starting out with functions - A Core Concept*, to see more on this.
  prefs: []
  type: TYPE_NORMAL
- en: Well, `sum3()`ought to be pure... but it actually depends on whatever parameters
    you pass to it! You might console yourself thinking that surely no one would pass
    such arguments, but edge cases are usually where bugs reside. But you need not
    resign yourself to abandoning the idea of pure functions. Adding some type checking
    (TypeScript might come in handy) you could at least prevent some cases -- though
    JS won't ever let you be totally sure that your code is *always* pure!
  prefs: []
  type: TYPE_NORMAL
- en: Testing - pure versus impure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have seen how pure functions are conceptually better than impure ones, but
    we cannot set out on a crusade to vanquish all impurity from our code. First,
    no one can deny that side effects can be useful, or at least unavoidable: you
    will need to interact with the DOM or call a web service, and there are no ways
    to do it in a pure way. So, rather on bemoaning the fact that you have to allow
    for impurity, try to structure your code so you can isolate the impure functions,
    and let the rest of your code be the best possible.'
  prefs: []
  type: TYPE_NORMAL
- en: With this in mind, you'll have to be able to write unit tests for all kinds
    of functions, pure or impure. Writing unit tests for functions is different, as
    to its difficulty and complexity, when you deal with pure or impure functions.
    While coding tests for the former is usually quite simple and follows a basic
    pattern, the latter usually require scaffolding and complex setups. So, let's
    finish this chapter by seeing how to go about testing both types of functions.
  prefs: []
  type: TYPE_NORMAL
- en: Testing pure functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Given the characteristics of pure functions that we have already described,
    most of your unit tests could be simply:'
  prefs: []
  type: TYPE_NORMAL
- en: Call the function with a given set of arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Verify that the results match what you expected
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s start with a couple of simple examples. Testing the `isOldEnough()`function
    would have been more complex than needed for the version that required access
    to a global variable. On the other hand, the last version, `isOldEnough3()`, which
    didn''t require anything because it received two parameters, is simple to test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Another of the pure functions we wrote is equally simple, but for a care about
    precision. If we test the `circleArea`function we must use the Jasmine `.toBeCloseTo()`matcher,
    which allows for approximate equality, when dealing with floating point numbers.
    Other than that, tests are just about the same: call the function with known arguments,
    and check the expected results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'No difficulty whatsoever! The test run reports success for both suites (see
    Figure 4.3):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/aa0a1952-14ab-403c-a802-19ad03979492.png)Figure 4.3: A successful
    test run for a pair of simple pure functions'
  prefs: []
  type: TYPE_NORMAL
- en: So, we don't have to worry about pure functions, so let's move on to the impure
    ones we dealt with by transforming them into pure equivalents.
  prefs: []
  type: TYPE_NORMAL
- en: Testing purified functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we considered the `roundFix` special function, which required using state
    to accumulate the differences due to rounding, we produced a new version by providing
    the current state as an added parameter, and by having the function return two
    values: the rounded one, and the updated state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This function is now pure, but testing it requires validating not only the
    returned values but also the updated states. We can base our tests on the experiments
    we did previously. Once again, we have to use `toBeCloseTo()` for dealing with
    floating point numbers but we can use `toBe()` with integers, which produce no
    rounding errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We took care to include several cases, with positive, zero, or negative accumulated
    differences and checking if it rounded up or down on each occasion. We could certainly
    go further, by rounding negative numbers, but the idea is clear: if your function
    takes the current state as a parameter, and updates it, the only difference with
    the pure functions tests are that you will also have to test whether the returned
    state matches your expectations.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's now consider the alternative way of testing, for our pure `getRandomLetter()`variant;
    let's call it `getRandomLetter2()`. This is simple; you just have to provide a
    function that will itself produce *random* numbers. (This kind of function, in
    testing parlance, is called a *stub*). There's no limit to the complexity of a
    stub, but you'll want to keep it simple.
  prefs: []
  type: TYPE_NORMAL
- en: Wecan then do some tests, based on our knowledge of the workings of the function,
    to verify that low values produce an `A`, values close to 1 produce a `Z`, so
    we can have a little confidence that no extra values are produced. Also, a middle
    value (around 0.5) should produce a letter around the middle of the alphabet.
    However, keep in mind that this kind of test is not very good; if we substituted
    an equally valid `getRandomLetter()` variant, it might be the case that the new
    function could work perfectly well, but not pass this test, because of a different
    internal implementation!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Testing our filename generator can be done in a similar way, by using stubs.
    We can provide a simple stub that will return the letters of `"SORTOFRANDOM"`
    in sequence (this function is quite impure; see why?). So, we can verify that
    the returned filename matches the expected name, and a couple more properties
    of the returned filename, such as its length and its extension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Testing *purified*impure functions is very much the same as testing originally
    pure functions. Now, we'll have to consider some cases of truly impure functions,
    because, as we said, it's quite certain that at some time or another, you'll have
    to use such functions.
  prefs: []
  type: TYPE_NORMAL
- en: Testing impure functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For starters, we'll go back to our `getRandomLetter()`function. With insider
    knowledge about its implementation (this is called *white box testing*, in opposition
    to *black box testing*, in which we know nothing about the function code itself)
    we can *spy*(a Jasmine term) on the `Math.random()`method, and set a *mock* function
    that will return whatever values we desire.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can revisit some of the test cases we did in the previous section. In the
    first case, we set `Math.random()`to return 0.0001, and we test that it was actually
    called, and also that the final return was `A`. In the second case, just for variety,
    we set things up so `Math.random()`can be called twice, returning two different
    values. We also verify that there were two calls to the function and that both
    results were `Z`. The third case shows yet a different way of checking how many
    times `Math.random()` (or, rather, our mocked function) was called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Of course, you wouldn't go around inventing whatever tests came into your head.
    Supposedly, you'll work from the description of the desired `getRandomLetter()`function,
    which was written before you started to code or test it. In our case, I'm making
    do as if that specification did exist, and it pointedly said, for example, that
    values close to 0 should produce an `A`, values close to 1 should return `Z`,
    and the function should return ascending letters for ascending `random` values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, how would you test the original `getRandomFileName()` function, the one
    that called the impure `getRandomLetter()`function? That''s a much more complicated
    problem.... what kind of expectations do you have? You cannot know the results
    it will give, so you won''t be able to write any `.toBe()` type of tests. What
    you can do, is to test for some properties of the expected results. And, also,
    if your function implies randomness of some kind, you can repeat the tests as
    many times as you want, to have a bigger chance of catching a bug:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: We are not passing any random letter generator function to `getFileName()`,
    so it will use the original, impure one. We ran some of the tests a hundred times,
    as extra insurance.
  prefs: []
  type: TYPE_NORMAL
- en: When testing code, always remember that *absence of evidence*isn't *evidence
    of absence*. Even if our repeated tests succeed, there is no guarantee that, with
    some other random input, they won't produce an unexpected, and hitherto undetected,
    error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s do another *property*test. Suppose we want to test a shuffling algorithm;
    we may decide to implement the Fisher-Yates version, along the lines of the following.
    As implemented, the algorithm is doubly impure: it doesn''t always produce the
    same result (obviously!) and it modifies its input parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: For more on this algorithm --including some pitfalls for the unwary programmer--
    see [https://en.wikipedia.org/wiki/Fisher-Yates_shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
  prefs: []
  type: TYPE_NORMAL
- en: 'How could you test this algorithm? Given that the result won''t be predictable,
    we can check for properties of its output. We can call it with a known array,
    and then test some properties of it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: We had to write the second part of the unit tests in that way, because, as we
    saw, `shuffle()` modifies the input parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 4.1\. **Minimalistic function**: Functional programmers sometimes tend to write
    code in a minimalistic way. Can you examine this version of the Fibonacci function,
    and explain whether it works, and if so, how?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '4.2\. **A cheap way**:The following version of the Fibonacci function is quite
    efficient and doesn''t do any unnecessary or repeated computations. Can you see
    how? Suggestion: try to calculate `fib4(6)` by hand, and compare with the example
    given earlier in the book:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 4.3 **A shuffle test:**How would you write unit tests for `shuffle()`, to test
    whether it works correctly with arrays with *repeated* values?
  prefs: []
  type: TYPE_NORMAL
- en: '4.4\. **Breaking laws:**Using `.toBeCloseTo()` is very practical, but it can
    cause some problems. Some basic mathematics properties are:'
  prefs: []
  type: TYPE_NORMAL
- en: 'a number should equal itself: for any number *a*, *a* should equal *a*'
  prefs: []
  type: TYPE_NORMAL
- en: If a number *a* equals number *b*, then *b* should equal *a*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If *a* equals *b*, and *b* equals *c*, then *a* should equal *c*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If *a* equals *b*, and *c* equals *d*, then *a*+*c* should equal *b*+*d*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If *a* equals *b*, and *c* equals *d*, then *a***c* should equal *b***d*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If *a* equals *b*, and *c* equals *d*, then *a*/*c* should equal *b*/*d*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does `.toBeCloseTo()` also satisfy all these properties?
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have introduced the concept of *pure functions* and studied
    why they matter. We have also seen the problems caused by *side effects*, one
    of the causes of impure functions; considered some ways of *purifying* such impure
    functions, and finally, we have seen several ways of doing unit tests, for both
    pure and impure functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 5](a58c196f-ddb4-4d2a-858e-10ce09e0d02f.xhtml), *Programming Declaratively
    - A Better Style*, we''ll show other advantages of FP: how you can program in
    a declarative fashion, at a higher level, for simpler, more powerful code.'
  prefs: []
  type: TYPE_NORMAL
