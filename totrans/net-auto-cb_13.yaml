- en: Advanced Techniques and Best Practices for Ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will explore some advanced features and techniques that
    we can use in Ansible, along with some best practices, in order to build clearer
    and more robust Ansible playbooks for network automation. All of these techniques
    can be used with all the code from the previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'The recipes covered in this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Installing Ansible in a virtual environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validating YAML and Ansible playbooks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calculating the execution time for Ansible playbooks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validating user input using Ansible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running Ansible in `check` mode
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling parallelism and rolling updates in Ansible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring fact caching in Ansible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating custom Python filters for Ansible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the code that we describe in this chapter can be found through this URL: [https://github.com/PacktPublishing/Network-Automation-Cookbook/tree/master/ch13_ansible_best_practice](https://github.com/PacktPublishing/Network-Automation-Cookbook/tree/master/ch13_ansible_best_practice).
  prefs: []
  type: TYPE_NORMAL
- en: 'You will need the following for this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Ansible machine running CentOS 7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ansible 2.9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python 3.6.8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing Ansible in a virtual environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will outline how to install Ansible in a Python virtual environment
    in order to have an isolated and contained environment for developing and running
    our playbooks.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python 3 must be already installed on your Linux machine.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new Python virtual environment called `dev`, and activate it as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Install Ansible in this new virtual environment, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As outlined in the first chapter of this book, we can install Ansible using
    one of these two methods:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the package manager on our Linux machine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Python PIP package manager
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In both these options, we are running Ansible using system-level Python. This
    means that when we install any other packages or scripts required for our automation,
    such as **Amazon Web Services** (**AWS**) or Azure packages, we are installing/upgrading
    these packages on the system level. In some cases, we might install a package
    that conflicts with an existing package on our system, and it might impact other
    scripts. Python virtual environments are mainly built for this use case. The virtual
    environment provides an isolated runtime environment where we install our Python
    packages totally separately from the system-level packages. Thus, we can run different
    versions of the same package (Ansible, for example) in a totally isolated and
    independent manner.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we outline how to create a new Python virtual environment using
    the `venv` Python module. We use the `python` command with the `-m` option to
    invoke the `venv` module, which allows us to create a new virtual environment.
    We use the `venv` Python module to create a new virtual environment called `dev`,
    which will create the `dev` folder to house our new virtual environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to start using this new virtual environment, we need to activate it.
    We use the `source` command to run the activate script located in the `dev` folder
    (`~/dev/bin/activate`). This script will activate the virtual environment and
    will place us inside this newly created environment. We can verify that our current
    Python executable is located within this new environment and not related to system-level
    Python, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we are inside our virtual environment, we use the `python-pip` command
    in order to install Ansible within our virtual environment. We can verify that
    Ansible is installed and is using our new virtual environment as shown in the
    following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'At this stage, we have installed Ansible in this virtual environment. However,
    by default, when Ansible is run, it will try to use the system-level Python located
    in `/usr/bin/python`. In order to override this behavior and force Ansible to
    use our new virtual environment, we need to set a variable for all our hosts to
    use this new virtual environment, which we can do in our inventory file, as shown
    in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Validating YAML and Ansible playbooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will outline how to validate YAML files and Ansible playbooks
    using the `Yamllint` and `ansible-lint` tools, in order to make sure that our
    YAML documents are valid with the correct syntax, as well as validating our Ansible
    playbooks.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python and PIP package manager must be already installed on your Linux machine,
    and Ansible must also be installed.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Install `yamllint`, as shown in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Install `ansible-lint`, as shown in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Change to the directory of your Ansible project, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Run `yamllint`, as shown in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Run `ansible-lint`, as shown in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We use YAML documents to declare our network topology and the different parameters
    that we need in order to run our playbooks or generate the configuration for our
    devices. Since we are going to edit these files regularly to update our network
    topology and add new services, we need to ensure that all the changes to these
    files are validated and that the syntax of these files is correct before we import/use
    these files in our playbooks. One of the most used tools to validate YAML files
    is the `Yamllint` program, which reads YAML documents and analyzes them for syntax
    errors and best practice formats, outputting the result of the analysis. We install
    this tool using the PIP package manager.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example, we have a typical Ansible project, with the directory structure
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/7c6ec20a-2d7c-4ff1-93ec-7ebb2fb2489b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We analyze all the YAML documents in this folder by running `Yamllint`, as
    outlined in the preceding section. The following screenshot outlines the output
    of the `Yamllint` command on the Ansible project folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/bce85647-9bf4-44d9-97c6-1b49b0229e25.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding output outlines the problems that the `Yamllint` command found
    in all the YAML files in this folder, and it provides a very clear output regarding
    the problems identified in each file. These problems can be identified as errors
    or warnings, and this affects the return code for the `Yamllint` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in cases where all the problems in the files are designated as a `warning`,
    the return code is `0`, which means that the YAML documents are valid. However,
    they have some minor problems that should be fixed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'If the problems are identified as an `error`, the return code is not `0`, which
    means that the YAML document has a major problem that needs to be fixed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The return code is critical since it signifies whether the `Yamllint` command
    was successful or not, and this is critical in building **continuous integration/continuous
    deployment** (**CI/CD**) pipelines to automate the provisioning of the infrastructure.
    One of the steps in the pipeline will be to lint all YAML files in order to make
    sure that the files are correct, and if the `Yamllint` command succeeds, it will
    have a return code of `0`.
  prefs: []
  type: TYPE_NORMAL
- en: The `Yamllint` command catches all the syntax errors in the YAML documents.
    However, `ansible-lint` provides a more comprehensive check on the `ansible-playbook`
    code specifically and verifies that the playbook adheres to good coding practices.
    It is very useful to run since it can be used to validate the correct style for
    playbooks and Ansible roles, and will prompt for any problem in the playbooks.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we run the `ansible-lint` command for our playbook, we can see that it
    catches the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/1aa2d0ae-8d09-4ca6-b21d-32f3c6308b7e.png)'
  prefs: []
  type: TYPE_IMG
- en: The output is very descriptive as it outlines that the task at line `7` within
    the playbook doesn't have a name, and this doesn't adhere to Ansible best practices.
    The return code for the command is `2`, and this signals that the command has
    failed. Once we correct this problem, there will be no errors displayed, and the
    return code will be `0`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Yamllint` program can be customized by including a `yamllint` file within
    the project directory structure that includes the rules that need to be modified.
    So, in our example, when we run the `yamllint` command, we can see that one of
    the problems outlined is that the line length is `> 80` characters, and this is
    an error as per the default rules with which `yamllint` complies:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/cb9bdefc-b0a3-4c70-9161-aaab7162bab4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can modify our file and try to change the length of the lines that `yamllint` is
    complaining about, or we can specify that this should not be a problem and only
    a `warning` should be triggered. We use the latter approach, and we create the
    `.yamllint` file inside our directory and add the following rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'So, when we run the `yamllint` command again on our folder, we can see that
    all the previous messages for line length have changed to warnings:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/623c1a50-140f-42c1-a1a8-c206131166f4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'For `ansible-lint`, we can check all the current rules that `ansible-lint`
    consults in order to validate a given playbook or role, using the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `-L` option will output all the rules and a short description of each of
    these rules.
  prefs: []
  type: TYPE_NORMAL
- en: The `-T` option will output all the rules/tags used by `ansible-lint`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can run our `ansible-lint` command to ignore a specific rule/tag, as shown
    in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This will cause `ansible-lint` to ignore all the rules with the `task` tag;
    this way, we can influence which rules are applied by `ansible-lint` to validate
    our playbooks.
  prefs: []
  type: TYPE_NORMAL
- en: See also...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For more information regarding `yamllint`, please use the following URL: [https://yamllint.readthedocs.io/en/stable/](https://yamllint.readthedocs.io/en/stable/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more information regarding the configuration file used by `yamllint` and
    how to customize it, please use the following URL: [https://yamllint.readthedocs.io/en/stable/configuration.html](https://yamllint.readthedocs.io/en/stable/configuration.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more information regarding `ansible-lint`, please use the following URL: [https://docs.ansible.com/ansible-lint/](https://docs.ansible.com/ansible-lint/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calculating the execution time for Ansible playbooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will outline how to get the time that various tasks within
    an Ansible playbook take to execute. This can help us understand which specific
    task or role is taking the largest portion of time during a playbook run, and
    can help us to optimize our playbooks.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Update the `ansible.cfg` file to include the following line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'List all the tasks in the `ansible-playbook` code for reference:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the Ansible playbook:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Ansible provides multiple callback plugins that we can use in order to add
    new behavior to Ansible when responding to events. One of the most useful callback
    plugins is the `timer` plugin; it provides the capability to measure the execution
    time for the tasks and roles within an Ansible playbook. We can enable this functionality
    by whitelisting these plugins in the `ansible.cfg` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Timer`: This plugin provides a summary of the execution time for the playbook.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Profile_tasks`: This provides us with a summary of the execution time of each
    task within a playbook.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Profile_roles`: This provides us with a summary of the time taken for each
    role within a playbook.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We list all the tasks within a playbook using the `--list-tasks` option in
    order to verify all the tasks that will be executed in our playbook. Here is a
    snippet of the tasks within our sample playbook:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/deda2ba3-8d06-4987-a2fb-349f73754ab7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We then run the playbook and check the newly added detailed execution summary,
    as outlined in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/d74a5f8c-d473-402b-adde-92e8afee5ced.png)'
  prefs: []
  type: TYPE_IMG
- en: The first part of the summary outlines the execution time for the role (`generate_config`),
    as well as the different modules, using the `post_task` section (we use only the
    `file` and `assemble` modules in the `post_task` section). The next part of the
    summary outlines the execution time for each task within our playbook (including
    a breakdown for tasks within the role). Finally, we get a summary of the overall
    execution time for our playbook as a whole, in a single line.
  prefs: []
  type: TYPE_NORMAL
- en: See also...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For more information regarding callback plugins, `profile_tasks` and `profile_roles`
    plugins, and the `timer`, please consult the following URLs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.ansible.com/ansible/latest/plugins/callback/timer.html](https://docs.ansible.com/ansible/latest/plugins/callback/timer.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.ansible.com/ansible/latest/plugins/callback/profile_tasks.html](https://docs.ansible.com/ansible/latest/plugins/callback/profile_tasks.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.ansible.com/ansible/latest/plugins/callback/profile_roles.html](https://docs.ansible.com/ansible/latest/plugins/callback/profile_roles.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validating user input using Ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will outline how to validate input data using Ansible. We
    rely heavily on the information that we either retrieve from the network or declare
    in `host` or `group` variables, in order to execute different tasks in Ansible
    such as generating configuration or provisioning devices. Before we start to use
    this information, we need to be able to validate the structure and validity of
    this data before further processing our playbooks.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create an `ACLs` definition in `ACLs.yml`, as shown in the following code block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new validation task in the `validate_acl.yml` file, as shown in the
    following code block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new playbook to create **access control lists** (**ACLs**) and push-to-network
    devices, as shown in the following code block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this example playbook, we want to push ACL configuration to our infrastructure.
    We generate the configuration using the `template` module, and we push the configuration
    using the `iosxr_config` module. All our ACL definition is declared in the `ACLs.yml`
    file. We would like to validate the input data contained within our `ACLs.yml`
    file since this is the data that we rely on in order to generate our configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'We create a `validate_acl.yml` `tasks` file that has multiple tasks to validate
    the structure and the content of the data that we will use to generate our configuration.
    We start by importing our data using the `include_vars` parameter and then we
    define two main tasks to validate our data:'
  prefs: []
  type: TYPE_NORMAL
- en: The first task is validating that the required data structure is present and
    that the data structure is in the correct format that we expect.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second task is validating the contents of each firewall rule.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In all these validation tasks, we are using the `assert` module in order to
    test and validate our conditional statements and we can define much more comprehensive
    checking on the input data structure to cover all the possibilities for our data.
  prefs: []
  type: TYPE_NORMAL
- en: Using this approach, we can validate the validity of our input data and make
    sure that our data is sane in order to be processed by subsequent tasks within
    the playbook.
  prefs: []
  type: TYPE_NORMAL
- en: Running Ansible in check mode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will outline how to run our Ansible playbooks in dry-run
    mode. This mode is also called `check` mode and, in this mode, Ansible will not
    perform any changes on the remotely managed nodes. We can consider this as a simulation
    run for our playbook that will make us understand which changes will be made by
    Ansible, if we execute the playbook in `check` mode.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Update our ACL declaration in the `ACLs.yml` file with the new entry, as shown
    in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the `pb_push_acl.yml` provision playbook using `check` mode, as shown in
    the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we run the playbook using the `check` mode, no changes are done on the
    remote systems, and we can see the output from the playbook run, as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/f3506f27-3628-4185-9ee6-5384e691d54c.png)'
  prefs: []
  type: TYPE_IMG
- en: This output outlines that the configuration file we generate for our ACL will
    be changed (a new rule will be added); however, the provision ACLs task is not
    reporting any change. This is because the configuration file didn't change since
    we are running our playbook in `check` mode, so in this case, this task is still
    using the unmodified configuration file, so no changes will be implemented.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also check the changes that will occur using the `--diff` flag when
    running the playbook, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We obtain the following output when we use the `--diff` flag, and it outlines
    the changes that will take place on our configuration file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/fab7de8a-ad06-42f7-b1b6-b2b856261527.png)'
  prefs: []
  type: TYPE_IMG
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can use `check` mode as a switch to run or skip tasks. So, in some cases
    when we are running in `check` mode, we would not like to connect to the device
    and push any configuration on the device, since nothing will be changed. Using
    `check` mode, we can build our playbooks to skip these tasks, as shown in the
    following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In our `tasks`, we added the `when` directive, and we are checking the value
    for the `ansible_check_mode` parameter. This parameter is set to `true` when we
    run our playbook in `check` mode. Thus, on each task, we are checking whether
    the `check` mode is set, and, if so, we will skip these tasks during the playbook
    run. If the playbook is run in normal mode (without `check` mode), these tasks
    will be executed normally.
  prefs: []
  type: TYPE_NORMAL
- en: See also...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For more information regarding running our playbooks in `check` mode, please
    consult the following URL: [https://docs.ansible.com/ansible/latest/user_guide/playbooks_checkmode.html](https://docs.ansible.com/ansible/latest/user_guide/playbooks_checkmode.html).
  prefs: []
  type: TYPE_NORMAL
- en: Controlling parallelism and rolling updates in Ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By default, Ansible runs tasks in parallel. In this recipe, we will outline
    how to control the parallel execution of Ansible and how we can modify this default
    behavior. We will also explore the concept of rolling updates and how to utilize
    them in Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Update the `ansible.cfg` file to control parallel execution, as shown in the
    following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the `pb_push_acl.yml` file to set up rolling updates for the configuration
    push on the network devices, as shown in the following code block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ansible, by default, works by executing each task across all the devices identified
    in a playbook in parallel. By default, for each task, Ansible will fork five parallel
    threads (called forks) and execute these threads in parallel across five nodes
    in the inventory. Once these tasks finish, it will target the remaining devices
    in the inventory in a batch of five nodes. It performs this on each task executed
    in the playbook. Using the `forks` keyword in the `ansible.cfg` file, we can modify
    the default `fork` value that Ansible is using and control the number of parallel
    nodes that Ansible targets during each task execution. This can speed up our playbook
    execution; however, it requires more resources in terms of memory and CPU power
    on the Ansible control node.
  prefs: []
  type: TYPE_NORMAL
- en: When using a large number of forks, be advised that any `local_action` steps
    can fork a Python interpreter on your local machine, so you may wish to keep `local_action`
    or `delegated` steps limited in number or in separate plays. For further information,
    see [https://www.ansible.com/blog/ansible-performance-tuning](https://www.ansible.com/blog/ansible-performance-tuning).
  prefs: []
  type: TYPE_NORMAL
- en: The other option that we can modify to control playbook execution is that, by
    default, Ansible runs each task across all nodes identified in the playbook, and
    it will only step from one task to the other once all the nodes have completed
    the previous task. We might want to modify this behavior in multiple situations,
    such as pushing the configuration to network devices or upgrading network devices.
    We might want to execute a playbook on each node in a serial fashion—this means
    that each node (or group of nodes) is picked up by Ansible and the playbook is
    executed on it; once this batch is finished, another batch is selected, and the
    playbook is run again. This approach allows us to deploy our changes in a rolling
    manner, and if one of our nodes has failed, we can stop the playbook execution.
    This configuration is controlled using the `serial` keyword in the playbook. It
    instructs Ansible to start the play with the number of hosts identified by the
    `serial` option, executes the whole tasks on this batch, then rolls over and selects
    another batch, and executes the complete playbook on that batch, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: See also...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For more information about Ansible forks and rolling updates, please consult
    the following URL: [https://docs.ansible.com/ansible/latest/user_guide/playbooks_delegation.html](https://docs.ansible.com/ansible/latest/user_guide/playbooks_delegation.html).
  prefs: []
  type: TYPE_NORMAL
- en: Configuring fact caching in Ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will outline how to set up and configure fact caching in
    Ansible. This is an important feature that can help us in optimizing and speeding
    the execution time of our playbooks when we require facts to be collected from
    our infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Update the `ansible.cfg` file to enable fact caching, and set up the required
    folder to store the cache:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new `pb_get_facts.yml` playbook to collect facts from the network
    using different approaches:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the new Ansible playbook on a single node from our inventory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ansible is a powerful tool to collect information about the operational state
    of our infrastructure, and we can use this information in generating configuration,
    building reports, and also to validate the state of our infrastructure. In cases
    where the state of our infrastructure is highly stable, we might not need to collect
    the network facts from our devices during every playbook run. In these cases,
    we might opt to use fact caching in order to speed up the execution of our playbooks.
    We read the facts (network state) of our devices from a stored location on the
    Ansible control node, instead of connecting to the devices and collecting the
    information from the live network.
  prefs: []
  type: TYPE_NORMAL
- en: Fact caching is enabled in the `ansible.cfg` file, and in this file, we also
    set the backend type that we will use to store the fact data. There are multiple
    options, ranging from YAML or JSON files to storing this data into `redis` or
    `Memcached` databases. In our example, for simplicity, we will use YAML files
    to store the facts collected from the devices. We also specify the folder location
    to store this information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have performed these steps, we can run our playbook to collect network
    facts. In this sample playbook, we are using different modules (approaches), as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`iosxr_facts`: This is a built-in module within Ansible networking modules
    to collect facts from IOS-XR devices (for most networking equipment, there is
    a fact collection module for each vendor supported by Ansible).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`napalm_get_facts`: This is a custom module from **Network Automation and Programmability
    Abstraction Layer with Multivendor support** (**NAPALM**) that needs to be installed
    to collect facts as well; however, it is not part of the core Ansible modules.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`set_fact`: We use the `set_fact` module to set a custom fact during the playbook
    run, and we use the `cacheable` option to instruct the module to write this new
    cached variable into our cache.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once we run the playbook, we can check that the new folder is created and a
    new YAML file for each node within our inventory is stored in this location. All
    the facts collected by these modules are saved in these YAML files, as shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/fd052830-d9c7-4ba5-9da1-dbdba6842272.png)'
  prefs: []
  type: TYPE_IMG
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once we have configured fact caching, we can start to use the Ansible variables
    declared in our cache in any other playbook, as shown in the following code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding playbook, we are utilizing the variables collected from the
    cache (`ansible_net_interfaces`, in this example) and running the tasks against
    the devices in the inventory. We need to consider that, by default, the entries
    in the cache are valid only for a specific amount of time, controlled by the timeout
    value for our cache to ensure that any outdated state in our cache will not be
    considered. This value is controlled by the `fact_caching_timeout` option, which
    can be set in the `ansible.cfg` file.
  prefs: []
  type: TYPE_NORMAL
- en: See also...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For more information regarding Ansible fact caching, please consult the following
    URLs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.ansible.com/ansible/latest/plugins/cache.html](https://docs.ansible.com/ansible/latest/plugins/cache.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.ansible.com/ansible/latest/plugins/cache/yaml.html](https://docs.ansible.com/ansible/latest/plugins/cache/yaml.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating custom Python filters for Ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ansible provides a rich set of filters from Jinja2, as well as some additional
    built-in filters to manipulate data; however, in some cases, you may find that
    there is no filter available to satisfy your requirements. In this recipe, we
    will outline how to build custom filters in Python to extend Ansible functionality
    to manipulate data.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the project directory (`ch13_ansible_best_practice`), create a new folder, `filter_plugins`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new Python script called `filter.py` under the `filter_plugins` folder,
    with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new Ansible playbook, `pb_test_custom_filter.yml`, with the following
    content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can extend the `filter` library provided by Ansible and create a custom filter
    using Python. In order to implement our custom filter, we create a folder called
    `filter_plugins` under our project directory, and we create a Python script with
    any name (we used `filter.py` in our example).
  prefs: []
  type: TYPE_NORMAL
- en: The custom Python filters must be placed in a folder called `filter_plugins`
    in order for Ansible to pick up these filters and process them.
  prefs: []
  type: TYPE_NORMAL
- en: Inside this Python script, we create a Python class called `FilterModule`. Inside
    this class, we declare a function named `filters` that returns a dictionary of
    all our custom filters that we define. We then start to create our filter by declaring
    a function called `acl_state` that takes the `acl_def` variables (which is our
    ACLs' definition that we pass in our playbook). In this example, we are simply
    taking the definition of our ACL state and changing it to uppercase. We then return
    the newly modified ACL definition.
  prefs: []
  type: TYPE_NORMAL
- en: We create an Ansible playbook as normal, and we read our ACL definition from
    the `ACLs.yml` file. Then, we create a new task to set a custom fact using the `set_fact`
    module, and we pass our ACLs' data structure to our custom filter that we have
    created (`acl_state`). We save the return value from our custom filter to a new
    variable called `standard_acl`, and we use the `debug` module in the next task
    to output the value of this new variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following snippet outlines the new value for our ACL and how the state
    parameter within our ACL definition has changed to uppercase:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ee611e48-9e8e-41fc-b57f-ef6b5e9bdfd7.png)'
  prefs: []
  type: TYPE_IMG
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We outlined how to pass the variable definition to our custom filter in the
    previous example; however, we can also pass multiple fields to our custom filter
    in order to have more control over the return value of our filter. In order to
    outline this, we will create another custom filter that will take the ACL definition
    along with a field variable, and, based on this field, we will change the value
    of this field in our ACL definition to uppercase. Here is the modified `filter.py` Python
    script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output of the modified tasks within the playbook, using our new
    custom filter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output for our `final_acl` file after applying the new custom filter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/cdf03605-e02c-4166-bb13-5738974f3db2.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding screenshot shows the output after applying the new custom filter.
  prefs: []
  type: TYPE_NORMAL
