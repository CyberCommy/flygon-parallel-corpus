- en: Working with MongoDB and Go to Create REST APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are going to introduce the NoSQL database called `MongoDB`.
    We will learn how well MongoDB suits modern web services. We will begin by learning
    about `MongoDB` collections and documents. We will try to create an example API
    with `MongoDB` as the database. In this process, we will use a driver package
    called `mgo`. We willthen try to design a document model for the e-commerce REST
    services.
  prefs: []
  type: TYPE_NORMAL
- en: 'Basically, we are going to discuss the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Installing and using MongoDB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with the Mongo shell
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building REST APIs with MongoDB as the database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basics of database indexing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing an e-commerce document model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting the code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can get the code samples for this chapter from [https://github.com/narenaryan/gorestful/tree/master/chapter5](https://github.com/narenaryan/gorestful/tree/master/chapter5).
    This chapter's examples are a combination of single programs and projects. So,
    copy the respective directory to your `GOPATH` to run the code samples properly.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to MongoDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**MongoDB** is a popular NoSQL database that is attracting a lot of developers
    worldwide. It is different from traditional relational databases such as MySQL,
    PostgreSQL, and SQLite3\. The main big difference of MongoDB compared to other
    databases is the ease of scalability at the time of internet traffic. It also
    has JSON as its data model, which allows us to store JSON directly into the database.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Many huge companies such as Expedia, Comcast, and Metlife built their applications
    on MongoDB. It is already proven as a vital element in modern internet businesses.
    MongoDB stores data in a document; think of this as a row in SQL databases. All
    MongoDB documents are stored in a collection, and the collection is a table (in
    SQL analogy). A sample document for an IMDB movie looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The main advantages of MongoDB over relational databases are:'
  prefs: []
  type: TYPE_NORMAL
- en: Easy to model (schema free)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can leverage querying power
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Document structure suits modern-day web applications (JSON)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More scalable than relational databases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing MongoDB and using the shell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'MongoDB can be easily installed on any platform. On Ubuntu 16.04, we need to
    perform some processes before running the `apt-get` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'It will ask for confirmation of installation in the last step; press *Y*. Once
    the installation is done, we need to start the MongoDB daemon using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: All the preceding commands are to be run by the root. If the user is not root,
    use the prepend `sudo` keyword before each command.
  prefs: []
  type: TYPE_NORMAL
- en: We can also download MongoDB manually from the website and run the server with
    the `~/mongodb/bin/mongod/` command. For this, we need to create an init script
    because the server will be killed if we close the terminal. We can also use `nohup`
    for running the server in the background. Usually, it is better to install it
    using `apt-get`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For installing MongoDB on macOS X, use the Homebrew software. We can easily
    install it using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we need to create the `db` directory where MongoDB stores its database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, change the permissions of that file using `chown`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have MongoDB ready. We can run it in a terminal window with the following
    command, which starts the MongoDB daemon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Take a look at the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c03be89e-caf0-4908-b354-18561320761a.png)'
  prefs: []
  type: TYPE_IMG
- en: On Windows, we can manually download the installer binary and launch it by adding
    the installation `bin` directory to the `PATH` variable. Then, we can run it using
    the `mongod`command.
  prefs: []
  type: TYPE_NORMAL
- en: Working with the Mongo shell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Whenever we start using MongoDB, the first thing we should do is play with
    it for a while. Looking for available databases, collections, documents, and so
    on can be done with a simple tool called Mongo shell. This shell is packaged along
    with the installation steps we mentioned in the preceding section. We need to
    launch it using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Refer to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/22b8e49f-16bd-40a6-add0-135f45be6284.png)'
  prefs: []
  type: TYPE_IMG
- en: If you see this screen, everything worked fine. If you are getting any errors,
    the server is not running or there is some other issue. For troubleshooting, you
    can look at the official MongoDB troubleshooting guide at [https://docs.mongodb.com/manual/faq/diagnostics](https://docs.mongodb.com/manual/faq/diagnostics/).
    The client gives the information about MongoDB versions and other warnings. To
    see all available shell commands, use the `help` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we are ready with our setup. Let us create a new collection called `movies`
    and insert the preceding example document into it. By default, the database will
    be a test database. You can switch to a new database using the `use`command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'It shows all available databases. By default, `admin`, `test`, and `local` are
    the three databases available. In order to create a new database, just use `use
    db_name`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This switches the current database to the `appdb` database.If you try to see
    this in the available databases, it won''t show up because MongoDB creates a database
    only when data is inserted into it (first collection or document). So, now we
    can create a new collection by inserting a document from the shell. Then, we can
    insert the preceding Star Trek movie record into a collection called `movies`,using
    this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The JSON you inserted has an ID called `_id`. We can either provide it while
    inserting a document or MongoDB can insert one for you itself. In SQL databases,
    we use *auto-increment* along with an `ID` schema toincrement the `ID` field.
    Here, MongoDB generates a unique hash `ID` rather than a sequence. Let us insert
    one more document about `The Dark Knight`, but this time let us not pass the `_id`
    field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If you observe the acknowledgement JSON response, `insertId`hasnow changed
    to a very lengthy `59574125bf7a73d140d5ba4a`.This is the unique hash generated
    by MongoDB. Now, let us see all the documents in our collection. We can also insert
    a batch of documents at a given time using an `insertMany` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the `find` function on the movies collection returns all matched documents
    in the collection. In order to return a single; document, use the `findOne` function.
    It returns the latest document from multiple results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'How do we fetch a document with some criteria? This means querying. Querying
    in MongoDB is known as filtering data and returning a result. If we need to filter
    for movies that were released in 2008, then we can do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The filter query from the preceding mongo statement is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This states that the searching criteria is the *year* and the value should
    be *2008.* `$eq`is called a filtering operator, which helps to relate the condition
    between the field and data. It is equivalent to the `=` operator in SQL. In SQL,
    the equivalent query can be written as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We can simplify the last written mongo query statement to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This find query and above mongo query were the same, returning the same set
    of documents. The former syntax is using the `$eq`which is a query operator. From
    now on, let us call a *query operator* simply an *operator*. Other operators are:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operator** | **Function** |'
  prefs: []
  type: TYPE_TB
- en: '| `$lt` | Less than |'
  prefs: []
  type: TYPE_TB
- en: '| `$gt` | Greater than |'
  prefs: []
  type: TYPE_TB
- en: '| `$in` | In the |'
  prefs: []
  type: TYPE_TB
- en: '| `$lte` | Less than or equal to |'
  prefs: []
  type: TYPE_TB
- en: '| `$ne` | Not equal to |'
  prefs: []
  type: TYPE_TB
- en: 'Now, let us pose a question to ourselves. We want to fetch all the documents
    whose budget is more than $150,000,000\. How can we filter it with the knowledge
    we gained previously? Take a look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'If you observe, we accessed the budget key within the JSON using `boxOffice.budget`.The
    beauty of MongoDB is that it allows us to query the JSON with a lot of freedom.
    Can''t we add two or more operators to the criteria while fetching documents?
    Yes, we can! Let us find all movies in the database that were released in 2009
    with a budget of more than $150,000,000:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This returns nothing because we don''t have any documents that match the given
    criteria. Comma-separated fields actually combine with the `AND`operation. Now,
    let us relax our condition and find movies that were either released in 2009 or
    had a budget of more than $150,000,000:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Here, the query is bit different. We used an operator called `$or`for finding
    the predicate of two conditions. The result will be the criteria for fetching
    the documents. `$or`needs to be assigned to a list that has a list of JSON condition
    objects. Since JSON can be nested, conditions can also be nested. This style of
    querying might look new to people coming from an SQL background. The MongoDB team
    designed it for the intuitive filtering of data. We can also write advanced queries
    such as inner joins, outer joins, nested queries, and so on easily in MongoDB
    with the clever use of operators.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unknowingly, we have finished three operations in CRUD. We saw how to create
    a database and a collection. Then, we inserted documents and read them using filters.
    Now it is time for the delete operation. We can delete a document from a given
    collection using the `deleteOne` and `deleteMany` functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The argument passed to the **`deleteOne` **function is the filtering criteria,
    which is similar to the read operation. All the documents that match the given
    criteria will be removed from the collection. The response has a nice acknowledgment
    message with a count of documents that got deleted.
  prefs: []
  type: TYPE_NORMAL
- en: All the preceding sections discuss the basics of MongoDB, but with the shell,
    which executes JavaScript statements. It is not quite useful executing `db` statements
    from the shell manually. We need to call the API of Mongo DB in Go using a driver
    program. In the upcoming section, we will see such a driver package called `mgo`.
    The official MongoDB drivers include languages such as Python, Java, and Ruby.
    Go's `mgo` driver is a third-party package.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing mgo, a MongoDB driver for Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`mgo` is a rich MongoDB driver that facilitates developers to write applications
    that talk to MongoDB without the need for the Mongo shell. The Go application
    can talk easily with MongoDB for all its CRUD operations using the `mgo` driver.
    It is an open-source implementation that can be used and modified freely. It is
    maintained by Labix. We can think it of as a wrapper around the MongoDB API. Installing
    the package is very simple, refer to the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This installs the package in `$GOPATH`. Now, we can refer the package to our
    Go programs, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us write a simple program that talks to MongoDB and inserts  `The Dark
    Knight` movie record:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'If you observe the code, we imported the `mgo` package as well as the `bson`
    package. Next, we created the structs that model our JSON to be inserted into
    the DB. In the main function, we created a session using the **`mgo.Dial` **function.
    After that, we fetched a collection using the `DB` and `C` functions in a chained
    manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `c` stands for collection. We are fetching the movies collection from `appdb`.Then,
    we are creating a struct object by filling in data. Next, we used the **`Insert` **function
    on the `c` collectionto insert `darkNight` data into the collection. This function
    can also take a list of struct objects to insert a batch of movies. Then, we used
    the **`Find` **function on the collection to read a movie with a given criteria.
    Here, the criteria (querying) is formed differently compared to the one we used
    in the shell. Since Go is not the JavaScript shell, we need a translator that
    can convert a normal filter query to the MongoDB understandable query. The **`bson.M` **function
    is designed for that in `mgo` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'But, what if we need to perform advanced queries with operators? We can do
    this by just replacing the plain JSON syntax with the `bson.M` function. We can
    find a movie from the database whose budget is more than $150,000,000with this
    query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: If you contrast this with the shell command, we just added `bson.M` in front
    of the JSON query and wrote the remaining query as it is. The operator symbol
    should be a string here (`"$gt"`).
  prefs: []
  type: TYPE_NORMAL
- en: 'One more notable thing in the struct definition is that we added a `bson:identifier`
    tag to each field. Without this, Go stores the BoxOffice as boxoffice. So, in
    order for Go to maintain the CamelCase, we add these tags. Now, let us run this
    program and see the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The output looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The result from a query can be stored in a new struct and can be serialized
    to JSON for the client to use.
  prefs: []
  type: TYPE_NORMAL
- en: RESTful API with Gorilla Mux and MongoDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapters, we explored all the possible ways of building a RESTful
    API. We first looked into HTTP routers, then web frameworks. But as a personal
    choice, in order to make our API lightweight, one prefers Gorilla Mux as the default
    choice and `mgo` for the MongoDB driver. In this section, we are going to build
    a proper movies API with an end-to-end integration of the database and HTTP router.
    We saw how to create a new resource and retrieve it back using Go and MongoDB.
    Using that knowledge, let us write this program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us name this program `movieAPI.go` and run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we can make a `POST` API request using curl or Postman to create a new
    movie:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This returns the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Our movie is successfully created. Here, the ID that is returned is generated
    by the `mgo` package. MongoDB expects the driver to provide the unique ID. If
    it''s not provided, then `Db` creates one itself. Now, let us make a `GET` API
    request using curl:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'It returns the same data that we got while creating the resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: A lot of things are happening in the preceding program. We will explain it in
    detail in the upcoming sections.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding program, the trivial logic for assigning the correct status
    codes is skipped in `PostMovie` for the sake of simplicity. The reader can feel
    free to modify the program to add the correct status codes for operations (200
    OK, 201 Created, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: At first, we are importing the necessary packages for our program. We imported `mgo`
    and `bson` for MongoDB-related implementation, Gorilla Mux for the HTTP router
    encoding/JSON, and ioutil for reading and writing JSON in the life cycle of an
    HTTP request.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we created a struct called **`DB` **that stores the session and collection
    information of MongoDB. We need to have this in order to have a global session
    and use it for multiple things instead of creating a new session (client connection).
    Take a look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: We need this because multiple HTTP handlers of Mux need this information. This
    is a simple trick of attaching common data to different functions. In Go, we can
    create a struct and add functions to it so that data in the struct is accessible
    in the functions. Then, we declared the structs that hold the information of the
    nested JSON for a movie. In Go, in order to create a nested JSON structure, we
    should nest the structures too.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we defined two functions on the `DB` struct. We will use these functions
    as handlers for the Gorilla Mux router later. These two functions can access session
    and collection information without creating a new one. The **`GetMovie` **handler
    function reads the data from MongoDB and returns JSON back to the client. **`PostMovie` **creates
    a new resource (movie here) in the database in a collection called `moviex`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, coming to the main function, we are creating the session and collection
    here. The `session` will be constant throughout the program's lifetime. But if
    needed, handler functions can override the collection by using a `session` variable.
    This allows us to write reusable database parameters. Then, we created a new router
    and attached handler functions and routes using **`HandleFunc`. **Then, we created
    a server that runs on the `8000` port of localhost.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `PostMovie`,we are creating a new hash ID using **`bson.NewObjectId()` **of
    the `mgo` function. This function returns the new hash each and every time we
    call it. We then pass this to the struct that we insert into the DB. We insert
    a document in the collection using the **`collection.Insert`** moviefunction.
    This returns an error if something goes wrong. For sending a message back, we
    are marshaling a struct using `json.Marshal`. If you carefully observe the structure
    of the `Movie` struct, it is like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The identifier on the right side, ``json:"id" bson:"_id,omitempty"``, is a helper
    to show how to serialize when marshaling or unmarshaling is performed on the struct.
    The `bson`tag shows how to insert the fields into MongoDB. `json`shows what format
    our HTTP handler should receive and send data from and to the client respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `GetMovie`, we are fetching the ID passed as the path parameter using the `Mux.vars`map.
    We cannot directly pass the ID to MongoDB because it expects a BSON object instead
    of a plain string. In order to achieve that, we use the **`bson.ObjectIdHex` **function.
    Once we get the movie of the given ID, that will be loaded into the struct object.
    Next, we serialize it to JSON using the **`json.Marshal` **function and will send
    it back to the client. We can easily add `PUT` (update) and `DELETE` methods to
    the preceding code. We just need to define two more handlers, as shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The approach is exactly the same, except the DB methods of `mgo` are different.
    Here, we used the `Update` and `Remove` functions. Since these are not important
    ones, we can just send the status back to the client with no body. For those handlers
    to be active, we need to add these two lines in the main block of the preceding
    program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The complete code for these additions is available in the `chapter5/movieAPI_updated.go`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Boosting the querying performance with indexing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We all know that while reading a book, indexes are very important. When we try
    to search for a topic in the book, we first roll our eyes through the index page.
    If the index is found, then we go to the specific page number for that topic.
    But there is a drawback here. We are using additional pages for the sake of this
    indexing. Similarly, MongoDB needs to go through all the documents whenever we
    query for something. If the document stores indexes for important fields, it can
    give back data to us quickly. At the same time, we are wasting extra space for
    indexing.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the computing field, the B-tree is an important data structure to implement
    indexing because it can categorize nodes. By traversing that tree, we can find
    the data we need in fewer steps. We can create an index using the `createIndex`
    function provided by MongoDB. Let us take an example of students and their scores
    in an examination. We will be doing `GET` operations more frequently with the
    sorting of scores. The indexing for this scenario can be visualized in this form.
    Take a look at the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b04cf3da-323c-4ca5-81d2-67fd41c87303.png)'
  prefs: []
  type: TYPE_IMG
- en: This is the official example given by the MongoDB website. The score is the
    field to be indexed because of frequent use. Once it is indexed, the database
    stores the address for each document in a binary tree. Whenever someone queries
    this field, it checks for the range operator (in this case, it's `$lt`), traverses
    the binary tree, and gets the addresses of documents in shorter steps. Since the
    scoreis indexed, the sort operations are less costly. So, the time that it takes
    for the database to return the sorted (ascending or descending) result is shorter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Coming to our previous examples of the movies API, we can create indexes for
    data. By default, all `_id`fields are indexed, here using mongo shell to show
    that. Previously, we treated the year field as a string. Let us modify that to
    an integer and index it. Launch mongo shell using `mongo` command. Use a new mongo
    database and insert one document into it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Insert one more similar document with the different data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let us add indexing to the year with the `createIndex` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'This single line adds the magic for retrieving the database records faster.
    Now, all the queries related to year leverage the indexing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: There is no difference in the query result. But the lookup mechanism for documents
    by `MongoDB` has changed by indexing. For a larger number of documents, that could
    reduce the lookup time drastically.
  prefs: []
  type: TYPE_NORMAL
- en: Indexing comes with a cost. Some queries run very slowly on different fields
    if indexing is not done properly. We can also have compound indexes in MongoDB
    that can index multiple fields.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to see the time of execution of a query, use the `explain` function
    after a `query` function. For example, `db.movies.find({year: {$lt: 2010}}).explain("executionStats")`.
    This explains the winning plan for a query, the time taken in milliseconds, indexes
    used, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: See the performance of indexed and non-indexed data using the `explain` function.
  prefs: []
  type: TYPE_NORMAL
- en: Designing an e-commerce data document model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Up until now, we have seen how to interact with MongoDB and perform CRUD operations
    for our REST API. Here, we are going to define a real-world JSON document that
    can be implemented by MongoDB. Let us lay down the design of JSON for an e-commerce
    problem. These five components are a must for any e-commerce design:'
  prefs: []
  type: TYPE_NORMAL
- en: Product
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customer/user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Category
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Order
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Review
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let us see a schema of each and every component:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Product:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Category:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'User:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Review:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: All the preceding schemas are to give an idea of how an e-commerce REST service
    can be designed. All the necessary fields should be included in the final data.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the preceding JSON is not true JSON, but the form used in the Mongo
    shell. Please observe that difference while creating the service. The schema is
    given so that the reader can see how e-commerce relational data is designed.
  prefs: []
  type: TYPE_NORMAL
- en: Since we defined the schema, there is a coding exercise for the reader. Can
    you create a REST service with the preceding schema by leveraging the knowledge
    we gained in the beginning sections of this chapter? Anyway, we will implement
    this model in other databases in upcoming chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, we started the chapter with an introduction to MongoDB and how it solves
    the problems of the modern web. MongoDB is a NoSQL database that is different
    from traditional relational databases. Then, we learned how to install MongoDB
    on all platforms and how to start the Mongo server. We then explored the features
    of the Mongo shell. The Mongo shell is a tool for quick checking or performing
    CRUD operations and many other operations in MongoDB. We looked at operator symbols
    for querying. We next introduced Go's MongoDB driver called `mgo`and learned its
    usages. We created a persistent movies API with the help of `mgo` and MongoDB.
    We saw how to map a Go struct to a JSON document.
  prefs: []
  type: TYPE_NORMAL
- en: Not all the queries are efficient in MongoDB. So, for boosting the query performance,
    we saw the indexing mechanism that reduces the document fetching time by arranging
    the documents in the order of a B-tree. We saw how to measure the execution time
    of a query using the `explain` command. Finally, we laid out an e-commerce document
    design by providing the BSON (Mongo shell's JSON).
  prefs: []
  type: TYPE_NORMAL
