- en: Chapter 7. Design Patterns in Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Design Patterns simplify building software by reusing successful designs and
    architectures. Patterns build on the collective experience of software engineers
    and architects. When encountered with a problem which needs new code to be written,
    an experienced software architect tends to make use of the rich ecosystem of available
    design/architecture patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Patterns evolve when a specific design proves successful in solving certain
    classes of problems repeatedly. When experts find that a specific design or architecture
    helps them to solve classes of related problems consistently, they tend to apply
    it more and more, codifying the structure of the solution into a pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Python, being a language which supports dynamic types, and high-level object
    oriented structures like classes and metaclasses, first-class functions, co-routines,
    callable objects, and so on, is a very rich playground for constructing reusable
    design and architecture patterns. In fact, as opposed to languages like C++ or
    Java, you would often find there are multiple ways of implementing a specific
    design pattern in Python. Also, more often than not, you would find that the Pythonic
    ways of implementing a pattern is more intuitive and illustrative than, say, copying
    a standard implementation from C++/Java into Python.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter's focus is mostly on this latter aspect—illustrating how one can
    build design patterns which are more Pythonic than what usual books and literature
    on this topic tend to do. It doesn't aim to be a comprehensive guide to design
    patterns, though we would be covering most of the usual aspects as we head into
    the content.
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics we plan to cover in this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Design patterns elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Categories of design patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pluggable hashing algorithms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summing up pluggable hashing algorithms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Patterns in Python – Creational
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Singleton pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Borg pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Factory pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Prototype pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Builder pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Patterns in Python – Structural
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Adapter pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Facade pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Proxy pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Patterns in Python – Behavioral
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Iterator pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Observer pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The State pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design patterns - Elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A design pattern attempts to record those aspects of a recurring design in object-oriented
    systems that solve a problem or a class of problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we inspect design patterns, we find that almost all of them have the following
    elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Name**: A well-known handle or title, which is commonly used to describe
    the pattern. Having standard names for design patterns aids communication and
    increases our design vocabulary.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Context**: This is the situation in which the problem arises. A context can
    be generic like *develop a web application software*, or specific like *Implementing
    resource-change notification in a shared memory implementation of the publisher-subscriber
    system*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Problem**: Describes the actual problem that the pattern is applied for.
    A problem can be described in terms of its forces, which are as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Requirements**: The requirements that the solution should fulfill, for example,
    the *Publisher-subscriber pattern implementation must support HTTP*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Constraints**: The constraints to the solution, if any, for example, the
    *Scalable peer-to-peer publisher pattern should not exchange more than three messages
    for publishing a notification*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Properties**: The properties of the solution which are desirable to have,
    for example, *The solution should work equally well on the Windows and Linux platforms*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Solution**: Shows the actual solution to the problem. It describes the structure
    and responsibilities, the static relationships, and the runtime interactions (collaborations)
    of the elements making up the solution. A solution should also discuss what *forces*
    of the problem it solves, and what it doesn''t. A solution should also try to
    mention its consequences, that is, the results and trade-offs of applying a pattern.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A design pattern solution almost never resolves all the forces of the problem
    leading to it, but leaves some of them open to related or alternate implementations.
  prefs: []
  type: TYPE_NORMAL
- en: Categories of design patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Design patterns can be categorized in different ways according to the criteria
    chosen. A commonly accepted way of categorizing is by using the criterion of purpose
    of the pattern. In other words, we ask the pattern what class of problems the
    pattern solves.
  prefs: []
  type: TYPE_NORMAL
- en: 'This kind of categorization gives us three neat varieties of pattern classes.
    These are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Creational**: These patterns solve the problems associated with object creation
    and initialization. These are problems that occur the earliest in the life cycle
    of problem solving with objects and classes. Take a look at the following examples:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The Factory pattern**: The "How do I make sure I can create related class
    instances in a repeatable and predictable fashion?" question is solved by the
    Factory class of patterns'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The Prototype pattern**: The "What is a smart approach to instantiate an
    object, and then create hundreds of similar objects by just copying across this
    one object ?" question is solved by the Prototype patterns'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Singleton and related patterns**: The "How do I make sure that any instance
    of a class I create is created and initialized just once" or "How do I make sure
    that any instances of a class share the same initial state ?" questions are solved
    by the Singleton and related patterns'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Structural**: These patterns concern themselves with composition and assembling
    of objects into meaningful structures, which provides the architect and developer
    with reusable behaviors, where "the whole is more than the sum of its parts".
    Naturally, they occur in the next step of problem solving with objects, once they
    are created. Examples of such problems are as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The Proxy pattern**: "How do I control access to an object and its methods
    via a wrapper, behavior on top?"'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The Composite pattern**: "How can I represent an object which is made of
    many components at the same time using the same class for representing the part
    and the whole—for example, a Widget tree ?"'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Behavioral**: These patterns solve the problems originating with runtime
    interactions of objects, and how they distribute responsibilities. Naturally,
    they occur in the later stage, once the classes are created, and then combined
    into larger structures. Here are a couple of examples:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Using the Median pattern in such case**: "Ensure that all the objects use
    loose coupling to refer to each other at runtime to promote run-time dynamism
    for interactions"'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Using the Observer pattern in such case**: "An object wants to be notified
    when the state of a resource changes, but it does not want to keep polling the
    resource to find this out. There may be many such instances of objects in the
    system"'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The order of Creational, Structural, and Behavioral patterns implicitly embed
    the life cycle of objects in a system at runtime. Objects are first created (Creational),
    then combined into useful structures (Structural), and then they interact (Behavioral).
  prefs: []
  type: TYPE_NORMAL
- en: Let us now turn our attention to the subject matter of this chapter, namely,
    implementing Patterns in Python in Python's own inimitable way. We will look at
    an illustrative example to get the matter going.
  prefs: []
  type: TYPE_NORMAL
- en: Pluggable hashing algorithms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let us look at the following problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'You want to read data from an input stream—a file or network socket—and hash
    the contents in a chunked manner. You write some code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All code is in Python3, unless explicitly mentioned otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: So that works, as expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s say you want a more reusable and versatile implementation, one that
    will work with multiple hashing algorithms. You first attempt to modify the previous
    code, but quickly realize that this means rewriting a lot of code, which is not
    a very smart way of doing it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You realize that you can reuse a lot of code by using a class. Being an experienced
    programmer, you may end up with something like this after a few iterations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'First lets try with `md5`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now with `sha1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As it must be evident by now, you can build different hasher objects, each with
    a specific algorithm, which will return the corresponding hash digest of the stream
    (in this case, a file).
  prefs: []
  type: TYPE_NORMAL
- en: Now lets summarize what we just did here.
  prefs: []
  type: TYPE_NORMAL
- en: We first developed a function, `hash_stream`, which took in a stream object,
    and hashed it chunk-wise using the `md5` algorithm. We then developed a class
    named `StreamHasher`, which allowed us to configure it using one algorithm at
    a time, thereby making the code more reusable. We obtained the hash digest by
    way of the method `get_hash`, which accepts the stream object as argument.
  prefs: []
  type: TYPE_NORMAL
- en: Now let us turn our attention to what more Python can do for us.
  prefs: []
  type: TYPE_NORMAL
- en: Our class is versatile with respect to different hashing algorithms, and is
    definitely more reusable, but is there a way to call it as if it were a function
    ? That would be rather neat, wouldn't it?
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a slight reimplementation of our `StreamHasher` class, which does just
    that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: What did we do in the last code ? We simply renamed the `get_hash` function
    as `Get_Call`. Let us see what effect this has.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We are able to call the instance of the class as if it were a function by simply
    passing the file object to it.
  prefs: []
  type: TYPE_NORMAL
- en: So our class not only gives us reusable and versatile code, but also acts as
    if it were a function. This is done by making our class a callable type in Python
    by simply implementing the magic method `__call__` .
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Callables** in Python are any object that can be called. In other words,
    `x` is a callable if we can perform `x()`—with or without params depending upon
    how the `__call__` method is overridden. Functions are the simplest and most familiar
    callables.'
  prefs: []
  type: TYPE_NORMAL
- en: In Python, `foo(args)` is a syntactic sugar for `foo.__call__(args)`.
  prefs: []
  type: TYPE_NORMAL
- en: Summing up pluggable hashing algorithm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So what does the previous example illustrate? It illustrates the power of Python
    in taking an existing problem, which would be solved traditionally in other programming
    languages, in a more exotic and powerful way due to the power of Python and the
    way it does things—in this case, by making any object callable by overriding a
    special method.
  prefs: []
  type: TYPE_NORMAL
- en: But what is the pattern we have achieved here? We discussed in the beginning
    of the chapter that something is a pattern only if it solves a class of problems.
    Is there a pattern hidden in this particular illustration?
  prefs: []
  type: TYPE_NORMAL
- en: 'Yes there is—this is an implementation of the Strategy behavioral pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Strategy pattern is used when we need different behaviors from a class and
    we should be able to configure a class with one of many available behaviors or
    algorithms*.'
  prefs: []
  type: TYPE_NORMAL
- en: In this particular case, we needed a class which supports different algorithms
    to perform the same thing—hashing data from a stream using chunks, and returning
    the digest. The class accepted the algorithm as a parameter, and since all algorithms
    support the same method for returning data (the method `hexdigest`), we were able
    to implement the class in a very simple way.
  prefs: []
  type: TYPE_NORMAL
- en: Let us continue our journey to find out what are some other interesting patterns
    we can write using Python, and its unique way of solving problems. We will follow
    the order of the Creational, Structural, and Behavioral patterns in this journey.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our approach to the discussion on patterns that follows is very pragmatic. It
    may not use the formal language used by the popular **Gang-of-four** (**G4**)
    patterns—the most elemental approach to Design Patterns. Our focus is on demonstrating
    the power of Python in building patterns rather than getting the formalisms right.
  prefs: []
  type: TYPE_NORMAL
- en: Patterns in Python – Creational
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will take a look at a few of the common creational patterns.
    We will start with Singleton, and then go on to Prototype, Builder, and Factory,
    in that order.
  prefs: []
  type: TYPE_NORMAL
- en: The Singleton pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Singleton pattern is one of the most well-known and easily understood patterns
    in the entire pantheon of design patterns. It is usually defined as:'
  prefs: []
  type: TYPE_NORMAL
- en: '*A Singleton is a class which has only one instance and a well-defined point
    of access to it*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The requirements of a Singleton can be summarized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A class must have only one instance accessible via a well-known access point
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The class must be extensible by inheritance without breaking the pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The simplest Singleton implementation in Python is shown next. It is done by
    overriding the `__new__` method of the base `object` type:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we would be requiring this check for a while, let us define a function
    for the same:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let us see if our Singleton implementation satisfies the second requirement.
    We will define a simple subclass to test this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Cool! So our simple implementation passes the test. Are we done here now?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, the point with Python, as we discussed before, is that it provides a
    number of ways to implement patterns due to its dynamism and flexibility. So,
    let us keep up with the Singleton for a while, and see if we can get some illustrative
    examples which would give us insights into the power of Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The preceding implementation moves the logic of creating a Singleton to the
    type of the class, namely, its metaclass.
  prefs: []
  type: TYPE_NORMAL
- en: We first create a type for Singletons, named `MetaSingleton`, by extending type
    and overriding the `__init__` and `__call__` methods on the metaclass. Then we
    declare the `SingletonM` class, `SingletonM`, as using the metaclass.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a peep into what is happening behind the scenes in the new implementation
    of the Singleton:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Initializing a class variable**: We can either do it at the class level (just
    after the class declaration) as we saw in previous implementation, or we can put
    it in the metaclass `__init__` method. This is what we are doing here for the
    `_instance` class variable, which will hold the single instance of the class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Overriding class creation**: One can either do it at the class level by overriding
    the `__new__` method of class as we saw in previous implementation, or, equivalently,
    do it in the metaclass by overriding its `__call__` method. This is what the new
    implementation does.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When we override a class's `__call__` method, it affects its instance, and instances
    become callable. Similarly, when we override a metaclass's `_call_` method, it
    affects its classes, and modifies the way the classes are called—in other words,
    the way the class creates its instances.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the pros and cons in the metaclass approach over the
    class approach:'
  prefs: []
  type: TYPE_NORMAL
- en: One benefit is that we can create any number of new top-level classes which
    get Singleton behavior via the metaclass. Using the default implementation, every
    class has to inherit the top-level class Singleton or its subclasses to obtain
    Singleton behavior. The metaclass approach provides more flexibility with respect
    to class hierarchies.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, the metaclass approach can be interpreted as creating slightly obscure
    and difficult-to-maintain code as opposed to the class approach. This is because
    the number of Python programmers who understand metaclasses and metaprogramming
    are less when compared to those who understand classes. This may be a disadvantage
    with the metaclass solution.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now let us think out of the box, and see if we can solve the Singleton problem
    in a little different way.
  prefs: []
  type: TYPE_NORMAL
- en: The Singleton – do we need a Singleton?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let us paraphrase the first requirement of a Singleton in a way slightly different
    from the original:'
  prefs: []
  type: TYPE_NORMAL
- en: '*A class must provide a way for all its instances to share the same initial
    state.*'
  prefs: []
  type: TYPE_NORMAL
- en: To explain that, let us briefly look at what a Singleton pattern actually tries
    to achieve.
  prefs: []
  type: TYPE_NORMAL
- en: When a Singleton ensures it has only one instance, what it guarantees is that
    the class provides one single state when it is created and initialized. In other
    words, what a Singleton actually gives is a way for a class to ensure a single
    shared state across all its instances.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, the first requirement of the Singleton can be paraphrased in
    a slightly different form, which has the same end result as the first form.
  prefs: []
  type: TYPE_NORMAL
- en: '*A class must provide a way for all its instances to share the same initial
    state*'
  prefs: []
  type: TYPE_NORMAL
- en: '*The technique of ensuring just a single actual instance at a specific memory
    location is just one way of achieving this.*'
  prefs: []
  type: TYPE_NORMAL
- en: Ah! So what has been happening so far is that we have been expressing the pattern
    in terms of the implementation details of lesser flexible and versatile programming
    languages, really. With a language like Python, we need not stick pedantically
    to this original definition.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us look at the following class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This pattern ensures that when you create a class, you specifically initialize
    all of its instances with a shared state which belongs to the class (since it
    is declared at the class level).
  prefs: []
  type: TYPE_NORMAL
- en: What we really care about in a Singleton is actually this shared state, so `Borg`
    works without worrying about all instances being exactly the same.
  prefs: []
  type: TYPE_NORMAL
- en: Since this is Python, it does this by initializing a shared state dictionary
    on the class, and then instantiating the instance's dictionary to this value,
    thereby ensuring that all instances share the same state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a specific example of `Borg` in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: So using `Borg`, we managed to create a class whose instances share the same
    state, even though the instances are actually not the same. And the state change
    was propagated across the instances; as the preceding example shows, when we change
    the value of state in `i1`, it also changes in `i2`.
  prefs: []
  type: TYPE_NORMAL
- en: What about dynamic values? We know it will work in a Singleton, since it's the
    same object always, but what about the Borg?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: So we attached a dynamic attribute `x` to instance `i1`, and it appeared in
    instance `i2` as well. Neat!
  prefs: []
  type: TYPE_NORMAL
- en: 'So let''s see if there are any benefits of `Borg` over Singleton:'
  prefs: []
  type: TYPE_NORMAL
- en: In a complex system where we may have multiple classes inheriting from a root
    Singleton class, it may be difficult to impose the requirement of a single instance
    due to import issues or race conditions—for example, if a system is using threads.
    A Borg pattern circumvents these problems neatly by doing away with the requirement
    of a single instance in memory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Borg pattern also allows for simple sharing of state across the Borg class
    and all its subclasses. This is not the case for a Singleton, since each subclass
    creates its own state. We will see an example illustrating this next.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: State sharing – Borg versus Singleton
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A Borg pattern always shares the same state from the top class (Borg) down to
    all the subclasses. This is not the case with a Singleton. Let us see an illustration.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this exercise, we will create two subclasses of our original Singleton
    class, namely, `SingletonA` and `SingletonB`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us create a subclass of `SingletonA`, namely, `SingletonA1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now lets create instances:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us attach a dynamic property, `x`, with a value `100` to `a`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us check if this is available on the instance `a1` of the subclass `SingletonA1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Good! Now let us check if it is available on the instance `b`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Oops! So it appears that `SingletonA` and `SingletonB` don't share the same
    state. This is why a dynamic attribute that is attached to an instance of `SingletonA`
    appears in the instance of its sub-classes, but doesn't appear on the instance
    of a sibling or peer subclass namely `SingletonB` – because it is an a different
    branch of the class hierarchy from the top-level `Singleton` class.
  prefs: []
  type: TYPE_NORMAL
- en: Let us see if the Borgs can do any better.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s create the classes and their instances:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s attach a dynamic attribute x to a with value 100:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s check if the instance of the sibling class Borg also gets it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This proves that the Borg pattern is much better at state sharing across classes
    and sub-classes than the Singleton pattern, and it does so without a lot of fuss
    or the overhead of ensuring a single instance.
  prefs: []
  type: TYPE_NORMAL
- en: Let us now move on to other creational patterns.
  prefs: []
  type: TYPE_NORMAL
- en: The Factory pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Factory pattern solves the problem of creating instances of related classes
    to another class, which usually implements the instance creation via a single
    method, usually, defined on a parent Factory class and overridden by subclasses
    (as needed).
  prefs: []
  type: TYPE_NORMAL
- en: The Factory pattern provides a convenient way for the client (user) of a class
    to provide a single entry point to create instances of classes and subclasses,
    usually, by passing in parameters to a specific method of the `Factory` class
    namely the Factory Method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us look at a specific example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We have created a general `Employee` class with some attributes and three subclasses,
    namely, `Engineer`, `Accountant`, and `Admin`.
  prefs: []
  type: TYPE_NORMAL
- en: Since all of them are related classes, a `Factory` class is useful to abstract
    away the creation of instances of these classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is our `EmployeeFactory` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The class provides a single `create` factory method, which accepts a `name`
    parameter, which is matched to the class's name and instance created accordingly.
    The rest of the arguments are parameters required for instantiating the class's
    instance, which is passed unchanged to its constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us see our `Factory` class in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are a few interesting notes about our `Factory` class:'
  prefs: []
  type: TYPE_NORMAL
- en: A single factory class can create instances of any class in the Employee hierarchy.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the Factory pattern, it is conventional to use one `Factory` class associated
    to a class family (a class and its subclass hierarchy). For example, a `Person`
    class could use a `PersonFactory`, an automobile class—`AutomobileFactory`, and
    so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Factory method is usually decorated as a `classmethod` in Python. This
    way it can be called directly via the class namespace. For example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In other words, an instance of the `Factory` class is really not required for
    this pattern.
  prefs: []
  type: TYPE_NORMAL
- en: The Prototype pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Prototype design pattern allows a programmer to create an instance of a
    class as a template instance, and then create new instances by copying or cloning
    this Prototype.
  prefs: []
  type: TYPE_NORMAL
- en: 'A Prototype is most useful in the following cases:'
  prefs: []
  type: TYPE_NORMAL
- en: When the classes instantiated in a system are dynamic, that is, they are specified
    as part of a configuration, or can otherwise change at runtime.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the instances only have a few combinations of initial state. Rather than
    keeping track of the state and instantiating an instance each time, it is more
    convenient to create prototypes matching each state and clone them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Prototype object usually supports copying itself via the `clone` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a simple implementation of the Prototype in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The `clone` method is implemented using the `copy` module, which copies the
    object deeply and returns a clone.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us see how this works. For that we need to create a meaningful subclass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Prototype – deep versus shallow copy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now let us take a deeper look at the implementation details of our Prototype
    class.
  prefs: []
  type: TYPE_NORMAL
- en: You may notice that we use the `deepcopy` method of the `copy` module to implement
    our object cloning. This module also has a `copy` method, which implements shallow
    copying.
  prefs: []
  type: TYPE_NORMAL
- en: If we implement shallow copying, you will find that all objects are copied via
    a reference. This is fine for immutable objects such as strings or tuples, as
    they can't be changed.
  prefs: []
  type: TYPE_NORMAL
- en: However, for mutables like lists or dictionaries, this is a problem since the
    state of the instance is shared instead of being wholly owned by the instance,
    and any modification of a mutable in one instance will modify the same object
    in the cloned instances as well!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us see an example. We will use a modified implementation of our Prototype
    class, which uses shallow copying, to demonstrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The `SRegister` class inherits from the new prototype class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us add a name to the names register of instance `r1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s checking `r2.names`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Oops! This is not what we wanted, but due to the shallow copy, both `r1` and
    `r2` end up sharing the same `names` list, as only the reference is copied over,
    not the entire object. This can be verified by a simple inspection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: A deep copy, on the other hand, calls `copy` recursively for all objects contained
    in the cloned (copied) object, so nothing is shared, but each clone will end up
    having its own copy of all the referenced objects.
  prefs: []
  type: TYPE_NORMAL
- en: Prototype using metaclasses
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We've seen how to build the Prototype pattern using classes. Since we've already
    seen a bit of meta-programming in Python in the Singleton pattern example, it
    helps to find if we can do the same in Prototype.
  prefs: []
  type: TYPE_NORMAL
- en: What we need to do is attach a `clone` method to all the Prototype classes.
    Dynamically attaching a method to a class like this can be done in its metaclass
    via the `__init__` method of the metaclass.
  prefs: []
  type: TYPE_NORMAL
- en: 'This provides a simple implementation of Prototype using metaclasses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The `PrototypeM` class now implements a Prototype pattern. Let''s see an illustration
    by using a subclass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'First we will create an `ItemCollection` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we will clone it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The clone is clearly a different object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'And it has its own copy of the attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Combining patterns using metaclasses
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It is possible to create interesting and customized patterns by using the power
    of metaclasses. The following example illustrates a type which is both a Singleton
    as well as a Prototype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Any class using this metaclass as its type would show both Singleton and Prototype
    behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'This may look a bit strange having a single class combine what looks like conflicting
    behaviors into one, since a Singleton allows only one instance and a Prototype
    allows cloning to derive multiple instances, but if we think of patterns in terms
    of their APIs then it begins to feel a bit more natural:'
  prefs: []
  type: TYPE_NORMAL
- en: Calling the class using the constructor would always return the same instance
    – it behaves like the Singleton pattern.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calling `clone` on the class's instance would always return cloned instances.
    The instances are always cloned using the Singleton instance as the source – it
    behaves like the Prototype pattern.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here, we have modified our `PrototypeM` class to now use the new metaclass:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Since `ItemCollection` continues to subclass `PrototypeM`, it automatically
    gets the new behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The `clone` method works as expected, and produces a clone:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'However, building an instance via the constructor always returns the Singleton
    (Prototype) instance only as it invokes the Singleton API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Metaclasses allow powerful customization of class creation. In this specific
    example, we created a combination of behaviors which included both Singleton and
    Prototype patterns into one class via a metaclass. The power of Python using metaclasses
    allows the programmer to go beyond traditional patterns and come up with such
    creative techniques.
  prefs: []
  type: TYPE_NORMAL
- en: The Prototype factory
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A prototype class can be enhanced with a helper **Prototype factory** or **registry
    class**, which can provide factory functions for creating prototypical instances
    of a configured family or group of products. Think of this as a variation of our
    previous Factory pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code for this class. See that we inherit it from `Borg` to share
    state automatically from the top of the hierarchy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us create a few subclasses of Prototype, whose instances which we can register
    on the factory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: We have two classes—one, a `Name` class another, an animal class, both of which
    inherit from `SPrototype`.
  prefs: []
  type: TYPE_NORMAL
- en: 'First create a name and animal object each:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Now, let us create an instance of the Prototype Factory.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s register the two instances on the factory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the factory is ready to clone any number of them from the configured instances:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The factory, rightfully, complains if we try to clone a class whose instance
    is not registered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The factory class shown here could be enhanced with a check for the existence
    of the `clone` method on the registered class to make sure any class that is registered
    is obeying the API of the Prototype class. This is left as an exercise to the
    reader.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is instructive to discuss a few aspects of this specific example we have
    chosen if the reader hasn''t observed them already:'
  prefs: []
  type: TYPE_NORMAL
- en: The `PrototypeFactory` class is a Factory class, so it is usually a Singleton.
    In this case, we have made it a Borg, as we've seen that `Borgs` do a better job
    in state sharing across class hierarchies.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Name` class and `Animal` class inherit from `SPrototype`, since their attributes
    are integers and strings which are immutable, so, a shallow copy is fine here.
    This is unlike our first Prototype subclass.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prototypes preserve the class creation signature in the prototypical instance
    namely the `clone` method. This makes it easy for the programmer, as he/she does
    not to have to worry about the class creation signature – the order and type of
    parameters to `__new__,` and hence, the `__init__` methods - but only has to call
    `clone` on an existing instance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Builder pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A Builder pattern separates out construction of an object from its representation
    (assembly) so that the same construction process can be used to build different
    representations.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, using a Builder pattern, one can conveniently create different
    types or representative instances of the same class, each using a slightly different
    building or assembling process.
  prefs: []
  type: TYPE_NORMAL
- en: Formally, the Builder pattern uses a `Director` class, which directs the `Builder`
    object to build instances of the target class. Different types (classes) of builders
    help to build slightly different variations of the same class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Our example shows three classes, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A `Room` and `Porch` class each representing a room and porch of a house—a room
    has windows and doors, and a porch has doors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `LegoHouse` class representing a toy example for an actual house (We are imagining
    a kid building a house with lego blocks here, having rooms and porches.) —The
    Lego house will consist of any number of rooms and porches.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let us try and create a simple `LegoHouse` instance with one room and one porch,
    each with default configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Are we done ? No! Notice that our `LegoHouse` is a class that doesn't fully
    construct itself in its constructor. The rooms and porches are not really built
    yet, only their counters are initialized.
  prefs: []
  type: TYPE_NORMAL
- en: 'So we need to build out the rooms and porches separately, and add them to the
    house. Let us do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Now you see that our house is fully built. Printing it displays not only the
    number of rooms and porches, but also details about them. All good!
  prefs: []
  type: TYPE_NORMAL
- en: Now, imagine that you need to build 100 such different house instances, each
    having different configurations of rooms and porches, and often, the rooms themselves
    having various numbers of windows and directions!
  prefs: []
  type: TYPE_NORMAL
- en: (Maybe you are building a mobile game which uses Lego Houses where cute little
    characters like Trolls or Minions stay and do interesting things, whatever.)
  prefs: []
  type: TYPE_NORMAL
- en: It is pretty clear from the example that writing code like the last one will
    not scale to solve the problem.
  prefs: []
  type: TYPE_NORMAL
- en: This is where the Builder pattern can help you. Let us start with a simple `LegoHouse`
    builder.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are the main aspects of this class:'
  prefs: []
  type: TYPE_NORMAL
- en: You configure the Builder class with the target class configuration—the number
    of rooms and porches in this case
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It provides a `build` method, which constructs and assembles (builds) the components
    of the house—in this case, `Rooms` and `Porches`, according to the specified configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `build` method returns the constructed and assembled house
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now building different types of Lego Houses with different designs of rooms
    and porches is just two lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'We will now build a similar house, but with rooms having two windows each:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s say you find you are continuing to build a lot of Lego Houses with this
    configuration. You can encapsulate it in a subclass of the Builder so that the
    preceding code itself is not duplicated a lot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the house configuration is *burned into* the new builder class, and building
    one is as simple as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also build many of them (say `100`, `50` for the Trolls and `50` for
    the Minions) as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'One can also create more exotic builder classes which do some very specific
    things. For example, here is a builder class which creates houses with rooms and
    porches always facing in the north direction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'And using Python''s multiple inheritance power, one can combine any such builders
    into new and interesting subclasses. Here, for example, is a builder that produces
    North-facing small houses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'As expected, it always produces North-facing, small houses with 2 windowed
    rooms repeatedly. Not very interesting maybe, but very reliable indeed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we conclude our discussion on Creational Patterns, let us summarize
    some interesting aspects of these creational patterns and their interplay, which
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Builder and Factory**: The Builder pattern separates out the assembling process
    of a class''s instance, from its creation. A Factory on the other hand is concerned
    with creating instances of different sub-classes belonging to same hierarchy using
    a unified interface. A builder also returns the built instance as a final step,
    whereas, a Factory returns the instance immediately, as there is no separate building
    step.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Builder and Prototype**: A Builder can, internally, use a prototype for creating
    its instances. Further instances from the same builder can then be cloned from
    this instance. For example, it is instructive to build a Builder class which uses
    one of our Prototype metaclasses to always clone a prototypical instance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Prototype and Factory**: A Prototype factory can, internally, make use of
    a Factory pattern to build the initial instances of the classes in question.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Factory and Singleton**: A Factory class is usually a Singleton in traditional
    programming languages. The other option is to make its methods a class or static
    method so there is no need to create an instance of the Factory itself. See that
    in our examples, we made it a Borg instead.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will now move on to the next class of patterns, namely, the Structural Patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Patterns in Python – Structural
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Structural patterns concern themselves with the intricacies of combining classes
    or objects to form larger structures, which are more than the sum of their parts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Structural patterns implement this by these two distinct ways:'
  prefs: []
  type: TYPE_NORMAL
- en: By using class Inheritance to compose classes into one. This is the static approach.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By using object composition at runtime to achieve combined functionality. This
    approach is more dynamic and flexible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python, by virtue of supporting multiple inheritance, can implement both of
    these very well. Being a language with dynamic attributes and using the power
    of magic methods, Python can also do object composition and the resultant method
    wrapping pretty well also. So, with Python, a programmer is indeed at a good place
    with respect to implementing structural patterns.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be discussing the following structural patterns in this section: Adapter,
    Facade, and Proxy.'
  prefs: []
  type: TYPE_NORMAL
- en: The Adapter pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As the name implies, the Adapter pattern wraps or adapts an existing implementation
    of a specific interface into another interface which a client expects. The Adapter
    is also called a **Wrapper**.
  prefs: []
  type: TYPE_NORMAL
- en: You very often adapt objects into interfaces or types you want when you program,
    most often without realizing this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at this list containing two instances of a fruit and its count:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Let us say you want to quickly find the number of fruits, given a fruit name.
    The list doesn't allow you to use the fruit as a key, which is the interface more
    suited to the operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'What do you do ? Well, you simply convert the list to a dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Voila! You got the object in a form that is more convenient for you, adapted
    to your programming needs. This is a kind of data or object adaption.
  prefs: []
  type: TYPE_NORMAL
- en: Programmers do such data or object adaptation almost continuously in their code
    without realizing it. Adaptation of code or data is more common than you think.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us consider a class Polygon, representing a regular or irregular Polygon
    of any shape:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: This preceding class describes a generic, closed Polygon geometric figure in
    geometry.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have implemented some of the basic methods such as `perimeter` and `is_regular`,
    the latter returning whether the Polygon is a regular one such as a hexagon or
    pentagon.
  prefs: []
  type: TYPE_NORMAL
- en: Let us say we want to implement specific classes for a few regular geometric
    shapes such as a triangle or rectangle. We can implement these from scratch, of
    course. However, since a Polygon class is available, we can try and reuse it,
    and adapt it to our needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us say the `Triangle` class requires the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`is_equilateral`: Returns whether the triangle is an equilateral one'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`is_isosceles`: Returns whether the triangle is an isosceles triangle'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`is_valid`: Implements the `is_valid` method for a triangle'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`area`: Implements the area method for a triangle'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Similarly the `Rectangle` class, needs the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`is_square`: Returns whether the rectangle is a square'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`is_valid`: Implements the `is_valid` method for a rectangle'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`area`: Implements the area method rectangle'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Following is the code for an adapter pattern, reusing the `Polygon` class for
    the `Triangle` and `Rectangle` classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code for the `Triangle` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Take a look at the following `Rectangle` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Now let's see the classes in action.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create an equilateral triangle for the first test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'An equilateral triangle is also isosceles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Lets calculate the area:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s try a triangle which is not valid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The dimensions show it is a straight line, not a triangle. The `is_valid` method
    is not implemented in the base class, hence, the subclasses need to override it
    to provide a proper implementation. In this case, we raise an exception if the
    triangle is invalid.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an illustration of the `Rectangle` class in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create a square:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: The `Rectangle`/`Triangle` classes shown here are examples of `class adapters`.
    This is because they inherit the class that they want to adapt, and provide the
    methods expected by the client, often delegating the computation to the base-class's
    methods. This is evident in the methods `is_equilateral` and `is_square` of the
    `Triangle` and `Rectangle` classes respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us look at an alternative implementation of the same classes—this time,
    via object composition, in other words, `object adapters`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'This class works similar to the other one, even though the internal details
    are implemented via object composition than class inheritance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'The main differences between this implementation and the class adapter are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The object adapter class doesn't inherit from the class we want to adapt from.
    Instead, it composes an instance of the class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any wrapper methods are forwarded to the composed instance. For example, the
    `perimeter` method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All attribute access of the wrapped instance has to be specified explicitly
    in this implementation. Nothing comes for free (since we are not inheriting the
    class. (For example, inspect the way we access the `sides` attribute of the enclosed
    `polygon` instance.).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Observe how we converted the previous `is_valid` method to a decorator in this
    implementation. This is because many methods carry out a first check on `is_valid`,
    and then perform their actions, so it is an ideal candidate for a decorator. This
    also aids rewriting of this implementation to a more convenient form, which is
    discussed next.
  prefs: []
  type: TYPE_NORMAL
- en: One problem with the object adapter implementation, as shown in the preceding
    implementation, is that any attribute reference to the enclosed adapted instance
    has to be made explicitly. For example, had we forgotten to implement the `perimeter`
    method for the `Triangle` class here, there wouldn't have been any method at all
    to call, as we aren't inheriting from the `Adapter` class.
  prefs: []
  type: TYPE_NORMAL
- en: The following is an alternate implementation, which makes use of the power of
    one of Python's magic methods, namely `__getattr__`, to simplify this. We are
    demonstrating this implementation on the `Rectangle` class`:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us look at examples using this class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: You can see that we are able to call the method `is_perimeter` on the `Rectangle`
    instance even though no such method is actually defined on the class. Similarly,
    `is_square` seems to work magically. What is happening here ?
  prefs: []
  type: TYPE_NORMAL
- en: The magic method `__getattr__` is invoked by Python on an object if it cannot
    find an attribute in the usual ways – which is by first looking up the object's
    dictionary, then its class's dictionary and so on. It takes a name, and hence,
    provides a hook on a class, to implement a way to provide method lookups by routing
    them to other objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, the `__getattr__` method does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Check for the attribute name in the `method_mapper` dictionary. This is a dictionary
    we have created on the class, which maps a method name that we want to call on
    the class (as key) to the actual method name on the wrapped instance (as value).
    If an entry is found, it is returned.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If no entry is found on the `method_mapper` dictionary, the entry is passed
    as such to the wrapped instance to be looked by the same name.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We use `getattr` in both cases to look up and return the attribute from the
    wrapped instance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attributes can be anything—data attributes or methods. For example, see how
    we refer to the `sides` attribute of the wrapped `polygon` instance as if it belonged
    to the `Rectangle` class in the method `area` and the `is_valid` decorator.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If an attribute is not present on the wrapped instance, it raises an `AttributeError`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Object adapters implemented using this technique are much more versatile, and
    lead to less amount of code than regular object adapters where every method has
    to be explicitly written and forwarded to the wrapped instance.
  prefs: []
  type: TYPE_NORMAL
- en: The Facade pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A facade is a structural pattern that provides a unified interface to multiple
    interfaces in a subsystem. The Facade pattern is useful where a system consists
    of multiple subsystems, each with its own interfaces, but presents some high-level
    functionality, which needs to be captured, as a general top-level interface to
    the client.
  prefs: []
  type: TYPE_NORMAL
- en: A classic example of an object of everyday life which is a Facade is an automobile.
  prefs: []
  type: TYPE_NORMAL
- en: For example, a car consists of an engine, power train, axle and wheel assembly,
    electronics, steering systems, brake systems, and other such components.
  prefs: []
  type: TYPE_NORMAL
- en: However, usually, you don't have to bother whether the brake in your car is
    a disc-brake, or whether its suspension is coil-spring or McPherson struts, do
    you?
  prefs: []
  type: TYPE_NORMAL
- en: 'This is because the car manufacturer has provided a Facade for you to operate
    and maintain the car which reduces the complexity and provides you with simpler
    sub-systems which are easy to operate by themselves- such as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The ignition system to start the car
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The steering system to maneuver it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The clutch-accelerator-brake system to control it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The gear and transmission system to manage the power and speed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A lot of complex systems around us are Facades. Like the car example, a computer
    is a Facade, an Industrial Robot is another. All factory control systems are facades,
    giving a few dashboards and controls for the engineer to tweak the complex systems
    behind it, and keep them running.
  prefs: []
  type: TYPE_NORMAL
- en: Facades in Python
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Python standard library contains a lot of modules which are good examples
    of Facades. The `compiler` module, which provides hooks to parse and compile the
    Python source code, is a Facade to the lexer, parser, ast tree generator, and
    the like.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an image of the help contents of this module:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Facades in Python](../Images/image00486.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the next page of the help contents, you can see how this module is a facade
    to other modules which are used to implement the functions defined in this package.
    (Look at "Package contents" at the bottom of the image):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Facades in Python](../Images/image00487.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Let us look at a sample code for a Facade pattern. In this example, we will
    model a Car with a few of its multiple subsystems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code for all the subsystems:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we have covered a good amount of the subsystems in a car, at
    least those which are essential.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code for the `Car` class, which combines them as a Facade with
    two methods, namely, to `start` and `stop` the car:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s build an instance of the `Car` first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now take the car out of the garage and go for a spin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: Car started.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have driven it for a while, we can stop the car. As you may have
    guessed, stopping is more involved than starting!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: Facades are useful for taking the complexity out of systems so that working
    with them becomes easier. As the preceding example shows, it would've been awfully
    difficult if we hadn't built the `start` and `stop` methods the way we have done
    in this example. These methods hide the complexity behind the actions involved
    with the subsystems in starting and stopping a `Car`.
  prefs: []
  type: TYPE_NORMAL
- en: This is what a Facade does best.
  prefs: []
  type: TYPE_NORMAL
- en: The Proxy pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A Proxy pattern wraps another object to control access to it. Some usage scenarios
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We need a virtual resource closer to the client, which acts in place of the
    real resource in another network, for example, a remote proxy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we need to control/monitor access to a resource, for example, a network
    proxy and an instance counting proxy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need to protect a resource or object (protection proxy) because direct access
    to it would cause security issues or compromise it, for example, a reverse proxy
    server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need to optimize access to results from a costly computation or network operation
    so that the computation is not performed every time, for example, a caching proxy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Proxy always implements the interface of the object it is proxying to – its
    target in other words. This can be either via inheritance or via composition.
    In Python, the latter can be done more powerfully by overriding the `__getattr__`
    method, as we've seen in Adapter example.
  prefs: []
  type: TYPE_NORMAL
- en: An instance-counting proxy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We will start with an example that demonstrates usage of the Proxy pattern
    for keeping track of instances of a class. We will reuse our `Employee` class
    and its subclasses from the Factory pattern here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We haven't duplicated the code for the employee subclasses, as these are already
    available in the Factory pattern discussion.
  prefs: []
  type: TYPE_NORMAL
- en: We have two classes here, namely, the `EmployeeProxy` and the original `factory`
    class modified to return instances of `EmployeeProxy` instead of Employee. The
    modified factory class makes it easy for us to create Proxy instances instead
    of having to do it ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: The proxy, as implemented here, is a composition or object proxy, as it wraps
    around the target object (employee) and overloads `__getattr__` to redirect attribute
    access to it. It keeps track of the count of instances by overriding the `__new__`
    and `__del__` methods for instance creation and instance deletion respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see an example of using the Proxy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This prints details of the engineer via proxy, since we have overridden the
    `__str__` method in the proxy class, which calls the same method of the employee
    instance.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s check the instance count now. This can be done either via the instances
    or via the class, since it is anyway referencing a class variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: Let's delete the instances, and see what happens!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The weak reference module in Python provides a proxy object which performs something
    very similar to what we have implemented, by proxying access to class instances.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us check the reference count of the new object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'Now create a weak reference to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'The `weakref` object acts in all respects like the object its proxying for:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'However, note that a `weakref` proxy doesn''t increase the reference count
    of the proxied object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: Patterns in Python – Behavioral
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Behavioral patterns are the last stage in the complexity and functionality of
    patterns. They also come last chronologically in object life cycle in a system
    since objects are first created, then built into larger structures, before they
    interact with each other.
  prefs: []
  type: TYPE_NORMAL
- en: These patterns encapsulate models of communication and interaction between objects.
    These patterns allow us to describe complex workflows that may be difficult to
    follow at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Typically, Behavioral patterns favor object composition over inheritance as
    usually, the interacting objects in a system would be from separate class hierarchies.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this brief discussion, we will look at the following patterns: **Iterator**,
    **Observer**, and **State**.'
  prefs: []
  type: TYPE_NORMAL
- en: The Iterator pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An iterator provides a way to access elements of a container object sequentially
    without exposing the underlying object itself. In other words, an iterator is
    a proxy that provides a single method of iterating over a container object.
  prefs: []
  type: TYPE_NORMAL
- en: Iterators are everywhere in Python, so there is no special need to introduce
    them.
  prefs: []
  type: TYPE_NORMAL
- en: All container/sequence types in Python, that is, list, tuple, str, and set implement
    their own iterators. Dictionaries also implement iterators over their keys.
  prefs: []
  type: TYPE_NORMAL
- en: In Python, an iterator is any object that implements the magic method `__iter__`,
    and also responds to the function iter returning the iterator instance.
  prefs: []
  type: TYPE_NORMAL
- en: Usually, the iterator object that is created is hidden behind the scenes in
    Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we iterate through a list like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'Internally, something very similar to the following happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'Every sequence type implements its own iterator type as well in Python. Examples
    for this are given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Lists**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: '**Tuples**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '**Sets**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'Even dictionaries come with their own special key iterator type in Python3:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'We will see a small example of implementing your own iterator class/type in
    Python now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'This preceding class is a prime number iterator, which returns prime numbers
    between two limits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'The Prime number iterator without the end limit is an infinite iterator. For
    example, the following iterator will return all prime numbers starting from `2`
    and will never stop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: However by combining it with the itertools module, one can extract specific
    data that one wants from such infinite iterators.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example here, we use it with the `islice` method of `itertools` to compute
    the first 100 prime numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, here are the first 10 prime numbers ending with 1 in the unit''s
    place using the `filterfalse` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'In a similar way, here are the first 10 palindromic primes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: The interested reader is referred to the documentation on the `itertools` module
    and its methods to find out fun and interesting ways to use and manipulate the
    data of such infinite generators.
  prefs: []
  type: TYPE_NORMAL
- en: The Observer pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Observer pattern decouples objects, but at the same time, allows one set
    of objects (Subscribers) to keep track of the changes in another object (the Publisher).
    This avoids one-to-many dependency and references while keeping their interaction
    alive.
  prefs: []
  type: TYPE_NORMAL
- en: This pattern is also called as **Publish-Subscribe**.
  prefs: []
  type: TYPE_NORMAL
- en: Here is a rather simple example using an `Alarm` class, which runs in its own
    thread and generates periodic alarms every second (by default). It also works
    as a `Publisher` class, notifying its subscribers whenever the alarm happens.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'Our subscriber is a simple `DumbClock` class, which subscribes to the `Alarm`
    object for its notifications, and using that, updates its time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s get these objects ticking:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First create the alarm with a notification period of one second. This allows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'Next create the `DumbClock` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, register the clock object on the alarm object as an observer so that
    it can receive the notifications:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the clock will keep receiving updates from the alarm. Every time you print
    the clock, it will show the current time correct to a second:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'After a while it will show you the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: Sleep for a while and print.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are some aspects to keep in mind when implementing observers:'
  prefs: []
  type: TYPE_NORMAL
- en: '**References to subscribers**: Publishers can choose to keep a reference to
    subscribers or use a Mediator pattern to get a reference when required. A Mediator
    pattern decouples many objects in a system from strongly referencing each other.
    In Python, for example, this could be a collection of weak references or proxies
    or an object managing such a collection if both publisher and subscriber objects
    are in the same Python runtime. For remote references, one can use a remote proxy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Implementing Callbacks**: In this example, the `Alarm` class directly updates
    the state of the subscriber by calling its `update` method. An alternate implementation
    is for the publisher to simply notify the subscribers, at which point they query
    the state of the Publisher using a `get_state` type of method to implement their
    own state change:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is the preferred option for a Publisher which may be interacting with subscribers
    of different types/classes. This also allows for decoupling of code from Publisher
    to Subscriber as the publisher doesn't have to change its code if the `update`
    or `notify` method of the Subscriber changes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Synchronous versus Asynchronous**: In this example, the notify is called
    in the same thread as the Publisher when the state is changed since the clock
    needs reliable and immediate notifications to be accurate. In an asynchronous
    implementation, this could be done asynchronously so that the main thread of the
    Publisher continues running. For example this may be the preferred approach in
    systems using asynchronous execution which returns a future object upon notification,
    but the actual notification may occur sometime later.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since we've already encountered asynchronous processing in [Chapter 5](part0040.xhtml#aid-164MG1
    "Chapter 5. Writing Applications That Scale"), on scalability, we will conclude
    our discussion on the Observer pattern with one more example, showing an asynchronous
    example where the Publisher and Subscriber interact asynchronously. We will be
    using the asyncio module in Python for this.
  prefs: []
  type: TYPE_NORMAL
- en: For this example, we will be using the domain of news publishing. Our publisher
    gets news stories from various sources as news URLs which are tagged to certain
    specific news channels. Examples of such channels could be - "sports", "international",
    "technology", "India", and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The news subscribers register for news channels of their interest, consuming
    news stories as URLs. Once they get a URL they fetch the data of the URL asynchronously.
    The publisher to subscriber notification too happens asynchronously.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the source code of our publisher:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: The publisher's `notify` method is asynchronous. It goes through list of channels,
    finds out the subscribers to each of them, and calls back the subscriber using
    its `callback` method, supplying it with the most recent data from the channel.
  prefs: []
  type: TYPE_NORMAL
- en: The `callback` method itself being asynchronous, it returns a future and not
    any final processed result. Further processing of this future occurs asynchronously
    inside the `fetch_urls` method of the subscriber.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the source code of the subscriber:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: Notice how both the `callback` and `fetch_urls` methods are both declared as
    asynchronous. The `callback` method passes the URL from the publisher to the `aiohttp`
    module's `GET` method which simply returns a future.
  prefs: []
  type: TYPE_NORMAL
- en: The future is appended a local list of futures, which is processed again asynchronously
    – by the `fetch_urls` method to get the URL data which is then appended to the
    local stories dictionary with the URL as the key.
  prefs: []
  type: TYPE_NORMAL
- en: Here is the asynchronous loop part of the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To get things started we create a publisher and add some news stories via specific
    URLs to couple of channels on the publisher:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'We then create two subscribers, one listening to the `sports` channel and the
    other to the `india` channel:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we create the asynchronous event loop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we add the tasks as co-routines to the loop to get the asynchronous loop
    to start its processing. We need to add the following three tasks:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`publisher.notify()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`subscriber.fetch_urls()`: one for each of the two subscribers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Since both the publisher and subscriber processing loops never exit we add
    a timeout the processing via its `wait` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: Here is our asynchronous Publisher and Subscriber(s) in action, on the console.
  prefs: []
  type: TYPE_NORMAL
- en: '![The Observer pattern](../Images/image00488.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We now move on to the last pattern in our discussion of design patterns, namely
    the State pattern.
  prefs: []
  type: TYPE_NORMAL
- en: The State pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A State pattern encapsulates the internal state of an object in another class
    (**state object**). The object changes its state by switching the internally encapsulated
    state object to different values.
  prefs: []
  type: TYPE_NORMAL
- en: A State object and its related cousin, **Finite State Machine** (**FSM**), allows
    a programmer to implement state transitions seamlessly across different states
    for the object without requiring complex code.
  prefs: []
  type: TYPE_NORMAL
- en: In Python, the State pattern can be implemented easily, since Python has a magic
    attribute for an object's class, namely, the `__class__` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: It may sound a bit strange, but in Python this attribute can be modified on
    the dictionary of the instance! This allows the instance to dynamically change
    its class, something which we can take advantage of to implement this pattern
    in Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a simple example showing this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: We were able to change the class of the object `c` at runtime. Now, in this
    example, this proved dangerous, since `C` and `D` are unrelated classes, so this
    is never a smart thing to do in such cases. This is evident in the way c forgot
    its method `f` when it changed to an instance of class `D` (`D` has no method
    `f`).
  prefs: []
  type: TYPE_NORMAL
- en: However, for related classes, and more specifically, subclasses of a parent
    class implementing the same interface, this gives a lot of power, and can be used
    to implement patterns like State.
  prefs: []
  type: TYPE_NORMAL
- en: In the following example, we have used this technique to implement the State
    pattern. It shows a computer which can switch from one state to another.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice how we are using an iterator to define this class since an iterator
    defines movement to the next position naturally by way of its nature. We are taking
    advantage of this fact to implement our state pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: Now let us define some concrete subclasses of the `ComputerState` class.
  prefs: []
  type: TYPE_NORMAL
- en: Each class can define a list of `next_states` which is a set of legal states
    the current state can switch to. It can also define a list of random states which
    are random legal states it can switch to once it has switched to the next state.
  prefs: []
  type: TYPE_NORMAL
- en: For example, here is the first state namely that of the `off` state of the computer.
    The next compulsory state is of course the `on` state. Once the computer is on,
    this state can move off to any of the other random states.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hence the definition is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, here are the definitions of the other state classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: Finally, here is the class for the Computer which uses the state classes to
    set its internal state.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are some interesting aspects of this implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '**State as an iterator**: We have implemented the `ComputerState` class as
    an iterator. This is because a state has, naturally, a list of immediate future
    states it can switch to and nothing else. For example, a computer in an `Off`
    state can move only to the `On` state next. Defining it as an iterator allows
    us to take advantage of the natural progression of an iterator from one state
    to next.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Random States**: We have implemented the concept of random states in this
    example. Once a computer moves from one state to its mandatory next state (On
    to Off, Suspend to WakeUp), it has a list of random states available to move on
    to. A computer that is On need not always be switched off. It can also go to Sleep
    (Suspend) or Hibernate.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Manual Change**: The computer can move to a specific state via the second
    optional argument of the `change` method. However, this is possible only if the
    state change is valid, otherwise an exception is raised.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will now see our State pattern in action.
  prefs: []
  type: TYPE_NORMAL
- en: 'The computer starts being off, of course:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us see some automatic state changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: 'And now, let the state machine decide its next states—note these are random
    states till the computer enters a state where it has to mandatorily move on to
    the next state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the state is Hibernate, which means the next state has to be On as it is
    a compulsory next state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the state is Off, which means the next state has to be On:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are all random state changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: Now, since the underlying state is an iterator, one can even iterate on the
    state using a module like itertools.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of this – iterating on the next five states of the computer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let us try some manual state changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: We get an exception when we try an invalid state transition, as the computer
    cannot go directly from Suspend to Hibernate. It has to wake up first!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: All good now.
  prefs: []
  type: TYPE_NORMAL
- en: We are at an end of our discussion on design patterns in Python, so it is time
    to summarize what we learned so far.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we took a detailed tour of object-oriented design patterns,
    and found out new and different ways of implementing them in Python. We started
    with an overview of Design Patterns and their classification into Creational,
    Structural, and Behavioral patterns.
  prefs: []
  type: TYPE_NORMAL
- en: We went on to see an example of a Strategy design pattern, and saw how to implement
    this in a Pythonic manner. We then began our formal discussion of patterns in
    Python.
  prefs: []
  type: TYPE_NORMAL
- en: In Creational patterns, we covered the Singleton, Borg, Prototype, Factory,
    and Builder patterns. We saw why Borg is usually a better approach than the Singleton
    in Python due to its ability to keep state across class hierarchies. We saw the
    interplay between the Builder, Prototype, and Factory patterns, and saw a few
    examples. Everywhere possible, metaclass discussions were introduced, and pattern
    implementations were done using metaclasses.
  prefs: []
  type: TYPE_NORMAL
- en: In Structural patterns, our focus was on the Adapter, façade, and Proxy patterns.
    We saw detailed examples using the Adapter pattern, and discussed approaches via
    inheritance and object composition. We saw the power of magic methods in Python
    when we implemented the Adapter and Proxy patterns via the `__getattr__` technique.
  prefs: []
  type: TYPE_NORMAL
- en: In Facade, using a `Car` class, we saw a detailed example on how Facade helps
    the programmers to conquer complexity and provide generic interfaces over the
    subsystems. We also saw that many of the Python standard library modules are themselves
    facades.
  prefs: []
  type: TYPE_NORMAL
- en: In the Behavioral section, we discussed the patterns Iterator, Observer, and
    State. We saw how iterators were part and parcel of Python. We implemented an
    iterator as a generator for building Prime numbers.
  prefs: []
  type: TYPE_NORMAL
- en: We saw a simple example of the Observer pattern by using an `Alarm` class as
    a Publisher and a clock class as Subscriber. We also saw an example of an asynchronous
    observer pattern using the asyncio module in Python.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we ended our discussion of Patterns with the State pattern. We discussed
    a detailed example of switching the states of a computer through allowable state
    changes, and how one can use Python's `__class__` as a dynamic attribute to change
    the class of an instance. In the implementation of State, we borrowed techniques
    from the Iterator pattern, and implemented the State example class as an Iterator.
  prefs: []
  type: TYPE_NORMAL
- en: In our next chapter, we move on from design to the next higher paradigm of patterns
    in software architecture, namely that of Architectural Patterns.
  prefs: []
  type: TYPE_NORMAL
