- en: Chapter 6. Enhancing the Responsiveness of the Functional Program with Asynchronous
    Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Responsive applications are a must in today''s programming approach. They can
    improve the performance of the application itself and make our application have
    a user-friendly interface. We need to asynchronously run the code execution process
    in our program to have a responsive application. To achieve this goal, in this
    chapter, we will discuss the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Using thread and thread pool to build a responsive application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning about asynchronous programming model patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning about task-based asynchronous patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the async and await keywords to build asynchronous programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying an asynchronous method in a functional approach
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a responsive application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first time .NET Framework was announced, the flow of the program was executed
    sequentially. The drawback of this execution flow is that our application has
    to wait for the operation to finish before executing the next operation. It will
    freeze our application, and that will be an unpleasant user experience.
  prefs: []
  type: TYPE_NORMAL
- en: To minimize this problem, .NET Framework introduces thread, the smallest unit
    of execution, which can be scheduled independently by the OS. And the asynchronous
    programming means that you run a piece of code on a separate thread, freeing up
    the original thread and doing other things while the task is completed.
  prefs: []
  type: TYPE_NORMAL
- en: Running a program synchronously
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start our discussion by creating a program that will run all operations
    synchronously. The following is the code that demonstrates the synchronous operation
    that we can find in the `SynchronousOperation.csproj` project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see in the preceding code, the `RunSynchronousProcess()` method executes
    two methods; they are the `LongProcess1()` and `LongProcess2()` methods. Now let''s
    call the preceding `RunSynchronousProcess()` method, and we will get the following
    output on the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Running a program synchronously](img/Image00072.jpg)'
  prefs: []
  type: TYPE_IMG
- en: These two methods, `LongProcess1()` and `LongProcess2()` , are independent,
    and each method takes a particular time to finish. Since it is executed synchronously,
    it takes 12 seconds to finish these two methods. The `LongProcess1()` method needs
    5 seconds to finish, and the `LongProcess2()` method needs 7 seconds to finish.
  prefs: []
  type: TYPE_NORMAL
- en: Applying threads in the program
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can improve our previous code so that it can be the responsive program by
    refactoring some of the code and adding threads to the code. The refactored code
    would be as follows, which we can find in the `ApplyingThreads.csproj` project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, we refactor the `RunSynchronousProcess()` method in the previous
    code into the `RunAsynchronousProcess()` method. And if we run the `RunAsynchronousProcess()`
    method, we will get the following output on the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Applying threads in the program](img/Image00073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Compared to the `RunSynchronousProcess()` method, we now have a faster process
    in the `RunAsynchronousProcess()` method. We create a new thread that will run
    the `LongProcess1()` method. The thread will not run until it has started using
    the `Start()` method. Take a look at the following code snippet, in which we create
    and run the thread:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'After the thread is run, we can run the other operation, in this case, the
    `LongProcess2()` method. When this operation is done, we have to wait for the
    thread to be finished so that we use the `Join()` method from the thread instance.
    The following code snippet will explain this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `Join()` method will block the current thread until the other thread that's
    being executed is finished. After the other thread finishes, the `Join()` method
    will return, and then the current thread will be unblocked.
  prefs: []
  type: TYPE_NORMAL
- en: Creating threads using thread pool
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Besides using the thread itself, we can also precreate some threads using the
    `System.Threading.ThreadPool` class. We use this class if we need to work with
    threads from the thread pool. When using thread pool, you are more likely to use
    only the `QueueUserWorkItem()` method. This method will add an execution request
    to the thread pool queue. If any threads are available in the thread pool, the
    request will execute right away. Let''s take a look at the following code in order
    to demonstrate the use of thread pool, which we can find in the `UsingThreadPool.csproj`
    project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In the thread pool, we can invoke the `QueueUserWorkItem()` method to put a
    new work item in a queue, which is managed by the thread pool when we need to
    run the long running process instead of creating a new thread. There are three
    possibilities of how the work is treated when we send it to thread pool; they
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The thread has one or more available threads idle in the thread pool so that
    the work can be handled by the idle thread and run immediately.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No threads are available, but the `MaxThreads` property has not been reached
    yet so the thread pool will create a new thread, assign the work, and run the
    work immediately.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is no available thread in the thread pool and the total number of threads
    in the thread pool has reached the `MaxThreads` . In this situation, the work
    item will wait in the queue for the first available thread.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let''s run the `ThreadPoolProcess()` method, and we will get the following
    output on the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating threads using thread pool](img/Image00074.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As we can see in the preceding screenshot, we get the same result with the similar
    process time we get when we apply the new thread that we discussed in the previous
    section.
  prefs: []
  type: TYPE_NORMAL
- en: The asynchronous programming model pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **asynchronous programming model** ( **APM** ) is an asynchronous operation
    that uses the `IAsyncResult` interface as its design pattern. It's also called
    the `IAsyncResult` pattern. For this purpose, the framework has provided the method
    named `BeginXx` and `EndXx` , in which `Xx` is the operation name, for instance,
    `BeginRead` and `EndRead` provided by the `FileStream` class to read bytes from
    a file asynchronously.
  prefs: []
  type: TYPE_NORMAL
- en: 'The difference in the synchronous `Read()` method with `BeginRead()` and `EndRead()`
    can be recognized from the method''s declaration, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, in the synchronous `Read()` method, we need three parameters;
    they are `array` , `offset` , and `numBytes` . In the `BeginRead()` method, there
    are two more parameter additions; they are `userCallback` , the method that will
    be called when the asynchronous read operation is completed, and `stateObject`
    , an object provided by the user that distinguishes the asynchronous read request
    from other requests.
  prefs: []
  type: TYPE_NORMAL
- en: Using the synchronous Read() method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, let''s take a look at the following code, which we can find in the `APM.csproj`
    project, in order to distinguish the asynchronous `BeginRead()` method from the
    synchronous `Read()` method in a clearer way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will synchronously read the `LoremIpsum.txt` file (included
    in the `APM.csproj` project), which means that the reading process has to be completed
    before executing the next process. If we run the preceding `ReadFile()` method,
    we will get the following output on the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the synchronous Read() method](img/Image00075.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Using the BeginRead() and EndRead() methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, let''s compare the synchronous reading process using the `Read()` method
    with the asynchronous reading process using the `BeginRead()` and `EndRead()`
    methods from the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, we have two methods named `ReadAsyncFile()` and `OnReadComplete()`
    . The `ReadAsyncFile()` method will read the `LoremIpsum.txt` file asynchronously
    and then invoke the `OnReadComplete()` method just after finishing reading the
    file. We have additional code to make sure that the asynchronous operation runs
    properly using the following `do-while` looping code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding `do-while` loop will iterate until the asynchronous operation
    is completed, as indicated in the `IsComplete` property of `IAsyncResult` . The
    asynchronous operation is started when the `BeginRead()` method is invoked, as
    shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: After that, it will continue with the next process while it reads the file.
    The `OnReadComplete()` method will be invoked when the reading process is finished,
    and since the implementation of the `OnReadComplete()` method set the `IsFinish`
    variable to true, it will stop our `do-while` looping.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output we will get by running the `ReadAsyncFile()` method is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the BeginRead() and EndRead() methods](img/Image00076.jpg)'
  prefs: []
  type: TYPE_IMG
- en: From the screenshot of the preceding output, we can see that the iteration of
    the `do-while` loop is successfully executed when the reading process is run as
    well. The reading process is finished in the 64th iteration of the `do-while`
    loop.
  prefs: []
  type: TYPE_NORMAL
- en: Adding LINQ to the BeginRead() method invocation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can also use LINQ to define the `OnReadComplete()` method so that we can
    replace that method using the anonymous method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, we replace the invocation of the `BeginRead()` method with the
    following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: From the preceding code, we can see that we don't have the `OnReadComplete()`
    method anymore since it has been represented by the anonymous method. We remove
    the `FileStream` instance in the callback because the anonymous method in lambda
    will access it using the closure. And if we invoke the `ReadAsyncFileAnonymousMethod()`
    method, we will get the exact same output as the `ReadAsyncFile()` method except
    the iteration count, since it depends on the CPU speed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides the `IsCompleted` property, which is used to fetch the value that indicates
    whether the asynchronous operation is complete, there are three more properties
    we can use when dealing with `IAsyncResult` ; they are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AsyncState` : This is used to retrieve an object defined by the user that
    qualifies or contains information about an asynchronous operation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AsyncWaitHandle` : This is used to retrieve `WaitHandle` (an object from the
    operating system that waits for exclusive access to shared resources), which indicates
    the completeness of the asynchronous operation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CompletedSynchronously` : This is used to retrieve a value that indicates
    whether the asynchronous operation completed synchronously'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unfortunately, there are several shortages when applying APM, such as the inability
    to do a cancelation. This means that we cannot cancel the asynchronous operator
    because from the invocation of `BeginRead` until the callback is triggered, there
    is no way to cancel the background process. If `LoremIpsum.txt` is a gigabyte
    file, we have to wait until the asynchronous operation is finished instead of
    canceling the operation.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The APM pattern is no longer recommended in a new development due to its obsolete
    technology.
  prefs: []
  type: TYPE_NORMAL
- en: The task-based asynchronous pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **task-based asynchronous pattern** ( **TAP** ) is a pattern that's used
    to represent arbitrary asynchronous operations. The concept of this pattern is
    to represent asynchronous operations in a method and combine the status of the
    operation and the API that is used to interact with these operators for them to
    become a single object. The objects are the `Task` and `Task<TResult>` types in
    the `System.Threading.Tasks` namespace.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the Task and Task<TResult> classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Task` and `Task<TResult>` classes were announced in .NET Framework 4.0
    in order to represent an asynchronous operation. It uses threads that are stored
    in the thread pool but offers the flexibility of how the task is created. We use
    the `Task` class when we need to run a method as a task but don't need the return
    value; otherwise, we use the `Task<TResult>` class when we need to get the return
    value.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can find a complete reference, including methods and properties, inside `Task`
    and `Task<TResult>` on the MSDN site at [https://msdn.microsoft.com/en-us/library/dd321424(v=vs.110).aspx](https://msdn.microsoft.com/en-us/library/dd321424(v=vs.110).aspx)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Applying a simple TAP model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start our discussion on TAP by creating the following code, which we
    can find in the `TAP.csproj` project, and use it to read a file asynchronously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As we can see in the preceding code, the `ReadAsync()` method inside the `FileStream`
    class will return `Task<int>` , which in this case will indicate the number of
    bytes that have been read from the file. After invoking the `ReadAsync()` method,
    we invoke the `ContinueWith()` extension method using method chaining, as discussed
    in [Chapter 1](text00016.html#ch01 "Chapter 1. Tasting Functional Style in C#")
    , *Tasting Functional Type in C#* . It allows us to specify `Action<Task<T>>`
    , which will be run after the asynchronous operation is completed.
  prefs: []
  type: TYPE_NORMAL
- en: 'By invoking the `ContinueWith()` method after the task is completed, the delegate
    will be run in a synchronous operation immediately. And if we run the preceding
    `ReadFileTask()` method, we get the following output on the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Applying a simple TAP model](img/Image00077.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Using the WhenAll() extension method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We successfully applied a simple TAP in the previous section. Now, we will
    continue by asynchronously reading two files and then processing the other operation
    only when both the reading operations have been completed. Let''s take a look
    at the following code, which will demonstrate our need:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, we use the `Task.WhenAll()` method to wrap the two tasks that
    are passed in as parameters into a larger asynchronous operation. It then returns
    a task that represents the combination of these two asynchronous operations. We
    don't need to wait for the completeness of both files' reading operations but
    it adds a continuation for when these two files have been read successfully.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run the preceding `ReadTwoFileTask()` method, we get the following output
    on the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the WhenAll() extension method](img/Image00078.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As we have discussed earlier that the drawback of APM pattern is that we cannot
    cancel the background process, now let''s try to cancel the list of tasks in TAP
    by refactoring the preceding code we have. The complete code will become like
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: As we can see from the preceding code, we add `CancellationTokenSource` and
    `CancellationToken` to inform the cancellation process. We then pass token to
    the `Task.WhenAll()` function. After the tasks have run, we can cancel the tasks
    using the `source.Cancel()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the output we will get on the console if we run the preceding
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the WhenAll() extension method](img/Image00079.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding output tells us that the tasks have been canceled successfully
    in the 11th counter because the counter has been higher than 10.
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping an APM into a TAP model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If the framework doesn''t offer a TAP model for asynchronous operation, we
    can, if we want, wrap APM `BeginXx` and `EndXx` methods into the TAP model using
    the `Task.FromAsync` method. Let''s take a look at the following code in order
    to demonstrate the wrapping process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'From the preceding code, we can see that we use the `BeginRead()` and `EndRead()`
    methods, which are actually APM patterns, but we use them in the TAP model, as
    shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'And if we run the preceding `WrapApmIntoTap()` method, we will get the following
    output on the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Wrapping an APM into a TAP model](img/Image00080.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As we can see in the screenshot of the output result, we have successfully read
    the `LoremIpsum.txt` file using the `BeginRead()` and `EndRead()` methods wrapped
    into the TAP model.
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous programming with the async and await keywords
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `async` and `await` keywords were announced in C# 5.0 and became the latest
    and greatest things in C# asynchronous programming. Developed from the TAP pattern,
    C# integrates these two keywords into the language itself so that it makes it
    simple and easy to read. Using these two keywords, the `Task` and `Task<TResult>`
    classes still become the core building blocks of asynchronous programming. We
    will still build a new `Task` or `Task<TResult>` data type using the `Task.Run()`
    method, as discussed in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s take a look at the following code, which demonstrates the `async`
    and `await` keywords, which we can find in the `AsyncAwait.csproj` project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see in the preceding code, we refactor the code from our previous
    topic by adding the `await` keyword when we read the file stream, as shown in
    the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, we use the `async` keyword in front of the method name, as shown in the
    following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'From the preceding two code snippets, we can see that the `await` keyword can
    only be called inside a method that is marked with the `async` keyword. And when
    `await` is reached--in this case, it is in await `fs.ReadAsync()` --the thread
    that called the method will jump out of the method and continue on its way to
    something else. The asynchronous code then takes place on a separate thread (like
    how we use the `Task.Run()` method). However, everything after await is scheduled
    to be executed when the task is finished. And if we run the preceding `AsyncAwaitReadFile()`
    method, we will get the following output on the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Asynchronous programming with the async and await keywords](img/Image00081.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As with the TAP model, we obtain the asynchronous result here as well.
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous functions in functional programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, using the chaining method, we are going to use the `async` and `await`
    keywords in functional programming. Suppose we have three tasks, as shown in the
    following code snippet, and we need to chain them together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'For that purpose, we have to create a new extension method for `Task<T>` named
    `MapAsync` , with the following implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The `MapAsync()` method allows us to define the method as `async` , accept
    the task returned from the `async` method, and `await` the call to the delegate.
    The following is the complete code we use to chain the three tasks that we can
    find in the `AsyncChain.csproj` project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run the preceding `AsyncChain()` method, we will get the following output
    on the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Asynchronous functions in functional programming](img/Image00082.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Asynchronous programming is a way that we can use to develop a responsive application,
    and we successfully applied `Thread` and `ThreadPool` to achieve this goal. We
    can create a new thread to run the work, or we can reuse the available threads
    in thread pool.
  prefs: []
  type: TYPE_NORMAL
- en: We also learned about the asynchronous programming model pattern, which is an
    asynchronous operation that uses the `IAsyncResult` interface as its design pattern.
    In this pattern, we used the two methods that are preceded by `Begin` and `End`
    ; for instance, in our discussion, these were the `BeginRead()` and `EndRead()`
    methods. The `BeginRead()` method started the asynchronous operation when invoked,
    and then the `EndRead()` method stopped the operation so that we could fetch the
    return value of the operation.
  prefs: []
  type: TYPE_NORMAL
- en: Besides the asynchronous programming model pattern, .NET Framework also has
    a task-based asynchronous pattern to run the asynchronous operation. The concept
    of this pattern is to represent asynchronous operations in a method and combine
    the status of the operation and the API that is used to interact with these operators
    to become a single object. The objects we used in this pattern are `Task` and
    `Task<TResult>` , which we can find in the `System.Threading.Tasks` namespace.
    In this pattern, we can also cancel the active tasks running as background processes.
  prefs: []
  type: TYPE_NORMAL
- en: Then, C# announced `async` and `await` to complete the asynchronous technique,
    which we can choose. It was developed from the task-based asynchronous pattern,
    where the `Task` and `Task<TResult>` classes became the core building blocks of
    asynchronous programming. The last thing we did in this chapter is that we tried
    to chain the three tasks using our extension method based on the use of the `async`
    and `await` keywords.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss the recursion that is useful in functional
    programming in order to simplify the code. We will learn about the usage of recursion
    and how to reduce the lines of code based on the recursion.
  prefs: []
  type: TYPE_NORMAL
