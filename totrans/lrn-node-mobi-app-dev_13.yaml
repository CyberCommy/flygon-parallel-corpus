- en: Chapter 13. Building an Advanced Chat App
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we developed a rudimentary chat application, which
    allowed an arbitrary number of users to connect to each other and talk anonymously.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we are going to expand this app and make it more advanced by
    adding features for chat rooms and notifications. In doing so, we will demonstrate
    how the concept of namespacing works on `socket.io`, which is one of the most
    important aspects of this library.
  prefs: []
  type: TYPE_NORMAL
- en: We need some room!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, the most advanced thing that we have done with WebSockets in our apps
    has simply been sending data back and forth across a single WebSocket interface.
    We paid very little attention to partitioning and basically just let it all go
    on as a free-for-all app. However, in real life, we will frequently find ourselves
    in situations where we want to partition WebSocket connections and only let certain
    users have access to a subset of partitions.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see how this can work, consider the case of a *group chat*. Here, rather
    than having just a single solitary chat interface, users instead have access to
    a multitude of them; each hosts its own members and conversation. To implement
    this, we can extend our existing chat server to simply start new `node` instances
    for the chat rooms that we want to open, with each of them having its own port,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: However, this becomes clunky very quickly. Since we will need to fire up a new,
    separate V8 instance for each server, chances are that we will very soon get angry
    knocks at the office window from the guy down the hall whose super-important stock
    analysis algorithm just crashed due to a lack of memory space. He may want to
    hurt us and do terrible things to our pets, all because we could not find a smoother
    way to make use of WebSockets.
  prefs: []
  type: TYPE_NORMAL
- en: Or, well, maybe we can, after all.
  prefs: []
  type: TYPE_NORMAL
- en: This is where the concept of a namespace comes into play. Imagine a situation
    where we can just partition a single `socket.io` instance into several different
    endpoints, each of which can service its own set of clients. It turns out that
    we can!
  prefs: []
  type: TYPE_NORMAL
- en: Namespaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Remember how we set up our original `websocket` server? For that take a look
    at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we simply used the main `socket.io` instance in order to directly register
    socket connections and their respective callbacks. However, looking a little closer,
    what we actually did was connect all the incoming connections to a namespace,
    even if this happened implicitly. Take a look at the following snippet from the
    preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: What is actually happening here is that we are registering the connections on
    the root namespace (written as /), which is the one namespace that `socket.io`
    gives us to work with even if we specify no other namespaces. This goes to show
    that namespaces are actually essential for the way `socket.io` works internally.
    In fact, every single connection that you have going will be associated with a
    single namespace, even if it is an implicit one!
  prefs: []
  type: TYPE_NORMAL
- en: 'Your users connect to the root namespace whenever they connect directly to
    the URL of your WebSocket server. For example, they can do this by doing the following
    on the client side:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: You are in effect telling `socket.io` that you wish to establish a connection
    to the root namespace.
  prefs: []
  type: TYPE_NORMAL
- en: The problem is that if we perform the preceding steps (as we have done until
    now), all the messages that we send to the server are open for broadcasting to
    all the other connected clients as well (this happens even if you have other namespaces
    defined, as we will see later). This is not very convenient if we want to concentrate
    on communications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say that we want to divide communications in order to let users subscribe
    to `websocket` channels, which sends information that interests them. For example,
    let''s say that we are building a chat application that will let them speak about
    various programming languages such as Java, Scala, and JavaScript. In that case,
    we can define namespaces on the server side by doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The important parts of the code are emphasized. Note how we use the `of` function
    in order to create the actual namespace. The argument of the function is the name
    of the namespace relative to the root namespace (`/`).
  prefs: []
  type: TYPE_NORMAL
- en: After the namespace is created, we register `socket` connections in a way that
    is familiar to us by now after having (albeit unknowingly!) done the same thing
    with the root namespace earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now make use of these modifications to the server by having the client
    connect to any given namespace available. For example, for the ones that we have
    already defined here, you can connect to each of them like this (respectively):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, proceed to operate on them just as you would in the case of any other
    single WebSocket connection, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This is all pretty straightforward, as you will note as you dig in a little
    deeper. Let's do so by dusting off the simple chat application that we wrote in
    the last chapter and giving it some genuine namespacing love.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a multiroom chat application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s take a brief refresher on the basic **Chat App** that we built during
    the course of the previous chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a multiroom chat application](img/B04653_13_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This app effectively sets up a connection to the WebSocket server and lets us
    talk to random strangers who, for some reason, are loitering in the kitchen and
    using the Wi-Fi connection. What we want to do here is give these strangers (and
    ourselves) the possibility to pick separate chat rooms depending on what they
    are keen to talk about. Since we love programming, programming languages are of
    course going to be the be-all-and-end-all of what is on the menu.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the basic layout
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to create a nice way to navigate between different chat rooms, we will
    use a tabbed layout, where each tab will correspond to a single chat room.
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that we will need to make several changes to our HTML as well as
    the routing for our app. Start out by modifying the `index.html` file. Make sure
    that it looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: I highlighted the most important part in the preceding code. Here, we created
    a navigation bar, which corresponds to a toolbar at the top of the screen in Ionic.
    If you are familiar with Android, you will recognize this as the action bar. Below
    this navigation bar, we then attached the actual view, which is currently loaded.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will attach a series of `tabs` to this layout, which will let us select
    the chat room that we wish to interact with. In the templates folder, create a
    file named `tabs.html` and make sure that it has the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we used the `ion-tabs` directive, which in essence acts like a horizontal
    list consisting of `ion-tab` instances. Note how we associate each tab with a
    single language view and URL. The router will use both in order to deduce the
    exact state the app should be in when a tab is clicked. Let''s see how it does
    so. Open the `app.js` file and make sure that it looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Note how we coupled each single tab with a given application state. In doing
    so, we also tell the app how it should render the view under each tab. In our
    case, we have a common view for each single chat, `templates/app-chat`, which
    is familiar to us from our previous work. Let''s take a look at the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, add some custom CSS to the `css/style.css` file in order to adjust
    the formatting according to our needs; this will also be familiar, as we saw this
    in the previous chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Your view should now look like what''s shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuring the basic layout](img/B04653_13_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s add some actual logic to our app in order to get the actual chat
    logic going. We are going to implement the namespace pattern that we discussed
    earlier in this chapter, adding one room for each tab. First, define the following
    controller in the `app.controllers.js` file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This controller works very much like what we are used to from the previous
    app, with the exception that it takes as a parameter the name of the chat room
    that we should connect to. This name is resolved in `app.js` in conjunction with
    the view being resolved, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The relevant part is emphasized. We simply bind `chatRoom` to whatever the name
    of the corresponding language room for the view is in this case.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we need to expand the `ChatService` module in order to make sure that
    we can connect to an individual chat room. Open the `app.services.js` file and
    make sure that it has the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In its previous incarnation, this service simply made a `socket` connection
    and serviced it. Here, we produce `socket` connections instead based on the namespace
    that we are connecting to. This allows us to set up a separate `service` instance
    for each individual `socket`.
  prefs: []
  type: TYPE_NORMAL
- en: That's all that we need for the client! Let's turn to the server in order to
    wrap things up.
  prefs: []
  type: TYPE_NORMAL
- en: Building the server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have already seen how to create namespaces on the server. So, let''s adjust
    our own accordingly. However, in order to make it much neater, let''s do so by
    iterating over a list with all the names of the namespaces that we wish to create:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: That's it! You can now start up your server, connect the app to server, and
    try it out. Pay special attention to your `server` console when you switch between
    the rooms. You will see the separate connections to separate rooms being made.
    Finally, see for yourself that the namespacing actually works. The messages that
    you send to one chat will only be visible to the users who are already connected
    to it.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is actually possible to partition the `socket.io` connections even further
    than what we did here. The `socket.io` connection also features the concept of
    rooms, which are essentially partitions of a single namespace. We recommend that
    you study this closely. The official documentation of `socket.io` contains a great
    deal of examples. To view this documentation, visit [http://socket.io/docs/rooms-and-namespaces/](http://socket.io/docs/rooms-and-namespaces/).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you created an advanced chat application, which allows its
    users to chat across several rooms using the important `socket.io` concept of
    namespacing. You learned how to configure namespaces on the server itself as well
    as how to connect to them from the client.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will wrap up what you learned so far by looking at how
    we can implement a common piece of functionality—an e-commerce application.
  prefs: []
  type: TYPE_NORMAL
