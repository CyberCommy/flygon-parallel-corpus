- en: Chapter 2. Java Data Types and Their Usage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we will learn more about how Java organizes and manipulates
    data, especially primitive data types and strings. In addition to this, we will
    explore various related concepts such as scoping and the lifetime of a variable.
    While strings are not a primitive data type in Java, they are a critical part
    of many applications and we will examine what Java has to offer.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we will focus on:'
  prefs: []
  type: TYPE_NORMAL
- en: The declaration and use of primitive data types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `String` and `StringBuilder` classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How the program stack and heap relate to each other
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The differences between a class and an object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constants and literals in Java
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The scope and lifetime of a variable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operators, operands, and expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding how Java handles data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The core of programming is code that manipulates data. As programmers we are
    interested in the organization of data and code. The organization of data is referred
    to as **data** **structures** . These structures can be static or dynamic in nature.
    For example, the ages of a population can be stored in consecutive locations in
    a data structure known as an **array** . While the array data structure has a
    fixed size, the contents may or may not change. Arrays are discussed in detail
    in [Chapter 4](ch04.html "Chapter 4. Using Arrays and Collections"), *Using Arrays
    and Collections*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will examine several different aspects of variables including:'
  prefs: []
  type: TYPE_NORMAL
- en: How they are declared
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Primitive data types versus objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Where they reside in memory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How they are initialized
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Their scope and lifetime
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java identifiers, objects, and memory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Variables are defined to be of a specific type and are allocated memory. When
    an object is created, instance variables that make up the object are allocated
    on the heap. The static variables of an object are allocated to a special area
    of memory. When a variable is declared as part of a method, the memory for the
    variable is allocated on the program stack.
  prefs: []
  type: TYPE_NORMAL
- en: Stack and heap
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A thorough understanding of the stack/heap and other issues is critical for
    understanding how a program works, and in turn how well a developer can use a
    language such as Java to do his job. These concepts provide a framework for understanding
    how an application works and are the basis for the implementation of the runtime
    system used by Java, not to mention almost every other programming language in
    existence.
  prefs: []
  type: TYPE_NORMAL
- en: With this said, the concept of a stack and heap is fairly simple. The **stack**
    is an area where the parameters of a method and its local variables are stored
    each time a method is invoked. The **heap** is an area of memory where objects
    are allocated when the `new` keyword is invoked. The parameters and local variables
    of a method make up an **activation** **record** , also called a **stack** **frame**
    . Activation records are pushed onto a stack when the method is invoked and popped
    off the stack when the method returns. The temporary existence of these variables
    determines the lifetime of the variables.
  prefs: []
  type: TYPE_NORMAL
- en: '![Stack and heap](img/7324_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The stack grows toward the heap when a method is invoked and shrinks when the
    method returns. The heap does not grow in a predictable order and can become fragmented.
    As they share the same memory space, if the heap and stack collide then the program
    will terminate.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Understanding the concept of stack and heap is important because:'
  prefs: []
  type: TYPE_NORMAL
- en: It provides a foundation used to understand how data is organized in an application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It helps explain the concept of the scope and lifetime of a variable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It helps explain how recursion works
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will re-use the program illustrated in [Chapter 1](ch01.html "Chapter 1. Getting
    Started with Java"), *Getting Started with Java*, to demonstrate the use of stack
    and heap. The program has been duplicated here for your convenience:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'When the `main` method is executed, an activation record is pushed onto the
    program stack. As shown in the following diagram, its activation record consists
    of only the single `args` parameter and the `customer` reference variable. When
    the instance of the `Customer` class is created, an object is created and allocated
    on the heap. The state of the stack and heap reflected in this example occurs
    after the `Customer` constructor executes. The `args` reference variable points
    to an array. Each element of the array references a string representing the applications''
    command line arguments. In the example shown in the following diagram, we assume
    there are two command line arguments, Argument 1 and Argument 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Stack and heap](img/7324_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When the `setBalance` method is executed, its activation record is pushed onto
    the program stack as illustrated below. The `setBalance` method has a single parameter,
    `balance`, which is assigned to the `balance` instance variable. But first, it
    is used as an argument to the `BigDecimal` constructor. The `this` keyword references
    the current object.
  prefs: []
  type: TYPE_NORMAL
- en: Heap is the memory that is dynamically allocated for objects. A heap manager
    controls how this memory is organized. When an object is no longer needed, a garbage
    collection routine will execute to free up the memory so it can be re-used. Before
    an object is disposed of, the object's `finalize` method is executed. However,
    there is no guarantee that the method will execute as the program may terminate
    without the need for the garbage collection routine to run. The original `BigDecimal`
    object will be eventually destroyed.
  prefs: []
  type: TYPE_NORMAL
- en: '![Stack and heap](img/7324_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In C++, when an object is about to be destroyed its destructor will be executed.
    The closest thing Java has to this is the `finalize` method, which will execute
    when the object is processed by the garbage collector. However, the garbage collector
    may not run and, thus, the `finalize` method may never execute. This paradigm
    shift results in an important difference in how we manage resources. The try-with-resources
    block introduced in [Chapter 8](ch08.html "Chapter 8. Handling Exceptions in an
    Application"), *Handling Exceptions in an Application*, offers a technique for
    dealing with this situation.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring a variable
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A variable is also called an identifier. The term "variable" implies that its
    value can be changed. This is usually the case. However, if the identifier is
    declared as a constant, as discussed in the *Constants* section, then it is not
    really a variable. Regardless of this, the terms variable and identifier are normally
    considered to be synonymous.
  prefs: []
  type: TYPE_NORMAL
- en: The declaration of a variable begins with the data type and is followed by the
    variable name and then a semicolon. The data type may be a primitive data type
    or a class. When the data type is a class, the variable is an object reference
    variable. That is, it is a reference to an object.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A reference variable is effectively a disguised C pointer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Variables can be classified into the following three categories:'
  prefs: []
  type: TYPE_NORMAL
- en: Instance variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Static variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Local variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instance variables are used to reflect the state of the object. Static variables
    are variables that are common to all instances. Local variables are declared within
    a method and are visible only within the block in which they are declared.
  prefs: []
  type: TYPE_NORMAL
- en: 'Identifiers are case-sensitive and can only be composed of:'
  prefs: []
  type: TYPE_NORMAL
- en: Letters, numbers, the underscore (_) and the dollar sign ($)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identifiers may only begin with a letter, the underscore or a dollar sign
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Examples of valid variable names include:'
  prefs: []
  type: TYPE_NORMAL
- en: '`numberWheels`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ownerName`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mileage`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`_byline`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`numberCylinders`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$newValue`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`_engineOn`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'By convention, identifiers and methods start with the first word in lower case
    and subsequent words capitalized as discussed in the *Java naming conventions*
    section of [Chapter 1](ch01.html "Chapter 1. Getting Started with Java"), *Getting
    Started with Java*. Examples of conventional declarations include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`int numberWheels;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int numberCylinders;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`float mileage;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boolean engineOn;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int $newValue;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`String ownerName;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`String _byline;`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the preceding examples, each variable, except the last two, is declared
    as a primitive data type. The last one is declared as a reference to a `String`
    object. The reference variable can reference a `String` object but, in this example,
    is assigned a `null` value meaning that it is does not currently reference a string.
    Strings are covered in more detail in the *The String class* section. The following
    code snippet declares three variables of type integer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'It is also possible to declare all three variables on a single line, shown
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Primitive data types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are eight primitive data types defined in Java, as listed in the following
    table. In Java, the size of each of the data types is the same for all machines:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Data type | Size in bytes | Internal representation | Range |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `boolean` | -- | Not precisely defined | `true` or `false` |'
  prefs: []
  type: TYPE_TB
- en: '| `byte` | 1 | 8-bit two''s complement | `−128` to `+127` |'
  prefs: []
  type: TYPE_TB
- en: '| `char` | 2 | Unicode | `\u0000` to `\uffff` |'
  prefs: []
  type: TYPE_TB
- en: '| `short` | 2 | 16-bit two''s complement | `–32768` to `32767` |'
  prefs: []
  type: TYPE_TB
- en: '| `int` | 4 | 32-bit two''s complement | `−2,147,483,648` to `2,147,483,647`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `long` | 8 | 64-bit two''s complement | `-9,223,372,036,854,775,808` to`9,223,372,036,854,775,807`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `float` | 4 | 32-bit IEEE 754 floating point | `3.4e +/- 38` (7 digits) |'
  prefs: []
  type: TYPE_TB
- en: '| `double` | 8 | 64-bit IEEE 754 floating point | `1.7e +/- 308` (15 digits)
    |'
  prefs: []
  type: TYPE_TB
- en: The `String` data type is also a part of Java. While it is not a primitive data
    type, it is a class and is discussed in detail in the *The String class* section.
  prefs: []
  type: TYPE_NORMAL
- en: Another common data type is currency. There are several ways of representing
    money in Java as detailed in the following table. However, the recommended approach
    is to use the `BigDecimal` class.
  prefs: []
  type: TYPE_NORMAL
- en: '| Data type | Advantages | Disadvantages |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Integer | Good for simple currency units, such as a penny. | It does not
    use a decimal point, such as that used in dollars and cents. |'
  prefs: []
  type: TYPE_TB
- en: '| Floating point | It uses a decimal point. | Rounding errors are very common.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `BigDecimal` class |'
  prefs: []
  type: TYPE_TB
- en: Handles large numbers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uses decimal points.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Has built-in rounding modes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| More difficult to use. |'
  prefs: []
  type: TYPE_TB
- en: 'When using `BigDecimal`, it is important to note the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Use the constructor with the `String` argument as it does a better job at placing
    the decimal point
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BigDecimal` is immutable'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ROUND_HALF_EVEN` rounding mode introduces the least bias
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Currency` class is used to control the formatting of currency.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another recommendation regarding currency representation is based on the number
    of digits used.
  prefs: []
  type: TYPE_NORMAL
- en: '**Number of digits** **Recommended data type**'
  prefs: []
  type: TYPE_NORMAL
- en: Less than 10 Integer or `BigDecimal`
  prefs: []
  type: TYPE_NORMAL
- en: Less than 19 Long or `BigDecimal`
  prefs: []
  type: TYPE_NORMAL
- en: Greater than 19 `BigDecimal`
  prefs: []
  type: TYPE_NORMAL
- en: 'Floating point numbers can be a significant source of problems in most languages.
    Consider the following snippets where we add `0.1` in an attempt to get the value
    `1.0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: It reflects the fact that the decimal value `0.1` cannot be accurately represented
    in base two. This means we must always be vigilant when working with floating
    point numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Wrapper classes and autoboxing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Wrapper classes are used to enclose primitive data type values inside an object.
    Prior to the availability of boxing, there were often situations where it was
    necessary to explicitly use wrapper classes such as the `Integer` and `Float`
    classes. This was required to be able to add primitive data types to collections
    often found in the `java.util` package, including the `ArrayList` class, because
    methods of these data classes used objects as arguments. Wrapper classes include
    the following data types:'
  prefs: []
  type: TYPE_NORMAL
- en: Boolean
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Byte
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Character
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Short
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Long
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Float
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Double
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Objects of these wrapper classes are immutable. That is, their values cannot
    be changed.
  prefs: []
  type: TYPE_NORMAL
- en: '**Autoboxing** is the automatic conversion of primitive data types into their
    corresponding wrapper classes. This is performed as needed so as to eliminate
    the need to perform trivial, explicit conversion between primitive data types
    and their corresponding wrapper classes. **Unboxing** refers to the automatic
    conversion of a wrapper object to its equivalent primitive data type. In effect,
    primitive data types are treated as if they are objects in most situations.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few things to remember when working with primitives and objects.
    First, objects can be `null`, whereas primitives cannot be assigned a `null` value.
    This can present problems from time to time. For example, unboxing a null object
    will result in a `NullPointerException`. Also, be careful when comparing primitives
    and objects when boxing does not occur as illustrated in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Comparison | Two primitives | Two objects | One of each |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `a == b` | Simple comparison | Compares reference values | Treated as two
    primitives |'
  prefs: []
  type: TYPE_TB
- en: '| `a.equals(b)` | Will not compile | Compares for equality of values | Will
    not compile if a is a primitive, otherwise their values are compared |'
  prefs: []
  type: TYPE_TB
- en: Initializing identifiers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The initialization of Java variables is actually a complex process. Java supports
    four ways of initializing variables:'
  prefs: []
  type: TYPE_NORMAL
- en: Default initial values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instance variable initializers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instance initializers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constructors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter we will examine the first two approaches. The latter two techniques
    are covered in [Chapter 6](ch06.html "Chapter 6. Classes, Constructors, and Methods"),
    *Classes, Constructors, and Methods*, where the whole initialization process is
    put together.
  prefs: []
  type: TYPE_NORMAL
- en: 'When explicit values are not provided, initial default values are used as the
    object is created. In general, when a field of an object is allocated it is initialized
    to a zero value as detailed in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Data type | Default value (for fields) |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `boolean` | `false` |'
  prefs: []
  type: TYPE_TB
- en: '| `byte` | `0` |'
  prefs: []
  type: TYPE_TB
- en: '| `char` | `''`\`u0000''` |'
  prefs: []
  type: TYPE_TB
- en: '| `short` | `0` |'
  prefs: []
  type: TYPE_TB
- en: '| `int` | `0` |'
  prefs: []
  type: TYPE_TB
- en: '| `long` | `0L` |'
  prefs: []
  type: TYPE_TB
- en: '| `float` | `0.0f` |'
  prefs: []
  type: TYPE_TB
- en: '| `double` | `0.0d` |'
  prefs: []
  type: TYPE_TB
- en: '| `String` (or any object) | `null` |'
  prefs: []
  type: TYPE_TB
- en: 'For example, in the following class, `name` is assigned `null` and `age` has
    a value of `0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The instance variable initializers'' operator can be used to explicitly assign
    a value to a variable. Consider the following variation of the `Person` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: When an object of type `Person` is created, the `name` and `age` fields are
    assigned the values `John Doe` and `23` respectively.
  prefs: []
  type: TYPE_NORMAL
- en: However, when a local variable is declared, it is not initialized. It is, therefore,
    important to either use the initialization operator when declaring the variable
    or to not use the variable until a value has been assigned to it. Otherwise, a
    syntax error will result.
  prefs: []
  type: TYPE_NORMAL
- en: Java constants, literals, and enumerations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Constants and literals are similar in that they cannot be changed. A variable
    can be declared using the `final` keyword as a primitive data type that cannot
    change and is, thus, referred to as a constant. A literal is a token such as `35`
    or `'C'` which represents a value. Obviously, it cannot be modified either. Related
    to this concept are immutable objects—objects which cannot be modified. While
    the object cannot be modified, the reference variable pointing to the object can
    be changed.
  prefs: []
  type: TYPE_NORMAL
- en: Enumerations are also effectively constant in nature. They are used to provide
    a convenient way of dealing with sets of values as a list. For example, an enumeration
    can be created to represent the suits of a card deck.
  prefs: []
  type: TYPE_NORMAL
- en: Literals
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Literal constants are simple numbers, characters, and strings that represent
    a quantity. There are three basic types:'
  prefs: []
  type: TYPE_NORMAL
- en: Numeric
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Character
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Strings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Numeric literals
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Numeric constants consist of a series of digits with an optional sign and an
    optional decimal point. Numeric literals that contain a decimal point are by default
    `double` constants. Numeric constants can also be prefixed with a `0x` to indicate
    the number is a hexadecimal number (base 16). Numbers that begin with a `0` are
    octal numbers (base 8). A suffix of `f` or `F` can be used to declare a floating
    point literal as of type `float`.
  prefs: []
  type: TYPE_NORMAL
- en: '| Numeric literal | Base | Data type | Decimal equivalent |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `25` | 10 | `int` | `25` |'
  prefs: []
  type: TYPE_TB
- en: '| `-235` | 10 | `int` | `-235` |'
  prefs: []
  type: TYPE_TB
- en: '| `073` | 8 | `int` | `59` |'
  prefs: []
  type: TYPE_TB
- en: '| `0x3F` | 16 | `int` | `63` |'
  prefs: []
  type: TYPE_TB
- en: '| `23.5` | 10 | `double` | `23.5` |'
  prefs: []
  type: TYPE_TB
- en: '| `23.5f` | 10 | `float` | `23.5` |'
  prefs: []
  type: TYPE_TB
- en: '| `23.5F` | 10 | `float` | `23.5` |'
  prefs: []
  type: TYPE_TB
- en: '| `35.05E13` | 10 | `double` | `350500000000.00` |'
  prefs: []
  type: TYPE_TB
- en: 'Integer literals are common. Normally they are expressed in base 10, but octal
    and hexadecimal literals can be created using the appropriate prefix. Integer
    literals are of type `int` by default. A literal can be specified as type `long`
    by appending an L to the end of the literal. The following table illustrates literals
    and their corresponding data types:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Literal | Type |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `45` | `int` |'
  prefs: []
  type: TYPE_TB
- en: '| `012` | An integer expressed as an octal number. |'
  prefs: []
  type: TYPE_TB
- en: '| `0x2FFC` | An integer expressed as a hexadecimal number. |'
  prefs: []
  type: TYPE_TB
- en: '| `10L` | `long` |'
  prefs: []
  type: TYPE_TB
- en: '| `0x10L` | A long expressed as a hexadecimal number. |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Either a lowercase or uppercase L can be used to designate an integer as type
    long. However, it is better to use an uppercase L to avoid confusing the letter
    with the numeric digit "1" (one). In the following example, an unwary reader might
    see the literal as one hundred and one versus the integer 10:'
  prefs: []
  type: TYPE_NORMAL
- en: '`10l` versus `10L`'
  prefs: []
  type: TYPE_NORMAL
- en: Floating point literals are numbers that contain a decimal point or those that
    are written using scientific notation.
  prefs: []
  type: TYPE_NORMAL
- en: '| Literal | Type |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `3.14` | `double` |'
  prefs: []
  type: TYPE_TB
- en: '| `10e6` | `double` |'
  prefs: []
  type: TYPE_TB
- en: '| `0.042F` | `float` |'
  prefs: []
  type: TYPE_TB
- en: Java 7 added the ability to uses underscore characters (`_`) in numeric literals.
    This enhances the readability of code by adding a visual spacing between significant
    parts of a literal. Underscores can be added almost anywhere with a numeric literal.
    It can be used with floating point numbers and with any integer base (binary,
    octal, hexadecimal, or decimal). In addition, base 2 literal are also supported.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table illustrates the use of underscores with a variety of numeric
    literals:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Example | Usage |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `111_22_3333` | Social security number |'
  prefs: []
  type: TYPE_TB
- en: '| `1234_5678_9012_3456` | Credit card number |'
  prefs: []
  type: TYPE_TB
- en: '| `0b0110_00_1` | Binary literal representing a byte |'
  prefs: []
  type: TYPE_TB
- en: '| `3._14_15F` | PI |'
  prefs: []
  type: TYPE_TB
- en: '| `0xE_44C5_BC_5` | Hexadecimal literal for a 32-bit quantity |'
  prefs: []
  type: TYPE_TB
- en: '| `0450_123_12` | 24-bit octal literal |'
  prefs: []
  type: TYPE_TB
- en: 'The use of literals in code has no effect on the internal representation of
    the number or how it is displayed. For example, if we use a long literal to represent
    a social security number, the number is stored internally in two''s complement
    notation and will be displayed as an integer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'If it is necessary to display the number formatted as a social security number,
    this needs to be done in code. The following is one of the approaches to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'When executed, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The use of the underscore is to make the code more readable to the developer
    but it is ignored by the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a couple of other things to consider when using underscores in literals.
    First, consecutive underscores are treated as one and also ignored by the compiler.
    Also, underscores cannot be placed:'
  prefs: []
  type: TYPE_NORMAL
- en: At the beginning or end of a number
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adjacent to a decimal point
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prior to the `D`, `F`, or `L` suffix
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following table illustrates invalid usage of the underscores. These will
    generate the syntax error: `illegal underscore`:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Example | Problem |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `_123_6776_54321L` | Cannot begin with an underscore |'
  prefs: []
  type: TYPE_TB
- en: '| `0b0011_1100_` | Cannot end with an underscore |'
  prefs: []
  type: TYPE_TB
- en: '| `3._14_15F` | Cannot be adjacent to a decimal point |'
  prefs: []
  type: TYPE_TB
- en: '| `987_654_321_L` | Cannot be adjacent to an `L` suffix |'
  prefs: []
  type: TYPE_TB
- en: 'Some applications need to manipulate the bits of a value. The following example
    will perform a bitwise AND operation against a value using a mask. A mask is a
    sequence of bits that are used to isolate part of another value. In this example,
    `value` represents a bit sequence whose last four bits we wish to isolate. The
    binary literal represents the mask:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The AND operation will return zeroes when ANDed with a mask containing zeroes.
    In the preceding example, the first four bits of result of the expression will
    be zeroes. The last four bits are ANDed with ones which result in the last four
    bits of the result being the same as the last four bits of value. Thus, the last
    four bits have been isolated.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is illustrated by executing the following code sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'When executed we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The following diagram illustrates this AND operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Numeric literals](img/7324_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Character literals
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Character literals are single characters enclosed in single quotes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'However, one or more symbols can be used to represent a character. The backslash
    character is used to "escape" or give special meaning to a letter. For example,
    `''\n''` represents the carriage return line feed character. These special escape
    sequences represent certain special values. These escape sequences can also be
    used within a string literal. Escape sequence characters are listed in the following
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Escape Sequence Character | Meaning |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `\a` | alert (bell) |'
  prefs: []
  type: TYPE_TB
- en: '| `\b` | backspace |'
  prefs: []
  type: TYPE_TB
- en: '| `\f` | form feed |'
  prefs: []
  type: TYPE_TB
- en: '| `\n` | new line |'
  prefs: []
  type: TYPE_TB
- en: '| `\r` | carriage return |'
  prefs: []
  type: TYPE_TB
- en: '| `\t` | horizontal tab |'
  prefs: []
  type: TYPE_TB
- en: '| `\v` | vertical tab |'
  prefs: []
  type: TYPE_TB
- en: '| `\\` | backslash |'
  prefs: []
  type: TYPE_TB
- en: '| `\?` | question mark |'
  prefs: []
  type: TYPE_TB
- en: '| `\''` | single quote |'
  prefs: []
  type: TYPE_TB
- en: '| `\"` | double quote |'
  prefs: []
  type: TYPE_TB
- en: '| `\ooo` | octal number |'
  prefs: []
  type: TYPE_TB
- en: '| `\xhh` | hexadecimal number |'
  prefs: []
  type: TYPE_TB
- en: String literals
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'String literals are a sequence of characters that are enclosed in a set of
    double quotes. String literals cannot be split across two lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Constants
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Constants are identifiers whose values cannot change. They are used in situations
    where, instead of using a literal, a more readable name should be used instead.
    In Java, constants are declared by prefixing the variable declaration with the
    `final` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, three constants are declared—`PI`, `NUMSHIPS`, and
    `RATEOFRETURN`. Each of these is capitalized as per the standard *Java naming
    conventions* section of [Chapter 1](ch01.html "Chapter 1. Getting Started with
    Java"), *Getting Started with Java*, and is given a value. These values cannot
    be changed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following statement, an attempt is made to change the value of PI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Depending on the compiler, an error message similar to the following will be
    generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This means you cannot change the value of the constant variable.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Constants provide other benefits apart from always having the same value. A
    constant number or object can be handled more efficiently and optimized. This
    makes the application that uses them more efficient and easier to understand.
    Instead of using 3.14159 every place it is needed, we can simply use `PI`.
  prefs: []
  type: TYPE_NORMAL
- en: The final keyword
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'While the `final` keyword is used to declare a constant, it has other uses
    as detailed in the following table. We will cover its use with methods and classes
    in later chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Applied to | Meaning |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Primitive data declaration | The value assigned to the variable cannot be
    changed. |'
  prefs: []
  type: TYPE_TB
- en: '| Reference variable | You cannot change the variable to reference a different
    variable. However, it may be possible to change the object the variable is referencing
    to. |'
  prefs: []
  type: TYPE_TB
- en: '| Method | The method cannot be overridden. |'
  prefs: []
  type: TYPE_TB
- en: '| Class | The class cannot be extended. |'
  prefs: []
  type: TYPE_TB
- en: Enumerations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Enumerations are actually subclasses of the `java.lang.Enum` class. In this
    section, we will look at the creation of a simple enumeration. A more complete
    treatment of this topic is found in [Chapter 6](ch06.html "Chapter 6. Classes,
    Constructors, and Methods"), *Classes, Constructors, and Methods*.
  prefs: []
  type: TYPE_NORMAL
- en: The following example declares an enumeration called `Directions`. This enumeration
    represents the four cardinal points.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We can declare a variable of this type and then assign values to it. The following
    code sequence illustrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this sequence is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'A `enum` call also can be used as part of a switch statement illustrated as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'When executed with the previous code we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Immutable objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Immutable objects are objects whose fields cannot be modified. There are several
    classes whose objects are immutable in the Java core SDK including the `String`
    class. Perhaps surprisingly, the `final` keyword is not used for this purpose.
    These are discussed in more detail in [Chapter 6](ch06.html "Chapter 6. Classes,
    Constructors, and Methods"), *Classes, Constructors, and Methods*.
  prefs: []
  type: TYPE_NORMAL
- en: Instance versus static data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two different types of variables (data) within a class: instance
    and static. When an object is instantiated (using the `new` keyword with a class
    name), each object is composed of the instance variables that make up that class.
    However, there is only one copy of static variables allocated for each class.
    While each class has its own copy of instance variables, all of the classes share
    a single copy of the static variables. These static variables are allocated to
    a separate area of memory and exist for the lifetime of the class.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the addition of a common discount percentage that may be applied selectively
    to some, but not all, customers. Regardless of whether or not it is applied, the
    percentage is always the same. Based on these assumptions, we can add a static
    variable to a class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Static methods and fields are covered in more detail in [Chapter 6](ch06.html
    "Chapter 6. Classes, Constructors, and Methods"), *Classes, Constructors, and
    Methods*.
  prefs: []
  type: TYPE_NORMAL
- en: Scope and lifetime
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Scope refers to where in a program a specific variable can be used. In general,
    a variable is visible within the block statement in which it is declared but not
    outside it. A block statement is a sequence of code encapsulated by curly braces.
  prefs: []
  type: TYPE_NORMAL
- en: If a variable is in scope, then it is visible to the code and can be accessed.
    If it is not in scope, then the variable cannot be accessed and any attempts to
    do so will result in a compile-time error.
  prefs: []
  type: TYPE_NORMAL
- en: The lifetime of a variable refers to the time period in which it has been allocated
    memory. When a variable is declared as a local variable of a method, the memory
    allocated to the variable is in the activation record. As long as the method has
    not returned, the activation record exists and memory is allocated for the variable.
    As soon as the method returns, the activation record is removed from the stack
    and the variable is no longer in existence and cannot be used.
  prefs: []
  type: TYPE_NORMAL
- en: The lifetime of an object allocated from the heap begins when the memory is
    allocated and ends when the memory is de-allocated. In Java, memory is allocated
    for an object using the `new` keyword. An object and its memory are marked for
    de-allocation when it is no longer referenced. In reality, it is de-allocated
    at some indeterminate point in the future when a garbage collection routine runs,
    if at all. If an object has no references to it, it can be used or accessed even
    if the garbage collector has not reclaimed it.
  prefs: []
  type: TYPE_NORMAL
- en: Scoping rules
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Scoping rules are critical to understanding how block structure languages, such
    as Java, work. These rules explain when a variable can be used and which one of
    the several will be used when a naming conflict occurs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Scoping rules revolve around the concept of a block. A block is delineated
    by an opening and closing curly brace. These blocks are used to group code together
    and to define the scope of a variable. The following diagram shows the scope of
    three variables, `i`, `j`, and `k`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Scoping rules](img/7324_02_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Access modifiers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Access modifiers can be used as prefixes when declaring instance and static
    variables and methods. Modifiers are applied in various combinations to provide
    specific behaviors. The modifier order is not always important, but consistent
    style leads to more readable code. All modifiers are optional though there are
    some default modifiers. Access modifiers include:'
  prefs: []
  type: TYPE_NORMAL
- en: '`public`: A public object is visible to all methods inside and outside its
    own class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`protected`: This allows protection between the current class and subclasses.
    A protected object is invisible outside *-the class, fully visible to subclasses.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`private`: A private variable cannot be seen by any class other than the one
    in which it is defined (including subclasses).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**package**: This visibility is the default protection. Only classes within
    the package have the access (public within the package).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To explain the scope of variables, consider the package/class organization
    shown in the following diagram, where the arrows indicate inheritance:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Access modifiers](img/7324_02_05a.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Assume that the A class is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'All of the variables are of type `int`. The `publicInt` variable is a public
    variable. It can be seen by all methods inside and outside of this class. The
    `privateInt` variable is only visible within this class. The `protectedInt` variable
    is visible only to those classes within this package. The `protectedInt` variable
    is visible to this class, its subclasses, and other classes in the same package.
    It is not visible elsewhere. The following table shows the visibility of each
    of the declaration types to each of the classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '|   | A | B | C | D | E |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `publicInt` | Visible | Visible | Visible | Visible | Visible |'
  prefs: []
  type: TYPE_TB
- en: '| `privateInt` | Visible | Invisible | Invisible | Invisible | Invisible |'
  prefs: []
  type: TYPE_TB
- en: '| `protectedInt` | Visible | Visible | Visible | Invisible | Visible |'
  prefs: []
  type: TYPE_TB
- en: '| `defaultInt` | Visible | Visible | Visible | Invisible | Invisible |'
  prefs: []
  type: TYPE_TB
- en: Data summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following table summarizes the types of variables and their relationship
    to Java compile-time and run-time elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Program element | Variable type | Part of | Allocated to |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Class | Instance | Object | Heap |'
  prefs: []
  type: TYPE_TB
- en: '| Static | Class | Special region of memory |'
  prefs: []
  type: TYPE_TB
- en: '| Method | Parameter | Activation record | Activation record of the stack |'
  prefs: []
  type: TYPE_TB
- en: '| Local |'
  prefs: []
  type: TYPE_TB
- en: Building expressions using operands and operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An expression consists of operands and operators. Operands are normally variable
    names or literals while operators act on operands. The following are examples
    of expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'There are several ways of classifying operators:'
  prefs: []
  type: TYPE_NORMAL
- en: Arithmetic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assignment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Relational
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logical complement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logical
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conditional
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bitwise
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Expressions can be thought of as the building blocks of a program. They are
    used to express the logic of the program.
  prefs: []
  type: TYPE_NORMAL
- en: Precedence and associativity
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Java operators are summarized in the following precedence and associativity
    table. Most of these operators are straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Precedence | Operator | Associativity | Operator |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | `++` | Right | Pre/post increment |'
  prefs: []
  type: TYPE_TB
- en: '| `--` | Right | Pre/post decrement |'
  prefs: []
  type: TYPE_TB
- en: '| `+,-` | Right | Unary plus or minus |'
  prefs: []
  type: TYPE_TB
- en: '| `~` | Right | Bitwise complement |'
  prefs: []
  type: TYPE_TB
- en: '| `!` | Right | Logical complement |'
  prefs: []
  type: TYPE_TB
- en: '| (cast) | Right | Cast |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | `*`, `/`, and `%` | Left | Multiplication, division, and modulus |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | `+` and `-` | Left | Addition and subtraction |'
  prefs: []
  type: TYPE_TB
- en: '| `+` | Left | String concatenation |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | `<<` | Left | Left shift |'
  prefs: []
  type: TYPE_TB
- en: '| `>>` | Left | Right shift and sign fill |'
  prefs: []
  type: TYPE_TB
- en: '| `>>>` | Left | Right shift and zero fill |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | `<`, `<=`, `>`, `>=` | Left | Logical |'
  prefs: []
  type: TYPE_TB
- en: '| `Instanceof` | Left | Type comparison |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | `==` and `!=` | Left | Equality and inequaltity |'
  prefs: []
  type: TYPE_TB
- en: '| 7 | `&` | Left | Bitwise and Boolean AND |'
  prefs: []
  type: TYPE_TB
- en: '| 8 | `^` | Left | Bitwise and Boolean XOR |'
  prefs: []
  type: TYPE_TB
- en: '| 9 | `&#124;` | Left | Bitwise and Boolean OR |'
  prefs: []
  type: TYPE_TB
- en: '| 10 | `&&` | Left | Boolean AND |'
  prefs: []
  type: TYPE_TB
- en: '| 11 | `&#124;&#124;` | Left | Boolean OR |'
  prefs: []
  type: TYPE_TB
- en: '| 12 | `?:` | Right | Conditional |'
  prefs: []
  type: TYPE_TB
- en: '| 13 | `=` | Right | Assignment |'
  prefs: []
  type: TYPE_TB
- en: '| `+=`, `-=`, `*=`, `/=`, and `%=` | Right | Compound |'
  prefs: []
  type: TYPE_TB
- en: 'While the use of most of these operators is straightforward, more detailed
    examples for their usage are provided in later chapters. However, bear in mind
    that there are no other variations and no other operators available in Java. For
    example, `+=` is a valid operator while `=+` is not. However, it can be used with
    possibly unintended consequences. Consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The last statement appears to be using a =+ operator. In reality, it is the
    assignment operator followed by the unary plus operator. A `+2` is assigned to
    `total`. Remember, Java ignores white space except within string literals.
  prefs: []
  type: TYPE_NORMAL
- en: Casting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When one type of data is assigned to a different type of data, it is possible
    to lose information. If the data is being assigned from a more precise data type
    to a less precise data type, it is referred to as **narrowing** . For example,
    if the floating point number `45.607` is assigned to an integer, the fractional
    part, `.607`, is lost.
  prefs: []
  type: TYPE_NORMAL
- en: 'When making assignments of this type, the cast operator should be used. The
    cast operator is simply the data type that you are casting to, enclosed in parentheses.
    The following shows several explicit casting operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Without the use of the cast operator in such situations, the compiler will issue
    a warning. The warning is there to suggest that you look more closely at the assignments.
    The loss of precision may or may not be a problem, depending upon the use of the
    data within the application. Without a cast operator, an implicit cast is made
    when the code is executed.
  prefs: []
  type: TYPE_NORMAL
- en: Working with characters and strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The primary classes include the `String`, `StringBuffer`, `StringBuilder`, and
    `Character` classes. There are several other classes and interfaces related to
    string and character manipulation, listed as follows, that you should be aware
    of. However, not all of the following classes will be detailed here.
  prefs: []
  type: TYPE_NORMAL
- en: '`Character`: This deals with the manipulation of character data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Charset`: This defines a mapping between Unicode characters and a sequence
    of bytes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CharSequence`: In this, an interface is implemented by the `String`, `StringBuffer`
    and `StringBuilder` classes defining common methods'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`StringTokenizer`: This is used for tokenizing text'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`StreamTokenizer`: This is used for tokenizing text'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Collator`: This is used to support operations on locale specific strings'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The String, StringBuffer, and StringBuilder classes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are several string-related classes available to the Java programmer. In
    this section, we will examine the classes and techniques available in Java for
    manipulating this type of data.
  prefs: []
  type: TYPE_NORMAL
- en: The three primary classes for string manipulation found in the JDK are the `String`,
    `StringBuffer`, and `StringBuilder`. The `String` class is the most widely used
    of these classes. The `StringBuffer` and `StringBuilder` classes were introduced
    in Java 5 to address efficiency issues of the `String` class. The `String` class
    is immutable and an application that requires frequent changes to a string will
    be burdened by the overhead of having to create new immutable objects. The `StringBuffer`
    and `StringBuilder` classes are mutable objects and can be used more efficiently
    when strings need to be modified frequently. `StringBuffer` differs from `StringBuilder`
    in that its methods are synchronized.
  prefs: []
  type: TYPE_NORMAL
- en: In terms of methods supported by the classes, the methods of `StringBuffer`
    and `StringBuilder` are identical. They only differ in whether the methods are
    synchronized or not.
  prefs: []
  type: TYPE_NORMAL
- en: '| Class | Mutable | Synchronized |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `String` | No | No |'
  prefs: []
  type: TYPE_TB
- en: '| `StringBuffer` | Yes | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| `StringBuilder` | Yes | No |'
  prefs: []
  type: TYPE_TB
- en: A synchronized method is useful when dealing with applications that use multiple
    threads. A **thread** is a code sequence that executes on its own. It will run
    at the same time as other threads within the same application. Concurrent threads
    do not pose a problem unless they are sharing data. When this happens it is possible
    for that data to become corrupted. The use of synchronized methods addresses this
    problem and prevents the data from being corrupted due to the interaction of the
    threads.
  prefs: []
  type: TYPE_NORMAL
- en: The use of synchronized methods includes some overhead. Thus, if the string
    is not being shared by multiple threads then the overhead introduced by the `StringBuffer`
    class is not needed. When synchronization is not needed, in most cases the `StringBuilder`
    class should be used.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Criteria for using string classes**'
  prefs: []
  type: TYPE_NORMAL
- en: 'If the string is not going to change, use the `String` class:'
  prefs: []
  type: TYPE_NORMAL
- en: As it is immutable it is safe for sharing between multiple threads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The threads will only read them, which is normally a thread safe operation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If the string is going to change and it will be shared between threads, then
    use the `StringBuffer` class:'
  prefs: []
  type: TYPE_NORMAL
- en: This class is designed for just this situation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using this class in this situation will insure that the string is updated correctly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The chief drawback is that the methods may execute slower
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If the string is to change but will not be shared between the threads, use
    the `StringBuilder` class:'
  prefs: []
  type: TYPE_NORMAL
- en: It allows modification of the strings but does not incur the overhead of synchronization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The methods of this class will execute as fast as, or faster, than those of
    the `StringBuffer` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unicode characters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Java uses the Unicode standard to define a character. However, this standard
    has evolved and changed, and Java has accommodated its changes. Originally the
    Unicode standard defined a character as a 2 byte 16-bit value which could be represented
    using printable characters or `U+0000` through `U+FFFF`. Hexadecimal digits can
    be use to encode the Unicode characters whether they were printable or not.
  prefs: []
  type: TYPE_NORMAL
- en: However, the 2-byte encoding was not sufficient for all languages. So, version
    4 of the Unicode standard introduced new characters above `U+FFFF` called **UTF-16**
    (**16-bit Unicode Transformation Format**). Java, in support of the new standard,
    uses the concept of **surrogate** **pairs** —pairs of 16-bit chars. These pairs
    are used to represent values from `U+10000` through `U+10FFFF`. The leading or
    high value of the surrogate pair ranges from `U+D800` through `U+DBFF`. The trailing
    or low value of the pair ranges from `U+DC00` through `U+DFFF`. Characters in
    this latter range are called **supplementary** **characters** . These two special
    ranges are used to map any Unicode character into a surrogate pair. As of JDK
    5.0, a character is represented using UTF-16.
  prefs: []
  type: TYPE_NORMAL
- en: The Character class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Character` class is a wrapper class for the `char` primitive data type.
    This data type supports the Unicode standard version 4.0\. Characters are defined
    as fixed-width, 16-bit quantities.
  prefs: []
  type: TYPE_NORMAL
- en: The Character class – methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `Character` class possesses a number of methods for dealing with characters.
    Many of the `Character` methods are overloaded and can take either a char or a
    Unicode code point parameter. A code point is an abstraction used for a character
    and for our purposes is a Unicode character. The following table lists several
    `Character` methods that you are likely to encounter:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Methods | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `isDigit` | Returns `true` if the character is a digit |'
  prefs: []
  type: TYPE_TB
- en: '| `isLetter` | Returns `true` if the character is a letter |'
  prefs: []
  type: TYPE_TB
- en: '| `isLetterOrDigit` | Returns `true` if the character is a letter or a digit
    |'
  prefs: []
  type: TYPE_TB
- en: '| `isLowerCase` | Returns `true` if the character is a lower case letter |'
  prefs: []
  type: TYPE_TB
- en: '| `isSpace` | Returns `true` if the character is a space |'
  prefs: []
  type: TYPE_TB
- en: '| `isUpperCase` | Returns `true` if the character is an upper case letter |'
  prefs: []
  type: TYPE_TB
- en: '| `toLowerCase` | Returns the lower case equivalent of the character |'
  prefs: []
  type: TYPE_TB
- en: '| `toUpperCase` | Returns the upper case equivalent of the character |'
  prefs: []
  type: TYPE_TB
- en: The String class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `String` class is a common class used to represent strings in Java. It is
    immutable which makes it thread safe. That is, multiple threads can access the
    same string and not worry about corrupting the string. Being immutable also means
    that it is of a fixed size.
  prefs: []
  type: TYPE_NORMAL
- en: One of the reasons the `String` class was made immutable was for security reasons.
    If a string is used to identify a resource that is protected, once permission
    has been granted for that resource, it may be possible to modify the string and
    then obtain access to another resource for which the user does not have permission.
    By making it immutable, this vulnerability is avoided.
  prefs: []
  type: TYPE_NORMAL
- en: 'While the `String` class is immutable, it may still appear to be mutable. Consider
    the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this sequence is the string "Constant and unchangeable". As `s`
    is defined as a `String` type, the object referenced by the `s` identifier cannot
    change. When the second assignment statement is made, a new object is created
    that combines `Constant` and `and unchangeable` together to produce a new string
    `Constant and unchangeable`. Three `String` objects are created in the process:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Constant`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`and unchangeable`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Constant and unchangeable`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The identifier, `s`, now references the new string `Constant and unchangeable`.
  prefs: []
  type: TYPE_NORMAL
- en: While we have access to these objects, we were not able to change them. We can
    access and read them but we cannot modify them.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could have used the `String` class'' `concat` method but this is not as
    straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The following code illustrates several techniques for creating a `String` object.
    The first constructor will only produce an empty string. This is not of immediate
    value unless an empty immutable string located on the heap is needed in the application.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition, there are two constructors that use the `StringBuffer` and `StringBuilder`
    classes. New `String` objects are created from these objects, as shown in the
    following code sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Internally, a string of the `String` class is represented as an array of `char`.
  prefs: []
  type: TYPE_NORMAL
- en: String comparisons
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'String comparisons are not as straightforward as they might initially appear.
    If we wanted to compare two integers, we might use a statement such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'However, for the comparisons of two strings, such as `s1` and `s2`, the following
    will often evaluate as `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The problem is that the variables `s1` and `s2` may be referencing different
    objects in memory. The if statement is comparing string reference variables and
    not the actual strings. As they are referencing different objects, the comparison
    returns `false`. It all depends on how the compiler and run-time system handles
    the strings internally.
  prefs: []
  type: TYPE_NORMAL
- en: When the `new` keyword is used, memory is allocated from the heap and assigned
    to the new object. In the case of a string literal however, this memory does not
    come from the heap but instead from a literal pool, or more specifically, the
    string intern pool. In Java, interned strings are placed into the permanent generation
    area of the JVM. This area also stores Java class declarations and class static
    variables, among other things.
  prefs: []
  type: TYPE_NORMAL
- en: String interning stores only one copy of each distinct string. This is to improve
    the execution of certain string methods and reduce the amount of space used to
    represent identical strings. The strings in this area are subject to garbage collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if we create two string literals and a `String` object using the
    `new` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The output follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The `String` class' `intern` method can be used to intern a string. Interning
    is performed automatically for all constant strings. When comparing interned strings,
    the equality operator can be used instead of having to use the `equals` method.
    This can save time for string intensive applications. It is easy to forget to
    intern a string, so be careful using the equality operator. In addition to this,
    the `intern` method can be an expensive method to use.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Other objects besides the `String` type are interned by Java. These include
    wrapper objects and small integer values. Wrapper objects can result when a string
    concatenation operator is used with a primitive type. For more details visit [http://docs.oracle.com/javase/specs/jls/se7/jls7.pdf](http://docs.oracle.com/javase/specs/jls/se7/jls7.pdf)
    and refer to sections 5.1.7 and 12.5.
  prefs: []
  type: TYPE_NORMAL
- en: 'To perform `String` comparisons, there is a number of `String` methods you
    can use including, but not necessarily limited to, the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Purpose |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `equals` | Compares two strings and returns `true` if they are equivalent
    |'
  prefs: []
  type: TYPE_TB
- en: '| `equalsIgnoreCase` | Compares two strings while ignoring the case of the
    letters and returns `true` if they are equivalent |'
  prefs: []
  type: TYPE_TB
- en: '| `startsWith` | Returns `tru` `e` if the string starts with the specified
    character sequence |'
  prefs: []
  type: TYPE_TB
- en: '| `endsWith` | Returns `true` if the string ends with the specified character
    sequence |'
  prefs: []
  type: TYPE_TB
- en: '| `compareTo` | Returns `-1` if the first string precedes the second, `0` if
    they are equal to each other, or `1` if the first string follows the second string
    |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember that strings start with an index `0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following illustrates the use of various string comparisons:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: There are several things to consider when using this method. First, uppercase
    letters come before lowercase letters. This is the result of their ordering in
    Unicode. The same ordering applies to ASCII.
  prefs: []
  type: TYPE_NORMAL
- en: A string can have multiple internal representations. Many languages use the
    accent to differentiate or emphasize a character. For example, the French name,
    Irène, uses an accent and can be represented either as `I` `r` `è` `n` `e` or
    as the sequence `I` `r` `e` [PRE39] to form the character `è`. If these two different
    internal representations were compared using the `equals` method, the method would
    return `false`. In this example, `\u0300` combines the grave accent with the letter
    `e`.
  prefs: []
  type: TYPE_NORMAL
- en: String firstIrene = "Irène";
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this code sequence is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The `Collator` class can be used to manipulate strings in a locale-specific
    manner removing the problems of different internal string representations.
  prefs: []
  type: TYPE_NORMAL
- en: Basic string methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are several `String` methods you may encounter. These are illustrated
    in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Purpose |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `length` | Returns the length of the string. |'
  prefs: []
  type: TYPE_TB
- en: '| `charAt` | Returns the position of a character given an index in the string.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `substring` | This method is overloaded and returns parts of the string.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `indexOf` | Returns the position of the first occurrence of a char or string.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `lastIndexOf` | Returns the position of the last occurrence of a char or
    string. |'
  prefs: []
  type: TYPE_TB
- en: 'The following examples illustrate the use of these methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'When this code is executed, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Searching a string for a character or sequence of characters is a common requirement
    of many applications. The `indexOf` and `lastIndex` methods perform this type
    of operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The results of these statements are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'You can think of the position in a string as a position immediately before
    a character. These positions or indexes start at `0`, as illustrated in the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Basic string methods](img/7324_02_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: String length
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The calculation of the length of a string can be a bit more complicated than
    suggested by the simple use of the `length` method. It depends upon what is being
    counted and how the string is represented internally.
  prefs: []
  type: TYPE_NORMAL
- en: 'Methods that can be used to determine the length of a string include:'
  prefs: []
  type: TYPE_NORMAL
- en: '`length`: The standard method used'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`codePointCount`: This is used in conjunction with supplementary characters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `length` method of an array of bytes: This is used to determine the actual
    number of bytes used to hold the string'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The actual length of the string in bytes can be important when storing a string.
    The amount of space allocated in a table of a database may need to be longer than
    simply the number of characters in the string.
  prefs: []
  type: TYPE_NORMAL
- en: Number/string conversions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The process of converting a number to a string is important. There are two
    approaches we can use. The first approach uses a static method, as shown in the
    following code sequence. The `valueOf` method will convert a number to a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The `intValue` and `doubleValue` methods take the object returned by the `valueOf`
    static method and return an integer or double number respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The second approach is to use the `parseInt` and `parseDouble` methods of their
    respective wrapper classes. Their use is illustrated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Miscellaneous String methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are several miscellaneous methods that can be useful:'
  prefs: []
  type: TYPE_NORMAL
- en: '`replace`: This replaces a part of a string with another string'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`toLowerCase`: This converts all characters to lower case in a string'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`toUpperCase`: This converts all characters to upper case in a string'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`trim`: This removes leading and trailing blanks'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The use of these methods is illustrated below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The results are shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The StringBuffer and StringBuilder classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `StringBuffer` and `StringBuilder` classes provide an alternative to the
    `String` class. Unlike the `String` class, they are mutable. This is sometimes
    helpful in making a program more efficiently. There are several commonly used
    methods that are available to manipulate a `StringBuffer` or a `StringBuilder`
    object. Several of these are illustrated in the example that follows. While the
    examples use the `StringBuffer` class, the `StringBuilder` method works the same
    way.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is frequently necessary to append one string to another. This can be accomplished
    using the `append` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The following illustrates inserting a string into a buffer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'A more detailed example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we have examined how Java deals with the data. The use of the
    stack and heap are important programming concepts that go a long way in explaining
    concepts such as the scope and lifetime of a variable. The difference between
    objects and primitive data types was introduced along with the initialization
    of variables. The initialization process will be covered in more detail in [Chapter
    6](ch06.html "Chapter 6. Classes, Constructors, and Methods"), *Classes, Constructors,
    and Methods*. The operators available in Java were listed along with the rules
    of precedence and associativity. In addition, the manipulation of character and
    string data was presented.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter we will explore the decision constructs available in Java
    and how they can be used effectively. This will build upon the data types presented
    here.
  prefs: []
  type: TYPE_NORMAL
- en: Certification objectives covered
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter we covered the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding how Java handles data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Investigating the relationships between identifiers, the Java class, and memory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining the scope of the variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initializing identifiers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building expressions using operators and operands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with strings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the difference between objects and primitive data types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test your knowledge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What will happen when you compile and run the following code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: a. 35 will be printed out
  prefs: []
  type: TYPE_NORMAL
- en: b. 45 will be printed out
  prefs: []
  type: TYPE_NORMAL
- en: c. A compile time error will be generated
  prefs: []
  type: TYPE_NORMAL
- en: d. An exception will be thrown
  prefs: []
  type: TYPE_NORMAL
- en: Which of the following lines will compile without warning or error?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. `char d="d";`
  prefs: []
  type: TYPE_NORMAL
- en: b. `float f=3.1415;`
  prefs: []
  type: TYPE_NORMAL
- en: c. `int i=34;`
  prefs: []
  type: TYPE_NORMAL
- en: d. `byte b=257;`
  prefs: []
  type: TYPE_NORMAL
- en: e. `boolean isPresent=true;`
  prefs: []
  type: TYPE_NORMAL
- en: 'Given the following declaration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Which of the following statements are correct if they replace the comment line?
  prefs: []
  type: TYPE_NORMAL
- en: a. `System.out.println(i);`
  prefs: []
  type: TYPE_NORMAL
- en: b. `System.out.println(sc.i);`
  prefs: []
  type: TYPE_NORMAL
- en: c. `System.out.println(SomeClass.i);`
  prefs: []
  type: TYPE_NORMAL
- en: d. `System.out.println((new SomeClass()).i);`
  prefs: []
  type: TYPE_NORMAL
- en: 'Given the following declaration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Which of the following are valid uses of the `sb` variable?
  prefs: []
  type: TYPE_NORMAL
- en: a. `sb.append(34.5);`
  prefs: []
  type: TYPE_NORMAL
- en: b. `sb.deleteCharAt(34.5);`
  prefs: []
  type: TYPE_NORMAL
- en: c. `sb.toInteger` `(3);`
  prefs: []
  type: TYPE_NORMAL
- en: d. `sb.toString();`
  prefs: []
  type: TYPE_NORMAL
- en: Which of the following will return the position of the first letter `a` where
    the string s contains "banana"?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. `lastIndexOf(2,s);`
  prefs: []
  type: TYPE_NORMAL
- en: b. `s.indexOf('a');`
  prefs: []
  type: TYPE_NORMAL
- en: c. `s.charAt(` `2);`
  prefs: []
  type: TYPE_NORMAL
- en: d. `indexOf(s,'v');`
  prefs: []
  type: TYPE_NORMAL
- en: Given the following code, which expression displays the word "Equal"?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: a. `s1==s2`
  prefs: []
  type: TYPE_NORMAL
- en: b. `s1.matchCase(s2)`
  prefs: []
  type: TYPE_NORMAL
- en: c. `s1.equalsIgnoreCase(s2)`
  prefs: []
  type: TYPE_NORMAL
- en: d. `s1.equals(s2)`
  prefs: []
  type: TYPE_NORMAL
