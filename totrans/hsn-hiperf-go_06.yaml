- en: Matrix and Vector Computation in Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Matrix and vector computation are important in computer science. Vectors can
    hold a group of objects in a dynamic array. They use contiguous storage and can
    be manipulated to accommodate growth. Matrices build on vectors, creating a two-dimensional
    set of vectors. In this chapter, we are going to discuss matrices and vectors
    along with how these two data structures can be used practically to perform much
    of the data manipulation that happens in computer science today. Vectors and matrices
    are building blocks that are commonly used for linear algebra, which is important
    in today's computer science. Processes such as image processing, computer vision,
    and web search all utilize linear algebra to perform their respective actions.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn about the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Basic Linear Algebra Subprograms** (**BLAS**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vectors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Matrices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vector and matrix manipulation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once we are able to tie all of these things together, you will learn how these
    different facets of matrix and vector computation can help drive forward the effective
    manipulation of large groupings of data.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Gonum and the Sparse library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most popular libraries in Go for scientific algorithms is the Gonum
    package. The Gonum package ([https://github.com/gonum](https://github.com/gonum))
    provides utilities that assist us in writing effective numerical algorithms using
    Go. This package focuses on creating performant algorithms for use in many different
    applications, and vectors and matrices are core tenets of this package. This library
    was created with performance in mind – the creators saw a problem with fighting
    vectorization in C, so they built this library in order to be able to manipulate
    vectors and matrices more easily in Go. The Sparse library ([https://github.com/james-bowman/sparse](https://github.com/james-bowman/sparse))
    was built on top of the Gonum library in order to handle some of the normal sparse
    matrix operations that happen in machine learning and other parts of scientific
    computing. Using these libraries together is a performant way to manage vectors
    and matrices in Go.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we'll look at what BLAS is.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing BLAS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A specification called BLAS is commonly used in order to perform linear algebra
    operations. This library was originally created as a FORTRAN library in 1979 and
    has been maintained since then. BLAS has many optimizations for performant manipulation
    of matrices. Because of the depth and breadth of this specification, many languages
    have chosen to use this specification as part of their linear algebra libraries
    within their domain. The Go Sparse library uses a BLAS implementation for its
    linear algebra manipulation. The BLAS specification is composed of three separate
    routines:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Level 1: Vector operations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Level 2: Matrix-vector operations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Level 3: Matrix-matrix operations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Having these leveled routines helps with the implementation and testing of this
    specification. BLAS has been used in many implementations, from Accelerate (macOS
    and iOS framework) to the Intel **Math Kernel Library** (**MKL**), and has been
    an integral part of linear algebra in applied computer science.
  prefs: []
  type: TYPE_NORMAL
- en: Now, it's time to learn about vectors.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing vectors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A vector is a one-dimensional array that is often used for storing data. Go
    originally had a container/vector implementation, but this was removed on 18 October
    2011, as slices were deemed more idiomatic for vector use in Go. The functionality
    provided by the built-in slice gives plenty of vector manipulation help. A slice
    would be a row vector, or 1 × m matrix, implementation. A simple row vector looks
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00b322c7-b978-45a4-a681-2f4397aa7199.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, we have a 1 × m matrix. To implement a simple row vector in
    Go, we can use a slice representation, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This is an easy way to portray a simple row vector using Go's built-in functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Vector computations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A column vector is an m x 1 matrix, also known as the transpose of a row vector.
    A matrix transposition is when a matrix is flipped over its diagonal, often denoted
    with a superscript T. We can see an example of a column vector in the following
    image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a47f76c2-b883-4fba-adc9-1eb32396c694.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If we want to implement a column vector in Go, we can use the Gonum vector
    package to initialize this vector, as shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This will print out a column vector like the one shown in the preceding image.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also do some neat vector manipulation with the Gonum package. For example,
    in the following code block, we can see how simple it is to double the values
    within a vector. We can add two vectors together using the `AddVec` function,
    thus creating a doubled vector. We also have the `prettyPrintMatrix` convenience
    function to make our matrix easier to read:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of this function, that is, a doubled vector, is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1b020747-a770-4fb4-ad41-98648242a382.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `gonum/mat` package also gives us many other neat helper functions for
    vectors, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Cap()` gives you the capacity of the vector'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Len()` gives you the number of columns within the vector'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IsZero()` validates whether or not a vector is zero-sized'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MulVec()` multiplies vectors *a* and *b* and serves the result'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AtVec()` returns the value within the vector at a given position'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The vector manipulation functions within the `gonum/mat` package help us to
    easily manipulate vectors into the datasets that we need.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we are done with vectors, let's look at matrices.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing matrices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Matrices are two-dimensional arrays, categorized by rows and columns. They are
    important in graphics manipulation and AI; namely, image recognition. Matrices
    are commonly used for graphics since the rows and columns that reside within a
    matrix can correspond to the row and column arrangement of pixels on a screen,
    as well as because we can have the matrix values correspond to a particular color.
    Matrices are also frequently used for digital sound processing as digital audio
    signals are filtered and compressed using Fourier transforms, and matrices help
    with performing these actions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Matrices are usually denoted with an *M × N* naming scheme, where *M* is the
    number of rows in the matrix and *N* is the number of columns in the matrix, as
    shown in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d388ff6d-3fc2-431f-9a5a-f3afa4dd282c.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding image, for example, is a 3 x 3 matrix. An *M x N* matrix is one
    of the core tenants of linear algebra, so it's important to see its relationship
    here.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's see how matrices operate.
  prefs: []
  type: TYPE_NORMAL
- en: Matrix operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Matrices are a good way to store a large amount of information in an efficient
    manner, but the manipulation of matrices is where the real value of matrices is
    derived from. The most commonly used matrix manipulation techniques are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Matrix addition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Matrix scalar multiplication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Matrix transposition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Matrix multiplication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Being able to perform these actions on matrices is important as they can help
    with real-world data manipulation at scale. We will take a look at some of these
    operations, as well as practical applications of them, in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Matrix addition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Matrix addition is the method in which we add two matrices together. Perhaps
    we want to find the resulting value of the summation of two 2D sets. If we have
    two matrices of the same size, we can add them together, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8bccb841-8f4e-4dab-8dce-228ef662ba58.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can also represent this in Go code, as shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of executing this function is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/71bc0301-19cd-4cf0-90da-68a61be2c948.png)'
  prefs: []
  type: TYPE_IMG
- en: The result is a depiction of the matrix summation from our code block.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will discuss a practical example of matrix manipulation.
    To demonstrate this example, we will use matrix subtraction.
  prefs: []
  type: TYPE_NORMAL
- en: A practical example (matrix subtraction)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Suppose you own two restaurants, one in **New York, NY** and one in **Atlanta,
    GA**. You want to figure out what items are selling the best in your restaurants
    each month in order to make sure that you stock the right ingredients in the upcoming
    months. We can utilize matrix subtraction to find the net total number of unit
    sales we had for each restaurant. We need to have the raw data for unit sales
    for each restaurant, as shown in the following tables:'
  prefs: []
  type: TYPE_NORMAL
- en: 'May unit sales:'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | **New York, NY** | **Atlanta, GA** |'
  prefs: []
  type: TYPE_TB
- en: '| Lobster Bisque | 1,345 | 823 |'
  prefs: []
  type: TYPE_TB
- en: '| House Salad | 346 | 234 |'
  prefs: []
  type: TYPE_TB
- en: '| Ribeye Steak | 843 | 945 |'
  prefs: []
  type: TYPE_TB
- en: '| Ice Cream Sundae | 442 | 692 |'
  prefs: []
  type: TYPE_TB
- en: 'June unit sales:'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | **New York, NY** | **Atlanta, GA** |'
  prefs: []
  type: TYPE_TB
- en: '| Lobster Bisque | 920 | 776 |'
  prefs: []
  type: TYPE_TB
- en: '| House Salad | 498 | 439 |'
  prefs: []
  type: TYPE_TB
- en: '| Ribeye Steak | 902 | 1,023 |'
  prefs: []
  type: TYPE_TB
- en: '| Ice Cream Sundae | 663 | 843 |'
  prefs: []
  type: TYPE_TB
- en: 'Now, we can find the difference in unit sales between these two months using
    the following matrix subtraction:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/43b44258-6545-45bf-af7b-ec30fd67ef97.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can perform this same action in Go, as shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Our resulting output gives us the difference in sales for both restaurants
    between May and June, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/10425e6d-5f23-4933-a4e6-74d78620f88f.png)'
  prefs: []
  type: TYPE_IMG
- en: The result in the preceding screenshot is shown as an *N × M* matrix, depicting
    the sales differences.
  prefs: []
  type: TYPE_NORMAL
- en: As we gain more restaurants and add more items to our restaurant menu, utilizing
    matrix subtraction will help us to keep a note of which items we need to keep
    in stock.
  prefs: []
  type: TYPE_NORMAL
- en: Scalar multiplication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While manipulating matrices, we may want to multiply all of the values within
    a matrix by a scalar value.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can represent this in Go with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This code produces the following results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c155d917-5fbb-42d8-b001-5a2b9f4a6270.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, we can see that each element in our matrix has been scaled by 4, thus
    providing an executed example of matrix scaling.
  prefs: []
  type: TYPE_NORMAL
- en: Scalar multiplication practical example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s say we own a hardware store and we have a catalog of products that have
    a **United States Dollar** (**USD**) value associated with them. Our company has
    decided to start selling our products in Canada, as well as the US. At the time
    of writing this book, $1 USD is equivalent to $1.34 **Canadian Dollars** (**CAD**).
    We can look at our matrix of prices for screws, nuts, and bolts based on volume
    count, as shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | **Individual USD** | **100ct USD** | **1000ct USD** |'
  prefs: []
  type: TYPE_TB
- en: '| Screws | $0.10 | $0.05 | $0.03 |'
  prefs: []
  type: TYPE_TB
- en: '| Nuts | $0.06 | $0.04 | $0.02 |'
  prefs: []
  type: TYPE_TB
- en: '| Bolts | $0.03 | $0.02 | $0.01 |'
  prefs: []
  type: TYPE_TB
- en: 'If we use matrix scalar multiplication to find the resulting cost in CAD, we''ll
    end up with the following matrix computation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7cb9da0e-246b-40c8-98c0-4e74ab792012.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can validate this with our Go scalar multiplication functionality, as shown
    in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We receive a resulting matrix that contains the values for each of our items
    in CAD:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ccdb70b9-3875-4224-b005-cab7c4b6a435.png)'
  prefs: []
  type: TYPE_IMG
- en: The output shows us the scaled resulting matrix.
  prefs: []
  type: TYPE_NORMAL
- en: As we get more and more products and have more different currencies that we'd
    like to account for, our scalar matrix manipulation will come in very handy as
    it will reduce the amount of work we have to do to manipulate these large sets
    of data.
  prefs: []
  type: TYPE_NORMAL
- en: Matrix multiplication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We may also want to multiply two matrices together. Multiplying two matrices
    together gives you a product of the two matrices. This can be very helpful when
    we want to multiply many numbers together at once in a concurrent fashion. We
    can take matrix *A*, an *N × M* matrix, alongside *B*, an *M × P* matrix. The
    resulting set is called *AB*, which is an *N × P* matrix, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e82ea761-1246-45b0-938f-effceac4c7eb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can represent this in Go with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'After execution, we receive the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/47d0d3dc-cea7-458b-a975-fc1ca5e3bbdc.png)'
  prefs: []
  type: TYPE_IMG
- en: This is how we can multiply matrices together using the `gonum/mat` package.
    Matrix multiplication is a common matrix function, and understanding how to perform
    this action will help you manipulate matrices effectively.
  prefs: []
  type: TYPE_NORMAL
- en: Matrix multiplication practical example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s talk about a practical example of matrix multiplication so that we can
    tie our theoretical work into a workable example. Two separate electronic vendors
    are vying for your business to make widgets for your company. Vendor A and vendor
    B both design offerings for the widget and give you a parts list for what they''ll
    need. Both vendor A and vendor B use the same component supplier. In this example,
    we can use matrix multiplication to find out which vendor creates a less expensive
    widget. The parts list that each vendor gave you is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Vendor A**:Resistors: 5'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Transistors: 10'
  prefs: []
  type: TYPE_NORMAL
- en: 'Capacitors: 2'
  prefs: []
  type: TYPE_NORMAL
- en: '**Vendor B**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Resistors: 8'
  prefs: []
  type: TYPE_NORMAL
- en: 'Transistors: 6'
  prefs: []
  type: TYPE_NORMAL
- en: 'Capacitors: 3'
  prefs: []
  type: TYPE_NORMAL
- en: 'You know from the component''s supplier catalog that the pricing for each of
    these components is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Resistors cost: $0.10'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Transistors cost: $0.42'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Capacitors cost: $0.37'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can represent each of these inputs with matrices, as we learned previously.
    This is done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We create a matrix composed of the cost of the components, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/54558420-1ed7-4e3d-ac0f-06e756954ced.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We create a matrix composed of the number of components from each vendor:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3bb4f614-13ca-4049-bbeb-12821e878eb2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, we use matrix multiplication to find some neat results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6a727ef6-8d10-449b-ae9c-030ba4aeb3f6.png)'
  prefs: []
  type: TYPE_IMG
- en: This result tells us that vendor A's solution costs $5.44 for parts, whereas
    vendor B's solution costs $4.43 for parts. Vendor B's solution is less expensive
    from a raw materials perspective.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be calculated in Go with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting output confirms the calculations we did in the preceding program:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ebec003c-cb2b-4b1f-96d8-a1e8545ebefa.png)'
  prefs: []
  type: TYPE_IMG
- en: As we see from our result, our formatted matrix lines up with the math that
    we performed earlier. Having a practical example can be very helpful in solidifying
    our understanding of theoretical concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Matrix transposition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Transposing a matrix flips a matrix diagonally, swapping rows and column indices.
    The following image shows an example transposition of a matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1475bd2c-8592-40f8-bc57-e676face4d1c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can represent a matrix transposition in Go using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of this matrix transposition can be seen in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2fa63e4c-f0e4-49ff-9bac-afcb485a38e7.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding output, we can see the regular matrix and the transposed version.
    Matrix transposition is often used in computer science to do things such as improve
    memory locality by transposing a matrix while still in memory.
  prefs: []
  type: TYPE_NORMAL
- en: Matrix transposition practical example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Transposing matrices is fun, but it may be helpful for you to have a practical
    example of when matrix transposition might be used. Let''s say that we have three
    engineers: **Bob**, **Tom**, and **Alice**. These three engineers push Git commits
    daily. We want to keep track of these Git commits in a meaningful way so that
    we can make sure the engineers have all the resources they need to continue writing
    code. Let''s take a count of our engineers'' code commits for 3 days:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **User** | **Day** | **Commits** |'
  prefs: []
  type: TYPE_TB
- en: '| Bob | 1 | 5 |'
  prefs: []
  type: TYPE_TB
- en: '| Bob | 2 | 3 |'
  prefs: []
  type: TYPE_TB
- en: '| Bob | 3 | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| Tom | 1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| Tom | 2 | 6 |'
  prefs: []
  type: TYPE_TB
- en: '| Tom | 3 | 4 |'
  prefs: []
  type: TYPE_TB
- en: '| Alice | 1 | 8 |'
  prefs: []
  type: TYPE_TB
- en: '| Alice | 2 | 7 |'
  prefs: []
  type: TYPE_TB
- en: '| Alice | 3 | 2 |'
  prefs: []
  type: TYPE_TB
- en: 'After we have our data points, we can represent them in a 2D array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/76486750-5d15-428b-a297-aaccfe1dffce.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that we have this array, we can take the transposition of the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a3acc159-f37d-42de-869e-ac94f779af6d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that we''ve performed this transposition, we can see that the rows of the
    transposed array correspond to the day of commits rather than the individual end
    users'' commits. Let''s look at the first row:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f3574069-e3d2-42ad-bb87-f5e164f9cd82.png)'
  prefs: []
  type: TYPE_IMG
- en: This now represents **BD1**, **TD1**, and **AD1** – the day 1 commits for each
    of the developers.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we are done with the operations part, it's high time we had a look
    at matrix structures.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding matrix structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Matrices are usually classified into two different structures: dense matrices
    and sparse matrices. A dense matrix is composed of mostly non-zero elements. A
    sparse matrix is a matrix that is mostly composed of elements with a 0 value.
    The sparsity of a matrix is calculated as the number of elements with a zero value
    divided by the total count of elements.'
  prefs: []
  type: TYPE_NORMAL
- en: If the result of this equation is greater than 0.5, the matrix is sparse. This
    distinction is important as it helps us to determine the best method for matrix
    manipulation. If a matrix is sparse, we may be able to use some optimizations
    to make the matrix manipulation more efficient. Inversely, if we have a dense
    matrix, we know that we will most likely be performing actions on the whole matrix.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to remember that operations on matrices are most likely going
    to be memory bound with today's computer hardware. The size of the matrix is an
    important thing to remember. When you're calculating when to use a sparse matrix
    or a dense matrix, a dense matrix will have the value of one int64, which, according
    to the size and alignment for numeric types in Go, is 8 bytes. A sparse matrix
    will have that value, plus an int for the column index of the entry. Keep these
    sizes in mind as you're choosing which data structure to use for your data.
  prefs: []
  type: TYPE_NORMAL
- en: Dense matrices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you create a dense matrix, all of the values of the matrix are stored.
    There are times when this is unavoidable – when we care about all of the values
    associated with a table and the table is mostly full. Using 2D slices or arrays
    for dense matrix storage can often be the best choice, but if you'd like to manipulate
    matrices, using the Gonum package can offer data manipulation in an effective
    manner. In practice, most matrices do not fall into the dense matrix category.
  prefs: []
  type: TYPE_NORMAL
- en: Sparse matrices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sparse matrices come up frequently in real-world datasets. Whether or not someone
    has viewed a video in a movie catalog, listened to the number of songs on a playlist,
    or completed an item in their to-do list are all good examples of times it's possible
    to use a sparse matrix. Many of the values within these tables are zero, so it
    doesn't make sense to store these matrices as dense matrices. This would take
    up a lot of room in memory and would be expensive to manipulate.
  prefs: []
  type: TYPE_NORMAL
- en: We can use the Go sparse library in order to create and manipulate sparse matrices.
    The Sparse library uses idioms from BLAS routines in order to perform a lot of
    common matrix manipulation. The Go Sparse library is fully compatible with the
    Gonum matrix package, so it can be used interchangeably with this package. In
    this example, we're going to create a new sparse **Dictionary of Keys** (**DOK**).
    After we create this, we'll set particular *M x N* values for sets in the array.
    Lastly, we will use the `gonum/mat` package in order to print the sparse matrix
    that we have created.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code, we''re creating a sparse matrix using the Sparse package.
    The `ToCSR()` and `ToCSC()` matrix functions create CSR and CSC matrices, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'After we execute this code, we can see that the sparse matrix has been returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/70599b5b-53e2-4949-80bf-92cba0e216a2.png)'
  prefs: []
  type: TYPE_IMG
- en: This output shows us the resulting sparse matrix.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sparse matrices can be grouped into three separate formats:'
  prefs: []
  type: TYPE_NORMAL
- en: Formats that are utilized for the efficient creation and modification of a matrix
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Formats that are utilized for efficient access and matrix operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specialized formats
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The formats that are utilized for the efficient creation and modification of
    a matrix are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Dictionary of Keys** (**DOK**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**List of** **Lists** (**LIL**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Coordinate Lists** (**COO**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These formats will be defined in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: DOK matrix
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A DOK matrix is a map in Go. This map links row and column pairs to their associated
    value. If no value has been defined for a particular coordinate in the matrix,
    it is assumed to be zero. Usually, a hashmap is used as the underlying data structure,
    which affords O(1) for random access, but iterating over elements ends up being
    a little bit slower. A DOK is useful for matrix construction or updating, but
    it is a non-performant choice for arithmetic operations. A DOK matrix can also
    be simply converted into a COO matrix once it's been created.
  prefs: []
  type: TYPE_NORMAL
- en: LIL matrix
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An LIL matrix stores a list per row that contains the column index and the value,
    usually sorted by column, as this decreases lookup time. LIL matrices are useful
    for incrementally composing sparse matrices. They are also useful when we don't
    know the sparsity pattern for our incoming dataset.
  prefs: []
  type: TYPE_NORMAL
- en: COO matrix
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A COO matrix (also frequently referred to as a triplet format matrix) stores
    lists of tuples containing rows, columns, and values, sorted by row and column
    index. A COO matrix is simple to append to with an O(1) timing. Random reads from
    a COO matrix are relatively slow (O(n)). COO matrices are a good choice for matrix
    initialization and conversion into CSR. COO matrices are a poor choice for arithmetic
    operations. We can improve the performance of a sequential iteration on a COO
    matrix by sorting the vectors within the matrix.
  prefs: []
  type: TYPE_NORMAL
- en: 'The formats that are utilized for efficient access and matrix operations are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Compressed Sparse Row** (**CSR**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Compressed Sparse Column** (**CSC**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These formats will be defined in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: CSR matrix
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'CSR matrices use three one-dimensional arrays to represent a matrix. The CSR
    format uses these three arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A: Values present within the array.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'IA: The index in which each of these values is present. These are defined as
    follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The value of IA at the 0 index, IA[0] = 0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The value of IA at the i index, IA[i] = IA[i − 1] + (number of non-zero elements
    on the i-1^(th) row in the original matrix)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'JA: Stores the column indices of the elements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following image shows an example of a 4 x 4 matrix. This is the matrix
    that we are going to use in our following code sample:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5ab5424b-13fd-4162-aaa5-5e4e016ed4a2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can calculate these values as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A = [ 1 2 3 4]
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IA = [0 1 2 3 4]
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JA = [2 0 3 1]
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can validate this using the `sparse` package, as shown in the following code
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The result shows us the reconverted values of the DOK representation of the
    matrix that we created, as well as its corresponding CSR matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f59aabb2-8043-4d8b-a7fb-fab0ddef139a.png)'
  prefs: []
  type: TYPE_IMG
- en: The output from this code shows us a CSR matrix that prints the IA, JA, and
    A values, respectively. As the matrix grows, being able to calculate a CSR matrix
    makes matrix manipulation more and more efficient. Computer science often manipulates
    matrices with millions of rows and columns, so being able to do so in an efficient
    manner makes your code much more performant.
  prefs: []
  type: TYPE_NORMAL
- en: CSC matrix
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A CSC matrix has an identical format to CSR matrices, but with one small difference.
    The column index slice is the element that is compressed, rather than the row
    index slice, as we saw within the CSR matrix. This means CSC matrices store their
    values in column-major order, instead of row-major order. This can also be viewed
    as a natural transposition of a CSR matrix. We can manipulate the example that
    we used in the previous section to look at how a CSC matrix is created, as shown
    in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The result shows us the reconverted values of the DOK representation of the
    matrix that we created, as well as its corresponding CSC matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6ac314fa-998d-4d1a-80e1-5e86d0161180.png)'
  prefs: []
  type: TYPE_IMG
- en: The output from the preceding code block shows us the DOK matrix as well as
    the CSC matrix. Knowing how to represent CSR and CSC matrices is vital in the
    process of matrix manipulation. These two different types of matrices have different
    distinguishing characteristics. For example, DOK matrices have an O(1) access
    pattern, while CSC matrices use column-oriented operations for efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed matrices and vectors, alongside how these two
    data structures are used practically to perform much of the data manipulation
    that happens in computer science today. Also, we learned about BLAS, vectors,
    matrices, and vector/matrix manipulation. Vectors and matrices are building blocks
    that are commonly used for linear algebra, and we saw hard examples of where this
    can take place.
  prefs: []
  type: TYPE_NORMAL
- en: The examples we have discussed in this chapter will help us a lot in situations
    pertinent to real-world data manipulation. In [Chapter 6](3ce4cee8-eaaa-4a6d-b817-4fdd3899f973.xhtml),
    *Composing Readable Go Code*, we are going to talk about composing readable Go
    code. Being able to write readable Go code will help keep topics and ideas clear
    and succinct for easy collaboration across code contributors.
  prefs: []
  type: TYPE_NORMAL
