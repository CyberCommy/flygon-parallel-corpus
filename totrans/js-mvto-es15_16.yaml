- en: Chapter 4. Structural Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we looked at a number of ways to create objects in
    order to optimize for reuse. In this chapter, we'll take a look at structural
    patterns; these are patterns that are concerned with easing the design by describing
    simple ways in which objects can interact.
  prefs: []
  type: TYPE_NORMAL
- en: Again, we will limit ourselves to the patterns described in the GoF book. There
    are a number of other interesting structural patterns that have been identified
    since the publication of the GoF and we'll look at those in part 2 of the book.
  prefs: []
  type: TYPE_NORMAL
- en: 'The patterns we''ll examine here are:'
  prefs: []
  type: TYPE_NORMAL
- en: Adapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bridge
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Composite
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decorator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Façade
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flyweight
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Proxy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once again, we'll discuss whether the patterns that were described years ago
    are still relevant for a different language and a different time.
  prefs: []
  type: TYPE_NORMAL
- en: Adapter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'From time to time there is a need to fit a round peg in a square hole. If you''ve
    ever played with a child''s shape sorting toy then you may have discovered that
    you can, in fact, put a round peg in a square hole. The hole is not completely
    filled and getting the peg in there can be difficult:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adapter](img/00045.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'To improve the fit of the peg an adapter can be used. This adapter fills the
    hole in completely resulting in a perfect fit:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adapter](img/00046.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In software a similar approach is often needed. We may need to make use of a
    class that does not perfectly fit the required interface. The class may be missing
    methods or may have additional methods we would like to hide. This occurs frequently
    when dealing with third party code. In order to make it comply with the interface
    needed in your code, an adapter may be required.
  prefs: []
  type: TYPE_NORMAL
- en: 'The class diagram for an adapter is very simple as can be seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adapter](img/00047.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The interface of the implementation does not look the way we would like it to
    for use in our code. Normally the solution to this is to simply refactor the implementation
    so it looks the way we would like it to. However, there are a number of possible
    reasons that cannot be done. Perhaps the implementation exists inside third party
    code to which we have no access. It is also possible that the implementation is
    used elsewhere in the application where the interface is exactly as we would like
    it to be.
  prefs: []
  type: TYPE_NORMAL
- en: The adapter class is a thin piece of code that implements the required interface.
    It typically wraps a private copy of the implementation class and proxy calls
    through to it. The adapter pattern is frequently used to change the abstraction
    level of the code. Let's take a look at a quick example.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the land of Westeros, much of the trade and travel is done by boat. It is
    not only more dangerous to travel by ship than to walk or travel by horse, but
    also riskier due to the constant presence of storms and pirates. These ships are
    not the sort which might be used by Royal Caribbean to cruise around the Caribbean;
    they are crude things which might look more at home captained by 15th century
    European explorers.
  prefs: []
  type: TYPE_NORMAL
- en: 'While I am aware that ships exist, I have very little knowledge of how they
    work or how I might go about navigating one. I imagine that many people are in
    the same (*cough!*) boat as me. If we look at the interface for a Ship in Westeros,
    it looks intimidating:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'I would really like a much simpler interface that abstracts away all the fiddly
    little details. Ideally something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This looks like something I could probably figure out even living in a city
    that is over 1000 kilometers from the nearest ocean. In short, what I'm looking
    for is a higher-level abstraction around the Ship. In order to transform a Ship
    into a SimpleShip we need an adapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The adapter will have the interface of SimpleShip but it will perform actions
    on a wrapped instance of Ship. The code might look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In reality these functions would be far more complex, but it should not matter
    much because we've got a nice simple interface to present to the world. The presented
    interface can also be set up so as to restrict access to certain methods on the
    underlying type. When building library code, adapters can be used to mask the
    internal method and only present the limited functions needed to the end user.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use this pattern, the code might look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: You would likely not want to use adapter in the name of your client class as
    it leaks some information about the underlying implementation. Clients should
    be unaware they are talking to an adapter.
  prefs: []
  type: TYPE_NORMAL
- en: The adapter itself can grow to be quite complex to adjust one interface to another.
    In order to avoid creating very complex adapters, care must be taken. It is certainly
    not inconceivable to build several adapters, one atop another. If you find an
    adapter becoming too large then it is a good idea to stop and examine if the adapter
    is following the single responsibility principle. That is to say, ensure that
    each class has only one thing for which it has some responsibility. A class that
    looks up users from a database should not also contain functionality for sending
    e-mails to these users. That is too much responsibility. Complex adapters can
    be replaced with a composite object, which will be explored later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: From the testing perspective, adapters can be used to totally wrap third party
    dependencies. In this scenario they provide a place into which to hook tests.
    Unit tests should avoid testing libraries but they can certainly test the adapters
    to ensure that they are proxying through the correct calls.
  prefs: []
  type: TYPE_NORMAL
- en: The adapter is a very powerful pattern for simplifying code interfaces. Massaging
    interfaces to better match a requirement is useful in countless places. The pattern
    is certainly useful in JavaScript. Applications written in JavaScript tend to
    make use of a large number of small libraries. By wrapping up these libraries
    in adapters I'm able to limit the number of places I interact with the libraries
    directly; this means that the libraries can easily be replaced.
  prefs: []
  type: TYPE_NORMAL
- en: The adapter pattern can be slightly modified to provide consistent interfaces
    over a number of different implementations. This is usually known as the bridge
    pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Bridge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The bridge pattern takes the adapter pattern to a new level. Given an interface,
    we can build multiple adapters, each one of which acts as an intermediary to a
    different implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'An excellent example that I''ve run across, is dealing with two different services
    that provide more or less the same functionality and are used in a failover configuration.
    Neither service provides exactly the interface required by the application and
    both services provide different APIs. In order to simplify the code, adapters
    are written to provide a consistent interface. The adapters implement a consistent
    interface and provide fills so that each API can be called consistently. To expand
    on the shape sorter metaphor a bit more, we can imagine that we have a variety
    of different pegs we would like to use to fill the square hole. Each adapter fills
    in the missing bits and helps us get a good fit:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Bridge](img/00048.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The bridge is a very useful pattern. Let''s take a look at how to implement
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Bridge](img/00049.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The adapters shown in the preceding diagram sit between the implementation and
    the desired interface. They modify the implementation to fit in with the desired
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We've already discussed that in the land of Westeros the people practice a number
    of disparate religions. Each one has a different way of praying and making offerings.
    There is a lot of complexity around making the correct prayers at the correct
    time and we would like to avoid exposing this complexity. Instead we'll write
    a series of adapters that can simplify prayers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we need is a number of different gods to which we can pray:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'These classes should look familiar as they are basically the same classes found
    in the previous chapter where they were used as examples for the factory method.
    You may notice, however, that the signature for the `prayTo` method for each religion
    is slightly different. This proves to be something of an issue when building a
    consistent interface like the one shown in pseudo code here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'So let''s slot in a few adapters to act as a bridge between the classes we
    have and the signature we would like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Each one of these adapters implements the `God` interface we wanted and abstracts
    away the complexity of dealing with three different interfaces, one for each god:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the Bridge pattern, we could write code like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This code uses the bridges to provide a consistent interface to the gods such
    that they can all be treated as equals.
  prefs: []
  type: TYPE_NORMAL
- en: In this case we are simply wrapping the individual gods and proxying method
    calls through to them. The adapters could each wrap a number of objects and this
    is another useful place in which to use the adapter. If a complex series of objects
    needs to be orchestrated, then an adapter can take some responsibility for that
    orchestration providing a simpler interface to other classes.
  prefs: []
  type: TYPE_NORMAL
- en: You can imagine how useful the bridge pattern is. It can be used well in conjunction
    with the factory method pattern presented in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: This pattern certainly remains a very useful one for use in JavaScript. As I
    mentioned at the start of this section, it is handy for dealing with different
    APIs in a consistent fashion. I have used it for swapping in different third party
    components such as different graphing libraries or phone system integration points.
    If you're building applications on a mobile platform using JavaScript, then the
    bridge pattern is going to be a great friend for you, allowing you to separate
    your common and platform specific code cleanly. Because there are no interfaces
    in JavaScript, the bridge pattern is far closer to the adapter in JavaScript than
    in other languages. In fact, it is basically exactly the same.
  prefs: []
  type: TYPE_NORMAL
- en: A bridge also makes testing easier. We are able to implement a fake bridge and
    use this to ensure that the calls into the bridge are correct.
  prefs: []
  type: TYPE_NORMAL
- en: Composite
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter I mentioned that we would like to avoid coupling our
    objects together tightly. Inheritance is a very strong form of coupling and I
    suggested that, instead, composites should be used. The composite pattern is a
    special case of this in which the composite is treated as interchangeable with
    the components. Let's explore how the composite pattern works.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following class diagram contains two different ways to build a composite
    component:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Composite](img/00050.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In the first one, the composite component is built from a fixed number of a
    variety of components. The second component is constructed from a collection of
    indeterminate length. In both cases the components contained within the parent
    composition could be of the same type as the composition. So a composition may
    contain instances of its own type.
  prefs: []
  type: TYPE_NORMAL
- en: The key feature of the composite pattern is the interchangeability of a component
    with its children. So, if we have a composite which implements `IComponent`, then
    all of the components of the composite will also implement `IComponent`. This
    is, perhaps, best illustrated with an example.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Tree structures are very useful in computing. It turns out that a hierarchical
    tree can represent many things. A tree is made up of a series of nodes and edges
    and is a cyclical. In a binary tree, each node contains a left and right child
    until we get down to the terminal nodes known as leaves.
  prefs: []
  type: TYPE_NORMAL
- en: 'While life is difficult in Westeros there is an opportunity for taking joy
    in things like religious holidays or weddings. At these events there is typically
    a great deal of feasting on delicious foods. The recipes for these foods is much
    as you would find in your own set of recipes. A simple dish like baked apples
    contains a list of ingredients:'
  prefs: []
  type: TYPE_NORMAL
- en: Baking apple
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Honey
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Butter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nuts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each one of these ingredients implements an interface which we'll refer to as
    `IIngredient`. More complex recipes contain more ingredients, but in addition
    to that, more complex recipes may contain complex ingredients that are themselves
    made from other ingredients.
  prefs: []
  type: TYPE_NORMAL
- en: 'A popular dish in a southern part of Westeros is a dessert which is not at
    all unlike what we would call tiramisu. It is a complex recipe with ingredients
    such as:'
  prefs: []
  type: TYPE_NORMAL
- en: Custard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cake
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whipped cream
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coffee
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Of course custard itself is made from:'
  prefs: []
  type: TYPE_NORMAL
- en: Milk
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sugar
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Eggs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vanilla
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custard is a composite as is coffee and cake.
  prefs: []
  type: TYPE_NORMAL
- en: Operations on the composite object are typically proxied through to all of the
    contained objects.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A simple ingredient, one which would be a leaf node, is shown in this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'It can be used interchangeably with a compound ingredient which has a list
    of ingredients:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The composite ingredient loops over its internal ingredients and performs the
    same operation on each of them. There is, of course, no need to define an interface
    due to the prototype model.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make use of this compound ingredient we might do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course this only shows part of the power of the pattern. We could use rice
    pudding as an ingredient in an even more complicated recipe: rice pudding stuffed
    buns (they have some strange foods in Westeros). As both the simple and compound
    version of the ingredient have the same interface, the caller does not need to
    know that there is any difference between the two ingredient types.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Composite is a heavily used pattern in JavaScript code that deals with HTML
    elements, as they are a tree structure. For example, the jQuery library provides
    a common interface if you have selected a single element or a collection of elements.
    When a function is called it is actually called on all the children, for instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This will hide all the links on a page regardless of how many elements are actually
    found by calling `$("a")`. The composite is a very useful pattern for JavaScript
    development.
  prefs: []
  type: TYPE_NORMAL
- en: Decorator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The decorator pattern is used to wrap and augment an existing class. Using a
    decorator pattern is an alternative to subclassing an existing component. Subclassing
    is typically a compile time operation and is a tight coupling. This means that
    once subclassing is performed, there is no way to alter it at runtime. In cases
    where there are many possible subclassings that can act in combination, the number
    of combinations of subclassings explodes. Let's look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'The armor worn by knights in Westeros can be quite configurable. Armor can
    be fabricated in a number of different styles: scale, lamellar, chainmail, and
    so on. In addition to the style of armor, there is also a variety of different
    face guards, knee, and elbow joints, and, of course, colors. The behavior of armor
    made from lamellar and a grille is different from chainmail with a face visor.
    You can see, however, that there is a large number of possible combinations; far
    too many combinations to explicitly code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'What we do instead is implement the different styles of armor using the decorator
    pattern. A decorator works using a similar theory to the adapter and bridge patterns,
    in that it wraps another instance and proxy calls through. The decorator pattern,
    however, performs the redirections at runtime by having the instance to wrap passed
    into it. Typically, a decorator will act as a simple pass through for some methods
    and for others it will make some modifications. These modifications could be limited
    to performing an additional action before passing the call off to the wrapped
    instance or could go so far as to change the parameters passed in. A UML representation
    of the decorator pattern looks like the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Decorator](img/00051.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This allows for very granular control over which methods are altered by the
    decorator and which remain as mere pass-through. Let's take a look at an implementation
    of the pattern in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this code we have a base class, `BasicArmor`, and it is then decorated by
    the `ChainMail` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ChainMail` armor takes in an instance of armor that complies with an interface,
    such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: That instance is wrapped and calls proxied through. The method `GetArmorIntegiry`
    modifies the result from the underlying class while `CalculateDamageFromHit` modifies
    the arguments that are passed into the decorated class. This `ChainMail` class
    could, itself, be decorated with several more layers of decorators until a long
    chain of methods is actually called for each method call. This behavior, of course,
    remains invisible to outside callers.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make use of this armor decorator, look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: It is tempting to make use of JavaScript's ability to rewrite individual methods
    on classes to implement this pattern. Indeed, in an earlier draft of this section
    I had intended to suggest just that. However, doing so is syntactically messy
    and not a common way of doing things. One of the most important things to keep
    in mind when programming is that code must be maintainable, not only by you but
    also by others. Complexity breeds confusion and confusion breeds bugs.
  prefs: []
  type: TYPE_NORMAL
- en: The decorator pattern is a valuable pattern for scenarios where inheritance
    is too limiting. These scenarios still exist in JavaScript, so the pattern remains
    useful.
  prefs: []
  type: TYPE_NORMAL
- en: Façade
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The façade pattern is a special case of the Adapter pattern that provides a
    simplified interface over a collection of classes. I mentioned such a scenario
    in the section on the adapter pattern but only within the context of a single
    class, `SimpleShip`. This same idea can be expanded to provide an abstraction
    around a group of classes or an entire subsystem. The façade pattern in UML form
    looks like the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Façade](img/00052.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If we take the same `SimpleShip` as before and expand it to an entire fleet,
    we have a great example of a use for creating a façade. If it was difficult to
    sail a single ship it would be far more difficult to command an entire fleet of
    ships. There is a great deal of nuance required, commands to individual ships
    would have to be made. In addition to the individual ships there must also be
    a fleet Admiral and a degree of coordination between the ships in order to distribute
    supplies. All of this can be abstracted away. If we have a collection of classes
    representing the aspects of a fleet such as these:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we might build a façade as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Façades are very useful abstractions, especially in dealing with APIs. Using
    a façade around a granular API can create an easier interface. The level of abstraction
    at which the API works can be raised so that it is more in sync with how your
    application works. For instance, if you''re interacting with the Azure blob storage
    API you could raise the level of abstraction from working with individual files
    to working with collections of files. Instead of writing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'A façade could be written which encapsulates all of these calls and provides
    an interface, like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: As you can see façades remain useful in JavaScript and should be a pattern that
    remains in your toolbox.
  prefs: []
  type: TYPE_NORMAL
- en: Flyweight
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In boxing there is a light weight division between 49-52 kg known as the flyweight
    division. It was one of the last divisions to be established and was named, I
    imagine, for the fact that the fighters in it were tiny, like flies.
  prefs: []
  type: TYPE_NORMAL
- en: The flyweight pattern is used in instances when there are a large number of
    instances of objects which vary only slightly. I should perhaps pause here to
    mention that a large number, in this situation, is probably in the order of 10,000
    objects rather than 50 objects. However, the cutoff for the number of instances
    is highly dependent on how expensive the object is to create.
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, the object may be so expensive that only a handful are required
    before they overload the system. In this case introducing flyweight at a smaller
    number would be beneficial. Maintaining a full object for each object consumes
    a lot of memory. It seems that the memory is largely consumed wastefully too,
    as most of the instances have the same value for their fields. Flyweight offers
    a way to compress this data by only keeping track of the values that differ from
    some prototype in each instance.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript's prototype model is ideal for this scenario. We can simply assign
    the most common value to the prototype and have individual instances override
    them as needed. Let's see how that looks with an example.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Returning once more to Westeros (aren''t you glad I''ve opted for a single
    overarching problem domain?) we find that armies are full of ill-equipped fighting
    people. Within this set of people there is really very little difference from
    the perspective of the generals. Certainly each person has their own life, ambitions,
    and dreams but they have all been adapted into simple fighting automatons in the
    eyes of the general. The general is only concerned with how well the soldiers
    fight, if they''re healthy, and if they''re well fed. We can see the simple set
    of fields in this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, with an army of 10,000 soldiers, keeping track of all of this requires
    quite some memory. Let''s take a different approach and use a class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Using this approach, we are able to defer all requests for the soldier''s health
    to the prototype. Setting the value is easy too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: You'll note that we make a call to delete to remove the property override and
    return the value back to the parent value.
  prefs: []
  type: TYPE_NORMAL
- en: Proxy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The final pattern presented in this chapter is the proxy. In the previous section
    I mentioned how it is expensive to create objects and how we would like to avoid
    creating too many of them. The proxy pattern provides a method of controlling
    the creation and use of expensive objects. The UML of the proxy pattern looks
    like the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Proxy](img/00053.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, the proxy mirrors the interface of the actual instance. It
    is substituted in for the instance in all the clients and, typically, wraps a
    private instance of the class. There are a number of places where the proxy pattern
    can be of use:'
  prefs: []
  type: TYPE_NORMAL
- en: Lazy instantiation of an expensive object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Protection of secret data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stubbing for remote method invocation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interposing additional actions before or after method invocation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Often an object is expensive to instantiate and we don't want to have instances
    created before they're actually used. In this case the proxy can check its internal
    instance and, if not yet initiated, create it before passing on the method call.
    This is known as lazy instantiation.
  prefs: []
  type: TYPE_NORMAL
- en: If a class has been designed without any security in mind but now requires some,
    this can be provided through the use of a proxy. The proxy will check the call
    and only pass on the method call in cases where the security checks out.
  prefs: []
  type: TYPE_NORMAL
- en: The proxy may be used to simply provide an interface to methods that are invoked
    somewhere else. In fact, this is exactly how a number of web socket libraries
    function, proxying calls back to the web server.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, there may be cases where it is useful to interpose some functionality
    into the method invocation. This could be logging of parameters, validating of
    parameters, altering results, or any number of things.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's take a look at a Westeros example where method interposition is needed.
    As tends to happen, the units of measurement for liquids vary greatly from one
    side of the land to the other. In the north, one might buy a pint of beer, while
    in the south, one would buy it by the dragon. This causes no end of confusion
    and code duplication, but can be solved by wrapping classes that care about measurement
    in proxies.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, this code is for a barrel calculator which estimates the number
    of barrels needed to ship a quantity of liquid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Although it is not well documented, here this version takes pints as a volume
    parameter. A proxy is created which deals with the transformation thusly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Equally we might create another proxy for a pint-based barrel calculator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This proxy class does the unit conversion for us and helps alleviate some confusion
    around units. Some languages, such as F#, support the concept of units of measure.
    In effect it is a typing system which is overlaid over simple data types such
    as integers, preventing programmers from making mistakes such as adding a number
    representing pints to one representing liters. Out of the box in JavaScript there
    is no such capability. Using a library such as JS-Quantities ([http://gentooboontoo.github.io/js-quantities/](http://gentooboontoo.github.io/js-quantities/))
    is an option however. If you look at it, you'll see the syntax is quite painful.
    This is because JavaScript doesn't permit operator overloading. Having seen how
    weird adding things such as an empty array to an empty array are (it results in
    an empty string), I think perhaps we can be thankful that operator overloading
    isn't supported.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we wanted to protect against accidentally using the wrong sort of calculator
    when we have pints and think we have dragons, then we could stop with our primitive
    obsession and use a type for the quantity, a sort of poor person''s units of measure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This can then be used as a guard in the proxy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we end up with pretty much what JS-Quantities does but in a
    more ES6 form.
  prefs: []
  type: TYPE_NORMAL
- en: The proxy is absolutely a useful pattern within JavaScript. I already mentioned
    that it is used by web socket libraries when generating stubs but it finds itself
    useful in countless other locations.
  prefs: []
  type: TYPE_NORMAL
- en: Hints and tips
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many of the patterns presented in this chapter provide methods of abstracting
    functionality and of molding interfaces to look the way you want. Keep in mind
    that with each layer of abstraction a cost is introduced. Function calls take
    longer but it is also much more confusing for people who need to understand your
    code. Tooling can help a little but tracking a function call through nine layers
    of abstraction is never fun.
  prefs: []
  type: TYPE_NORMAL
- en: Also be wary of doing too much in the façade pattern. It is very easy to turn
    the façade into a fully-fledged management class and that degrades easily into
    a God object that is responsible for coordinating and doing everything.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we've looked at a number of patterns used to structure the interaction
    between objects. Some of them are quite similar to each other but they are all
    useful in JavaScript, although the bridge is effectively reduced to an adapter.
    In the next chapter we'll finish our examination of the original GoF patterns
    by looking at behavioral patterns.
  prefs: []
  type: TYPE_NORMAL
