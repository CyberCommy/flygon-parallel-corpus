- en: Chapter 6. Sessions and Cookies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our application is beginning to get a little more real now; in the previous
    chapter, we added some APIs and client-side interfaces to them.
  prefs: []
  type: TYPE_NORMAL
- en: In our application's current state, we've added `/api/comments`, `/api/comments/[id]`,
    `/api/pages`, and `/api/pages/[id]`, thus making it possible for us to get and
    update our data in JSON format and making the application better suited for Ajax
    and client-side access.
  prefs: []
  type: TYPE_NORMAL
- en: Though we can now add comments and edit them directly through our API, there
    is absolutely no restriction on who can perform these actions. In this chapter,
    we'll look at the ways to limit access to certain assets, establishing identities,
    and securely authenticating when we have them.
  prefs: []
  type: TYPE_NORMAL
- en: By the end, we should be able to enable users to register and log in and utilize
    sessions, cookies, and flash messages to keep user state in our application in
    a secure way.
  prefs: []
  type: TYPE_NORMAL
- en: Setting cookies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most common, fundamental, and simplest way to create persistent memory across
    a user's session is by utilizing cookies.
  prefs: []
  type: TYPE_NORMAL
- en: Cookies provide a way to share state information across requests, URL endpoints,
    and even domains, and they have been used (and abused) in every possible way.
  prefs: []
  type: TYPE_NORMAL
- en: Most often, they're used to keep a track of identity. When a user logs into
    a service, successive requests can access some aspects of the previous request
    (without duplicating a lookup or the login module) by utilizing the session information
    stored in a cookie.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you''re familiar with cookies in any other language''s implementation, the
    basic `struct` will look familiar. Even so, the following relevant attributes
    are fairly lockstep with the way a cookie is presented to the client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: That's a lot of attributes for a very basic `struct`, so let's focus on the
    important ones.
  prefs: []
  type: TYPE_NORMAL
- en: The `Name` attribute is simply a key for the cookie. The `Value` attribute represents
    its contents and `Expires` is a `Time` value for the moment when the cookie should
    be flushed by a browser or another headless recipient. This is all you need in
    order to set a valid cookie that lasts in Go.
  prefs: []
  type: TYPE_NORMAL
- en: Beyond the basics, you may find setting a `Path`, `Domain`, and `HttpOnly` useful,
    if you want to lock down the accessibility of the cookie.
  prefs: []
  type: TYPE_NORMAL
- en: Capturing user information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When a user with a valid session and`/`or cookie attempts to access restricted
    data, we need to get that from the user's browser.
  prefs: []
  type: TYPE_NORMAL
- en: A session itself is just that—a single session on the site. It doesn't naturally
    persist indefinitely, so we need to leave a breadcrumb, but we also want to leave
    one that's relatively secure.
  prefs: []
  type: TYPE_NORMAL
- en: For example, we would never want to leave critical user information in the cookie,
    such as name, address, email, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: However, any time we have some identifying information, we leave some vector
    for misdeed—in this case we'll likely leave a session identifier that represents
    our session ID. The vector in this case allows someone, who obtains this cookie,
    to log in as one of our users and change information, find billing details, and
    so on.
  prefs: []
  type: TYPE_NORMAL
- en: These types of physical attack vectors are well outside the scope of this (and
    most) application and to a large degree, it's a concession that if someone loses
    access to their physical machine, they can also have their account compromised.
  prefs: []
  type: TYPE_NORMAL
- en: What we want to do here is ensure that we're not transmitting personal or sensitive
    information over clear text or without a secure connection. We'll cover setting
    up TLS in [Chapter 9](ch09.html "Chapter 9. Security"), *Security*, so here we
    want to focus on limiting the amount of information we store in our cookies.
  prefs: []
  type: TYPE_NORMAL
- en: Creating users
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous chapter, we allowed non-authorized requests to create new comments
    by hitting our REST API via a `POST`. Anyone who''s been on the Internet for a
    while knows a few truisms, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: The comments section is often the most toxic part of any blog or news post
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Step 1 is true, even when users have to authenticate in non-anonymous ways
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, let's lock down the comments section to ensure that users have registered
    themselves and are logged in.
  prefs: []
  type: TYPE_NORMAL
- en: We won't go deep into the authentication's security aspects now, as we'll be
    going deeper with that in [Chapter 9](ch09.html "Chapter 9. Security"), *Security*.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s add a `users` table in our database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We could surely go a lot deeper with user information, but this is enough to
    get us started. As mentioned, we won't go too deep into security, so we'll just
    generate a hash for the password now and not worry about the salt.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, to enable sessions and users in the app, we''ll make some changes
    to our structs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: And here are the two stub handlers for registration and logging in. Again, we're
    not putting our full effort into fleshing these out into something robust, we
    just want to open the door a bit.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling sessions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to storing the users themselves, we'll also want some way of persistent
    memory for accessing our cookie data. In other words, when a user's browser session
    ends and they come back, we'll validate and reconcile their cookie value against
    values in our database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use this SQL to create the `sessions` table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The most important values are the `user_id`, `session_id`, and the timestamps
    for updating and starting. We can use the latter two to decide if a session is
    actually valid after a certain period. This is a good security practice, just
    because a user has a valid cookie doesn't necessarily mean that they should remain
    authenticated, particularly if you're not using a secure connection.
  prefs: []
  type: TYPE_NORMAL
- en: Letting users register
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To be able to allow users to create accounts themselves, we'll need a form for
    both registering and logging in. Now, most systems similar to this do some multi-factor
    authentication to allow a user backup system for retrieval as well as validation
    that the user is real and unique. We'll get there, but for now let's keep it as
    simple as possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll set up the following endpoints to allow a user to `POST` both the register
    and login forms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Keep in mind that these are presently set to the HTTPS scheme. If you're not
    using that, remove that part of the `HandleFunc` register.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we''re only showing these following views to unauthenticated users, we
    can put them on our `blog.html` template and wrap them in `{{if .Session.Unauthenticated}}
    … {{end}}` template snippets. We defined `.Unauthenticated` and `.Authenticated`
    in the application under the `Session` `struct`, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'And our `/register` endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Note that this fails inelegantly for a number of reasons. If the passwords do
    not match, we don't check and report to the user. If the user already exists,
    we don't tell them the reason for a registration failure. We'll get to that, but
    now our main intent is producing a session.
  prefs: []
  type: TYPE_NORMAL
- en: 'For reference, here''s our `weakPasswordHash` function, which is only intended
    to generate a hash for testing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Letting users log in
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A user may be already registered; in which case, we''ll also want to provide
    a login mechanism on the same page. This can obviously be subject to better design
    considerations, but we just want to make them both available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: And then we'll need receiving endpoints for each POSTed form. We're not going
    to do a lot of validation here either, but we're not in a position to validate
    a session.
  prefs: []
  type: TYPE_NORMAL
- en: Initiating a server-side session
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most common ways of authenticating a user and saving their state
    on the Web is through sessions. You may recall that we mentioned in the last chapter
    that REST is stateless, the primary reason for that is because HTTP itself is
    stateless.
  prefs: []
  type: TYPE_NORMAL
- en: If you think about it, to establish a consistent state with HTTP, you need to
    include a cookie or a URL parameter or something that is not built into the protocol
    itself.
  prefs: []
  type: TYPE_NORMAL
- en: Sessions are created with unique identifiers that are usually not entirely random
    but unique enough to avoid conflicts for most logical and plausible scenarios.
    This is not absolute, of course, and there are plenty of (historical) examples
    of session token hijacking that are not related to sniffing.
  prefs: []
  type: TYPE_NORMAL
- en: Session support as a standalone process does not exist in Go core. Given that
    we have a storage system on the server side, this is somewhat irrelevant. If we
    create a safe process for generation of server keys, we can store them in secure
    cookies.
  prefs: []
  type: TYPE_NORMAL
- en: But generating session tokens is not completely trivial. We can do this using
    a set of available cryptographic methods, but with session hijacking as a very
    prevalent way of getting into systems without authorization, that may be a point
    of insecurity in our application.
  prefs: []
  type: TYPE_NORMAL
- en: Since we're already using the Gorilla toolkit, the good news is that we don't
    have to reinvent the wheel, there's a robust session system in place.
  prefs: []
  type: TYPE_NORMAL
- en: Not only do we have access to a server-side session, but we get a very convenient
    tool for one-time messages within a session. These work somewhat similar to a
    message queue in the manner that once data goes into them, the flash message is
    no longer valid when that data is retrieved.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a store
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To utilize the Gorilla sessions, we first need to invoke a cookie store, which
    will hold all the variables that we want to keep associated with a user. You can
    test this out pretty easily by the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The first time you hit your URL and endpoint, you''ll see **We just set the
    value!**, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a store](img/B04294_06_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the second request, you should see **(world)**, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a store](img/B04294_06_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'A couple of notes here. First, you must set cookies before sending anything
    else through your `io.Writer` (in this case the `ResponseWriter w`). If you flip
    these lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: You can see this in action. You'll never get the value set to your cookie store.
  prefs: []
  type: TYPE_NORMAL
- en: So now, let's apply it to our application. We will want to initiate a session
    store before any requests to `/login` or `/register`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll initialize a global `sessionStore`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Feel free to group these, as well, in a `var ()`. Next, we'll want to create
    four simple functions that will get an active session, update a current one, generate
    a session ID, and evaluate an existing cookie. These will allow us to check if
    a user is logged in by a cookie's session ID and enable persistent logins.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, the `getSessionUID` function, which will return a user''s ID if a session
    already exists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, the update function, which will be called with every front-facing request,
    thus enabling a timestamp update or inclusion of a user ID if a new log in is
    attempted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'An important part is the ability to generate a strongly-random byte array (cast
    to string) that will allow unique identifiers. We do that with the following `generateSessionId()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: And finally, we have the function that will be called with every request to
    check for a cookie's session or create one if it doesn't exist.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This is predicated on having a global `Session struct`, in this case defined
    as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This leaves us with just one piece—to call `validateSession()` on our `ServePage()`
    method and `LoginPost()` method and then validate the passwords on the latter
    and update our session on a successful login attempt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In our previously defined check against the form values, if a valid user is
    found, we''ll update the session directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Utilizing flash messages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned earlier in this chapter, Gorilla sessions offer a simple system
    to utilize a single-use and cookie-based data transfer between requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'The idea behind a flash message is not all that different than an in-browser/server
    message queue. It''s most frequently utilized in a process such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: A form is POSTed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The data is processed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A header redirect is initiated
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The resulting page needs some access to information about the `POST` process
    (success, error)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At the end of this process, the message should be removed so that the message
    is not duplicated erroneously at some other point. Gorilla makes this incredibly
    easy, and we'll look at that shortly, but it makes sense to show a quick example
    of how this can be accomplished in native Go.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, we''ll create a simple HTTP server that includes a starting point
    handler called `startHandler`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re not doing anything special here, just rendering our form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `middleHandler` demonstrates creating cookies through a `Cookie struct`,
    as described earlier in this chapter. There''s nothing important to note here
    except the fact that you may want to extend the expiration out a bit, just to
    ensure that there''s no way a cookie could expire (naturally) between requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The `finishHandler` function does the magic of a flash message—removes the
    cookie if and only if a value has been found. This ensures that the cookie is
    a one-time retrievable value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The following example is our HTML for POSTing our cookie value to the `/middle`
    handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: If you do as the page suggests and refresh again, the cookie value would have
    been removed and the page will not render, as you've previously seen.
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin the flash message, we hit our `/start` endpoint and enter an intended
    value and then click on the **Send Message** button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Utilizing flash messages](img/B04294_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At this point, we''ll be sent to the `/middle` endpoint, which will set the
    cookie value and HTTP redirect to `/finish`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Utilizing flash messages](img/B04294_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And now we can see our value. Since the `/finish` endpoint handler also unsets
    the cookie, we''ll be unable to retrieve that value again. Here''s what happens
    if we do what `/finish` tells us on its first appearance:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Utilizing flash messages](img/B04294_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: That's all for now.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Hopefully by this point you have a grasp of how to utilize basic cookies and
    sessions in Go, either through native Go or through the use of a framework, such
    as Gorilla. We've tried to demonstrate the inner workings of the latter so you're
    able to build without additional libraries obfuscating the functionality.
  prefs: []
  type: TYPE_NORMAL
- en: We've implemented sessions into our application to enable persistent state between
    requests. This is the very basis of authentication for the Web. By enabling `users`
    and `sessions` table in our database, we're able to log users in, register a session,
    and associate that session with the proper user on subsequent requests.
  prefs: []
  type: TYPE_NORMAL
- en: By utilizing flash messages, we made use of a very specific feature that allows
    transfer of information between two endpoints without enabling an additional request
    that may look like an error to the user or generate erroneous output. Our flash
    messages works just once and then expire.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 7](ch07.html "Chapter 7. Microservices and Communication"), *Microservices
    and Communication*, we'll look at connecting disparate systems and applications
    across our existing and new APIs to allow event-based actions to be coordinated
    between those systems. This will facilitate connecting to other services within
    the same environment as well as those outside of our application.
  prefs: []
  type: TYPE_NORMAL
