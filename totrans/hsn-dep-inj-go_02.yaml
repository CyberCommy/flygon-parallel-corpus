- en: SOLID Design Principles for Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In 2002, *Robert "Uncle Bob" Martin* published the book *Agile Software Development,
    Principles, Patterns, and Practices* in which he defined the five principles of
    reusable programs, which he called SOLID principles. While it might seem strange
    to include these principles in a book about a programming language invented 10
    years later, these principles are still relevant today.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will briefly examine each of these principles, how they
    relate to **dependency injection** (**DI**) and what that means for Go. SOLID
    is an acronym for five popular object-oriented software design principles:'
  prefs: []
  type: TYPE_NORMAL
- en: Single responsibility principle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Open/closed principle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Liskov substitution principle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interface segregation principle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependency inversion principle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The only requirement for this chapter is a basic understanding of objects and
    interfaces and an open mind.
  prefs: []
  type: TYPE_NORMAL
- en: All code in this chapter is available at [https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/tree/master/ch02](https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/tree/master/ch02).
  prefs: []
  type: TYPE_NORMAL
- en: You will find links to additional information and other references mentioned
    in this chapter in the *Further reading* section at the end of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Single responsibility principle (SRP)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"A class should have one, and only one, reason to change."'
  prefs: []
  type: TYPE_NORMAL
- en: –Robert C. Martin
  prefs: []
  type: TYPE_NORMAL
- en: Go doesn't have classes, but if we squint a little and replace the word *class* with
    *objects* (structs, functions, interfaces or packages), then the concept still
    applies.
  prefs: []
  type: TYPE_NORMAL
- en: 'Why do we want our objects to do only one thing? Let''s look at a couple of
    objects that do one thing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e11113bc-3419-40f2-a79b-fe55cdf8a914.png)'
  prefs: []
  type: TYPE_IMG
- en: These objects are simple and easy to use, and have a wide range of uses.
  prefs: []
  type: TYPE_NORMAL
- en: 'Designing objects so that they all do only one thing sounds okay in the abstract.
    But you are probably thinking that doing so for an entire system would add a lot
    more code. Yes, it will. However, what it doesn''t do is add complexity; in fact,
    it significantly reduces it. Each piece of code would be smaller and easier to
    understand, and therefore easier to test. This fact gives us the first advantage
    of SRP:'
  prefs: []
  type: TYPE_NORMAL
- en: '**SRP reduces the complexity by decomposing code into smaller, more concise
    pieces**'
  prefs: []
  type: TYPE_NORMAL
- en: 'With a name like single responsibility principle, it would be safe to assume
    that it is all about responsibility, but so far, all we have talked about is change.
    Why is this? Let''s look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The code looks reasonable—one member variable and two methods. It does not,
    however, conform to SRP. Let''s assume that the app was successful, and we decided
    that we also needed to output the results to CSV. We could add a method to do
    that, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We have changed the struct and added another `Output()` method. We have added
    more responsibilities to the struct and, in doing so, we have added complexity.
    In this simple example, our changes are confined to one method, so there's no
    risk that we broke the previous code. However, as the struct gets bigger and more
    complicated, our changes are unlikely to be so clean.
  prefs: []
  type: TYPE_NORMAL
- en: Conversely, if we were to break the responsibilities into `Calculate` and `Output`,
    then adding more outputs would mere define new structs. Additionally, should we
    decide that we don't like the default output format, we could change it separately
    from other parts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try a different implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Do you notice anything significant about the printers? They have no connection
    at all to the calculation. They could be used for any data in the same format.
    This leads to the second advantage of SRP:'
  prefs: []
  type: TYPE_NORMAL
- en: '**SRP increases the potential reusability of code**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the first implementation of our coverage calculator, to test the `Output()`
    method we would be first call the `Calculate()` method. This approach increases
    the complexity of our tests by coupling the calculation with the output. Consider
    the following scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: How do we test for no results?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do we test edge conditions, such as 0% or 100% coverage?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After decoupling these responsibilities, we should encourage ourselves to consider
    the inputs and outputs of each part in a less interdependent manner, hence making
    the tests easier to write and maintain. This leads to the third advantage of SRP:'
  prefs: []
  type: TYPE_NORMAL
- en: '**SRP makes tests simpler to write and maintain**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'SRP is also an excellent way to improve general code readability. Take a look
    at this next example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: I'd bet that took more than five seconds to understand. How about this code?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: By applying SRP at the function level, we have reduced the function's bloat
    and increased its readability. The function's single responsibility is now to
    coordinate the calls to the other functions.
  prefs: []
  type: TYPE_NORMAL
- en: How does this relate to DI?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When applying DI to our code, we are unsurprisingly injecting our dependencies,
    typically in the form of a function parameter. If you see a function with many
    injected dependencies, this is a likely sign that the method is doing too much.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, applying SRP will inform our object design. As such, this helps
    us identify when and where to use DI.
  prefs: []
  type: TYPE_NORMAL
- en: What does this mean for Go?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 1](32773d95-0c4b-45bc-97e6-ce1ca3f3b3b9.xhtml), *Never Stop Aiming
    for Better*, we mentioned Go's relationship with the Unix philosophy, which states
    that we should *design code that does a single thing, but to does it well and
    works well together well with other code*. After applying SRP, our objects will
    be perfectly in line with this principle.
  prefs: []
  type: TYPE_NORMAL
- en: Go interfaces, structs, and functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the interface and struct level, applying SRP results in many small interfaces.
    A function that complies with the SRP has few inputs and is quite short (that
    is, it has less than one screen of code). Both of these features inherently address
    the code bloat smells we mentioned in [Chapter 1](32773d95-0c4b-45bc-97e6-ce1ca3f3b3b9.xhtml),
    *Never Stop Aiming for Better*.
  prefs: []
  type: TYPE_NORMAL
- en: By addressing the code bloat, we find that one of the less-advertised advantages
    of SRP is that it makes code easier to understand. Simply put, when a piece of
    code does one thing, its purpose is clearer.
  prefs: []
  type: TYPE_NORMAL
- en: When applying SRP to existing code, you will often break the code into smaller
    pieces. You may experience a natural aversion to this, due to the feeling that
    you might also then have to write more tests. In cases where you are splitting
    a struct or interface into multiple parts, this may be true. However, if the code
    you are refactoring has high unit-test coverage, then you probably already have
    many of the tests you need. They just need to be moved around a little bit.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, when applying SRP to a function to reduce bloat, no new
    tests are required; the tests for the original function are perfectly acceptable.
    Let''s look at an example of a test for our `loadUserHandler()`, which was shown
    in the preceding example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This test can be applied to either form of our function and will achieve the
    same thing. In this case, we were refactoring for readability, and we don't want
    anything to discourage us from that. Additionally, testing from the API (either
    a public method or a function called by others) is more stable, as the API contract
    is less likely to change than the internal implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Go packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Applying SRP at the package level is perhaps harder to do. Systems are often
    designed in layers. For example, it''s common to see an HTTP REST service with
    layers arranged in the following manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/528ec62c-ccb2-464d-bc13-926017793262.png)'
  prefs: []
  type: TYPE_IMG
- en: These abstractions are nice and clear; however, problems start to appear when
    our service has more than a few endpoints. We very quickly end up with monster
    packages full of entirely unrelated logic. Good packages, on the other hand, are
    small, concise, and clear of purpose.
  prefs: []
  type: TYPE_NORMAL
- en: 'It can be hard to find the right abstraction. Often, when I am in need of inspiration,
    I turn to the experts and examine the standard Go libraries. For example, let''s
    take a look at the `encoding` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2b144d17-587f-4b9d-9245-dae8f9d9d965.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, each different type is neatly organized in its own package,
    but all of the packages are still grouped logically by the parent directory. Our
    REST service would break it down as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/29ac7f3f-93ef-48ec-a808-627f86f2abb6.png)'
  prefs: []
  type: TYPE_IMG
- en: Our initial abstractions are on the right track, only from too high a level.
  prefs: []
  type: TYPE_NORMAL
- en: Another aspect of the `encoding` package that is not immediately apparent is
    that the shared code is in the parent package. When working on a feature, it's
    common for programmers to think *I need that code I wrote earlier*, and for them
    to be tempted to extract the code to a `commons` or `utils` package. Please resist
    this temptation—reusing the code is absolutely correct, but you should resist
    the allure of the general package name. Such packages inherently violate SRP by
    having no clear-cut purpose.
  prefs: []
  type: TYPE_NORMAL
- en: Another common temptation is to add the new code next to the existing code.
    Let's imagine that we were writing the `encoding` package mentioned previously
    and the first encoder we made was the JSON one. Next, we add the GobEncoder, and
    things are going great. Add a few more encoders, and suddenly we have a substantial
    package with lots of code and a large exported API. At some point, the documentation
    for our little `encoding` package becomes so long that it will be hard for users
    to follow. Similarly, we have so much code in the package that our extension and
    debugging work slows down because it's hard to find things.
  prefs: []
  type: TYPE_NORMAL
- en: SRP helps us identify reasons to change; multiple reasons to change indicate
    multiple responsibilities. Decoupling these responsibilities enables us to develop
    better abstractions.
  prefs: []
  type: TYPE_NORMAL
- en: If you have the time or the inclination to do it right from the start, fantastic.
    However, applying SRP and finding the correct abstractions from the beginning
    is difficult. You can counter this by breaking the rules first and then using
    subsequent changes to discover how the software wants to evolve, using the forces
    of evolution as the basis for refactoring.
  prefs: []
  type: TYPE_NORMAL
- en: Open/closed principle (OCP)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"Software entities (classes, modules, functions, etc.) should be open for extension,
    but closed for modification."'
  prefs: []
  type: TYPE_NORMAL
- en: '- Bertrand Meyer'
  prefs: []
  type: TYPE_NORMAL
- en: The terms *open* and *closed* are not something I often hear when discussing
    software engineering, so perhaps they could do with a little explanation.
  prefs: []
  type: TYPE_NORMAL
- en: Open means that we should be able to extend or adapt code by adding new behaviors
    and features. Closed means that we should avoid making changes to existing code,
    changes that could result in bugs or other kinds of regression.
  prefs: []
  type: TYPE_NORMAL
- en: These two characteristics might seem contradictory, but the missing piece of
    the puzzle is the scope. When talking about being open, we are talking about the
    design or structure of the software. From this perspective, being open means that
    it is easy to add new packages, new interfaces, or new implementations of an existing
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we talk about being closed, we are talking about existing code and minimizing
    the changes we make to it, particularly the APIs that are used by others. This
    brings us to the first advantage of OCP:'
  prefs: []
  type: TYPE_NORMAL
- en: '**OCP helps reduce the risk of additions and extensions**'
  prefs: []
  type: TYPE_NORMAL
- en: You can think of OCP as a risk-mitigation strategy. Modifying existing code
    always has some risk involved, and changes to the code used by others especially
    so. While we can and should be protecting ourselves from this risk with unit tests,
    these are restricted to scenarios that we intend and misuses that we can imagine;
    they will not cover everything our users can come up with.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code does not follow the OCP:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The first hint that something is amiss is the `switch` statement. It is not
    hard to imagine a situation where requirements change, and where we might need
    to add or even remove an output format.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just how much would have to change if we needed to add another format? See
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**We would need to add another case condition to the switch**: This method
    is already 18 lines long; how many more formats do we need to add before we cannot
    see it all on one screen? In how many other places does this `switch` statement
    exist? Will they need to be updated too?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**We would need to write another formatting function**: This is one of three
    changes that are unavoidable'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The caller of the method would have to be updated to use the new format**:
    This is the other unavoidable change'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**We would have to add another set of test scenarios to match the new formatting**:
    This is also unavoidable; however, the tests here will likely be longer than just
    testing the formatting in isolation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What started as a *small and simple change* is beginning to feel more arduous
    and risky than we intended.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s replace the format input parameter and the `switch` statement with an
    abstraction, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'How many changes was it this time? Let''s see:'
  prefs: []
  type: TYPE_NORMAL
- en: We need to define another implementation of the `PersonFormatter` interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The caller of the method has to be updated to use the new format
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have to write test scenarios for the new `PersonFormatter`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'That''s much better: we are down to only the three unavoidable changes and
    *we changed nothing in the primary function at all*. This shows us the second
    advantage of OCP:'
  prefs: []
  type: TYPE_NORMAL
- en: '**OCP can help reduce the number of changes needed to add or remove a feature**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, if there happens to be a bug in our new structure after adding the new
    formatter, it can only be in one place—the new code. This is the third advantage
    of OCP:'
  prefs: []
  type: TYPE_NORMAL
- en: '**OCP narrows the locality of bugs to only the new code and its usage**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at another example, where we don''t end up applying DI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, both our HTTP handlers are pulling the data from the form and
    then converting it into a number. One day, we decide to tighten our input validation
    and ensure that the number is positive. The likely result? Some pretty nasty shotgun
    surgery. In this case, however, there is no way around. We made the mess; now
    we need to clean it up. The fix is hopefully pretty obvious—extracting the repeated
    logic to one place and then adding the new validation there, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Sadly, the original code has not reduced, but it's definitely easier to read.
    Beyond that, we have future-proofed ourselves against any further changes to the
    validation of the `UserID` field.
  prefs: []
  type: TYPE_NORMAL
- en: For both our examples, the key to meeting OCP was to find the correct abstraction.
  prefs: []
  type: TYPE_NORMAL
- en: How does this relate to DI?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 1](32773d95-0c4b-45bc-97e6-ce1ca3f3b3b9.xhtml), *Never Stop Aiming
    for Better,* we defined DI as *coding in such a way that those resources that
    we depend on are abstractions*. By using OCP, we can discover cleaner and more
    durable abstractions.
  prefs: []
  type: TYPE_NORMAL
- en: What does this mean for Go?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Typically, when discussing OCP, the examples are littered with abstract classes,
    inheritance, virtual functions, and all kinds of things that Go doesn't have.
    Or does it?
  prefs: []
  type: TYPE_NORMAL
- en: What is an abstract class really? What is it actually trying to achieve?
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s trying to provide a place for code that is shared between several implementations.
    We can do that in Go—it''s called **composition**. You can see it at work in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we have extracted some of the shared logic into a
    `rowConverter` struct. Then, by embedding that struct in the other structs, we
    can use it without any changes. We have achieved the goals of the abstract class
    and OCP. Our code is open; we can embed wherever we like but closed. The embedded
    class has no knowledge of the fact that it was embedded, nor did it require any
    changes to be used.
  prefs: []
  type: TYPE_NORMAL
- en: Earlier, we defined *closed* as remaining unchanged, but restricted the scope
    to only the parts of the API that were exported or used by others. It is not reasonable
    to expect that internal implementation details, including private member variables,
    should never change. The best way to achieve this is to hide those implementation
    details. This is called **encapsulation**.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the package level, encapsulation is simple: we make it private. A good rule
    of thumb here is to make everything private and only make things public when you
    really have to. Again, my justification is risk and work avoidance. The moment
    you export something is the moment that someone could rely on it. Once they rely
    on it, it should become closed; you have to maintain it, and any changes have
    a higher risk of breaking something. With proper encapsulation, changes within
    a package should be invisible to existing users.'
  prefs: []
  type: TYPE_NORMAL
- en: At the object level, private doesn't mean what it does in other languages, so
    we have to learn to behave ourselves. Accessing private member variables leaves
    the objects tightly coupled, a decision that will come back to bite us.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of my favorite features of Go''s type system is the ability to attach methods
    to just about anything. Let''s say you are writing an HTTP handler for a health
    check. It does nothing more than return the status `204` (No Content). The interface
    we need to satisfy is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'A simple implementation might look as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We could create a new struct to implement an interface, but that''s going to
    be at least five lines. We can reduce it to three, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The secret sauce, in this case, is hidden in the standard library. We are casting
    our function into the `http.HandlerFunc` type, which has a `ServeHTTP` method
    attached to it. This nifty little trick makes it easy for us to satisfy the `http.Handler`
    interface. As we have already seen in this chapter, moving towards interfaces
    leads us to less coupled code that is easier to maintain and extend.
  prefs: []
  type: TYPE_NORMAL
- en: Liskov substitution principle (LSP)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"If for each object o1 of type S there is an object o2 of type T such that
    for all programs P defined in terms of T, the behavior of P is unchanged when
    o1 is substituted for o2 then S is a subtype of T."'
  prefs: []
  type: TYPE_NORMAL
- en: -Barbara Liskov
  prefs: []
  type: TYPE_NORMAL
- en: 'After reading that three times, I am still not sure I have got it straight.
    Thankfully, Robert C. Martin made it easier on us and summarized it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '"Subtypes must be substitutable for their base types."'
  prefs: []
  type: TYPE_NORMAL
- en: -Robert C. Martin
  prefs: []
  type: TYPE_NORMAL
- en: That I can follow. However, isn't he talking about abstract classes again? Probably.
    As we saw in the section on OCP, while Go doesn't have abstract classes or inheritance,
    it does have a composition and interface implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Let's step back for a minute and look at the motivation of this principle. LSP
    requires that *subtypes are substitutable for each other*. We can use Go interfaces,
    and this will always hold true.
  prefs: []
  type: TYPE_NORMAL
- en: 'But hang on, what about this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'It uses an interface, but it clearly violates LSP. We could fix this by adding
    more interfaces, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'However, this isn''t better. The fact that this code still smells indicates
    that we are probably using the wrong abstraction or the wrong composition. Let''s
    try the refactor again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s much better. The `Buggy` phrase is not forced to implement methods
    that make no sense, nor does it contain any logic it doesn''t need, and the usage
    of both vehicle types is nice and clean. This demonstrates a key point about LSP:'
  prefs: []
  type: TYPE_NORMAL
- en: '**LSP refers to behavior and not implementation**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'An object can implement any interface that it likes, but that doesn''t make
    it behaviorally consistent with other implementations of the same interface. Look
    at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we met (as in delivered) the API contract by implementing
    all of the methods, but we turned the method we didn't need into a NO-OP. By having
    our `ReadOnlyCollection` implement the `Add()` method, it satisfies the interface
    but introduces the potential for confusion. What happens when you have a function
    that accepts a `Collection`? When you call `Add()`, what would you expect to happen?
  prefs: []
  type: TYPE_NORMAL
- en: 'The fix, in this case, might surprise you. Instead of making an `ImmutableCollection`
    out of a `MutableCollection`, we can flip the relation over, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: A bonus of this new structure is that we can now let the compiler ensure that
    we don't use `ImmutableCollection` where we need `MutableCollection`.
  prefs: []
  type: TYPE_NORMAL
- en: How does this relate to DI?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By following LSP, our code performs consistently regardless of the dependencies
    we are injecting. Violating LSP, on the other hand, leads us to violate OCP. These
    violations cause our code to have too much knowledge of the implementations, which
    in turn breaks the abstraction of the injected dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: What does this mean for Go?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When using composition—particularly the unnamed variable form—to satisfy interfaces,
    LSP applies just as it would in object-oriented languages.
  prefs: []
  type: TYPE_NORMAL
- en: When implementing interfaces, we can use LSP's focus on *consistent *behavior as
    a way of detecting code smells related to incorrect abstractions.
  prefs: []
  type: TYPE_NORMAL
- en: Interface segregation principle (ISP)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"Clients should not be forced to depend on methods they do not use."'
  prefs: []
  type: TYPE_NORMAL
- en: –Robert C. Martin
  prefs: []
  type: TYPE_NORMAL
- en: Personally, I prefer a much more direct definition—*interfaces should be reduced
    to the minimum possible size*.
  prefs: []
  type: TYPE_NORMAL
- en: Let's first discuss why fat interfaces might be a bad thing. Fat interfaces
    have more methods and are therefore likely to be harder to understand. They also
    require more work to use, whether this be through implementing, mocking, or stubbing
    them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fat interfaces indicate more responsibility and, as we saw with the SRP, the
    more responsibility an object has, the more likely it will want to change. If
    the interface changes, it causes a ripple effect through all its users, violating
    OCP and causing a massive amount of shotgun surgery. This is the first advantage
    of ISP:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ISP requires us to define thin interfaces**'
  prefs: []
  type: TYPE_NORMAL
- en: 'For many programmers, their natural tendency is to add to the existing interface
    rather than define a new one, thereby creating a fat interface. This leads to
    a situation where the, sometimes singular, implementation becomes tightly coupled
    with the users of the interface. This coupling then makes the interface, their
    implementations, and users all the more resistant to change. Consider the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s not hard to imagine all of these methods belonging to one struct. Method
    pairs such as `GetItem()` and `GetItemWithContext()` are quite likely to share
    much, if not almost all, of the same code. On the other hand, a user of `GetItem()`
    is not likely to also use `GetItemWithContext()`. For this particular use case,
    a more appropriate interface would be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Leveraging this new, thin interface makes the function signature far more explicit
    and flexible. This leads us to the second advantage of ISP:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ISP leads to explicit inputs**.'
  prefs: []
  type: TYPE_NORMAL
- en: A thin interface is also more straightforward to more fully implement, keeping
    us away from any potential problems with LSP.
  prefs: []
  type: TYPE_NORMAL
- en: 'In cases where we are using an interface as an input and the interface needs
    to be fat, this is a powerful indication that the method is violating SRP. Consider
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Do you see the issue? We are using the `context` interface, which is fantastic
    and highly recommended, but we are violating ISP. Being pragmatic programmers,
    we can argue that this interface is widely used and understood, and the value
    of defining our own interface to reduce it to the two methods that we need is
    unnecessary. In most cases, I would agree, but in this particular case, we should
    reconsider. We are using the `context` interface for two entirely separate purposes.
    The first is a control channel to allow us to stop short or timeout the task,
    and the second is to provide a value. In effect, our usage of `context` here is
    violating SRP and, as such, risks potential confusion and results in a greater
    resistance to change.
  prefs: []
  type: TYPE_NORMAL
- en: 'What happens if we decide to use the stop channel pattern not on a request
    level, but at the application level? What happens if the key value is not in the
    `context`, but from some other source? By applying the ISP, we can separate the
    concerns into two interfaces, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Our function now complies with the ISP, and both inputs are free to evolve
    separately. But what happens to the users of this function? Must they stop using
    `context`? Absolutely not. The method can be called as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The repeated use of `context` as a parameter likely feels a little weird but,
    as you can see, it''s for a good cause. This leads us to our final advantage of
    the ISP:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ISP helps to decouple the inputs from their concrete implementation, enabling
    them to evolve separately**.'
  prefs: []
  type: TYPE_NORMAL
- en: How does this relate to DI?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have seen, the ISP helps us to break down interfaces to logically separate
    parts, with each part providing a particular feature—a concept sometimes referred
    to as a role interface. By leveraging these role interfaces in our DI, our code
    becomes decoupled from the concrete implementation of the inputs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Not only does this decoupling allow parts of the code to evolve separately,
    but it also tends to make it easier to identify test vectors. In the previous
    example, it''s easier to scan through the inputs one at a time and consider their
    possible values and states. This process might result in a list of vectors like
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Test vectors for the *value* input include**:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Happy path**: Returns a valid value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Error path**: Returns an empty value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Test vectors for the *monitor* input include**:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Happy path**: Does not return a done signal'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Error path**: Immediately returns a done signal'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What does this mean for Go?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 1](32773d95-0c4b-45bc-97e6-ce1ca3f3b3b9.xhtml), *Never Stop Aiming
    for Better,* we mentioned the popular Go idiom coined by *Jack Lindamood*—*accept
    interfaces, return structs*. Combine this idea with the ISP and things start to
    take off. The resultant functions are very concise about their requirements and,
    at the same time, they are quite explicit regarding their outputs. In other languages,
    we might have to define the outputs in the form of an abstraction or create adapter
    classes to decouple our function from our users entirely. However, given Go's
    support for implicit interfaces, there is no need for this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Implicit interfaces are a language feature whereby the implementor (that is,
    the struct) does not need to define the interfaces that it implements, but rather
    only needs to define the appropriate methods to satisfy the interface, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This might seem like a neat trick to cut down on typing, and it is. However,
    that is not the only reason to use it. When using explicit interfaces, the implementing
    object becomes somewhat coupled with its dependents as there is a rather explicit
    link between them. However, perhaps the most significant reason is simplicity.
    Let''s look at one of the most popular interfaces in Go that you''ve probably
    never heard of:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This interface might not look impressive, but the fact that the `fmt` package
    supports this interface allows you to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: If we had explicit interfaces, imagine how many times we would have to declare
    that we implement `Stringer`. Perhaps where implicit interfaces give us the most
    significant advantage in Go is when they are combined with the ISP and DI. The
    combination of the three allows us to define input interfaces that are thin, specific
    to the particular use case, and decoupled from everything else, as we saw with
    the `Stringer` interface.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, defining interfaces in the package in which they are used narrows
    the scope of knowledge required to work on a piece of code, which in turn makes
    it much easier to understand and test.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency inversion principle (DIP)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"High level modules should not depend on low level modules. Both should depend
    on abstractions. Abstractions should not depend upon details. Details should depend
    on abstractions"'
  prefs: []
  type: TYPE_NORMAL
- en: –Robert C. Martin
  prefs: []
  type: TYPE_NORMAL
- en: 'Have you ever found yourself standing in a shoe store wondering if you should
    get the brown or the black pair, only to get home and regret your choice? Sadly,
    once you''ve bought them, they''re yours. Programming against concrete implementations
    is the same thing: once you choose, you are stuck with it, refunds and refactoring
    notwithstanding. But why choose when you don''t have to? Look at the relationship
    shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d884c295-071e-4718-94e8-a3147c61a713.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Not very flexible, is it?  Let''s convert the relationship into an abstraction:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/51c1018c-2c1f-4f10-a286-eff0cf163de8.png)'
  prefs: []
  type: TYPE_IMG
- en: That's much better. Everything relies only on nice clean abstractions, satisfying
    both LSP and ISP. The packages are concise and clear, happily satisfying the SRP.
    The code even *seems* to satisfy *Robert C*. *Martin*'*s* description of the DIP,
    but sadly, it doesn't. It's that pesky word in the middle, inversion.
  prefs: []
  type: TYPE_NORMAL
- en: In our example, the `Shoes` package owns the `Shoe` interface, which is entirely
    logical. However, problems arise when the requirements change. Changes to the
    `Shoes` package are likely to cause the `Shoe` interface to want to change. This
    will, in turn, require the `Person` object to change. Any new features that we
    add to the `Shoe` interface may be not be needed or relevant to the `Person` object.
    Therefore, the `Person` object is still coupled to the `Shoe` package.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to entirely break this coupling, we need to change the relationship
    from **Person ** uses Shoe to **Person ** requires **Footwear**, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fbac05cb-978c-49ef-b58d-d2dead2306d0.png)'
  prefs: []
  type: TYPE_IMG
- en: There are two key points here. Firstly, the DIP forces us to focus on the ownership
    of the abstractions. In our example, that means moving the interface into the
    package where it was used and changing the relationship from *uses* to *requires*;
    it's a subtle difference, but an important one.
  prefs: []
  type: TYPE_NORMAL
- en: Secondly, the DIP encourages us to decouple usage requirements from implementations.
    In our example, our `Brown Shoes` object implements `Footwear`, but it's not hard
    to imagine a lot more implementations and some might not even be shoes.
  prefs: []
  type: TYPE_NORMAL
- en: How does this relate to DI?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dependency inversion is very easy to mistake for dependency injection, and many,
    including me for a long time, assume that they are equivalent. But as we have
    seen, dependency inversion focuses on the ownership of the dependencies' abstract
    definition, and DI is focused on using those abstractions.
  prefs: []
  type: TYPE_NORMAL
- en: By applying DIP with DI, we end up with very well-decoupled packages that are
    incredibly easy to understand, easy to extend, and simple to test.
  prefs: []
  type: TYPE_NORMAL
- en: What does this mean for Go?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have talked before about Go's support for implicit interfaces and how we
    can leverage that to define our dependencies as interfaces in the same package,
    rather than importing an interface from another package. This approach is DIP.
  prefs: []
  type: TYPE_NORMAL
- en: Perhaps your inner skeptic is going crazy, yelling, *but this would mean I would
    have to define interfaces everywhere!* Yes, that might be true. It could even
    result in a small amount of duplication. You will find, however, that the interfaces
    you would have defined without dependency inversion would have been fatter and
    more unwieldy, a fact that would have cost you more to work with in the future.
  prefs: []
  type: TYPE_NORMAL
- en: After applying DIP, you are unlikely to have any circular dependency issues.
    In fact, you will almost certainly find that the number of imports in your code
    drops significantly and your dependency graph becomes rather flat. In fact, many
    packages will only be imported by the `main` package.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this brief introduction of SOLID design principles, we learned how they apply
    not only to DI, but also to Go. During our examination of the various DI methods
    in the second section of this book, we will frequently reference these principles.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will continue to examine the aspects of coding that
    should be at the forefront of your mind when studying and experimenting with new
    techniques. I will also introduce you to a few handy tools that will make your
    coding life a little easier.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How does the single responsibility principle improve Go code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does the open/closed principle improve Go code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does the liskov substitution principle improve Go code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does the interface segregation principle improve Go code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does the dependency inversion principle improve Go code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How is dependency inversion different from dependency injection?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Packt has many other great resources for learning about SOLID principles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.packtpub.com/mapt/book/application_development/9781787121300/1](https://www.packtpub.com/mapt/book/application_development/9781787121300/1)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.packtpub.com/mapt/book/application_development/9781785884375/10/ch10lvl1sec50/the-solid-principles](https://www.packtpub.com/mapt/book/application_development/9781785884375/10/ch10lvl1sec50/the-solid-principles)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.packtpub.com/mapt/book/application_development/9781785280832/8](https://www.packtpub.com/mapt/book/application_development/9781785280832/8)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
