- en: Chapter 8. AI in Game Development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, the following recipes will be covered:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding artificial intelligence to a game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using heuristics in a game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a Binary Space Partition Tree
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a decision making AI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding behavioral movements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using neural network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using genetic algorithms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using other waypoint systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Artificial intelligence** (**AI**) can be defined in many ways. Artificial
    intelligence deals with finding similarities in different situations and differences
    in similar situations. AI can help to bring realism to a game. The user playing
    the game should feel that that entity that they are competing against is another
    human. Achieving this is extremely difficult and can consume a lot of processing
    cycles. In fact, there is a *turing test* held every year to determine whether
    an AI can fool other humans into believing that it is human. Now, if we use a
    lot of processing cycles for the AI, then executing the game at above 40 FPS can
    become extremely difficult. Hence we need to write efficient algorithms to achieve
    this.'
  prefs: []
  type: TYPE_NORMAL
- en: Adding artificial intelligence to a game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Adding artificial intelligence to a game may be easy or extremely difficult,
    based on the level of realism or complexity we are trying to achieve. In this
    recipe, we will start with the basics of adding artificial intelligence.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To work through this recipe, you will need a machine running Windows and a version
    of Visual Studio. No other prerequisites are required.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will see how easy it is to add a basic artificial intelligence
    to the game. Add a source file called `Source.cpp`. Add the following code to
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous example, we are using a string array to store a response. The
    idea of the software is to create an intelligent chat bot that can reply to questions
    asked by users and interact with them as if it were human. Hence the first task
    was to create an array of responses. The next thing to do is to ask the user for
    the question. In this example, we are searching for a basic keyword called `Hi`
    and, based on that, we are displaying the appropriate answer. Of course, this
    is a very basic implementation. Ideally we would have a list of keywords and responses
    when either of the keywords is triggered. We can even personalize this by asking
    the user for their name and then appending it to the answer every time.
  prefs: []
  type: TYPE_NORMAL
- en: The user may also ask to search for something. That is actually quite an easy
    thing to do. If we have detected the word that the user is longing to search for
    correctly, we just need to enter that into the search engine. Whatever result
    the page displays, we can report it back to the user. We can also use voice commands
    to enter the questions and give the responses. In this case, we would also need
    to implement some kind of **NLP** (**Natural Language** **Processing**). After
    the voice command is correctly identified, all the other processes are exactly
    the same.
  prefs: []
  type: TYPE_NORMAL
- en: Using heuristics in a game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Adding heuristics in a game means to define rules. We need to define a set of
    rules for the AI agent so that it can move to its destination in the best possible
    way. For example, if we want to write a pathfinding algorithm, and define only
    its start and end positions, it may get there in many different ways. However,
    if we want the agent to reach the goal in a particular way, we need to establish
    a heuristic function for it.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need a Windows machine and a working copy of Visual Studio. No other prerequisites
    are required.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will find out how easy it is to add a heuristic function
    to our game for pathfinding. Add a source file called `Source.cpp` and add the
    following code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are many ways to define what a heuristic is. However, the simplest way
    to think about it is that it is a function that provides hints and directions
    for the AI to reach a specified goal. Let us say that our AI needs to go from
    point `A` to point `D`. Now, there are also points `B` and `C` somewhere on the
    map. How should the AI decide which path to take? This is what is provided by
    a heuristic function. In this example, we have used a heuristic in a pathfinding
    algorithm called `A*`. In special cases where the heuristic function is `0`, we
    get an algorithm called **Dijkstra's**.
  prefs: []
  type: TYPE_NORMAL
- en: Let us consider Dijkstra's first. It will be easier to understand `A*` later.
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/4929_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Let us consider we need to find the shortest path between **s** and **x**, traversing
    all nodes at least once. **s**, **t**, **y**, **x**, and **z** are the different
    nodes or the different subdestinations. The number from one node to another node
    is the cost of going from one node to the other. The algorithm states that we
    start from **s** with a **0** value and consider all other nodes to be infinite.
    The next thing to consider is the nodes adjacent to **s**. The nodes adjacent
    to **s** are **t** and **y**. The cost of reaching them is **5** and **10** respectively.
    We note that and then replace the infinity value at those nodes with **5** and
    **10**. Now let us consider the node **y**. The adjacent nodes are **t**, **x**,
    and **z**. The cost to reach **x** is **5** (its current node value) plus **9**
    (path cost value) equals *14*. Similarly, the cost to reach **z** is *5 + 2 =
    7*. So we replace the infinity values of **x** and **z** with **14** and **7**
    respectively. Now, the cost to reach **t** is *5 + 3 = 8*. However, it already
    has a node value. Its value is **10**. Since *8<10*, we will replace **t** with
    **8**. We keep on doing this for all the nodes. After that we will get the minimum
    cost to traverse all the nodes.
  prefs: []
  type: TYPE_NORMAL
- en: '`A*` has two cost functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`g(x)`: This is the same as Dijkstra. It is the real cost to reach node **x**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`h(x)`: This is the approximate cost from node **x** to the goal node. It is
    a heuristic function. This heuristic function should never overestimate the cost.
    That means the real cost to reach goal node from node **x** should be greater
    than or equal to `h(x)`. It is called an admissible heuristic.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The total cost of each node is calculated using *f(x) = g(x)+h(x)*.
  prefs: []
  type: TYPE_NORMAL
- en: In `A*`, we do not need to traverse all nodes, we just need to find the minimum
    path from start to the destination. An A* search only expands a node if it seems
    promising. It only focuses on reaching the goal node from the current node, not
    reaching every other node. It is optimal if the heuristic function is admissible.
    So writing the heuristic function is the key to checking whether to expand to
    a node or not. In the previous example, we used neighboring nodes and formed a
    priority list to decide that.
  prefs: []
  type: TYPE_NORMAL
- en: Using a Binary Space Partition Tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes in games we work with a lot of geometry and huge 3D worlds. If our
    game camera was to render all of it all the time, then it would be extremely expensive
    and the game would not be able to run smoothly at higher frame rates. Hence we
    need to write intelligent algorithms so that the world is divided into more manageable
    chunks that can be traversed easily using a tree structure.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to have a working Windows machine and a working copy of Visual Studio.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Add a source file called `Source.cpp`. Then add the following code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **Binary Space Partition** (**BSP**) tree, as the name implies, is a tree
    structure within which a geometrical space is partitioned. To be more precise,
    in BSP a plane is portioned into more hyperplanes. A plane is such that it has
    one dimension less than the ambient space from which it was created. So a 3D plane
    would have 2D hyperplanes and a 2D plane would have 1D lines. The idea behind
    this is once we have divided the planes into these hyperplanes in a logical manner,
    we can save the formation into a tree structure. Finally, we can traverse the
    tree structure in real time to provide better frame rates for the game overall.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us consider an example in which the world looks like the following diagram.
    The camera must decide which areas it should render and which it should not. Hence,
    dividing them using a logical algorithm is necessary:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/4929_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'After we apply the algorithm, the tree structure should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/4929_08_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, we traverse this algorithm as with any other tree structure, using
    the concept of parent and child, and we get the desired sections that the camera
    should render.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a decision making AI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **decision tree** is one of the most useful things to have in machine learning
    for AI. Given a large number of scenarios, based on certain parameters, decision
    making is essential. If we can write a system that can make these decisions well,
    then we can not only have a well-written algorithm but also have a lot of unpredictability
    in terms of gameplay. This will add a lot of variation to the game and will help
    the *replayability* of the overall game.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, you will need a Windows machine and Visual Studio. No other
    prerequisites are required.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will find out how easy it is to add source control:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As the name suggests, a decision tree is a subset of the tree data structure.
    Therefore, there is a root node and two child nodes. The root node denotes a condition
    and the child nodes will have the probable solutions. On the next level, those
    solution nodes will become part of the condition, which will lead to two more
    solution nodes. Hence, as the preceding example shows, the entire structure is
    modeled on the basis of a tree structure. We have a root node and then primary
    and secondary nodes. We need to traverse the tree to continuously find the answers
    to a situation based on the root nodes and the child nodes.
  prefs: []
  type: TYPE_NORMAL
- en: We have also written a `Query` function that will query the tree structure to
    find out what the most probable scenario is for the situation. That in turn will
    get the help of a decision function, which will add its own level of heuristics,
    combined with the result of the query, and generate the output for the solution.
  prefs: []
  type: TYPE_NORMAL
- en: Decision trees are extremely fast, because for every scenario we are checking
    only half the tree. So in effect we have reduced the search space by half. The
    tree structure also makes it robust, so that we can add and remove nodes on the
    fly as well. This gives us a lot of flexibility and the overall architecture of
    the game is improved.
  prefs: []
  type: TYPE_NORMAL
- en: Adding behavioral movements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we talk about AI in games, after pathfinding the next most important thing
    to consider is movement. When does an AI decide that it has to walk, run, jump,
    or slide? The ability to make these decisions quickly and correctly will make
    the AI really competitive in games and extremely difficult to beat. We can do
    all this with the help of behavioral movements.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, you will need a Windows machine and Visual Studio. No other
    prerequisites are required.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this example, you will find out how easy it is to create a decision tree.
    Add a source file called `Source.cpp` and add the following code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example, we have implemented a simple state machine. The state machine
    is created with the **state-machine** design pattern in mind. So the states in
    this case are walk and run. The objective is that if the AI is walking and then
    needs to switch to running, it can do so at runtime. Similarly, if it is running,
    it can switch to walking at runtime. However, if it is already walking, and a
    request comes to walk, it should notify itself that there is no need to change
    the state.
  prefs: []
  type: TYPE_NORMAL
- en: All these change of states are handled by a class called machine, hence the
    name state-machine pattern. The reason why this structure is preferred by many
    over the traditional state machine design is that all the states need not be defined
    in one class and then a switch case statement can be used to change states. Although
    this method is correct, every additional step that is added to the game would
    require changing and adding to the same class structure. This is a recipe for
    bugs and possible disasters in the future. Instead, we are going for a more object-oriented
    approach where every state is a class in itself.
  prefs: []
  type: TYPE_NORMAL
- en: The `machine` class holds a pointer to the `StateTo` class and then pushes the
    request to the appropriate child class of the state. If we need to add the jump
    state, we do not need to change much in the code. We need to write a new `jump`
    class and add the corresponding functionalities. Because the machine has a pointer
    to the base class (state), it will correspondingly push the request for jump to
    the correct derived class.
  prefs: []
  type: TYPE_NORMAL
- en: Using neural network
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Artificial neural networks** (**ANNs**) are an advanced form of AI used in
    some games. They may not be directly used in-game; however, they may be used during
    the production phase to train the AI agents. Neural nets are mostly used as predictive
    algorithms. Based on certain parameters, and historical data, they calculate the
    most likely decision or attribute that the AI agent will distribute. ANNs are
    not restricted to games; they are used across multiple diverse domains to predict
    possible outcomes.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To work through this recipe, you will need a machine running Windows and Visual
    Studio.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Take a look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example snippet, we have created the backbone to write a neural network
    that can predict a letter which is drawn on the screen. Many devices and touch
    screen tablets have this ability to detect a letter that you draw on screen. Let
    us take this and think in terms of game design. If we want to create a game in
    which we draw shapes, and the corresponding weapon will be given to us, which
    we can then use in battle, we can use this as a template to train the agents to
    identify a shape before the game is released onto the market. Generally, games
    like these only detect basic shapes. These can be easily detected and do not require
    neural nets to train agents.
  prefs: []
  type: TYPE_NORMAL
- en: 'In games, ANNs will mostly be used to create good AI behavior. However, it
    is not wise to use ANNs while the game is being played, as they are expensive
    and take a long time to train agents. Let us look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Class type | Speed | HP |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Melee | Speed (4) | 25 (HP) |'
  prefs: []
  type: TYPE_TB
- en: '| Archer | Speed (7) | 22 (HP) |'
  prefs: []
  type: TYPE_TB
- en: '| Magic | Speed (6.4) | 20 (HP) |'
  prefs: []
  type: TYPE_TB
- en: '| ? | Speed (6.6) | 21 (HP) |'
  prefs: []
  type: TYPE_TB
- en: Given the data, what is the most likely class of the unknown? The number of
    parameters (**Class type**, **Speed**, and **HP**) is only three, but in reality
    it will be over 10\. It will be difficult to predict the class by just looking
    at those numbers. That's where an ANN comes in. It can predict any of the missing
    column data based on other columns' data and previous historical data. This becomes
    a very handy tool for the designer to use to balance the game.
  prefs: []
  type: TYPE_NORMAL
- en: A few concepts of the ANN which we have implemented is necessary to understand.
  prefs: []
  type: TYPE_NORMAL
- en: 'An ANN is typically defined by three types of parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: The interconnection pattern between the different layers of neurons.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The learning process for updating the weights of the interconnections.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The activation function that converts a neuron's weighted input to its output
    activation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following diagram explaining the layers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/4929_08_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Input Layer** is the layer in which we supply all the column data that is
    known, both historical and new. The process first involves supplying data whose
    output we already know. This phase is known as the learning phase. There are two
    types of learning algorithms, supervised and non-supervised. The explanation for
    these is out of the scope of this book. After that, there is a training algorithm
    that is applied to minimize the errors in the desired output. Back-propagation
    is one such technique, in which the weights that calculate the neural network
    function are adjusted till we get close to the desired result. After the network
    is set and is giving correct results for already known outputs, we can then supply
    new data and find the results for the unknown column data.'
  prefs: []
  type: TYPE_NORMAL
- en: Using genetic algorithms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **genetic** **algorithm** (**GA**) is a method of **evolutionary** **algorithm**
    (**EA**). They are particularly useful when we want to write predictive algorithms
    in which only the strongest is selected and the rest are rejected. This is how
    it gets its name. So at every iteration it mutates, does a cross-over, and only
    the best is selected for the next iteration of population. The idea behind genetic
    algorithms is that after multiple iterations only the best possible candidates
    are left.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To work through this recipe, you will need a machine running Windows with an
    installed version of Visual Studio.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will find out how easy it is to write a genetic algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: GA may seem extremely difficult to understand or make sense of at first. However,
    GAs are extremely simple. Let us think of a situation in which we have a land
    that is filled with dragons with different attributes. The objective or goal of
    the dragon is to defeat a human player who has some attributes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Dragon(AI)**'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/4929_08_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Human(Player)**'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/4929_08_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'So for the Dragon to be competitive against the Human, it must learn how to
    run, defend, and attack. Let us see how GA helps us to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: Step 1 (Initial Population)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Dragon(AI):**'
  prefs: []
  type: TYPE_NORMAL
- en: This is our initial population. Each has its own set of properties. We are just
    considering three dragons. In practice, there will be more than that.
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 1 (Initial Population)](img/4929_08_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Step 2 (Fitness function)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The fitness function (%) determines how fit a particular dragon is from the
    population. 100% is perfect fitness.
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 2 (Fitness function)](img/4929_08_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Step 3 Cross-over
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Based on the fitness function and the attributes that are missing, there will
    be a cross-over or reproduction phase to create a new dragon with both properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 1**'
  prefs: []
  type: TYPE_NORMAL
- en: '| Fitness | Dragon | Attribute 1 | Attribute 2 | Attribute 3 |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 60% | Dragon 1 | Run | Defend | Attack |'
  prefs: []
  type: TYPE_TB
- en: '| 75% | Dragon 2 | Run | Defend | Attack |'
  prefs: []
  type: TYPE_TB
- en: '| 20% | Dragon 3 | Run | Defend | Attack |'
  prefs: []
  type: TYPE_TB
- en: '**Table 2**'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 Cross-over](img/4929_08_010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The dragon with the least fitness function will be removed from the population.
    (Survival of the fittest).
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 Cross-over](img/4929_08_011.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Step 4 Mutate
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So we have now got a new dragon that can run as well as attack and has a fitness
    function of *67%*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 4 Mutate](img/4929_08_012.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We must now repeat the process (new generation) with other dragons in the population
    until we are satisfied with the result. The ideal population will be when all
    dragons have the following capabilities:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 4 Mutate](img/4929_08_013.jpg)'
  prefs: []
  type: TYPE_IMG
- en: However, this may not always be possible. We need to be satisfied it is closer
    to the goal. All the stages described here are implemented as functions, and could
    be expanded upon based on the requirements of the AI agent.
  prefs: []
  type: TYPE_NORMAL
- en: Now you could ask, why don't we create dragons with all the properties in the
    first place? That's where adaptive AI comes into play. If we define all the properties
    in the dragons before the user plays the game, it may be very easy to defeat the
    dragons as the game progresses. However, if the AI dragons can adapt based on
    how the player defeats them, it may get progressively more difficult to beat the
    AI. As the player defeats the AI, we need to record the parameters and add that
    parameter as a goal attribute for the dragon, which it can achieve after a few
    cross-overs and mutations.
  prefs: []
  type: TYPE_NORMAL
- en: Using other waypoint systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Waypoints are a way of writing pathfinding algorithms. They are extremely easy
    to write. However, if not thought out properly, they can be extremely buggy and
    the AI can look extremely stupid. Many older games often had this sort of bug,
    which resulted in a revolution in the implementation of waypoint systems.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To work through this recipe, you will need a machine running Windows with an
    installed version of Visual Studio. No other prerequisites are required.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will find out how easy it is to create waypoint systems:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this example, we will just discuss a basic implementation of the waypoint
    system. As the name suggests, waypoints are just 2D/3D points in world space that
    we want the AI agent to follow. All the agent has to do is move from point **A**
    to point **B**. However, this has complications. For example, let us consider
    the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/4929_08_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To get from **A** to **B** is easy. Now, to get from **B** to **C** it has to
    follow a pathfinding algorithm such as A* or Djikstra's algorithm. In that case,
    it will avoid the obstacle in the center and move towards **C**. Now let's say
    it has suddenly seen the user at point **A**, part way through the journey. How
    should it react? If we just provide waypoints, it will look at its dictionary
    of points that it is allowed to move to and which is closest to it. The answer
    will be **A**. However, if it starts going towards **A**, it will be blocked by
    the wall and it may get stuck in a loop, hitting the wall continuously. You may
    have seen this behavior a lot in older games. In this case, the AI must make a
    decision to go back to **B** and then to **A**. So we can't use a waypoint algorithm
    on its own. For better performance and efficiency, we need to write a decision-making
    algorithm and a pathfinding algorithm along with it. This is what is used in most
    modern games, along with techniques such as **NavMesh** and so on.
  prefs: []
  type: TYPE_NORMAL
