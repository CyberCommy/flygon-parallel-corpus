- en: 14\. Spawning the Player Projectile
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn about `Anim Notifies` and `Anim States`, which
    can be found inside Animation Montages. You will code your own `Anim Notify` using
    C++ and implement this notify in the `Throw` Animation Montage. Lastly, you will
    learn about Visual and Audio Effects, and how these effects are used in games.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to play Animation Montages in both
    Blueprints and C++ and know how to spawn objects into the game world using C++
    and the `UWorld` class. These elements of the game will be given audio and visual
    components as an added layer of polish, and your `SuperSideScroller` player character
    will be able to throw projectiles that destroy enemies.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, you made great progress with the enemy character's
    AI by creating a behavior tree that would allow the enemy to randomly select points
    from the `BP_AIPoints` actor you created. This gives the `SuperSideScroller` game
    more life as you can now have multiple enemies moving around your game world.
    Additionally, you learned the different tools available in Unreal Engine 4 that
    are used together to make artificial intelligence of various degrees of complexity.
    These tools included the `Navigation Mesh`, behavior trees, and Blackboards.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have enemies running around your level, you need to allow the player
    to defeat these enemies with the player projectile you started to create at the
    end of the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn how to use the `UAnimNotify` class to spawn
    the player projectile at a specific frame of the `Throw` Animation Montage. You
    will also learn how to add this new notify to the Montage itself, and how to add
    a new `Socket` to the main character skeleton from which the projectile will spawn.
    Lastly, you will learn how to use `Particle Systems` and `SoundCues` to add a
    layer of visual and audio polish to the game.
  prefs: []
  type: TYPE_NORMAL
- en: Let's begin this chapter by learning about `Anim Notifies` and `Anim Notify
    States`. After that, you'll get your hands dirty by creating your own `UAnimNotify`
    class so that you can spawn the player projectile during the `Throw` Animation Montage.
  prefs: []
  type: TYPE_NORMAL
- en: Anim Notifies and Anim Notify States
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When it comes to creating polished and complex animations, there needs to be
    a way for animators and programmers to add custom events within the animation
    that will allow for additional effects, layers, and functionality to occur. The
    solution in Unreal Engine 4 is to use `Anim Notifies` and `Anim Notify States`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main difference between `Anim Notify` and `Anim Notify State` is that `Anim
    Notify State` possesses three distinct events that `Anim Notify` does not. These
    events are `Notify Begin`, `Notify End`, and `Notify Tick`, all of which can be
    used in Blueprints or C++. When it comes to these events, Unreal Engine 4 secures
    the following behaviors:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Notify State` will always start with `Notify Begin Event`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Notify State` will always finish with `Notify End Event`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Notify Tick Event` will always take place between the `Notify Begin` and `Notify
    End` events.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Anim Notify`, however, is a much more simplified version that uses just a
    single function, `Notify()`, to allow programmers to add functionality to the
    notify itself. It works with the mindset of *fire and forget*, meaning you don''t
    need to worry about what happens at the start, end, or anywhere in-between the
    `Notify()` event. It is due to this simplicity of `Anim Notify`, and due to the
    fact that we do not need the events included with `Anim Notify State` that we
    will use `Anim Notify` to spawn the player projectile for the Super Side-Scroller
    game.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before moving on to the following exercise, where you will create your own
    custom `Anim Notify` in C++, let''s briefly discuss some examples of existing
    `Anim Notifies` that Unreal Engine 4 provides by default. A full list of default
    `Anim Notifies` states can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.1: The full list of default Anim Notifies provided in Unreal Engine
    4'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_14_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 14.1: The full list of default Anim Notifies provided in Unreal Engine
    4'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two `Anim Notifies` that you will be using later on in this chapter:
    `Play Particle Effect` and `Play Sound`. Let''s discuss these two in more detail
    so that you are familiar with them by the time you use them:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Play Particle Effect`: The `Play Particle Effect` notify, as the name suggests,
    allows you to spawn and play a particle system at a certain frame of your animation.
    As shown in the following screenshot, you have options to change the VFX being
    used, such as updating the `location`, `rotation`, and `scale` settings of the
    particle. You can even attach the particle to a specified `Socket Name` if you
    so choose:![Figure 14.2: The Details panel of the Play Particle Effect notify,
    which'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: allows you to customize the particle
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_14_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 14.2: The Details panel of the Play Particle Effect notify, which allows
    you to customize the particle'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Visual Effects, or VFX for short, are crucial elements for any game. Visual
    Effects, in Unreal Engine 4, are created using a tool called *Cascade*, inside
    the editor. Since Unreal Engine version 4.20, a new tool called *Niagara* has
    been introduced as a free plugin to improve the quality and pipeline for how VFX
    are made. You can learn more about *Niagara* here: [https://docs.unrealengine.com/en-US/Engine/Niagara/Overview/index.html](https://docs.unrealengine.com/en-US/Engine/Niagara/Overview/index.html).'
  prefs: []
  type: TYPE_NORMAL
- en: A very common example used in games is to use this type of notify to spawn dirt
    or other effects underneath the player's feet while they walk or run. Having the
    ability to specify at which frame of the animation these effects spawn is very
    powerful and allows you to create convincing effects for your character.
  prefs: []
  type: TYPE_NORMAL
- en: '`Play Sound`: The `Play Sound` notify allows you to play a `Soundcue` or `Soundwave`
    at a certain frame of your animation. As shown in the following screenshot, you
    have options to change the sound being used, update its `volume` and `pitch` values,
    and even have the sound follow the owner of the sound via attaching it to a specified
    `Socket Name`:![Figure 14.3: The Details panel of the Play Sound notify, which'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '](img/B16183_14_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 14.3: The Details panel of the Play Sound notify, which allows you to
    customize the sound'
  prefs: []
  type: TYPE_NORMAL
- en: Much like the example given for the `Play Particle Effect` notify, the `Play
    Sound` notify can also be commonly used to play the sounds of footsteps while
    the character is moving. By having control of exactly where on the animation timeline
    you can play a sound, it is possible to create believable sound effects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although you will not be using `Anim Notify States`, it is still important
    to at least know the options that are available to you by default, as shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.4: The full list of default Anim Notify States provided to you
    in Unreal Engine 4'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_14_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 14.4: The full list of default Anim Notify States provided to you in
    Unreal Engine 4'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The two `Notify` states that are not available in animation sequences are the
    *Montage Notify Window* and *Disable Root Motion* states, as shown in the preceding
    screenshot. For more information regarding notifies, refer to the following documentation:
    [docs.unrealengine.com/en-US/Engine/Animation/Sequences/Notifies/index.html](http://docs.unrealengine.com/en-US/Engine/Animation/Sequences/Notifies/index.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Now that you are more familiar with `Anim Notify` and `Anim Notify State`, let's
    move on to the next exercise, where you will create your own custom `Anim Notify`
    in C++ that you will use to spawn the player projectile.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 14.01: Creating a UAnim Notify Class'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The main offensive ability that the player character will have in the `SuperSideScroller`
    game is the projectile that the player can throw at enemies. In the previous chapter,
    you set up the framework and base functionality of the projectile, but right now,
    there is no way for the player to use it. In order to make spawning, or throwing,
    the projectile convincing to the eye, you need to create a custom `Anim Notify`
    that you will then add to the `Throw` Animation Montage. This `Anim Notify` will
    let the player know it's time to spawn the projectile.
  prefs: []
  type: TYPE_NORMAL
- en: 'Do the following to create the new `UAnimNotify` class:'
  prefs: []
  type: TYPE_NORMAL
- en: Inside Unreal Engine 4, navigate to the `File` option and *left-click* to select
    the option for `New C++ Class`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the `Choose Parent Class` dialogue window, search for `AnimNotify` and
    *left-click* the `AnimNotify` option. Then, *left-click* the `Next` option to
    name the new class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name this new class `Anim_ProjectileNotify`. Once named, *left-click* to select
    the `Create Class` option so that Unreal Engine 4 recompiles and hot-reloads the
    new class in Visual Studio.bOnce Visual Studio opens, you will have both the header
    file, `Anim_ProjectileNotify.h`, and the source file, `Anim_ProjectileNotify.cpp`,
    available to you.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `UAnimNotify` base class has one function that needs to be implemented
    inside your class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This function is called automatically when the notify is hit on the timeline
    it is being used in. By overriding this function, you will be able to add your
    own logic to the notify. This function also gives you access to both the `Skeletal
    Mesh` component of the owning notify and the Animation Sequence currently being played.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s add the override declaration of this function to the header file.
    In the header file `Anim_ProjectileNotify.h`, add the following code underneath
    the `GENERATED_BODY()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now that you added the function to the header file, it is time to define the
    function inside the `Anim_ProjectileNotify` source file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `Anim_ProjectileNotify.cpp` source file, define the function and
    add a `UE_LOG()` call that prints the text `"Throw Notify"`, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: For now, you will just use this `UE_LOG()` debugging tool to know that this
    function is correctly being called when you add this notify to the `Throw` Animation
    Montage in the next exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this exercise, you created the groundwork necessary to implement your own
    `AnimNotify` class by adding the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Inside this function, you are using `UE_LOG()` to print the custom text `"Throw
    Notify"` in the output log so that you know that this notify is working correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Later in this chapter, you will update this function so that it calls logic
    that will spawn the player projectile, but first, let's add the new notify to
    the `Throw` Animation montage.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 14.02: Adding the Notify to the Throw Montage'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that you have your `Anim_ProjectileNotify` notify, it is time to add this
    notify to the `Throw` Animation Montage so that it can actually be of use to you.
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, you will add `Anim_ProjectileNotify` to the timeline of the
    `Throw` Montage at the exact frame of the animation that you'd expect the projectile
    to spawn.
  prefs: []
  type: TYPE_NORMAL
- en: 'Complete the following steps to achieve this:'
  prefs: []
  type: TYPE_NORMAL
- en: Back inside Unreal Engine, navigate to the `Content Browser` interface and go
    to the `/MainCharacter/Animation/` directory. Inside this directory, *double-click*
    the `AM_Throw` asset to open the `Animation Montage` editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the very bottom of the `Animation Montage` editor, you will find the timeline
    for the animation. By default, you will observe that the *red colored bar* will
    be moving along the timeline as the animation plays.
  prefs: []
  type: TYPE_NORMAL
- en: '*Left-click* this `red` bar and manually move it to the 22nd `frame`, as close
    as you can, as shown in the following screenshot:![Figure 14.5: The red colored
    bar allows you to manually position'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: notifies anywhere on the timeline
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_14_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 14.5: The red colored bar allows you to manually position notifies anywhere
    on the timeline'
  prefs: []
  type: TYPE_NORMAL
- en: 'The 22nd frame of the `Throw` animation is the exact moment in the throw that
    you would expect a projectile to spawn and be thrown by the player. The following
    screenshot shows the frame of the throw animation, as seen inside the editor within
    `Persona`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.6: The exact moment the player projectile should spawn'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_14_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 14.6: The exact moment the player projectile should spawn'
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know the position on the timeline that the notify should be played,
    you can now *right-click* on the thin `red` line within the `Notifies` timeline.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This will show you a popup where you can add a `Notify` or a `Notify State`.
    In some cases, the `Notifies` timeline may be collapsed and hard to find; simply
    left-click on the word `Notifies` to toggle between collapsed and expanded.
  prefs: []
  type: TYPE_NORMAL
- en: Select `Add Notify` and, from the options provided, find and select `Anim Projectile
    Notify`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After selecting to add `Anim Projectile Notify` to the Notifies timeline, you
    will see the following:![Figure 14.7: Anim_ProjectileNotify successfully added
    to the Throw Animation Montage'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_14_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 14.7: Anim_ProjectileNotify successfully added to the Throw Animation
    Montage'
  prefs: []
  type: TYPE_NORMAL
- en: With the `Anim_ProjectileNotify` notify in place on the `Throw` Animation Montage
    timeline, save the montage.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the `Output Log` window is not visible, please re-enable the window by navigating
    to the `Window` option and hover over it for `Developer Tools`. Find the option
    for `Output Log` and *left-click* to enable it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, use `PIE`, and, once in-game, use the *left mouse button* to start playing
    the `Throw` montage.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the point in the animation where you added the notify, you will now see the
    debugging log text `Throw Notify` appear in the output log.
  prefs: []
  type: TYPE_NORMAL
- en: As you may recall from *Chapter 12*, *Animation Blending and Montages*, you
    added the `Play Montage` function to the player character blueprint, `BP_SuperSideScroller_MainCharacter`.
    For the sake of learning C++ in the context of Unreal Engine 4, you will be moving
    this logic from Blueprint to C++ in the upcoming exercises. This is so that we
    don't rely too heavily on Blueprint scripts for the base behavior of the player
    character.
  prefs: []
  type: TYPE_NORMAL
- en: With this exercise complete, you have successfully added your custom `Anim Notify`
    class, `Anim_ProjectileNotify`, to the `Throw` Animation Montage. This notify
    was added at the precise frame in which you expect a projectile to be thrown from
    the player's hand. Since you added the Blueprint logic to the player character
    in *Chapter 12*, *Animation Blending and Montages*, you are able to play this
    `Throw` Animation Montage when the `InputAction` event, `ThrowProjectile`, is
    called when using the *left mouse button*. Before making the transition from playing
    the Throw Animation Montage in Blueprints to playing the Montage from C++, let's
    discuss playing Animation Montages some more.
  prefs: []
  type: TYPE_NORMAL
- en: Playing Animation Montages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you learned in *Chapter 12*, *Animation Blending and Montages*, these items
    are useful for allowing animators to combine individual animation sequences into
    one complete montage. By splitting the Montage into its own unique sections and
    adding notifies for particles and sound, animators and animation programmers can
    make complex sets of montages that handle all the different aspects of the animation.
  prefs: []
  type: TYPE_NORMAL
- en: But once the Animation Montage is ready, how do we play this Montage on a character?
    You are already familiar with the first method, which is via Blueprints.
  prefs: []
  type: TYPE_NORMAL
- en: Playing Animation Montages in Blueprints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Blueprints, the `Play Montage` function is available for you to use, as
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.8: The Play Montage function in Blueprints'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_14_08.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 14.8: The Play Montage function in Blueprints'
  prefs: []
  type: TYPE_NORMAL
- en: You have already used the function to play the `AM_Throw` Animation Montage.
    This function requires the `Skeletal Mesh` component that the Montage must be
    played on, and it requires the Animation Montage to play.
  prefs: []
  type: TYPE_NORMAL
- en: 'The remaining parameters are optional, depending on how your Montage will work.
    Let''s have a quick look at these parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Play Rate`: The `Play Rate` parameter allows you to increase or decrease the
    playback speed of the Animation Montage. For faster playback, you would increase
    this value; otherwise, you would decrease the value for slower playback speed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Starting Position`: The `Starting Position` parameter allows you to set the
    starting position, in seconds, along the Montage timeline from which the Montage
    will start playing. For example, in an Animation Montage that has a 3-second timeline,
    you could choose to have the Montage start at the `1.0f` position instead of at
    `0.0f`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Starting Section`: The `Starting Section` parameter allows you to tell the
    Animation Montage to start at a specific section. Depending on how your Montage
    is set up, you could have multiple sections created for different parts of the
    montage. For example, a shotgun weapon reloading Animation Montage would include
    a section for the initial movement for reload, a looped section for the actual
    bullet reload, and a final section for re-equipping the weapon so that it is ready
    to fire again.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When it comes to the outputs of the `Play Montage` function, you have a few
    different options:'
  prefs: []
  type: TYPE_NORMAL
- en: '`On Completed`: The `On Completed` output is called when the Animation Montage
    has finished playing and has been fully blended out.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`On Blend Out`: The `On Blend Out` output is called when the Animation Montage
    begins to blend out. This can occur during `Blend Out Trigger Time`, or if the
    Montage ends prematurely.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`On Interrupted`: The `On Interrupted` output is called when the Montage begins
    to blend out due to this Montage being interrupted by another Montage that is
    trying to play on the same skeleton.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`On Notify Begin & On Notify End`: Both the `On Notify Begin` and `On Notify
    End` outputs are called if you are using the `Montage Notify` option under the
    `Notifies` category in the Animation Montage. The name given to the `Montage`
    `Notify` is returned via the `Notify Name` parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Playing Animation Montages in C++
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: On the C++ side, there is only one thing you need to know about, and that is
    the `UAnimInstance::Montage_Play()` function. This function requires the Animation
    Montage to play, the play rate in which to play back the montage, a value of the
    `EMontagePlayReturnType` type, a `float` value for determining the start position
    to play the montage, and a `Boolean` value for determining whether playing this
    Montage should stop or interrupt all montages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although you will not be changing the default parameter of `EMontagePlayReturnType`,
    which is `EMontagePlayReturnType::MontageLength`, it is still important to know
    the two values that exist for this enumerator:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Montage Length`: The `Montage Length` value returns the length of the Montage
    itself, in seconds.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Duration`: The `Duration` value returns the play duration of the montage,
    which is equal to the length of the montage, divided by the play rate.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'For more details regarding the `UAnimMontage` class, please refer to the following
    documentation: https://docs.unrealengine.com/en-US/API/Runtime/Engine/Animation/UAnimMontage/index.html.'
  prefs: []
  type: TYPE_NORMAL
- en: You will learn more about the C++ implementation of playing an Animation Montage
    in the next exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 14.03: Playing the Throw Animation in C++'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that you have a better understanding of play Animation Montages in Unreal
    Engine 4, both via Blueprints and C++, it is time to migrate the logic for playing
    the `Throw` Animation Montage from Blueprints to C++. The reason behind this change
    is because the Blueprint logic was put into place as a placeholder method so that
    you could preview the `Throw` montage. This book is a more heavily focused C++
    guide to game development, and as such, it is important to learn how to implement
    this logic in code.
  prefs: []
  type: TYPE_NORMAL
- en: Let's begin by removing the logic from Blueprints, and then move on to recreating
    the logic in C++ inside the player character class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps will help you complete this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to the player character Blueprint, `BP_SuperSideScroller_MainCharacter`,
    which can be found in the following directory: `/MainCharacter/Blueprints/`. *Double-click*
    this asset to open it.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside this Blueprint, you will find the `InputAction ThrowProjectile` event
    and the `Play Montage` function that you created to preview the `Throw` Animation
    Montage, as shown in the following screenshot. Delete this logic and then recompile
    and save the player character Blueprint:![Figure 14.9: You no longer need this
    placeholder logic inside the player character Blueprint'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_14_09.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 14.9: You no longer need this placeholder logic inside the player character
    Blueprint'
  prefs: []
  type: TYPE_NORMAL
- en: Now, use `PIE` and attempt to throw with the player character by using the *left
    mouse button*. You will observe that the player character no longer plays the
    `Throw` Animation Montage. Let's fix this by adding the required logic in C++.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open up the header file for the player character in Visual Studio, `SuperSideScroller_Player.h`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The first thing you need to do is create a new variable for the player character
    that will be used for the `Throw` animation. Add the following code under the
    `Private` access modifier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Now that you have a variable that will represent the `Throw` Animation Montage,
    it is time to add the logic for playing the Montage inside the `SuperSideScroller_Player.cpp`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before you can make the call to `UAnimInstance::Montage_Play()`, you need to
    add the following `include` directory to the existing list at the top of the source
    file in order to have access to this function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'As we know from *Chapter 9*, *Audio-Visual Elements*, the player character
    already has a function called `ThrowProjectile` that is called whenever the *left
    mouse button* is pressed. As a reminder, this is where the binding occurs in C++:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Update `ThrowProjectile` so that it plays `ThrowMontage`, which you set up
    earlier in this exercise. Add the following code to the `ThrowProjectile()` function.
    Then, we can discuss what is happening here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The first line is checking if the `ThrowMontage` is valid; if we don't have
    a valid Animation Montage assigned, there is no point in continuing the logic,
    and also it can be dangerous to use a NULL object in further function calls as
    it could result in a crash. Next, we are declaring a new Boolean variable, called
    `bIsMontagePlaying`, that determines whether `ThrowMontage` is already playing
    on the player character's skeletal mesh. This check is made because the `Throw`
    Animation Montage should not be played while it is already playing; this will
    cause the animation to break if the player repeatedly presses the *left mouse button*.
  prefs: []
  type: TYPE_NORMAL
- en: Next, there is an `If` statement that checks that `ThrowMontage` is valid and
    that the Montage is not playing. As long as these conditions are met, it is safe
    to move on and play the Animation Montage.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `If` statement, you are telling the player's skeletal mesh to play
    the `ThrowMontage` Animation Montage with a play rate of `1.0f`. The `1.0f` value
    is used so that the Animation Montage plays back at the speed it is intended to.
    Values larger than `1.0f` will make the Montage play back faster, while values
    lower than `1.0f` will make the Montage play back slower. The other parameters
    that you learned about, such as the start position or the `EMontagePlayReturnType`
    parameter, can be left at their `defaults.Head`. Back inside the Unreal Engine
    4 editor, perform a recompile of the code, as you have done in the past.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After the code recompiles successfully, navigate back to the player character
    blueprint, `BP_SuperSideScroller_MainCharacter`, which can be found in the following
    directory: `/MainCharacter/Blueprints/`. *Double-click* this asset to open it.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `Details` panel of the player character, you will now see the `Throw
    Montage` parameter that you added.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Left-click* on the drop-down menu for the `Throw Montage` parameter to find
    the `AM_Throw` montage. *Left-click* again on the `AM_Throw` option to select
    it for this parameter. Please refer to the following screenshot to see how the
    variable should be set up:![Figure 14.10: Now, the Throw Montage is assigned the
    AM_Throw montage'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_14_10.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 14.10: Now, the Throw Montage is assigned the AM_Throw montage'
  prefs: []
  type: TYPE_NORMAL
- en: 'Recompile and save the player character blueprint. Then, use `PIE` to spawn
    the player character and use the *left mouse button* to play `Throw Montage`.
    The following screenshot shows this in action:![Figure 14.11: The player character
    is now able to perform the Throw animation again'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_14_11.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 14.11: The player character is now able to perform the Throw animation
    again'
  prefs: []
  type: TYPE_NORMAL
- en: By completing this exercise, you have learned how to add an `Animation Montage`
    parameter to the player character, as well as how to play the Montage in C++.
    In addition to playing `Throw` Animation Montage in C++, you also added the ability
    to control how often the `Throw` animation can be played by adding the check for
    whether the Montage is already playing. By doing this, you prevent the player
    from spamming the `Throw` input and causing the animation to break or not play
    entirely.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Try setting the play rate of `Animation Montage` from `1.0f` to `2.0f` and recompile
    the code. Observe how increasing the play rate of the animation affects how the
    animation looks and feels for the player.
  prefs: []
  type: TYPE_NORMAL
- en: Game World and Spawning Objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When it comes to spawning objects into the game world, it is actually the `World`
    object that represents your level that handles the creation of said objects. You
    can think of the `UWorld` class object as the single, top-level object that represents
    your level.
  prefs: []
  type: TYPE_NORMAL
- en: The `UWorld` class can do many things, such as spawning and removing objects
    from the world, detect when levels are being changed or streamed in/out, and even
    perform line traces to assist with inter-object detection. For the sake of this
    chapter, we'll focus on spawning objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `UWorld` class has multiple variations of the `SpawnActor()` function,
    depending on how you want to spawn the object, or by which parameters you have
    access to in the context in which you are spawning this object. The three consistent
    parameters to take into consideration are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`UClass`: The `UClass` parameter is simply the class of the object that you
    want to spawn in.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FActorSpawnParameters`: This is a struct of variables that give the spawned
    object more context and references to what has spawned it. For a list of all of
    the variables included within this struct, please refer to this article from the
    Unreal Engine 4 Community Wiki: https://www.ue4community.wiki/Actor#Spawn'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s briefly discuss one of the more crucial variables included in `FActorSpawnParameters`:
    the `Owner` actor. `Owner` is the actor that has spawned this object, and in the
    case of the player character and the projectile, it will be important for you
    to explicitly reference the player as the owner of the projectile. The reason
    behind this, especially in the context of this game, is that you don''t want the
    projectile to collide with its `Owner`; you want this projectile to ignore the
    owner entirely so that it can only collide with enemies or the level environment.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Transform`: When spawning an object into the world, the world needs to know
    the `location`, `rotation`, and `scale` properties of this actor before it can
    spawn it. In some templates of the `SpawnActor()` function, it requires a full
    `Transform` to be passed, while in other templates, `Location` and `Rotation`
    need to be passed in individually.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before moving on to spawning the player projectile, let's set up the `Socket`
    location in the player character's `Skeleton` so that the projectile can spawn
    from the *players' hand* during the `Throw` animation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 14.04: Creating the Projectile Spawn Socket'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to spawn the player projectile, you need to determine the `Transform`
    in which the projectile will spawn while primarily focusing on `Location` and
    `Rotation`, rather than `Scale`.
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, you will create a new `Socket` on the player character's `Skeleton`
    that you can then reference in code in order to obtain the location from which
    to spawn the projectile.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Inside Unreal Engine 4, navigate to the `Content Browser` interface and find
    the `/MainCharacter/Mesh/` directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this directory, find the `Skeleton` asset; that is, `MainCharacter_Skeleton.uasset`.
    *Double-click* to open this `Skeleton`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To determine the best position for where the projectile should spawn, we need
    to add the `Throw` Animation Montage as the preview animation for the skeleton.
  prefs: []
  type: TYPE_NORMAL
- en: In the `Details` panel, under the `Animation` category, find the `Preview Controller`
    parameter and select the `Use Specific Animation` option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, *left-click* on the drop-down menu to find and select the `AM_Throw` Animation
    Montage from the list of available animations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, the player character''s `Skeleton` will start previewing the `Throw` Animation
    Montage, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.12: The player character previewing the Throw Animation Montage'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_14_12.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 14.12: The player character previewing the Throw Animation Montage'
  prefs: []
  type: TYPE_NORMAL
- en: If you recall from *Exercise 14.02*, *Adding the Notify to the Throw Montage*,
    you added `Anim_ProjectileNotify` at the 22nd frame of the `Throw` animation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the timeline at the bottom of the `Skeleton` editor, move the `red` bar
    to as close to the 22nd frame as you can. Please refer to the following screenshot:![Figure
    14.13: The same 22nd frame in which you added Anim_ProjectileNotify i'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: n an earlier exercise
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_14_13.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 14.13: The same 22nd frame in which you added Anim_ProjectileNotify
    i n an earlier exercise'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the 22nd frame of the `Throw` animation, the player character should look
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.14: At the 22nd frame of the Throw Animation Montage, the character’s
    hand is in position to release a projectile'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_14_14.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 14.14: At the 22nd frame of the Throw Animation Montage, the character''s
    hand is in position to release a projectile'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, the player character will be throwing the projectile from their
    right hand, so the new `Socket` should be attached to the *right hand*. Let''s
    take a look at the skeletal hierarchy of the player character, as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.15: The RightHand bone found within the hierarchy'
  prefs: []
  type: TYPE_NORMAL
- en: of the player character’s skeleton
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_14_15.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 14.15: The RightHand bone found within the hierarchy of the player character''s
    skeleton'
  prefs: []
  type: TYPE_NORMAL
- en: From the skeletal hierarchy, find the `RightHand` bone. This can be found underneath
    the `RightShoulder` bone hierarchy structure.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Right-click* on the `RightHand` bone and *left-click* the `Add Socket` option
    from the list of options that appear. Name this socket `ProjectileSocket`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Also, when adding a new `Socket`, the hierarchy of the entire `RightHand` will
    expand and the new socket will appear at the bottom.
  prefs: []
  type: TYPE_NORMAL
- en: 'With `ProjectileSocket` selected, use the `Transform` widget gizmo to position
    this `Socket` at the following location:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The final result should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.16: The final position of ProjectileSocket at the 22nd frame of
    the Throw Animation in world space.'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_14_16.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 14.16: The final position of ProjectileSocket at the 22nd frame of the
    Throw Animation in world space.'
  prefs: []
  type: TYPE_NORMAL
- en: If your gizmo looks a bit different, that is because the above image shows the
    socket location in world space, not local space.
  prefs: []
  type: TYPE_NORMAL
- en: Now that `ProjectileSocket` is positioned where you want it, save the `MainCharacter_Skeleton`
    asset.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With this exercise complete, you now know the location that the player projectile
    will spawn from. Since you used the `Throw` Animation Montage in the preview,
    and used the same 22nd frame of the animation, you know this position will be
    correct based on when `Anim_ProjectileNotify` will fire.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's move on to actually spawning the player projectile in C++.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 14.05: Preparing the SpawnProjectile() Function'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that you have `ProjectileSocket` in place and there is now a location from
    which to spawn the player projectile, let's add the code necessary to spawn the
    player projectile.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this exercise, you will have the function ready to spawn the projectile
    and it will be ready to call from the `Anim_ProjectileNotify` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: From Visual Studio, navigate to the `SuperSideScroller_Player.h` header file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You need a class reference variable to the `PlayerProjectile` class. You can
    do this using the variable template class type known as `TSubclassOf`. Add the
    following code to the header file, under the `Private` access modifier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Now that you have the variable ready, it is time to declare the function you
    will use to spawn the projectile.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following function declaration under the declaration of the void `ThrowProjectile()`
    function and the `Public` access modifier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Before preparing the definition of the `SpawnProjectile()` function, add the
    following `include` directories to the list of includes in the `SuperSideScroller_Player.cpp`
    source file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: You need to include `PlayerProjectile.h` because it is required in order to
    reference the collision component of the projectile class. Next, use of the `Engine/World.h`
    include is necessary in order to use the `SpawnActor()` function and access the
    `FActorSpawnParameters` struct. Lastly, you need to use the `Components/SphereComponent.h`
    include in order to update the collision component of the player projectile so
    that it will ignore the player.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, create the definition of the `SpawnProjectile()` function at the bottom
    of the `SuperSideScroller_Player.cpp` source file, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The first thing this function needs to do is check whether the `PlayerProjectile`
    class variable is valid. If this object is not valid, there is no point in continuing
    to try and spawn it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `SpawnProjectile()` function so that it looks as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now, if the `PlayerProjectile` object is valid, you'll want to obtain the `UWorld`
    object that the player currently exists in and ensure that this world is valid
    before continuing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `SpawnProjectile()` function to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: At this point, you have made safety checks to ensure that both `PlayerProjectile`
    and `UWorld` are valid, so now it is safe to attempt to spawn the projectile.
    The first thing to do is declare a new variable of the `FactorSpawnParameters`
    type and assign the player as the owner.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code within the most recent `if` statement so that the `SpawnProjectile()`
    function looks like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As you have previously learned, the `SpawnActor()` function call from the `UWorld`
    object will require the `FActorSpawnParameters` struct as part of the spawned
    objects' initialization. In the case of the player projectile, you can use the
    `this` keyword as a reference to the player character class for the owner of the
    projectile. This will come in handy later on in this function when you update
    the collision of the projectile after it spawns.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, you need to handle the `Location` and `Rotation` parameters of the `SpawnActor()`
    function. Add the following lines under the latest line, `SpawnParams.Owner =
    this`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In the first line, you declare a new `FVector` variable called `SpawnLocation`.
    This vector uses the `Socket` location of the `ProjectileSocket` socket that you
    created in the previous exercise. The `Skeletal Mesh` component returned from
    the `GetMesh()` function contains a function called `GetSocketLocation()` that
    will return the location of the socket with the `FName` that is passed in; in
    this case, the name `ProjectileSocket`.
  prefs: []
  type: TYPE_NORMAL
- en: In the second line, you are declaring a new `FRotator` variable called `Rotation`.
    This value is set to the player's forward vector, converted into a `Rotator` container.
    This will ensure that the rotation, or in other words, the direction in which
    the player projectile will spawn, will be in front of the player, and it will
    move away from the player.
  prefs: []
  type: TYPE_NORMAL
- en: Now, all of the parameters required to spawn the projectile are ready.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following line underneath the code from the previous step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `World->SpawnActor()` function will return an object of the class you are
    attempting to spawn in; in this case, `APlayerProjectile`. This is why you are
    adding `APlayerProjectile* Projectile` before the actual spawning occurs. Then,
    you are passing in the `SpawnLocation`, `Rotation`, and `SpawnParams` parameters
    to ensure that the projectile is spawning where and how you want.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you can add the player character to the array of actors to ignore
    on the player projectile by adding the following lines of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Now that you have a reference to the projectile, this line is updating the `CollisionComp`
    component so that the player, or `SpawnParams.Owner`, is added to the `MoveIgnoreActors`
    array. This array of actors will be ignored by the projectile's collision as it
    moves, which is perfect because this projectile should not collide with the player
    that has thrown it.
  prefs: []
  type: TYPE_NORMAL
- en: Return to the editor to recompile the newly added code. After the code compiles
    successfully, this exercise is complete.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With this exercise complete, you now have a function that will spawn the player
    projectile class that is assigned inside the player character. By adding safety
    checks for the validity of both the projectile and the world, you ensure that
    if an object is spawned, it is a valid object inside a valid world.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you set up the appropriate `location`, `rotation`, and `FActorSpawnParameters`
    parameters for the `UWorld SpawnActor()` function to ensure that the player projectile
    spawns at the right location, based on the socket location from the previous exercise,
    with the appropriate direction so that it moves away from the player, and with
    the player character as its `Owner`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, it is time to update the `Anim_ProjectileNotify` source file so that it
    spawns the projectile.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 14.06: Updating the Anim_ProjectileNotify Class'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have the function ready to allow the player projectile to spawn, but you
    aren't calling this function anywhere yet. Back in *Exercise 14.01*, *Creating
    a UAnim Notify Class*, you created the `Anim_ProjectileNotify` class, while in
    *Exercise 14.02*, *Adding the Notify to the Throw Montage*, you added this notify
    to the `Throw` Animation Montage.
  prefs: []
  type: TYPE_NORMAL
- en: Now it is time to update the `Uanim` `Notify` class so that it calls the `SpawnProjectile()`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Do the following to achieve this:'
  prefs: []
  type: TYPE_NORMAL
- en: In Visual Studio, open the `Anim_ProjectileNotify.cpp` source file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the source file, you have the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Remove the `UE_LOG()` line from the `Notify()` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, add the following `include` lines underneath `Anim_ProjectileNotify.h`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: You need to include the `SuperSideScroller_Player.h` header file because it
    is required in order to call the `SpawnProjectile()` function you created in the
    previous exercise. We also included `SkeletalMeshComponent.h` because we will
    reference this component inside the `Notify()` function, so it's best to include
    it here too.
  prefs: []
  type: TYPE_NORMAL
- en: The `Notify()` function passes in a reference to the owning `Skeletal Mesh`,
    labeled `MeshComp`. You can use the skeletal mesh to get a reference to the player
    character by using the `GetOwner()` function and casting the returned actor to
    your `SuperSideScroller_Player` class. We'll do this next.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `Notify()` function, add the following line of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that you have a reference to the player, you need to add a validity check
    of the `Player` variable before making a call to the `SpawnProjectile()` function.
    Add the following lines of code after the line from the previous step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Now that the `SpawnProjectile()` function is being called from the `Notify()`
    function, return to the editor to recompile and hot-reload the code changes you
    have made.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Before you are able to use `PIE` to run around and throw the player projectile,
    you need to assign the `Player Projectile` variable from the previous exercise.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `Content Browser` interface, navigate to the `/MainCharacter/Blueprints`
    directory to find the `BP_SuperSideScroller_MainCharacter` Blueprint. *Double-click*
    to open the Blueprint.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `Details` panel, underneath the `Throw Montage` parameter, you will find
    the `Player Projectile` parameter. *Left-click* the drop-down option for this
    parameter and find `BP_PlayerProjectile`. *Left-click* on this option to assign
    it to the `Player Projectile` variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Recompile and save the `BP_SuperSideScroller_MainCharacter` Blueprint.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, use `PIE` and use the *left mouse button*. The player character will play
    the `Throw` animation and the player projectile will spawn.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Notice that the projectile is spawned from the `ProjectileSocket` function
    you created and that it moves away from the player. The following screenshot shows
    this in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.17: The player can now throw the player projectile'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_14_17.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 14.17: The player can now throw the player projectile'
  prefs: []
  type: TYPE_NORMAL
- en: With this exercise complete, the player can now throw the player projectile.
    The player projectile, in its current state, is ineffective against enemies and
    just flies through the air. It took a lot of moving parts between the `Throw`
    Animation Montage, the `Anim_ProjectileNotify` class, and the player character
    to get the player to throw the projectile.
  prefs: []
  type: TYPE_NORMAL
- en: In the upcoming exercises, you will update the player projectile so that it
    destroys enemies and play additional effects such as particles and sound.
  prefs: []
  type: TYPE_NORMAL
- en: Destroying Actors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far in this chapter, we have put a lot of focus on spawning, or creating,
    actors inside the game world; the player character uses the `UWorld` class in
    order to spawn the projectile. Unreal Engine 4 and its base `Actor` class come
    with a default function that you can use to destroy, or remove, an actor from
    the game world:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: You can find the full implementation of this function in Visual Studio by finding
    the `Actor.cpp` source file in the `/Source/Runtime/Engine/Actor.cpp` directory.
    This function exists in all the classes that extend from the `Actor` class, and
    in the case of Unreal Engine 4, it exists in all classes that can be spawned,
    or placed, inside the game world. To be more explicit, both the `EnemyBase` and
    `PlayerProjectile` classes are *children* of the `Actor` class, and therefore,
    can be destroyed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking further into the `AActor::Destroy()` function, you will find the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We will not be going into further detail about what exactly the `UWorld` class
    does in order to destroy an actor, but it is important to emphasize the fact that
    the `UWorld` class is responsible for both the creation and destruction of actors
    inside the world. Feel free to dig deeper into the source engine code to find
    more information about how the `UWorld` class handles the destruction and spawning
    of actors.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have more context regarding how Unreal Engine 4 handles the destruction
    and removal of actors from the game world, we'll implement this ourselves for
    the enemy character.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 14.07: Creating the DestroyEnemy() Function'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The main part of the gameplay for the `Super SideScroller` game is for the player
    to move around the level and use the projectile to destroy enemies. At this point
    in the project, you have handled the player movement and spawning the player projectile.
    However, the projectile does not destroy enemies yet.
  prefs: []
  type: TYPE_NORMAL
- en: In order to get this functionality in place, we'll start by adding some logic
    to the `EnemyBase` class so that it knows how to handle its destruction and remove
    it from the game once it collides with the player projectile.
  prefs: []
  type: TYPE_NORMAL
- en: 'Complete the following steps to achieve this:'
  prefs: []
  type: TYPE_NORMAL
- en: First, navigate to Visual Studio and open the `EnemyBase.h` header file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the header file, create the declaration of a new function called `DestroyEnemy()`
    under the `Public` access modifier, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Make sure this function definition is written underneath `GENERATED_BODY()`,
    within the class definition.
  prefs: []
  type: TYPE_NORMAL
- en: Save these changes to the header file and open the `EnemyBase.cpp` source file
    in order to add the implementation of this function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Below the `#include` lines, add the following function definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: For now, this function will be very simple. All you need to do is call the inherited
    `Destroy()` function from the base `Actor` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `DestroyEnemy()` function so that it looks like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: With this function complete, save the source file and return to the editor so
    that you can recompile and hot-reload the code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With this exercise complete, the enemy character now has a function that can
    easily handle the destruction of the actor whenever you choose. The `DestroyEnemy()`
    function is publicly accessible so that it can be called by other classes, which
    will come in handy later when you handle the destruction of the player projectile.
  prefs: []
  type: TYPE_NORMAL
- en: The reason you're creating your own unique function to destroy the enemy actor
    is because you will use this function later in this chapter to add VFX and SFX
    to the enemy when they are destroyed by the player projectile.
  prefs: []
  type: TYPE_NORMAL
- en: Before moving on to the polishing elements of the enemy's destruction, let's
    implement a similar function inside the player projectile class so that it can
    also be destroyed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 14.08: Destroying Projectiles'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that the enemy characters can handle being destroyed through the new `DestroyEnemy()`
    function you implemented in the previous exercise, it is time to do the same for
    the player projectile.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this exercise, the player projectile will have its own unique
    function to handle its own destruction and removal from the game world.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: In Visual Studio, open the header file for the player projectile; that is, `PlayerProjectile.h`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Under the `Public` access modifier, add the following function declaration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Next, open the source file for the player projectile; that is, `PlayerProjectile.cpp`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Underneath the void `APlayerProjectile::OnHit` function, add the definition
    of the `ExplodeProjectile()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: For now, this function will work identically to the `DestroyEnemy()` function
    from the previous exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the inherited `Destroy()` function to the new `ExplodeProjectile()` function,
    like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: With this function complete, save the source file and return to the editor so
    that you can recompile and hot-reload the code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With this exercise complete, the player projectile now has a function that can
    easily handle the destruction of the actor whenever you choose. The reason you
    need to create your own unique function to handle destroying the player projectile
    actor is the same reason you created the `DestroyEnemy()` function – you will
    use this function later in this chapter to add VFX and SFX to the player projectile
    when it collides with another actor.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have experience with implementing the `Destroy()` function inside
    both the player projectile and the enemy character, it is time to put these two
    elements together.
  prefs: []
  type: TYPE_NORMAL
- en: In the next activity, you will enable the player projectile in order to destroy
    the enemy character when they collide.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 14.01: Projectile Destroying Enemies'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that both the player projectile and the enemy character can handle being
    destroyed, it is time to go the extra step and allow the player projectile to
    destroy the enemy character when they collide.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps to achieve this:'
  prefs: []
  type: TYPE_NORMAL
- en: Add the `#include` statement for the `EnemyBase.h` header file toward the top
    of the `PlayerProjectile.cpp` source file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Within the void `APlayerProjectile::OnHit()` function, create a new variable
    of the `AEnemyBase*` type and call this variable `Enemy`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Cast the `OtherActor` parameter of the `APlayerProjectile::OnHit()` function
    to the `AEnemyBase*` class and set the `Enemy` variable to the result of this
    cast.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use an `if()` statement to check the validity of the `Enemy` variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the `Enemy` is valid, call the `DestroyEnemy()` function from this `Enemy`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After the `if()` block, make a call to the `ExplodeProjectile()` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the changes to the source file and return to the Unreal Engine 4 editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use `PIE` and then use the player projectile against an enemy to observe the results.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The expected output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.18: The player throwing the projectile'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_14_18.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 14.18: The player throwing the projectile'
  prefs: []
  type: TYPE_NORMAL
- en: 'As the projectile hits the enemy, the enemy character is destroyed, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.19: The projectile and enemy destroyed'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_14_19.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 14.19: The projectile and enemy destroyed'
  prefs: []
  type: TYPE_NORMAL
- en: With this activity complete, the player projectile and the enemy character can
    be destroyed when they collide with each other. Additionally, the player projectile
    will be destroyed whenever another actor triggers its `APlayerProjectile::OnHit()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'With that, a major element of the `Super SideScroller` game has been completed:
    the player projectile spawning and the enemies being destroyed when they collide
    with the projectile. You can observe that destroying these actors is very simple
    and not very interesting to the player.'
  prefs: []
  type: TYPE_NORMAL
- en: This is why, in the upcoming exercises in this chapter, you will learn more
    about Visual and Audio Effects, or VFX and SFX, respectively. You will also implement
    these elements with regard to the enemy character and player projectile.
  prefs: []
  type: TYPE_NORMAL
- en: Now that both the enemy character and the player projectile can be destroyed,
    let's briefly discuss what VFX and SFX are, and how they will impact the project.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution to this activity can be found at: [https://packt.live/338jEBx](https://packt.live/338jEBx).'
  prefs: []
  type: TYPE_NORMAL
- en: Visual and Audio Effects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Visual Effects such as particle systems and sound effects such as Sound Cues
    play an important role in video games. They add a level of polish on top of systems,
    game mechanics, and even basic actions that make these elements more interesting
    or more pleasing to perform.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by understanding Visual Effects, followed by Audio Effects.
  prefs: []
  type: TYPE_NORMAL
- en: '**Visual Effects (VFX)**'
  prefs: []
  type: TYPE_NORMAL
- en: Visual Effects, in the context of Unreal Engine 4, are made up of what's called
    **Particle Systems**. Particle systems are made up of emitters, and emitters are
    comprised of modules. In these modules, you can control the appearance and behaviors
    of the emitter using materials, meshes, and mathematical modules. The end result
    can be anything from a fire torch, or snow falling, to rain, dust, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'You can learn more here: [https://docs.unrealengine.com/en-US/Resources/Showcases/Effects/index.html](https://docs.unrealengine.com/en-US/Resources/Showcases/Effects/index.html).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Audio Effects (SFX)**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Audio Effects, in the context of Unreal Engine 4, are made up of a combination
    of Sound Waves and Sound Cues:'
  prefs: []
  type: TYPE_NORMAL
- en: Sound Waves are `.wav` audio format files that can be imported into Unreal Engine
    4.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sound Cues combine Sound Wave audio files with other nodes such as Oscillator,
    Modulator, and Concatenator to create unique and complex sounds for your game.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'You can learn more here: [https://docs.unrealengine.com/en-US/Engine/Audio/SoundCues/NodeReference/index.html](https://docs.unrealengine.com/en-US/Engine/Audio/SoundCues/NodeReference/index.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Let's use the game *Portal 2*, developed by Valve, as an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Portal 2*, the player uses a portal gun to fire two portals: one *orange*
    and one *blue*. These portals allow the player to travel across gaps, move objects
    from one location to another, and utilize other simple mechanics that layer on
    top of each other to create complex puzzles. The use of these portals, the sound
    effects for firing the portals, and the visual VFX of these portals make the game
    more enjoyable to play. If you are unfamiliar with the game, please watch the
    full walkthrough here: [https://www.youtube.com/watch?v=ZFqk8aj4-PA](https://www.youtube.com/watch?v=ZFqk8aj4-PA).'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'For further reading regarding the importance of sound and sound design, please
    refer to the following Gamasutra article: [https://www.gamasutra.com/view/news/318157/7_games_worth_studying_for_their_excellent_sound_design.php](https://www.gamasutra.com/view/news/318157/7_games_worth_studying_for_their_excellent_sound_design.php).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the context of Unreal Engine 4, VFX were originally created using a tool
    called `materials`, `static meshes`, and `math` to create interesting and convincing
    effects for the game world. This book will not dive into how this tool works,
    but you can find information about Cascade here: [https://www.ue4community.wiki/Legacy/Introduction_to_Particles_in_UE4_-_2_-_Cascade_at_a_Glance](https://www.ue4community.wiki/Legacy/Introduction_to_Particles_in_UE4_-_2_-_Cascade_at_a_Glance).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In more recent versions of the engine, starting in the 4.20 update, there is
    a plugin called `Niagara`, unlike Cascade, uses a system similar to Blueprints
    where you can visually script the behaviors of the effect rather than use a preset
    of modules with pre-defined behavior. You can find more information about Niagara
    here: [https://docs.unrealengine.com/en-US/Engine/Niagara/Overview/index.html](https://docs.unrealengine.com/en-US/Engine/Niagara/Overview/index.html).'
  prefs: []
  type: TYPE_NORMAL
- en: In *Chapter 9*, *Audio-Visual Elements*, you learned more about audio and how
    audio is handled inside Unreal Engine 4\. All that needs to be known right now
    is that Unreal Engine 4 uses the `.wav` file format to import audio into the engine.
    From there, you can use the `.wav` file directly, referred to as Sound Waves in
    the editor, or you can convert these assets into Sound Cues, which allow you to
    add Audio Effects on top of the sound wave.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, there is one important class to know about that you will be referencing
    in the upcoming exercises, and this class is called `UGameplayStatics`. This is
    a static class featured in Unreal Engine that can be used from both C++ and Blueprints,
    and it offers a variety of useful gameplay-related functions. The two functions
    you will be working with in the upcoming exercise are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: These two functions work in very similar ways; they both require a `World` context
    object in which to spawn the effect, the particle system or audio to spawn, and
    the location in which to spawn the effect. You will be using these functions to
    spawn the destroy effects for the enemy in the next exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 14.09: Adding Effects When the Enemy Is Destroyed'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, you will add new content to the project that comes included
    with this chapter and exercise. This includes the particle VFX and sound SFX,
    and all of their required assets. Then, you will update the `EnemyBase` class
    so that it can use audio and particle system parameters to add the layer of polish
    needed when the enemy is destroyed by the player projectile.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this exercise, you will have an enemy that is visually and audibly
    destroyed when it collides with the player projectile.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: To begin, we need to migrate specific assets from the `Action RPG` project,
    which can be found in the `Learn` tab of `Unreal Engine Launcher`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From `Epic Games Launcher`, navigate to the `Learn` tab and, under the `Games`
    category, you will find `Action RPG`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You will be taking additional assets from the Action RPG project in later exercises
    of this chapter, so you should keep this project open so as to avoid redundant
    opening of the project.
  prefs: []
  type: TYPE_NORMAL
- en: Left-click the `Action RPG` game project and then left-click the `Create Project`
    option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From here, select engine version 4.24 and choose which directory to download
    the project to. Then, *left-click* the `Create` button to start installing the
    project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the `Action RPG` project has finished downloading, navigate to the `Library`
    tab of `Epic Games Launcher` to find `ActionRPG` under the `My Projects` section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Double-click* the `ActionRPG` project to open it in the Unreal Engine editor.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the editor, find the `A_Guardian_Death_Cue` audio asset in the `Content Browser`
    interface. *Right-click* this asset and select `Asset Actions` and then `Migrate`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After selecting `Migrate`, you will be presented with all the assets that are
    referenced in `A_Guardian_Death_Cue`. This includes all audio classes and sound
    wave files. Choose `OK` from the `Asset Report` dialogue window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, you will need to navigate to the `Content` folder for your `Super SideScroller`
    project and *left-click* `Select Folder`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the migration process is complete, you will be given a notification in
    the editor saying that the migration was completed successfully.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Do the same migration steps for the `P_Goblin_Death` VFX asset. The two primary
    assets you are adding to the project are as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The `P_Goblin_Death` particle system asset references additional assets such
    as materials and textures that are included in the `Effects` directory, while
    `A_Guardian_Death_Cue` references additional sound wave assets included in the
    `Assets` directory.
  prefs: []
  type: TYPE_NORMAL
- en: After migrating these folders into your `Content` directory, open the Unreal
    Engine 4 editor of your `SuperSideScroller` project to find the new folders included
    in your project's `Content Browser`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The particle you will be using for the enemy character's destruction is called
    `P_Goblin_Death` and can be found in the `/Effects/FX_Particle/` directory. The
    sound you will be using for the enemy character's destruction is called `A_Guardian_Death_Cue`
    and can be found in the `/Assets/Sounds/Creatures/Guardian/` directory. Now that
    the assets you need have been imported into the editor, let's move on to the code.
  prefs: []
  type: TYPE_NORMAL
- en: Open Visual Studio and navigate to the header file for the enemy base class;
    that is, `EnemyBase.h`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following `UPROPERTY()` variable. This will represent the particle
    system for when the enemy is destroyed. Make sure this is declared under the `Public`
    access modifier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following `UPROPERTY()` variable. This will represent the sound for
    when the enemy is destroyed. Make sure this is declared under the `Public` access
    modifier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: With these two properties defined, let's move on and add the logic required
    to spawn and use these effects for when the enemy is destroyed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the source file for the enemy base class, `EnemyBase.cpp`, add the following
    includes for the `UGameplayStatics` and `UWorld` classes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: You will be using the `UGameplayStatics` and `UWorld` classes to spawn the sound
    and particle system into the world when the enemy is destroyed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within the `AEnemyBase::DestroyEnemy()` function, you have one line of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following line of code above the `Destroy()` function call:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: It is necessary to define the `UWorld` object before attempting to spawn a particle
    system or sound because a `World` context object is required.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, use an `if()` statement to check the validity of the `World` object you
    just defined:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Within the `if()` block, add the following code to check the validity of the
    `DeathEffect` property, and then spawn this effect using the `SpawnEmitterAtLocation`
    function from `UGameplayStatics`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: It cannot be emphasized enough that you should ensure an object is valid before
    attempting to spawn or manipulate the object. By doing so, you can avoid engine crashes.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the `if(DeathEffect)` block, perform the same validity check of the `DeathSound`
    property and then spawn the sound using the `UGameplayStatics::SpawnSoundAtLocation`
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Before calling the `Destroy()` function, you need to make checks regarding whether
    both the `DeathEffect` and `DeathSound` properties are valid, and if so, spawn
    those effects using the proper `UGameplayStatics` function. This ensures that
    regardless of whether either property is valid, the enemy character will still
    be destroyed.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the `AEnemyBase::DestroyEnemy()` function has been updated to spawn
    these effects, return to the Unreal Engine 4 editor to compile and hot-reload
    these code changes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Within the `Content Browser` interface, navigate to the `/Enemy/Blueprints/`
    directory. *Double-click* the `BP_Enemy` asset to open it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `Details` panel of the enemy Blueprint, you will find the `Death Effect`
    and `Death Sound` properties. *Left-click* on the drop-down list for the `Death
    Effect` property and find the `P_Goblin_Death` particle system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, underneath the `Death Effect` parameter, *left-click* on the drop-down
    list for the `Death Sound` property and find the `A_Guardian_Death_Cue` Sound
    Cue.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that these parameters have been updated and assigned the correct effect,
    compile and save the enemy Blueprint.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Using `PIE`, spawn the player character and throw a player projectile at an
    enemy. If an enemy is not present in your level, please add one. When the player
    projectile collides with the enemy, the VFX and SFX you added will play, as shown
    in the following screenshot:![Figure 14.20: Now, the enemy explodes and gets destroyed
    in a blaze of glory'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_14_20.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 14.20: Now, the enemy explodes and gets destroyed in a blaze of glory'
  prefs: []
  type: TYPE_NORMAL
- en: With this exercise complete, the enemy character now plays a particle system
    and a Sound Cue when it is destroyed by the player projectile. This adds a nice
    layer of polish to the game, and it makes it more satisfying to destroy the enemies.
  prefs: []
  type: TYPE_NORMAL
- en: In the next exercise, you will add a new particle system and audio components
    to the player projectile so that it looks and sounds more interesting while it
    flies through the air.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 14.10: Adding Effects to the Player Projectile'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In its current state, the player projectile functions the way it is intended
    to; it flies through the air, collides with objects in the game world, and is
    destroyed. However, visually, the player projectile is just a ball with a plain
    white texture.
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, you will add a layer of polish to the player projectile by
    adding both a particle system and an audio component so that the projectile is
    more enjoyable to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Complete the following steps to achieve this:'
  prefs: []
  type: TYPE_NORMAL
- en: Much like the previous exercises, we will need to migrate assets from the `Action
    RPG` project to our `Super SideScroller` project. Please refer to *Exercise 14.09*,
    *Adding Effects When the Enemy Is Destroyed*, on how to install and migrate assets
    from the `Action RPG` project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The two primary assets you are adding to the project are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The `P_Env_Fire_Grate_01` particle system asset references additional assets,
    such as materials and textures, that are included in the `Effects` directory,
    while `A_Ambient_Fire01_Cue` references additional sound wave and sound attenuation
    assets included in the `Assets` directory.
  prefs: []
  type: TYPE_NORMAL
- en: The particle you will be using for the player projectile is called `P_Env_Fire_Grate_01`
    and can be found in the `/Effects/FX_Particle/` directory. This is the same directory
    that's used by the `P_Goblin_Death` VFX from the previous exercise. The sound
    you will be using for the player projectile is called `A_Ambient_Fire01_Cue` and
    can be found in the `/Assets/Sounds/Ambient/` directory.
  prefs: []
  type: TYPE_NORMAL
- en: '*Right-click* on each of these assets in the `Content Browser` interface of
    the `Action RPG` project and select `Asset Actions` and then `Migrate`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure to choose the directory of the `Content` folder for your `Super SideScroller`
    project before confirming the migration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that the required assets have been migrated to our project, let's continue
    creating the player projectile class.
  prefs: []
  type: TYPE_NORMAL
- en: Open Visual Studio and navigate to the header file for the player projectile
    class; that is, `PlayerProjectile.h`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Under the `Private` access modifier, underneath the declaration of the `UStaticMeshComponent*
    MeshComp` class component, add the following code to declare a new audio component
    for the player projectile:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, add the following code underneath the declaration of the audio component
    in order to declare a new particle system component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Instead of using properties that can be defined within the Blueprint, such as
    in the enemy character class, these effects will be components of the player projectile.
    This is because these effects should be attached to the collision component of
    the projectile so that they move with the projectile as it travels across the
    level when thrown.
  prefs: []
  type: TYPE_NORMAL
- en: 'With these two components declared in the header file, open the source file
    for the player projectile and add the following includes to the list of `include`
    lines at the top of the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: You need a reference to both the audio component and the particle system classes
    in order to create these sub-objects using the `CreateDefaultSubobject` function,
    and to attach these components to `RootComponent`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following lines in order to create the default sub-object of the `ProjectileMovementSound`
    component, and to attach this component to `RootComponent`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, add the following lines in order to create the default sub-object for
    the `ProjectileEffect` component, and to attach this component to `RootComponent`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Now that you have created, initialized, and attached these two components to
    `RootComponent`, return to the Unreal Engine 4 editor to recompile and hot-reload
    these code changes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the `Content Browser` interface, navigate to the `/MainCharacter/Projectile/`
    directory. Find the `BP_PlayerProjectile` asset and *double-click* it to open
    the Blueprint.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `Components` tab, you will find the two new components you added using
    the preceding code. Observe that these components are attached to the `CollisionComp`
    component, also known as `RootComponent`.
  prefs: []
  type: TYPE_NORMAL
- en: '*Left-click* to select the `ProjectileEffect` component and, within the `Details`
    panel, assign the `P_Env_Fire_Grate_01` VFX asset to this parameter, as shown
    in the following screenshot:![Figure 14.21: Now, you can apply the P_Env_fire_Grate_01
    VFX asset to the'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Particle System component you added earlier
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_14_21.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 14.21: Now, you can apply the P_Env_fire_Grate_01 VFX asset to the Particle
    System component you added earlier'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before assigning the audio component, let''s adjust the `Transform` of the
    `ProjectileEffect` VFX asset. Update the `Rotation` and `Scale` parameters of
    the `Transform` for the VFX so that they match what is shown in the following screenshot:![Figure
    14.22: The updated Transform of the particle system component'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: so that it fits better with the projectile
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_14_22.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 14.22: The updated Transform of the particle system component so that
    it fits better with the projectile'
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to the `Viewport` tab within the Blueprint to view these changes to
    the `Transform`. `ProjectileEffect` should look as follows:![Figure 14.23: Now,
    the fire VFX has been scaled and rotated appropriately'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_14_23.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 14.23: Now, the fire VFX has been scaled and rotated appropriately'
  prefs: []
  type: TYPE_NORMAL
- en: Now that the VFX has been set up, *left-click* the `ProjectileMovementSound`
    component and assign `A_Ambient_Fire01_Cue` to this component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Save and recompile the `BP_PlayerProjectile` Blueprint. Use `PIE` and observe
    that when you throw the projectile, it now shows the VFX asset and plays the assigned
    sound:![Figure 14.24: The player projectile now has a VFX and an SFX as it flies
    through the air'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_14_24.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 14.24: The player projectile now has a VFX and an SFX as it flies through
    the air'
  prefs: []
  type: TYPE_NORMAL
- en: With this exercise complete, the player projectile now has a VFX and an SFX
    that play together while it flies through the air. These elements bring the projectile
    to life and make the projectile much more interesting to use.
  prefs: []
  type: TYPE_NORMAL
- en: Since the VFX and SFX are created as components of the projectile, they are
    also destroyed when the projectile is destroyed.
  prefs: []
  type: TYPE_NORMAL
- en: In the next exercise, you will add a particle notify and a sound notify to the
    `Throw` Animation Montage in order to provide more of an impact when the player
    throws the player projectile.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 14.11: Adding VFX and SFX Notifies'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, you have been implementing polish elements to the game via C++, which
    is a valid means of implementation. In order to give variety, and to expand your
    knowledge of the Unreal Engine 4 toolset, this exercise will walk you through
    how to use notifies in Animation Montages to add particle systems and audio within
    the animation. Let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: 'Much like the previous exercises, we will need to migrate assets from the `Action
    RPG` project to our `Super SideScroller` project. Please refer to *Exercise 14.09*,
    *Adding Effects When the Enemy Is Destroyed*, to learn how to install and migrate
    assets from the `Action RPG` project. Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `ActionRPG` project and navigate to the `Content Browser` interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The two primary assets you are adding to the project are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The `P_Skill_001` particle system asset references additional assets such as
    *materials* and *textures* that are included in the `Effects` directory, while
    `A_Ability_FireballCast_Cue` references additional *sound wave* assets included
    in the `Assets` directory.
  prefs: []
  type: TYPE_NORMAL
- en: The particle you will be using for the player when the projectile is thrown
    is called `P_Skill_001` and can be found in the `/Effects/FX_Particle/` directory.
    This is the same directory used by the `P_Goblin_Death` and `P_Env_Fire_Grate_01`
    VFX assets from the previous exercises. The sound you will be using for the enemy
    character destruction is called `A_Ambient_Fire01_Cue` and can be found in the
    `/Assets/Sounds/Ambient/` directory.
  prefs: []
  type: TYPE_NORMAL
- en: '*Right-click* on each of these assets in the `Content Browser` interface of
    the `Action RPG` project and select `Asset Actions` and then `Migrate`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure to choose the directory of the `Content` folder for your `Super SideScroller`
    project before confirming the migration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that the assets you need have been migrated into your project, let's move
    on to adding the required notifies to the `AM_Throw` asset. Make sure to return
    to your `Super SideScroller` project before continuing with this exercise.
  prefs: []
  type: TYPE_NORMAL
- en: From the `Content Browser` interface, navigate to the `/MainCharacter/Animation/`
    directory. Find the `AM_Throw` asset and *double-click* it to open it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Underneath the preview window in the center of the `Animation Montage` editor,
    find the `Notifies` section. This is the same section where you added `Anim_ProjectileNotify`
    earlier in this chapter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To the right of the `Notifies` track, you will find a `+` sign that allows
    you to use additional notify tracks. *Left-click* to add a new track, as shown
    in the following screenshot:![Figure 14.25: It is useful to add multiple tracks
    to the timeline in order to keep things organized when adding multiple notifies'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_14_25.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 14.25: It is useful to add multiple tracks to the timeline in order
    to keep things organized when adding multiple notifies'
  prefs: []
  type: TYPE_NORMAL
- en: In the same frame as `Anim_ProjectileNotify`, *right-click* within the new track
    you created in the previous step. From the `Add Notify` list, *left-click* to
    select `Play Particle Effect`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once created, *left-click* to select the new notify and access its `Details`
    panel. In `Details`, add the `P_Skill_001` VFX asset to the `Particle System` parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After you''ve added this new VFX, you will notice that the VFX is placed almost
    toward the bottom, where the player characters'' feet are, but not exactly where
    you want it. This VFX should be placed directly on the floor, or at the base of
    the character. The following screenshot demonstrates this location:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.26: The location of the particle notify is not on the ground'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_14_26.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 14.26: The location of the particle notify is not on the ground'
  prefs: []
  type: TYPE_NORMAL
- en: In order to fix this, you need to add a new `Socket` to the player character skeleton.
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to the `/MainCharacter/Mesh/` directory. *Double-click* the `MainCharacter_Skeleton`
    asset to open it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the `Skeleton` bone hierarchy on the left-hand side, *right-click* on the
    `Hips` bone and *left-click* to select the `Add Socket` option. Name this new
    socket `EffectSocket`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Left-click* this socket from the hierarchy of bones in order to view its current
    location. By default, its location is set to the same position as the `Hips` bone.
    The following screenshot shows this location:![Figure 14.27: The default location
    of this socket is in the center of the player skeleton'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_14_27.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'This position will be closer to the ground and the player characters'' feet.
    The final location can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.28: Moving the socket location to the base of the player skeleton'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_14_28.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 14.28: Moving the socket location to the base of the player skeleton'
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have a location for the particle notify, return to the `AM_Throw`
    Animation Montage.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Within the `Details` panel of the `Play Particle Effect` notify, there is the
    `Socket Name` parameter. Use `EffectSocket` as the name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If `EffectSocket` does not appear via the autocomplete, close and reopen the
    Animation Montage. Once reopened, the `EffectSocket` option should appear for
    you.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, the scale of the particle effect is a little too big, so adjust the
    scale of the projectile so that its value is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when the particle effect is played via this notify, its position and scale
    will be correct, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.29: The particle now plays at the base of the player character
    skeleton'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_14_29.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 14.29: The particle now plays at the base of the player character skeleton'
  prefs: []
  type: TYPE_NORMAL
- en: To add the `Play Sound` notify, add a new track to the `Notifies` timeline section;
    you should now have three in total.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'On this new track, and at the same frame position as both the `Play Particle
    Effect` and `Anim_ProjectileNotify` notifies, *right-click* and select the `Play
    Sound` notify from the `Add Notify` selection. The following screenshot shows
    where to find this notify:![Figure 14.30: The Play Sound notify that you learned
    about earlier in this chapter'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_14_30.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 14.30: The Play Sound notify that you learned about earlier in this
    chapter'
  prefs: []
  type: TYPE_NORMAL
- en: Next, *left-click* to select the `Play Sound` notify and access its `Details`
    panel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the `Details` panel, find the `Sound` parameter and assign `A_Ability_FireballCast_Cue`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With the sound assigned, when the `Throw` animation is played back, you will
    see the VFX play and you will hear the sound. The `Notifies` tracks should look
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.31: The final notify set up on the Throw Animation Montage timeline'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_14_31.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 14.31: The final notify set up on the Throw Animation Montage timeline'
  prefs: []
  type: TYPE_NORMAL
- en: Save the `AM_Throw` asset and use `PIE` to throw the player projectile.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, when you throw the projectile, you will see the particle notify play the
    `P_Skill_001` VFX and you will hear the `A_Ability_FireballCast_Cue` SFX. The
    result will look as follows:![Figure 14.32: Now, when the player throws the projectile,
    powerful VFX and SFX are played'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_14_32.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 14.32: Now, when the player throws the projectile, powerful VFX and
    SFX are played'
  prefs: []
  type: TYPE_NORMAL
- en: With this final exercise complete, the player now plays powerful VFX and SFX
    when the player projectile is thrown. This gives the throw animation more power
    and it feels like the player character is using a lot of energy to throw the projectile.
  prefs: []
  type: TYPE_NORMAL
- en: In the following final activity, you will use the knowledge you've gained from
    the last few exercises to add VFX and SFX to the player projectile when it is
    destroyed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 14.02: Adding Effects for When the Projectile Is Destroyed'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this final activity, you will use the knowledge that you've gained from adding
    VFX and SFX elements to the player projectile and the enemy character to create
    an explosion effect for when the projectile collides with an object instead. The
    reason we're adding this additional explosion effect is to add a level of polish
    on top of destroying the projectile when it collides with environment objects.
    It would look awkward and out of place if the player projectile were to hit an
    object and disappear without any audio or visual feedback from the player.
  prefs: []
  type: TYPE_NORMAL
- en: You will add both a particle system and Sound Cue parameters to the player projectile
    and spawn these elements when the projectile collides with an object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps to achieve the expected output:'
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `PlayerProjectile.h` header file, add a new particle system variable
    and a new sound base variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the particle system variable `DestroyEffect` and name the sound base variable
    `DestroySound`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `PlayerProjectile.cpp` source file, add the include for `UGameplayStatics`
    to the list of includes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update the `APlayerProjectile::ExplodeProjectile()` function so that it now
    spawns both the `DestroyEffect` and `DestroySound` objects. Return to the Unreal
    Engine 4 editor and recompile the new C++ code. Inside the `BP_PlayerProjectile`
    Blueprint, assign the `P_Explosion` VFX, which is already included in your project
    by default, to the `Destroy Effect` parameter of the projectile.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assign the `Explosion_Cue` SFX, which is already included in your project by
    default, to the `Destroy Sound` parameter of the projectile.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save and compile the player projectile Blueprint.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use `PIE` to observe the new player projectile's destruction VFX and SFX.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The expected output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.33: Projectile VFX and SFX'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_14_33.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 14.33: Projectile VFX and SFX'
  prefs: []
  type: TYPE_NORMAL
- en: With this activity complete, you now have experience with adding polish elements
    to the game. Not only have you added these elements through C++ code, but you've
    added elements through other tools from Unreal Engine 4\. At this point, you have
    enough experience to add particle systems and audio to your game without having
    to worry about how to implement these features.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution to this activity can be found at: [https://packt.live/338jEBx](https://packt.live/338jEBx).'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned a lot about the importance of Visual and Audio
    Effects in the world of game development. Using a combination of C++ code and
    notifies, you were able to bring gameplay functionality to the player projectile
    and the enemy character colliding, as well as a layer of polish to this functionality
    by adding VFX and SFX. On top of this, you learned about how objects are spawned
    and destroyed in Unreal Engine 4.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, you learned about how Animation Montages are played, both from Blueprints
    and through C++. By migrating the logic of playing the `Throw` Animation Montage
    from Blueprint to C++, you learned how both methods work and how to use both implementations
    for your game.
  prefs: []
  type: TYPE_NORMAL
- en: By adding a new Animation Notify using C++, you were able to add this notify
    to the `Throw` Animation Montage, which allows the player to spawn the player
    projectile you created in the previous chapter. Through the use of the `UWorld->SpawnActor()`
    function, and adding a new socket to the player skeleton, you were able to spawn
    the player projectile at the exact frame of the `Throw` animation, and at the
    exact position that you wanted to.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, you learned how to use the `Play Particle Effect` and `Play Sound` notifies
    within the Throw Animation Montage to add VFX and SFX to the throw of the player
    projectile. This chapter has given you the opportunity to learn about the different
    methods that exist inside Unreal Engine 4 when it comes to using VFX and SFX for
    your game.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the player projectile can be thrown and destroy enemy characters, it
    is time to implement the final set of mechanics for the game. In the next chapter,
    you will create the collectibles that the player can collect, and you will also
    create a powerup for the player that will improve the players' movement mechanics
    for a short period of time.
  prefs: []
  type: TYPE_NORMAL
