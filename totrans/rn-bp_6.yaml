- en: Messaging App
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One-to-one communication is the main use for mobile phones although, text messaging
    has been quickly replaced by direct messaging apps. In this chapter, we will build
    a messaging app in React Native with the support of Firebase, a mobile backend
    as a service that will free us from having to build a whole backend for our app.
    Instead, we will focus on handling the state of our app fully from the frontend.
    Of course, this may have security implications that need to be eventually tackled,
    but to keep the focus of this book on React Native's capabilities, we will stick
    with the approach of keeping all the logic inside our app.
  prefs: []
  type: TYPE_NORMAL
- en: Firebase is a real-time database built on self-synching collections of data,
    it plays very well with MobX, so we will use it again for controlling the state
    of our app. But in this chapter, we will dive deeper as we will build larger data
    stores, which will be injected in our component tree through the `mobx-react`
    connectors.
  prefs: []
  type: TYPE_NORMAL
- en: We will build the app to be used both with iOS and Android having some platform-specific
    code for navigation (we will use tabbed navigation for iOS and drawer navigation
    for Android).
  prefs: []
  type: TYPE_NORMAL
- en: To reduce the size of the code, in this chapter, we will set the focus on functionality
    rather than design. Most of the user interface will be plain and simple, but trying
    to keep usability in mind. Moreover, we will use a `react-native-gifted` chat
    for our chat screen--a pre-built React Native component to render chat rooms based
    on a list of messages.
  prefs: []
  type: TYPE_NORMAL
- en: Overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A messaging app requires more work than the apps we reviewed in previous chapters,
    as it needs a user management system comprising of logging in, registering, and
    logging out. We will reduce the complexity of building this system using Firebase
    as a backend. Together with its user management system, we will use their push
    notifications system to notify users when new messages are sent to them. Firebase
    also gives an analytics platform, a lambda functions service, and a storage system
    for free, but the feature we will take the most profit from is their real-time
    database. We will store our user's profile, messages, and chats data there.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at what our app will look like to have a mental image of
    the screens we will be building:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/7328e6c2-0078-4b7b-bcfa-e96e749a29da.png)'
  prefs: []
  type: TYPE_IMG
- en: 'First screen will be a login/registration screen because we need our users
    to provide a name and some credentials to attach their device to a specific account,
    so they can receive push notifications for each message they need to receive.
    Both authentication methods are validated using Firebase''s API and would result
    in the chats screen when they are successful:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/a525bb6f-9022-4004-b99a-c726f0fc082f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When pressing a contact in the contacts list, the app will display the conversation
    with the selected contact in the chat screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/9729a17b-e713-482a-a9b8-4cc6c7d19af1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The chats screen will show up all the chats that were started for the logged
    in user. Initially, this screen will be empty as the user won''t have initiated
    any chats. To start a conversation, the user should go to the search screen in
    order to find some contacts:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/0385f83f-b196-44dd-9543-92b74b2b9eb5.png)'
  prefs: []
  type: TYPE_IMG
- en: This is a simple screen where the user can enter the contact name to search
    for it in the database. If there is a match on the name of the contact; the user
    will be able to tap on it to get the conversation started. From that point on,
    the conversation will show in the chat screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last screen is the profile screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/5e03b5e4-8945-4c4e-bcb1-087c85575919.png)'
  prefs: []
  type: TYPE_IMG
- en: This screen is just a mean to log the current user out. When extending the app,
    we could add more features such as changing the avatar or the username.
  prefs: []
  type: TYPE_NORMAL
- en: 'While the app will look very similar on Android, navigation will be replaced
    by a drawer from which all the screens will be available. Let''s take a look at
    the Android version:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/c9a8db8a-c522-493e-9c1b-d5adeb8a31f3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The login/registration screen has standard text input and button components
    for Android:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/c3032531-f6b3-4b07-b0eb-e3cb1f21bc27.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once the user logs in, he/she can navigate through all the screens by opening
    the drawer through the sliding finger gesture. The screen that opens by default
    after login is the chats screens where we will list the list of open conversations
    the user has:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/9d64041f-16fd-4ed5-bf4f-8b52e7cacc61.png)'
  prefs: []
  type: TYPE_IMG
- en: 'From this screen, the user can press a specific conversation to list the messages
    on it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/15526fdd-df16-41c1-a055-ab14122f49a8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The next screen is the search screen, which will be used to search for other
    users and start conversations with them:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/8c7259a1-9e7b-4491-a03b-f18e0f6f9a73.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The last screen is the profile screen where the LOGOUT button can be found:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/c275ce0e-2d78-4a68-8f94-34115a0cc9ee.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The app will work on both platforms in portrait and landscape mode out of the
    box:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/b6098c83-2578-4a1d-8304-481ddc987cc2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As we can imagine, this app will require of a powerful backend environment
    to store our users, messages, and statuses. Moreover, we will require a Push Notifications
    platform to notify users when they receive any messages. Since we are focusing
    in React Native in this book, we will delegate all this backend work to one of
    the most popular Mobile Backend as a Services (MBaaS) in the mobile world: Firebase'
  prefs: []
  type: TYPE_NORMAL
- en: Before start coding, we will spend some time setting up our Firebase's push
    notifications service and real-time database to better understand what kind of
    data we will be dealing with in our app.
  prefs: []
  type: TYPE_NORMAL
- en: 'In summary, we will go through the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Complex Redux in React Native
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Firebase real-time database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Firebase push notifications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Firebase user management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Forms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start by reviewing the data models we will be using and how our app will
    connect with Firebase for syncing its data.
  prefs: []
  type: TYPE_NORMAL
- en: Firebase
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Firebase is a **Mobile Backend as a Service** (**MBaaS**), which means that
    it provides mobile developers with all the backend necessities, such as user management,
    no SQL database, and a push notification server. It integrates easily with React
    Native through an official node package, which brings the database connection
    for free. Unfortunately, Firebase doesn't offer a JavaScript SDK for their push
    notifications service, but there are several React Native libraries filling that
    gap by bridging Firebase's iOS and Java SDKs with a JavaScript interface. We will
    be using `react-native-fcm` as it is the most mature in its field.
  prefs: []
  type: TYPE_NORMAL
- en: Before building an app on top of a Firebase MBaaS, you need to create a project
    for it. This is a free process that is explained in Firebase's website [https://firebase.google.com/](https://firebase.google.com/).
    Although this process is not directly related to React Native, it's a good starting
    point to understand how to set up and use a MBaaS for our apps. Most of the configuring
    can be finished in a matter of minutes just by following the tutorials available
    on Firebase's documentation site. The benefits of setting up this MBaaS make those
    minutes worth the time and initial hassle.
  prefs: []
  type: TYPE_NORMAL
- en: 'To set up Firebase and connect our app to the correct project, we need to use
    the `configuration for the web` snippet we can find in the Settings screen inside
    our Firebase project''s dashboard. We added this initialization snippet on `src/firebase.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Once the project is set up, we can start taking a look at how our database is
    going to be structured.
  prefs: []
  type: TYPE_NORMAL
- en: Real-time database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Firebase allows mobile developers to store and sync data between users and devices
    in real time using a cloud-hosted, noSQL database. Updated data syncs across connected
    devices in milliseconds and data remains available if your app goes offline, providing
    a great user experience regardless of network connectivity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Three data models come into the picture when thinking about the basic data
    a one-to-one communication app should handle:'
  prefs: []
  type: TYPE_NORMAL
- en: '`users`: This will store avatars, names, and push notification tokens. There
    is no need to store authentication data here as it is handled through a different
    Firebase API (authentication API).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`messages`: We will save each message on each chat room separately for easy
    retrieval using the chat room ID as a key.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`chats`: All the information about the opened chats will be stored here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To understand how we will request and use the data in our app, let''s see a
    gist of the example data we can actually use for testing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We organized our data in a way it will be easy for the messaging app to retrieve
    and synchronize. Instead of normalizing the data structure, we introduced some
    data duplication to increase speed during data retrieval and simplify the frontend
    code to the maximum.
  prefs: []
  type: TYPE_NORMAL
- en: The `users` collection holds the users' data using the user ID as a key (`--user1--`,
    and `--user2--`). These user IDs are retrieved automatically by Firebase during
    registration/login. Each user has a notification token, which is an identifier
    for the device the user is logged in with the push notifications service. When
    the user logs out, the notifications token is removed, so messages sent to this
    user will be stored, but not notified to any device.
  prefs: []
  type: TYPE_NORMAL
- en: The `chats` collection stores each user's chat list by user ID. Each chat has
    its own ID (a concatenation of both user IDs) and will be duplicated as every
    user on that chat should have a copy of the chat data. In each copy, there is
    enough information for the other user to build up their chat screen.
  prefs: []
  type: TYPE_NORMAL
- en: The `messages` collection is stored in a separate collection, which can be referenced
    by that ID. Each chat ID points to a list of messages (only one in this example)
    where all the data needed by the chat screen is stored. There is also some duplication
    in this collection as some user data is stored together with each message to reduce
    the number of requests needed when building a chat screen.
  prefs: []
  type: TYPE_NORMAL
- en: A full tutorial on how to read and write data in Firebase's real-time database
    can be found on their website ([https://firebase.google.com/docs/database/](https://firebase.google.com/docs/database/)),
    but we will take a quick look at the methods we will be using in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Reading data from Firebase's database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two ways for retrieving data from Firebase''s database. The first
    one sets a listener that will be called every time the data changes, so we only
    need to set it up once for the entire lifetime of our app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, in order to retrieve a snapshot of data, we need to call the
    `database()` method in our `firebaseApp` object (the one we created in our `src/firebase.js`
    file). Then, we will have a `database` object where we can call the `ref('<uri>')` on
    it passing the URI, where the data is stored. That will return a reference to
    the piece of data pointed by that URI. We can go for the `on('value', callback)`
    method, which will attach a callback passing the snapshot of data. Firebase always
    returns objects as snapshots, so we need to transform them into plain data ourselves.
    In this example, we want to retrieve an object with two keys (`name` and `avatar`),
    so we only need to call the `val()` method on the snapshot to retrieve a plain
    object containing the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we don''t need the retrieved data to be automatically synched every time
    it is updated, we could have used the `once()` method instead of `on()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The callback receiving snapshot will only be called once.
  prefs: []
  type: TYPE_NORMAL
- en: Updating data in Firebase's database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Writing data in a Firebase database can also be done in two different ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '`update()` changes the object referenced by the supplied URI according to the
    keys and values passed as a parameter. The rest of the object is left intact.'
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, `set()` will replace the object in the database with the
    one we provide as a parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, if we want to add a new snapshot of data but we want Firebase to generate
    an ID for it, we can use the `push` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will use Firebase authentication services, so we don't need to worry about
    storing login credentials, handling forgotten passwords, or verifying emails on
    our side. These and other related tasks come for free with Firebase authentication
    services.
  prefs: []
  type: TYPE_NORMAL
- en: In order to activate login and registration through email and password, we need
    to enable this method as a session sign-in method in our Firebase dashboard. More
    information about how to do this can be found on Firebase's website at [https://firebase.google.com/docs/auth/web/password-auth](https://firebase.google.com/docs/auth/web/password-auth).
  prefs: []
  type: TYPE_NORMAL
- en: 'In our app, we only need to use the provided Firebase SDK for login:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'For registration, we can use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'All the token handling will be taken care of by Firebase, and we only need
    to add a listener to make sure our app is updated when the authentication status
    changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Setting up the folder structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s initialize a React Native project using React Native''s CLI. The project
    will be named `messagingApp` and will be available for iOS and Android devices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We will be using MobX to manage state in our app, so we will need a folder
    for our stores. The rest of the folder structure is standard to most React apps:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/a7683572-2298-4276-b416-676f563b0335.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We need five screens (`Chats`, `Chat`, `Login`, `Profile`, and `Search`), a
    component (`ListItem`) and two stores (`chats` and `users`), which will be available
    through the `stores/index.js` file. There are also two helpers that we will be
    using to support our app:'
  prefs: []
  type: TYPE_NORMAL
- en: '`notifications.js`: All the logic related to push notifications will be stored
    in this file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`firebase.js`: This includes the configuration and initialization of Firebase
    SDK'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Since we will be using MobX and several other dependencies, let''s take a look
    at our `package.json` file to understand what packages we will be using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Some of the npm packages we will be using are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`firebase`: Firebase''s SDK for authentication and database connection'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mobx`: MobX will handle our app state'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`react-native-fcm`: Firebase''s SDK for push messaging'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`react-native-gifted-chat`: A library for rendering chat rooms including date
    separation, avatars, and many other features'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`react-native-keyboard-aware-scroll-view`: A library that ensures the on-screen
    keyboard doesn''t hide any focused text input when working with forms'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`react-native-vector-icons`: We will use Font Awesome icons for this app'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`react-navigation`: We will have a drawer, a tabbed, and a stack navigator
    handling the screens in our app'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`babel-plugin-transform-decorators-legacy`: This library allows us to use decorators
    (with the legacy @ syntax) which is quite useful when working with MobX'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After running `npm install`, we will have our app ready to start coding. As
    it happened in previous apps, the entry point for our messaging app will be the
    same code both in  `index.ios.js` for iOS and in `index.android.js` for Android:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a standard way to start up a React Native app working with MobX--a
    `<Provider />` is supplied as the root element to inject the two stores (`users`
    and `chats`) into the screens in our app. All the initializing and navigation
    logic has been deferred to the `src/main.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The first thing we can see on the `src/main.js` file is that we will use different
    navigators, depending on which platform we are running the app: iOS will open
    a tabbed navigator, while Android will open a drawer-based navigator.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we see a line we will be repeating in many components in our app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This is the way to tell MobX this component needs to receive the `users` store.
    MobX will then pass it as a prop to this component and therefore we can use all
    the methods and attributes it holds. In this case, we are interested in the `isLoggedIn`
    attribute to present the user with the `<Login />` screen if they are still not
    logged in. Since MobX will inject this attribute as a property in our component,
    the right way to access it will be `this.props.users.isLoggedIn`.
  prefs: []
  type: TYPE_NORMAL
- en: Before continuing building components, let's take a look at the stores we will
    be using throughout this chapter to better understand what data and actions are
    available.
  prefs: []
  type: TYPE_NORMAL
- en: Users store
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This store is responsible for holding all the data and logic surrounding users,
    but also helps the `chats` store initializing when a user is logged in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'These are all the attributes and methods we need for this store. There are
    several flags (those attributes containing a verb in its -ing form) to note network
    activity. Let''s implement each method now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Logging in with Firebase is as simple as calling `signInWithEmailAndPassword`
    on their authentication SDK. If the login is successful, we will initialize the
    notifications module to enable the device to receive push notifications. We will
    follow the opposite path on logout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In the registration action, besides setting the appropriate flags for network
    activity, we need to validate the user entered a name, initialize the notifications,
    and store the name in the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Setting the notification token is just a simple update in the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '`searchUsers()` is not marked as `@action`, as it won''t modify the state of
    our app, but only search and return a list of users with the provided name in
    the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We will return the result as a promise, due to the asynchronous nature of the
    request we are making.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally,` bindToFirebase()` will attach the attributes in this store to data
    snapshots in Firebase''s database. This method is called by the constructor, so
    it serves as initialization for the user data. It''s important to note that this
    data will be updated when the authentication status changed to always reflect
    the most up to date data for the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We will store the listeners for the chat data (as `this.chatsBind`) and for
    the user data (as `this.userBind`), so we can remove them (by calling the `off()`
    method) before attaching new listeners on every `auth` state change.
  prefs: []
  type: TYPE_NORMAL
- en: Chats store
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This store is responsible for holding all the data and logic surrounding chats
    and messages, but it also helps the `chats` store initializing when a user is
    logged in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We will store the list of open chats the user has in `@observable list`. When
    a user selects one chat, we will download and synchronize the list of messages
    on that chat to `@observable selectedChatMessages`. Then, we will have a couple
    of flags to let the user know when we are downloading data from the Firebase database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at each method individually. We will start with `addMessages`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This method receives three parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`chatId`: The ID for the chat in which the messages will be added.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`contactId`: The ID for the user to whom we are sending the message. This will
    be used to send a notification to the user''s contact.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`messages`: This is an array with all the messages we want to add to the chat.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will loop through the list of messages, formatting the message the way we
    want to store it. Then, we will call the `set()` method on a database reference
    to save the new message in Firebase's database. Finally, we need to send the notification
    to our contact, so we retrieve their notifications token by querying the `users`
    collection by their `contactId`.
  prefs: []
  type: TYPE_NORMAL
- en: Sending notifications is normally handled by the backend, but since we are setting
    all the logic on the app itself, we need to build a function to send notifications.
    We have done this in our notifications `module: notifications.sendNotification(notificationsToken,
    data);`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see what happens when we select a chat to display the messages for it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The main piece of functionality here is attaching a listener to the messages/chat
    ID collection, which will sync the `this.selectedChatMessages` observable with
    the list of messages for the selected chat in the database. This means that every
    time a new message is stored in Firebase, `this.selectedChatMessages` will be
    synced to reflect it. This is how the `on()` method in the Firebase SDK works:
    we pass a callback, which we can use to synchronize the real-time database with
    our app''s state.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding a new chat will be done using the `add()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are building and returning a promise that will be resolved when the
    two chats (one per each user participating in the chat) are updated. These two
    database updates can be seen as the duplication of data, but it will also reduce
    the data structure complexity and therefore our code base readability.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last method in this store is `bindToFirebase()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: As we saw in our `users` store, this method will be called when the user logs
    in and attaches a listener to the `chats/<userId>` snapshot of data to keep all
    the chats data synched with the database on the `this.list` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a convenience, we will group both stores in `src/stores/index.js`, so we
    can import them both on one line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This is all about the stores we will be using. As we can see, most of the business
    logic is handled here so it can be thoroughly tested. Let's move now to the helper
    we will use for notifications.
  prefs: []
  type: TYPE_NORMAL
- en: Push notifications using Firebase
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Firebase incorporates a push notification service for iOS and Android, but it
    unfortunately doesn't provide any JavaScript on their SDK to use it. For this
    matter, an open source library was created bridging the Objective-C and Java SDKs
    into a React Native module: `react-native-fcm`.
  prefs: []
  type: TYPE_NORMAL
- en: We won't cover the installation of this module in this book, as it's a changing
    process that can be better followed on its repository at [https://github.com/evollu/react-native-fcm.](https://github.com/evollu/react-native-fcm)
  prefs: []
  type: TYPE_NORMAL
- en: 'We decided to abstract the logic for this module on our `src/notifications.js`
    file to make it available for every component while keeping its maintainability.
    Let''s take a look at this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'There are four functions exposed in this module:'
  prefs: []
  type: TYPE_NORMAL
- en: '`init`: This requests the permission to receive push notifications (in case
    it was not yet granted) and requests the device token or refreshes it if changed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onNotification`: This invokes a provided callback when a notification is received.
    In iOS, it also calls the appropriate methods on the notification to close the
    cycle.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unbind`: This stops listening for push notifications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sendNotification`: This formats and sends a push notification to a specific
    device using a provided notifications token.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending notifications in Firebase can be done using their HTTP API, so we will
    use `fetch` for sending a `POST` request with the proper header and body data.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we have all the logic we need to start building our screens and components.
  prefs: []
  type: TYPE_NORMAL
- en: Login
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `<Login />` component heavily relies on the `users` store for logic, as
    it is mostly focused on rendering two forms for login and registration. All the
    validation for the forms is done by Firebase, so we only need to focus on rendering
    the UI elements and calling the proper store methods.
  prefs: []
  type: TYPE_NORMAL
- en: In this screen, we will be using the `react-native-keyboard-aware-scroll` view,
    which is a module providing a self-scrolling `<Scrollview />`, which reacts to
    any focused `<TextInput />` so they are not hidden when the keyboard pops up.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We split the login screen in two forms: `<LoginForm />` and `<RegistrationForm
    />`. Both components need to be passed three props:'
  prefs: []
  type: TYPE_NORMAL
- en: '`onPress`: What the component needs to do when the `Send` button is pressed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`busy`: Are we waiting for remote data?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`loginError`/`registrationError`: Description of the error that happened when
    logging/register (in case it happened).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We are wrapping the whole screen in a `<KeyboardAwareScrollView />` to ensure
    no `<TextInput />` gets hidden by the keyboard when focused. Let''s take a look
    at the `LoginForm` now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: For the `<TextInput />` elements containing the email, we set the property `keyboardType='email-address'`
    so the `@` sign is easily accessible on the software keyboard. There are other
    options such as numeric keyboards, but we will only use `'email-address'` for
    this app.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another useful prop on `<TextInput />` is `returnKeyType`. We set `returnKeyType=''next''`
    for those form inputs that are not the last ones to display the `Next` button
    in the keyboard so the user knows they can go to the next input by tapping that
    button. This prop is used in conjunction with a prop like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '`onSubmitEditing` is a `<TextInput />` prop that will be invoked when a user
    presses the `Return` or `Next` button on the keyboard. We are using it to focus
    on the next `<TextInput />`, which is quite user-friendly when dealing with forms.
    To get the reference for the next `<TextInput />` we use `ref`, which is not the
    safest way, but is good enough for simple forms. For this to work, we need to
    assign the corresponding `ref` to the next `<TextInput />`: `ref=''loginPassword''`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`RegistrationForm` is a very similar form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Chats
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is the screen displaying the list of open chats. The special thing to
    note here is we are using a second navigator to display selected chats on top
    of the chats list. This means we need a `StackNavigator` in our `Chats` component
    that will contain two screens: `ChatList` and `Chat`. When a user taps on a chat
    from `ChatList`, `StackNavigator` will display the selected chat on top of `ChatList`
    making the list of chats available through a standard `< back` button in the header.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For listing the chats, we will use `<FlatList />`, a performant interface for
    rendering simple, flat lists, supporting the most of the features from `<ListView
    />`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The first thing we notice is that we are injecting the `chats` store where the
    list of chats is saved: `@inject('chats') @observer`. We need this to build our
    `<FlatList />`, based on `this.props.chats.list`, but as the list of chats is
    an observable MobX object, we need to transform it using its `toJS()` method to
    make a JavaScript array out of it.
  prefs: []
  type: TYPE_NORMAL
- en: On the `componentWillMount()` function, we will invoke `onNotification` on the
    notifications module to open the corresponding chat every time the user presses
    a push notification on her device. Therefore, we will use the `navigate()` method
    on the navigator to open the proper chat screen including the name of the contact
    and her avatar.
  prefs: []
  type: TYPE_NORMAL
- en: ListItem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The list of chats relies on `<ListItem />` to render each specific chat within
    the list. This component is a custom UI class we created to reduce the `ChatList`
    component complexity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: There is little logic on this component as it only receives a prop named `onPress()`,
    which will be called when the `<ListItem />` is pressed, which, as we saw on this
    component's parent, will open the chat screen to show the list of messages on
    that specific chat. Let's take a look at the `chat` screen where all the messages
    for a specific chat are rendered.
  prefs: []
  type: TYPE_NORMAL
- en: Chat
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To keep our code succinct and maintainable, we will use `GiftedChat` for rendering
    all the messages in a chat, but there is still some work we need to do to properly
    render this screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to inject some stores for our `<Chat />` component to work. This
    time, we need `users` and `chats` stores that will be available as props inside
    the component. This component also expects to receive two params from the navigator:
    `chatId` (the ID for the chat) and `contactId` (the ID for the person the user
    is chatting with).'
  prefs: []
  type: TYPE_NORMAL
- en: When the component is getting ready to be mounted (`onComponentWillMount()`)
    we save the `chatId` and `contactId` in more convenient variables inside the component
    and call the `selectChat()` method on the `chats` store. This will trigger a request
    to Firebase database to fetch the messages for the selected chat, which will be
    synced through the `chats` store and is accessible to the component through `this.props.chats.selectedChatMessages`.
    MobX will also update a `downloadingChat` property to ensure we let the user know
    the data is being retrieved from Firebase.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we need to add a `onSend()` function to `GiftedChat,` which will call
    the `addMessages()` method on the `chats` store to post the message to Firebase
    every time the `Send` button is pressed.
  prefs: []
  type: TYPE_NORMAL
- en: '`GiftedChat` helped us in largely reducing the amount of work we need to do
    in order to render the list of messages for a chat. On the other hand, we had
    to format the messages in the way `GiftedChat` requires and provide an `onSend()`
    function to be executed whenever we need a message posted to our backend.'
  prefs: []
  type: TYPE_NORMAL
- en: Search
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The search screen is divided into two parts: a `<TextInput />` for the user
    to search a name and a `<FlatList />` to show the list of contacts found with
    the entered name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This component requires the injection of both stores (`users` and `chats`).
    The `users` store is used to invoke the `searchUsers()` method when the user hits
    the `Search` button. This method doesn't modify the state and therefore we need
    to provide a callback to receive the list of found users to finally set that list
    on the component's state.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second store, `chats`, will be used to store the open chat in Firebase
    by calling `add()` from the `onPressUser()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The `add()` method in the `chats` store requires two parameters to be passed:
    one per each user in the newly open chat. This data will be properly stored in
    Firebase, so both users will see the chat on their chat list in the app. After
    adding the new chat, we will navigate the app to the chats screen so the user
    can see if the addition was successful.'
  prefs: []
  type: TYPE_NORMAL
- en: Profile
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The profile screen displays the user''s avatar, name, and a `Logout` button
    for signing out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The logout process is triggered by calling the `logout()` method on the `users`
    store. Since we controlled the authentication status in our `src/main.js` file,
    the app will automatically return to the Login or Register screen when the logout
    is successful.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We covered several important topics for most of the modern enterprise apps:
    user management, data synchronization, complex app state, and handling forms.
    This is a complete app, which we manage to fix with a small code base and the
    help of MobX and Firebase.'
  prefs: []
  type: TYPE_NORMAL
- en: Firebase is very capable of handling this app in production with a large number
    of users, but building our own backend system should not be a complex task, especially
    if we have experience in working with `socket.io` and real-time databases.
  prefs: []
  type: TYPE_NORMAL
- en: There are some aspects missing in this chapter such as handling security (which
    can be done fully within Firebase) or creating chat rooms for more than two users.
    In any case, these aspects fall out of React Native's environment, so they were
    intentionally left out.
  prefs: []
  type: TYPE_NORMAL
- en: After finishing this chapter, we should be able to build any app on top of Firebase
    and MobX as we covered the most used user cases on both pieces of technology.
    Of course, there are some more complex cases that were left out, but they can
    be easily learned by having a good understanding of the basics explained throughout
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we will build a very different kind of app: a game written
    in React Native.'
  prefs: []
  type: TYPE_NORMAL
