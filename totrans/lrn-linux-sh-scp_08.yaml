- en: Variables and User Input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll begin by describing what variables are, and why we
    want and need them. We''ll explain the difference between variables and constants.
    Next, we''ll provide some possibilities with regard to variable naming and introduce
    some best practices on naming conventions. Finally, we''ll discuss user input
    and how to properly deal with it: either with positional arguments or with interactive
    scripts. We''ll end the chapter with an introduction to `if-then` constructs and
    exit codes, which we''ll use to combine positional arguments and interactive prompts.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following commands will be introduced in this chapter: `read`, `test`,
    and `if`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: What is a variable?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variable naming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dealing with user input
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interactive versus non-interactive scripts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Other than the Ubuntu virtual machine with files from the previous chapters,
    no other resources are needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'All scripts for this chapter can be found on GitHub: [https://github.com/PacktPublishing/Learn-Linux-Shell-Scripting-Fundamentals-of-Bash-4.4/tree/master/Chapter08](https://github.com/PacktPublishing/Learn-Linux-Shell-Scripting-Fundamentals-of-Bash-4.4/tree/master/Chapter08).
    For the name-improved.sh script only the final version is found online. Be sure
    to verify the script version in the header before executing it on your system.'
  prefs: []
  type: TYPE_NORMAL
- en: What is a variable?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Variables are a standard building block used in many (if not all) programming
    and scripting languages. Variables allow us to store information, so we can reference
    and use it later, often multiple times. We can, for example, use the `textvariable` variable
    to store the sentence `This text is contained in the variable`. In this case,
    the variable name of `textvariable` is referred to as the key, and the content
    of the variable (the text) is referred to as the value, in the key-value pair
    that makes up the variable.
  prefs: []
  type: TYPE_NORMAL
- en: In our program, we always reference the `textvariable` variable when we need
    the text. This might be a bit abstract now, but we're confident that after seeing
    the examples in the rest of the chapter, the usefulness of variables will become
    clear.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve actually already seen Bash variables in use. Remember, in [Chapter 4](5c0848c2-4c8b-4f52-bcc8-2e670faa6a82.xhtml),
    *The Linux Filesystem*, we looked at both the `BASH_VERSION` and `PATH` variables.
    Let''s see how we can use variables in shell scripting. We''ll take our `hello-world-improved.sh`
    script, and instead of using the `Hello world` text directly, we''ll first put
    it in a variable and reference it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we copy the `hello-world-improved.sh` script from the `chapter_07` directory
    into the newly created `chapter_08` directory, with the name `hello-world-variable.sh`.
    Then, we use `vim` to edit it. Give it the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Congratulations, you've just used your first variable in a script! As you can
    see, you can use the content of a variable by wrapping its name inside the `${...}`
    syntax. Technically, just putting `$` in front of the name is enough (for example,
    `echo $hello_text`). However, in that situation, it is hard to differentiate where
    the variable name ends and the rest of the program begins—if you use the variable
    in the middle of a sentence, for example (or, even better, in the middle of a
    word!). If you use `${..}`, it's clear that the variable name ends at `}`.
  prefs: []
  type: TYPE_NORMAL
- en: 'At runtime, the variable we defined will be replaced with the actual content
    instead of the variable name: this process is called *variable interpolation*
    and is used in all scripting/programming languages. We''ll never see or directly
    use the value of a variable within a script, since in most cases the value is
    dependent on runtime configurations.'
  prefs: []
  type: TYPE_NORMAL
- en: You will also see that we edited the information in the header. While it's easy
    to forget it, if a header does not contain correct information, you reduce readability.
    Always make sure you have an up-to-date header!
  prefs: []
  type: TYPE_NORMAL
- en: If we further dissect the script, you can see the `hello_text` variable is the
    first functional line after the header. We call this **assigning a value to a
    variable**. In some programming/scripting languages, you first have to *declare*
    a variable before you can *assign* it (most of the time, these languages have
    shorthand in which you can declare and assign as a single action).
  prefs: []
  type: TYPE_NORMAL
- en: The need for declaration comes from the fact that some languages are *statically
    typed* (the variable type—for example, string or integer—should be declared before
    a value is assigned, and the compiler will check that you're doing it correctly—for
    example, not assigning a string to an integer typed variable), while other languages
    are *dynamically typed*. For dynamically typed languages, the language just assumes
    the type of the variable from what is assigned to it. If it is assigned a number,
    it will be an integer; if it is assigned text, it will be a string, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Basically, variables can be **assigned** a value, **declared**, or **initialized**.
    While, technically, these are different things, you will often see the terms being
    used interchangeably. Do not get too hung up on this; the most important thing
    to remember is you're *creating the variable and its content*!
  prefs: []
  type: TYPE_NORMAL
- en: 'Bash does not *really* follow either approach. Bash''s simple variables (excluding
    arrays, which we will explain later) are always considered strings, unless the
    operation explicitly specifies that we should be doing arithmetic. Look at the
    following script and result (we omitted the header for brevity):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'You might have expected that we would get the number 2 printed. However, as
    stated, Bash considers everything a string; it just prints the value of the variable,
    followed by the space, the plus sign, another space, and the number 1\. If we
    want to have the actual arithmetic performed, we need a specialized syntax so
    that Bash knows that it is dealing with numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: By including the `variable + 1` inside `$((...))`, we tell Bash to evaluate
    it as arithmetic.
  prefs: []
  type: TYPE_NORMAL
- en: Why do we need variables?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Hopefully, you understand how to use variables now. However, you might not
    yet grasp why we would *want* or *need* to use variables. It might just seem like
    extra work for a small payoff, right? Consider the next example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we used the `name` variable not once, but three times. If we
    did not have the variable in place, and we needed to edit the name, we would need
    to search for every place in the text that the name was used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Furthermore, if we made a spelling mistake in one of the places, writing *Sebastian*
    instead of *Sebastiaan* (which, if you''re interested, happens *a lot*), both
    reading the text and editing it would take much more effort. Moreover, this was
    a simple example: often, variables are used many times (many more than three times
    at least).'
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, variables are often used to store the *state* of a program. For
    a Bash script, you could imagine creating a temporary directory in which you'll
    perform some operations. We can store the location of this temporary directory
    in a variable, and anything we need to do in the temporary directory will make
    use of the variable to find the location. After the program finishes, the temporary
    directory should be cleaned up and the variable will no longer be needed. For
    every run of the program, the temporary directory will be named differently, so
    the content of the variable will be different, or *variable*, as well.
  prefs: []
  type: TYPE_NORMAL
- en: Another advantage of variables is that they have a name. Because of this, if
    we create a descriptive name, we can make the application easier to read and easier
    to use. We've determined that readability is always a must-have for shell scripting,
    and the use of properly named variables helps us with this.
  prefs: []
  type: TYPE_NORMAL
- en: Variables or constants?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the examples up to now, we have actually used variables as **constants**.
    The term variable implies that it can change, whereas our examples have always
    assigned a variable at the start of the script, and used it throughout. While
    that has merits of its own (as stated before, for consistency or easier editing),
    it does not yet utilize the full power of variables.
  prefs: []
  type: TYPE_NORMAL
- en: A constant is a variable, but a special type. Simply put, a constant is *a variable
    defined at the start of the script that is not affected by user input and does
    not change value during execution.*
  prefs: []
  type: TYPE_NORMAL
- en: Later in this chapter, when we discuss dealing with user input, we'll see true
    variables. There, the content of the variables is supplied by the caller of the
    script, which means the output of the script will be different, or *varied*, each
    time the script is called. Later in the book, when we describe conditional testing,
    we will even change the value of a variable during the script itself, according
    to logic in that same script.
  prefs: []
  type: TYPE_NORMAL
- en: Variable naming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'On to the subject of naming. You might have noticed something about the variables
    we''ve seen up to now: the Bash variables `PATH` and `BASH_VERSION` are written
    fully uppercase, but in our examples we used lowercase, with words separated by
    an underscore (`hello_text`). Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run this, we get a nice little story:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'So, our variables are working great! Technically, everything we did in this
    example was fine. However, they look a mess. We used four different naming conventions:
    lowercase_with_underscores, UPPERCASE, _lowercase, and finally camelCase. While
    these are technically valid, remember that readability counts: it''s best to pick
    one way of naming your variables, and stick with this.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you might expect, there are many opinions about this (probably as many as
    in the tabs versus spaces debate!). Obviously, we also have an opinion, which
    we would like to share: use **lowercase_separated_by_underscores** for regular
    variables, and **UPPERCASE** for constants. From now on, you''ll see this practice
    in all further scripts.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous example would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We hope you agree this looks *much better*. Later in this chapter, when we introduce
    user input, we will be working with normal variables as well, as opposed to the
    constants we've been using so far.
  prefs: []
  type: TYPE_NORMAL
- en: 'Whatever you decide upon when naming your variables, there is only one thing
    in the end that really matters: consistency. Whether you prefer lowercase, camelCase,
    or UPPERCASE, it has no impact on the script itself (except for certain readability
    pros and cons, as discussed). However, using multiple naming conventions at the
    same time greatly confuses things. Always make sure to pick a convention wisely,
    and then **stick to it!**'
  prefs: []
  type: TYPE_NORMAL
- en: 'To keep things clean, we generally avoid using UPPERCASE variables, except
    for constants. The main reason for this is that (almost) all *environment variables*
    in Bash are written in uppercase. If you do use uppercase variables in your scripts,
    there is one important thing to keep in mind: **make sure the names you choose
    do not conflict with pre-existing Bash variables**. These include `PATH`, `USER`,
    `LANG`, `SHELL`, `HOME`, and so on. Should you use the same names in your script,
    you might get some unexpected behavior.'
  prefs: []
  type: TYPE_NORMAL
- en: It is a much better idea to avoid these conflicts and choose unique names for
    your variables. You could, for example, choose the `SCRIPT_PATH` variable instead
    of `PATH`.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with user input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we''ve been dealing with really static scripts. While it''s fun to
    have a story available for everyone to print out, it hardly qualifies as a functional
    shell script. At the very least, it''s not something you are going to use often!
    So, we''d like to introduce a very important concept in shell scripting: **user
    input**.'
  prefs: []
  type: TYPE_NORMAL
- en: Basic input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At a very basic level, everything that you put on the command line right after
    calling the script can be used as input. However, it is up to the script to use
    it! For example, consider the following situation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'When we called `name.sh` the first time, we used the originally intended functionality.
    The second time we called it, we supplied an extra argument: `Sanne`. However,
    because the script does not parse user input at all, the output we saw was exactly
    the same.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s revise the `name.sh` script so that it actually uses the extra input
    we specify when calling the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, that looks much better! The script now accepts user input; specifically,
    the name of the person. It does this by using the `$1` construct: this is the
    *first positional argument*. We call these arguments positional because the position
    matters: the first one will always be written to `$1`, the second to `$2`, and
    so on. There is no way for us to swap these around. Only once we start looking
    into making our script compatible with flags will we get more flexibility. If
    we provide even more arguments to the script, we can grab them using `$3`, `$4`,
    and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: There is a limit to the number of arguments you can provide. However, it is
    sufficiently high that you never have to really worry about it. If you get to
    that point, your script will be unwieldy enough that no one will ever use it anyway!
  prefs: []
  type: TYPE_NORMAL
- en: 'You might want to pass a sentence to a Bash script, as **one** argument. In
    this case, you need to enclose the entire sentence in single or double quotes
    if you want to have it interpreted as a *single positional argument*. If you do
    not, Bash will consider each space in your sentence the delimiter between the
    arguments; passing the sentence **This Is Cool** will result in three arguments
    to the script: This, Is, and Cool.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice how, again, we updated the header to include the new input under *Usage*.
    Functionally, however, the script isn''t that great; we used male pronouns with
    a female name! Let''s fix that real quick and find out what happens if we now
    *omit the user input*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: So, we've made the text a little more unisex. However, when we called the script
    without providing a name as an argument, we messed up the output. In the next
    chapter we'll dive deeper into error checking and input validation, but for now
    remember that Bash **will not provide an error if variables are missing/empty**;
    you are fully responsible for handling this. We will discuss this further in the
    next chapter, as this is another very important topic in shell scripting.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters and arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We need to take a small step back and discuss some terminology—parameters and
    arguments. It's not terribly complicated, but it can be a bit confusing, and they
    are sometimes used incorrectly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Basically, an argument is something you pass to a script*.* What you define
    in the script is considered the parameter*.* Look at the following example to
    see how this works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Variables we use in this manner are called parameters inside the scripts, but
    are referred to as arguments when passing them to the script. In our `name-improved.sh`
    script, the parameter is the `name` variable. This is static and bound to the
    script version. The argument, however, is different each time the script is run:
    it can be `Sebastiaan`, or `Sanne`, or any other name.'
  prefs: []
  type: TYPE_NORMAL
- en: Remember, when we are talking about an argument, you can read that as a *runtime
    argument*; something that can be different each run. If we're talking about a
    parameter of the script, we're referring to the static piece of information expected
    by a script (which is often provided by a runtime argument, or some logic in the
    script).
  prefs: []
  type: TYPE_NORMAL
- en: Interactive versus non-interactive scripts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The script we have created so far uses user input, but it can't really be called
    interactive. As soon as the script is fired off, with or without arguments to
    the parameters, the script runs and completes.
  prefs: []
  type: TYPE_NORMAL
- en: But what if we do not want to use a long list of arguments, instead prompting
    the user for the information that is needed?
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the `read` command. The basic usage of `read` looks at input from the
    command line, and stores it in the `REPLY` variable. Try it out yourself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: After you start the `read` command, your terminal will go down a line and allow
    you to type anything you want. As soon as you hit *Enter* (or, actually, until
    Bash encounters the *newline* key), the input will be saved into the `REPLY` variable.
    You can then echo this variable to verify it has actually stored your text.
  prefs: []
  type: TYPE_NORMAL
- en: '`read` has a few interesting flags which make it more usable in shell scripting.
    We can use the `-p` flag with an argument (the text to display, surrounded by
    quotes) to present the user with a prompt, and we can supply the name of the variable
    in which we want to store the response as the last argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In the previous example, we first used `read -p` without specifying a variable
    where we want to save our response. In this case, `read`'s default behavior places
    it in the `REPLY` variable. A line later, we ended the `read` command with the
    text `day_of_week`. In this case, the full response is saved into a variable with
    this name, as can be seen in the `echo ${day_of_week}` right after.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use `read` in an actual script now. We''ll first create the script using
    `read`, and then using positional arguments as we have up to now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'That worked out pretty well. The user could just call the script without looking
    at how to use it, and is further prompted for information. Now, let''s copy and
    edit this script and use positional arguments to supply the information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: First, we copied the `interactive.sh` script to `interactive-arguments.sh`.
    We edited this script to no longer use `read`, but instead to grab the values
    from the arguments passed to the script. We edited the header with *the new name
    and the new usage*, and we ran it by supplying another set of arguments. Once
    again, we were presented with a nice little story.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, you might be wondering, when should you use which method? Both methods
    ended with the same result. However, as far as we''re concerned, both scripts
    aren''t equally readable or simple to use. Look at the following table for pros
    and cons for each method:'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | **Pros** | **Cons** |'
  prefs: []
  type: TYPE_TB
- en: '| Read |'
  prefs: []
  type: TYPE_TB
- en: User does not need to be aware of arguments to supply; they can just run the
    script and be prompted for any information needed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is not possibly to forget to supply information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: If you want to repeat the script multiple times, you need to type the responses
    every time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cannot be run non-interactively; for example, in a scheduled job
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| Arguments |'
  prefs: []
  type: TYPE_TB
- en: Can be repeated easily
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can be run non-interactively as well
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: User needs to be aware of arguments to supply **before** attempting to run the
    script
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is much easier to forget to supply part of the information needed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Basically, the pros for one method are the cons for the other, and vice-versa.
    It seems as though we can't win by using either method. So, how would we create
    a robust interactive script that we can also run non-interactively?
  prefs: []
  type: TYPE_NORMAL
- en: Combining positional arguments and read
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By combining both methods, of course! Before we start executing the actual functionality
    of the script, we need to verify whether  all necessary information has been supplied.
    If it has not, we can then prompt the user for the missing information.
  prefs: []
  type: TYPE_NORMAL
- en: We're going to look ahead slightly to [Chapter 11](05e9179f-31c1-4f5f-903a-5a6b9f2c80d5.xhtml),
    *Conditional Testing and Scripting Loops*, and explain the basic use of `if-then`
    logic. We'll combine this with the `test` command, which we can use to check if
    a variable contains a value or is empty. *If* that is the case, *then* we can
    prompt the user with `read` to supply the missing information.
  prefs: []
  type: TYPE_NORMAL
- en: At its heart, `if-then` logic is nothing more than saying `if <something>, then
    do <something>`. In our example, `if` the variable of `character_name` is empty,
    `then` use `read` to prompt for this information. We'll do this for all three
    parameters in our script.
  prefs: []
  type: TYPE_NORMAL
- en: Because the arguments we're supplying are positional, we cannot supply the first
    and the third only; the script would interpret that as the first and second argument,
    with a missing third argument. With our current knowledge, we're limited by this.
    In [Chapter 15](fe4b95bc-7c5e-4602-a102-a46e1c4934dc.xhtml), *Parsing Bash Script
    Arguments with getopts*, we'll explore how to supply information using flags.
    In this case, we can supply all information separately, without worrying about
    the order. For now, however, we'll have to live with the limitation!
  prefs: []
  type: TYPE_NORMAL
- en: Before we can explain the `test` command, we need to go back a little bit and
    explain **exit codes**. Basically, every program that runs and exits returns a
    code to the parent process that originally started it. Normally, if a process
    is done and execution was successful, it exits with **code 0**. If execution of
    the program was not successful, it exits with *any other code*; however, this
    is usually **code 1**. While there are conventions for exit codes, often you will
    just encounter 0 for good exits and 1 for bad exits.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we use the `test` command, it generates exit codes conforming to the guidelines
    as well: if the test is successful, we see exit code 0\. If it is not, we see
    another code (probably 1). You can see the exit code of the previous command with
    the `echo $?` command.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: A lot happened in the previous example. First, we tried to create a directory
    that was already present. Since we can't have two directories with the same name
    (in the same location), the `mkdir` command failed. When we printed the exit code
    using `$?`, we were returned `1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving on, we successfully created a new directory, `testdir`. When we printed
    the exit code after that command, we saw the number for success: `0`. After successfully
    removing the empty `testdir`, we saw an exit code of `0` again. When we tried
    to remove the not-empty `scripts` directory with `rmdir` (which isn''t allowed),
    we got an error message and saw that the exit code was again `1`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s get back to `test`. What we need to do is verify whether a variable
    is empty. If it is, we want to start a `read` prompt to have it filled by user
    input. First we''ll try this on the `${PATH}` variable (which will never be empty),
    and then on the `empty_variable`, which will be indeed empty. To test whether
    a variable is empty, we use `test -z <variable name>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: While this might seem like the wrong way around at first, think about it. We're
    testing whether a variable **is empty**. Since `$PATH` is not empty, the test
    fails and produces an exit code of 1\. For `${empty_variable}` (which we have
    never created), we are sure it is indeed empty, and an exit code of 0 confirms
    this.
  prefs: []
  type: TYPE_NORMAL
- en: If we want to combine the Bash `if` with `test`, we need to know that `if` expects
    a test that ends in an exit code of 0\. So, if the test is successful, we can
    do something. This fits our example perfectly, since we're testing for empty variables.
    If you wanted to test it the other way around, you'd need to test for a non-zero
    length variable, which is the `-n` flag for `test`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the `if` syntax first. In essence, it looks like this: `if <exit
    code 0>; then <do something>; fi`. You can choose to have this on multiple lines,
    but using ; on a line terminates it as well. Let''s see whether we can manipulate
    this for our needs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we used our constructed `if-then` clause on the `PATH` variable. Since
    it is not empty, we did not expect a prompt: a good thing we did not get one!
    We used the same construct, but now with the `empty_variable`. Behold, since the
    `test -z` returned exit code 0, the `then` part of the `if-then` clause was executed
    and prompted us for a value. After inputting the value, we could echo it out.
    Running the `if-then` clause again did not give us the `read` prompt, because
    at that point the variable `empty_variable` was no longer empty!'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s incorporate this `if-then` logic into our `new interactive-ultimate.sh`
    script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Success! We were prompted for `location` and `food`, but `character_name` was
    successfully resolved from the argument that we passed. We've created a script
    that we can use both fully interactive, without supplying arguments, but also
    non-interactive with arguments.
  prefs: []
  type: TYPE_NORMAL
- en: While this script is informative, it is not really efficient. It would be better
    to combine the `test` looking directly at the passed arguments (`$1`, `$2`, `$3`),
    so we only need one line. Later on in the book, we will start using such optimizations,
    but for now it is more important to write things out in full, so you can more
    easily understand them!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At the start of this chapter, we explained what a variable was: a standard
    building block that allows us to store information, which we can reference later.
    We prefer to use variables for a number of reasons: we can store a value once
    and reference it multiple times, and if we need to change the value, we only have
    to change it once and the new value will be used everywhere.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We explained that a constant is a special type of variable: it is defined only
    once in the beginning of a script, it is not affected by user input, and it does
    not change during the course of the script execution.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We continued with some notes on variable naming. We demonstrated that Bash
    is very flexible with regard to variables: it allows many different styles of
    variable naming. However, we explained that readability suffers if you use multiple
    different naming conventions in the same script, or between multiple scripts.
    The best idea is to choose one way of naming variables, and stick with it. We
    recommended using UPPERCASE for constants, and lowercase_separated_by_underscores
    for all other variables. This will lessen the chance of conflicts between local
    and environment variables.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we explored user input and how to deal with it. We gave users of our
    scripts the ability to alter the outcome of our scripts, a function that is almost
    mandatory for most real-life functional scripts. We described two different methods
    of user interaction: basic input using positional arguments, and interactive input
    using the `read` construct.'
  prefs: []
  type: TYPE_NORMAL
- en: We ended the chapter with a brief introduction to if**–**then logic and the
    `test` command. We used these concepts to create a robust way to handle user input,
    combining positional arguments with a `read` prompt for missing information, after
    presenting the pros and cons of each method used alone. This created a script
    that could be used both interactively and non-interactively, depending on the
    use case.
  prefs: []
  type: TYPE_NORMAL
- en: The following commands were introduced in this chapter: `read`, `test`, and `if`.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is a variable?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why do we need variables?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a constant?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why are naming conventions especially important for variables?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are positional arguments?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between a parameter and an argument?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can we make a script interactive?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can we create a script that we can use both non-interactively and interactively?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following resources might be interesting if you''d like to go deeper into
    the subjects of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Bash variables**: [https://ryanstutorials.net/bash-scripting-tutorial/bash-variables.php](https://ryanstutorials.net/bash-scripting-tutorial/bash-variables.php)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Google Shell Style Guide**: [https://google.github.io/styleguide/shell.xml](https://google.github.io/styleguide/shell.xml)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
