- en: Chapter 12. Patterns for Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this module we've been pushing the idea that JavaScript is no longer
    a toy language with which we can't do useful things. Real world software is being
    written in JavaScript right now and the percentage of applications using JavaScript
    is only likely to grow over the next decade.
  prefs: []
  type: TYPE_NORMAL
- en: With real software comes concerns about correctness. Manually testing software
    is painful and, weirdly, error-prone. It is far cheaper and easier to produce
    unit and integration tests that run automatically and test various aspects of
    the application.
  prefs: []
  type: TYPE_NORMAL
- en: There are countless tools available for testing JavaScript, from test runners
    to testing frameworks; the ecosystem is a rich one. We'll try to maintain a more
    or less tool-agnostic approach to testing in this chapter. This module does not
    concern itself with which framework is the best or friendliest. There are overarching
    patterns that are common to testing as a whole. It is those that we'll examine.
    We will touch on some specific tools but only as a shortcut to having to write
    all our own testing tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we''ll look at the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Fake objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monkey patching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interacting with the user interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The testing pyramid
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We computer programmers are, as a rule, highly analytical people. This means
    that we're always striving to categorize and understand concepts. This has led
    to our developing some very interesting global techniques that can be applied
    outside computer programming. For instance, agile development has applications
    in general society but can trace its roots back to computing. One might even argue
    that the idea of patterns owes much of its popularity to it being used by computer
    programmers in other walks of life.
  prefs: []
  type: TYPE_NORMAL
- en: 'This desire to categorize has led to the concept of testing code being divided
    up into a number of different types of tests. I''ve seen as many as eight different
    categories of tests from unit tests, right the way up to workflow tests and GUI
    tests. This is, perhaps, an overkill. It is much more common to think about having
    three different categories of test: unit, integration, and user interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The testing pyramid](img/00095.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Unit tests form the foundation of the pyramid. They are the most numerous,
    the easiest to write, and the most granular in the errors they give. An error
    in a unit test will allow you to find the individual method that has an error
    in it. As we move up the pyramid, the number of tests falls along with the granularity
    while the complexity of each test increases. At a higher level, when a test fails
    we might only be able to say: "There is an issue with adding an order to the system".'
  prefs: []
  type: TYPE_NORMAL
- en: Testing in the small with unit tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To many, unit testing is a foreign concept. This is understandable as it is
    a topic which is poorly taught in many schools. I know that I've done six years
    of higher education in computing science without it being mentioned. It is unfortunate
    because delivering a quality product is a pretty important part of any project.
  prefs: []
  type: TYPE_NORMAL
- en: For those who know about unit testing, there is a big barrier to adoption. Managers,
    and even developers, frequently see unit testing, and automated testing as a whole,
    as a waste of time. After all you cannot ship a unit test to your customer nor
    do most customers care whether their product has been properly unit tested.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unit testing is notoriously difficult to define. It is close enough to integration
    testing that people slip back and forth between the two easily. In the seminal
    book; *The Art of Unit Testing*, *Roy Osherove*, the author defines a unit test
    as:'
  prefs: []
  type: TYPE_NORMAL
- en: '*A unit test is an automated piece of code that invokes a unit of work in the
    system and then checks a single assumption about the behavior of that unit of
    work.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The exact size of a unit of work is up for some debate. Some people restrict
    it to a single function or a single class, while others allow a unit of work to
    span multiple classes. I tend to think that a unit of work that spans multiple
    classes can actually be broken into smaller, testable units.
  prefs: []
  type: TYPE_NORMAL
- en: The key to unit testing is that it tests a small piece of functionality and
    it quickly tests the functionality in a repeatable, automated fashion. Unit tests
    written by one person should be easily runnable by any other member of the team.
  prefs: []
  type: TYPE_NORMAL
- en: For unit testing we want to test small pieces of functionality because we believe
    that if all the components of a system work correctly then the system as a whole
    will work. This is not the whole truth. The communication between modules is just
    as likely to fail as a function within the unit. This is why we want to write
    tests on several levels. Unit tests check that the code we're writing right now
    is correct. Integration testing tests entire workflows through the application
    and will uncover problems in the interaction of units.
  prefs: []
  type: TYPE_NORMAL
- en: The test-driven development approach suggests writing tests at the same time
    as we write code. While this gives us great confidence that the code we're writing
    is correct, the real advantage is that it helps drive good architecture. When
    code has too many interdependencies it is far harder to test than well-separated
    modular code. A lot of the code that developers write goes unread by anybody ever
    again. Unit tests provide a useful way of keeping developers on the right path
    even in cases where they know that nobody will ever see their code. There is no
    better way to produce a quality product than to tell people they are going to
    be checked on it, even if the checker happens to be an automated test.
  prefs: []
  type: TYPE_NORMAL
- en: Tests can be run both while developing new code and in an automatic fashion
    on the build machines. If every time a developer checks in a change, the entire
    project is built and tested, then some reassurance can be provided that the newly
    checked-in code is correct. From time to time the build will break and that will
    be a flag that something that was just added was in error. Often the code that
    is broken may not even be proximal to the code changed. An altered return value
    may percolate through the system and manifest itself somewhere wholly unexpected.
    Nobody can keep anything more than the most trivial system in their mind at any
    one time. Testing acts as a sort of second memory, checking and rechecking assumptions
    made previously.
  prefs: []
  type: TYPE_NORMAL
- en: Failing the build as soon as an error occurs shortens the time it takes between
    an error being made in the code and it being found and fixed. Ideally the problem
    will still be fresh in the developer's mind so the fix can easily be found. If
    the errors were not discovered until months down the road, the developer will
    certainly have forgotten what s/he was working on at the time. The developer may
    not even be around to help solve the problem, throwing somebody who has never
    seen the code in to fix it.
  prefs: []
  type: TYPE_NORMAL
- en: Arrange-Act-Assert
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When building tests for any piece of code, a very common approach to follow
    is that of Arrange-Act-Assert. This describes the different steps that take place
    inside a single unit test.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we do is set up a test scenario (arrange). This step can consist
    of a number of actions and may involve putting in place fake objects to simulate
    real objects as well as creating new instances of the subject under test. If you
    find that your test setup code is long or involved, it is likely a smell and you
    should consider refactoring your code. As mentioned in the previous section, testing
    is helpful for driving not just correctness but also architecture. Difficult-to-write
    tests are indicative that the architecture is not sufficiently modular.
  prefs: []
  type: TYPE_NORMAL
- en: Once the test is set up then the next step is to actually execute the function
    we would like to test (act). The act step is usually very short, in many cases
    no more than a single line of code.
  prefs: []
  type: TYPE_NORMAL
- en: The final part is to check to make sure that the result of the function or the
    state of the world is as you would expect (assert).
  prefs: []
  type: TYPE_NORMAL
- en: 'A very simple example of this might be a castle builder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This class simply builds a new castle of a specific size. We want to make sure
    that no shenanigans are going on and that when we build a castle of size `10`
    we get a castle of size `10`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Assert
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You may have noticed that in the last example we made use of a function called
    `assertEquals`. Anassert is a test that, when it fails, throws an exception. There
    is currently no built-in assert functionality in JavaScript, although there is
    a proposal in the works to add it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, building an assert is pretty simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: It is helpful to mention, in the error, the actual value as well as the expected
    value.
  prefs: []
  type: TYPE_NORMAL
- en: There is a great number of assertion libraries in existence. Node.js ships with
    one, creatively called `assert.js`. If you end up using a testing framework for
    JavaScript it is likely that it will also contain an assertion library.
  prefs: []
  type: TYPE_NORMAL
- en: Fake objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we think of the interdependencies between objects in an application as a
    graph it becomes quickly apparent that there are a number of nodes that have dependencies
    on, not just one, but many other objects. Attempting to place an object with a
    lot of dependencies under test is challenging. Each of the dependent objects must
    be constructed and included in the test. When these dependencies interact with
    external resources such as the network or file system, the problem becomes intractable.
    Pretty soon we're testing the entire system at a time. This is a legitimate testing
    strategy, known as **integration testing**, but we're really just interested in
    ensuring that the functionality of a single class is correct.
  prefs: []
  type: TYPE_NORMAL
- en: Integration testing tends to be slower to execute than unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'The subject of a test can have a large dependency graph that makes testing
    it difficult. You can see an example here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Fake objects](img/00096.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We need to find a way to isolate the class under test so that we don''t have
    to recreate all the dependencies, including the network. We can think of this
    approach as adding bulkheads to our code. We will insert bulkheads to stop tests
    from flowing over from one class to many. These bulkheads are similar to how oil
    tankers maintain separation to limit the impact of spills and maintain weight
    distribution as can be seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Fake objects](img/00097.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '*Image courtesy of [http://www.reactivemanifesto.org/](http://www.reactivemanifesto.org/).'
  prefs: []
  type: TYPE_NORMAL
- en: To this end we can use fake objects that have a limited set of functionalities
    in place of the real objects. We'll look at three different methods of creating
    fake objects.
  prefs: []
  type: TYPE_NORMAL
- en: The first is the, rather niftily named, test spy.
  prefs: []
  type: TYPE_NORMAL
- en: Test spies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A spy is an approach that wraps all the methods of an object and records the
    inputs and outputs from that method as well as the number of calls. By wrapping
    the calls, it is possible to examine exactly what was passed in and what came
    out of the function. Test spies can be used when the exact inputs into a function
    are not known beforehand.
  prefs: []
  type: TYPE_NORMAL
- en: In other languages, building test spies requires reflection and can be quite
    complicated. We can actually get away with making a basic test spy in no more
    than a couple of lines of code. Let's experiment.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start we''ll need a class to intercept:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we would like to spy on this function. Because functions are first class
    objects in JavaScript we can simply rejigger the `SpyUpon` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we take the existing function and give it a new name. Then we create a
    new function that calls the renamed function and also records some things. After
    the function has been called we can examine the various properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this code in node gets us the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Using this technique, it is possible to get all sorts of insight into how a
    function is used. There are a number of libraries that support creating test spies
    in a more robust way than our simple version here. Some provide tools for recording
    exceptions, the number of times called, and the arguments for each call.
  prefs: []
  type: TYPE_NORMAL
- en: Stubs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **stub** is another example of a fake object. We can use stubs when we have
    some dependencies in the subject under test that need to be satisfied with an
    object that returns a value. They can also be used to provide a bulkhead to stop
    computationally expensive or I/O reliant functions from being run.
  prefs: []
  type: TYPE_NORMAL
- en: Stubs can be implemented in much the same way that we implemented spies. We
    just need to intercept the call to the method and replace it with a version that
    we wrote. However, with stubs we actually don't call the replaced function. It
    can be useful to keep the replaced function around just in case we need to restore
    the functionality of the stubbed out class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with an object that depends on another object for part of its
    functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This knight object takes a `credentialFactory` argument as part of its constructor.
    By passing in the object we exteriorize the dependency and remove the responsibility
    for creating `credentialFactory` from the knight. We've seen this sort of inversion
    of control previously and we'll look at it in more detail in the next chapter.
    This makes our code more modular and testing far easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now when we want to test the knight without worrying about how a credential
    factory works, we can use a fake object, in this case a stub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This stub is a very simple one that simply returns a standard new credential.
    Stubs can be made quite complicated if there need to be multiple calls to it.
    For instance, we could rewrite our simple stub as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This version of the stub returns a different sort of credential every time
    it is called. On the third call it returns null. As we set up the class using
    an inversion of control, writing a test is as simple as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now execute the test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Because there is no hard typing system in JavaScript, we can build stubs without
    worrying about implementing interfaces. There is also no need to stub an entire
    object but only the function in which we're interested.
  prefs: []
  type: TYPE_NORMAL
- en: Mock
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The final type of fake object is a **mock**. The difference between a mock
    and a stub is where the verification is done. With a stub, our test must check
    if the state is correct after the act. With a mock object, the responsibility
    for testing the asserts falls to the mock itself. Mocks are another place where
    it is useful to leverage a mocking library. We can, however, build the same sort
    of thing, simply, ourselves:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This `mockCredentialsFactory` class takes on the responsibility of verifying
    the correct functions were called. This is a very simple sort of approach to mocking
    and can be used as such:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This is a static mock that keeps the same behavior every time it is used. It
    is possible to build mocks that act as recording devices. You can instruct the
    mock object to expect certain behaviors and then have it automatically play them
    back.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax for this is taken from the documentation for the mocking library;
    Sinon. It looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Monkey patching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've seen a number of methods for creating fake objects in JavaScript. When
    creating the spy, we made use of a method called **monkey patching**. Monkey patching
    allows you to dynamically change the behavior of an object by replacing its functions.
    We can use this sort of approach without having to revert to full fake objects.
    Any existing object can have its behavior changed in isolation using this approach.
    This includes built-in objects such as strings and arrays.
  prefs: []
  type: TYPE_NORMAL
- en: Interacting with the user interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A great deal of the JavaScript in use today is used on the client and is used
    to interact with elements that are visible on the screen. Interacting with the
    page flows through a model of the page known as **Document Object Model** (**DOM**).
  prefs: []
  type: TYPE_NORMAL
- en: Every element on the page is represented in the DOM. Whenever a change is made
    to the page, the DOM is updated. If we add a paragraph to the page, then a paragraph
    is added to the DOM. Thus if our JavaScript code adds a paragraph, checking that
    it does so is simply a function of checking the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, this requires that a DOM actually exists and that it is formed
    in the same way that it is on the actual page. There are a number of approaches
    to testing against a page.
  prefs: []
  type: TYPE_NORMAL
- en: Browser testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most naïve approach is to simply automate the browser. There are a few projects
    out there that can help with this task. One can either automate a fully-fledged
    browser such as Firefox, Internet Explorer, or Chrome, or one can pick a browser
    that is headless. The fully-fledged browser approach requires that a browser be
    installed on the test machine and that the machine be running in a mode that has
    a desktop available.
  prefs: []
  type: TYPE_NORMAL
- en: Many Unix-based build servers will not have been set up to show a desktop as
    it isn't needed for most build tasks. Even if your build machine is a Windows
    one, the build account frequently runs in a mode that has no ability to open a
    window. Tests using full browsers also have a tendency to break, to my mind. Subtle
    timing issues crop up and tests are easily interrupted by unexpected changes to
    the browser. It is a frequent occurrence that manual intervention will be required
    to unstick a browser that has ended up in an incorrect state.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, efforts have been made to decouple the graphical portions of a
    web browser from the DOM and JavaScript. For Chrome this initiative has resulted
    in PhantomJS and for Firefox SlimerJS.
  prefs: []
  type: TYPE_NORMAL
- en: Typically, the sorts of test that require a full browser require some navigation
    of the browser across several pages. This is provided for in the headless browsers
    through an API. I tend to think of tests at this scale as integration tests rather
    than unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'A typical test using PhantomJS and the CasperJS library that sits on top of
    the browser might look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This would test that entering a value into the search box on Google changes
    the `aria-haspopup` property from `false` to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: Testing things this way puts a great deal of reliance on the DOM not changing
    too radically. Depending on the selectors used to find elements on the page, a
    simple change to the style of the page could break every test. I like to keep
    tests of this sort away from the look of that page by never using CSS properties
    to select elements. Instead make use of IDs or, better yet, data-* attributes.
    We don't necessarily have the luxury of that when it comes to testing existing
    pages but certainly for new pages it is a good plan.
  prefs: []
  type: TYPE_NORMAL
- en: Faking the DOM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Much of the time, we don't need a full page DOM to perform our tests. The page
    elements we need to test are part of a section on the page instead of the entire
    page. A number of initiatives exist that allow for the creation of a chunk of
    the document in pure JavaScript. `jsdom` for instance is a method for injecting
    a string of HTML and receiving back a fake window.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, modified slightly from their README, they create some HTML
    elements, load JavaScript, and test that it returns correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: If your JavaScript is focused on a small section of the page, perhaps you're
    building custom controls or web components, then this is an ideal approach.
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping the manipulation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The final approach to dealing with graphical JavaScript is to stop interacting
    directly with elements on the page. This is the approach that many of the more
    popular JavaScript frameworks of today use. One simply updates a JavaScript model
    and this model then updates the page through the use of some sort of MV* pattern.
    We looked at this approach in some detail some chapters ago.
  prefs: []
  type: TYPE_NORMAL
- en: Testing in this case becomes quite easy. Our complicated JavaScript can simply
    be tested by building a model state prior to running the code and then testing
    to see if the model state after running the code is as we expect.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example we could have a model that looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The test code for it might look as simple as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: As everything on the page is manipulated, through the bindings to the model,
    we can be confident that changes in the model are correctly updating the page.
  prefs: []
  type: TYPE_NORMAL
- en: Some would argue that we've simply shifted the problem. Now the only place for
    errors is if the binding between the HTML and the model is incorrect. So we also
    need to test if we have bindings correctly applied to the HTML. This falls to
    higher-level testing that can be done more simply. We can cover far more with
    a higher-level test than with a lower-level one, although at the cost of knowing
    exactly where the error occurred.
  prefs: []
  type: TYPE_NORMAL
- en: You're never going to be able to test everything about an application but the
    smaller you can make the untested surface, the better.
  prefs: []
  type: TYPE_NORMAL
- en: Tips and tricks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I have seen tests where people split up the Arrange-Act-Assert by putting in
    place comments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: You're going to wear your fingers to the bone typing those comments for every
    single test. Instead I just split them up with a blank line. The separation is
    clear and anybody who knows Arrange-Act-Assert will instantly recognize what it
    is that you're doing. You'll have seen the example code in this chapter split
    up in this fashion.
  prefs: []
  type: TYPE_NORMAL
- en: There are countless JavaScript testing libraries available to make your life
    easier. Choosing one may depend on your preferred style. If you like a gherkin-style
    syntax then cuumber.js might be for you. Otherwise try mocha, either on its own,
    or with the chai BDD style assertion library , which is is fairly nice. There
    are also testing frameworks such as Protractor which are specific to Angular apps
    (although you can use it to test other frameworks with a bit of work). I'd suggest
    taking a day and playing with a few to find your sweet spot.
  prefs: []
  type: TYPE_NORMAL
- en: When writing tests, I tend to name them in a way that makes it obvious that
    they are tests and not production code. For most JavaScript I follow camel case
    naming conventions such as `testMapping`. However, for test methods I follow an
    underscored naming pattern `When_building_a_castle_size_should_be_correctly_set`.
    In this way the test reads more like a specification. Others have different approaches
    to naming and there is no "right" answer, so feel free to experiment.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Producing a quality product is always going to require extensive and repeated
    testing; this is exactly the sort of thing computers are really good at. Automate
    as much as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Testing JavaScript code is an up-and-coming thing. The tooling around, mocking
    out objects, and even the tools for running tests are undergoing constant changes.
    Being able to use tools such as Node.js to run tests quickly and without having
    to boot up an entire browser is stunningly helpful. This is an area that is only
    going to improve over the next few years. I am enthused to see what changes come
    from it.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter we'll take a look at some advanced patterns in JavaScript
    that you might not want to use every day but are very handy.
  prefs: []
  type: TYPE_NORMAL
