- en: Type Checking Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To be able to leave your application working and forget about any troubles,
    you need a way to make sure that all parts of your application match each other.
    Languages built on top of JavaScript or ECMAScript, such as Flow or TypeScript,
    bring type systems to your application. Thanks to these, you will know that no
    one is sending the wrong data to your functions or components. We have already
    used `PropTypes` for assertions in components. Now we will apply this concept
    to any JavaScript variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn about the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The basics of type systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to assign types to functions and variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What contract tests are; for instance, the Pact test
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generics and union types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tips on how to solve type problems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How type systems use nominal and structural typing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In ECMAScript, we have seven implicit types. Six of them are primitives.
  prefs: []
  type: TYPE_NORMAL
- en: 'The six data types that are primitives are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Boolean.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Number.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: String.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Null.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Undefined.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Symbol—a unique identifier introduced in ECMAScript. Its purpose is to guarantee
    uniqueness. This is used commonly as a unique key in objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The seventh type is objects.
  prefs: []
  type: TYPE_NORMAL
- en: Functions and arrays are also objects. Generally, anything that is not a primitive
    type is an object.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever you assign a value to a variable, the type is automatically determined.
    Based on the type, there are some rules that apply.
  prefs: []
  type: TYPE_NORMAL
- en: Primitive function arguments are passed by value. Objects are passed by reference.
  prefs: []
  type: TYPE_NORMAL
- en: Every variable is stored in memory in the form of zeros and ones. Passing by
    value means that the called function parameter will be copied. This means the
    creation of a new object that has a new reference. Passing by reference means
    passing just the reference to the object—if somebody makes changes to the referenced
    memory, then it will affect everyone who uses this reference.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the examples of the mechanism of passing by value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `num` variable has not been changed because, on function call, the value
    was copied. The `x` variable referenced a completely new variable in the memory.
    Let''s now look at a similar example, but with an object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This time, we passed the `numObj` object to the function. It has been passed
    by reference, and so was not copied. When we changed the `obj` variable, it affected
    `numObj` externally.
  prefs: []
  type: TYPE_NORMAL
- en: However, when we invoke the preceding functions, we do not check the types.
    By default, we can pass anything. If our function cannot handle the passed variable,
    then it will break with some kind of error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at the hidden and unexpected behavior that may occur with
    usage of the `increase` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `increase` function computes `51` when we add `"5"` and `1`. This is how
    JavaScript works—it does implicit type conversion to be able to perform an operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Do we have a way to prevent this and save developers from accidental mistakes?
    Yes, we can do a runtime check to reassess that the variable is of a certain type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: A runtime check is a check that is performed while the code is evaluated. It
    is part of the code execution phase and affects the application speed. We will
    look more closely at runtime checking later on in this chapter, in the section
    on solving problems in runtime validation.
  prefs: []
  type: TYPE_NORMAL
- en: When the `Error` message is thrown, we also need to use error boundaries for
    component replacement or some `try{}catch(){}` syntax for handling async code
    errors.
  prefs: []
  type: TYPE_NORMAL
- en: If you did not read this book from the beginning, then you may find it handy
    to go back to [Chapter 2](89d7ff7d-4e5b-4f17-b8f7-8d9b3574d197.xhtml), *View Patterns*,
    to learn more about error boundaries in React.
  prefs: []
  type: TYPE_NORMAL
- en: However, we did not check if the `obj` variable is of the `Object` type! Such
    runtime checks can be added, but let's look at something much more convenient—TypeScript, the
    type checking language built on top of JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to TypeScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'TypeScript brings types to our code. We can explicitly express the requirement
    that a function accepts only a specific variable type. Let''s look at how we could
    use the example from the previous section with types from TypeScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This code will not compile. The static check will exit with an error saying
    that the code base is corrupted because types do not match.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following error will be shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: TypeScript has caught us red-handed. We need to fix the error. Such code will
    never reach the end user until the developer fixes the error.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring TypeScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For your convenience, I have configured TypeScript in our repository. You can
    check it under `src/Chapter 11/Example 1` in the code files.
  prefs: []
  type: TYPE_NORMAL
- en: There are a few things I want you to understand.
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript comes with its own configuration file, called `tsconfig.json`. In
    this file, you will find multiple configuration properties that control how strict
    the TypeScript compiler is. You can find a detailed list of the properties and
    explanations in the official documentation at [https://www.typescriptlang.org/docs/handbook/compiler-options.html](https://www.typescriptlang.org/docs/handbook/compiler-options.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Among the options, you can find `outDir`. This specifies where the compiler
    output should be saved. In our repository, it is set to `"outDir": "build/dist"`.
    Our application, from now on, will run the compiled code from the `build/dist`
    directory. Hence, I have changed the root `App.js` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now that you understand the configuration changes, we can now proceed with learning
    basic typing.
  prefs: []
  type: TYPE_NORMAL
- en: Learning the basic types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To get the most out of TypeScript, you should type as much code as possible.
    However, our application did not have types before. In the case of a large application,
    you obviously cannot suddenly add types everywhere. Hence, we will gradually increase
    application type coverage.
  prefs: []
  type: TYPE_NORMAL
- en: 'TypeScript''s list of basic types is quite long—Boolean, number, string, array,
    tuple, enum, any, void, null, undefined, never, and object. If you are unfamiliar
    with any of the them, then kindly please check the following page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.typescriptlang.org/docs/handbook/basic-types.html](https://www.typescriptlang.org/docs/handbook/basic-types.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, let''s look at one of the components that we used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We will now switch to TypeScript. Let''s start with the `Prop` types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In these little examples, we have defined the structure of the `NavigationButton`
    props. The `data` prop is of the `any` type, as we do not control what kind of
    data is being passed.
  prefs: []
  type: TYPE_NORMAL
- en: The `navigation` prop uses types defined by the `react-navigation` library.
    This is crucial to reuse already exposed types. In the project files, I have installed
    the `react-navigation` types using the `yarn add @types/react-navigation` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can proceed with adding types to `NavigationButton`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '`SFC` type is exported by React library. It is a generic type that can accept
    any possible prop types definition. Hence, we need to specify what kind of prop
    type it is: `SFC<NavigateButtonProps>`.'
  prefs: []
  type: TYPE_NORMAL
- en: That's it—we also need to remove the old `NavigateButton.propTypes` definition
    at the bottom. From now on, TypeScript will validate the types passed on the `NavigateButton`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: enums and constants patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is a concept that is long praised in any code base I have seen: constants.
    They save so much value that almost everybody agrees that it is a must to define
    variables that hold a specific constant value. If, instead, we copied it to every
    single place where we need them, it would be much harder to update the value.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Some constants need to be flexible, hence, wise developers extract them to
    configuration files. Such files are stored in the code base, and sometimes in
    many different flavors (for instance, for test: `dev`, quality assurance, and
    production environments).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In many cases, the constants we define allow only a constant set of valid values.
    For instance, if we were to define available environments, then we could create
    a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In old-school programming in JavaScript, you would simply `switch-case` the
    environments and propagate relevant information to the specific objects in your
    application. If the environment was unrecognized, then if would fall into a default
    clause where it usually simply throws an error saying "unrecognized environment"
    and closes the application.
  prefs: []
  type: TYPE_NORMAL
- en: If you assume that, in TypeScript, you would not need to check such things,
    you are wrong. Whatever you consume from the outside needs runtime validation.
    You cannot allow JavaScript to fail on its own and blow up the application in
    an unpredictable manner. This is a huge "gotcha" that is often overlooked.
  prefs: []
  type: TYPE_NORMAL
- en: One of the most common problems you may run into is API change. If you expect
    the `http://XYZ` endpoint to return JSON with the `tasks` key, and you do not
    validate what was really returned to you, you are in trouble. For instance, if
    a separate team decides to change the key to `projectTasks`, and is not aware
    of your dependency on `tasks`, it will surely lead to problems. How can we fix
    this?
  prefs: []
  type: TYPE_NORMAL
- en: The expected return values on your APIs is quite easy to enforce. A long time
    ago, the term contract tests was developed. This means creating a contract in
    both frontend and backend systems. Contracts cannot be changed without reassuring
    both code bases are ready. This is usually enforced by some automation tool, one
    of which may be Pact tests.
  prefs: []
  type: TYPE_NORMAL
- en: '"**Pact** (noun):'
  prefs: []
  type: TYPE_NORMAL
- en: A formal agreement between individuals or parties. "The country negotiated a
    trade pact with the US.
  prefs: []
  type: TYPE_NORMAL
- en: 'Synonyms: agreement, protocol, deal, contract"'
  prefs: []
  type: TYPE_NORMAL
- en: - [Oxford Dictionaries (https://en.oxforddictionaries.com/definition/pact)](https://en.oxforddictionaries.com/definition/pact).
  prefs: []
  type: TYPE_NORMAL
- en: If you look for a way to enforce this programmatically, have a look at [https://github.com/pact-foundation/pact-js](https://github.com/pact-foundation/pact-js).
    This topic is tough and also requires knowledge of  backend languages, hence it
    is out of this book's scope.
  prefs: []
  type: TYPE_NORMAL
- en: Once we are 100% sure that outside world data is validated, we may want to ensure
    that our own computations never lead to changing the variables (for instance,
    through immutability, see [Chapter 9,](0577761c-9fca-49f2-98ad-2d217e00e974.xhtml) *Elements
    of Functional Programming Patterns*) or if the change is expected, that it will
    always retain a value of the allowed set.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is when TypeScript comes in handy. You can ensure that your computations
    will always lead to the one of the allowed states. You will not need any runtime
    validation. TypeScript will save you from unnecessary checks that, in large amounts,
    could result in slowing your app by a few miliseconds. Let''s see how we can do
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We have defined an `enum` type. If the variable is expected to be of the `TasksActionType`
    type, it can only be assigned the values from the preceding `enum TasksActionType`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now define `AddTaskActionType`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'It will be used in the `addTask` action creator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now our action creator is type checked very well. If any developer, by mistake,
    changes the `type` object key to any other, for instance, `TasksActionType.TASK_FETCH_COMPLETE`,
    then TypeScript will detect that and show an incompatibility error.
  prefs: []
  type: TYPE_NORMAL
- en: We have `AddTaskActionType`, but how can we combine this with other action types
    that our reducer may accept? We can use union types.
  prefs: []
  type: TYPE_NORMAL
- en: Creating union types and intersections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A union type describes a value that can be one of several types. This is a
    great fit for our `Tasks` reducer type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The union type is created with the `**|**` operator. It works just as if it
    was `|` was `or`. One type or another.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now use the previous type in the `Reducer` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: To make TypeScript happy, we need to add types to all of the parameters. Hence,
    I have added the rest of the types. One of them is still missing: `TaskType`.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding code example, you may be surprised by the `Immutable.List<TaskType>`
    notation, and especially the `< >` signs. Those need to be used because `List`
    is a generic type. We will talk about generic types in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create `TaskType`, we could just write its type as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: However, this is not reusing the type we have already created: `TaskAddFormData`.
    Whether you want to do so is a topic for another discussion. Let's assume we want
    to.
  prefs: []
  type: TYPE_NORMAL
- en: 'To reuse existing type and declare or create `TaskType` in the desired shape,
    we will need to use an intersection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we used the `&` intersection operator to create a new type.
    The created type is an intersection of the types from the left-hand side and right-hand
    side of the  `&` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/7683edab-1560-4008-9969-33e9e76d8ef9.png)'
  prefs: []
  type: TYPE_IMG
- en: An intersection diagram, where the intersection is the space that is both in
    circle A and in circle B
  prefs: []
  type: TYPE_NORMAL
- en: 'An intersection of **A** and **B** possesses both the properties of **A** and
    **B**. Hence, the type that is created by an intersection of type **A** and type
    **B** must have both type **A** types and type **B** types. To summarize,  `TaskType` must
    now be of the following shape:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, intersections may be handy. Sometimes, when we rely on external
    libraries, we don''t want to hardcode the key types as in the previous examples.
    Let''s look at it again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The navigation key is hardcoded in our type. We could have used an intersection
    to comply with possible future changes of the external library shape:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we use the `<>` signs again. These are needed because `NavigationInjectedProps`
    is a generic type. Let's learn what generic types are.
  prefs: []
  type: TYPE_NORMAL
- en: Generic types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Generics allow you to write code that will handle any type of object. For instance,
    you know that a list is a generic type. You can make a list of anything. Hence,
    when we used `Immutable.List`, we had to specify what kind of objects the list
    will consist of:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: List of tasks. Let's now create our own generic type.
  prefs: []
  type: TYPE_NORMAL
- en: In our code base, we have one util that is supposed to work with any type. It
    is a `Maybe` monad.
  prefs: []
  type: TYPE_NORMAL
- en: If you have jumped to this chapter, then you may find it handy to read about
    monad patterns in [Chapter 9](0577761c-9fca-49f2-98ad-2d217e00e974.xhtml), *Elements
    of Functional Programming Patterns*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Maybe` monad is either `Nothing`, when the variable happens to be `null`,  `undefined`,
    or `Something` of that type. This is a perfect fit for generic types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The tricky part is implementing `Something<T>` and `Nothing`. Let''s start
    with `Nothing`, as it is much easier. It should return `null` on value check and
    always map to itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '`Something<T>` should map to either `Something<MappingResult>` or `Nothing`.
    The value check should return `T`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Mapping the result type is saved by using the `Z` generic type that is introduced
    in the `map` function signature.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if we try to use our newly defined types, they will not work. Unfortunately,
    TypeScript does not always figure out union types correctly. This problem occurs
    when union of types leads to different call signatures per specific key. In our
    case, this happens with the `map` function. Its type is `(args: any) => Nothing`
    or `<Z>(fn: ((a:T) => Z)) => MaybeType<Z>`. Hence, `map` has no compatible call
    signature.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The quick fix to this problem is defining a standalone `MaybeType` that satisfies
    two conflicting type definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'With such a type definition, we can proceed to use the new generic type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The selector function takes `TasksState` as an argument and is expected to return
    a map that is assigned to the `tasks` key within the state. It may look a little
    tough to understand, hence, I highly recommend you to open the previous file and
    have a longer look. If you struggle, in the *Further reading* section at the end
    of the chapter, I have included a reference to an issue on GitHub that discusses
    this in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding TypeScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we ran into a problem that is quite tough to understand
    if you have never worked with type systems. Let's learn a little bit about TypeScript
    itself to understand this better.
  prefs: []
  type: TYPE_NORMAL
- en: Type inference
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The very first thing I want you to understand is type inference. You do not
    need to type everything. Some types can be inferred by TypeScript.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine a situation where I have told you, "I have put only chocolate donuts
    in the box on your desk." Since, in this example, I pretend to be the computer,
    you can trust me. Hence, when you arrive at your desk, you are 100% sure that
    the box is of the `Box<ChocolateDonut[]>` type. You know this without opening
    the box or having an explicit sticker on it that says *Box full of chocolate donuts*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a real code, it works very similarly. Let''s look at the following minimal
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This is trivial. We can now look at something that I like more, `ChocolateDonuts`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we exercise both the `enum` and generic types. The `clone`
    simply clones any type into a brand new one and delegates to JSON functions: `stringify` and
    then `parse`. The `ProduceBox` function simply takes a recipe and creates an array
    of clones based on that recipe. In the end, we create a box of chocolate donuts.
    The type is correctly inferred because we have specified a generic type for `produceBox`.'
  prefs: []
  type: TYPE_NORMAL
- en: Structural typing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'TypeScript uses structural typing. To understand what that means, let''s look
    at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we first declare the `p` variable, and then assign a new instance
    of `ChocolateDonut` to it. It works in TypeScript. It wouldn't work in Java. Why?
  prefs: []
  type: TYPE_NORMAL
- en: 'We have never explicitly indicated that `ChocolateDonut` implements the `Donut`
    interface. If TypeScript did not use structural typing, you would need to refactor
    part of the preceding code to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The reasoning behind using structural typing is often referred as duck-typing:'
  prefs: []
  type: TYPE_NORMAL
- en: If it walks like a duck and it quacks like a duck, then it must be a duck.
  prefs: []
  type: TYPE_NORMAL
- en: Hence, `implements Donut` is not required in TypeScript, because `ChocolateDonut`
    already behaves like a donut, so it must be a donut. Hurray!
  prefs: []
  type: TYPE_NORMAL
- en: Immutability with TypeScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, I want to reiterate a point on immutability. This topic is
    huge in JavaScript, and in some cases, TypeScript may be a much better solution
    than any other path to immutability.
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript comes with the special `readonly` keyword that enforces that a certain
    variable is read-only. You cannot mutate such a variable. This is enforced at
    compile time. Hence, you have no runtime checks for immutability. If this is a
    huge win for you, then you may not even need any API, such as Immutable.js. Immutable.js
    shines when you are required to clone huge objects to avoid mutations. If you
    can get away with a spread operation on your own, then it means your object may
    not be big enough for Immutable.js.
  prefs: []
  type: TYPE_NORMAL
- en: readonly
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since our application is not super big yet, as an exercise, let''s replace
    Immutable.js with `readonly` from TypeScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'This looks like a lot of repetition. We can use `Readonly< T >` instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This looks much cleaner. However, it is not entirely immutable. You can still
    mutate the `entities` array. To prevent that, we need to use `ReadonlyArray<TaskType>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The remaining work is to replace every `TaskType[]`  with `ReadonlyArray<TaskType>` throughout
    the entire application. Then you will need to change Immutable.js objects into
    standard JavaScript arrays. Such a refactor is long and does not fit in these
    book pages, but I have done the refactor in the code files. If you want to see
    what has changed, go to the code files directory at `src/Chapter_11/Example_5`.
  prefs: []
  type: TYPE_NORMAL
- en: Using linter to enforce immutability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may use the TypeScript linter to enforce the `readonly` keyword in TypeScript
    files. One of the open source solutions that allows you to do this is `tslint-immutable`.
  prefs: []
  type: TYPE_NORMAL
- en: 'It adds additional rules to the `tslint.json` configuration file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'From now on, when you run linter, you will see errors if you violate any of
    the preceding rules. I have refactored the code to comply with them. Check the
    full example in code files directory at `src/Chapter_11/Example_6`. To run linter,
    you may use the following command in the Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you have learned about a very powerful tool: typed language
    built on top of JavaScript. Type checking has countless advantages for any code
    base. It prevents you from deploying a breaking change that definitely does not
    comply with what is expected. You have learned how to tell TypeScript what is
    allowed. You know what generic types are, and how to use them to reduce code repetition
    in typed files.'
  prefs: []
  type: TYPE_NORMAL
- en: New tools come with new knowledge, so you have also learned the basics of type
    inference and structural typing. This part of TypeScript definitely requires trial
    and error. Practice it to understand it better.
  prefs: []
  type: TYPE_NORMAL
- en: This is the last chapter of this book. I hope you have learned many interesting
    concepts and patterns. I have challenged you throughout this book; now it is time
    that you challenged your code base. See what fits your application and maybe rethink
    the choices you and your team made before.
  prefs: []
  type: TYPE_NORMAL
- en: Don't worry if you do not understand some patterns. Not all of them are a must.
    Some come with experience, some apply only to large code bases, and some are a
    matter of preference.
  prefs: []
  type: TYPE_NORMAL
- en: Choose the patterns that guarantee application correctness, as well as ones
    that enable you to add customer value more quickly. Good luck!
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Mastering TypeScript (Second edition),* Nathan Rozentals: This is a great
    book to learn TypeScript in depth. It demonstrates how to type some really advanced
    use cases. This is my personal recommendation, not the publisher''s.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Official documentation for TypeScript can be found at [www.typescriptlang.org](http://www.typescriptlang.org).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The discussion of the call signatures issue, mentioned previously in this chapter,
    can be found in the TypeScript GitHub repository at [https://github.com/Microsoft/TypeScript/issues/7294](https://github.com/Microsoft/TypeScript/issues/7294).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
