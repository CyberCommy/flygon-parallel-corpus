- en: Laying a Foundation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is largely devoted to the fundamental building blocks that are
    core elements of the Kotlin programming language. Each one may seem insignificant
    by itself, but combined together, they create really powerful language constructs.
    We will discuss the Kotlin type system that introduces strict null safety and
    smart casts. Also we will see a few new operators in the JVM world, and many improvements
    compared to Java. We will also present new ways to handle application flows and
    deal with equality in a unified way.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Variables, values, and constants
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type inference
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Strict null safety
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Smart casts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kotlin data types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Control structures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exceptions handling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Kotlin, we have two types of variables: `var` or `val` . The first one,
    `var` , is a mutable reference (read-write) that can be updated after initialization.
    The `var` keyword is used to define a variable in Kotlin. It is equivalent to
    a normal (non-final) Java variable. If our variable needs to change at some time,
    we should declare it using the `var` keyword. Let''s look at an example of a variable
    declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Create fruit variable and initialize it with variable `orange` value
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Reinitialize fruit variable with with `banana` value
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The second type of variable is a read-only reference. This type of variable
    cannot be reassigned after initialization.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `val` keyword can contain a custom getter, so technically it can return
    different objects on each access. In other words, we can''t guarantee that the
    reference to the underlying object is immutable:'
  prefs: []
  type: TYPE_NORMAL
- en: '`val random: Int`'
  prefs: []
  type: TYPE_NORMAL
- en: '`get() = Random().nextInt()`'
  prefs: []
  type: TYPE_NORMAL
- en: Custom getters will be discussed in more detail in Chapter 4, *Classes and Objects*
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'The `val` keyword is equivalent of a Java variable with the `final` modifier.
    Using immutable variables is useful, because it makes sure that the variable will
    never be updated by mistake. The concept of *immutability* is also helpful for
    working with multiple threads without worrying about proper data synchronization.
    To declare immutable variables, we will use the `val` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Create fruit variable and initialize it with string `orange` value
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compiler will throw an error, because fruit variable was already initialized
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Kotlin also allows us to define variables and functions at the level of the
    file. We will discuss it further in [Chapter 3](text00073.html) , *Playing with
    Functions* .
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that the type of the variable reference (`var` , `val` ) relates to
    the reference itself, not the properties of the referenced object. This means
    that when using a read-only reference (`val` ), we will not be able to change
    the reference that is pointing to a particular object instance (we will not be
    able to reassign variable values), but we will still be able to modify properties
    of referenced objects. Let''s see it in action using an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Initialize mutable list
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compiler will throw an error, because value reference cannot be changed (reassigned)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compiler will allow to modify content of the list
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The keyword `val` cannot guarantee that the underlying object is immutable.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we really want to make sure that the object will not be modified, we must
    use immutable reference and an immutable object. Fortunately, Kotlin''s standard
    library contains an immutable equivalent of any collection interface (`List` versus
    `MutableList` , `Map` versus `MutableMap` , and so on) and the same is true for
    helper functions that are used to create instance of particular collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Variable/value definition** | **Reference can change** | **Object state
    can change** |'
  prefs: []
  type: TYPE_TB
- en: '| `val = listOf(1,2,3)` | No | No |'
  prefs: []
  type: TYPE_TB
- en: '| `val = mutableListOf(1,2,3)` | No | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| `var = listOf(1,2,3)` | Yes | No |'
  prefs: []
  type: TYPE_TB
- en: '| `var = mutableListOf(1,2,3)` | Yes | Yes |'
  prefs: []
  type: TYPE_TB
- en: Type inference
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we saw in previous examples, unlike Java, the Kotlin type is defined after
    variable name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'At first glance, this may look strange to Java developers, but this construct
    is a building block of a very important feature of Kotlin called **type inference**
    *.* Type inference means that the compiler can infer type from context (the value
    of an expression assigned to a variable). When variable declaration and initialization
    is performed together (single line), we can omit the type declaration. Let''s
    look at the following variable definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The type of the `title` variable is `String` , but do we really need an implicit
    type declaration to determine variable type? On the right side of the expression,
    we have a string `Kotlin` and we are assigning it to a variable `title` defined
    on the left-hand side of the expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'We specified a variable type as `String` , but it was obvious, because this
    is the same type as the type of assigned expression (`Kotlin` ). Fortunately,
    this fact is also obvious for the Kotlin compiler, so we can omit type when declaring
    a variable, because the compiler will try to determine the best type for the variable
    from the current context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Keep in mind, that type declaration is omitted, but the type of variable is
    still implicitly set to `String` , because Kotlin is a strongly typed language.
    That''s why both of the preceding declarations are the same, and Kotlin compiler
    will still be able to properly validate all future usages of variable. Here is
    an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Inferred type was `String` and we are trying to assign `Int`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If we want to assign the `Int` (value `12` ) to the title variable then we
    need to specify title type to one that is a `String` and `Int` common type. The
    closest one, up in the type hierarchy is `Any` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Any is an equivalent of the Java object type. It is the root of the Kotlin type
    hierarchy. All classes in Kotlin explicitly inherit from type `Any` , even primitive
    types such as `String` or `Int`
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00021.jpg)Any defines three methods: `equals` , `toString` , and
    `hashCode` . Kotlin standard library contains a few extensions for this type.
    We will discuss extensions in [Chapter 7](text00171.html) , *Extension Functions
    and Properties* .'
  prefs: []
  type: TYPE_NORMAL
- en: 'As we can see, *type inference* is not limited to primitive values. Let''s
    look at inferring types directly from functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, the inferred type will be the same as type returned
    by the function. We may guess that it will be `Int` , but it may also be a `Double`
    , `Float` , or some other type. If it''s not obvious from the context what type
    will be inferred we can use place carrot on the variable name and run the Android
    Studio expression type command (for Windows, it is *Shift* + *Ctrl* + *P* , and
    for macOS, it is arrow key + *control* + *P* ). This will display the variable
    type in the tooltip, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00022.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'Type inference works also for generic types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Assuming that we pass only instances of the `Person` class, the inferred type
    will be `List<Person>` . The `listOf` method is a helper function defined in the
    Kotlin standard library that allow us to create collection. We will discuss this
    subject in [Chapter 7](text00171.html) , *Extension Functions and Properties*
    . Let''s look at more advanced examples that uses the Kotlin standard library
    type called `Pair` , which contains a pair composed of two values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, a `pair` instance is created using the *infix function*
    , which will be discussed in [Chapter 4](text00088.html) , *Classes and Objects*
    , but for now all we need to know is that those two declarations return the same
    type of `Pair` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Type inference works also for more complex scenarios such as inferring type
    from inferred type. Let''s use the Kotlin standard library''s `mapOf` function
    and infix the `to` method of the `Pair` class to define `map` . The first item
    in the pair will be used to infer the `map` key type; the second will be used
    to infer the value type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Generic type of `Map<String, Int>` is inferred from type of `Pair<String, Int>`
    , which is inferred from type of parameters passed to `Pair` constructor. We may
    wonder what happens if inferred type of pairs used to create `map` differs? The
    first pair is `Pair<String, Int>` and second is `Pair<String, String>` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding scenario, Kotlin compiler will try to infer common type for
    all pairs. First parameter in both pairs is `String` (`Mount Everest` , `K2` ),
    so naturally `String` will be inferred here. Second parameter of each pair differs
    (`Int` for first pair, `String` for second pair), so Kotlin needs to find the
    closest common type. The `Any` type is chosen, because this is the closest common
    type in upstream type hierarchy:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00023.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As we can see, type inference does a great job in most cases, but we can still
    choose to explicitly define a data type if we want, for example, we want different
    variable types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'When dealing with integers, the `Int` type is always a default choice, but
    we can still explicitly define different types, for example, `Short` *,* to save
    some precious Android memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, if we need to store larger values, we can define the type
    of the `age` variable as `Long` . We can use explicit type declaration as previously,
    or use *literal constant* :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Those two declarations are equal, and all of them will create variable of type
    `Long` .
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, we know that there are more cases in code where type declaration can
    be omitted to make code syntax more concise. There are however some situations
    where the Kotlin compiler will not be able to infer type due to lack of information
    in context. For example, simple declaration without assignment will make type
    inference impossible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the variable will be initialized later, so there is
    no way to determine its type. That's why type must be explicitly specified. The
    general rule is that if type of expression is known for the compiler, then type
    can be inferred. Otherwise, it must be explicitly specified. Kotlin plugin in
    Android Studio does a great job because it knows exactly where type cannot be
    inferred and then it is highlighting error. This allows us to display proper error
    messages instantly by IDE when writing the code without the need to complete application.
  prefs: []
  type: TYPE_NORMAL
- en: Strict null safety
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: According to **Agile Software Assessment** *(* [http://p3.snf.ch/Project-144126](http://p3.snf.ch/Project-144126)
    *)* research, missing null check is the most frequent pattern of bugs in Java
    systems. The biggest source of errors in Java is `NullPointerExceptions` . It's
    so big, that speaking at a conference in 2009, Sir Tony Hoare apologized for inventing
    the null reference, calling it a *billion-dollar mistake* ([https://en.wikipedia.org/wiki/Tony_Hoare](https://en.wikipedia.org/wiki/Tony_Hoare)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: To avoid `NullPointerException` , we need to write defensive code that checks
    if an object is null before using it. Many modern programming languages, including
    Kotlin, made steps to convert runtime errors into compile time errors to improve
    programming language safeness. One of the way to do it in Kotlin is by adding
    *nullability safeness mechanisms* to language type systems. This is possible because
    Kotlin type system distinguishes between references that can hold null (nullable
    references) and those that cannot (non-nullable references). This single feature
    of Kotlin allows us to detect many errors related to `NullPointerException` at
    very early stages of development. Compiler together with IDE will prevent many
    `NullPointerException` . In many cases compilation will fail instead of application
    failing at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'Strict null safety is part of Kotlin type system. By default, regular types
    cannot be null (can''t store null references), unless they are explicitly allowed.
    To store null references, we must mark variable as nullable (allow it to store
    null references) by adding question mark suffix to variable type declaration.
    Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Compiler will throw error, because this type does not allow null.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compiler will allow null assignment, because type is marked as nullable using
    question mark suffix.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We are not allowed to call method on a potentially nullable object, unless
    a nullity check is performed before a call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We will learn how to deal with the problem in the next section. Every non-nullable
    type in Kotlin has its nullable type equivalent: `Int` has `Int?` , `String` has
    `String?` and so on. The same rule applies for all classes in the Android framework
    (`View` has `View?` ), third-party libraries (`OkHttpClient` has `OkHttpClient?`
    ), and all custom classes defined by developers (`MyCustomClass` has `MyCustomClass?`
    ). This means that every non generic class can be used to define two kinds of
    types, nullable and non-nullable. A non-nullable type is also a subtype of its
    nullable equivalent. For example, `Vehicle` , as well as being a subtype of `Vehicle?`
    , is also a subtype of `Any` *:*'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00024.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `Nothing` type is an empty type (uninhabited type), which can''t have an
    instance. We will discuss it in more details in [Chapter 3](text00073.html) ,
    *Playing with Functions* . This type hierarchy is the reason why we can assign
    non-null object (`Vehicle` *)* into a variable typed as nullable (`Vehicle?` *)*
    , but we cannot assign a nullable object (`Vehicle?` *)* into a non-null variable
    (`Vehicle` ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Assignment possible
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Error because `nullableVehicle` may be a null
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will discuss ways of dealing with nullable types in following sections.
    Now let''s get back to type definitions. When defining *generic types* , there
    are multiple possibilities of defining nullability, so let''s examine various
    collection types by comparing different declarations for generic `ArrayList` containing
    items of type `Int` . Here is a table that is presents the key differences:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Type declaration** | **List itself can be null** | **Element can be null**
    |'
  prefs: []
  type: TYPE_TB
- en: '| `ArrayList<Int>` | No | No |'
  prefs: []
  type: TYPE_TB
- en: '| `ArrayList<Int>?` | Yes | No |'
  prefs: []
  type: TYPE_TB
- en: '| `ArrayList<Int?>` | No | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| `ArrayList<Int?>?` | Yes | Yes |'
  prefs: []
  type: TYPE_TB
- en: 'It''s important to understand different ways to specify null type declarations,
    because Kotlin compiler enforces it to avoid `NullPointerExceptions` . This means
    that compiler enforces nullity check before accessing any reference that potentially
    can be null. Now let''s examine common Android/Java error in the `Activity` class''
    `onCreate` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In Java, this code will compile fine and accessing null objects will result
    in application crash at runtime throwing `NullPointerException` . Now let''s examine
    the Kotlin version of the same method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '`savedInstanceState` defined as nullable `Bundle?`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compiler will throw error
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*The* `savedInstanceState` type is a platform type that can be interpreted
    by Kotlin as nullable or non-nullable. We will discuss platform types in the following
    sections, but for now we will define `savedInstanceState` as nullable type. We
    are doing so, because we know that `null` will be passed when Activity is created
    for the first time. Instance of `Bundle` will only be passed when an Activity
    is recreated using saved instance state:'
  prefs: []
  type: TYPE_NORMAL
- en: We will discuss functions in [Chapter 3](text00073.html) *, Playing with Functions*
    , but for now, we can already see that the syntax for declaring functions in Kotlin
    is quite similar to Java.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most obvious way to fix the preceding error in Kotlin is to check for nullity
    exactly the same way as in Java:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The preceding construct presents some boilerplate code, because null-checking
    is a pretty common operation in Java development (especially in the Android framework,
    where most elements are nullable). Fortunately, Kotlin allows a few simpler solutions
    to deal with nullable variables. The first one is the *safe call* operator.
  prefs: []
  type: TYPE_NORMAL
- en: Safe call
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The safe call operator is simply a question mark followed by a dot. It''s important
    to understand that safe cast operator will always return a value. If the left-hand
    side of the operator is null, then it will return null, otherwise it will return
    the result of the right-hand side expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: If `savedInstanceState` is `null` *,* then `null` will be returned, otherwise
    the result of evaluating a `savedInstanceState?.getBoolean("locked")` expression
    will be returned. Keep in mind, that a nullable reference call may always returns
    nullable, so the result of the whole expression is nullable `Boolean*?*` . If
    we want to make sure we will get non-nullable Boolean, we can combine the *safe
    call* operator combined with the *elvis* operator, discussed in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Multiple calls of the *save call* operator can be chained together to avoid
    a nested `if` expression or complex conditions like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The preceding chain works like this--`correct` will be accessed only if the
    `answer` value is not null and `answer` is accessed only if the `currentQuestion`
    value is not null. As a result, the expression will return the value returned
    by `correct property` or null if any object in the safe call chain is null.
  prefs: []
  type: TYPE_NORMAL
- en: Elvis operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The elvis operator is represented by a question mark followed by a colon (`?:`
    ) and has such syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The elvis operator works as follows: if `first operand` is not null, then this
    operand will be returned, otherwise `second operand` will be returned. The elvis
    operator allows us to write very concise code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can apply the elvis operator to our example to retrieve the variable `locked`
    *,* which will be always non-nullable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, the elvis operator will return value of `savedInstanceState?.getBoolean("locked")`
    expression if `savedInstanceState` is not null, otherwise it will return false.
    This way we can make sure that the `locked` variable. Thanks to elvis operator
    we can define default value. Also note that the right-hand side expression is
    evaluated only if the left-hand side is null. It is then providing default value
    that will be used when the expression is nullable. Getting back to our quiz example
    from the previous section, we can easily modify the code to always return a non-nullable
    value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: As the result, the expression will return the value returned by the `correct`
    property or `false` if any object in the *safe call* chain is null. This means
    that the value will always be returned, so non-nullable Boolean type is inferred.
  prefs: []
  type: TYPE_NORMAL
- en: The operator name comes from the famous American singer-songwriter Elvis Presley,
    because his hairstyle is similar to a question mark.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00025.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Not null assertion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another tool to deal with nullity is the *not-null assertion* operator. It
    is represented by a double exclamation mark (`!!` ). This operator explicitly
    casts nullable variables to non-nullable variables. Here is a usage example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Normally, we would not be able to assign a value from a nullable property `length`
    to a non-nullable variable size*.* However, as a developer, we can assure the
    compiler that this nullable variable will have a value here. If we are right,
    our application will work correctly, but if we are wrong, and the variable has
    a null value, the application will throw `NullPointerException` . Let''s examine
    our activity method `onCreate()` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code will compile, but will this code work correctly? As we said
    before, when restoring an activity instance, `savedInstanceState` will be passed
    to the `onCreate` method, so this code will work without exceptions. However,
    when creating an activity instance, the `savedInstanceState` will be null (there
    is no previous instance to restore), so `NullPointerException` will be thrown
    at runtime. This behavior is similar to Java, but the main difference is that
    in Java accessing potentially nullable objects without a nullity check is the
    default behavior, while in Kotlin we have to force it; otherwise, we will get
    a compilation error.
  prefs: []
  type: TYPE_NORMAL
- en: There are only few correct possible applications for usage of this operator,
    so when you use it or see it in code, think about it as potential danger or warning.
    It is suggested that not-null assertion should be used rarely, and in most cases
    should be replaced with safe call or smart cast.
  prefs: []
  type: TYPE_NORMAL
- en: Combating non-null assertions article presents few useful examples where non-null
    assertion operator is replaced with other, safe Kotlin constructs at [http://bit.ly/2xg5JXt](http://bit.ly/2xg5JXt)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Actually in this case there is no point of using not-null assertion operator
    because we can solve our problem in safer way using let.
  prefs: []
  type: TYPE_NORMAL
- en: Let
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another tool to deal with nullable variables is `let` . This is actually not
    the operator, nor the language special construct. It is a function defined in
    the Kotlin standard library. Let''s see the syntax of `let` combined with the
    *safe call* operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '`savedInstanceState` inside let can be accessed using variable'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: named it.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned before, the right-hand side expression of the safe call operator
    will be only be evaluated if the left-hand side is not null. In this case, the
    right-hand side is a `let` function that takes another function (lambda) as a
    parameter. Code defined in the block after `let` will be executed if `savedInstanceState`
    is not null. We will learn more about it and how to define such functions later
    in [Chapter 7](text00171.html) , *Extension Functions and Properties* .
  prefs: []
  type: TYPE_NORMAL
- en: Nullability and Java
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We know that Kotlin requires to explicitly define references that can hold null
    values. Java on the other hand, is much more lenient about nullability, so we
    may wonder how Kotlin handles types coming from Java (basically the whole Android
    SDK and libraries written in Java). Whenever possible, Kotlin compiler will determine
    type nullability from the code and represent types as actual nullable or non-nullable
    types using nullability annotations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Kotlin compiler supports several flavors of nullability annotations, including:'
  prefs: []
  type: TYPE_NORMAL
- en: Android (`com.android.annotations` and `android.support.annotations` )
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JetBrains (`@Nullable` and `@NotNull` from the `org.jetbrains.annotations` package)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JSR-305 (`Javax.annotation` )
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can find the full list in the Kotlin compiler source code ([https://github.com/JetBrains/kotlin/blob/master/core/descriptor.loader.Java/src/org/jetbrains/kotlin/load/Java/JvmAnnotationNames.kt](https://github.com/JetBrains/kotlin/blob/master/core/descriptor.loader.Java/src/org/jetbrains/kotlin/load/Java/JvmAnnotationNames.kt)
    )
  prefs: []
  type: TYPE_NORMAL
- en: 'We have seen this previously in Activity''s `onCreate` method, where the `savedInstanceState`
    type was explicitly set to the nullable type `Bundle?` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: There are, however, many situations where it is not possible to determine variable
    nullability. All variables coming from Java can be null except ones annotated
    as non-nullable.. We could treat all of them as nullable and check before each
    access, but this would be impractical. As a solution for this problem, Kotlin
    introduced the concept of *platform types.* Those are types coming from Java types
    with relaxed null checks, meaning that each platform type may be null or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although we cannot declare platform types by ourselves, this special syntax
    exists because the compiler and Android Studio need to display them sometimes.
    We can spot platform types in exception messages or the method parameters list.
    Platform type syntax is just a single exclamation mark suffix in a variable type
    declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We could treat each platform type as nullable, but type nullability usually
    depends on context, so sometimes we can treat them as non-nullable variables.
    This pseudo code shows the possible meaning of platform type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s our responsibility as developers to decide how to treat such type, as
    nullable or non-nullable. Let''s consider the usage of the `findViewById` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: What will the `findViewById` method actually return? What is the inferred type
    of the `textView` variable? Nullable type (`TestView` ) or not nullable (`TextView?`
    *)* ? By default, the Kotlin compiler knows nothing about the nullability of the
    value returned by the `findViewById` method. This is why inferred type for `TextView`
    has platform type `View!` .
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the kind of developer responsibility that we are talking about. We,
    as developers, must decide, because only we know if the layout will have `textView`
    defined in all configurations (portrait, landscape, and so on) or only in some
    of them. If we define proper view inside current layout `findViewById` method
    will return reference to this view, and otherwise it will return null:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Assuming that `textView` is present in every layout for each configuration,
    so `textView` can be defined as non-nullable
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assuming that `textView` is not present in all layout configurations (for example,
    present only in landscape), `textView` must be defined as nullable, otherwise
    the application will throw a `NullPointerException` when trying to assign null
    to a non-nullable variable (when layout without `textView` is loaded)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Casts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The casting concept is supported by many programming languages. Basically, casting
    is a way to convert an object of one particular type into another type. In Java,
    we need to cast an object explicitly before accessing its members or cast it and
    store it in the variable of the casted type. Kotlin simplifies concept of casting
    and moves it to the next level by introducing *smart casts* .
  prefs: []
  type: TYPE_NORMAL
- en: 'In Kotlin, we can perform a few types of casts:'
  prefs: []
  type: TYPE_NORMAL
- en: Cast objects to different types explicitly (*safe cast* operator)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cast objects to different types or nullable types to non-nullable types implicitly
    (*smart cast* mechanism)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Safe/unsafe cast operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In strongly typed languages, such as Java or Kotlin, we need to convert values
    from one type to another explicitly using the cast operator. A typical casting
    operation is taking an object of one particular type and turning it into another
    object type that is its supertype (upcasting), subtype (downcasting), or interface.
    Let''s start with a small remainder of casting that could be performed in Java:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, there is an instance of `ProductFragment` that is
    assigned to a variable storing `Fragment` data type. To be able to store this
    data into the `productFragment` variable that can store only the `ProductFragment`
    data type, so we need to perform an explicit cast. Unlike Java, Kotlin has a special
    `as` keyword representing the *unsafe cast* operator to handle casting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ProductFragment` variable is a subtype of `Fragment` , so the preceding
    example will work fine. The problem is that casting to an incompatible type will
    throw the exception `ClassCastException` . That''s why the `as` operator is called
    an unsafe cast operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'To fix this problem, we can use the *safe cast* operator `as?` *.* It is sometimes
    called the **nullable cast** operator. This operator tries to cast a value to
    the specified type, and returns null if the value cannot be casted. Here is an
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice, that usage of the *safe cast* operator requires us to define the `name`
    variable as nullable (`ProductFragment?` instead of `ProductFragment` ). As an
    alternative, we can use the *unsafe cast* operator and nullable type `ProductFragment?`
    , so we can see exactly the type that we are casting to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'If we would like to have a `productFragment` variable that is non-nullable,
    then we would have to assign a default value using the elvis operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the `fragment as? ProductFragment` expression will be evaluated without
    a single error. If this expression returns a non-nullable value (the cast can
    be performed), then this value will be assigned to the `productFragment` variable,
    otherwise a default value (the new instance of `ProductFragment` ) will be assigned
    to the `productFragment` variable. Here is a comparison between these two operators:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Unsafe cast `(as)` : Throws `ClassCastException` when casting is impossible'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Safe cast `(as?)` : Returns null when casting impossible'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, when we understand the difference between *safe cast* and *unsafe cast*
    operators, we can safely retrieve a fragment from the fragment manager:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The *safe cast* and *unsafe cast* operators are used for casting complex objects.
    When working with primitive types, we can simply use one of the Kotlin standard
    library conversion methods. Most of the objects from the Kotlin standard library
    have standard methods used to simplify common casting to other types. The convention
    is that this kind of functions have prefix to, and the name of the class that
    we want to cast to. In the line in this example, the `Int` type is casted to the
    `String` type using the `toString` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: We will discuss *primitive types* and their conversions in the primitive data
    types section.
  prefs: []
  type: TYPE_NORMAL
- en: Smart casts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Smart casting** converts variable of one type to another type, but as opposed
    to safe casting*,* it is done implicitly (we don''t need to use the `as` or `as?`
    cast operator). Smart casts work only when the Kotlin compiler is absolutely sure
    that the variable will not be changed after check. This makes them perfectly safe
    for multithreaded applications. Generally smart casts are available for all immutable
    references (`val` ) and for local mutable references (`var` ). We have two kinds
    of *smart casts* :'
  prefs: []
  type: TYPE_NORMAL
- en: Type *smart cast* that cast objects of one type to an object of another type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nullity *smart cast* that cast nullable references to non-nullable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type smart casts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s represent the `Animal` and `Fish` class from the previous section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00026.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s assume we want to call the `isHungry` method and we want to check if
    the `animal` is an instance of `Fish` . In Java we would have to do something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The problem with this code is its redundancy. We have to check if `animal`
    instance is `Fish` and then we have to explicitly cast `animal` to `Fish` after
    this check*.* Wouldn''t it be nice if compiler could handle this for us? It turns
    out that the Kotlin compiler is really smart when it comes to casts, so it will
    handle all those redundant casts for us, using the *smart casts* mechanism. Here
    is an example of smart casting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '**Smart cast in Android Studio**'
  prefs: []
  type: TYPE_NORMAL
- en: Android Studio will display proper errors if smart casting is not possible,
    so we will know exactly if we can use it. Android Studio marks variables with
    green background when we access a member that required a cast.![](img/Image00027.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: 'In Kotlin, we don''t have to explicitly cast an `animal` instance to a `Fish`
    , because after the type check, Kotlin compiler will be able to handle casts implicitly.
    Now inside the `if` block, the variable animal is casted to `Fish` . The result
    is then exactly the same as in previous Java example (the Java instance of the
    operator is called is in Kotlin). This is why we can safely call the `isHungry`
    method without any explicit casting. Notice, that in this case, the scope of this
    *smart cast* is limited by the `if` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: In this context animal instance is Fish, so we can call `isHungry` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this context animal instance is still Animal, so we can't call `isHungry`
    method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'There are, however, other cases where the smart cast scope is larger than a
    single block, as like in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: From this point, animal will be implicitly converted to non- nullable Fish
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the preceding example, the whole method would return from function if `animal`
    is not `Fish` , so the compiler knows that `animal` must be a `Fish` across the
    rest of the code block. Kotlin and Java conditional expressions are evaluated
    lazily.
  prefs: []
  type: TYPE_NORMAL
- en: 'It means that in expression `condition1() && condition2()` , method `condition2`
    will be called only when `condition1` returns `true` . This is why we can use
    a *smart casted* type in the right-hand side of the conditional expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Notice that if the `animal` was not a `Fish` , the second part of the conditional
    expression would not be evaluated at all. When it is evaluated, Kotlin knows that
    `animal` is a `Fish` (smart cast).
  prefs: []
  type: TYPE_NORMAL
- en: Non-nullable smart cast
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Smart casts* also handle other cases, including nullity checks. Let''s assume
    that we have a `view` variable that is marked as nullable, because we don''t know
    wherever or not `findViewById` will return a view or null:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'We could use safe call operator to access `view` methods and properties, but
    in some cases we may want to perform more operations on the same object. In these
    situations smart casting may be a better solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: When performing null checks like this, the compiler automatically casts a nullable
    view (`View*?*` ) to non-nullable (`View` ). This is why we can call the `isShown`
    method inside the `if` block, without using a safe call operator. Outside the
    `if` block, the view is still nullable.
  prefs: []
  type: TYPE_NORMAL
- en: Each *smart casts* works only with read-only variables, because read-write variable
    may change between the time the check was performed and the time the variable
    is accessed.
  prefs: []
  type: TYPE_NORMAL
- en: '*Smart casts* also work with a function''s `return` statements. If we perform
    nullity checks inside the function with a return statement, then the variable
    will also be casted to non-nullable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: In this case, Kotlin is absolutely sure that the variable value will not be
    null, because the function would call `return` otherwise. Functions will be discussed
    in more detail in [Chapter 3](text00073.html) *, Playing with Functions* . We
    can make the preceding syntax even simpler by using elvis operator and perform
    a nullity check in a single line*:*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of just returning from the function, we may want to be more explicit
    about existing problem and throw an exception. Then we can use elvis operator
    together with the error throw:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, *smart casts* are a very powerful mechanism that allows us to
    decrease the number of nullity checks. This is why it is heavily exploited by
    Kotlin. Remember the general rule--*smart casts* work only if Kotlin is absolutely
    sure that the variable cannot change after the cast even by another thread.
  prefs: []
  type: TYPE_NORMAL
- en: Primitive data types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Kotlin, everything is an object (reference type, not primitive type). We
    don''t find primitive types, like ones we can use in Java. This reduces code complexity.
    We can call methods and properties on any variable. For example, this is how we
    can convert the `Int` variable to a `Char` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Usually (whenever it is possible), under the hood types such as `Int` , `Long`
    , or `Char` are optimized (stored as primitive types) but we can still call methods
    on them as on any other objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, Java platform stores numbers as JVM primitive types, but when a
    nullable number reference (for example, `Int?` ) is needed or generics are involved,
    Java uses *boxed representation* . **Boxing** means wrapping a primitive type
    into corresponding boxed primitive type. This means that the instance behaves
    as an object. Examples of Java boxed representations of primitive types are *int
    versus Integer* or a *long versus Long* . Since Kotlin is compiled to JVM bytecode,
    the same is true here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Value is stored as primitive type
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Value is stored as boxed integer (composite type)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This means that each time we create a number (`Byte` , `Short` , `Int` , `Long`
    , `Double` , `Float` ), or with `Char` , `Boolean` , it will be stored as a primitive
    type unless we declare it as a nullable type (`Byte?` , `Char?` , `Array?` , and
    so on); otherwise, it will be stored as a boxed representation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '`a` is non-nullable, so it is stored as primitive type'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`b` is null so it is stored as boxed representation'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`b` is still stored as boxed representation although it has a value'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Generic types cannot be parameterized using primitive types, so boxing will
    be performed. It's important to remember that using boxed representation (composite
    type) instead of primary representation can have performance penalties, because
    it will always create memory overhead compared to primitive type representation.
    This may be noticeable for lists and arrays containing a huge number of elements,
    so using primary representation may be crucial for application performance. On
    the other hand, we should not worry about the type of representation when it comes
    to a single variable or even multiple variable declarations, even in the Android
    world, where memory is limited.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s discuss the most important Kotlin primitive data types: numbers,
    characters, Booleans, and arrays.'
  prefs: []
  type: TYPE_NORMAL
- en: Numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Basic Kotlin data types used for numbers are equivalents of Java numeric primitives:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00028.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Kotlin, however, handles numbers a little bit differently than Java. The first
    difference is that there are no implicit conversions for numbers--smaller types
    are not implicitly converted to bigger types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'This means that we cannot assign a value of type `Int` to the `Long` variable
    without an explicit conversion. As we said, in Kotlin everything is an object,
    so we can call the method and explicitly convert `Int` type to `Long` to fix the
    problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'At first, this may seem like boilerplate code, but in practice this will allow
    us to avoid many errors related to number conversion and save a lot of debugging
    time. This is actually a rare example where Kotlin syntax has more amount of code
    than Java. The Kotlin standard library supports the following conversion methods
    for numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '`toByte()` : Byte'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`toShort()` : Short'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`toInt()` : Int'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`toLong()` : Long'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`toFloat()` : Float'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`toDouble()` : Double'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`toChar()` : Char'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can, however, explicitly specify a number literal to change the inferred
    variable type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The second difference between Kotlin and Java numbers is that number literals
    are slightly different in some cases. There are the following kinds of literal
    constants for integral values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Octal literals are not supported. Kotlin also supports a conventional notation
    for floating-point numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Char
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Characters in Kotlin are stored in type `Char` . In many ways, characters are
    similar to strings, so we will concentrate on the similarities and differences.
    To define `Char` , we must use a single quote kind of opposite to a `String` where
    we are using double quotes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Defines variable of type `Char`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Defines variable of type `String`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In both characters and strings, special characters can be escaped using a backslash.
    The following escape sequences are supported:'
  prefs: []
  type: TYPE_NORMAL
- en: '`\t` : Tabulator'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\b` : Backspace'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\n` : New line'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\r` : New line'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\''` : Quote'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\"` : Double quote'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\\` : Slash'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\$` : Dollar character'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\u` : Unicode escape sequence'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s define *Char* containing the Yin Yang unicode character (U+262F):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Kotlin, arrays are represented by the `Array` class. To create an array
    in Kotlin, we can use a number of Kotlin standard library functions. The simplest
    one is `arrayOf()` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, this function will create an array of boxed `Int` . If we want
    to have an array containing *Short* or *Long* , then we have to specify array
    type explicitly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'As previously mentioned, using boxed representations may decrease application
    performance. That''s why Kotlin has a few specialized classes representing arrays
    of primitive types to reduce boxing memory overhead: `ShortArray` , `IntArray`
    , `LongArray` , and so on. These classes have no inheritance relation to the `Array`
    class, although they have the same set of methods and properties. To create instances
    of this class we have to use the corresponding factory function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s important to notice and keep in mind this subtle difference, because
    those methods look similar, but create different type representations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Generic array of boxed Long elements (inferred type: `Array<Long>` )'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Array containing primitive Long elements (inferred type: `LongArray` )'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Knowing the exact size of an array will often improve performance, so Kotlin
    has another library function, `arrayOfNulls` , that creates an array of a given
    size filled with null elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also fill a predefined size array using the factory function that takes
    the array size as the first parameter and the lambda that can return the initial
    value of each array element given its index as the second parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'We will discuss lambdas (anonymous functions) in more detail in [Chapter 5](text00125.html)
    *, Functions as First Class Citizen* . Accessing array elements in Kotlin is done
    the same way as in Java:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Element are also indexed the same way as in Java, meaning the first element
    has index 0, second has index 1, and so on. Not everything works the same and
    there are some differences. Main one is that arrays in Kotlin, unlike in Java,
    arrays are invariant. We will discuss *variance* is [Chapter 6](text00153.html)
    , *Generics Are Your Friends* .
  prefs: []
  type: TYPE_NORMAL
- en: The Boolean type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Boolean is a logic type that has two possible values: `true` and `false` .
    We can also use the nullable Boolean type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Boolean type also supports standard built-in operations that are generally
    available in most modern programming languages:'
  prefs: []
  type: TYPE_NORMAL
- en: '`||` : Logical OR. Returns `true` when any of two predicates return `true`
    .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`&&` : Logical AND. Returns `true` when both predicates return `true` .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`!` : Negation operator. Returns `true` for `false` , and `false` for `true`
    .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keep in mind that we can only use not-null Boolean for any type of condition.
  prefs: []
  type: TYPE_NORMAL
- en: Like in Java, in `||` and `&&` , predicates are evaluated lazily, and only when
    needed (*lazy conjunction* ).
  prefs: []
  type: TYPE_NORMAL
- en: Composite data types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's discuss more complex types built into Kotlin. Some data types have major
    improvements compared to Java, while others are totally new.
  prefs: []
  type: TYPE_NORMAL
- en: Strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Strings in Kotlin behave in a similar way as in Java, but they have a few nice
    improvements.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start to access characters at a specified index we can use *indexing* operator
    and access character the same way we access array elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'We also have access to various extensions defined in Kotlin standard library,
    which make working with strings easier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: This is exactly the same String class as in Java, so these methods are not part
    of `String` class. They were defined as extensions. We will learn more about extensions
    in [Chapter 7](text00171.html) , *Extension Functions and Properties* .
  prefs: []
  type: TYPE_NORMAL
- en: Check the `String` class documentation for a full list of the methods ([https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: String templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Building strings is an easy process, but in Java it usually requires long concatenation
    expressions. Let''s jump straight to an example. Here is a string built from multiple
    elements implemented in Java:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'In Kotlin, we can greatly simplify the process of string creation by using
    *string templates.* Instead of using concatenation, we can simply place a variable
    inside a string using a dollar character to create a placeholder. During interpolation,
    string placeholders will be replaced with the actual value. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'This is as efficient as concatenation, because under the hood the compiled
    code creates a `StringBuilder` and appends all the parts together. String templates
    are not limited to single variables. They can also contain whole expressions between
    `${` , and `}` characters. It can be a function call that will return the value
    or property access as shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: This syntax allows us to create much cleaner code without the need to break
    the string each time a value from a variable or expression is required to construct
    strings.
  prefs: []
  type: TYPE_NORMAL
- en: Ranges
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A range is a way to define a sequence of values. It is denoted by the first
    and last value in the sequence. We can use ranges to store weights, temperatures,
    time, and age. A range is defined using double dots notation (under the hood,
    a range is using the `rangeTo` operator):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Inferred type is `IntRange` (equivalent of `i >= 1 && i <= 4` )
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inferred type is `CharRange` (equivalent of letters from `'b'` to `'g'` )
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Notice that we are using single quotes to define the character range.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Int` , `Long` , and `Char` type ranges can be used to iterate over next
    values in the `for... each` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Ranges can be used to check if a value is bigger than a start value and smaller
    than an end value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'It can be also used this way for other types of range, such as `CharRange`
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'In Kotlin, ranges are closed (end inclusive). This means that the range ending
    value is included into range:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Note, that ranges in Kotlin are incremental by default (a step is equal to
    1 by default):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'To iterate in reverse order, we must use a `downTo` function that is setting
    a step to `-1` . Like in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also set different steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Notice that in the `3..6` range, the last element was not printed. This is because
    the *stepping index* is moving two steps in each of the loop iterations. So in
    the first iteration it has a value of `3` , in the second iteration a value of
    `5` , and finally, in a third iteration the value would be `7` , so it is ignored,
    because it is outside the range.
  prefs: []
  type: TYPE_NORMAL
- en: 'A step defined by the `step` function must be positive. If we want to define
    a negative step then we should use the `downTo` function together with the `step`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A very important aspect of programming is working with collections. Kotlin offers
    multiple kinds of collections and many improvements compared to Java. We will
    discuss this subject in [Chapter 7](text00171.html) , *Extension Functions and
    Properties* .
  prefs: []
  type: TYPE_NORMAL
- en: Statements versus expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Kotlin utilizes expressions more widely than Java, so it is important to know
    the difference between a *statement* and an *expression* . A program is basically
    a sequence of statements and expressions. Expression produces a value, which can
    be used as part of another expression, variable assignment, or function parameter.
    An expression is a sequence of one or more *operands* (data that is manipulated)
    and zero or more *operators* (a token that represents a specific operation) that
    can be evaluated to a single value:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00029.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s review some examples of expressions from Kotlin:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Expression (produce a value)** | **Assigned value** | **Expression of type**
    |'
  prefs: []
  type: TYPE_TB
- en: '| `a = true` | `true` | Boolean |'
  prefs: []
  type: TYPE_TB
- en: '| `a = "foo" + "bar"` | `"foobar"` | String |'
  prefs: []
  type: TYPE_TB
- en: '| `a = min(2, 3)` | `2` | Integer |'
  prefs: []
  type: TYPE_TB
- en: '| `a = computePosition().getX()` | Value returned by `getX` method | Integer
    |'
  prefs: []
  type: TYPE_TB
- en: Statements, on the other hand, perform an action and cannot be assigned to a
    variable, because they simply don't have a value. Statements can contain language
    keywords that are used to define classes (`class` ), interfaces (`interface` ),
    variables (`val` , `var` ), functions (`fun` ), loop logic (`break` , `continue`
    ) and so on. Expressions can also be treated as a statement when the value returned
    by the expression is ignored (do not assign value to variable, do not return it
    from a function, do not use it as part of other expressions, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: Kotlin is an expression-oriented language. This means that many constructs that
    are statements in Java are treated as expressions in Kotlin. The first major difference
    is the fact that Java and Kotlin have different ways of treating *control structures*
    . In Java they are treated as statements while in Kotlin all control structures
    are treated as expressions, except for loops. This means that in Kotlin we can
    write very concise syntax using control structures. We will see examples in upcoming
    sections.
  prefs: []
  type: TYPE_NORMAL
- en: Control flow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kotlin has many control flow elements known from Java, but they offer a little
    bit more flexibility and in some cases their usage is simplified. Kotlin introduces
    a new control flow construct known as `when` as a replacement for Java `switch...
    case` .
  prefs: []
  type: TYPE_NORMAL
- en: The if statement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At its core, Kotlin''s `if` clause works the same way as in Java:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'The version with the block body is also correct if the block contains single
    statements or expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Java, however, treats `if` as a *statement* while Kotlin treats `if` as an
    *expression* . This is the main difference, and this fact allows us to use more
    concise syntax. We can, for example, pass the result of an `if` expression directly
    as a function argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'We can compress our code into single line, because result the `if` expression
    (of type String) is evaluated and then passed to the `println` method. When condition
    `x > 10` is `true` , then first branch (greater) will be returned by this expression,
    otherwise the second branch (smaller) will be returned by this expression. Let''s
    examine another example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we are using `if` as a statement. But as we know,
    `if` in Kotlin is an expression and the result of the expression can be assigned
    to a variable. This way we can assign the result of the `if` expression to a greeting
    variable directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'But sometimes there is a need to place some other code inside the branch of
    the `if` statement. We can still use if as an expression. Then the last line of
    the matching `if` branch will be returned as a result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'If we are using `if` as an expression rather than a statement, the expression
    is required to have an `else` branch. The Kotlin version is even better than Java.
    Since the `greeting` variable is defined as non-nullable, the compiler will validate
    the whole `if` expression and it will check that all cases are covered with branch
    conditions. Since `if` is an expression*,* we can use it inside *string template*
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: Treating `if` as *expression* gives us a wide range of possibilities previously
    unavailable in Java world.
  prefs: []
  type: TYPE_NORMAL
- en: The when expression
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `when` expression in Kotlin is a multiway branch statement. The `when`
    expression is designed as a more powerful replacement of the Java `switch... case`
    statement. The `when` statement often provides a better alternative than a large
    series of `if... else if` statements, but it provides more concise syntax. Let''s
    look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: The `when` expression matches its argument against all branches one after another
    until the condition of some branch is satisfied. This behavior is similar to Java
    `switch... case` , but we do not have to write a redundant `break` statement after
    every branch.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to the `if` clause, we can use `when` either as a *statement* ignoring
    returned value or as *expression* and assign its value to a variable. If `when`
    is used as an *expression* , the value of the last line of the satisfied branch
    becomes the value of the overall expression. If it is used as a statement, the
    value is simply ignored. As usual, the `else` branch is evaluated if none of the
    previous branches satisfy the condition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: Each time a branch has more than one instruction, we must place it inside the
    code block, defined by two braces `{... }` . If `when` is treated as an expression
    (result of evaluating `when` is assigned to variable), the last line of each block
    is treated as return value. We have seen the same behavior with an `if` expression,
    so by now we probably figured out that this is common behavior across many Kotlin
    constructs including lambdas, which will be discussed further across the book.
  prefs: []
  type: TYPE_NORMAL
- en: 'If `when` is used as an expression, the `else` branch is mandatory, unless
    the compiler can prove that all possible cases are covered with branch conditions.
    We can also handle many matching arguments in a single branch using commas to
    separate them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'Another nice feature of `when` is the ability to check variable type. We can
    easily validate that value `is` or `!is` of a particular type. Smart casts become
    handy again, because we can access the methods and properties of a matching type
    in a branch block without any extra checks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'In a similar way, we can check whatever range or collection contains a particular
    value. This time we''ll use `is` and `!is` keywords:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'Actually, we can put any kind of expression on the right-hand side of the `when`
    branch. It can be a method call or any other expression. Consider the following
    example where the second `when` expression is used for the `else` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, `when` is a very powerful construct allowing more control than
    Java `switch` , but it is even more powerful because it is not limited only to
    checking values for equality. In a way, it can even be used as a replacement for
    an `if... else if` chain. If no argument is supplied to the `when` expression,
    the branch conditions behave as Boolean expressions, and a branch is executed
    when its condition is `true` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'All the presented examples require an `else` branch. Each time when all the
    possible cases are covered, we can omit an `else` branch (exhaustive `when` ).
    Let''s look at the simplest example with Boolean:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: Compiler can verify that all possible values are handled, so there is no need
    to specify an `else` branch. The same logic applies to enums and sealed classes
    that will be discussed in [Chapter 4](text00088.html) *, Classes and Objects*
    .
  prefs: []
  type: TYPE_NORMAL
- en: Checks are performed by the Kotlin compiler, so we have certainty that any case
    will not be missed. This reduces the possibility of a common Java bug where the
    developer forgets to handle all the cases inside the `switch` statement (although
    polymorphism is usually a better solution)*.*
  prefs: []
  type: TYPE_NORMAL
- en: Loops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Loop is a control structure that repeats the same set of instructions until
    a termination condition is met. In Kotlin, loops can iterate through anything
    that provides iterator. Iterator is an interface that has two methods: `hasNext`
    and `next` . It knows how to iterate over a collection, range, string, or any
    entity that can be represented as a sequence of elements.'
  prefs: []
  type: TYPE_NORMAL
- en: To iterate through something, we have to supply an `iterator()` method. As `String`
    doesn't have one, so in Kotlin it is defined as an extension function. Extensions
    will be covered in [Chapter 7](text00171.html) , *Extension Functions and Properties*
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'Kotlin provides three kinds of loops: `for` , `while` , and `do... while` .
    All of them work the same as in other programming languages, so we will discuss
    them briefly.'
  prefs: []
  type: TYPE_NORMAL
- en: The for loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The classic Java `for` loop, where we need to define the iterator explicitly,
    is not present in Kotlin. Here is an example of this kind of loop in Java:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'To iterate through a collection of items from start to finish, we can simply
    use the `for` loop instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'It can also be defined without a block body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'If a `collection` is a generic collection, then *item* will be smart casted
    to type corresponding to a generic collection type. In other words, if a collection
    contains elements of type `Int` the item will be smart cased to `Int` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also iterate through the collection using its index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'The `array.indices` param returns `IntRange` with all indexes. It is the equivalent
    of (`1.. array.length - 1` *)* . There is also an alternative `withIndex` library
    method that returns a list of the `IndexedValue` property, which contains an index
    and value. This can be destructed into these elements this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: The construct `(index, value)` is known as a destructive declaration and we
    will discuss it in [Chapter 4](text00088.html) , *Classes and Objects* .
  prefs: []
  type: TYPE_NORMAL
- en: The while loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `while` loop repeats a block, while its conditional expression returns
    `true` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'There is also a `do... while` loop that repeats blocks as long as a *conditional
    expression* is returning `true` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: Kotlin, opposed to Java, can use variables declared inside the `do... while`
    loop as condition.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: The main difference between both `while` and `do... while` loops is when a conditional
    expression is evaluated. A `while` loop is checking the condition before code
    execution and if it is not true then the code won't be executed. On the other
    hand, a `do... while` loop first executes the body of the loop, and then evaluates
    the conditional expression, so the body will always execute at least once. If
    this expression is `true` , the loop will repeat. Otherwise, the loop terminates.
  prefs: []
  type: TYPE_NORMAL
- en: Other iterations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There other ways to iterate over collections using built-in standard library
    functions, such as `forEach` . We will cover them in [Chapter 7](text00171.html)
    , *Extension Functions and Properties* .
  prefs: []
  type: TYPE_NORMAL
- en: Break and continue
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All loops in Kotlin support classic `break` and `continue` statements. The
    `continue` statement proceeds to the next iteration of that loop while `break`
    stops the execution of the most inner enclosing loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s add a `condition` and `break` the iteration when this condition
    is `true` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'The `break` and `continue` statements are especially useful when dealing with
    nested loops. They may simplify our control flow and significantly decrease the
    amount of performed work to save priceless Android resources. Let''s perform a
    nested iteration and break the outer loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'We used a `break` statement to terminate the outer loop at the beginning of
    the third iteration, so the nested loop was also terminated. Notice the usage
    of the `\t` escaped sequence that adds indents on the console. We can also utilize
    the `continue` statement to skip the current iteration of the loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: We skip the iteration of the outer loop when the current value equals to `3`
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'Both `continue` and `break` statements perform corresponding operations on
    the enclosing loop. There are, however, times when we want to terminate or skip
    iteration of one loop from within another; for example, terminate an outer loop
    iteration from within an inner loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'Fortunately, both a `continue` statement and `break` statement have two forms--labeled
    and unlabeled. We already saw unlabeled, now we will need labeled to solve our
    problem. Here is an example of how a labeled break might be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: The `@outer` is the label name. By convention, the label name always starts
    with `*@*` followed by label name. Label is placed before the loop. Labeling the
    loop allows us to use qualified `break` (`break@outer` ), which is a way to stop
    execution of a loop that is referenced by this label. The preceding qualified
    `break` (break with label) jumps to the execution point right after the loop marked
    with that label.
  prefs: []
  type: TYPE_NORMAL
- en: 'Placing the `return` statement will break all the loops and return from enclosing
    an anonymous or named function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'After the method call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: Exceptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Most Java programming guidelines, including the book *Effective Java* , promote
    the concept of validity checks. This means that we should always verify arguments
    or the state of the object and throw an exception if a validity check fails. Java
    exception systems have two kinds of exceptions: checked exceptions and unchecked
    exceptions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Unchecked exception means that the developer is not forced to catch exceptions
    by using a `try... catch` block. By default, exceptions go all the way up the
    call stack, so we make decisions where to catch them. If we forget to catch them,
    they will go all the way up the call stack and stop thread execution with a proper
    message (thus they remind us):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00030.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Java has a really strong exception system, which in many cases forces developers
    to explicitly mark each function that may throw an exception and explicitly catch
    each exception by surrounding them by `try... catch` blocks (checked exceptions).
    This works great for very small projects, but in real large-scale applications
    this very often leads to the following, verbose code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: Instead of passing the exception up in the call stack, it is ignored by providing
    an empty catch block, so it won't be handled properly and it will vanish. This
    kind of code may mask critical exceptions and give a false sense of security and
    lead to unexpected problems and difficult to find bugs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we discuss how exception handling is done in Kotlin, let''s compare
    both types of exceptions:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Code** | **Checked exceptions** | **Unchecked exceptions** |'
  prefs: []
  type: TYPE_TB
- en: '| Function declaration | We have to specify what exceptions can be thrown by
    functions. | Function declaration does not contain information about all thrown
    exceptions. |'
  prefs: []
  type: TYPE_TB
- en: '| Exception handling | Function that throws exception must to be surrounded
    by a `try... catch` block. | We can catch exception and do something if we want,
    but we aren''t forced to do this. Exception goes up in the call stack. |'
  prefs: []
  type: TYPE_TB
- en: 'The biggest difference between Kotlin and Java exception systems is that in
    Kotlin all exceptions are unchecked. This means we never have to surround a method
    with `try... catch` block even if this is a Java method that may throw a cached
    exception. We can still do it, but we are not forced to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: This approach removes code verbosity and improves safety because we don't need
    to introduce empty *catch* blocks.
  prefs: []
  type: TYPE_NORMAL
- en: The try... catch block
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Kotlin `try... catch` block is the equivalent of the Java `try... catch` block.
    Let''s look at quick example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: Exceptions are not specified on function signature like in Java.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We check validity of data and throw `NullPointerException` (notice that no new
    keyword is required when creating an object instance).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `try... catch` block is similar construct from Java.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Handle only this specific exceptions (`AssertionError` exception).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `finally` block is always executed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There may be zero or more `catch` blocks and `finally` block may be omitted.
    However, at least one `catch` or `finally` block should be present.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Kotlin, exception handling `try` is an expression, so it can return a value
    and we can assign its value to a variable. The actual assigned value is the last
    expression of the executed block. Let''s check if a particular Android application
    is installed on the device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: The `try... catch` block is returning value that is returned by a single expression
    function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If an application is installed, the `getPackageInfo` method will return a value
    (this value is ignored) and the next line containing `true` expression will be
    executed. This is the last operation performed by a `try` block, so its value
    will be assigned to a variable (`true` ).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If an app is not installed, `getPackageInfo` will throw `PackageManager.NameNotFoundException`
    and the `catch` block will be executed. The last line of the `catch` block contains
    a `false` expression, so its value will be assigned to a variable.
  prefs: []
  type: TYPE_NORMAL
- en: Compile-time constants
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since the `val` variable is read only, in most cases we could treat it as a
    constant. We need to be aware that its initialization may be delayed, so this
    means that there are scenarios where the `val` variable may not be initialized
    at compile time, for example, assigning the result of the method call to a value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: 'This value will be assigned at runtime. There are, however, situations where
    we need to know the value at compile time. The exact value is required when we
    want to pass parameters to annotations. Annotations are processed by an annotation
    processor that runs long before the application is started:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00031.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To make absolutely sure that the value is known at compile time (and thus can
    be processed by an annotation processor), we need to mark it with a `const` modifier.
    Let''s define a custom annotation `MyLogger` with a single parameter defining
    maximum log entries and annotate a `Test` class with it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: There are couple limitations regarding usage of `const` that we must be aware
    of. The first limitation is that it must be initialized with values of primitive
    types or `String` type. The second limitation is that it must be declared at the
    top level or as a member of an object. We will discuss objects in [Chapter 4](text00088.html)
    , *Classes and Objects* . The third limitation is that they cannot have a custom
    getter.
  prefs: []
  type: TYPE_NORMAL
- en: Delegates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kotlin provides first-class support for delegation. It is very useful improvement
    comparing to Java. If fact, there are many applications for delegates in Android
    development, so we have decided to spare a whole chapter on this subject ([Chapter
    8](text00205.html) , *Delegates* ).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have discussed the differences between variables, values,
    and consts and discussed basic Kotlin data types including ranges. We also looked
    into a Kotlin type system that enforces strict null safety and ways to deal with
    nullable references using various operators and smart casts. We know that we can
    write more concise code by taking advantage of using type inference and various
    control structures that in Kotlin are treated as expressions. Finally, we discussed
    ways of exception handling.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about functions and present different ways
    of defining them. We will cover concepts such as single-expression functions,
    default arguments and named argument syntax, and discuss various modifiers.
  prefs: []
  type: TYPE_NORMAL
