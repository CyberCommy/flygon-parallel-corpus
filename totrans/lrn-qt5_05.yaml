- en: Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will implement classes to handle the most critical part
    of any Line of Business application—the data. We will introduce self-aware data
    entities, which can automatically serialize to and from **JavaScript Object Notation**
    (**JSON**), a popular serialization format used a lot in web communications. We
    will create the core models we need for our application and wire them up to our
    UI for reading and writing via custom controls. We will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: JSON
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data decorators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Abstract data entities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collections of data entities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Concrete data models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: UI controls and data binding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JSON
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In case you have never come across JSON before, let’s have a quick crash course.
    It is a simple and lightweight way to express hierarchies of objects and their
    properties. It is a very popular choice when sending data in HTTP requests. It
    is similar to XML in intent but is much less verbose.
  prefs: []
  type: TYPE_NORMAL
- en: 'A JSON object is encapsulated in curly braces `{}`, while properties are denoted
    in the format key: value. Strings are delimited with double quotes `""`. We can
    represent a single client object as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note that white space and control characters such as tab and newline are ignored—the
    indented properties are to simply make things more readable.
  prefs: []
  type: TYPE_NORMAL
- en: It's usually a good idea to strip extraneous characters out of JSON when transmitting
    over the network (for example, in an HTTP request) in order to reduce the size
    of the payload; every byte counts!
  prefs: []
  type: TYPE_NORMAL
- en: Property values can be one of the following types: `String`, `Number`, `JSON
    Object`, `JSON Array`, and the literal values `true`, `false`, and `null`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can add the supply address and billing address to our client as child JSON
    objects, providing a unique key for each. While keys can be in any format as long
    as they are unique, it is common practice to use camel case, for example, `myAwesomeJsonKey`.
    We can express an empty address object with null:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'A collection (array) of objects is enclosed in square brackets `[]` separated
    by commas. We can express no scheduled appointments by simply leaving the square
    brackets empty:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Object hierarchy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Most real-world applications represent data in a hierarchical or relational
    manner, with the data rationalized into discrete objects. There is often a central
    "root" object, which parents several other child objects, either as singular objects
    or as a collection. Each discrete object has its own set of data items that can
    be any number of types. The key principles we want to cover are as listed:'
  prefs: []
  type: TYPE_NORMAL
- en: A range of data types (`string`, `integer`, `datetime`) and an enumerated value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Object hierarchy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiple single child entities of the same type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collections of entities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Balancing these goals with simplicity, the data diagram we will work toward
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ffa84470-9d21-4f42-93b5-1691a7bdabe0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The purpose of each of these models is described in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Model** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| **Client** | This is the root of our object hierarchy and represents an individual
    or party our company has a relationship with, for example, a customer or a patient.
    |'
  prefs: []
  type: TYPE_TB
- en: '| **Contact** | A collection of addresses that we can use to contact the client.
    The possible types of contact will be a telephone, email, and fax. There may be
    one or more contacts per client. |'
  prefs: []
  type: TYPE_TB
- en: '| **Appointment** | A collection of scheduled appointments with the client,
    for example, a site visit or consultation. There may be zero or more appointments
    per client. |'
  prefs: []
  type: TYPE_TB
- en: '| **Supply address** | The address central to the relationship with the client,
    for example, the site our company supplies energy to or the home address of a
    patient. There must be one supply address per client. |'
  prefs: []
  type: TYPE_TB
- en: '| **Billing address** | An optional address different to the supply address
    used for invoicing, for example, the head office of a corporation. There may be
    zero or one billing address per client. |'
  prefs: []
  type: TYPE_TB
- en: Another perfectly valid approach would be to aggregate the addresses into a
    collection, much like we have done with our contacts, but I want to demonstrate
    using the same type of object (Address) in multiple properties.
  prefs: []
  type: TYPE_NORMAL
- en: With the high-level design in place, we are now in a position to write our classes.
    However, before we start on our data entities, let’s take a look at the data items.
  prefs: []
  type: TYPE_NORMAL
- en: DataDecorators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A simple implementation of the `name` property of our client model would be
    to add it as a `QString`; however, this approach has some shortcomings. Whenever
    we display this property in the UI, we will probably want to display an informative
    label next to the textbox so that the user knows what it is for, saying “Name”
    or something similar. Whenever we want to validate a name entered by the user,
    we have to manage that in the code somewhere else. Finally, if we want to serialize
    the value to or from JSON, again there needs to be some other component that does
    it for us.
  prefs: []
  type: TYPE_NORMAL
- en: To solve all of these problems we will introduce the concept of a `DataDecorator`,
    which will lift a given base data type and give us a label, validation capabilities,
    and JSON serialization out of the box. Our models will maintain a collection of
    `DataDecorators`, allowing them to validate and serialize themselves to JSON too
    by simply walking through the data items and performing the relevant action.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our `cm-lib` project, create the following classes in a new folder `cm-lib/source/data`:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Class** | **Purpose** |'
  prefs: []
  type: TYPE_TB
- en: '| `DataDecorator` | Base class for our data items |'
  prefs: []
  type: TYPE_TB
- en: '| `StringDecorator` | Derived class for string properties |'
  prefs: []
  type: TYPE_TB
- en: '| `IntDecorator` | Derived class for integer properties |'
  prefs: []
  type: TYPE_TB
- en: '| `DateTimeDecorator` | Derived class for date/time properties |'
  prefs: []
  type: TYPE_TB
- en: '| `EnumeratorDecorator` | Derived class for enumerated properties |'
  prefs: []
  type: TYPE_TB
- en: Our `DataDecorator` base class will house the features shared across all of
    our data items.
  prefs: []
  type: TYPE_NORMAL
- en: '`data-decorator.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We inherit from QObject, add our `dllexport` macro and wrap the whole thing
    in namespaces as usual. Also, because this is an abstract base class, we ensure
    that we’ve implemented a virtual destructor.
  prefs: []
  type: TYPE_NORMAL
- en: We know that because we are inheriting from QObject, we want to receive a pointer
    to a parent in our constructor. We also know that all data items will be children
    of an **Entity** (which we will write soon and have forward declared here), which
    will itself be derived from QObject. We can leverage these two facts to parent
    our `DataDecorator` directly to an Entity.
  prefs: []
  type: TYPE_NORMAL
- en: We construct the decorator with a couple of strings. All of our data decorators
    must have a key that will be used when serializing to and from JSON, and they
    will also share a `label` property that the UI can use to display descriptive
    text next to the data control. We tuck these members away in the private implementation
    and implement some accessor methods for them.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we begin implementing our JSON serialization by declaring virtual methods
    to represent the value as a `QJsonValue` and to update the value from a provided
    `QJsonObject`. As the value is not known in the base class and will instead be
    implemented in the derived classes, both these methods are pure virtual functions.
  prefs: []
  type: TYPE_NORMAL
- en: '`data-decorator.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The implementation is very straightforward, essentially just managing some data
    members.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we'll implement our derived decorator class for handling strings.
  prefs: []
  type: TYPE_NORMAL
- en: '`string-decorator.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: There isn’t much else going on here—we’re just adding a strongly typed `QString`
    value property to hold our value. We also override the virtual JSON-related methods.
  prefs: []
  type: TYPE_NORMAL
- en: When deriving from a class that inherits from QObject, you need to add the Q_OBJECT macro
    to the derived class as well as the base class if the derived class implements
    its own signals or slots.
  prefs: []
  type: TYPE_NORMAL
- en: '`string-decorator.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Again, there is nothing particularly complicated here. By using the `READ` and
    `WRITE` property syntax rather than the simpler `MEMBER` keyword, we now have
    a way of intercepting values being set by the UI, and we can decide whether or
    not we want to apply the change to the member variable. The mutator can be as
    complex as you need it to be, but all we’re doing for now is setting the value
    and emitting the signal to tell the UI that it has been changed. We wrap the operation
    in an equality check, so we don’t take any action if the new value is the same
    as the old one.
  prefs: []
  type: TYPE_NORMAL
- en: Here, the mutator returns a reference to self (*this), which is helpful because
    it enables method chaining, for example,  `myName.setValue(“Nick”).setSomeNumber(1234).setSomeOtherProperty(true)`.
    However, this is not necessary for the property bindings, so feel free to use
    the more common `void` return type if you prefer.
  prefs: []
  type: TYPE_NORMAL
- en: We use a two-step conversion process, converting our `QString` value into a
    `QVariant` before converting it into our target `QJsonValue` type. The `QJsonValue`
    will be plugged into the parent Entity JSON object using the `key` from the `DataDecorator`
    base class. We will cover that in more detail when we write the **Entity** related
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: An alternative approach would be to simply represent the value of our various
    data items as a `QVariant` member in the `DataDecorator` base class, removing
    the need to have separate classes for `QString`, `int`, and so on. The problem
    with this approach is that you end up having to write lots of nasty code that
    says “if you have a `QVariant` containing a string then run this code if it contains
    an `int` then run this code...”. I prefer the additional overhead of writing the
    extra classes in exchange for having known types and cleaner, simpler code. This
    will become particularly helpful when we look at data validation. Validating a
    string is completely different from validating a number and different again from
    validating a date.
  prefs: []
  type: TYPE_NORMAL
- en: '`IntDecorator` and `DateTimeDecorator` are virtually identical to `StringDecorator`,
    simply substituting `QString` values for int or `QDateTime`. However, we can supplement
    `DateTimeDecorator` with a few additional properties to help us out. Add the following
    properties and an accessor method to go with each:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The purpose of these properties is to make the UI easily access the date/time
    value as a `QString` preformatted to a few different styles. Let's run through
    the implementation for each of the accessors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Qt has inbuilt support for ISO8601 format dates, which is a very common format
    when transmitting datetime values between systems, for example, in HTTP requests.
    It is a flexible format that supports several different representations but generally
    follows the format yyyy-MM-ddTHH:mm:ss.zt, where T is a string literal, z is milliseconds,
    and t is the timezone information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we provide a method to display a full datetime in a long human readable
    format, for example, Sat 22 Jul 2017 @ 12:07:45:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The final two methods display either the date or time component, for example,
    22 Jul 2017 or 12:07 pm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Our final type, `EnumeratorDecorator`, is broadly the same as `IntDecorator`,
    but it also accepts a mapper. This container helps us map the stored int value
    to a string representation. If we consider the `Contact.type` enumerator we plan
    to implement, the enumerated value will be 0, 1, 2, so on; however, when it comes
    to the UI, that number won't mean anything to the user. We really need to present
    `Email`, `Telephone`, or some other string representation, and the map allows
    us to do just that.
  prefs: []
  type: TYPE_NORMAL
- en: '`enumerator-decorator.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We store the map as another member variable in our private implementation class
    and then use it to provide the string representation of the enumerated value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have covered the data types we need for our entities, let’s move
    on to the entities themselves.
  prefs: []
  type: TYPE_NORMAL
- en: Entities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have a lot of functionality we want to share across our data models, we'll
    implement an **Entity** base class. We need to be able to represent parent/child
    relationships so that a client can have supply and billing addresses. We also
    need to support collections of entities for our contacts and appointments. Finally,
    each entity hierarchy must be able to serialize itself to and from a JSON object.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new class Entity in `cm-lib/source/data`.
  prefs: []
  type: TYPE_NORMAL
- en: '`entity.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '`entity.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Much like our `DataDecorator` base class, we assign all entities a unique key, which
    will be used in JSON serialization. We also add an overloaded constructor to which
    we can pass a `QJsonObject` so that we can instantiate an entity from JSON. On
    a related note, we also declare a pair of methods to serialize an existing instance
    to and from JSON.
  prefs: []
  type: TYPE_NORMAL
- en: Our entity will maintain a few collections—a map of data decorators representing
    the properties of the model, and a map of entities representing individual children.
    We map the key of each item to the instance.
  prefs: []
  type: TYPE_NORMAL
- en: We expose a couple of protected methods that are derived classes will use to
    add its data items and children; for example, our client model will add a name
    data item along with the `supplyAddress` and `billingAddress` children. To complement
    these methods, we also add signals to tell any interested observers that the collections
    have changed.
  prefs: []
  type: TYPE_NORMAL
- en: In both cases, we check that the key doesn’t already exist on the map before
    adding it. We then return the supplied pointer so that the consumer can use it
    for further actions. You’ll see the value of this when we come to implement the
    data models.
  prefs: []
  type: TYPE_NORMAL
- en: We use our populated maps for the JSON serialization methods. We’ve already
    declared an `update()` method on our `DataDecorator` base class, so we simply
    iterate through all the data items and pass the JSON object down to each in turn.
    Each derived decorator class has its own implementation to take care of the parsing.
    Similarly, we recursively call `Entity::update()` on each of the child entities.
  prefs: []
  type: TYPE_NORMAL
- en: Serializing to a JSON object follows the same pattern. Each data item can convert
    its value to a `QJsonValue` object, so we get each value in turn and append it
    to a root JSON object using the key of each item. We recursively call `Entity::toJson()`
    on each of the children, and this cascades down the hierarchy tree.
  prefs: []
  type: TYPE_NORMAL
- en: Before we can finish off our **Entity**, we need to declare a group of classes
    to represent an entity collection.
  prefs: []
  type: TYPE_NORMAL
- en: Entity collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To implement entity collections, we need to leverage some more advanced C++
    techniques, and we will take a brief break from our conventions so far, implementing
    multiple classes in a single header file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create `entity-collection.h` in `cm-lib/source/data`, and in it, add our namespaces
    as normal and forward declare Entity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Next, we’ll walk through the necessary classes in turn, each of which must be
    added in order inside the namespaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'We first define the root class, which does nothing more than inheriting from
    `QObject` and giving us access to all the goodness that it brings, such as object
    ownership and signals. This is required because classes deriving directly from
    `QObject` cannot be templated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'You will need to add includes for `QObject` and our DLL export macros. Next,
    we need a type agnostic interface to use with our entities, much the same as we
    have with the `DataDecorator` and Entity maps we’ve implemented. However, things
    are a little more complicated here, as we will not derive a new class for each
    collection we have, so we need some way of getting typed data. We have two requirements.
    Firstly, the UI needs a `QList` of derived types (for example, **Client***) so
    that it can access all the properties specific to a client and display all the
    data. Secondly, our **Entity** class needs a vector of base types (**Entity***)
    so that it can iterate its collections without caring exactly which type it is
    dealing with. The way we achieve this is to declare two template methods but delay
    defining them until later. `derivedEntities()` will be used when the consumer
    wants a collection of the derived type, while `baseEntities()` will be used when
    the consumer just wants access to the base interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we declare a full template class where we store our collection of derived
    types and implement all of our methods, except for the two template methods we
    just discussed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: You will need `#include <QJsonValue>` and `<QJsonArray>` for these classes.
  prefs: []
  type: TYPE_NORMAL
- en: The `clear()` method simply empties the collection and tidies up the memory; 
    `update()` is conceptually the same as the JSON methods we implemented in Entity,
    except that we are dealing with a collection of entities, so we take a JSON array
    instead of an object. `addEntity()` adds an instance of a derived class to the
    collection, and `derivedEntities()` returns the collection; `baseEntities()` does
    a little more work, creating a new vector on request and populating it with all
    the items in the collection. It is just implicitly casting pointers, so we’re
    not concerned about expensive object instantiation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we provide the implementation for our magic templated methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: What we’ve achieved by delaying our implementation of these methods is that
    we’ve now fully declared our templated `EntityCollection` class. We can now "route"
    any calls to the templated methods through to the implementation in the templated
    class. It’s a tricky technique to wrap your head around, but it will hopefully make
    more sense when we start implementing these collections in our real-world models.
  prefs: []
  type: TYPE_NORMAL
- en: With our entity collections now ready, we can return to our Entity class and
    add them to the mix.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the header, `#include <data/entity-collection.h>`, add the signal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, add the protected method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In the implementation file, add the private member:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, add the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This works in exactly the same way as the other maps, associating a key with
    a pointer to a base class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, add the collections to the `update()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, add the collections to the `toJson()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: You will need `#include <QJsonArray>` for that last snippet.
  prefs: []
  type: TYPE_NORMAL
- en: We use the `baseEntities()` method to give us a collection of `Entity*`. We
    then append the JSON object from each entity to a JSON array and when complete,
    add that array to our root JSON object with the collection’s key.
  prefs: []
  type: TYPE_NORMAL
- en: The past few sections have been quite long and complex and may seem like a lot
    of work just to implement some data models. However, it’s all code that you write
    once, and it gives you a lot of functionality for free with every entity you go
    on and make, so it’s worth the investment in the long run. We’ll go ahead and
    look at how to implement these classes in our data models.
  prefs: []
  type: TYPE_NORMAL
- en: Data models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have the infrastructure in place to be able to define data objects
    (entities and entity collections) and properties of various types (data decorators),
    we can move on and build the object hierarchy we laid out earlier in the chapter.
    We already have a default **Client** class created by Qt Creator, so supplement
    that in `cm-lib/source/models` with the following new classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Class** | **Purpose** |'
  prefs: []
  type: TYPE_TB
- en: '| `Address` | Represents a supply or billing address |'
  prefs: []
  type: TYPE_TB
- en: '| `Appointment` | Represents an appointment with a client |'
  prefs: []
  type: TYPE_TB
- en: '| `Contact` | Represents a method of contacting a client |'
  prefs: []
  type: TYPE_TB
- en: We’ll start with the simplest of the models—the address.
  prefs: []
  type: TYPE_NORMAL
- en: '`address.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We define the properties we designed at the beginning of the chapter, but instead
    of using regular `QString` objects, we use our new `StringDecorators`. To protect
    the integrity of our data, we should really use the `READ` keyword and return
    a `StringDecorator* const` via an accessor method, but for simplicity, we’ll use
    `MEMBER` instead. We also provide an overloaded constructor that we can use to
    construct an address from a `QJsonObject`. Finally, we add a helper `fullAddress()`
    method and property to concatenate the address elements into a single string for
    use in the UI.
  prefs: []
  type: TYPE_NORMAL
- en: '`address.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This is where all of our hard work starts to come together. We need to do two
    things with each of our properties. Firstly, we need a pointer to the derived
    type (`StringDecorator`), which we can present to the UI in order to display and
    edit the value. Secondly, we need to make the base Entity class aware of the base
    type (`DataDecorator`) so that it can iterate the data items and perform the JSON
    serialization work for us. We can use the `addDataItem()` method to achieve both
    these goals in a one-line statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Breaking this down, we create a new `StringDecorator*` with the `building` key and
    `Building` UI label. This is immediately passed to `addDataItem()`, which adds
    it to the `dataDecorators` collection in the **Entity** and returns the data item
    as a `DataDecorator*`. We can then cast it back to a `StringDecorator*` before
    storing it in the `building` member variable.
  prefs: []
  type: TYPE_NORMAL
- en: The only other piece of implementation here is to take a JSON object, construct
    the address as normal by calling the default constructor, and then update the
    model using the `update()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Appointment` and `Contact` models follow the same pattern, just with different
    properties and the appropriate variation of `DataDecorator` for each of their
    data types.  Where `Contact` varies more significantly is in its use of an `EnumeratorDecorator`
    for the `contactType` property. To support this, we first define an enumerator
    in the header file that contains all the possible values we want:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we have a default value of `Unknown` represented by `0`. This is
    important as it allows us to accommodate an initial unset value. Next, we define
    a mapper container that allows us to map each of the enumerated types to a descriptive
    string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'When creating the new `EnumeratorDecorator`, we supply the default value (0
    for `eContactType::Unknown`) along with the mapper:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Our client model is a little more complex, as it not only has data items but
    has child entities and collections too. However, the way we create and expose
    these things is very similar to what we have already seen.
  prefs: []
  type: TYPE_NORMAL
- en: '`client.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: We expose the child entities as pointers to the derived type and the collections
    as pointers to a templated `EntityCollection`.
  prefs: []
  type: TYPE_NORMAL
- en: '`client.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Adding child entities follows the same pattern as data items, but using the
    `addChild()` method. Note that we add more than one child of the same address
    type, but ensure that they have different `key` values to avoid duplicates and
    invalid JSON. Entity collections are added with `addChildCollection()` and other
    than being templated, they follow the same approach.
  prefs: []
  type: TYPE_NORMAL
- en: While it was a lot of work to create our entities and data items, creating models
    is really quite straightforward and now they all come packed with features that
    we wouldn’t otherwise have had.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we can use our fancy new models in the UI, we need to register the types
    in `main.cpp` in `cm-ui`, including the data decorators that represent the data
    items. Remember to add the relevant `#include` statements first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: With that done, we’ll create an instance of a client in `MasterController`, which
    we will use to populate data for new clients. This follows exactly the same pattern
    that we’ve used for adding the other controllers.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, add the member variable to the private implementation of `MasterController`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, initialize it in the `Implementation` constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Third, add the accessor method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, add `Q_PROPERTY`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We now have an empty instance of a client available for consumption by the
    UI, specifically `CreateClientView`, which we will edit next. Begin by adding
    a shortcut property for the new client instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Remember that the properties should all be defined at the root Item level and
    that you need to `import CM 1.0` to get access to the registered types. This just
    enables us to use `newClient` as shorthand to access the instance rather than
    having to type out `masterController.ui_newClient` every time.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, everything is hooked up ready for use, and you should be able
    to run the application and navigate to the new client view with no problems. The
    view isn’t doing anything with the new client instance just yet, but it’s happily
    sitting there ready for action. Now, let’s look at how we can interact with it.
  prefs: []
  type: TYPE_NORMAL
- en: Custom TextBox
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We’ll start with the `name` data item of our client. Back when we worked with
    another `QString` property in our UI with the welcome message, we displayed it
    with the basic text component. This component is read only, so to view and edit
    our property, we will need to reach for something else. There are a couple of
    options in the base `QtQuick` module: `TextInput` and `TextEdit`. `TextInput`
    is for a single line of editable plain text, while `TextEdit` handles multiline
    blocks of text and also supports rich text. `TextInput` is ideal for our **name**.'
  prefs: []
  type: TYPE_NORMAL
- en: Importing the `QtQuick.Controls` module makes additional text-based components
    like `Label`, `TextField`, and `TextArea` available. Label inherits and extends
    Text, `TextField` inherits and extends `TextInput` and `TextArea` inherits and
    extends `TextEdit`. The basic controls are enough for us at this stage, but be
    aware that these alternatives exist. If you find yourself trying to do something
    with one of the basic controls which it doesn’t seem to support, then import `QtQuick.Controls`
    and take a look at its more powerful cousin. It may well have the functionality
    you are looking for.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s build on what we''ve learned and create a new reusable component. As
    usual, we''ll begin by preparing the Style properties we''ll need:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Next, create `StringEditorSingleLine.qml` in `cm/cm-ui/components`. It’s not
    the most beautiful of names, but at least it’s descriptive!
  prefs: []
  type: TYPE_NORMAL
- en: It's generally helpful to use a prefix with custom QML views and components
    to help distinguish them from the built-in Qt components and avoid naming conflicts.
    If we were using that approach with this project, we could have called this component
    `CMTextBox` or something equally short and simple. Use whatever approach and conventions
    work for you, it makes no functional difference.
  prefs: []
  type: TYPE_NORMAL
- en: Edit `components.qrc` and `qmldir` as we did previously to make the new component
    available in our components module.
  prefs: []
  type: TYPE_NORMAL
- en: 'What we''re trying to achieve with this component is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: To be able to pass in any `StringDecorator` property from any data model and
    view/edit the value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: View a descriptive label for the control as defined in the `ui_label` property
    of the `StringDecorator`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: View/edit the `ui_value` property of the `StringDecorator` in a `TextBox`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the window is wide enough, then the label and textbox are laid out horizontally
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the window is not wide enough, then the label and textbox are laid out vertically
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With these goals in mind, implement `StringEditorSingleLine`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: We begin with a public `StringDecorator` property (public because it is in the
    root Item element), which we can set from outside of the component.
  prefs: []
  type: TYPE_NORMAL
- en: We introduce a new kind of element—Flow—to lay out our label and textbox for
    us. Rather than always laying out content in a single direction like row or column,
    the Flow item will lay out its child elements side by side until it runs out of
    available space and then wraps them like words on a page. We tell it how much
    available space it has to play with by anchoring it to the root Item.
  prefs: []
  type: TYPE_NORMAL
- en: Next comes our descriptive label in a Text control and the editable value in
    a `TextInput` control. We embed both controls in explicitly sized rectangles.
    The rectangles help us align the elements and give us the opportunity to draw
    backgrounds and borders.
  prefs: []
  type: TYPE_NORMAL
- en: The `Binding` component establishes a dependency between the properties of two
    different objects; in our case, the `TextInput` control called `textValue` and
    the `StringDecorator` instance called `stringDecorator`. The `target` property
    defines the object we want to update, the `property` is the `Q_PROPERTY` we want
    to set, and `value` is the value we want to set it to. This is a key element that
    gives us true two-way binding. Without this, we will be able to view the value
    from the `StringDecorator`, but any changes we make in the UI will not update
    the value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back in `CreateClientView`, replace the old Text element with our new component
    and pass in the `ui_name` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Now build and run the app, navigate to the Create Client view, and try editing
    the name:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/91a79322-c123-4af2-8e42-736e540130a3.png)'
  prefs: []
  type: TYPE_IMG
- en: If you switch to the Find Client view and back again, you will see that the
    value is retained, demonstrating the updates are successfully being set in the
    string decorator.
  prefs: []
  type: TYPE_NORMAL
- en: Our newly bound view isn't exactly overflowing with data just yet, but over
    the coming chapters, we will add more and more to this view, so let's add a few
    finishing touches to prepare us.
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, we only need to add another three or four properties to the view, and
    we'll run out of space as the default size we’ve set for the window is very small,
    so in `MasterView` bump the window size up to something comfortable for your display.
    I'll treat myself and go full HD at 1920 x 1080.
  prefs: []
  type: TYPE_NORMAL
- en: Even with a larger window to work with, we still need to prepare for the possibility
    of overflow, so we'll add our content to another new element called `ScrollView`.
    As its name suggests, it works in a similar way to flow and manages its content
    based on the space it has available to it. If the content exceeds the available
    space, it will present scrollbars for the user. It's also a very finger friendly
    control and on a touch screen, the user can just drag the content rather than
    having to fiddle around with a tiny scrollbar.
  prefs: []
  type: TYPE_NORMAL
- en: Although we only have one property currently, when we add more, we will need
    to lay them out so we'll add a column.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the controls are stuck to the bounds of the view, so we'll add a little
    gutter around the view and some spacing in the column.
  prefs: []
  type: TYPE_NORMAL
- en: 'The revised view should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Build and run, and you should see the nice neat screen margin. You should also
    be able to resize the window from wide to narrow and see the string editor automatically
    adjust its layout accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This was a fairly hefty chapter, but we’ve covered arguably the most important
    element of any Line of Business application, and that is the data. We’ve implemented
    a framework of self-aware entities that can serialize themselves to and from JSON
    and started building data bound controls. We’ve designed and created our data
    models and are now entering the homeward stretch. In [Chapter 6](8e0365b0-e826-4ab5-8a7c-858222ce2c00.xhtml),
    *Unit Testing*, we’ll show some love to our so far neglected unit test project
    and check that our entities are behaving as expected.
  prefs: []
  type: TYPE_NORMAL
