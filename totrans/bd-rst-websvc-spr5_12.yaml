- en: Microservice Basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Though monolithic architecture has its own benefits, when an application is
    getting bigger to support various types of business logic, it gives a tough time
    to the developers and deployment engineers. Even a single bug fix in the backend
    will force the developer to redeploy the whole application in the server, causing
    unnecessary maintenance. On the other hand, microservices come with an option
    to keep business logic separated into services. So applications can be pushed
    to the server without interrupting the flow, and the end user especially should
    not notice any interruption. In this chapter, we will delve into some basics about
    microservices and related topics.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will discuss:'
  prefs: []
  type: TYPE_NORMAL
- en: Monolithic architecture and its drawbacks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Microservices and their benefits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic characteristics of microservices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Microservice components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Microservice tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monolithic architecture and its drawbacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Even though microservice architecture is growing in popularity nowadays, the
    majority of companies still use the monolithic architecture. As a monolithic application,
    you can bundle all business modules into one single unit and deploy them in all
    desired servers. If any changes are needed in the application, developers have
    to provide them and redeploy the updated version of the application. In monolithic,
    we follow tight coupling between service modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'Though monolithic architecture has some benefits, its drawbacks paved the way
    for an alternate architectural designâ€”microservices. Here we will talk a little
    about the drawbacks of monolithic architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: For each bug fix or code change, we have to redeploy the entire application
    on all servers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If any common issue persists in the monolithic application, such as performance
    issues, it will impact the entire application, which might be hard to find out
    and fix quickly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bigger applications might take longer to start during deployment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Library requirements and conflicts might affect the entire application. We will
    have a hard time fixing libraries to support all modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scaling might be hard for monoliths, as all modules come under one umbrella
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the application grows, the complexity of business logic and implementation
    will grow as well, which might need more time to develop and maintain
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Infrequent, expensive, and mass deployment option: if we have multiple types
    of business logic and layers and want to upgrade one business logic, we will need
    to deploy all other layers/services, as well'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tightly coupled services cause difficulty when one service/layer needs an upgrade
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Service discovery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a microservice architecture, based on the business requirements and service
    load, we might have to increase the service instances. In such cases, keeping
    track of all available service instances and their information, such as port numbers,
    would be hard to manage. Service discovery will help us manage such tasks by automatically
    configuring service instances and looking them up when in need.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Changing a few things in a big application is a constant pain for developers.
    Every time we make a small change in the code, we might have to deploy the whole
    application into servers, which is a time-consuming and tiring process, especially
    when we have multiple services, like accounting, reporting, user management, and
    so on. Microservices help us get rid of this pain. The main goal of microservices
    is to split up the application into services and deploy each service to our servers
    independently. By doing this, we provide loosely coupled processes in our application.
    Also, microservices can be deployed in the cloud to avoid service outage issues
    and provide nonstop services to consumers.
  prefs: []
  type: TYPE_NORMAL
- en: In microservices, each module or business section can be written as a separate
    service to provide continuous delivery and integration. These services are built
    to fulfill specific business requirements, and they are independently deployable
    by automating deployment infrastructure. Managing these services can be decentralized
    and can be programmable in different languages, as well.
  prefs: []
  type: TYPE_NORMAL
- en: Before moving on to components, we will briefly discuss the basic characteristics
    of microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Independence and autonomy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Microservices play as a better alternative for monolithic environments. In microservices,
    each service can be started, stopped, upgraded, or replaced at any time, without
    interrupting other services. All services are independent and can be registered
    automatically into our central registry.
  prefs: []
  type: TYPE_NORMAL
- en: Resilience and fault tolerance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a complex application design, creating a resilient system is vital for every
    service. Most cloud environments require an architectural design where all services
    respond to unexpected situations, like outages, and so on. These scenarios can
    be receiving bad data (broken data), may not be able to reach the required service,
    or may request conflicts in concurrent systems. Microservices need to be resilient
    to failures, and they should be able to restart themselves quickly.
  prefs: []
  type: TYPE_NORMAL
- en: Microservices should prevent failures from cascading through other dependent
    services in the system.
  prefs: []
  type: TYPE_NORMAL
- en: Automated environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Automation should be an important factor in microservice architectural design,
    as many services will be involved in the application, and thus the interaction
    between services will be very complex. Automated monitoring and an alert management
    system have to be implemented to augment microservice design. All services should
    log their data and metrics, and these metrics should be monitored properly, as
    it will improve service management.
  prefs: []
  type: TYPE_NORMAL
- en: Stateless
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Microservices are stateless, which means they don't keep data from one session
    to another session. Also, microservice instances will not interact with each other.
    When we have more microservice instances available in the application, each instance
    will not have any idea about other instances, whether the next instance is alive
    or not. This characteristic is very helpful when we scale our applications.
  prefs: []
  type: TYPE_NORMAL
- en: Benefits of microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will discuss the benefits of developing microservices in
    our applications:'
  prefs: []
  type: TYPE_NORMAL
- en: Business logic can be grouped and developed into services that are easy to develop
    and deploy, with multiple service instances
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Microservices can avoid having a complex application by splitting the application
    into multiple services, providing easy to develop and maintain business logic,
    especially when we upgrade specific sections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Services can be deployed independently, without interrupting the application;
    hence, the end user will never feel any service interruption
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loosely coupled services will give more flexibility in terms of scaling the
    application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Upgrading services separately to meet trendy business requirements is handy,
    and developers can bring in new technologies to develop the service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Continuous deployment is easier to implement with the help of microservices;
    hence, a quick upgrade can be made on desired modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scaling these services will be very flexible, especially when specific business
    requirements need more instances to provide uninterrupted service to end users
    in the case of high traffic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Organizations can focus on small batches of work that they can move to production
    very quickly, especially when testing out new features for specific clients
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Microservice components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to have fully functional microservice applications, the following
    components have to be used properly. These components help us to solve complex
    business logic distribution among services:'
  prefs: []
  type: TYPE_NORMAL
- en: Configuration server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Load balancer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Service discovery
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Circuit breaker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Edge server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will briefly discuss these components in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A configuration server will help us store all configurable parameters for each
    service that will be deployed. These properties can be saved in a repository if
    needed. Also, the configuration server will give the option to change the configuration
    of our application without having to deploy the code. Once the configuration is
    changed, it will be automatically reflected on the fly, so we can avoid redeploying
    our services.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we will have many services in our microservice application, having a configuration
    server will help us to avoid service redeployment, and the service can get the
    corresponding configuration from the server. It is also one of the principles
    of continuous delivery: decoupling source code from the configuration.'
  prefs: []
  type: TYPE_NORMAL
- en: Load balancer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A load balancer acts as the backbone for scaling applications by allocating
    the load to specific services. The load balancer is considered a major player
    in microservice architecture. Unlike regular load balancers distributed among
    servers, these manage service instances and distribute the load among those instances.
    With the help of a service discovery component, they will get information about
    available service instances and distribute the loads.
  prefs: []
  type: TYPE_NORMAL
- en: Netflix Ribbon is used as a load balancer; we will explore this in the *Microservice
    tools* section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Circuit breaker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As there are many services working together in our architecture, each service
    might be inter-dependent. There are some situations that cause some services to
    fail and might be causing other services to fall down with them. To avoid such
    situations, our architecture should be fault-tolerant. Using patterns like circuit
    breaker can reduce failures in microservice architectures.
  prefs: []
  type: TYPE_NORMAL
- en: Edge server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The edge server implements the API Gateway pattern, and behaves like a wall
    for the APIs to the outside world. With the help of an edge server, all public
    traffic will be forwarded to our internal services. By doing this, end users will
    not be affected in the case of any changes in our services and internal structures
    in the future. Netflix Zuul is used as an edge server, and we will share a little
    bit about Zuul in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Microservice tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Netflix engineers contributed much to microservice development and introduced
    various components for microservice ecosystems. Here, we will discuss more components
    that might be involved with microservices:'
  prefs: []
  type: TYPE_NORMAL
- en: Netflix Eureka
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Netflix Zuul
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Cloud Config Server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Netflix Ribbon
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Cloud Netflix
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Security OAuth2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Netflix Hystrix and Turbine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Eclipse Microprofile
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will talk more about them in the coming sections.
  prefs: []
  type: TYPE_NORMAL
- en: Netflix Eureka
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Eureka plays the role of service discovery service in microservices. It allows
    microservices to register themselves at runtime and helps us locate services when
    needed. It is used for the load balancing and fail-over of middle-tier servers.
    Also, Eureka comes with a Java client (Eureka Client) to make service interaction
    easier. The Eureka server acts as a middle-tier (services level) load balancing
    tool by locating services in middle-tier servers. These middle-tier (services
    level) load balancing tool might not have been available for AWS-like clouds.
  prefs: []
  type: TYPE_NORMAL
- en: Though AWS **Elastic Load Balancer** (**ELB**) is available for load balancing
    services, it supports only end user web services such as traditional load balancers,
    not middle-tier load balancing.
  prefs: []
  type: TYPE_NORMAL
- en: In the Eureka server, the instances of the client know which services they have
    to talk to, as the Eureka load balancer focuses on instance levels as well. Eureka
    services are stateless, and hence they support scalability. As the server information
    is cached on the client side, load balancing is very helpful in the case of outages
    of load balancers.
  prefs: []
  type: TYPE_NORMAL
- en: Eureka is used in Netflix for memcached services, cassandra deployments, and
    other operations. The Eureka server is highly recommended for middle-tier services
    where local services should be disabled for the public.
  prefs: []
  type: TYPE_NORMAL
- en: Netflix developers initiated the Eureka server and made it open source. Later,
    Spring incorporated it into the Spring Cloud. In a microservice architecture,
    services should be fine-grained to improve the modularity of the application for
    development, testing, and maintenance.
  prefs: []
  type: TYPE_NORMAL
- en: Netflix Zuul
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Zuul acts as a front door gatekeeper to the public, and does not allow unauthorized
    external requests to pass through. It also provides the entry point to microservices
    in our server. Zuul uses Netflix Ribbon to lookup available services and routes
    external requests to the right service instances. Zuul supports dynamic routing,
    monitoring, and security.
  prefs: []
  type: TYPE_NORMAL
- en: 'Zuul''s different types of filter, like `PRE`, `ROUTING`, `POST`, and `ERROR`,
    help to achieve the following actions:'
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic routing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Insights and monitoring
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authentication and security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stress testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiregion resiliency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Static response handling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Zuul has multiple components:'
  prefs: []
  type: TYPE_NORMAL
- en: '`zuul-core`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`zuul-simple-webapp`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`zuul-netflix`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`zuul-netflix-webapp`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Cloud Netflix
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring Cloud provides interaction between third-party cloud technologies and
    the Spring programming model. Spring Cloud Netflix provides Netflix **Open Source
    Software** (**OSS**) integration support to work with Spring Boot through auto-configuration
    and binding to the Spring environment. By adding a few annotations in Spring Boot,
    we can build a large, distributed application, including Netflix components, as
    well.
  prefs: []
  type: TYPE_NORMAL
- en: Features such as service discovery, service creation, external configuration,
    router, and filter can be implemented in Spring Cloud Netfix with microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Netflix Ribbon
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Netflix is used by service consumers to find services at runtime. Ribbon gets
    the information from the Eureka server to locate the appropriate service instances.
    In the case of multiple instances available for Ribbon, it will apply load balancing
    mechanisms to spread requests over the available instances. Ribbon does not run
    as a separate service, but rather as an embedded component in each service consumer.
    Having client-side load balancing is a big benefit from using the service registry
    as the balancer lets the client pick the registered instance of a service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ribbon provides the following features:'
  prefs: []
  type: TYPE_NORMAL
- en: Load balancing rules (multiple and pluggable)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Service discovery integration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resilient over failures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support for cloud
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ribbon has sub-components, such as `ribbon-core`, `ribbon-eureka`, and `ribbon-httpclient`.
  prefs: []
  type: TYPE_NORMAL
- en: Netflix Ribbon acts as a client-side load balancer, and it can be integrated
    with Spring Cloud.
  prefs: []
  type: TYPE_NORMAL
- en: Netflix Hystrix
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every distributed environment is prone to service failures, which might happen
    often. In order to fix this issue, our architecture should be fault- and latency-tolerant.
    Hystrix is a circuit breaker that can help us avoid such situations, like service
    dependency failures. Hystrix prevents a service from being overloaded and isolates
    failures when they happen.
  prefs: []
  type: TYPE_NORMAL
- en: With Hystrix support, we can control the interactions between our microservices
    by adding latency tolerance and fault tolerance logic in them. Hystrix provides
    strong fallback options in the case of service failure and thus improves our system's
    overall resiliency. Without Hystrix, if an internal service fails, it might interrupt
    the API and break the user experience.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hystrix follows a few basic principles of resiliency, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Failure in service dependency should not cause any interruption for the end
    user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The API should react in the case of service dependency failure to take correct
    action
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Hystrix also has a circuit breaker fallback mechanism using these approaches:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Custom fallback**: Where the client library provides fallback, or local data
    instead to generate responses'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fail silent**: Fallback returns null, which is helpful in some cases'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fail fast**: Used in specific cases, such as HTTP 5XX responses'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Netflix Turbine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Turbine is used for aggregating all streams of **server-sent-event** (**SSE**)
    JSON data into one stream, which can be used for dashboard purposes. The Turbine
    tool is used in the Hystrix application, which has a real-time dashboard to aggregate
    data from multiple machines. Turbine can be used with any data source that supports
    the JSON format. Turbine is data-agnostic and able to view the JSON blob as a
    map of key and value pairs.
  prefs: []
  type: TYPE_NORMAL
- en: Netflix uses Turbine with a Eureka server plugin to handle instances that are
    joining and leaving clusters for various reasons, like autoscaling, being unhealthy,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: HashiCorp Consul
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Consul is a service discovery and configuration tool to support microservices.
    Consul was initiated by Hashi Corp in 2014, mainly focusing on distributed services
    across multiple data centers. Also, Consul keeps data safe and works with big
    infrastructures. By configuring services with keys and values, and finding the
    services it needs, Consul solves the core problem of microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Consul has servers and clients that form a single Consul cluster. In the Consul
    cluster, nodes will be able to store and replicate data. Discovering other members
    in the cluster happens automatically, with the help of at least one member's address.
    Also, Consul provides a dynamic infrastructure, so there is no extra coding/development
    needed for the auto-discovery of services.
  prefs: []
  type: TYPE_NORMAL
- en: Consul is made for both the DevOps community and application developers to support
    modern and elastic infrastructures.
  prefs: []
  type: TYPE_NORMAL
- en: Eclipse MicroProfile
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Eclipse MicroProfile was initiated by companies such as RedHat, IBM, and other
    groups, to provide a specification for building microservices. This project was
    started in 2016, and recently they have released the 1.2 version of MicroProfile.
    It mainly focuses on optimizing enterprise Java for microservice architectures.
    Both Payara Micro and Payara Servers are compatible with Eclipse MicroProfile.
  prefs: []
  type: TYPE_NORMAL
- en: Eclipse MicroProfile version 1.2 comes with a config API, health checks, fault
    tolerance, metrics, and other necessary tools to support microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have briefly discussed monoliths and their drawbacks. We
    then talked about microservices and their benefits, and related topics. Also,
    we talked about the basic principles of microservices, including resilience and
    fault tolerance.
  prefs: []
  type: TYPE_NORMAL
- en: In the later section of this chapter, we talked about microservice components
    and covered tools involved with microservices, such as Netflix Eureka, Zuul, and
    so on. In the next and final chapter, we will work on a Ticket management real-time
    scenario, with advanced CRUD operations, including authentication and authorization.
  prefs: []
  type: TYPE_NORMAL
