- en: Chapter 5. Managing Filesystems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Getting FileStore information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting FileSystem information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the SimpleFileVisitor class to traverse filesystems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deleting a directory using the SimpleFileVisitor class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copying a directory using the SimpleFileVisitor class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Processing the contents of a directory by using the DirectoryStream interface
    as explained in the *Filtering a directory using globbing* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing your own directory filter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitoring file events using WatchEvents
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the ZIP filesystem provider
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **filesystem** is one or more top-level root directories containing a hierarchy
    of files. A filesystem is supported by a file store that is the provider for the
    storage of the files. This chapter is concerned with obtaining information about
    these entities and typical filesystem tasks, such as determining the contents
    of a directory or monitoring filesystem events.
  prefs: []
  type: TYPE_NORMAL
- en: A file store represents a unit of storage. For example, it might represent a
    device, such as a `C` drive, a partition of a drive, or a volume. The `java.nio.file.FileStore`
    class supports file stores and provides several methods to this end. The *Getting
    FileStore information* recipe covers how to obtain basic information about a specific
    file store.
  prefs: []
  type: TYPE_NORMAL
- en: A filesystem supports access to a hierarchy of directories and files. It is
    represented in Java 7 with the `java.nio.file.FileSystem` class. Obtaining general
    information about a filesystem is covered in the *Getting FileSystem information*
    recipe. This includes how to obtain a list of root directories for a filesystem
    and the underlying file stores.
  prefs: []
  type: TYPE_NORMAL
- en: Traversing a directory hierarchy is useful for many applications. The *Using
    the SimpleFileVisitor class to traverse filesystems* recipe details the basic
    approach. This approach is used in the *Deleting a directory using the SimpleFileVisitor
    class* and *Copying a directory using the SimpleFileVisitor class* recipes.
  prefs: []
  type: TYPE_NORMAL
- en: When an operation is restricted to a single directory, the `java.nio.file.DirectoryStream`
    interface provides a convenient technique for examining each element in the directory
    as a `java.nio.file.Path` object. It is very easy to use a for each loop to process
    these paths. This approach is explored in the *Using the DirectoryStream interface
    to process the contents of a directory* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes we don't need the entire contents of a directory, but rather a subset
    of its elements. Java 7 provides a few approaches to filtering the contents of
    a directory as described in the *Filtering a directory using globbing* and *Writing
    your own directory filter* recipes. **Globbing** is a pattern-matching technique
    that is similar to regular expressions but is easier to use.
  prefs: []
  type: TYPE_NORMAL
- en: In the *Monitoring file events using WatchEvents* recipe we learn how Java 7
    supports the detection of file creation, modification, and deletion within a directory
    by external processes. This can be very useful when it is necessary to know when
    changes to a directory are made.
  prefs: []
  type: TYPE_NORMAL
- en: With Java 7, it is now possible to treat the contents of a ZIP file as a filesystem.
    This makes it easier to manage the contents of a ZIP file and to manipulate the
    files contained within the ZIP file. This technique is demonstrated in the *Understanding
    the zip filesystem provider* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting FileStore information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Each filesystem supports a file storage mechanism. This may be a device, such
    as a `C` drive, a partition of a drive, a volume, or some other way of organizing
    a filesystem's space. The `java.nio.file.FileStore` class represents one of these
    storage divisions. This recipe details the methods available to obtain information
    about the file store.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To obtain and use a `FileStore` object:'
  prefs: []
  type: TYPE_NORMAL
- en: Obtain an instance of the `java.nio.file.FileSystem` in use.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `FileSystem` class' `getFileStores` method to return the available file
    stores.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a new console application. In the `main` method, we will use several
    methods of the `FileStore` class to demonstrate the support provided by this class.
    Let's start by adding the first part of the `main` method, where we display an
    initial header and get a `FileSystem` object. Also, define a `long` variable called
    `kiloByte:`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to use the `getFileStores` method to retrieve the available file
    stores and then display them. In the first part of the block, we use several `FileStore`
    methods to get relevant information. In the last part, we display the information
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the application. Your output will differ from the following, but should
    reflect the drives on your system:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Name Filesystem Type Readonly Size(KB) Used(KB) Available(KB)**'
  prefs: []
  type: TYPE_NORMAL
- en: '**HP HP (C:) NTFS false 301,531,984 163,041,420 138,490,564**'
  prefs: []
  type: TYPE_NORMAL
- en: '**FACTORY_IMAGE FACTORY_IMAGE (D:) NTFS false 11,036,652 9,488,108 1,548,544**'
  prefs: []
  type: TYPE_NORMAL
- en: '**HP_PAVILION HP_PAVILION (E:) NTFS false 312,568,640 66,489,184 246,079,456**'
  prefs: []
  type: TYPE_NORMAL
- en: '**TOSHIBA TOSHIBA (H:) FAT32 false 15,618,080 3,160,768 12,457,312**'
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A format string was created to simplify the display of the file store information.
    This string was used in both of the `printf` methods. Using the same string twice
    ensures consistent spacing of the output. A simple title was displayed using this
    string.
  prefs: []
  type: TYPE_NORMAL
- en: A `FileSystem` object was obtained using the `FileSystems` class' `getDefault`
    method. The `getFileStores` method was executed against this object to obtain
    a list of `FileStore` objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within the loop, a try block was used to catch exceptions that might have been
    thrown. Several methods were invoked as detailed in the following table. An instance
    of the `NumberFormat` class was created to format file store size information.
    The last `printf` method displayed the file store information for each file store:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Meaning |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `getTotalSpace` | The total space available on the file store in bytes |'
  prefs: []
  type: TYPE_TB
- en: '| `getUnallocatedSpace` | The number of unallocated bytes |'
  prefs: []
  type: TYPE_TB
- en: '| `getUsableSpace` | The number of usable bytes available to the JVM |'
  prefs: []
  type: TYPE_TB
- en: '| `name` | An implementation-specific string representing the file store name
    |'
  prefs: []
  type: TYPE_TB
- en: '| `type` | An implementation-specific string representing the file store type
    |'
  prefs: []
  type: TYPE_TB
- en: '| `isReadOnly` | If the method returns `true`, then attempts to create a file
    or open a file for writing will result in an `IOException` being thrown |'
  prefs: []
  type: TYPE_TB
- en: The values returned by the `getUnallocatedSpace` or `getUsableSpace` methods
    can change if an external operation uses or releases space on the file store.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The attribute views as supported by a `FileStore` are determined using one of
    the two `supportsFileAttributeView` methods. These are illustrated in the *There's
    more..*. section of the *Determining operating system support for attribute views*
    recipe in [Chapter 3](ch03.html "Chapter 3. Obtaining File and Directory Information"),
    *Obtaining File and Directory Information*.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Filesystem information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A filesystem is composed of a hierarchy of directories and files. There is a
    limited amount of information regarding a filesystem that is normally useful.
    For example, we may want to know whether the filesystem is read-only or who the
    provider is. In this recipe we will examine the methods available to retrieve
    filesystem attributes.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To access the method of a filesystem we need to:'
  prefs: []
  type: TYPE_NORMAL
- en: Obtain a reference to a `java.nio.file.FileSystem` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the methods of this object to access filesystem information.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new console application. Add the following code to the `main` method
    of the application. This sequence displays several `fileSystem` attributes, including
    the filesystem provider, file open status, whether the file is available to be
    read-only, the root directories, and the names of the file stores:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the application. Your output will depend upon the configuration of
    your system. However, it should mimic the output that follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Provider: sun.nio.fs.WindowsFileSystemProvider@7b60e796**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Open: true**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Read Only: false**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Root Directories**'
  prefs: []
  type: TYPE_NORMAL
- en: '**C:\**'
  prefs: []
  type: TYPE_NORMAL
- en: '**D:\**'
  prefs: []
  type: TYPE_NORMAL
- en: '**E:\**'
  prefs: []
  type: TYPE_NORMAL
- en: '**F:\**'
  prefs: []
  type: TYPE_NORMAL
- en: '**G:\**'
  prefs: []
  type: TYPE_NORMAL
- en: '**H:\**'
  prefs: []
  type: TYPE_NORMAL
- en: '**I:\**'
  prefs: []
  type: TYPE_NORMAL
- en: '**J:\**'
  prefs: []
  type: TYPE_NORMAL
- en: '**K:\**'
  prefs: []
  type: TYPE_NORMAL
- en: '**L:\**'
  prefs: []
  type: TYPE_NORMAL
- en: '**File Stores**'
  prefs: []
  type: TYPE_NORMAL
- en: '**HP**'
  prefs: []
  type: TYPE_NORMAL
- en: '**FACTORY_IMAGE**'
  prefs: []
  type: TYPE_NORMAL
- en: '**HP_PAVILION**'
  prefs: []
  type: TYPE_NORMAL
- en: '**TOSHIBA**'
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `getDefault` method returned the default filesystem used by the JVM. Next,
    several methods were invoked against this object:'
  prefs: []
  type: TYPE_NORMAL
- en: The `provider` method returned the provider, that is, implementer of the filesystem.
    In this case, it was a Windows filesystem provider that came bundled with the
    JVM.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `isOpen` method indicated that the filesystem is open and ready for use.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `isReadOnly` method returned `false`, meaning that we can read and write
    to the system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We used the `getRootDirectories` method to create an `Iterable` object that
    permitted us to list each root directory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `getFileStores` method returned another `Iterable` object, which was used
    to display the names of the file stores.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While we do not normally need to close a filesystem, the `close` method can
    be used to close the filesystem. Any subsequent methods executed against the filesystem
    will result in a `ClosedFileSystemException` being thrown. Any open channels,
    directory streams, and watch services associated with the filesystem will also
    be closed. Note that the default filesystem cannot be closed.
  prefs: []
  type: TYPE_NORMAL
- en: The `FileSystems` class' `getFileSystem` method can be used to access a specific
    filesystem. In addition, the overloaded `newFileSystem` method will create new
    filesystems. The `close` method can be used with these instances.
  prefs: []
  type: TYPE_NORMAL
- en: Filesystems are thread-safe. However, if one thread attempts to close the filesystem
    while another thread is accessing the `filesystem` object, the close operation
    may be blocked
  prefs: []
  type: TYPE_NORMAL
- en: until the access is complete.
  prefs: []
  type: TYPE_NORMAL
- en: Using the SimpleFileVisitor class to traverse filesystems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When working with directory systems, a common need is to traverse the filesystem
    examining each subdirectory within a file hierarchy. This task has been made easy
    with the `java.nio.file.SimpleFileVisitor` class. This class implements methods
    that execute before and after a directory is visited. In addition, callback methods
    are invoked for each instance a file is visited in a directory and if an exception
    occurs.
  prefs: []
  type: TYPE_NORMAL
- en: The `SimpleFileVisitor` class or a derived class is used in conjunction with
    the `java.nio.file.Files` class' `walkFileTree` method. It performs a depth first
    traversal, starting at a specific root directory.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To traverse a directory we need to:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `Path` object representing the root directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an instance of a class derived from `SimpleFileVisitor`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use these objects as arguments to the `Files` class' `walkFileTree` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new console application and use the following `main` method. Here,
    we will traverse the `home` directory and list each of its elements as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following `ListFiles` class to your project. It illustrates the use
    of each of the `SimpleFileVisitor` methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the application. Depending on the structure of your `home` directory,
    you may get results different from the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**About to traverse the directory: home**'
  prefs: []
  type: TYPE_NORMAL
- en: '**About to traverse the directory: docs**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Visiting file:users.bak**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Visiting file:users.txt**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Finished with the directory: docs**'
  prefs: []
  type: TYPE_NORMAL
- en: '**About to traverse the directory: music**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Visiting file:Future Setting A.mp3**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Visiting file:Robot Brain A.mp3**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Visiting file:Space Machine A.mp3**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Finished with the directory: music**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Finished with the directory: home**'
  prefs: []
  type: TYPE_NORMAL
- en: Examine the `backup` directory to verify that it was created successfully.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the `main` method, we created a `Path` object for the `home` directory. Next,
    an instance of the `ListFiles` class was created. These objects were used as the
    arguments of the `walkFileTree` method. This method affected the traversal of
    the `home` directory and invoked the methods of the `ListFiles` class as required.
  prefs: []
  type: TYPE_NORMAL
- en: The `walkFileTree` method started at a root directory, and performed a depth
    first traversal of the directory hierarchy. Before a directory was traversed,
    the `preVisitDirectory` method was invoked. Next, each element of the directory
    was processed. If it was a file, then the `visitFile` method was invoked. Once
    all of the elements of the directory had been processed, the `postVisitDirectory`
    method was invoked. If an exception had occurred, then the `visitFileFailed` method
    would have been invoked.
  prefs: []
  type: TYPE_NORMAL
- en: Private helper methods were added, which made the output more readable. The
    `indentionAmount` variable controlled the depth of each indention. The `indentionLevel`
    variable was incremented and decremented as each subdirectory was visited. The
    `indent` method preformed the actual indention.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two overloaded `walkFileTree` methods. One takes a `Path` and a `FileVisitor`
    object, which was illustrated previously. It will not follow links and will visit
    all levels of the directory. The second method takes two additional arguments:
    one that specifies the number of directory levels to be visited and a second one
    to configure the traversal. Currently, the only configuration option available
    is `FileVisitOption.FOLLOW_LINKS`, which directs the method to follow symbolic
    links.'
  prefs: []
  type: TYPE_NORMAL
- en: Symbolic links are not followed by default. If they are followed when specified
    by an argument of the `walkFileTree` method, then care is taken to detect circular
    links. If a circular link is detected, it is treated as an error condition.
  prefs: []
  type: TYPE_NORMAL
- en: The number of levels of directories to visit is controlled by an integer argument.
    A value of 0 will result in only the top-level directory being visited. A value
    of `Integer.MAX_VALUE` means that all of the levels will be visited. A value of
    two means only the first two directory levels are traversed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The traversal will terminate when one of the following conditions occurs:'
  prefs: []
  type: TYPE_NORMAL
- en: All files have been traversed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `visit` method returns `FileVisitResult.TERMINATE`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `visit` method terminates with an `IOException`, or other exception is propagated
    back
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any unsuccessful action will generally result in the `visitFileFailed` method
    being invoked and an `IOException` being thrown.
  prefs: []
  type: TYPE_NORMAL
- en: When a file is encountered, and if it is not a directory, then an attempt is
    made to read its `BasicFileAttributes`. If successful, the attribute is passed
    to the `visitFile` method. If unsuccessful, the `visitFileFailed` method is invoked,
    and it will throw an `IOException` unless it is dealt with.
  prefs: []
  type: TYPE_NORMAL
- en: If the file is a directory and the directory can be opened, then the `preVisitDirectory`
    is invoked and the elements of the directory and their descendants are visited.
  prefs: []
  type: TYPE_NORMAL
- en: If the file is a directory and the directory could not be opened, the `visitFileFailed`
    method is invoked and it will throw an `IOException`. However, the depth-first
    search will continue with the next sibling.
  prefs: []
  type: TYPE_NORMAL
- en: The following table summarizes the traversal process.
  prefs: []
  type: TYPE_NORMAL
- en: '| Element encountered | Can be opened | Fails to open |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| File | `visitFile` is invoked | `visitFileFailed` is invoked |'
  prefs: []
  type: TYPE_TB
- en: '| Directory | `preVisitDirectory` is calledDirectory elements are processed`postVisitDirectory`
    is invoked | `visitFileFailed` is invoked |'
  prefs: []
  type: TYPE_TB
- en: 'For convenience, the enumeration constants for the enumeration `FileVisitResult`
    are listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Value | Meaning |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `CONTINUE` | Continue the traversal |'
  prefs: []
  type: TYPE_TB
- en: '| `SKIP_SIBLINGS` | Continue without visiting the siblings of this file or
    directory |'
  prefs: []
  type: TYPE_TB
- en: '| `SKIP_SUBTREE` | Continue without visiting the entries in this directory
    |'
  prefs: []
  type: TYPE_TB
- en: '| `TERMINATE` | Terminate |'
  prefs: []
  type: TYPE_TB
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Deleting a directory using the SimpleFileVisitor class* and *Copying a
    directory using the SimpleFileVisitor class* recipes utilize the approach described
    in this recipe to delete and copy a directory respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting a directory using the SimpleFileVisitor class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The ability to delete a directory is a requirement of some applications. This
    can be achieved using the `walkFileTree` method and a `java.nio.file.SimpleFileVisitor`
    derived class. This recipe builds on the foundation provided in the *Using the
    SimpleFileVisitor class to traverse filesystems* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To delete a directory, we need to:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `Path` object representing the root directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create an instance of a class derived from `SimpleFileVisitor` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Override the `visitFile` method to delete the file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Override the `postVisitDirectory` method to delete the directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use these objects as arguments to the `Files` class' `walkFileTree` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new console application. Here, we will delete the `home` directory
    and all of its elements. Add the following code to the `main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `DeleteDirectory` class is shown as follows. As each file and directory
    is deleted, a message is displayed to that effect:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Back up the `home` directory and then execute the application. You should get
    the following output depending on the actual directory structure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Deleting users.bak**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Deleting users.txt**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Deleting docs**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Deleting Future Setting A.mp3**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Deleting Robot Brain A.mp3**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Deleting Space Machine A.mp3**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Deleting music**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Deleting home**'
  prefs: []
  type: TYPE_NORMAL
- en: Verify that the directory was deleted.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the `main` method, we created a `Path` object representing the `home` directory.
    Next, we created an instance of the `DeleteDirectory` class. These two objects
    were used as arguments to the `walkFileTree` method, which started the traversal
    process.
  prefs: []
  type: TYPE_NORMAL
- en: When a file is encountered, the `visitFile` method was executed. In this method,
    we displayed a message indicating that the file was being deleted, and then used
    the `Files` class' `delete` method to delete the file. When a directory was encountered,
    the `postVisitDirectory` method was invoked. A test was made to ensure that no
    errors had occurred, and then a message was displayed indicating that the directory
    was being deleted followed by the invocation of the `delete` method for that directory.
    Both of the methods returned `FileVisitResult.CONTINUE`, which continues the deletion
    process.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Using the SimpleFileVisitor class to traverse filesystems* recipe provides
    more detail on the use of the `walkFileTree` method and the `SimpleFileVisitor`
    class. The *Copying a directory using the SimpleFileVisitor class* recipe also
    provides a variation of the use of this approach.
  prefs: []
  type: TYPE_NORMAL
- en: Copying a directory using the SimpleFileVisitor class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The ability to copy a directory is a requirement of some applications. This
    can be achieved using the `walkFileTree` method and a `java.nio.file.SimpleFileVisitor`
    derived class. This recipe builds on the foundation provided in the *Using the
    SimpleFileVisitor class to traverse filesystems* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To delete a directory, we need to:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `Path` object representing the root directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create an instance of a class derived from the `SimpleFileVisitor` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Override the `visitFile` method to copy the file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Override the `preVisitDirectory` method to copy the directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use these objects as arguments to the `Files` class' `walkFileTree` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new console application. Here, we will copy the `home` directory and
    all of its elements to a `backup` directory. Add the following code to the `main`
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The `CopyDirectory` class is shown as follows. As each file and directory is
    deleted, a message is displayed to that effect:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the application. The exact output is dependent on the source file structure
    you used, but should be similar to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Copying**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Copying docs**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Copying docs\users.bak**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Copying docs\users.txt**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Copying music**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Copying music\Future Setting A.mp3**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Copying music\Robot Brain A.mp3**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Copying music\Space Machine A.mp3**'
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the `main` method, we created `Path` objects for the `home` and `backup`
    directories. We used these objects to create a `CopyDirectory` object. We used
    a two-argument `CopyDirectory` constructor, so that its methods would have direct
    access to the two paths.
  prefs: []
  type: TYPE_NORMAL
- en: The `walkFileTree` method was invoked with the source `Path`. It was also passed
    as the second argument, an `EnumSet`, which specified that symbolic links were
    not to be followed. This argument required a set of options. The `EnumSet` class'
    static method created the set.
  prefs: []
  type: TYPE_NORMAL
- en: The third argument of the `walkFileTree` method was a value indicating how many
    levels to follow. We passed a value of `Integer.MAX_VALUE`, which results in all
    of the levels of the `home` directory being copied. The last argument was an instance
    of the `CopyDirectory` object.
  prefs: []
  type: TYPE_NORMAL
- en: When a file was encountered during the traversal, the `CopyDirectory` class'
    `visitFile` method was invoked. A message was displayed indicating that the file
    was being copied, followed by the use of the `copy` method to copy the source
    file to the target directory. The `relativize` method was used to obtain a relative
    path to the source, which was used as the argument of the `resolve` method. The
    result is a `Path` object representing the target directory with the source filename.
    These methods are discussed in the *Combining paths using path resolution* and
    *Creating a path between two locations* recipes in [Chapter 2](ch02.html "Chapter 2. Locating
    Files and Directories Using Paths"), *Locating Files and Directories Using Paths*.
  prefs: []
  type: TYPE_NORMAL
- en: When a directory was encountered during the traversal, the `preVisitDirectory`
    method was invoked. It works the same way as the `visitFile` method, except we
    copied a directory instead of a file. Both of the methods returned `FileVisitResult.CONTINUE`,
    which continues the copying process. It is still necessary to copy the individual
    files of a directory, since the `copy` method only copies a single file.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the `CopyDirectory` class extended the `SimpleFileVisitor` class
    using `Path` as the generic value. The `walkFileTree` method requires an object
    that implements the `Path` interface. Thus we had to use `Path` or an interface
    that extended `Path`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Using the SimpleFileVisitor class to traverse filesystems* recipe provides
    more detail on the use of the `walkFileTree` method and the `SimpleFileVisitor`
    class. The *Deleting a directory using the SimpleFileVisitor class* recipe also
    provides a variation on the use of this approach.
  prefs: []
  type: TYPE_NORMAL
- en: Processing the contents of a directory by using the DirectoryStream interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Determining the contents of a directory is a fairly common requirement. There
    are several approaches to doing this. In this recipe, we will examine the use
    of the `java.nio.file.DirectoryStream` interface in support of this task.
  prefs: []
  type: TYPE_NORMAL
- en: A directory will consist of files or subdirectories. These files may be regular
    files or possibly linked or hidden. The `DirectoryStream` interface will return
    all of these element types. We will use the `java.nio.file.Files` class' `newDirectoryStream`
    method to obtain a `DirectoryStream` object. There are three overloaded versions
    of this method. The simplest use of the method is illustrated first. The versions
    used to filter the contents of the directory are shown in the *Filtering a directory
    using globbing* recipe and the *Writing your own directory filter* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to use the `DirectoryStream`, we need to:'
  prefs: []
  type: TYPE_NORMAL
- en: Obtain an instance of a `DirectoryStream` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Iterate through the `DirectoryStream` to process its elements.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new console application and add the following `main` method. We create
    a new `DirectoryStream` object and then use a for each loop to iterate through
    the directory elements as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the application. Your output should reflect the contents of your `home`
    directory and should be similar to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**docs**'
  prefs: []
  type: TYPE_NORMAL
- en: '**music**'
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A `Path` object was created for the `home` directory. This object was used
    with the `newDirectoryStream` method, which returned a `DirectoryStream` object
    for the directory. The `DirectoryStream` interface extends the `Iterable` interface.
    This allowed the `DirectoryStream` object to be used with a for each statement,
    which simply printed the name of each element of the `home` directory. In this
    case, there were only two subdirectories: `docs` and `music`.'
  prefs: []
  type: TYPE_NORMAL
- en: Notice the use of the try-with-resource block. This is new to Java 7 and is
    discussed in the *Using the try-with-resource block to improve exception handling
    code* recipe found in [Chapter 1](ch01.html "Chapter 1. Java Language Improvements"),
    *Java Language Improvements*. This guarantees that the directory stream will be
    closed. If this type of try block was not used, then it is important to close
    the stream after it is no longer needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Iterable` object used is not a general-purpose `iterator`. It differs
    in several important aspects as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: It only supports a single `Iterator`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `hasNext` method performs a read-ahead of at least one element
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It does not support the `remove` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `DirectoryStream` interface has a single method, `iterator`, which returns
    an `Iterator` type object. The first time the method is invoked, an `Iterator`
    object is returned. Subsequent invocation of the method will throw an `IllegalStateException`.
  prefs: []
  type: TYPE_NORMAL
- en: The `hasNext` method will read ahead by at least one element. If the method
    returns `true`, then the next invocation of its next method is guaranteed to return
    an element. The order of the elements returned is not specified. Also, many operating
    systems have links to themselves and/or their parent as represented by a `".`"
    or `"..`" in many shells. These entries are not returned.
  prefs: []
  type: TYPE_NORMAL
- en: The `iterator` returned is sometimes referred to as **weakly consistent**. This
    means that while the `iterator` is thread-safe, any updates to the directory after
    the `iterator` has returned will not result in a change to the `iterator`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are two overloaded `newDirectoryStream` methods, which allow the results
    of the method to be filtered either by a globbing pattern or a `DirectoryStream.Filter`
    object. A **globbing pattern** is a string containing a series of characters that
    define a pattern. The pattern is used to determine which directory elements to
    return. A `DirectoryStream.Filter` interface has a single method, `accept`, which
    returns a Boolean value indicating whether the directory element should be returned
    or not.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Filtering a directory using globbing* recipe illustrates the use of the
    globbing pattern. The *Writing your own directory filter* recipe shows how to
    create and use a `DirectoryStream.Filter` object to filter the contents of a directory.
  prefs: []
  type: TYPE_NORMAL
- en: Filtering a directory using globbing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A globbing pattern is similar to a regular expression but it is simpler. Like
    a regular expression it can be used to match specific character sequences. We
    can use globbing in conjunction with the `newDirectoryStream` method to filter
    the contents of a directory. The use of this method is demonstrated in the *Using
    the DirectoryStream interface to process the contents of a directory* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To use this technique we need to:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a globbing string that meets our filtering requirements.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `java.nio.file.Path` object for the directory of interest.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use these two objects as arguments to the `newDirectoryStream` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new console application and use the following `main` method. In this
    example, we will list only those directory elements that start with `java` and
    end with `.exe`. We will use the Java 7 `bin` directory. The `globbing` string
    uses the special character, `*` to represent zero or more characters as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the application. The output should be similar to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**java-rmi.exe**'
  prefs: []
  type: TYPE_NORMAL
- en: '**java.exe**'
  prefs: []
  type: TYPE_NORMAL
- en: '**javac.exe**'
  prefs: []
  type: TYPE_NORMAL
- en: '**javadoc.exe**'
  prefs: []
  type: TYPE_NORMAL
- en: '**javah.exe**'
  prefs: []
  type: TYPE_NORMAL
- en: '**javap.exe**'
  prefs: []
  type: TYPE_NORMAL
- en: '**javaw.exe**'
  prefs: []
  type: TYPE_NORMAL
- en: '**javaws.exe**'
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, a `Path` object representing the `bin` directory was created. It was
    then used as the first argument to the `newDirectoryStream` method. The second
    argument was the `globbing` string. In this case, it matched a directory element
    which started with `java` and ended with `.exe`. Any number of intermediate characters
    were allowed. A for each loop was then used to display the filtered files.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Globbing strings are based on patterns, which use special characters to match
    string sequences. These are defined in the documentation for the `Files` class''
    `getPathMatcher` method. Here, we will examine those strings in more depth. There
    are several special characters summarized in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Special Symbols | Meaning |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| * | Matches zero or more characters of a name component without crossing
    directory boundaries |'
  prefs: []
  type: TYPE_TB
- en: '| ** | Matches zero or more characters crossing directory boundaries |'
  prefs: []
  type: TYPE_TB
- en: '| ? | Matches exactly one character of a name component |'
  prefs: []
  type: TYPE_TB
- en: '| \ | The escape character used to match the special symbols |'
  prefs: []
  type: TYPE_TB
- en: '| [ ] | Matches a single character found within the brackets. A - matches a
    range. A ! means negation. The *, ?, and \ characters match themselves, and a
    - matches itself if it is the first character within the brackets or the first
    character after the !. |'
  prefs: []
  type: TYPE_TB
- en: '| { } | Multiple subpatterns can be specified at the same time. These patterns
    are grouped together using the curly braces, but are separated within the curly
    braces by commas. |'
  prefs: []
  type: TYPE_TB
- en: Matching is typically performed in an implementation-dependent manner. This
    includes whether matching is case sensitive or not. The `**` symbol is not applicable
    here, since the `newDirectoryStream` method returns individual elements. There
    is no opportunity here to match sequences that cross directory boundaries. Other
    methods will use this capability.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table presents several examples of potentially useful globbing
    patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Globbing String | Will Match |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `*.java` | Any filename that ends with `.java` |'
  prefs: []
  type: TYPE_TB
- en: '| `*.{java,class,jar}` | Any file that ends with `.java, .class`, or `.jar`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `java*[ph].exe` | Only those files that start with java and are terminated
    with either a `p.exe` or `h.exe` |'
  prefs: []
  type: TYPE_TB
- en: '| `j*r.exe` | Those files that start with a `j` and end with an `r.exe` |'
  prefs: []
  type: TYPE_TB
- en: Now, let's discuss the use of the `PathMatcher` interface.
  prefs: []
  type: TYPE_NORMAL
- en: Using the PathMatcher interface to filter a directory
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `java.nio.file.PathMatcher` interface provides a method of matching a filename
    using a **glob**. It has a single method `matches`, which accepts a `Path` argument.
    If the file matches the glob pattern, then it returns `true`. Otherwise, it returns
    `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code sequence, we modify the previous example by creating
    a `PathMatcher` object using the glob pattern: `glob:java?.exe`. Within the for
    loop, we use the `matches` method to further filter a subset of the file that
    starts with `java` and is followed by a single character and then ends with `.exe:`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'When you execute this sequence, you should get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '**javac.exe**'
  prefs: []
  type: TYPE_NORMAL
- en: '**javah.exe**'
  prefs: []
  type: TYPE_NORMAL
- en: '**javap.exe**'
  prefs: []
  type: TYPE_NORMAL
- en: '**javaw.exe**'
  prefs: []
  type: TYPE_NORMAL
- en: Notice the use of the **glob:** prefix used with the `matches` method. Its use
    is required with this method, but not with the `newDirectoryStream` method. Also,
    the `matches` method takes a `Path` argument. However, notice that we used the
    `String` returned from the `Path` class' `getFileName` method. Using the `Path`
    object only or using a `String` literal does not work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of using the glob: prefix, we can use regular expressions instead.
    To do this, use a **reg:** prefix followed by a regular expression.'
  prefs: []
  type: TYPE_NORMAL
- en: Normally, for a simple filtering of a directory, we would use the more restrictive
    glob pattern as part of the `newDirectoryStream` method. We used it here for illustrative
    purposes. However, if we wanted to perform more than one filtering operation as
    part of a loop, then using a pattern as part of the `newDirectoryStream` method,
    and later with the use of one or more `matches` method invocations is a viable
    strategy.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Writing your own directory filter* recipe explores how to create more powerful
    filters to match filenames based on attributes other than the filename.
  prefs: []
  type: TYPE_NORMAL
- en: Writing your own directory filter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A directory filter is used to control which directory elements are returned,
    when using the `java.nio.file.Files` class' `newDirectoryStream` method. This
    is useful when we need to limit the stream's output. For example, we may only
    be interested in those files that exceed a certain size or were last modified
    after a certain date. The `java.nio.file.DirectoryStream.Filter` interface, as
    described in this recipe will restrict the stream's output. It is more powerful
    than using globbing as described in the *Filtering a directory using globbing*
    recipe because decisions can be based on factors other than the filename.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To use this technique we need to:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `DirectoryStream.Filter` object that meets our filtering requirements.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `Path` object for the directory of interest.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use these two objects as arguments to the `newDirectoryStream` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new console application and add the following sequence to the `main`
    method. In this example, we will filter out only those directory elements that
    are hidden. We will use the Windows system directory. However, any other appropriate
    directory will work:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'When executed, your output should list only those files that are hidden. The
    following is one possible output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**SwSys1.bmp**'
  prefs: []
  type: TYPE_NORMAL
- en: '**SwSys2.bmp**'
  prefs: []
  type: TYPE_NORMAL
- en: '**WindowsShell.Manifest**'
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, we created an anonymous inner class to define an object that implements
    the `DirectoryStream.Filter` interface. In the `accept` method, the `isHidden`
    method was used to determine whether the element file was hidden or not. The `DirectoryStream.Filter`
    interface used its `accept` method to determine whether a directory element should
    be returned or not. This method returned either a `true` or a `false` indicating
    whether the element should or should not be returned by the `newDirectoryStream`
    method, respectively. Thus, it filters out the **undesirables**, which in this
    case were non-hidden elements. A for each loop was used to display the hidden
    elements. When the `filter` variable was declared, it was declared using `Path`
    as its generic value. Interfaces that extended the `Path` interface could also
    be used.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This technique filters a single directory. If more than one directory needs
    to be filtered, then the example used in the *Using the SimpleFileVisitor class
    to traverse filesystems* recipe can be adapted to address multiple directories.
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring file events using WatchEvents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When an application needs to be aware of changes in a directory, a watch service
    can listen to the changes and then inform the application of these changes. The
    service will register a directory to be monitored based on the type of event that
    is of interest. When the event occurs, a watch event is queued and can subsequently
    be processed as dictated by the needs of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To monitor a directory for events, we need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `java.nio.file.Path` object representing the directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new watch service using the `java.nio.file.FileSystem` class' `newWatchService`
    method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Determine which events we are interested in monitoring.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Register the directory and events with the watch service.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Process the events as they occur.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new console application. We will add code to the `main` method to
    create a watch service, determine the events we want to watch, register the `docs`
    directory with the service, and then process the events. Let''s start by creating
    the watch service and a `Path` object for the directory. Add the following code
    to the `main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create an array of watch events to monitor for file creation, deletion,
    and modification as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following while loop to monitor and process any directory events:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the application. You should get the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Waiting for a watch event**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using a text editor, create a new file called `temp.txt` and save it in the
    `docs` directory. The application should then display output similar to the following.
    Your output may differ if this is the first time you created the file in the directory.
    These entries indicate that the file has been created and its contents are then
    saved:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Path being watched: \home\docs**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Kind: ENTRY_CREATE**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Context: temp.txt**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Count: 1**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Waiting for a watch event**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Path being watched: \home\docs**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Kind: ENTRY_MODIFY**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Context: temp.txt**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Count: 2**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Waiting for a watch event**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, save the file again. You should now get the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Path being watched: \home\docs**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Kind: ENTRY_MODIFY**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Context: temp.txt**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Count: 1**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Waiting for a watch event**'
  prefs: []
  type: TYPE_NORMAL
- en: 'From file manager, delete the file. Your output should reflect its deletion:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Kind: ENTRY_DELETE**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Context: temp1.txt**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Count: 1**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Waiting for a watch event**'
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first thing we needed was a `WatchService` object. This was acquired by
    obtaining the default filesystem and then applying the `newWatchService` method
    to it. Next, we created a `Path` object representing the `docs` directory and
    an array of events that cover creation, deletion, and modification type events.
  prefs: []
  type: TYPE_NORMAL
- en: An infinite loop was then entered to monitor and handle file events that occur
    in the `docs` directory. The loop started by displaying a message indicating that
    it was waiting for events. The `WatchService` class' `take` method was executed.
    This method will block until an event occurs.
  prefs: []
  type: TYPE_NORMAL
- en: When an event occurred, it returned with a `WatchKey` object, which contained
    information about the event. Its `watchable` method returned the object being
    watched, which was then displayed for informational purposes.
  prefs: []
  type: TYPE_NORMAL
- en: The watch key was verified to be valid using the `isValid` method, and its `pollEvents`
    method was used as part of a for each loop. The `pollEvents` method returned a
    list of all pending events. The type, context, and count value associated with
    the event were displayed.
  prefs: []
  type: TYPE_NORMAL
- en: The context for the events that we monitored was the relative path between the
    target directory and the entry that caused the event. The count value depends
    on the event and is addressed in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: The last activity reset the watch key. This was needed to put the key back into
    a ready state until it is needed again. If the method returned `false`, then the
    key is no longer valid.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `WatchService` interface possesses methods to get a watch key and to close
    the service. The `poll` and `take` methods retrieve the next watch key as we saw
    earlier. The `poll` method will return `null` if there are none present. However,
    the `take` method will block until a watch key is available. There is an overloaded
    `poll` method that takes additional arguments to specify how long to wait for
    an event before returning. These arguments include a time out value and a `TimeUnit`
    value. The use of the `TimeUnit` enumeration is discussed in the *Understanding
    the FileTime class section of the Setting time related attributes of a file or
    directory* recipe in [Chapter 4](ch04.html "Chapter 4. Managing Files and Directories"),
    *Managing Files and Directories*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Path` class'' `register` method will register a file specified by the
    `Path` object that it is executing against. The method takes arguments that:'
  prefs: []
  type: TYPE_NORMAL
- en: Specify the watch service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The kind of events it is to monitor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modifiers that determine how the `Path` object is registered
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `WatchEvent.Modifier` interface specifies how a `Path` object is to be registered
    with a watch service. In this release of Java, there are no defined modifiers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `java.nio.file.StandardWatchEventKinds` class defines the standard event
    types. The fields of this interface are summarized in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Kind | Meaning | Count |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `ENTRY_CREATE` | Directory entry created | Always a 1 |'
  prefs: []
  type: TYPE_TB
- en: '| `ENTRY_DELETE` | Directory entry deleted | Always a 1 |'
  prefs: []
  type: TYPE_TB
- en: '| `ENTRY_MODIFY` | Directory entry modified | 1 or greater |'
  prefs: []
  type: TYPE_TB
- en: '| `OVERFLOW` | A special event to indicate that events may have been lost or
    discarded | Greater than 1 |'
  prefs: []
  type: TYPE_TB
- en: When an event occurs, the watch service will return a `WatchKey` object representing
    the event. This key is reused for multiple occurrences of the same event type.
    When an event of that type occurs, the count associated with the event is incremented.
    If multiple events of that type occur before the events are processed, the count
    value is incremented each time by some amount. The amount is dependent on the
    type of event.
  prefs: []
  type: TYPE_NORMAL
- en: The use of the `reset` method in the previous example will re-queue the watch
    key and reset the count to zero. For repeated events, the context is the same.
    Each directory entry will have its own watch key for that event type.
  prefs: []
  type: TYPE_NORMAL
- en: An event can be canceled using the `WatchKey` interface's `cancel` method. This
    will unregister the event with the watch service. Any pending events in the queue
    will remain in the queue until removed. Watch events are also canceled if the
    watch service is closed.
  prefs: []
  type: TYPE_NORMAL
- en: The watch service is thread-safe. This implies that if multiple threads are
    accessing events, then care should be taken when using the `reset` method. The
    method should not be used until all of the threads using that event have completed
    processing the event.
  prefs: []
  type: TYPE_NORMAL
- en: The watch service can be closed using the `close` method. If multiple threads
    are using this service, then subsequent attempts to retrieve a watch key will
    result in a `ClosedWatchServiceException`.
  prefs: []
  type: TYPE_NORMAL
- en: A filesystem may be able to report events faster than the watch service can
    handle them. Some implementations of a watch service may impose a limit of the
    number of events queued. When events are intentionally ignored, then an event
    of the type `OVERFLOW` is used to report this problem. Overflow events are automatically
    registered for a target. The context of an overflow event is implementation-dependent.
  prefs: []
  type: TYPE_NORMAL
- en: 'Many aspects of the watch service are implementation-dependent including:'
  prefs: []
  type: TYPE_NORMAL
- en: Whether a native event notification service is used or simulated
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How timely the events are enqueued
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The order in which events are handled
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whether short-lived events are even reported
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the ZIP filesystem provider
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Handling ZIP files is much simpler than it was prior to Java 7\. The ZIP filesystem
    provider introduced in this release handles ZIP and JAR files as though they were
    filesystems and, as a result, you can easily access the contents of the file.
    You can manipulate the file as you would do ordinary files, including copying,
    deleting, moving, and renaming the file. You also have the ability to modify certain
    attributes of the file. This recipe will show you how to create an instance of
    a ZIP filesystem and add directories to the system.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We must first create an instance of a `java.net.URI` object to represent our
    ZIP file, and then create the new `java.nio.file.FileSystem` before we can do
    any manipulations of the contents of the ZIP file. In this example, we will also
    use a `java.util.HashMap` to set an optional property of the `FileSystem` as follows:.
  prefs: []
  type: TYPE_NORMAL
- en: Create a `URI` object to represent the ZIP file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `HashMap` object to specify the `create` property as `true`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `FileSystem` object using the `newFileSystem` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a console application with a `main` method. In the `main` method, add
    the following code sequence. We will create a new filesystem within a ZIP file,
    and then add a directory to it as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the program. Your output should appear as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**docs/**'
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `URI` object specifies the location of your ZIP file by using a `HashMap`
    object, we specified that if the ZIP file does not exist, it should be created.
    The `FileSystem` object, `zipFileSys`, was created in the try-with-resources block,
    so the resource will automatically be closed, but if you do not wish to use the
    nested try-with-resources block you must use the `FileSystem` class'' `close`
    method to close the resource manually. The try-with-resources block is detailed
    in [Chapter 1](ch01.html "Chapter 1. Java Language Improvements"), *Java Language
    Improvements*, recipe: *Using the try-with-resources block to improve exception
    handling code*.'
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate how ZIP files can be manipulated as `FileSystem` objects, we
    invoked the `createDirectory` method to add a folder within our ZIP file. At this
    point, we also had the option to perform other `FileSystem` operations, such as
    copying files, renaming files, and deleting files. We used a `java.nio.file.DirectoryStream`
    to navigate through our ZIP file structure and print out our `docs` directory,
    but you can also navigate on your computer to the location of the ZIP file to
    verify its creation.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See the *Using the DirectoryStream interface to process the contents of a directory*
    recipe for more information on the `DirectoryStream` class.
  prefs: []
  type: TYPE_NORMAL
