- en: Adding Users to MyMDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In our preceding chapter, we started our project and created our `core` app
    and our `core` models (`Movie` and `Person`). In this chapter, we will build on
    that foundation to do the following things:'
  prefs: []
  type: TYPE_NORMAL
- en: Let users register, log in, and log out
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let logged in users vote movies up/down
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Score each movie based on the votes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use votes to recommend the top 10 movies.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start this chapter with managing users.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the user app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you will create a new Django app, called `user`, register it
    with your project, and make it manage users.
  prefs: []
  type: TYPE_NORMAL
- en: At the beginning of [Chapter 1](df6a3177-07c4-4edb-84b8-a01a6fd8ad0e.xhtml),
    *Building MyMDB*, you learned that a Django project is made up of many Django
    apps (such as our existing `core` app). A Django app should provide well-defined
    and tightly scoped behavior. Adding user management to our `core` app violates
    that principle. Making a Django app bear too many responsibilities makes it harder
    to test and harder to reuse. For example, we’ll be reusing the code we write in
    this `user` Django app throughout this book.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new Django app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we did when we created the `core` app, we will use `manage.py` to generate
    our `user` app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''ll register it with our Django project by editing our `django/config/settings.py`
    file and updating the `INSTALLED_APPS` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We will need to put `user` before the `admin` app for reasons that we'll discuss
    in the *Logging in and out* section. Generally, it's a good idea to put our apps
    above built-in apps.
  prefs: []
  type: TYPE_NORMAL
- en: Our `user` app is now a part of our project. Usually, we would now move on to
    creating and defining models for our app. However, thanks to Django’s built-in `auth`
    app, we already have a user model that we can use.
  prefs: []
  type: TYPE_NORMAL
- en: If we want to use a custom user model, then we can register it by updating `settings.py`
    and setting `AUTH_USER_MODEL` to a string python path to the model (for example, `AUTH_USER_MODEL=myuserapp.models.MyUserModel`).
  prefs: []
  type: TYPE_NORMAL
- en: Next, we'll create our user registration view.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a user registration view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our `RegisterView` class will be responsible for letting users register for
    our site. If it receives a `GET` request, then it will show them the `UserCreationFrom`;
    if it gets a `POST` request, it will validate the data and create the user. `UserCreationForm`
    is provided by the `auth` app and provides a way to collect and validate the data
    required to register a user; also, it is capable of saving a new user model if
    the data is valid.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add our view to `django/user/views.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a look at our code line by line:'
  prefs: []
  type: TYPE_NORMAL
- en: '`class RegisterView(CreateView):`: Our view extends `CreateView`, so it doesn''t
    have to define how to handle `GET` and `POST` requests, as we will discuss in
    the following steps.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`template_name = ''user/register.html''`: This is a template that we''ll create.
    Its context will be a little different than what we''ve seen before; it won''t
    have an `object` or `object_list` variables but will have a `form` variable, which
    is an instance of the class we set in the `form_class` attribute.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`form_class = UserCreationForm`: This is the form class that this `CreateView`
    should use. Simpler models could just say `model = MyModel`, but a user is a little
    more complex because passwords need to be entered twice then hashed. We’ll talk
    about how Django stores password in [Chapter 3](0121ce03-4293-49ea-b9ab-fb7956cb1a3c.xhtml),
    *Posters, Headshots, and Security*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`success_url = reverse_lazy(''core:MovieList'')`: When model creation succeeds,
    this is the URL that you need to redirect to. This is actually an optional parameter;
    if the model has a method called `model.get_absolute_url()`, then that will be
    used and we don''t need to provide `success_url`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The behavior of `CreateView` is spread across a number of base classes and mixins
    that interact through methods that act as hooks we can override to change behavior.
    Let's take a look at some of the most critical points.
  prefs: []
  type: TYPE_NORMAL
- en: If `CreateView` receives a `GET` request, it will render the template for the
    form. One of the ancestors of `CreateView` is `FormMixin` which overrides `get_context_data()`
    to call `get_form()` and add the form instance to our template's context. The
    rendered template is returned as the body of the response by `render_to_response`.
  prefs: []
  type: TYPE_NORMAL
- en: If `CreateView` receives a `POST` request, it will also use `get_form()` to
    get the form instance. The form will be *bound* to the `POST` data in the request.
    A bound form can validate the data it is bound to. `CreateView` will then call
    `form.is_valid()` and either `form_valid()` or `form_invalid()` as appropriate.
    `form_valid()` will call `form.save()` (saving the data to the database) then
    return a 302 response that will redirect the browser to `success_url`. The `form_invalid()` method will
    re-render the template with the form (which will now contain error messages for
    the user to fix and resubmit).
  prefs: []
  type: TYPE_NORMAL
- en: We're also seeing `reverse_lazy()` for the first time. It's a lazy version of
    `reverse()`. Lazy functions are functions that return a value that is not resolved
    until it is used. We can't use `reverse()` because views classes are evaluated
    while the full set of URLConfs are still being built, so if we need to use `reverse()` at
    the *class* level of a view, we must use `reverse_lazy()`. The value will not
    resolved until the view returns its first response.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's create the template for our view.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the RegisterView template
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In writing a template with a Django form, we must remember that Django doesn''t
    provide the `<form>` or `<button type=''submit>` tags, just contents of the form
    body. This lets us potentially include multiple Django forms in the same `<form>`.
    With that in mind, let’s add our template to `django/user/templates/user/register.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Like our previous templates, we extend `base.html` and put our code in one of
    the existing `block` s (in this case, `main`). Let's take a closer look at how
    forms render.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a form is rendered, it renders in two parts, first an optional `<ul class=''errorlist''>` tag
    of general error messages (if any), then each field is rendered in four basic
    parts:'
  prefs: []
  type: TYPE_NORMAL
- en: a `<label>` tag with the field name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a `<ul class="errorlist">` tag with errors from the user's previous form submission;
    this will only render if there were errors for that field
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: an `<input>` (or `<select>`) tag to accept input
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a `<span class="helptext">` tag for the field's help text
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Form` comes with the following three utility methods to render the form:'
  prefs: []
  type: TYPE_NORMAL
- en: '`as_table()`: Each field is wrapped in a `<tr>` tag with the label in a `<th>` tag
    and the widget wrapped in a `<td>` tag. The containing `<table>` tag is not provided.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`as_ul`: The entire field (label and help text widget) is wrapped in a `<li>` tag.
    The containing `<ul>` tag is not provided.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`as_p`: The entire field (label and help text widget) is wrapped in a `<p>` tag.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Containing `<table>` and `<ul>` tags are not provided for the same form that
    a `<form>` tag is not provided, to make it easier to output multiple forms together
    if necessary.
  prefs: []
  type: TYPE_NORMAL
- en: If you want fine-grained control over form rendering, `Form` instances are iterable,
    yielding a `Field` in each iteration, or can be looked up by name as `form["fieldName"]`.
  prefs: []
  type: TYPE_NORMAL
- en: In our example, we use the `as_p()` method because we don't need fine-grained
    layout control.
  prefs: []
  type: TYPE_NORMAL
- en: This template is also the first time we will see the `csrf_token` tag. CSRF
    is a common vulnerability in web apps that we'll discuss more in [Chapter 3](0121ce03-4293-49ea-b9ab-fb7956cb1a3c.xhtml),
    *Posters, Headshots, and Security*. Django automatically checks all `POST` and
    `PUT` requests for a valid `csrfmiddlewaretoken` and header. Requests missing
    this won’t even reach the view, but will get a `403 Forbidden` response.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our template, let's add a `path()` object to our view in our
    URLConf.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a path to RegisterView
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our `user` app doesn''t have a `urls.py` file, so we''ll have to create the `django/user/urls.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''ll have to `include()` this URLConf in our root URLConf in `django/config/urls.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Since URLConf will only search until the *first* matching `path` is found, we
    always want to put `path`s with no prefix or with the broadest URLConfs last so
    that they don't accidentally block other views.
  prefs: []
  type: TYPE_NORMAL
- en: Logging in and out
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Django''s `auth` app provides views for logging in and out. Adding this to
    our project will be a two-step process:'
  prefs: []
  type: TYPE_NORMAL
- en: Registering the views in the `user` URLConf
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adding templates for the views
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Updating user URLConf
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Django's `auth` app provides a lot of views to help make user management and
    authentication easier, including logging in/out, changing passwords, and resetting
    forgotten passwords. A full-featured production app should offer all three features
    to users. In our case, we will restrict ourselves to just log in and log out.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s update `django/user/urls.py` to use log in and log out views of `auth`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If you''re providing log in/log out, password change, and password reset, then
    you can use URLConf of `auth` as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's add the template.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a LoginView template
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, let''s add a template for the login page in `django/user/templates/registration/login.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code looks very similar to `user/register.html`.
  prefs: []
  type: TYPE_NORMAL
- en: However, what should happen when the user logs in?
  prefs: []
  type: TYPE_NORMAL
- en: A successful login redirect
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In `RegisterView`, we were able to specify where to redirect the user after
    success because we created the view. The `LoginView` class will follow these steps
    to decide where to redirect the user:'
  prefs: []
  type: TYPE_NORMAL
- en: Use the `POST` parameter `next` if it is a valid URL and point at a server hosting
    this application. `path()` names are not available.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `GET` parameter `next` if it is a valid URL and point at a server hosting
    this application. `path()` names are not available.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`LOGIN_REDIRECT_URL` setting which has a default of `''/accounts/profile/''`.
    `path()` names *are* available.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In our case, we want to redirect all users to the movie list, so let''s update
    `django/config/settings.py` to have a `LOGIN_REDIRECT_URL` setting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: However, if there were cases where we wanted to redirect users to a specific
    page, we could use the `next` parameter to specifically redirect them to a particular
    page. For example, if a user tries to perform an action before they're logged
    in, we pass the page they were on to `LoginView` as a `next` parameter to redirect
    them back to the page they were on after logging in.
  prefs: []
  type: TYPE_NORMAL
- en: Now, when a user will log in, they will be redirected to our Movie List view.
    Next, let’s create a template for the logout view.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a LogoutView template
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `LogoutView` class behaves strangely. If it receives a `GET` request, it
    will log the user out and then try to render `registration/logged_out.html`. It's
    unusual for `GET` requests to modify a user's state, so it's worth remembering
    that this view is a bit different.
  prefs: []
  type: TYPE_NORMAL
- en: There's another wrinkle with the `LogoutView` class. If you don't provide a
    `registration/logged_out.html` template and you have the `admin` app installed,
    then Django *may* use the template of `admin` because the `admin` app does have
    that template (log out of the `admin` app, and you’ll see it).
  prefs: []
  type: TYPE_NORMAL
- en: 'The way that Django resolves template names into files is a three-step process
    that stops as soon as a file is found, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Django iterates over the directories in the `DIRS` list in `settings.TEMPLATES`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If `APP_DIRS` is `True`, then it will iterate over the apps listed in `INSTALLED_APPS`
    until a match is found. If `admin` comes before `user` in the `INSTALLED_APPS`
    list, then it will match first. If `user` comes first, `user` will match first.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Raise a `TemplateDoesNotExist` exception.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is why we put `user` first in our list of installed apps and added a comment
    warning future developers not to change the order.
  prefs: []
  type: TYPE_NORMAL
- en: We're now done with our `user` app. Let's review what we've accomplished.
  prefs: []
  type: TYPE_NORMAL
- en: A quick review of the section
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've created a `user` app to encapsulate user management. In our `user` app,
    we leveraged a lot of functionalities that Django's `auth` app provides, including `UserCreationForm`,
    `LoginView`, and `LogoutView` classes. We've also learned about some new generic
    views that Django provides and used `CreateView` in combination with the `UserCreationForm` class
    to make the `RegisterView` class.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have users, let's allow them to vote on our movies.
  prefs: []
  type: TYPE_NORMAL
- en: Letting users vote on movies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Part of the fun of community sites such as IMDB is being able to vote on the
    movies we love and hate. In MyMDB, users will be able to vote for movies with
    either a ![](img/0c9c7943-1c53-4ac8-9020-ef1441b7b361.png) or a ![](img/0c525625-fa6c-4afe-a5a6-49f32529c098.png).
    A movie will have a score, which is the number of ![](img/0c9c7943-1c53-4ac8-9020-ef1441b7b361.png)
     minus the number of ![](img/0c525625-fa6c-4afe-a5a6-49f32529c098.png).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the most important part of voting: the `Vote` model.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Vote model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In MyMDB, each user can have one vote per movie. The vote can either be positive—![](img/99b1dc6e-8da4-459c-ac70-7ea8c550c455.png)—or
    negative—![](img/184747c1-7c19-4599-8fd8-d8319dab8d5c.png).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s update our `django/core/models.py` file to have our `Vote` model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This model has the following four fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '`value`, which must be `1` or `-1`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`user` is a `ForeignKey`, which references the `User` mode through `settings.AUTH_USER_MODEL`.
    Django recommends that you never reference `django.contrib.auth.models.User` directly
    but using either `settings.AUTH_USER_MODEL` or `django.contrib.auth.get_user_model()`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`movie` is a `ForeignKey` referencing a `Movie` model.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`voted_on` is a `DateTimeField` with `auto_now` enabled. The `auto_now` argument
    makes the model update the field to the current date time every time the model
    is saved.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `unique_together` attribute of Meta creates a unique constraint on the table.
    A unique constraint will prevent two rows having the same value for both `user`
    and `movie`, enforcing our rule of one vote per user per movie.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a migration for our mode with `manage.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, let''s run our migration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have our model and table set up, let's create a form to validate
    votes.
  prefs: []
  type: TYPE_NORMAL
- en: Creating VoteForm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Django's forms API is very robust and lets us create almost any kind of form
    we want. If we want to create an arbitrary form, we can create a class that extends
    `django.forms.Form` and add whatever fields we want to it. However, if we want
    to build a form that represents a model, Django offers us a shortcut with `django.forms.ModelForm`.
  prefs: []
  type: TYPE_NORMAL
- en: The type of form we want depends on where the form will be placed and how it
    will be used. In our case, we want a form we can place on the `MovieDetail` page
    and just let it give the user the following two radio buttons:![](img/05b14743-dedd-4122-97df-cc15869422be.png) and ![](img/73102249-cbaf-442e-a8f8-7ba208bb4348.png).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the simplest `VoteForm` possible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Django will generate a form from the `Vote` model using the `value`, `user`,
    and `movie` fields. `user` and `movie` will be `ModelChoiceField`s that use a
    `<select>` dropdown to pick the correct value, and `value` is a `ChoiceField`
    that also uses a `<select>` drop-down widget, not quite what we wanted by default.
  prefs: []
  type: TYPE_NORMAL
- en: '`VoteForm` will require `user` and `movie`. Since we''ll use `VoteForm` to
    save new votes, we can''t eliminate those fields. However, letting users vote
    on behalf of other users will create a vulnerability. Let''s customize our form
    to prevent that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding form, we've customized the fields.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a closer look at the `user` field:'
  prefs: []
  type: TYPE_NORMAL
- en: '`user = forms.ModelChoiceField(`: A `ModelChoiceField` accepts another model
    as the value for this field. The choice of model is validated by providing a `QuerySet` instance
    of valid options.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`queryset=get_user_model().objects.all(),`: A `QuerySet` that defines the valid
    choices for this field. In our case, any user can vote.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`widget=forms.HiddenInput,`: The `HiddenInput` widget renders as a `<input
    type=''hidden''>` HTML element, meaning that the user won’t be distracted by any
    UI.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`disabled=True,`: The `disabled` parameter tells the form to ignore any provided
    data for this field and only use values initially provided in the code. This prevents
    users from voting on behalf of other users.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `movie` field is much the same as `user`, but with the  `queryset` attribute
    queries for `Movie` model instances.
  prefs: []
  type: TYPE_NORMAL
- en: 'The value field is customized in a different way:'
  prefs: []
  type: TYPE_NORMAL
- en: '`value = forms.ChoiceField(`: A `ChoiceField` is used to represent a field
    that can have a single value from a limited set. By default, it''s represented
    by a drop-down list widget.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`label=''Vote'',`: The `label` attribute lets us customize the label used for
    this field. While `value` makes sense in our code, we want users to think that
    their ![](img/05b14743-dedd-4122-97df-cc15869422be.png)/![](img/73102249-cbaf-442e-a8f8-7ba208bb4348.png) is
    the vote.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`widget=forms.RadioSelect,`: A dropdown hides the options until a user clicks
    on the dropdown. But our values are effective calls to action that we want to
    be always visible. Using the `RadioSelect` widget, Django will render each choice
    as an `<input type=''radio''>` tag with the appropriate `<label>` tag and `name` value
    to make voting easier.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`choices=Vote.VALUE_CHOICES,`: A `ChoiceField` must be told the valid choices;
    conveniently, it uses the same format as a model field’s `choices` parameter,
    so we can reuse the `Vote.VALUE_CHOICES` tuple we used in the model.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our newly customized form will appear with the label `vote` and two radio buttons.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our form, let's add voting to the `MovieDetail` view and create
    views that know how to process votes.
  prefs: []
  type: TYPE_NORMAL
- en: Creating voting views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will update the `MovieDetail` view to let users cast their
    votes and views that log the votes in the database. To process the users casting
    votes, we will create the following two views:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CreateVote`, which will be a `CreateView` to be used if a user hasn''t voted
    for a movie yet'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UpdateVote`, which will be an `UpdateView` to be used if a user has already
    voted but is changing their vote'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start by updating `MovieDetail` to provide a UI for voting on a movie.
  prefs: []
  type: TYPE_NORMAL
- en: Adding VoteForm to MovieDetail
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our `MovieDetail.get_context_data` method will be a bit more complex now. It
    will have to get the user's vote for the movie, instantiate the form, and know
    which URL to submit the vote to (`create_vote` or `update_vote`).
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we will need is a way to check whether a user model has a related
    `Vote` model instance for a given `Movie` model instance. To do this, we will
    create a `VoteManager` class with a custom method. Our method will have a special
    behavior—if there is no matching `Vote` model instance, it will return an *unsaved*
    blank `Vote` object. This will make it easier to instantiate our `VoteForm` with
    the proper `movie` and `user` values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s our new `VoteManager`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '`VoteManager` is much like our previous `Manager`s.'
  prefs: []
  type: TYPE_NORMAL
- en: One thing we haven't encountered before is instantiating a model using its constructor
    (for example, `Vote(movie=movie, user=user)`) as opposed to its manager's `create()`
    method. Using the constructor creates a new model in memory but *not* in the database.
    An unsaved model is fully functional in itself (all the methods and manager methods
    are generally available), with the exception of anything that relies on relationships.
    An unsaved model has no `id` thus cannot be looked up using a `RelatedManager`
    or `QuerySet` until it is saved by calling its `save()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have everything that `MovieDetail` needs, let''s update it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We've introduced two new elements in the preceding code, `self.request` and
    instantiating forms with instances.
  prefs: []
  type: TYPE_NORMAL
- en: Views have access to the request that they're processing through their `request`
    attribute. Also, `Request`s have a `user` property that gives us access to the
    user who made the request. We use this to check whether the user is authenticated
    or not, since only authenticated users can vote.
  prefs: []
  type: TYPE_NORMAL
- en: '`ModelForms` can be instantiated with an instance of the model they represent.
    When we instantiate a `ModelForm` with an instance and render it, the fields will
    have the values of the instance. A nice shortcut for a common task is to display
    this model’s values in this form.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will also reference two `path`s that we haven''t created yet; we''ll do
    that in a moment. First, let''s finish off our `MovieDetail` update by updating
    the `movie_detail.html` template sidebar block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In designing this, we again follow the principle that templates should have
    the least amount of logic possible.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's add our `CreateVote` view.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the CreateVote view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `CreateVote` view will be responsible for validating vote data using `VoteForm`
    and then creating the correct `Vote` model instance. However, we will not create
    a template for voting. If there's a problem, we'll just redirect the user to the
    `MovieDetail` view.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the `CreateVote` view we should have in our `django/core/views.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve introduced four new concepts in the preceding code that are different
    than in the `RegisterView` class—`get_initial()`, `render_to_response()`, `redirect()`,
    and `LoginRequiredMixin`. They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`get_initial()` is used to pre-populate a form with `initial` values before
    the form gets `data` values from the request. This is important for `VoteForm`
    because we''ve disabled `movie` and `user`. `Form` disregards `data` assigned
    to disabled fields. Even if a user sends in a different `movie` value or `user`
    value in the form, it will be disregarded by the disabled fields, and our `initial`
    values will be used instead.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`render_to_response()` is called by `CreateView` to return a response with
    the render template to the client. In our case, we will not return a response
    with a template, but an HTTP redirect to `MovieDetail`. There is a serious downside
    to this approach—we lose any errors associated with the form. However, since our
    user has only two choices for input, there aren''t many error messages we could
    provide anyway.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`redirect()` is from Django''s `django.shortcuts` package. It provides shortcuts
    for common operations, including creating an HTTP redirect response to a given
    URL.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LoginRequiredMixin` is a mixin that can be added to any `View` and will check
    whether the request is being made by an authenticated user. If the user is not
    logged in, they will be redirected to the login page.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Django''s default setting for a login page is `/accounts/profile/`, so let''s
    change this by editing our `settings.py` file and adding a new setting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We now have a view that will create a `Vote` model instance and redirect the
    user back to the related `MovieDetail` view on success or failure.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's add a view to let users update their `Vote` model instances.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the UpdateVote view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `UpdateVote` view is much simpler because `UpdateView` (like `DetailView`)
    takes care of the job of looking up the vote though we still have to be concerned
    about `Vote` tampering.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s update our `django/core/views.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Our `UpdateVote` view checks whether the `Vote` retrieved is the logged in user's
    vote in the `get_object()` method. We've added this check to prevent vote tampering.
    Our user interface doesn't let users do this by mistake. If the `Vote` wasn't
    cast by the logged in user then `UpdateVote` throws a `PermissionDenied` exception
    that Django will process and return into a `403 Forbidden` response.
  prefs: []
  type: TYPE_NORMAL
- en: The final step will be to register our new views with the `core` URLConf.
  prefs: []
  type: TYPE_NORMAL
- en: Adding views to core/urls.py
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve now created two new views, but, as always, they''re not accessible to
    users until they’re listed in a URLConf. Let''s edit `core/urls.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: A quick review of the section
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we saw examples of how to build basic and highly customized
    forms for accepting and validating user input. We also discussed some of the built-in
    views that simplify the common tasks of processing forms.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we'll show how to start using our users, votes to rank each movie and
    provide a top-10 list.
  prefs: []
  type: TYPE_NORMAL
- en: Calculating Movie score
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll use Django's aggregate query API to calculate the score
    for each movie. Django makes writing database agnostic aggregate queries easy
    by building the functionality into its `QuerySet` objects.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by adding a method to calculate a score to `MovieManager`.
  prefs: []
  type: TYPE_NORMAL
- en: Using MovieManager to calculate Movie score
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our `MovieManager` class is responsible for building `QuerySet` objects associated
    with `Movie`. We now need a new method that retrieves movies (ideally still with
    the related persons) and marking each movie's score based on the sum of the votes
    it received (we can just sum all the `1` and `-1`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at how we can do this using Django''s `QuerySet.annotate()`
    API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In `all_with_related_persons_and_score`, we call `all_with_related_persons`
    and get a `QuerySet` that we can modify further with our `annotate()` call.
  prefs: []
  type: TYPE_NORMAL
- en: '`annotate` turns our regular SQL query into an aggregate query, adding the
    supplied aggregate operation''s result to a new attribute called `score`. Django
    abstracts most common SQL aggregate functions into class representations, including
    `Sum`, `Count`, and `Average` (and many more).'
  prefs: []
  type: TYPE_NORMAL
- en: The new `score` attribute is available on any instance we `get()` out of the
    `QuerySet` as well as in any methods we want to call on our new `QuerySet` (for
    example, `qs.filter(score__gt=5)` would return a `QuerySet` that has movies with
    a `score` attribute greater than 5).
  prefs: []
  type: TYPE_NORMAL
- en: Our new method still returns a `QuerySet` that is lazy, which means that our
    next step is to update `MovieDetail` and its template.
  prefs: []
  type: TYPE_NORMAL
- en: Updating MovieDetail and template
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we can query movies with their scores, let''s change the `QuerySet`
    `MovieDetail` uses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when `MovieDetail` uses `get()` on its query set, the `Movie` will have
    a score attribute. Let''s use it in our `movie_detail.html` template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We can reference the `score` property safely because of `QuerySet` of `MovieDetail`.
    However, we don't have a guarantee that the score will not be `None` (for example,
    if the `Movie` has no votes). To guard against a blank score, we use the `default_if_none`
    filter to provide a value to print out.
  prefs: []
  type: TYPE_NORMAL
- en: We now have a `MovieManager` method that can calculate the score for all movies,
    but when you use it in `MovieDetail`, it means that it will only do so for the
    `Movie` being displayed.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we added users to our system, letting them register, log in
    (and out), and vote on our movies. We learned how to use aggregate queries to
    efficiently calculate the results of these votes in the database.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will let users upload pictures associated with our `Movie` and `People`
    models and discuss security considerations.
  prefs: []
  type: TYPE_NORMAL
