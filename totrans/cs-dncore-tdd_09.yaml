- en: Testing and Packaging the Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 8](a63afc21-65f0-4d5d-9329-e4e69da1ed64.xhtml), *Creating Continuous
    Integration Build Processes*, we walked through the installation and setup of
    the Cake automation building tool. Also, we extensively demonstrated the process
    of writing build scripts using Cake with its rich, C# domain-specific languages.
    We also covered installing Cake Extension for Visual Studio and running Cake scripts
    using the *Task Explorer* window.
  prefs: []
  type: TYPE_NORMAL
- en: The benefits of CI process brings to software development cannot be overemphasized;
    it facilitates the easy fixing of bugs in project's code base through early and
    quick detection. Using CI, running and reporting test coverage of unit tests projects
    can be automated alongside the project build and deployment.
  prefs: []
  type: TYPE_NORMAL
- en: In order to utilize the features of the CI process effectively, the unit test
    projects in a code base should run and test coverage reports that should be generated
    by the CI tool. In this chapter, we will modify the Cake build script to run our
    suite of xUnit.net tests.
  prefs: []
  type: TYPE_NORMAL
- en: Later in this chapter, we will explore .NET Core versioning and how it can affect
    application development. We will finish up the chapter by packaging the `LoanApplication`
    project for distribution on the various platforms .NET Core supports. Later, we
    will explore how to package the .NET Core application for sharing on NuGet.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Executing xUnit.net tests with Cake
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: .NET Core versioning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: .NET Core packages and metapackages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Packaging for NuGet distribution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Executing xUnit.net tests with Cake
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 8](a63afc21-65f0-4d5d-9329-e4e69da1ed64.xhtml), *Creating Continuous
    Integration Build Processes*, in the *LoanApplication build script* section, we
    walked through the process of creating and running build steps using the Cake
    automation build script. Running unit tests and getting the test results and coverage
    from Visual Studio IDE, Visual Studio Code, or any other suitable IDE for building
    .NET and .NET Core applications is easier with the assistance of the xUnit console
    runner and xUnit adapter. However, for the CI process and the build process to
    be complete and effective, unit test projects should be compiled and executed
    as part of the build steps.
  prefs: []
  type: TYPE_NORMAL
- en: Executing xUnit.net tests in .NET projects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cake has a rich support for running xUnit.net tests. Cake has two aliases for
    running the different versions of xUnit.net tests—xUnit for running earlier versions
    of xUnit.net and xUnit2 for Version 2 of xUnit.net. To use commands for the alias,
    the **ToolPath** to xUnit.net must be specified within the `XUnit2Settings` class
    or include the tool directive in the `build.cake` file, to instruct Cake to get
    the binaries required to run xUnit.net tests from NuGet.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the syntax for including the tool directive for xUnit.net:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Cake''s `XUnit2Alias` is overloaded with different forms for running the xUnit.net
    version tests in the specified assemblies. The alias resides in Cake''s `Cake.Common.Tools.XUnit`
    namespace. The first form is `XUnit2(ICakeContext, IEnumerable<FilePath>)`, which
    is used to run all xUnit.net tests in the specified assemblies in the `IEnumerable`
    parameter. The following script shows how to get the test assemblies to be executed
    into the `IEnumerable` object using the `GetFiles` method and passing it to the
    `XUnit2` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `XUnit2(ICakeContext, IEnumerable<FilePath>, XUnit2Settings)` alias is
    similar to the first form, with the addition of the `XUnit2Settings` class for
    specifying options of how Cake should execute the xUnit.net tests. The following
    snippet describes the usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, the `XUnit2` alias allows the passing of the `IEnumerable` of
    string, which is expected to contain the paths to the assemblies of the xUnit.net
    Version 2 test projects to be executed. The form is `XUnit2(ICakeContext, IEnumerable<string>)`
    and the following snippet describes the usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Executing xUnit.net tests in .NET Core projects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to complete a build process successfully, it is important to run test
    projects in a solution to verify that the code works correctly. Running xUnit.net
    tests in a .NET Core project is relatively easy, by using the dotnet test command
    through the `DotNetCoreTest` alias. To have access to some other features of the
    **dotnet-xunit** tool, it is preferred to run the test using `DotNetCoreTool`.
  prefs: []
  type: TYPE_NORMAL
- en: Unit tests in .NET Core projects are executed by running the `dotnet test` command.
    This command supports all the major unit test frameworks available for writing
    .NET Core tests, provided that the framework has a test adapter that the `dotnet
    test` command can integrate to expose available unit test features.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the dotnet-xunit framework tool to run .NET Core tests provides access
    to features and settings in xUnit.net and is the preferred way of executing .NET
    Core tests. To get started, the dotnet-xunit tool should be installed into a .NET
    Core test project by editing the `.csproj` file and including the `DotNetCliToolReference`
    entry in the `ItemGroup` section. The `xunit.runner.visualstudio` and `Microsoft.NET.Test.Sdk`
    packages should be added so as to be able to execute the tests using the `dotnet
    test` or `dotnet xunit` commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Additionally, there are other arguments which can be used to customize the behavior
    of xUnit.net framework during .NET Core unit tests execution when the `dotnet
    xunit` command is used. These  arguments and their usages can be displayed by
    running `dotnet xunit --help` command on the terminal.
  prefs: []
  type: TYPE_NORMAL
- en: Cake has aliases that can be used to invoke the dotnet SDK commands to execute
    xUnit.net tests. The `DotNetCoreRestore` alias restores NuGet packages used in
    a solution using the `dotnet restore` command. Also, `DotNetCoreBuild` alias is
    responsible for building a .NET Core solution by using the `dotnet build` command.
    Unit tests in test project are executed using the `DotNetCoreTest` alias which
    uses the `dotnet test` command. See the following Cake snippet for the usage of
    the aliases.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, the `DotNetCoreTool` alias can be used to execute xUnit.net
    tests for .NET Core projects. `DotNetCoreTool` is a general purpose alias in Cake
    that can be used to execute any dotnet tool. This is done by supplying the tool
    name and the required arguments, if any. `DotNetCoreTool` exposes the additional
    features available in the `dotnet xunit` command, which gives the flexibility
    of effectively tweaking the way the unit tests are executed. When the `DotNetCoreTool`
    alias is used, command-line arguments are to be passed manually into the alias.
    See the usage of the alias in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: .NET Core versioning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Versioning the .NET Core SDK and runtime makes the platform easy to understand
    and allows better agility. The .NET Core platform essentially is distributed as
    a unit that consists of the different distributions of the frameworks, tools,
    installer, and NuGet packages. Also, versioning the .NET Core platform gives great
    flexibility as regards side-by-side application development on different platforms
    of .NET Core.
  prefs: []
  type: TYPE_NORMAL
- en: Beginning from .NET Core 2.0, a top-level version number that is easy to comprehend
    was used to version .NET Core. Some components of .NET Core version together while
    some do not. However, starting from Version 2.0, there is a consistent versioning
    strategy adopted for .NET Core distributions and components, these include the
    web pages, installers, and NuGet packages.
  prefs: []
  type: TYPE_NORMAL
- en: The versioning model used in .NET Core is based on the framework's runtime component
    `[major].[minor]` version numbers. Similar to the runtime versioning, the SDK
    version uses `[major].[minor]` version numbers with an additional independent
    `[patch]` that combines features and patch semantics for the SDK.
  prefs: []
  type: TYPE_NORMAL
- en: Versioning principle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As of Version 2.0 of .NET Core, the following principles were adopted:'
  prefs: []
  type: TYPE_NORMAL
- en: Version all .NET Core distributions as *x.0.0*, for example 2.0.0 for the first
    release and then move forward together
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: File and package names should clearly represent the component or collection
    and its version, leaving version divergence reconciliation to minor and major
    version boundaries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clear communication should exist between the high-order versions and installers
    that chain multiple components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also, beginning from .NET Core 2.0, the version numbers were unified for the
    shared framework and associated runtime, the .NET Core SDK and the associated
    .NET Core CLI and `Microsoft.NETCore.App` metapackage. Using single version numbers
    makes it easier to identify the version of the SDK to install on the development
    machine and what version the shared framework should be when moving application
    production environments.
  prefs: []
  type: TYPE_NORMAL
- en: Installer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Downloads for the daily builds and releases conforms to the new naming scheme.
    The installer UI available in the downloads was also modified to display both
    the names and versions of the components being installed as from .NET Core 2.0\.
    The naming scheme format is here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, the format shows in detail what is being downloaded, the version it is,
    on what OS it can be used, and whether it is readable. See the examples of the
    format as shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Descriptions of the website and UI strings contained in the installers are maintained
    and kept simple, accurate, and consistent. Sometimes an SDK release can contain
    more than one version of the runtime. In that case, the installer UX shows only
    the SDK version and installed runtime on the summary page when the installation
    process completes. This is applicable to the installers for both Windows and macOS.
  prefs: []
  type: TYPE_NORMAL
- en: Also, .NET Core Tools might be required to be updated, without  necessarily
    updating the runtime. In which case, the SDK version is incremented, for example,
    to 2.1.2\. The Runtime version will be incremented when next there is an update,
    while for example, both the Runtime and SDK, when updated the next time, will
    be shipped as 2.1.3.
  prefs: []
  type: TYPE_NORMAL
- en: Package manager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The flexibility of the .NET Core platform allows the distribution not to be
    done solely by Microsoft; the platform can be distributed by other entities. The
    platform's flexibility makes it easy to distribute installers and packages for
    Linux distribution owners. As well making it seamless for package maintainers
    to add .NET Core packages to their package managers.
  prefs: []
  type: TYPE_NORMAL
- en: The minimum package set details include `dotnet-runtime-[major].[minor]` which
    is the .NET runtime with the specific major+minor version combination indicated
    and available in the package manager for this package. The `dotnet-sdk` includes
    forward major, minor, patch versions as well as update rolls. Also included in
    the package set is the `dotnet-sdk-[major].[minor]` which is the SDK with the
    highest specified version of the shared frameworks and the latest host which is `dotnet-host`.
  prefs: []
  type: TYPE_NORMAL
- en: Docker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Similar to the installer and package manager, the docker tag takes the naming
    convention in which the version number is placed before the component name. The
    available docker tags include the runtime versions listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`1.0.8-runtime`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`1.0.8-sdk`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`2.0.4-runtime`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`2.0.4-sdk`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`2.1.1-runtime`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`2.1.1-sdk`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The SDK version is increased when the .NET Core CLI tools that are included
    in the SDK are fixed and reshipped with an existing Runtime, for example, when
    the version is increased from Version 2.1.1 to version 2.1.2\. Also, it is important
    to note that the SDK tags are updated to represent the SDK version and not the
    Runtime. Based on this, the Runtime will catch up with the SDK version numbering
    the next time it ships, for example, both the SDK and Runtime will take Version
    number 2.1.3 in the next release.
  prefs: []
  type: TYPE_NORMAL
- en: Semantic Versioning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Semantic Versioning is used in .NET Core to provide descriptions of the type
    and and degree of change that occur in a version of .NET Core. **Semantic Versioning**
    (**SemVer**) uses the `MAJOR.MINOR.PATCH` versioning pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `PRERELEASE` and `BUILDNUMBER` parts of SemVer are optional and not part
    of supported releases. They are used specifically for nightly builds, local builds
    from source targets, and unsupported preview releases.
  prefs: []
  type: TYPE_NORMAL
- en: The `MAJOR` part of the versioning is incremented when an old version is not
    being supported anymore, there is an adoption of a newer `MAJOR` version of an
    existing dependency, or the setting of a compatibility quirk is toggled off. `MINOR`
    is incremented whenever there is a newer `MINOR` version of an existing dependency
    or there is a new dependency, a Public API surface area, or a new behavior is
    added. `PATCH` is incremented whenever there is a newer `PATCH` version of an
    existing dependency, support for a newer platform, or there are bug fixes.
  prefs: []
  type: TYPE_NORMAL
- en: When `MAJOR` is incremented, `MINOR` and `PATCH` are reset to zero. Similarly,
    when `MINOR` is incremented, `PATCH` is reset to zero while `MAJOR` is not affected.
    This implies that whenever there are multiple changes, the highest element affected
    by the resulting changes is incremented while the other parts are reset to zero.
  prefs: []
  type: TYPE_NORMAL
- en: Usually, preview versions have `-preview[number]-([build]|"final")` appended
    to the version, for example, 2.1.1-preview1-final. Developers can select the desired
    features and level of stability based on the two types of releases of .NET Core
    available, which are **Long-Term Support** (**LTS**) and **Current**.
  prefs: []
  type: TYPE_NORMAL
- en: The LTS version is a relatively more stable platform, supported for a longer
    period while new features are added less frequently. The Current version adds
    new features and APIs more frequently, but there is a shorter allowed duration
    to install updates with more frequent updates being made available and a shorter
    support period than for LTS.
  prefs: []
  type: TYPE_NORMAL
- en: .NET Core packages and metapackages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The .NET Core platform is shipped as a set of packages that are typically called
    metapackages. The platform is essentially made of NuGet packages, this contributes
    to it being lightweight and easily distributable. The packages in .NET Core provide
    both primitives and higher level data types and common utilities available in
    the platform. Also, each package directly maps to an assembly both with the same
    name; `System.IO.FileSystem.dll` assembly is the package for `System.IO.FileSystem`.
  prefs: []
  type: TYPE_NORMAL
- en: Packages in .NET Core are defined as fine-grained. This comes with great benefits
    as the resulting application developed on the platform has small print and only
    contains packages that are referenced and used in the project. Unreferenced packages
    are not shipped as part of the application distribution. Additionally, fine-grained
    packages can provide differing OS and CPU support as well as dependencies peculiar
    to only one library. .NET Core packages usually ship using the same schedule as
    the platform support. This allows fixes to be distributed and installed as lightweight
    package updates.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the NuGet packages available for .NET Core are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`System.Runtime`: This is the .NET Core package, which includes `Object`, `String`,
    `Array`, `Action`, and `IList<T>`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`System.Reflection`: This package contains the types for loading, inspecting,
    and activating types, including `Assembly`, `TypeInfo`, and `MethodInfo`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`System.Linq`: A set of types for querying objects, including `Enumerable`
    and `ILookup<TKey,TElement>`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`System.Collections`: Types for generic collections, including `List<T>` and
    `Dictionary<TKey,TValue>`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`System.Net.Http`: Types for HTTP network communication, including `HttpClient`
    and `HttpResponseMessage`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`System.IO.FileSystem`: Types for reading and writing to local or networked,
    disk-based storage, including **file** and **directory**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Referencing a package in your .Net Core project is relatively easy. For example,
    if you include `System.Reflection` in your project, you can reference it in the
    project, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Metapackage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Metapackage** is a reference or dependency that is added to a .NET Core project
    in addition to the already referenced target framework in the project. For example,
    you can add `Microsoft.NETCore.App` or `NetStandard.Library` to a .NET Core project.'
  prefs: []
  type: TYPE_NORMAL
- en: At times, it is required to use a set of packages in a project. This is done
    through the use of metapackages. Metapackages are groups of packages that are
    often used together. Also, metapackages are NuGet packages that describe a group
    or set of packages. Metapackages can create a framework for the packages when
    the framework is specified.
  prefs: []
  type: TYPE_NORMAL
- en: When you reference a metapackage, essentially a reference is made to all the
    packages contained in the metapackage. In essence, this makes the libraries in
    the packages available for IntelliSense during project development with Visual
    Studio. Also, the libraries will be available when the project is being published.
  prefs: []
  type: TYPE_NORMAL
- en: In a .NET Core project, a metapackage is referenced by the framework targeted
    in the project, which implies that a metapackage is strongly associated or tied
    to a specific framework. Metapackages give access to groups of packages that have
    already been confirmed and tested to work together.
  prefs: []
  type: TYPE_NORMAL
- en: 'The .NET Standard metapackage is the `NETStandard.Library`, which constitutes
    a set of libaries in the .NET Standard. This is applicable to the different variants
    of the .NET platforms: .NET Core, .NET Framework and Mono framework.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Microsoft.NETCore.App` and `Microsoft.NETCore.Portable.Compatibility` are
    the main .NET Core metapackages. `Microsoft.NETCore.App` describes the set of
    libraries that constitute the .NET Core distribution and depends on `NETStandard.Library`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Microsoft.NETCore.Portable.Compatibility` describes the set of facades that
    enable the mscorlib-based **Portable Class Libraries** (**PCLs**) to work on .NET
    Core.'
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft.AspNetCore.All metapackage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Microsoft.AspNetCore.All` is the metapackage for ASP.NET Core. The metapackage
    comprises packages supported and maintained by the ASP.NET Core team, supported
    packages by Entity Framework Core, as well as the internal and third-party dependencies
    used by both ASP.NET Core and Entity Framework Core.'
  prefs: []
  type: TYPE_NORMAL
- en: The available default project templates that target ASP.NET Core 2.0 use the
    `Microsoft.AspNetCore.All` package. The version numbers of ASP.NET Core version
    and Entity Framework Core are similar to that of the `Microsoft.AspNetCore.All`
    metapackage. All available features in ASP.NET Core 2.x and Entity Framework Core
    2.x are included in the `Microsoft.AspNetCore.All` package.
  prefs: []
  type: TYPE_NORMAL
- en: When you create an ASP.NET Core application that references the `Microsoft.AspNetCore.All`
    metapackage, .NET Core Runtime Store is made available for your usage. .NET Core
    Runtime Store exposes the required runtime assets to run ASP.NET Core 2.x applications.
  prefs: []
  type: TYPE_NORMAL
- en: During deployment, assets from the referenced ASP.NET Core NuGet packages are
    not deployed together with the application, the assets are in the .NET Core Runtime
    Store. These assets are precompiled for performance gain, to speed up application
    startup time. Also, it is desirable to exclude packages that are not used. This
    is done  by using the package-trimming process.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use `Microsoft.AspNetCore.All` packages, it should be added as a reference
    to the .NET Core `.csproj` project file, like in the following XML config:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Packaging for NuGet distribution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: .NET Core's flexibility is not only limited to the application's development,
    it extends to the deployment process. Deploying .NET Core applications can take
    two forms—**framework-dependent deployment** (**FDD**) and **self-contained deployment**
    (**SCD**).
  prefs: []
  type: TYPE_NORMAL
- en: Using the FDD approach requires that there is a system-wide .NET Core installed
    on the machine where the application will be developed. The installed .NET Core
    runtime will be shared by your application and other applications deployed on
    the machine.
  prefs: []
  type: TYPE_NORMAL
- en: This allows your application to be portable between the versions or installations
    of the .NET Core framework. Also, with this approach, your deployment will be
    lightweight and only contain your application's code and the third-party libraries
    used. When using this approach, `.dll` files are created for your application,
    which allows it to be launched from the command line.
  prefs: []
  type: TYPE_NORMAL
- en: SCD allows you to package your application together with the .NET Core libraries
    and .NET Core runtime that are required to make it run. Essentially, your application
    does not rely on the presence of installed .NET Core on the deployment machine.
  prefs: []
  type: TYPE_NORMAL
- en: When using this approach, an executable file, which essentially is a renamed
    version of the platform-specific .NET Core host will be packaged as part of the
    application. This executable file is `app.exe` on Windows or `app` on Linux and
    macOS. Similar to when the application is deployed using the *framework-dependent
    approach*, `.dll` files are created for your application that allows it to be
    launched.
  prefs: []
  type: TYPE_NORMAL
- en: dotnet publish command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `dotnet publish` command is used to compile the application, and to check
    the application''s dependencies before copying the application and the dependencies
    into a folder in preparation for deployment. The execution of the command is the
    only officially supported way of preparing the .NET Core application for deployment.
    The synopsis is here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: When the command is run, the output will contain the **Intermediate Language**
    (**IL**) code contained in a `.dll` assembly, a `.deps.json` file that contains
    the project's dependencies, a `.runtime.config.json` file that specifies the expected
    shared runtime, and the application's dependencies copied from the NuGet cache
    into the output folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'The command''s argument and options are explained here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`PROJECT`: To specify the project to be compiled and published, it defaults
    to the current folder.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-c|--configuration`: This option is used to specify the build configuration,
    it takes the `Debug` and `Release` values, the default value is `Debug`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-f|--framework <FRAMEWORK>`: The target framework option, when specified with
    the command, will publish the application for the target framework.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--force`: Used to force dependencies to be resolved, similar to deleting the
    `project.assets.json` file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-h|--help`: Displays the help for the command.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--manifest <PATH_TO_MANIFEST_FILE>`: For specifying one or more target manifests
    to be used in trimming the packages published with the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--no-dependencies`: This option is used to ignore project-to-project references
    but restores the root project.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--no-restore`: This is to instruct the command not to perform an implicit
    restore.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-o|--output <OUTPUT_DIRECTORY>`: This is for specifying the path of the output
    directory. If the option is not specified, it defaults to `./bin/[configuration]/[framework]/`
    for an FDD or `./bin/[configuration]/[framework]/[runtime]` for an SCD.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-r|--runtime <RUNTIME_IDENTIFIER>`: The option is for publishing the application
    for a given runtime, used only when creating an SCD.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--self-contained`: Is for specifying an SCD. When a runtime identifier is
    specified, its default value is true.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-v|--verbosity <LEVEL>`: For specifying the verbosity level of the `dotnet
    publish` command. The allowed values are `q[uiet]`, `n[ormal]`, `m[inimal]`, `diag[nostic]`,
    and `d[etailed]`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--version-suffix <VERSION_SUFFIX>`: For specifying the version suffix to be
    used when replacing the asterisk (`*`) in the version field of the project file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An example of the command usage is running `dotnet publish` on the command
    line. This publishes the project in the current folder. To publish the `LoanApplication`
    project that was used in this book, you can run the `dotnet publish` command.
    This will publish the application using the framework specified in the project.
    The projects in the solution that the ASP.NET Core application depends on will
    be built alongside. See the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6e3b3ee4-f49d-48dd-aefc-4d7c53f9f986.png)'
  prefs: []
  type: TYPE_IMG
- en: 'A `publish` folder is created in the `netcoreapp2.0` folder where all the compiled
    files and the dependencies will be copied to:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/71dacc7f-c199-41f2-a5bb-a3985c070d53.png)'
  prefs: []
  type: TYPE_IMG
- en: Creating a NuGet package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**NuGet** is the package manager for .NET, it is an open source package manager
    that provides an easier way of versioning and distributing libraries for applications
    built on both .NET Framework and the .NET Core platform. The NuGet gallery is
    the .NET central package repository for hosting all packages used by both package
    authors and consumers.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the .NET Core''s `dotnet pack` command makes it easy to create NuGet
    packages. When this command is run, it builds a .NET Core project and creates
    a NuGet package from it. NuGet dependencies of a packed .NET Core project will
    be added to the `.nuspec` file, to ensure they''re resolved when the package is
    installed. The following command synopsis is shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The command''s argument and options are explained here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`PROJECT` is to specify the project to pack, which can be a path to a directory
    or a `.csproj` file. It defaults to the current folder.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`c|--configuration`: This option is used to define the build configuration.
    It takes the `Debug` and `Release` values. The default value is `Debug`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--force`: Used to force dependencies to be resolved similar to deleting the
    `project.assets.json` file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-h|--help`: Displays the help for the command.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-include-source`: It''s to specify that the source files be included in the
    `src` folder in the NuGet package.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--include-symbols`: To generate the `nupkg` symbols.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--no-build`: This is to instruct the command to not build the project before
    packing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--no-dependencies`: This option is used to ignore project-to-project references
    but restores the root project.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--no-restore`: This is to instruct the command not to perform an implicit
    restore.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-o|--output <OUTPUT_DIRECTORY>`: This is for specifying the path of the output
    directory to place the built packages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-r|--runtime <RUNTIME_IDENTIFIER>`: This option is to specify the target runtime
    to restore the packages for.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-s|--serviceable`: Is for setting the serviceable flag in the package.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-v|--verbosity <LEVEL>`: For specifying the verbosity level of the command.
    The allowed values are `q[uiet]`, `m[inimal]`, `n[ormal]`, `d[etailed]`, and `diag[nostic]`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--version-suffix <VERSION_SUFFIX>`: For specifying the version suffix to be
    used when replacing the asterisk (`*`) in the version field of the project file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Running the `dotnet pack` command will pack the project in the current directory.
    To pack the `LoanApplication.Core` project, we can run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'When the command is run, the `LoanApplication.Core` project will be built and
    packed into the `nupkgs` file in the project folder. The `LoanApplication.Core.1.0.0.nupkg`
    file will be created, which is an archive file containing the packed project''s
    libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/15b74cee-dd94-4076-b5dc-faa7f6040573.png)'
  prefs: []
  type: TYPE_IMG
- en: After the application has been packed, it can be published to the NuGet gallery
    by using the `dotnet nuget push` command. In order to be able to push packages
    to NuGet, you need to register for NuGet API keys. These keys are to be specified
    as options with the `dotnet nuget push` command when uploading packages to NuGet.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the `dotnet nuget push LoanApplication.Core.1.0.0.nupkg -k <api-key> -s
    https://www.nuget.org/` command to push the created NuGet package to the gallery,
    which will make it available for use by other developers. When the command is
    run, a connection will be established to the NuGet server to push the package
    under your account:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/601521bb-89f1-45a2-bf67-f262cb128c78.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After the package has been pushed to NuGet gallery, when you log in to your
    account, you can find the pushed package in the list of published packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/680b6ae6-3f27-4c89-af9b-224ae44623d1.png)'
  prefs: []
  type: TYPE_IMG
- en: When you upload your package to the NuGet gallery, other programmers can search
    for your package directly from Visual Studio by using the NuGet package manager
    and add a reference to the libraries in their projects.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we started by executing the xUnit.net test with Cake. Also,
    we extensively discussed .NET Core versioning, the concepts, and how it affects
    application development on the .NET Core platform. Later, we packaged the `LoanApplication`
    project that was used in this book for NuGet distribution.
  prefs: []
  type: TYPE_NORMAL
- en: You have been taken through an exciting TDD journey in this book. Using the
    xUnit.net unit test framework, the concept of TDD was introduced and discussed
    extensively. Data-driven unit tests were covered, which allow you to test your
    code with data from different data sources.
  prefs: []
  type: TYPE_NORMAL
- en: The Moq framework was used to introduce and explain how to unit test code with
    dependencies. The TeamCity CI server was used to explain the concepts of CI. Cake,
    a cross-platform build system was explored and used to create build steps executed
    in TeamCity. Also, Microsoft VSTS, another CI tool, was used to execute Cake scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, effective use of TDD is greatly rewarding in terms of the quality of
    code and resulting application. With continuous practices, all the concepts explained
    in this book can become part of your day-to-day programming routine.
  prefs: []
  type: TYPE_NORMAL
