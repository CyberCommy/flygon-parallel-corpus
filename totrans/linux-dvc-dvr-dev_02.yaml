- en: Device Driver Basis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A driver is a piece of software whose aim is to control and manage a particular
    hardware device; hence the name device driver. From an operating system point
    of view, it can be either in the kernel space (running in privileged mode) or
    in the user space (with lower privilege). This book only deals with kernel space
    drivers, especially Linux kernel drivers. Our definition is a device driver exposes
    the functionality of the hardware to user programs.
  prefs: []
  type: TYPE_NORMAL
- en: 'This book''s aim is not to teach you how to become a Linux guru—I''m not even
    one at all—but there are some concepts you should understand prior to writing
    a device driver. C programming skills are mandatory; you should be at least familiar
    with pointers. You should also be familiar with some of the manipulating functions.
    Some hardware skills are required too. So this chapter essentially discusses:'
  prefs: []
  type: TYPE_NORMAL
- en: Module building processes, as well as their loading and unloading
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Driver skeletons, and debugging message management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Error handling in the driver
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User space and kernel space
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The concept of kernel space and user space is a bit abstract. It is all about
    memory and access rights. One may consider the kernel to be privileged, whereas
    the user apps are restricted. It is a feature of a modern CPU, allowing it to
    operate either in privileged or unprivileged mode. This concept will be clearer
    to you in [Chapter 11](http://post%2011) , *Kernel Memory Management* .
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: User space and kernel space
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding figure introduces the separation between kernel and user space,
    and highlights the fact that system calls represent the bridge between them (we
    discuss this later in this chapter). One can describe each space as following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Kernel space:** This is a set of addresses where the kernel is hosted and
    where it runs. Kernel memory (or kernel space) is a memory range, owned by the
    kernel, protected by access flags, preventing any user apps from messing with
    the kernel (un)knowingly. On the other hand the kernel can access the whole system
    memory, since it runs with the higher priority on the system. In kernel mode,
    the CPU can access the whole memory (both kernel space and user space).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**User space:** This is a set of addresses (locations) where normal programs
    (such as gedit and so on) are restricted to run. You may consider it as a sand-box
    or a jail, so that a user program can''t mess with memory or any other resource
    owned by another program. In user mode, the CPU can only access memory tagged
    with user-space access rights. The only way for the user app to run into the kernel
    space is through system calls. Some of these are `read` , `write` , `open` , `close`
    , `mmap` , and so on. User-space code runs with lower priority. When a process
    performs a system call, a software interrupt is sent to the kernel, which turns
    on privileged mode so that the process can run in kernel space. When the system
    call returns, the kernel turns off the privileged mode and the process is jailed
    again.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The concept of modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A module is to the Linux kernel what a plugin (add-on) is to user software
    (Firefox is an example). It dynamically extends the kernel functionalities without
    even the need to restart the computer. Most of the time, kernel modules are plug
    and play. Once inserted, they are ready to be used. In order to support modules,
    the kernel must have been built with the following option enabled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Module dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Linux, a module can provide functions or variables, exporting them using
    the `EXPORT_SYMBOL` macro, which makes them available for other modules. These
    are called symbols. A dependency of module B on module A is that module B is using
    one of the symbols exported by module A.
  prefs: []
  type: TYPE_NORMAL
- en: depmod utility
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`depmod` is a tool that you run during the kernel build process to generate
    module dependency files. It does that by reading each module in `/lib/modules/<kernel_release>/`
    to determine what symbols it should export and what symbols it needs. The result
    of that process is written to the file `modules.dep` , and its binary version
    `modules.dep.bin` . It is a kind of module indexing.'
  prefs: []
  type: TYPE_NORMAL
- en: Module loading and unloading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For a module to be operational, one should load it into the kernel, either by
    using `insmod` given the module path as argument, which is the preferred method
    during development, or by using `modprobe` , a clever command but that one prefered
    in production systems.
  prefs: []
  type: TYPE_NORMAL
- en: Manual loading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Manual loading needs the intervention of a user, which should have root access.
    The two classical methods to achieve this are described as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: modprobe and insmod
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'During development, one usually uses `insmod` in order to load a module and
    it should be given the path of the module to load:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'It is low-level form of module loading, which forms the base of other module
    loading methods, and the one we will use in this book. On the other hand, there
    is `modprobe` , mostly used by sysadmin or in a production system. `modprobe`
    is a clever command that parses the file `modules.dep` in order to load dependencies
    first, prior to loading the given module. It automatically handles module dependencies,
    as a package manager does:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Whether one can use `modprobe` or not depends on `depmod` being aware of module
    installation.
  prefs: []
  type: TYPE_NORMAL
- en: /etc/modules-load.d/<filename>.conf
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you want some module to be loaded at boot time, just create the file `/etc/modules-load.d/<filename>.conf`
    , and add the module''s name that should be loaded, one per line. `<filename>`
    should be meaningful to you, and people usually use module: `/etc/modules-load.d/modules.conf`
    . You may create as many `.conf` files as you need:'
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of `/etc/modules-load.d/mymodules.conf` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Auto-loading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `depmod` utility doesn''t only build `modules.dep` and `modules.dep.bin`
    files. It does more than that. When a kernel developer actually writes a driver,
    they know exactly what hardware the driver will support. They are then responsible
    for feeding the driver with the product and vendor IDs of all devices supported
    by the driver. `depmod` also processes module files in order to extract and gather
    that information, and generates a `modules.alias` file, located in `/lib/modules/<kernel_release>/modules.alias`
    , which will map devices to their drivers:'
  prefs: []
  type: TYPE_NORMAL
- en: 'An excerpt of `modules.alias` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: At this step, you'll need a user-space hot-plug agent (or device manager), usually
    `udev` (or `mdev` ), that will register with the kernel in order to get notified
    when a new device appears.
  prefs: []
  type: TYPE_NORMAL
- en: The notification is done by the kernel, sending the device's description (pid,
    vid, class, device class, device subclass, interface, and all other information
    that may identify a device) to the hot-plug daemon, which in turn calls `modprobe`
    with this information. `modprobe` then parses the `modules.alias` file in order
    to match the driver associated with the device. Before loading the module, `modprobe`
    will look for its dependencies in `module.dep` . If it finds any, the dependencies
    will be loaded prior to the associated module loading; otherwise, the module is
    loaded directly.
  prefs: []
  type: TYPE_NORMAL
- en: Module unload
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The usual command to unload a module is `rmmod` . One should prefer using this
    to unload a module loaded with `insmod` command. The command should be given the
    module name to unload as a parameter. Module unloading is a kernel feature that
    one can enable or disable, according to the value of the `CONFIG_MODULE_UNLOAD`
    config option. Without this option, one will not be able to unload any module.
    Let us enable module unloading support:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'At runtime, the kernel will prevent from unloading modules that may break things,
    even if one asks it to do so. This is because the kernel keeps a reference count
    on module usage, so that it knows whether a module is actually in use or not.
    If the kernel believes it is unsafe to remove a module, it will not. Obviously,
    one can change this behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding option should be set in the kernel config in order to force module
    unload:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, a higher level command to unload a module in a smart manner
    is `modeprobe -r` , which automatically unloads unused dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'As you may have guessed, it is a really helpful option for developers. Finally,
    one can check whether a module is loaded or not with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Driver skeletons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s consider the following `helloworld` module. It will be the basis for
    our work during the rest of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: helloworld.c
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Module entry and exit point
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Kernel drivers all have entry and exit points: the former corresponds to the
    function called when the module is loaded (`modprobe` , `insmod` ) and the latter
    is the function executed at module unloading (at `rmmod or modprobe -r` ).'
  prefs: []
  type: TYPE_NORMAL
- en: We all remember the `main()` function, which is the entry point for every user-space
    program written in C/C++ that exits when that same function returns. With kernel
    modules, things are different. The entry point can have any name you want, and
    unlike a user-space program that exits when `main()` returns, the exit point is
    defined in another function. All you need to do is to inform the kernel which
    functions should be executed as an entry or exit point. The actual functions `hellowolrd_init`
    and `hellowolrd_exit` could be given any name. The only thing that is actually
    mandatory is to identify them as the corresponding loading and removing functions,
    giving them as parameters to the `module_init()` and `module_exit()` macros.
  prefs: []
  type: TYPE_NORMAL
- en: To sum up, `module_init()` is used to declare the function that should be called
    when the module is loaded (with `insmod` or `modprobe` ). What is done in the
    initialization function will define the behavior of the module. `module_exit()`
    is used to declare the function that should be called when the module is unloaded
    (with `rmmod` ).
  prefs: []
  type: TYPE_NORMAL
- en: Either the `init` function or the `exit` function is run once, right after the
    module is loaded or unloaded.
  prefs: []
  type: TYPE_NORMAL
- en: __init and __exit attributes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`__init` and `__exit` are actually kernel macros, defined in `include/linux/init.h`
    , shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `__init` keyword tells the linker to place the code in a dedicated section
    into the kernel object file. This section is known in advance to the kernel, and
    freed when the module is loaded and the `init` function finished. This applies
    only to built-in drivers, not to loadable modules. The kernel will run the init
    function of the driver for the first time during its boot sequence.
  prefs: []
  type: TYPE_NORMAL
- en: Since the driver cannot be unloaded, its init function will not be called again
    until the next reboot. There is no need to keep references on its init function
    anymore. The same for the `__exit` keyword, whose corresponding code is omitted
    when the module is compiled statically into the kernel, or when module unloading
    support is not enabled, because in both cases, the `exit` function is never called.
    `__exit` has no effect on loadable modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s spend more time understanding how such attributes work. It is all about
    object files called **Executable and Linkable Format** (**ELF** ). An ELF object
    file is made of various named sections. Some of these are mandatory and form the
    basis of the ELF standard, but one can make up any section one wants and have
    it used by special programs. This is what the kernel does. One can run `objdump
    -h module.ko` in order to print out different sections that constitute the given
    `module.ko` kernel module:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: List of sections of helloworld-params.ko module
  prefs: []
  type: TYPE_NORMAL
- en: 'Only a few of the sections in the caption are standerd ELF sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '`.text` , also called code, which contains program code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.data` , which contains initialized data, and is also called data segment'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.rodata` , for read-only data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.comment`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uninitialized data segment, also called **block started by symbol** (**bss**
    )
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other sections are added on demand for the kernel purpose.The most important
    for this chapter are **.modeinfo** sections, which store information about the
    modules, and **.init.text** sections, which store code prefixed with the `__init`
    macro.
  prefs: []
  type: TYPE_NORMAL
- en: The linker (`ld` on Linux systems), which is a part of binutils, is responsible
    for the placement of symbols (data, code, and so on) in the appropriate section
    in the generated binary in order to be processed by the loader when the program
    is executed. One may customize these sections, change their default location,
    or even add additional sections by providing a linker script, called a **linker
    definition file** (**LDF** ) or **linker definition script** (**LDS** ). Now all
    you have to do is to inform the linker of the symbol placement through compiler
    directives. The GNU C compiler provides attributes for that purpose. In the case
    of the Linux kernel, there is a custom LDS file provided, located in `arch/<arch>/kernel/vmlinux.lds.S`
    . `__init` and `__exit` are then used to mark symbols to be placed onto dedicated
    sections mapped in kernel's LDS files.
  prefs: []
  type: TYPE_NORMAL
- en: In conclusion, `__init` and `__exit` are Linux directives (actually macros),
    which wrap the C compiler attribute used for symbol placement. They instruct the
    compiler to put the code they prefix respectively in `.init.text` and `.exit.text`
    sections, even though the kernel can access different object sections.
  prefs: []
  type: TYPE_NORMAL
- en: Module information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Even without having to read its code, one should be able to gather some information
    (for example, the author(s), parameter(s) description, the license) about a given
    module. A kernel module uses its `.modinfo` section to store informations about
    the module. Any `MODULE_*` macro will update the content of that section with
    the values passed as parameters. Some of these macros are `MODULE_DESCRIPTION()`
    , `MODULE_AUTHOR()` , and `MODULE_LICENSE()` . The real underlying macro provided
    by the kernel to add an entry in the module info section is `MODULE_INFO(tag,
    info)` , which adds generic info of form tag = info. This means a driver author
    could add any free form info they want, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'One can dump the content of the `.modeinfo` section of a kernel module using
    the `objdump -d -j .modinfo` command on the given module:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Content of .modeinfo section of helloworld-params.ko module
  prefs: []
  type: TYPE_NORMAL
- en: 'The modinfo section can be seen as the data sheet of the module. The user-space
    tool that actually prints information in a stylized manner is `modinfo` :'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: modinfo output
  prefs: []
  type: TYPE_NORMAL
- en: Apart from the custom info one defines, there is standard info one should provide,
    and that the kernel provides macros for; these are license, module author, parameter
    description, module version, and module description.
  prefs: []
  type: TYPE_NORMAL
- en: Licensing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The license is defined in a given module by the `MODULE_LICENSE()` macro:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The license will define how your source code should be shared (or not) with
    other developers. `MODULE_LICENSE()` tells the kernel what license our module
    is under. It has an effect on your module behavior, since a non GPL-compatible
    license will result in your module not being able to see/use services/functions
    exported by the kernel through the `EXPORT_SYMBOL_GPL()` macro, which shows the
    symbols to GPL-compatible modules only, which is the opposite of `EXPORT_SYMBOL()`
    , which exports functions for modules with any license. Loading a non GPL-compatible
    will also result in a tainted kernel; that means a non-open source or untrusted
    code has been loaded, and you will likely have no support from the community.
    Remember that the module without `MODULE_LICENSE()` is not considered open source
    and will taint the kernel too. The following is an excerpt of `include/linux/module.h`
    , describing the license supported by the kernel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: It is mandatory for your module to be at least GPL-compatible in order for you
    to enjoy full kernel services.
  prefs: []
  type: TYPE_NORMAL
- en: Module author(s)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`MODULE_AUTHOR()` declares the module''s author(s):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'It is possible to have more than one author. In this case, each author must
    be declared with `MODULE_AUTHOR()` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Module description
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`MODULE_DESCRIPTION()` briefly describes what the module does:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Errors and message printing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Error codes are interpreted either by the kernel or by the user-space application
    (through the `errno` variable). Error handling is very important in software development,
    more than it is in kernel development. Fortunately, the kernel provides a couple
    of errors that cover almost every error you'll encounter, and sometimes you will
    need to print them out in order to help you debug.
  prefs: []
  type: TYPE_NORMAL
- en: Error handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Return the wrong error code for a given error and it will result in either
    the kernel or user-space app producing unneeded behavior and making a wrong decision.
    To keep things clear, there are predefined errors in the kernel tree that cover
    almost every case you may face. Some of the errors (with their meaning) are defined
    in `include/uapi/asm-generic/errno-base.h` , and the rest of the list can be found
    in `include/uapi/asm-generic/errno.h.` The following is an excerpt of list of
    errors, from `include/uapi/asm-generic/errno-base.h` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Most of time, the classical way to return an error is to do so in the form
    `return -ERROR` , especially when it comes to answering to system calls. For example,
    for an I/O error, the error code is `EIO` and one should `return -EIO` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Errors sometimes cross the kernel space and propagate themselves to the user
    space. If the returned error is an answer to a system call (`open` , `read` ,
    `ioctl` , `mmap` ), the value will be automatically assigned to the user-space
    `errno` global variable, on which one can use `strerror(errno)` to translate the
    error into a readable string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'When you face an error, you must undo everything that has been set until the
    error occurs. The usual way to do this is to use the `goto` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The reason why one uses the `goto` statement is simple. When it comes to handling
    error, let''s say at step 5, one has to clean previous operations (steps 4, 3,
    2, 1). Instead of doing lot of nested checking operation shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This may be confusing, and may lead to indentation issues. One prefers using
    the `goto` in order to have a straight control flow, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This means, one should only use goto to move forward in a function.
  prefs: []
  type: TYPE_NORMAL
- en: Handling null pointer errors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When it comes to returning an error from functions that are supposed to return
    a pointer, functions often return the `NULL` pointer. It is a working but quite
    meaningless approach, since one does not exactly know why this null pointer is
    returned. For that purpose, the kernel provides three functions, `ERR_PTR` , `IS_ERR`
    , and `PTR_ERR` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The first actually returns the error value as a pointer. Given a function that
    is likely to `return -ENOMEM` after a failed memory allocation, we have to do
    something like `return ERR_PTR(-ENOMEM);` . The second is used to check whether
    the returned value is a pointer error or not, `if (IS_ERR(foo))` . The last returns
    the actual error code `return PTR_ERR(foo);` . The following is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'How to use `ERR_PTR` , `IS_ERR` , and `PTR_ERR` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a plus on error handling, which is also an excerpt of the kernel coding
    style that says: If the name of a function is an action or an imperative command,
    the function should return an error-code integer. If the name is a predicate,
    the function should return a `succeeded` Boolean. For example, `add work` is a
    command, and the `add_work()` function returns `0` for success or `-EBUSY` for
    failure. In the same way, `PCI device present` is a predicate, and the `pci_dev_present()`
    function returns `1` if it succeeds in finding a matching device or `0` if it
    doesn''t.'
  prefs: []
  type: TYPE_NORMAL
- en: Message printing – printk()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `printk()` is to the kernel what `printf()` is to the user-space. Lines
    written by `printk()` can be displayed through the `dmesg` command. Depending
    on how important the message you need to print is, you can choose between eight
    log-level messages, defined in `include/linux/kern_levels.h` , along with their
    meaning:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the list of kernel log levels. Each of these levels correspond
    to a number in a string, whose priority is inverted proportional to the value
    of the number. For example, `0` is higher priority:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code shows how one can print a kernel message along with a log
    level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'If you omit the debug level (`printk("This is an error\n")` ), the kernel will
    provide one to the function, depending on the `CONFIG_DEFAULT_MESSAGE_LOGLEVEL`
    config option, which is the default kernel log level. One may actually use one
    of the following, much more meaningful macros, which are wrappers around those
    defined previously: `pr_emerg` , `pr_alert` , `pr_crit` , `pr_err` , `pr_warning`
    , `pr_notice` , `pr_info` , and `pr_debug` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'For new drivers, it is recommended to use these wrappers. The reality of `printk()`
    is that, whenever it is called, the kernel compares the message log level with
    the current console log level; if the former is higher (lower value) than the
    latter, the message will be immediately printed to the console. You can check
    your log level parameters with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In this code, the first value is the current log level (4), and the second is
    the default one, according to the `CONFIG_DEFAULT_MESSAGE_LOGLEVEL` option. Other
    values are not relevant for the purpose of this chapter, so let us ignore these.
  prefs: []
  type: TYPE_NORMAL
- en: 'A list of kernel log levels is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The current log level can be changed with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '`printk()` never blocks and is safe enough to be called even from atomic contexts.
    It tries to lock the console and print the message. If locking fails, the output
    will be written into a buffer and the function will return, never blocking. The
    current console holder will then be notified about new messages and will print
    them before releasing the console.'
  prefs: []
  type: TYPE_NORMAL
- en: The kernel supports other debug methods too, either dynamically or by using
    `#define DEBUG` on top of the file. People interested in such debugging style
    can refer to kernel documentation in *Documentation/dynamic-debug-howto.txt* file.
  prefs: []
  type: TYPE_NORMAL
- en: Module parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As a user program does, a kernel module can accept arguments from the command
    line. This allows dynamically changing the behavior of the module according to
    given parameters, and can help the developer not having to indefinitely change/compile
    the module during a test/debug session. In order to set this up, one should first
    declare the variables that will hold the values of command line arguments, and
    use the `module_param()` macro on each of these. The macro is defined in `include/linux/moduleparam.h`
    (this should be included in the code too: `#include <linux/moduleparam.h>` ) shown
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This macro contains the following elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '`name` : The name of the variable used as the parameter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`type` : The parameter''s type (bool, charp, byte, short, ushort, int, uint,
    long, ulong), where `charp` stands for char pointer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`perm` : This represents the `/sys/module/<module>/parameters/<param>` file
    permissions. Some of them are `S_IWUSR` , `S_IRUSR` , `S_IXUSR` , `S_IRGRP` ,
    `S_WGRP` , and `S_IRUGO` , where:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`S_I` is just a prefix'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`R` : read, `W` : write, `X` : execute'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`USR` : user, `GRP` : group, `UGO` : user, group, others'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One can eventually use a `|` (OR operation) to set multiple permissions. If
    perm is `0` , the file parameter in `sysfs` will not be created. You should use
    only `S_IRUGO` read-only parameters, which I highly recommend; by making a `|`
    (OR) with other properties, you can obtain fine-grained properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'When using module parameters, one should use `MODULE_PARM_DESC` in order to
    describe each of them. This macro will populate the module info section with each
    parameter''s description. The following is a sample, from the `helloworld-params.c`
    source file provided with the code repository of the book:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'To load the module and feed our parameter, we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'One could have used `modinfo` prior to loading the module in order to display
    description of parameters supported by the module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Building your first module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are two places to build a module. It depends on whether you want people
    to enable the module by themselves or not using the kernel config interface.
  prefs: []
  type: TYPE_NORMAL
- en: The module's makefile
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A makefile is a special file used to execute a set of actions, among which the
    most important is the compilation of programs. There is a dedicated tool to parse
    makefiles, called `make` . Prior to jumping to the description of the whole make
    file, let us introduce the `obj-<X>` kbuild variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'In almost every kernel makefile, one will see at least one instance of an `obj<-X>`
    variable. This actually corresponds to the `obj-<X>` pattern, where `<X>` should
    be either `y` , `m` , left blank, or `n` . This is used by the kernel makefile
    from the head of the kernel build system in a general manner. These lines define
    the files to be built, any special compilation options, and any subdirectories
    to be entered recursively. A simple example is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'This tells kbuild that there is one object in the current directory named `mymodule.o`
    . `mymodule.o` will be built from `mymodule.c` or `mymodule.S` . How and if `mymodule.o`
    will be built or linked depends on the value of `<X>` :'
  prefs: []
  type: TYPE_NORMAL
- en: If `<X>` is set to `m` , the variable `obj-m` is used, and `mymodule.o` will
    be built as a module.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If `<X>` is set to `y` , the variable `obj-y` is used, and `mymodule.o` will
    be built as part of the kernel. One then says foo is a built-in module.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If `<X>` is set to `n` , the variable `obj-m` is used, and `mymodule.o` will
    not be built at all.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Therefore, the pattern `obj-$(CONFIG_XXX)` is often used, where `CONFIG_XXX`
    is a kernel config option, set or not during the kernel configuration process.
    An example is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '`$(CONFIG_MYMODULE)` evaluates to either `y` or `m` according to its value
    during the kernel configuration (remember `make menuconfig` ). If `CONFIG_MYMODULE`
    is neither `y` nor `m` , then the file will not be compiled nor linked. `y` means
    built-in (it stands for yes in the kernel config process), and `m` stands for
    module. `$(CONFIG_MYMODULE)` pulls the right answer from the normal config process.
    This is explained in the next section.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The last use case is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This means that kbuild should go into the directory named `somedir` ; look for
    any makefile inside and process it in order to decide what objects should be built.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back to the makefile, the following is the content makefile we will use to
    build each of the modules introduced in the book:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '`obj-m := hellowolrd.o` : `obj-m` lists modules we want to build. For each
    `<filename>.o` , the build system will look for a `<filename>.c` to build. `obj-m`
    is used to build a module, whereas `obj-y` will result in a built-in object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`KERNELDIR := /lib/modules/$(shell uname -r)/build` : `KERNELDIR` is the location
    of the prebuilt kernel source. As we said earlier, we need a prebuilt kernel in
    order to build any module. If you have built your kernel from the source, one
    should set this variable with the absolute path of the built source directory.
    `-C` instructs to make utility to change into the specified directory prior to
    reading the makefiles or doing anything else.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`M=$(shell pwd)` : This is relevant to the kernel build system. The kernel
    Makefile uses this variable to locate the directory of the external module to
    build. Your .c files should be placed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`all default: modules` : This line instructs the `make` utility to execute
    the `modules` target, whether `all` or `default` targets, which are classical
    targets when it comes to building user apps. In other words, `make default` or
    `make all` or simply `make` commands will be translated into `make modules` .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`modules modules_install help clean:` : This line represents the list target
    valid in this Makefile .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$(MAKE) -C $(KERNELDIR ) M=$(shell pwd) $@` : This is the rule to be executed
    for each target enumerated above. `$@` will be replaced with the name of the target
    that caused the rule to run. In other words, if one calls make modules, `$@` will
    be replaced with modules, and the rule will become: `$(MAKE) -C $(KERNELDIR )
    M=$(shell pwd) module` .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the kernel tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before you can build your driver in the kernel tree, you should first identify
    which directory in drivers should host your `.c` file. Given your file name `mychardev.c`
    , which contains the source code of your special character driver, it should be
    placed to the `drivers/char` directory in the kernel source. Every subdirectory
    in drivers has both `Makefile` and `Kconfig` files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following content to the `Kconfig` of that directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'In the makefile of that same directory, add:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Be careful when updating the `Makefile` ; the `.o` file name must match the
    exact name of your `.c` file. If your source file is `foobar.c,` you must use
    `foobar.o` in the `Makefile` . In order to have your driver built as a module,
    add the following line in your board defconfig in the `arch/arm/configs` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'You may also run `make menuconfig` to select it from the UI, and run `make`
    , to build the kernel, then `make modules` to build modules (including yours).
    To make the driver be built in, just replace `m` with `y` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Everything described here is what embedded board manufacturers do in order
    to provide a **Board Support Package** (**BSP** ) with their board, with a kernel
    that already contains their custom drivers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: packt_dev module in kernel tree
  prefs: []
  type: TYPE_NORMAL
- en: Once configured, you can build the kernel with `make` and build modules with
    `make modules` .
  prefs: []
  type: TYPE_NORMAL
- en: 'Modules included in the kernel source tree are installed in `/lib/modules/$(KERNELRELEASE)/kernel/`
    . On your Linux system, it is `/lib/modules/$(uname -r)/kernel/` . Run the following
    command in order to install the modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Out of the tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before you can build an external module, you need to have a complete and precompiled
    kernel source-tree. The kernel source-tree version must be the same as the kernel
    you''ll load and use your module with. There are two ways to obtain a prebuilt
    kernel version:'
  prefs: []
  type: TYPE_NORMAL
- en: Build it by yourself (discussed this earlier)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Install the `linux-headers-*` package from your distribution repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: This will install only headers, not the whole source tree. Headers will then
    be installed in `/usr/src/linux-headers-$(uname -r)` . On my computer, it is `/usr/src/linux-headers-4.4.0-79-generic/`
    . There will be a symlink, `/lib/modules/$(uname -r)/build` , pointing to the
    previously installed headers. It is the path you should specify as your kernel
    directory in your `Makefile` . It is all you have to do for a prebuilt kernel.
  prefs: []
  type: TYPE_NORMAL
- en: Building the module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, when you are done with your makefile, just change to your source directory
    and run the `make` command, or `make modules` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example only dealt with native builds, compiling on an x86 machine
    for an x86 machine. What about cross-compilation ? This is the process by which
    one compiles on machine A, called host, a code that is intended to run on machine
    B, called target; host and target having different architectures. The classical
    use case is to build on an x86 machine a code that should run on an ARM architecture,
    which is exactly our situation.
  prefs: []
  type: TYPE_NORMAL
- en: 'When it comes to crosscompiling a kernel module, there are essentially two
    variables the kernel makefile needs to be aware of; these are: `ARCH` and `CROSS_COMPILE`
    , which respectively represent the target architecture and the compiler prefix
    name. So what change between native compilation and cross compilation of a kernel
    module is the `make` command. The following is the line to build for ARM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter showed you the basics of driver development and explained the concept
    of module/built-in devices, as well as their loading and unloading. Even if you
    are not able to interact with the user space, you are ready to write a complete
    driver, print a formatted message, and understand the concept of `init` /`exit`
    . The next chapter will deal with character devices, with which you will be able
    to target enhanced features, write code accessible from the user space, and have
    a significant impact on the system.
  prefs: []
  type: TYPE_NORMAL
