- en: Validating Component Properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you'll learn about property validation in React components.
    This might seem simple at first glance, but it's an important topic because it
    leads to bug-free components. I'll start things off with a discussion about **predictable
    outcomes** and how this leads to components that are portable throughout the application.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you'll walk through examples of some of the type-checking property validators
    that come with React. Then, you'll walk through some more complex property-validation
    scenarios. Finally, I'll wrap the chapter up with an example of how to implement
    your own custom validators.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing what to expect
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Property validation** in React components is like field validation in HTML
    forms. The basic premise of validating form fields is letting the user know that
    they''ve provided a value that''s not acceptable. Ideally, the validation error
    message is clear enough that the user can easily fix the situation. With React
    component property validation, you''re doing the same thing—making it easy to
    fix a situation where an unexpected value was provided. Property validation enhances
    the developer experience, rather than the user experience.'
  prefs: []
  type: TYPE_NORMAL
- en: The key aspect of property validation is knowing what's passed into the component
    as a property value. For example, if you're expecting an array and a boolean is
    passed instead, something will probably go wrong. If you validate the property
    values using the `prop-types` React validation package, then you know that something
    unexpected was passed. If the component is expecting an array so that it can call
    the `map()` method, it'll fail if a Boolean value is passed because it has no
    `map()` method. However, before this failure happens, you'll see the property
    validation warning.
  prefs: []
  type: TYPE_NORMAL
- en: The idea isn't to **fail fast** with property validation. It's to provide information
    to the developer. When property validation fails, you know that something was
    provided as a component property that shouldn't have been. It's a matter of finding
    where the value is passed in the code and fixing it.
  prefs: []
  type: TYPE_NORMAL
- en: Fail fast is an architectural property of software in which the system will
    crash completely rather than continue running in an inconsistent state.
  prefs: []
  type: TYPE_NORMAL
- en: Promoting portable components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you know what to expect from your component properties, the context in
    which the component is used becomes less important. This means that as long as
    the component is able to validate its property values, it really shouldn't matter
    where the component is used; it could easily be used by any feature.
  prefs: []
  type: TYPE_NORMAL
- en: If you want a generic component that's portable across application features,
    you can either write component validation code or you can write **defensive code**
    that runs at render time. The challenge with programming defensively is that it
    dilutes the value of declarative React components. Using React-style property
    validation, you can avoid writing defensive code. Instead, the property validation
    mechanism emits a warning when something doesn't pass, informing you that you
    need to fix something.
  prefs: []
  type: TYPE_NORMAL
- en: Defensive code is code that needs to account for a number of edge cases during
    runtime, in a production environment. Coding defensively is necessary when potential
    problems cannot be detected during development, like with React component property
    validation.
  prefs: []
  type: TYPE_NORMAL
- en: Simple property validators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you'll learn how to use the simple property type validators
    available in the `prop-types` package. Then, you'll learn how to accept any property
    value as well as make a property **required** instead of **optional**.
  prefs: []
  type: TYPE_NORMAL
- en: Basic type validation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s take a look at validators that handle the most primitive types of JavaScript
    values. You will use these validators frequently, as you''ll want to know that
    a property is a string or that it''s a function, for example. This example will
    also introduce you to the mechanisms involved with setting up validation on a
    component. Here''s the component; it just renders some properties using basic
    markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: There are two key pieces to the property validation mechanism. First, you have
    the static `propTypes` property. This is a class-level property, not an instance
    property. When React finds `propTypes`, it uses this object as the property specification
    of the component. Second, you have the `PropTypes` object from the `prop-types`
    package, which has several built-in validator functions.
  prefs: []
  type: TYPE_NORMAL
- en: The `PropTypes` object used to be built into React. It was split from the React
    core and moved into the `prop-types` package so that it became an opt-in to use
    – a request by React developers that do not use property validation.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, `MyComponent` has six properties, each with their own type.
    When you look at the `propTypes` specification, you can see what type of values
    this component will accept. Let''s render this component with some property values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The first time `<MyComponent>` is rendered, it uses the `validProps` properties.
    These values all meet the component property specification, so no warnings are
    logged in the console. The second time around, the `invalidProps` properties are
    used, and this fails the property validation, because the wrong type is used in
    every property. The console output should look something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This last error is interesting. You can clearly see that the property validation
    is complaining about the invalid property types. This includes the invalid function
    that was passed to `myFunc`. So, despite the type checking that happens on the
    property, the component will still try to call the value as though it were a function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s what the rendered output looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/fe0fcdfb-8e2b-4b88-9860-538c1cee3c61.png)Once again, the aim of
    property validation in React components is to help you discover bugs during development.
    When React is in production mode, property validation is turned off completely.
    This means that you don''t have to concern yourself with writing expensive property
    validation code; it''ll never run in production. However, the error will still
    occur, so fix it.'
  prefs: []
  type: TYPE_NORMAL
- en: Requiring values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s make some adjustments to the preceding example. The component property
    specification required specific types for values, but these are only checked if
    the property is passed to the component as a JSX attribute. For example, you could
    have completely omitted the `myFunc` property and it would have validated. Thankfully,
    the `PropTypes` functions have a tool that lets you specify that a property must
    be provided and it must have a specific type. Here''s the modified component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Not much has changed between this component and the one that you implemented
    in the preceding section. The main difference is with the specs in `propTypes`.
    The `isRequired` value is appended to each of the type validators used. So, for
    instance, `string.isRequired` means that the property value must be a string,
    and the property cannot be missing. Let''s put this component to the test now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The first time around, the component is rendered with all of the correct property
    types. The second time around, the component is rendered without the `myObject`
    property. The console errors should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Thanks to the property specification and subsequent error message for `myObject`,
    it's clear that an object value needs to be provided to the `myObject` property.
    The last error is because the component assumes that there is an object with `myProp`
    as a property.
  prefs: []
  type: TYPE_NORMAL
- en: Ideally, you would validate for the `myProp` object property in this example
    since it's directly used in the JSX. The specific properties that are used in
    the JSX markup for the shape of an object, and shape can be validated, as you'll
    see later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Any property value
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The final topic of this section is the `any` property validator. That is, it
    doesn''t actually care what value it gets—anything is valid, including not passing
    a value at all. In fact, the `isRequired` validator can be combined with the `any`
    validator. For example, if you''re working on a component and you just want to
    make sure that something is passed, but not sure exactly which type you''re going
    to need yet, you could do something like `myProp: PropTypes.any.isRequired`.'
  prefs: []
  type: TYPE_NORMAL
- en: Another reason to have the `any` property validator is for the sake of consistency.
    Every component should have property specifications. The `any` validator is useful
    in the beginning, when you're not exactly sure what the property type will be.
    You can at least begin the property spec, and then refine it later as things unfold.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at some code now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This component doesn''t actually validate anything because the three properties
    in its property spec will accept anything. However, it''s a good starting point,
    because at a glance, I can see the names of the three properties that this component
    uses. So later on, when I decide exactly which types these properties should have,
    the change is simple. Let''s see this component in action now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Strings and numbers are interchangeable in several places. Allowing just one
    or the other seems overly restrictive. As you'll see in the next section, React
    has other property validators that allow you to further restrict property values
    allowed by your component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s what our component looks like when rendered:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/070e9a68-1e63-4c79-a9d3-f31bb093adb2.png)'
  prefs: []
  type: TYPE_IMG
- en: Type and value validators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you'll learn about the more advanced validator functionality
    available in the React `prop-types` package. First, you'll learn about the element
    and node validators that check for values that can be rendered inside HTML markup.
    Then, you'll see how to check for specific types, beyond the primitive type checking
    that you just learned about. Finally, you'll implement validation that looks for
    specific values.
  prefs: []
  type: TYPE_NORMAL
- en: Things that can be rendered
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, you just want to make sure that a property value is something that
    can be rendered by JSX markup. For example, if a property value is an array of
    plain objects, this can't be rendered by putting it in `{}`. You have to map the
    array items to JSX elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'This sort of checking is especially useful if your component passes property
    values to other elements as children. Let''s look at an example of what this looks
    like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This component has two properties that require values that can be rendered.
    The `myHeader` property wants an `element`. This can be any JSX element. The `myContent`
    property wants a `node`. This can be any JSX element or any string value. Let''s
    pass this component some values and render it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `myHeader` property is more restrictive about the values it will accept.
    The `myContent` property will accept a string, an element, or an array of elements.
    These two validators are important when passing in child data from properties,
    as this component does. For example, trying to pass a plain object or a function
    as a child will not work, and it's best if you check for this situation using
    a validator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s what this component looks like when rendered:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/34cff75d-ef5e-493b-bf5c-0952fff62538.png)'
  prefs: []
  type: TYPE_IMG
- en: Requiring specific types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes, you need a property validator that checks for a type defined by
    your application. For example, let''s say you have the following user class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, suppose that you have a component that wants to use an instance of this
    class as a property value. You would need a validator that checks that the property
    value is an instance of `MyUser`. Let''s implement a component that does just
    that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This component has three properties that require specific types, each going
    beyond the basic type validators that you''ve seen so far in this chapter. Let''s
    walk through these now:'
  prefs: []
  type: TYPE_NORMAL
- en: '`myDate` requires an instance of `Date`. It uses the `instanceOf()` function
    to build a validator function that ensures the value is a `Date` instance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`myCount` requires that the value either be a number or a string. This validator
    function is created by combining `oneOfType`, `PropTypes.number()`, and `PropTypes.string()`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`myUsers` requires an array of `MyUser` instances. This validator is built
    by combining `arrayOf()` and `instanceOf()`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This example illustrates the number of scenarios that you can handle by combining
    the property validators provided by React. Here''s what the rendered output looks
    like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/aac1c9ee-ab58-4201-905a-e5ea0eb47ca0.png)'
  prefs: []
  type: TYPE_IMG
- en: Requiring specific values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I''ve focused on validating the type of property values so far, but that''s
    not always what you''ll want to check for. Sometimes, specific values matter.
    Let''s see how you can validate specific property values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `level` property is expected to be a number from the `levels` array. This
    is easy to validate using the `oneOf()` function. The `user` property is expecting
    a specific shape. A shape is the expected properties and types of an object. The
    `userShape` defined in this example requires a `name` string and an `age` number.
    The key difference between `shape()` and `instanceOf()` is that you don't necessarily
    care about the type. You might only care about the values that are used in the
    JSX of the component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at how this component is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s what the component looks like when it''s rendered:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/73b1b803-db22-4c20-84ae-72d2b13e0105.png)'
  prefs: []
  type: TYPE_IMG
- en: Writing custom property validators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this final section, you'll learn how to build your own custom property validation
    functions and apply them in the property specification. Generally speaking, you
    should only implement your own property validator if you absolutely have to. The
    default validators available in `prop-types` cover a wide range of scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, sometimes, you need to make sure that very specific property values
    are passed to the component. Remember, these will not be run in production mode,
    so it''s perfectly acceptable for a validator function to iterate over collections.
    Let''s implement some custom validator functions now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The `myArray` property expects a non-empty array, and the `myNumber` property
    expects a number that''s greater than `0` and less than `100`. Let''s try passing
    these validators some data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The first element renders just fine, as both of the validators return null.
    However, the empty array and the number `100` cause both validators to return
    errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s what the rendered output looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/cc4bf346-2ab7-4e36-a9a4-77b8e9392185.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The focus of this chapter has been React component property validation. When
    you implement property validation, you know what to expect; this promotes portability.
    The component doesn't care how the property values are passed to it, just as long
    as they're valid.
  prefs: []
  type: TYPE_NORMAL
- en: Then, you worked on several examples that used the basic React validators that
    check primitive JavaScript types. You also learned that if a property is required,
    this must be made explicit. Next, you learned how to validate more complex property
    values by combining the built-in validators that come with React.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you implemented your own custom validator functions to perform validation
    that goes beyond what's possible with the `prop-types` validators. In the next
    chapter, you'll learn how to extend React components with new data and behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Test your knowledge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Which of the following best describes the `prop-types` package?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A strongly typed JavaScript utility for compiling React components.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A tool to validate prop values that are passed to components during development.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A tool to validate prop values that are passed to components in production.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you validate that a property value is something that can be rendered?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If it has a `toString()` function, this is enough to render it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the **`PropTypes.node`** validator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `PropTypes.renderable` validator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the purpose of the PropTypes.shape validator?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To make sure that an object has certain properties with certain types, ignoring
    any additional properties.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To make sure that an object passed as a prop is of a particular class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To make sure that an object has certain property names.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[https://reactjs.org/docs/typechecking-with-proptypes.html](https://reactjs.org/docs/typechecking-with-proptypes.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
