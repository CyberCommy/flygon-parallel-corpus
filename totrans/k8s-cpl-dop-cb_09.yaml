- en: Securing Applications and Clusters
  prefs: []
  type: TYPE_NORMAL
- en: 00000000000000In this chapter, we will discuss the fundamental steps of reducing
    the attack surface and securing Kubernetes clusters before we go live from test
    to production. We will talk about security auditing, building DevSecOps into CI/CD
    pipelines, detecting metrics for performance analysis, and how to securely manage
    secrets and credentials.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Using RBAC to harden cluster security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring Pod Security Policies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Kubernetes CIS Benchmark for security auditing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building DevSecOps into the pipeline using Aqua Security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitoring suspicious application activities using Falco
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Securing credentials using HashiCorp Vault
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The recipes in this chapter require that you have a functional Kubernetes cluster
    deployed by following one of the recommended methods described in [Chapter 1](a8580410-3e1c-4e28-8d18-aaf9d38d011f.xhtml),
    *Building Production-Ready Kubernetes Clusters*.
  prefs: []
  type: TYPE_NORMAL
- en: The Kubernetes command-line tool, `kubectl` ,will be used for the rest of the
    recipes in this chapter since it's the main command-line interface for running
    commands against Kubernetes clusters. We will also use `helm` where Helm charts
    are available to deploy solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Using RBAC to harden cluster security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a complex system such as Kubernetes, authorization mechanisms are used to
    set who is allowed to make what changes to the cluster resources and manipulate
    them. **Role-based access control** (**RBAC**) is a mechanism that's highly integrated
    into Kubernetes that grants users and applications granular access to Kubernetes
    APIs.
  prefs: []
  type: TYPE_NORMAL
- en: As good practice, you should use the Node and RBAC authorizers together with
    the `NodeRestriction` admission plugin.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will cover getting RBAC enabled and creating Roles and RoleBindings
    to grant applications and users access to the cluster resources.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Make sure you have an RBAC-enabled Kubernetes cluster ready (since Kubernetes
    1.6, RBAC is enabled by default) and that `kubectl` and `helm` have been configured
    so that you can manage the cluster resources. Creating private keys will also
    require that you have the `openssl` tool before you attempt to create keys for
    users.
  prefs: []
  type: TYPE_NORMAL
- en: 'Clone the `k8sdevopscookbook/src` repository to your workstation to use the
    manifest files IN the `chapter9` directory, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: RBAC is enabled by default starting with Kubernetes 1.6\. If it is disabled
    for any reason, start the API server with `--authorization-mode=RBAC` to enable
    RBAC.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This section is further divided into the following subsections to make this
    process easier:'
  prefs: []
  type: TYPE_NORMAL
- en: Viewing the default Roles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating user accounts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating Roles and RoleBindings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing the RBAC rules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Viewing the default Roles
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: RBAC is a core component of the Kubernetes cluster that allows us to create
    and grant roles to objects and control access to resources within the cluster.
    This recipe will help you understand the content of roles and role bindings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s perform the following steps to view the default roles and role bindings
    in our cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: 'View the default cluster roles using the following command. You will see a
    long mixed list of `system:`, `system:controller:`, and a few other prefixed `roles. system:*`
    roles are used by the infrastructure, `system:controller`  roles are used by a
    Kubernetes controller manager, which is a control loop that watches the shared
    state of the cluster. In general, they are both good to know about when you need
    to troubleshoot permission issues, but they''re not something we will be using
    very often:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'View one of the system roles owned by Kubernetes to understand their purpose
    and limits. In the following example, we''re looking at `system:node`, which defines
    the permission for kubelets. In the output in Rules, `apiGroups:` indicates the
    core API group, `resources` indicates the Kubernetes resource type, and `verbs` indicates
    the API actions allowed on the role:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s view the default user-facing roles since they are the ones we are more
    interested in. The roles that don''t have the `system:` prefix are intended to
    be user-facing roles. The following command will only list the non-system: prefix
    roles. The main roles that are intended to be granted within a specific namespace
    using RoleBindings are the `admin`, `edit`, and `view` roles:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, review the default cluster binding, that is, `cluster-admin`, using the
    following command. You will see that this binding gives the `system:masters` group
    cluster-wide superuser permissions with the `cluster-admin` role:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Since the Kubernetes 1.6 release, RBAC is enabled by default and new users can
    be created and start with no permissions until permissions are assigned by an
    admin user to a specific resource. Now, you know about the available default roles.
  prefs: []
  type: TYPE_NORMAL
- en: In the following recipes, you will learn how to create new Roles and RoleBindings
    and grant accounts the permissions that they need.
  prefs: []
  type: TYPE_NORMAL
- en: Creating user accounts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As explained in the Kubernetes docs, Kubernetes doesn't have objects to represent
    normal user accounts. Therefore, they need to be managed externally (check the *Kubernetes
    Authentication* documentation in the *See also* section for more details). This
    recipe will show you how to create and manage user accounts using private keys.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s perform the following steps to create a user account:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a private key for the example user. In our example, the key file is
    `user3445.key`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a **certificate sign request** (**CSR**) called `user3445.csr` using
    the private key we created in *Step 1*. Set the username (`/CN`) and group name
    (`/O`) in the `-subj` parameter. In the following example, the username is `john.geek`,
    while the group is `development`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'To use the built-in signer, you need to locate the cluster-signing certificates
    for your cluster. By default, the `ca.crt` and `ca.key` files should be in the
    `/etc/kubernetes/pki/` directory.If you are using kops to deploy, your cluster
    signing keys can be downloaded from `s3://$BUCKET_NAME/$KOPS_CLUSTER_NAME/pki/private/ca/*.key`
    and `s3://$BUCKET_NAME/$KOPS_CLUSTER_NAME/pki/issued/ca/*.crt`. Once you''ve located
    the keys, change the `CERT_LOCATION` mentioned in the following code to the current
    location of the files and generate the final signed certificate:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If all the files have been located, the command in *Step 3* should return an
    output similar to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Before we move on, make sure you store the signed keys in a safe directory.
    As an industry best practice, using a secrets engine or Vault storage is recommended.
    You will learn more about Vault storage later in this chapter IN the *Securing
    credentials using HashiCorp Vault* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new context using the new user credentials:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'List the existing context using the following comment. You will see that the
    new `user3445-context` has been created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, try to list the pods using the new user context. You will get an access
    denied error since the new user doesn''t have any roles and new users don''t come
    with any roles assigned to them by default:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Optionally, you can `base64` encode all three files (`user3445.crt`, `user3445.csr`,
    and `user3445.key`) using the `openssl base64 -in <infile> -out <outfile>` command
    and distribute the populated `config-user3445.yml` file to your developers. An
    example file can be found in this book''s GitHub repository in the `src/chapter9/rbac`
    directory. There are many ways to distribute user credentials. Review the example
    using your text editor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: With that, you've learned how to create new users. Next, you will create roles
    and assign them to the user.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Roles and RoleBindings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Roles and RolesBindings are always used in a defined namespace, meaning that the
    permissions can only be granted for the resources that are in the same namespace
    as the Roles and the RoleBindings themselves compared to the ClusterRoles and
    ClusterRoleBindings that are used to grant permissions to cluster-wide resources
    such as nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s perform the following steps to create an example Role and RoleBinding
    in our cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create a namespace where we will create the Role and RoleBinding. In
    our example, the namespace is `secureapp`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a role using the following rules. This role basically allows all operations
    to be performed on deployments, replica sets, and pods for the `deployer` role
    in the `secureapp` namespace we created in *Step 1.* Note that any permissions
    that are granted are only additive and there are no deny rules:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a RoleBinding using the `deployer` role and for the username `john.geek`
    in the `secureapp` namespace. We''re doing this since a RoleBinding can only reference
    a Role that exists in the same namespace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: With that, you've learned how to create a new Role and grant permissions to
    a user using RoleBindings.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the RBAC rules
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s perform the following steps to test the Role and RoleBinding we created
    earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Deploy a test pod in the `secureapp` namespace where the user has access:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'List the pods in the new user''s context. The same command that failed in the
    *Creating user accounts* recipe in *Step 7* should now execute successfully:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: If you try to create the same pod in a different namespace, you will see that
    the command will fail to execute.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe showed you how to create new users in Kubernetes and quickly create
    Roles and RoleBindings to grant permission to user accounts on Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Kubernetes clusters have two types of users:'
  prefs: []
  type: TYPE_NORMAL
- en: '**User accounts**: User accounts are normal users that are managed externally.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Service accounts**: Service accounts are the users who are associated with
    the Kubernetes services and are managed by the Kubernetes API with its own resources.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can read more about service accounts by looking at the *Managing service
    accounts* link in the *See also* section.
  prefs: []
  type: TYPE_NORMAL
- en: In the *Creating Roles and RoleBindings* recipe, in *Step 1*, we created a Role
    named `deployer`. Then, in *Step 2*, we granted the rules associated with the
    deployer Role to the user account `john.geek`.
  prefs: []
  type: TYPE_NORMAL
- en: RBAC uses the `rbac.authorization.k8s.io` API to make authorization decisions.
    This allows admins to dynamically configure policies using the Kubernetes APIs.
    If you wanted to use the existing Roles and give someone cluster-wide superuser
    permission, you could use the `cluster-admin` ClusterRole with a ClusterRoleBinding
    instead. ClusterRoles don't have namespace limits and can execute commands in
    any namespace with the granted permissions. Overall, you should be careful while
    assigning the `cluster-admin` ClusterRole to users. ClusterRoles can be also limited
    to namespaces, similar to Roles if they are used with RoleBindings to grant permissions
    instead.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: RBAC Authorization in Kubernetes documentation: [https://kubernetes.io/docs/reference/access-authn-authz/rbac/#rolebinding-and-clusterrolebinding](https://kubernetes.io/docs/reference/access-authn-authz/rbac/#rolebinding-and-clusterrolebinding)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'More on the default roles and role bindings: [https://kubernetes.io/docs/reference/access-authn-authz/rbac/#default-roles-and-role-bindings](https://kubernetes.io/docs/reference/access-authn-authz/rbac/#default-roles-and-role-bindings)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Autogenerating RBAC policies based on Kubernetes audit logs: [https://github.com/liggitt/audit2rbac](https://github.com/liggitt/audit2rbac)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Kubernetes Authentication: [https://kubernetes.io/docs/reference/access-authn-authz/authentication/](https://kubernetes.io/docs/reference/access-authn-authz/authentication/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Managing Service Accounts: [https://kubernetes.io/docs/reference/access-authn-authz/service-accounts-admin/](https://kubernetes.io/docs/reference/access-authn-authz/service-accounts-admin/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The kubectl-bindrole tool for finding Kubernetes Roles bound to a specified
    ServiceAccount: [https://github.com/Ladicle/kubectl-bindrole](https://github.com/Ladicle/kubectl-bindrole)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring Pod Security Policies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Pod Security Policies** (**PSP**) are used on Kubernetes clusters to enable
    granular authorization of pod creation and to control security aspects of pods.
    PodSecurityPolicy objects define the conditions for a pod to be accepted into
    the cluster and run as expected.'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will cover the recreation and configuration of PSPs on Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Make sure you have an RBAC-enabled Kubernetes cluster ready (since Kubernetes
    1.6, RBAC is enabled by default) and `kubectl` and `helm` configured to manage
    the cluster resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'Clone the `k8sdevopscookbook/src` repository to your workstation to use the
    manifest files in the `chapter9` directory, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Verify if PodSecurityPolicy needs to be enabled on your cluster by running the
    `kubectl get psp` command. If you get a message stating `the server doesn't have
    a resource type "podSecurityPolicies".`, then PSP needs to be enabled on your
    cluster.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This section is further divided into the following subsections to make this
    process easier:'
  prefs: []
  type: TYPE_NORMAL
- en: Enabling PSPs on EKS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enabling PSPs on GKE
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enabling PSPs on AKS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a restricted PSPs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enabling PSPs on EKS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As a best practice, PSPs should not be enabled before you create your own policies. This
    recipe will take you through how to enable PSP on Amazon EKS and how to review
    default policies.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Deploy Kubernetes version 1.13 or higher. PSP will be enabled by default. The
    default configuration comes with a non-disruptive policy named `eks.privileged`
    that has no restrictions. View the default policy with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Describe the policy to see its full details, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: To review, restore, or delete the default PSP, use the YAML manifest in the
    example repository in `src/chapter9/psp` named `eks-privileged-psp.yaml`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enabling PSPs on GKE
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As a best practice, PSPs should not be enabled before you create your own policies. This
    recipe will take you through how to enable PSP on **Google Kubernetes Engine**
    (**GKE**) and how to review default policies.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can enable PSP on the cluster you deployed by following the instructions
    given in [Chapter 1](a8580410-3e1c-4e28-8d18-aaf9d38d011f.xhtml), *Building Production-Ready
    Kubernetes Clusters*, in the *Provisioning a managed Kubernetes cluster on GKE* recipe
    by running the following command. Replace `k8s-devops-cookbook-1` with your own
    cluster name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The default configuration comes with a non-disruptive policy named `gce.privileged`
    that has no restrictions and couple of other policies. View the default policies
    with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Describe the policy to see its full details, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: To review, restore, or delete the default PSP, use the YAML manifest in the
    example repository in `src/chapter9/psp` named `gce-privileged-psp.yaml`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enabling PodSecurityPolicy on AKS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As a best practice, PodSecurityPolicy should not be enabled before you create
    your own policies. This recipe will take you through how to enable PSP on **Azure
    Kubernetes Service** (**AKS**) and how to review default policies.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can enable PSP on the cluster you have deployed by following the instructions
    given in [Chapter 1](a8580410-3e1c-4e28-8d18-aaf9d38d011f.xhtml) *Building Production-Ready
    Kubernetes Clusters*, in the *Provisioning a managed Kubernetes cluster on AKS* recipe
    by running the following command. Replace `k8sdevopscookbook` with your own resource
    group and `AKSCluster` with your cluster name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'he default configuration comes with a non-disruptive policy named `privileged`
    that has no restrictions. View the default policy with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Describe the policy to see its full details, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: To review, restore, or delete the default PSP, use the YAML manifest in the
    example repository in `src/chapter9/psp` named `aks-privileged-psp.yaml`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating a restricted PSPs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As a security best practice, it is recommended to restrict containers in pods
    from running with root user privileges to limit any possible risks. When running
    in privileged mode, processes that run inside the container have the same privileges
    and access as the processes outside the container, which can raise the risk of
    some management capabilities being accessed by attackers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s perform the following steps to create a root access restricted PodSecurityPolicy:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Deploy a new restricted `PodSecurityPolicy`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Confirm that the policy has been created. You will notice that the `RUNASUSER`
    column shows `MustRunAsNonRoot`, which indicates that using root privileges is
    not allowed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Verify the PSP by running a pod that requires root access. The deployment will
    fail and show a message stating `container has runAsNonRoot and image will run
    as root`, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: With that, you've learned how to create a root access restricted PodSecurityPolicy.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This section is further divided into the following subsections to make this
    process easier:'
  prefs: []
  type: TYPE_NORMAL
- en: Restricting pods to access certain volume types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Kubernetes PSPs advisor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Restricting pods to access certain volume types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As part of the PodSecurityPolicy rule, you may want to limit the use of a specific
    type of volume. In this recipe, you will learn how to restricts containers to
    volume types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s perform the following steps to create a PodSecurityPolicy:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new restricted `PodSecurityPolicy`. This policy limits the type of
    volume to `nfs` only:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Verify the policy by deploying an application that requires persistent storage.
    Here, we will use the MinIO example from previous chapters. The deployment should
    fail with a message stating `persistentVolumeClaim volumes are not allowed to
    be used`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Delete both the PSPs and the deployment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The recommended set of allowed volumes for new PSPs are `configMap`, `downwardAPI`,
    `emptyDir`, `persistentVolumeClaim`, `secret`, and `projected`. You can find the
    complete list of volume types by going to the *Type of volumes supported* link
    in the *See also* section. Create a new restricted PodSecurityPolicy using the
    following content. This policy limits the type of volume to `persistentVolumeClaim` only:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Repeat *Step 2* to deploy the application. This time, `persistentVolumeClaim`
    creation will be allowed and the PVC that was requested by the pod will be created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using Kubernetes PodSecurityPolicy advisor
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Kubernetes PodSecurityPolicy Advisor is a simple tool from Sysdig that's used
    to enforce best security practices in Kubernetes. `kube-psp-advisor` scans the
    existing security context of Kubernetes resources and generates the PSPs for the
    resources in the cluster to remove unnecessary privileges.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s perform the following steps to enable `kube-psp-advisor` on our cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Clone the repository and build the project using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the scan process by executing the binary. If you want to limit the scan
    to a namespace, you can specify it by adding the `--namespace=` parameter to the
    command, similar to what can be seen in the following code. If you don''t do this,
    it will scan the whole cluster. After doing this, a `PodSecurityPolicy` will be
    generated:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Review the content of the `psp-advisor.yaml` file and apply the generated PSP:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: With that, you've learned how to generate a PSP in a simpler way to reduce the
    unnecessary permissions that may increase the attack surface.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Kubernetes documentation – PodSecurityPolicy: [https://kubernetes.io/docs/concepts/policy/pod-security-policy/](https://kubernetes.io/docs/concepts/policy/pod-security-policy/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type of volumes supported: [https://kubernetes.io/docs/concepts/storage/volumes/#types-of-volumes](https://kubernetes.io/docs/concepts/storage/volumes/#types-of-volumes)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Kubernetes CIS Benchmark for security auditing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kubernetes CIS Benchmarks are the security configuration best practices that
    are accepted by industry experts. The CIS Benchmark guide can be download as a
    PDF file from the **Center for Internet Security** (**CIS**) website at [https://www.cisecurity.org/](https://www.cisecurity.org/).
    `kube-bench` is an application that automates documented checks.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will cover the installation and use of the open source `kube-bench`
    tool to run Kubernetes CIS Benchmarks for security auditing of Kubernetes clusters.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we need to have a Kubernetes cluster ready and the Kubernetes
    command-line tool `kubectl` installed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Clone the `k8sdevopscookbook/src` repository to your workstation to use the
    manifest files in the `chapter9` directory, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Some of the tests target Kubernetes nodes and can only be executed on fully
    self-managed clusters where you have control over the master nodes. Therefore,
    managed clusters such as EKS, GKE, AKS, and so on will not be able to execute
    all the tests and require different job descriptions or parameters to execute
    the tests. These will be mentioned when necessary.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This section is further divided into the following subsections to make this
    process easier:'
  prefs: []
  type: TYPE_NORMAL
- en: Running kube-bench on Kubernetes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running kube-bench on managed Kubernetes services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running kube-bench on OpenShift
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running kube-hunter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running kube-bench on Kubernetes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The CIS Benchmark has tests for both master and worker nodes. Therefore, the
    full scope of the test can only be completed on self-managed clusters where you
    have control over the master nodes. In this recipe, you will learn how to run
    kube-bench directly on the master and worker nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s perform the following steps to run the CIS recommended tests:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Download and install the `kube-bench` command-line interface on one of your
    master nodes and one of your worker nodes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'SSH into your Kubernetes master node and run the following command. It will
    quickly return the result of the test with an explanation and a list of additional
    manual tests that are recommended to be run after. Here, you can see that `31`
    checks passed and `36` tests failed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'To save the results, use the following command. After the test is complete, move
    the `kube-bench-master.txt` file to your localhost for further review:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Review the content of the `kube-bench-master.txt` file. You will see the status
    of the checks from the CIS Benchmark for the Kubernetes guide, similar to the
    following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Tests are split into categories that have been suggested in the CIS Benchmark
    guidelines, such as API Server, Scheduler, Controller Manager, Configuration Manager,
    etcd, General Security Primitives, and PodSecurityPolicies.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow the methods suggested in the *Remediations* section of the report to
    fix the failed issues and rerun the test to confirm that the correction has been
    made. You can see some of the remediations that were suggested by the preceding
    report here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take one of the issues from the preceding list. `1.2.1` suggests that
    we disable the profiling API endpoint. The reason for this is that highly sensitive system
    information can be uncovered by profiling data and the amount of data and load
    that''s created by profiling your cluster could be put out of service (denial-of-service
    attack) by this feature. Edit the `kube-scheduler.manifest` file and add `--profiling=false`
    right after the `kube-schedule` command, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the test again and confirm that the issue on `1.2.1` has been corrected.
    Here, you can see that the number of passed tests has increased from `31` to `32`.
    One more check has been cleared:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the test on the worker nodes by using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'To save the results, use the following command. After the test has completed, move
    the `kube-bench-worker.txt` file to your localhost for further review:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Review the content of the `kube-bench-worker.txt` file. You will see the status
    of the checks from the CIS Benchmark for the Kubernetes guide, similar to the
    following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, follow all the remediations until you've cleared all the failed tests
    on the master and worker nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Running kube-bench on managed Kubernetes services
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The difference between managed Kubernetes services such as EKS, GKE, AKS, and
    so on is that you can't run the checks on the master. Instead, you have to either
    only follow the worker checks from the previous recipe or run a Kubernetes job
    to validate your environment. In this recipe, you will learn how to run kube-bench
    on managed Kubernetes service-based nodes and also in cases where you don't have
    direct SSH access to the nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s perform the following steps to run the CIS recommended tests:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For this recipe, we will use EKS as our Kubernetes service, but you can change
    the Kubernetes and container registry services to other cloud providers if you
    wish. First, create an ECR repository where we will host the kube-bench image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Clone the `kube-bench` repository to your localhost:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Log in to your **Elastic Container Registry** (**ECR**) account. You need to
    be authenticated before you can push images to the registry:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Build the kube-bench image by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace `<AWS_ACCT_NUMBER>` with your AWS account number and execute it to
    push it to the ECR repository. The first command will create a tag, while the
    second command will push the image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Edit the `job-eks.yaml` file and replace the image name on line 12 with the
    URI of the image you pushed in *Step 5*. It should look similar to the following,
    except you should use your AWS account number in the image URI:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the job using the following command. It will be executed and completed
    shortly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'List the kube-bench pods that were created in your cluster. It should show
    `Completed` as the status, similar to the following example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace the pod name with the output of the previous command and view the pod
    logs to retrieve the `kube-bench` results. In our example, the pod name is `kube-bench-7lxzn`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Now, you can run kube-bench on any managed Kubernetes cluster. After you get
    the logs, follow all the remediation suggestions until you clear the failed tests
    on the worker nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Running kube-bench on OpenShift
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: OpenShift has different command-line tools, so if we run the default test jobs,
    we won't be able to gather the required information on our cluster unless specified. In
    this recipe, you will learn how to run `kube-bench` on OpenShift.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s perform the following steps to run the CIS recommended tests:'
  prefs: []
  type: TYPE_NORMAL
- en: 'SSH into your OpenShift master node and run the following command using `--version
    ocp-3.10` or `ocp-3.11` based on your OpenShift version. Currently, only 3.10
    and 3.11 are supported:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'To save the results, use the following command. After the test has been completed, move
    the `kube-bench-master.txt` file to your localhost for further review:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'SSH into your OpenShift worker node and repeat the first two steps of this
    recipe, but this time using the `node` parameter for the OpenShift version you
    are running. In our example, this is OCP 3.11:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Follow the *Running kube-bench on Kubernetes* recipe's instructions to patch
    security issues with the suggested remediations.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe showed you how to quickly run CIS Kubernetes Benchmarks on your
    cluster using kube-bench.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the *Running kube-bench on Kubernetes* recipe, in s*tep 1*, after you executed
    the checks, kube-bench accessed the configuration files that were kept in the
    following directories: `/var/lib/etcd`, `/var/lib/kubelet`, `/etc/systemd`, `/etc/kubernetes`,
    and `/usr/bin`. Therefore, the user who runs the checks needs to provide root/sudo
    access to all the config files.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If the configuration files can''t be found in their default directories, the
    checks will fail. The most common issue is the missing `kubectl` binary in the
    `/usr/bin` directory. kubectl is used to detect the Kubernetes version. You can
    skip this directory by specifying the Kubernetes version using `--version` as
    part of the command, similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '*Step 1* will return four different states. The `PASS` and `FAIL` states are
    self-explanatory as they indicate whether the tests were run successfully or failed. `WARN`
    indicates that the test requires manual validation, which means it requires attention.
    Finally, `INFO` means that no further action is required.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: CIS Kubernetes Benchmarks: [https://www.cisecurity.org/benchmark/kubernetes/](https://www.cisecurity.org/benchmark/kubernetes/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: kube-bench repository: [https://github.com/aquasecurity/kube-bench](https://github.com/aquasecurity/kube-bench)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to customize the default configuration: [https://github.com/aquasecurity/kube-bench/blob/master/docs/README.md#configuration-and-variables](https://github.com/aquasecurity/kube-bench/blob/master/docs/README.md#configuration-and-variables)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automating compliance checking for Kubernetes-based applications: [https://github.com/cds-snc/security-goals](https://github.com/cds-snc/security-goals)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hardening Kubernetes from Scratch: [https://github.com/hardening-kubernetes/from-scratch](https://github.com/hardening-kubernetes/from-scratch)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'CNCF Blog on 9 Kubernetes Security Best Practices Everyone Must Follow: [https://www.cncf.io/blog/2019/01/14/9-kubernetes-security-best-practices-everyone-must-follow/](https://www.cncf.io/blog/2019/01/14/9-kubernetes-security-best-practices-everyone-must-follow/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hardening Guide for Rancher [https://rancher.com/docs/rancher/v2.x/en/security/hardening-2.2/](https://rancher.com/docs/rancher/v2.x/en/security/hardening-2.2/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Must-have Kubernetes security audit tools:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kube-bench: [https://github.com/aquasecurity/kube-bench](https://github.com/aquasecurity/kube-bench)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kube-hunter: [https://kube-hunter.aquasec.com/](https://kube-hunter.aquasec.com/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kubeaudit: [https://github.com/Shopify/kubeaudit](https://github.com/Shopify/kubeaudit)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kubesec:[https://github.com/controlplaneio/kubesec](https://github.com/controlplaneio/kubesec)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Open Policy Agent:[https://www.openpolicyagent.org/](https://www.openpolicyagent.org/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: K8Guard: [https://k8guard.github.io/](https://k8guard.github.io/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building DevSecOps into the pipeline using Aqua Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Shift Left** approach to DevOps Security is becoming increasingly popular,
    which means that security must be built into the process and pipeline. One of
    the biggest problems with shortened pipelines is that they often leave little room
    for proper security checks. Due to this, another approach called **deploy changes
    as quickly as possible** was introduced, which is key to the success of DevOps.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will cover automating vulnerability checks in container
    images using Aqua Security to reduce the application attack surface.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Make sure you have an existing CI/CD pipeline configured using your preferred
    CI/CD tool. If not, follow the instructions in [Chapter 3](811c24c7-debf-4487-91e9-81db1520c0aa.xhtml), *Building
    CI/CD Pipelines*, to configure GitLab or CircleCI.
  prefs: []
  type: TYPE_NORMAL
- en: 'Clone the `k8sdevopscookbook/src` repository to your workstation to use the
    manifest files in the `chapter9` directory, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Make sure you have a Kubernetes cluster ready and `kubectl` configured to manage
    the cluster resources.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This section will show you how to integrate Aqua with your CI/CD platform.
    This section is further divided into the following subsections to make this process
    easier:'
  prefs: []
  type: TYPE_NORMAL
- en: Scanning images using Aqua Security Trivy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building vulnerability scanning into GitLab
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building vulnerability scanning into CircleCI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scanning images using Trivy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Trivy is an open source container scanning tool that's used to identify container
    vulnerabilities. It is one of the simplest and most accurate scanning tools in
    the market. In this recipe, we will learn how to install and scan container images
    using Trivy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s perform the following steps to run Trivy:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Get the latest Trivy release number and keep it in a variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Download and install the `trivy` command-line interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Verify that `trivy` is functional by running the following command. It will
    return its current version:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute `trivy` checks by replacing the container image name with your target
    image. In our example, we scanned the `postgres:12.0` image from the Docker Hub
    repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'The test summary will show the number of vulnerabilities that have been detected
    and will include a detailed list of vulnerabilities, along with their IDs and
    an explanation of each of them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: With that, you've learned how to quickly scan your container images. Trivy supports
    a variety of container base images (CentOS, Ubuntu, Alpine, Distorless, and so
    on) and natively supports container registries such as Docker Hub, Amazon ECR,
    and Google Container Registry GCR. Trivy is completely suitable for CI. In the
    next two recipes, you will learn how you can add Trivy into CI pipelines.
  prefs: []
  type: TYPE_NORMAL
- en: Building vulnerability scanning into GitLab
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With GitLab Auto DevOps, the container scanning job uses CoreOS Clair to analyze
    Docker images for vulnerabilities. However, it is not a complete database of all
    security issues for Alpine-based images. Aqua Trivy has nearly double the number
    of vulnerabilities and is more suitable for CI. For a detailed comparison, please
    refer to the *Trivy Comparison* link in the *See also* section. This recipe will
    take you through adding a test stage to a GitLab CI pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s perform the following steps to add Trivy vulnerability checks in GitLab:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the CI/CD pipeline configuration `.gitlab-ci.yml` file in your project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a new stage to your pipeline and define the stage. You can find an example
    in the `src/chapter9/devsecops` directory. In our example, we''re using the `vulTest` stage
    name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the new stage, that is, `vulTest`. When you define a new stage, you specify
    a stage name parent key. In our example, the parent key is `trivy`. The commands
    in the `before_script` section will download the `trivy` binaries:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, review and add the Trivy scan script and complete the `vulTest` stage.
    The following script will return `--exit-code 1` for the critical severity vulnerabilities,
    as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Now, you can run your pipeline and the new stage will be included in your pipeline.
    The pipeline will fail if a critical vulnerability is detected. If you don't want
    the stage to fail your pipeline, you can also specify `--exit-code 0` for critical
    vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Building vulnerability scanning into CircleCI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: CircleCI uses Orbs to wrap predefined examples to speed up your project configurations.
    Currently, Trivy doesn't have a CircleCI Orb, but it is still easy to configure
    Trivy with CircleCI. This recipe will take you through adding a test stage to
    the CircleCI pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s perform the following steps to add Trivy vulnerability checks in CircleCI:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the CircleCI configuration file located in our project repository in `.circleci/config.yml`. You
    can find our example in the `src/chapter9/devsecops` directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Start by adding the job and the image. In this recipe, the job name is `build`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Start adding the steps to build your image. The `checkout` step will checkout
    the project from its code repository. Since our job will require docker commands,
    add `setup_remote_docker`. When this step is executed, a remote environment will
    be created and your current primary container will be configured appropriately:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the necessary step to install Trivy:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the step that will scan a local image with Trivy. Modify the `trivy` parameters
    and preferred exit codes as needed. Here, `trivy` only checks for critical vulnerabilities
    (`--severity CRITICAL`) and fails if a vulnerability is found (`--exit-code 1`).
    It suppresses the progress bar (`--no-progress`) and refreshes the database automatically
    when updating its version (`--auto-refresh`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, update the workflows to trigger the vulnerability scan:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Now, you can run your pipeline in CircleCI and the new stage will be included
    in your pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Aqua Security Trivy Comparison: [https://github.com/aquasecurity/trivy#comparison-with-other-scanners](https://github.com/aquasecurity/trivy#comparison-with-other-scanners)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Aqua Security Trivy CI examples: [https://github.com/aquasecurity/trivy#comparison-with-other-scanners](https://github.com/aquasecurity/trivy#comparison-with-other-scanners)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Aqua Security Trivy Alternatives for image vulnerability testing:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Aqua Security Microscanner: [https://github.com/aquasecurity/microscanner](https://github.com/aquasecurity/microscanner)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clair: [https://github.com/coreos/clair](https://github.com/coreos/clair)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker Hub: [https://beta.docs.docker.com/v17.12/docker-cloud/builds/image-scan/](https://beta.docs.docker.com/v17.12/docker-cloud/builds/image-scan/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GCR: [https://cloud.google.com/container-registry/docs/container-analysis](https://cloud.google.com/container-registry/docs/container-analysis)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Layered Insight: [https://layeredinsight.com/](https://layeredinsight.com/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NeuVector: [https://neuvector.com/vulnerability-scanning/](https://neuvector.com/vulnerability-scanning/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sysdig Secure: [https://sysdig.com/products/secure/](https://sysdig.com/products/secure/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Quay: [https://coreos.com/quay-enterprise/docs/latest/security-scanning.html](https://coreos.com/quay-enterprise/docs/latest/security-scanning.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Twistlock: [https://www.twistlock.com/platform/vulnerability-management-tools/](https://www.twistlock.com/platform/vulnerability-management-tools/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitoring suspicious application activities using Falco
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Falco is a cloud-native runtime security toolset. Falco gains deep insight into
    system behavior through its runtime rule engine. It is used to detect intrusions
    and abnormalities in applications, containers, hosts, and the Kubernetes orchestrator.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will cover the installation and basic usage of Falco on
    Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Clone the `k8sdevopscookbook/src` repository to your workstation to use the
    manifest files in the `chapter9` directory, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Make sure you have a Kubernetes cluster ready and `kubectl` and `helm` configured
    to manage the cluster resources.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This section will show you how to configure and run Falco. This section is
    further divided into the following subsections to make this process easier:'
  prefs: []
  type: TYPE_NORMAL
- en: Installing Falco on Kubernetes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detecting anomalies using Falco
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining custom rules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing Falco on Kubernetes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Falco can be installed in various ways, including directly on Linux hosts by
    deploying Falco as a DaemonSet or by using Helm. This recipe will show you how
    to install Falco as a DaemonSet.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s perform the following steps to get Falco deployed on our cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Clone the Falco repository into your current working directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a Service Account for Falco. The following command will also create
    the ClusterRole and ClusterRoleBinding for it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a service using the following command from the cloned repository location:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `config` directory and copy the deployment configuration file and
    rule files in the `config` directory. We will need to edit these later:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a ConfigMap using the config files in the `config/` directory. Later,
    the DaemonSet will make the configuration available to Falco pods using the ConfigMap:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, deploy Falco using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Verify that the DaemonSet pods have been successfully created. You should see
    one pod per schedulable worker node on the cluster. In our example, we used a
    Kubernetes cluster with four worker nodes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: With that, Falco has been deployed and started monitoring behavioral activity
    to detect anomalous activities in our applications on our nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting anomalies using Falco
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Falco detects a variety of suspicious behavior. In this recipe, we will produce
    some activities that would be suspicious on a normal production cluster.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s perform the following steps to produce activities that would trigger
    a syscall event drop:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to review the full rules before we test some of the behaviors.
    Falco has two rules files. The default rules are located at `/etc/falco/falco_rules.yaml`,
    while the local rules file is located at `/etc/falco/falco_rules.local.yaml`.
    Your custom rules and modifications should be in the `falco_rules.local.yaml`
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see a long list of default rules and macros. Some of them are as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s test that Falco is working by getting a bash shell into one of the Falco
    pods and view the logs afterward. List the Falco pods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Get bash shell access to one of the Falco pods from the output of the preceding
    command and view the logs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'In the logs, you will see that Falco detects our shell access to the pods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: With that, you've learned how to use Falco to detect anomalies and suspicious
    behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Defining custom rules
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Falco rules can be extended by adding our own rules. In this recipe, we will
    deploy a simple application and create a new rule to detect a malicious application
    accessing our database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps to create an application and define custom rules
    for Falco:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Change to the `src/chapter9/falco` directory, which is where our examples are
    located:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new `falcotest` namespace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Review the YAML manifest and deploy them using the following commands. These
    commands will create a MySQL pod, web application, a client that we will use to
    ping the application, and its services:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, use the client pod with the default credentials of `bob/foobar` to send
    a ping to our application. As expected, we will be able to authenticate and complete
    the task successfully:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'Edit the `falco_rules.local.yaml` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following rule to the end of the file and save it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the ConfigMap that''s being used for the DaemonSet and delete the pods
    to get a new configuration by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'We will execute a SQL injection attack and access the file where our MySQL
    credentials are stored. Our new custom rule should be able to detect it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command will return the content of the PHP file. You will be
    able to find the MySQL credentials there:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'List the Falco pods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'View the logs from a Falco pod:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'In the logs, you will see that Falco detects our shell access to the pods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: With that, you know how to add custom rules using Kubernetes metadata such as `k8s.ns.name`
    and `k8s.deployment.name`. You can also use other filters. This is described in
    more detail in the *Supported filters* link in *See also* section.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe showed you how to detect anomalies based on the predefined and custom
    rules of your applications when they're running on Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: In the *Installing Falco on Kubernetes* recipe, in *Step 5,* we created a ConfigMap
    to be used by the Falco pods. Falco has two types of rules files.
  prefs: []
  type: TYPE_NORMAL
- en: In Step 6, when we created the DaemonSet, all the default rules are provided
    through the `falco_rules.yaml` file in the ConfigMap.These are placed in `/etc/falco/falco_rules.yaml`
    inside the pods, while the local rules file ,  `falco_rules.local.yaml,` can be
    found at `/etc/falco/falco_rules.local.yaml`.
  prefs: []
  type: TYPE_NORMAL
- en: The default rules file contains rules for many common anomalies and threats.
    All pieces of customization must be added to the `falco_rules.local.yaml` file,
    which we did in the *Defining custom rules* recipe*.*
  prefs: []
  type: TYPE_NORMAL
- en: 'In the *Defining custom rules r*ecipe, in *Step 6*, we created a custom rule
    file containing the `rules` element. The Falco rule file is a YAML file that uses
    three kinds of elements: `rules`, `macros`, and `lists`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The rules define certain conditions to send alerts about them. A rule is a
    file that contains at least the following keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '`rule`: The name of the rule'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`condition`: An expression that''s applied to events to check if they match
    the rule'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`desc`: Detailed description of what the rule is used for'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`output`: The message that is displayed to the user'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`priority`: Either emergency, alert, critical, error, warning, notice, informational,
    or debug'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can find out more about these rules by going to the *Understanding Falco
    Rules* link that's provided in the *See also* section.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Falco documentation: [https://falco.org/docs/](https://falco.org/docs/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Falco repository and integration examples: [https://github.com/falcosecurity/falco](https://github.com/falcosecurity/falco)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding Falco Rules:[ https://falco.org/dochttps://falco.org/docs/rules/s/rules/](https://falco.org/dochttps://falco.org/docs/rules/s/rules/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparing Falco with other tools: [https://sysdig.com/blog/selinux-seccomp-falco-technical-discussion/](https://sysdig.com/blog/selinux-seccomp-falco-technical-discussion/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Supported filters: [https://github.com/draios/sysdig/wiki/Sysdig-User-Guide#all-supported-filters](https://github.com/draios/sysdig/wiki/Sysdig-User-Guide#all-supported-filters)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Securing credentials using HashiCorp Vault
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: HashiCorp Vault is a popular tool for securely storing and accessing secrets
    such as credentials, API keys, and certificates. Vault provides secure secret
    storage, on-demand dynamic secrets, data encryption, and support for secret revocation.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will cover the installation and basic use case of accessing
    and storing secrets for Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Clone the `k8sdevopscookbook/src` repository to your workstation to use the
    manifest files in the `chapter9` directory, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: Make sure you have a Kubernetes cluster ready and `kubectl` and `helm` configured
    to manage the cluster resources.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This section is further divided into the following subsections to make this
    process easier:'
  prefs: []
  type: TYPE_NORMAL
- en: Installing Vault on Kubernetes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing the Vault UI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing credentials on Vault
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing Vault on Kubernetes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This recipe will show you how to get a Vault service on Kubernetes. Let''s
    perform the following steps to get Vault installed using Helm charts:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Clone the chart repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'Check out the latest stable release:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'If you would like to install a highly available Vault, skip to *Step 4*; otherwise,
    install the standalone version using the Helm chart parameters shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'To deploy a highly available version that uses an HA storage backend such as
    Consul, use the following Helm chart parameters. This will deploy Vault using
    a StatefulSet with three replicas:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'Verify the status of the pods. You will notice that the pods aren''t ready
    since the readiness probe requires Vault to be initialized first:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'Check the initialization status. It should be `false`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'Initialize the Vault instance. The following command will return an unseal
    key and root token:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'Unseal Vault using the unseal key from the output of the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'Verify the pod''s status. You will see that the readiness probe has been validated
    and that the pod is ready:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: Vault is ready to be used after it is initialized. Now, you know how to get
    Vault running on Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing the Vault UI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'By default, the Vault UI is enabled when using a Helm chart installation. Let''s
    perform the following steps to access the Vault UI:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Since access to Vault is a security concern, it is not recommended to expose
    it with a service. Use port-forwarding to access the Vault UI using the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'Once forwarding is complete, you can access the UI at `http://localhost:8200`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/1b504490-441c-4b87-9a8f-a44ab9159dc2.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, you have access to the web UI. Take the Vault Web UI tour to familiarize
    yourself with its functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Storing credentials on Vault
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This recipe will show you how to use Vault in Kubernetes and retrieve secrets
    from Vault.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s perform the following steps to enable the Kubernetes authentication
    method in Vault:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Log in to Vault using your token:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'Write a secret to Vault:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s configure Vault''s Kubernetes authentication backend. First, create
    a ServiceAccount:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a RoleBinding for the `vault-k8s` ServiceAccount:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'Get the token:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'Enable the Kubernetes auth backend in the vault:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new policy called `vault-policy` from the example repository using
    the `policy.hcl`: file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create a Role for the ServiceAccount:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'Authenticate with the Role by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'Log in to the Vault with the token by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a secret at the `secret/demo` path:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: With that, you've learned how to create a Kubernetes auth backend with Vault
    and use Vault to store Kubernetes secrets.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Hashicorp Vault documentation: [https://www.vaultproject.io/docs/](https://www.vaultproject.io/docs/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hashicorp Vault repository: [https://github.com/hashicorp/vault-helm ](https://github.com/hashicorp/vault-helm)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hands-on with Vault on Kubernetes: [https://github.com/hashicorp/hands-on-with-vault-on-kubernetes](https://github.com/hashicorp/hands-on-with-vault-on-kubernetes)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
