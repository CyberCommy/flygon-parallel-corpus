- en: Tools, Frameworks, and Environments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"We become what we behold. We shape our tools and then our tools shape us."'
  prefs: []
  type: TYPE_NORMAL
- en: – Marshall McLuhan
  prefs: []
  type: TYPE_NORMAL
- en: As every soldier knows his weapons, a programmer must be familiar with the development
    ecosystem and those tools that make programming much easier. Whether you are already
    using any of these tools at work or home, it is worth taking a look at many of
    them and comparing their features, advantages, and disadvantages. Let's get an
    overview of what we can find nowadays about the following topics and construct
    a small project to get familiar with some of them.
  prefs: []
  type: TYPE_NORMAL
- en: We won't go into the details of those tools and frameworks, since that will
    be done later on in the following chapters. The goal is to get you up and running,
    and provide you with a short overview of what they do and how.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Git
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Virtual machines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The integrated development environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit testing frameworks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hamcrest and AssertJ
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code coverage tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mocking frameworks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User interface testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Behavior-driven development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Git
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Git is the most popular revision control system. For that reason, all the code
    used in this book is stored in Bitbucket ([https://bitbucket.org/](https://bitbucket.org/)).
    If you don't have it already, install Git. Distributions for all the popular operating
    systems can be found at: [http://git-scm.com](http://git-scm.com).
  prefs: []
  type: TYPE_NORMAL
- en: Many graphical interfaces are available for Git; some of them being Tortoise
    ([https://code.google.com/p/tortoisegit](https://code.google.com/p/tortoisegit)),
    Source Tree ([https://www.sourcetreeapp.com](https://www.sourcetreeapp.com)),
    and Tower ([http://www.git-tower.com/](http://www.git-tower.com/)).
  prefs: []
  type: TYPE_NORMAL
- en: Virtual machines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Even though they are outside the topic of this book, virtual machines are a
    powerful tool and a first-class citizen in a good development environment. They
    provide dynamic and easy-to-use resources in isolated systems so they can be used
    and dropped at the time we need them. This helps developers to focus on their
    tasks instead of wasting their time creating or installing required services from
    scratch. This is the reason why virtual machines have found room in here. We want
    to take advantage of them to keep you focused on the code.
  prefs: []
  type: TYPE_NORMAL
- en: In order to have the same environment no matter the OS you're using, we'll be
    creating virtual machines with Vagrant and deploying required applications with
    Docker. We chose Ubuntu as a base operating system in our examples, just because
    it is a popular, commonly used Unix-like distribution. Most of these technologies
    are platform-independent, but occasionally you won't be able to follow the instructions
    found here because you might be using some other operating system. In that case,
    your task is to find what the differences are between Ubuntu and your operating
    system and act accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Vagrant
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Vagrant is the tool we are going to use for creating the development environment
    stack. It is an easy way to initialize ready-to-go virtual machines with minimum
    effort using preconfigured boxes. All boxes and configurations are placed in one
    file, called the `Vagrant` file.
  prefs: []
  type: TYPE_NORMAL
- en: Here is an example of creating a simple Ubuntu box. We made an extra configuration
    for installing MongoDB using Docker (the usage of Docker will be explained shortly).
    We assume that you have VirtualBox ([https://www.virtualbox.org](https://www.virtualbox.org))
    and Vagrant ([https://www.vagrantup.com](https://www.vagrantup.com)) installed
    on your computer and that you have internet access.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this particular case, we are creating an instance of Ubuntu 64-bits using
    the Ubuntu box (`ubuntu/trusty64`) and specifying that the VM should have 1 GB
    of RAM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Further on, we''re exposing MongoDB''s default port in the Vagrant machine
    and running it using Docker:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Finally, in order to speed up the Vagrant setup, we're caching some resources.
    You should install the plugin called `cachier`. For further information, visit: [https://github.com/fgrehm/vagrant-cachier](https://github.com/fgrehm/vagrant-cachier).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now it''s time to see it working. It usually takes a few minutes to run it
    for the first time because the base box and all the dependencies need to be downloaded
    and installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'When this command is run, you should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/beed715c-3901-41ea-8d2a-97d563266fc0.png)'
  prefs: []
  type: TYPE_IMG
- en: Be patient until the execution is finished. Once done, you'll have a new virtual
    machine with Ubuntu, Docker, and one MongoDB instance up and running. The best
    part is that all this was accomplished with a single command.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see the status of the currently running VM, we can use the `status` argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The virtual machine can be accessed either through `ssh` or by using Vagrant
    commands, as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, to stop the virtual machine, exit from it and run the `vagrant halt`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: For the list of Vagrant boxes or further details about configuring Vagrant,
    visit: [https://www.vagrantup.com](https://www.vagrantup.com).
  prefs: []
  type: TYPE_NORMAL
- en: Docker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once the environment is set, it is time to install the services and the software
    that we need. This can be done using Docker, a simple and portable way to ship
    and run many applications and services in isolated containers. We will use it
    to install the required databases, web servers, and all the other applications
    required throughout this book, in a virtual machine created using Vagrant. In
    fact, the Vagrant VM that was previously created already has an example of getting
    an instance of MongoDB up and running using Docker.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s bring up the VM again (we stopped it previously with the `vagrant halt`
    command) and also MongoDB:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: With `docker start`, we started the container; with `docker ps`, we listed all
    the running processes.
  prefs: []
  type: TYPE_NORMAL
- en: By using this kind of procedure, we are able to reproduce a full-stack environment
    in the blink of an eye. You may be wondering if this is as awesome as it sounds.
    The answer is yes, it is. Vagrant and Docker allow developers to focus on what
    they are supposed to do and forget about complex installations and tricky configurations.
    Furthermore, we made an extra effort to provide you with all the necessary steps
    and resources to reproduce and test all the code examples and demonstrations in
    this book.
  prefs: []
  type: TYPE_NORMAL
- en: Build tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With time, code tends to grow both in complexity and size. This occurs in the
    software industry by its nature. All products evolve constantly and new requirements
    are made and implemented across a product's life. Build tools offer a way to make
    managing the project life cycle as straightforward as possible, by following a
    few code conventions, such as the organization of your code, in a specific way,
    and by the usage of naming a convention for your classes or a determined project
    structure formed by different folders and files.
  prefs: []
  type: TYPE_NORMAL
- en: Some of you might be familiar with Maven or Ant. They are a great couple of
    Swiss army knives for handling projects, but we are here to learn so we decided
    to use Gradle. Some of the advantages of Gradle are its reduced boilerplate code,
    resulting in a much shorter file and a more readable configuration file. Among
    others, Google uses it as its build tool. It is supported by IntelliJ IDEA and
    is quite easy to learn and work with. Most of the functionalities and tasks are
    obtained by adding plugins.
  prefs: []
  type: TYPE_NORMAL
- en: Mastering Gradle is not the goal of this book. So, if you want to learn more
    about this awesome tool, take a tour through its website ([http://gradle.org/](http://gradle.org/))
    and read about the plugins you can use and the options you can customize. For
    a comparison of different Java build tools, visit: [https://technologyconversations.com/2014/06/18/build-tools/](https://technologyconversations.com/2014/06/18/build-tools/).
  prefs: []
  type: TYPE_NORMAL
- en: Before proceeding forward, make sure that Gradle is installed on your system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s analyze the relevant parts of a `build.gradle` file. It holds project
    information in a concise way, using Groovy as the descriptor language. This is
    our project''s build file, autogenerated with IntelliJ:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'A Java plugin is applied since it is a Java project. It brings common Java
    tasks, such as build, package, test, and so on. The source compatibility is set
    to JDK 7\. The compiler will complain if we try to use the Java syntax that is
    not supported by this version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Maven Central ([http://search.maven.org/](http://search.maven.org/)) holds
    all our project dependencies. This section tells Gradle where to pull them from.
    The Maven Central repository is enough for this project, but you can add your
    custom repositories, if any. Nexus and Ivy are also supported:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Last, but not least, this is how project dependencies are declared. IntelliJ
    decided to use JUnit as the testing framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'Gradle tasks are easy to run. For example, to run tests from the command prompt,
    we can simply execute the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This can be accomplished from IDEA by running the `test` task from the Gradle
    Tool Window that can be accessed from View|Tool Windows|Gradle.
  prefs: []
  type: TYPE_NORMAL
- en: The tests result is stored in the HTML files that are located in the `build/reports/tests`
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the test report generated by running `gradle test` against
    the sample code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3faba178-b0f0-487c-bf82-a7656f5e7f51.png)'
  prefs: []
  type: TYPE_IMG
- en: The integrated development environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As many tools and technologies will be covered, we recommend using IntelliJ
    IDEA as the tool for code development. The main reason is that this **integrated
    development environment** (**IDE**) works without any tedious configuration. The
    Community Edition (IntelliJ IDEA CE) comes with a bunch of built-in features and
    plugins that make coding easy and efficient. It automatically recommends plugins
    that can be installed depending on the file extension. As IntelliJ IDEA is the
    choice we made for this book, you will find references and steps referring to
    its actions or menus. Readers should find a proper way to emulate those steps
    if they are using other IDEs. Refer to: [https://www.jetbrains.com/idea/](https://www.jetbrains.com/idea/)
    for instructions on how to download and install IntelliJ IDEA.
  prefs: []
  type: TYPE_NORMAL
- en: The IDEA demo project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's create the base layout of the demo project. This project will be used
    throughout this chapter to illustrate all the topics that are covered. Java will
    be the programming language and Gradle ([http://gradle.org/](http://gradle.org/))
    will be used to run different sets of tasks, such as building, testing, and so
    on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us import into IDEA the repository that contains examples from this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Open IntelliJ IDEA, select Check out from Version Control, and click on Git.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type `https://bitbucket.org/vfarcic/tdd-java-ch02-example-junit.git` in the
    Git repository URL and click on Clone. Confirm for the rest of the IDEA questions
    until a new project is created with code cloned from the Git repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The imported project should look similar to the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4f24bf69-eaa5-4aac-8877-275f383e142f.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that we have got the project set up, it's time to take a look at unit-testing
    frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: Unit-testing frameworks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, two of the most used Java frameworks for unit testing are shown
    and briefly commented on. We will focus on their syntax and main features by comparing
    a test class written using both JUnit and TestNG. Although there are slight differences,
    both frameworks offer the most commonly used functionalities, and the main difference
    is how tests are executed and organized.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with a question. What is a test? How can we define it?
  prefs: []
  type: TYPE_NORMAL
- en: A test is a repeatable process or method that verifies the correct behavior
    of a tested target in a determined situation with a determined input expecting
    a predefined output or interactions.
  prefs: []
  type: TYPE_NORMAL
- en: In the programming approach, there are several types of tests depending on their
    scope—functional tests, acceptance tests, and unit tests. Further on, we will
    explore each of those types of tests in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unit testing is about testing small pieces of code. Let''s see how to test
    a single Java class. The class is quite simple, but enough for our interest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: JUnit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JUnit ([http://junit.org/](http://junit.org/)) is a simple and easy-to-learn
    framework for writing and running tests. Each test is mapped as a method, and
    each method should represent a specific known scenario in which a part of our
    code will be executed. The code verification is made by comparing the expected
    output or behavior with the actual output.
  prefs: []
  type: TYPE_NORMAL
- en: The following is the test class written with JUnit. There are some scenarios
    missing, but for now we are interested in showing what tests look like. We will
    focus on better ways to test our code and on best practices later in this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Test classes usually consist of three stages: set up, test, and tear down.
    Let''s start with methods that set up data needed for tests. A setup can be performed
    on a class or method level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `@BeforeClass` annotation specifies a method that will be run once before
    any of the test methods in the class. It is a useful way to do some general set
    up that will be used by most (if not all) tests.
  prefs: []
  type: TYPE_NORMAL
- en: The `@Before` annotation specifies a method that will be run before each test
    method. We can use it to set up test data without worrying that the tests that
    are run afterwards will change the state of that data. In the preceding example,
    we're instantiating the `Friendships` class and adding five sample entries to
    the `Friendships` list. No matter what changes will be performed by each individual
    test, this data will be recreated over and over until all the tests are performed.
  prefs: []
  type: TYPE_NORMAL
- en: Common examples of usage of those two annotations are the setting up of database
    data, the creation of files needed for tests, and so on. Later on, we'll see how
    external dependencies can and should be avoided using mocks. Nevertheless, functional
    or integration tests might still need those dependencies and the `@Before` and
    `@BeforeClass` annotations are a good way to set them up.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the data is set up, we can proceed with the actual tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we are using a few of the many different types of asserts.
    We're confirming that `Alex` does not have any friends, while `Joe` is a very
    popular guy with five friends (`Audrey`, `Peter`, `Michael`, `Britney`, and `Paul`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, once the tests are finished, we might need to perform some cleanup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In our example, in the `Friendships` class, we have no need to clean up anything.
    If there were such a need, those two annotations would provide that feature. They
    work in a similar fashion to the `@Before` and `@BeforeClass` annotations. `@AfterClass`
    is run once all tests are finished. The `@After` annotation is executed after
    each test. This runs each test method as a separate class instance. As long as
    we are avoiding global variables and external resources, such as databases and
    APIs, each test is isolated from the others. Whatever was done in one, does not
    affect the rest.
  prefs: []
  type: TYPE_NORMAL
- en: The complete source code can be found in the `FriendshipsTest` class at [https://bitbucket.org/vfarcic/tdd-java-ch02-example-junit](https://bitbucket.org/vfarcic/tdd-java-ch02-example-junit).
  prefs: []
  type: TYPE_NORMAL
- en: TestNG
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In TestNG ([http://testng.org/doc/index.html](http://testng.org/doc/index.html)),
    tests are organized in classes, just as in the case of JUnit.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following Gradle configuration (`build.gradle`) is required in order to
    run TestNG tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Unlike JUnit, TestNG requires additional Gradle configuration that tells it
    to use TestNG to run tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following test class is written with TestNG and is a reflection of what
    we did earlier with JUnit. Repeated imports and other boring parts are omitted
    with the intention of focusing on the relevant parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: You probably already noticed the similarities between JUnit and TestNG. Both
    are using annotations to specify what the purposes of certain methods are. Besides
    different names (`@Beforeclass` versus `@BeforeMethod`), there is no difference
    between the two. However, unlike Junit, TestNG reuses the same test class instance
    for all test methods. This means that the test methods are not isolated by default,
    so more care is needed in the `before` and `after` methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Asserts are very similar as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The only notable difference when compared with JUnit is the order of the `assert`
    variables. While the JUnit assert's order of arguments is **optional message**,
    **expected values**, and **actual values**, TestNG's order is an actual value,
    expected value, and optional message. Besides the difference in the order of arguments
    we're passing to the `assert` methods, there are almost no differences between
    JUnit and TestNG.
  prefs: []
  type: TYPE_NORMAL
- en: You might have noticed that `@Test` is missing. TestNG allows us to set it on
    the class level and thus convert all public methods into tests.
  prefs: []
  type: TYPE_NORMAL
- en: The `@After` annotations are also very similar. The only notable difference
    is the TestNG `@AfterMethod` annotation that acts in the same way as the JUnit
    `@After` annotation.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the syntax is pretty similar. Tests are organized in to classes
    and test verifications are made using assertions. That is not to say that there
    are no more important differences between those two frameworks; we'll see some
    of them throughout this book. I invite you to explore JUnit ([http://junit.org/](http://junit.org/))
    and TestNG ([http://testng.org/](http://testng.org/)) by yourself.
  prefs: []
  type: TYPE_NORMAL
- en: The complete source code with the preceding examples can be found at [https://bitbucket.org/vfarcic/tdd-java-ch02-example-testng](https://bitbucket.org/vfarcic/tdd-java-ch02-example-testng).
  prefs: []
  type: TYPE_NORMAL
- en: The assertions we have written until now have used only the testing frameworks.
    However, there are some test utilities that can help us make them nicer and more
    readable.
  prefs: []
  type: TYPE_NORMAL
- en: Hamcrest and AssertJ
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we gave an overview of what a unit test is and how
    it can be written using two of the most commonly used Java frameworks. Since tests
    are an important part of our projects, why not improve the way we write them?
    Some cool projects emerged, aiming to empower the semantics of tests by changing
    the way that assertions are made. As a result, tests are more concise and easier
    to understand.
  prefs: []
  type: TYPE_NORMAL
- en: Hamcrest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Hamcrest** adds a lot of methods called **matchers**. Each matcher is designed
    to perform a comparison operation. It is extensible enough to support custom matchers
    created by yourself. Furthermore, JUnit supports Hamcrest natively since its core
    is included in the JUnit distribution. You can start using Hamcrest effortlessly.
    However, we want to use the full-featured project so we will add a test dependency
    to Gradle''s file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us compare one assert from JUnit with the equivalent one from Hamcrest:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The JUnit `assert`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The Hamcrest `assert`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, Hamcrest is a bit more expressive. It has a much bigger range
    of asserts that allows us to avoid some boilerplate code and, at the same time,
    makes code easier to read and is more expressive.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s another example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'JUnit `assert`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Hamcrest `assert`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: You'll notice two differences. The first is that, unlike JUnit, Hamcrest works
    almost always with direct objects. While in the case of JUnit, we needed to get
    the integer size and compare it with the expected number (`5`); Hamcrest has a
    bigger range of asserts so we can simply use one of them (`hasSize`) together
    with the actual object (`List`). Another difference is that Hamcrest has the inverse
    order with the actual value being the first argument (like TestNG).
  prefs: []
  type: TYPE_NORMAL
- en: Those two examples are not enough to show the full potential offered by Hamcrest.
    Later on in this book, there will be more examples and explanations of Hamcrest.
    Visit [http://hamcrest.org/](http://hamcrest.org/) and explore its syntax.
  prefs: []
  type: TYPE_NORMAL
- en: The complete source code can be found in the `FriendshipsHamcrestTest` class
    in the [https://bitbucket.org/vfarcic/tdd-java-ch02-example-junit](https://bitbucket.org/vfarcic/tdd-java-ch02-example-junit)
    repositories.
  prefs: []
  type: TYPE_NORMAL
- en: AssertJ
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**AssertJ** works in a similar way to Hamcrest. A major difference is that
    AssertJ assertions can be concatenated.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To work with AssertJ, the dependency must be added to Gradle''s dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s compare JUnit asserts with AssertJ:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The same two asserts can be concatenated to a single one in AssertJ:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This was a nice improvement. There was no need to have two separate asserts,
    nor was there a need to create a new list with expected values. Moreover, AssertJ
    is more readable and easier to understand.
  prefs: []
  type: TYPE_NORMAL
- en: The complete source code can be found in the `FriendshipsAssertJTest` class
    at [https://bitbucket.org/vfarcic/tdd-java-ch02-example-junit](https://bitbucket.org/vfarcic/tdd-java-ch02-example-junit).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the tests up and running, we might want to see what the code
    coverage is that is generated by our tests.
  prefs: []
  type: TYPE_NORMAL
- en: Code coverage tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The fact that we wrote tests does not mean that they are good, nor that they
    cover enough code. As soon as we start writing and running tests, the natural
    reaction is to start asking questions that were not available before. What parts
    of our code are properly tested? What are the cases that our tests did not take
    into account? Are we testing enough? These and other similar questions can be
    answered with code coverage tools. They can be used to identify the blocks or
    lines of code that were not covered by our tests; they can also calculate the
    percentage of code covered and provide other interesting metrics.
  prefs: []
  type: TYPE_NORMAL
- en: They are powerful tools used to obtain metrics and show relations between tests
    and implementation code. However, as with any other tool, their purpose needs
    to be clear. They do not provide information about quality, but only about which
    parts of our code have been tested.
  prefs: []
  type: TYPE_NORMAL
- en: Code coverage shows whether the code lines are reached during test execution,
    but it is not a guarantee of good testing practices because test quality is not
    included in these metrics.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at one of the most popular tools used to calculate code coverage.
  prefs: []
  type: TYPE_NORMAL
- en: JaCoCo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Java Code Coverage (JaCoCo) is a well-known tool for measuring test coverage.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use it in our project, we need to add a few lines to our Gradle configuration
    file, that is, `build.gradle`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the Gradle `plugin` for JaCoCo:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'To see the JaCoCo results, run the following from your command prompt:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The same Gradle tasks can be run from the Gradle Tasks IDEA Tool Window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The end result is stored in the `build/reports/jacoco/test/html` directory.
    It''s an HTML file that can be opened in any browser:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/2d6b19f8-0fbc-4101-88d0-46a046cd900a.png)'
  prefs: []
  type: TYPE_IMG
- en: Further chapters of this book will explore code coverage in more detail. Until
    then, go to [http://www.eclemma.org/jacoco/](http://www.eclemma.org/jacoco/) for
    more information.
  prefs: []
  type: TYPE_NORMAL
- en: Mocking frameworks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our project looks cool, but it's too simple and it is far from being a real
    project. It still doesn't use external resources. A database is required by Java
    projects so we'll try to introduce it, as well.
  prefs: []
  type: TYPE_NORMAL
- en: What is the common way to test code that uses external resources or third-party
    libraries? Mocks are the answer. A mock object, or simply a mock, is a simulated
    object that can be used to replace real ones. They are very useful when objects
    that depend on external resources are deprived of them.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, you don't need a database at all while you are developing the application.
    Instead, you can use mocks to speed up development and testing and use a real
    database connection only at runtime. Instead of spending time setting up a database
    and preparing test data, we can focus on writing classes and think about them
    later on during integration time.
  prefs: []
  type: TYPE_NORMAL
- en: 'For demonstration purposes, we''ll introduce two new classes: the `Person`
    class and the `FriendCollection` class that are designed to represent persons
    and database object mapping. Persistence will be done with MongoDB ([https://www.mongodb.org/](https://www.mongodb.org/)).'
  prefs: []
  type: TYPE_NORMAL
- en: Our sample will have two classes. `Person` will represent database object data;
    `FriendCollection` will be our data access layer. The code is, hopefully, self-explanatory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create and use the `Person` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create and use the `FriendsCollection` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In addition, some new dependencies have been introduced so the Gradle dependencies
    block needs to be modified, as well. The first one is the MongoDB driver, which
    is required to connect to the database. The second is Jongo, a small project that
    makes accessing Mongo collections pretty straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Gradle dependencies for `mongodb` and `jongo` are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We are using a database so the `Friendships` class should also be modified.
    We should change a map to `FriendsCollection` and modify the rest of the code
    to use it. The end result is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The complete source code can be found in the `FriendsCollection` and `FriendshipsMongo`
    classes in the [https://bitbucket.org/vfarcic/tdd-java-ch02-example-junit](https://bitbucket.org/vfarcic/tdd-java-ch02-example-junit)
    repository.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our `Friendships` class working with MongoDB, let's take a
    look at one possible way to test it by using mocks.
  prefs: []
  type: TYPE_NORMAL
- en: Mockito
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mockito is a Java framework that allows easy creation of the test double.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Gradle dependency is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Mockito runs through the JUnit runner. It creates all the required mocks for
    us and injects them into the class with tests. There are two basic approaches;
    instantiating mocks by ourselves and injecting them as class dependencies via
    a class constructor or using a set of annotations. In the next example, we are
    going to see how it is done using annotations.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order for a class to use Mockito annotations, it needs to be run with `MockitoJUnitRunner`.
    Using the runner simplifies the process because you just simply add annotations
    to objects to be created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'In your test class, the tested class should be annotated with `@InjectMocks`.
    This tells Mockito which class to inject mocks into:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'From then on, we can specify which specific methods or objects inside the class,
    in this case `FriendshipsMongo`, will be substituted with mocks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: In this example, `FriendsCollection` inside the `FriendshipsMongo` class will
    be mocked.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can specify what should be returned when `friends` is invoked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we're telling Mockito to return the `joe` object whenever `friends.findByName("Joe")`
    is invoked. Later on, we're verifying with `assertThat` that this assumption is
    correct.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try to do the same test as we did previously in the class that was without
    MongoDB:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: A lot of things happened in this small test. First, we're specifying that `joe`
    is a spy. In Mockito, spies are real objects that use real methods unless specified
    otherwise. Then, we're telling Mockito to return `joe` when the `friends` method
    calls `getFriends`. This combination allows us to return the `expected` list when
    the `getFriends` method is invoked. Finally, we're asserting that the `getFriendsList`
    returns the expected list of names.
  prefs: []
  type: TYPE_NORMAL
- en: The complete source code can be found in the `FriendshipsMongoAssertJTest` class
    in the [https://bitbucket.org/vfarcic/tdd-java-ch02-example-junit](https://bitbucket.org/vfarcic/tdd-java-ch02-example-junit) repository.
  prefs: []
  type: TYPE_NORMAL
- en: We'll use Mockito later on; throughout this book, you'll get your chance to
    become more familiar with it and with mocking in general. More information about
    Mockito can be found at [http://mockito.org/](http://mockito.org/).
  prefs: []
  type: TYPE_NORMAL
- en: EasyMock
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: EasyMock is an alternative mocking framework. It is very similar to Mockito.
    However, the main difference is that EasyMock does not create `spy` objects but
    mocks. Other differences are syntactical.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see an example of EasyMock. We''ll use the same set of test cases as
    those that were used for the Mockito examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Essentially, the runner does the same as the Mockito runner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The `@TestSubject` annotation is similar to Mockito's `@InjectMocks`, while
    the `@Mock` annotation denotes an object to be mocked in a similar fashion to
    Mockito's `@Mock`. Furthermore, the type `NICE` tells the mock to return empty.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s compare one of the asserts we did with Mockito:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Besides small differences in syntax, the only disadvantage of EasyMock is that
    the additional instruction `replay` was needed. It tells the framework that the
    previously specified expectation should be applied. The rest is almost the same.
    We're specifying that `friends.findByName` should return the `joe` object, applying
    that expectation and, finally, asserting whether the actual result is as expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the EasyMock version, the second test method that we used with Mockito is
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Again, there are almost no differences when compared to Mockito, except that
    EasyMock does not have spies. Depending on the context, that might be an important
    difference.
  prefs: []
  type: TYPE_NORMAL
- en: Even though both frameworks are similar, there are small details that make us
    choose Mockito as a framework, which will be used throughout this book.
  prefs: []
  type: TYPE_NORMAL
- en: Visit [http://easymock.org/](http://easymock.org/) for more information about
    this asserts library.
  prefs: []
  type: TYPE_NORMAL
- en: The complete source code can be found in the `FriendshipsMongoEasyMockTest`
    class in the [https://bitbucket.org/vfarcic/tdd-java-ch02-example-junit](https://bitbucket.org/vfarcic/tdd-java-ch02-example-junit) repository.
  prefs: []
  type: TYPE_NORMAL
- en: Extra power for mocks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Both projects introduced earlier do not cover all types of methods or fields.
    Depending on the applied modifiers, such as static or final, a class, method,
    or field, can be out of range for Mockito or EasyMock. In such cases, we can use
    PowerMock to extend the mocking framework. This way, we can mock objects that
    can only be mocked in a tricky manner. However, one should be cautious with PowerMock
    since the necessity to use many of the features it provides is usually a sign
    of poor design. If you're working on a legacy code, PowerMock might be a good
    choice. Otherwise, try to design your code in such a way that PowerMock is not
    needed. We'll show you how to do that later on.
  prefs: []
  type: TYPE_NORMAL
- en: For more information, visit [https://code.google.com/p/powermock/](https://code.google.com/p/powermock/).
  prefs: []
  type: TYPE_NORMAL
- en: User interface testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Even though unit testing can and should cover the major part of the application,
    there is still a need to work on functional and acceptance tests. Unlike unit
    tests, they provide higher-level verifications, and are usually performed at entry
    points, and rely heavily on user interfaces. At the end, we are creating applications
    that are, in most cases, used by humans, so being confident of our application's
    behavior is very important. This comfort status can be achieved by testing what
    the application is expected to do, from the point of view of real users.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we'll try to provide an overview of functional and acceptance testing
    through a user interface. We'll use the web as an example, even though there are
    many other types of user interfaces, such as desktop applications, smartphone
    interfaces, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Web-testing frameworks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The application classes and data sources have been tested throughout this chapter,
    but there is still something missing; the most common user entry point—the web.
    Most enterprise applications such as intranets or corporate sites are accessed
    using a browser. For this reason, testing the web provides significant value,
    helping us to make sure that it is doing what it is expected to do.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, companies are investing a lot of time performing long and heavy
    manual tests every time the application changes. This is a big waste of time since
    a lot of those tests can be automatized and executed without supervision, using
    tools such as Selenium or Selenide.
  prefs: []
  type: TYPE_NORMAL
- en: Selenium
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Selenium is a great tool for web testing. It uses a browser to run verifications
    and it can handle all the popular browsers, such as Firefox, Safari, and Chrome.
    It also supports headless browsers to test web pages with much greater speed and
    less resources consumption.
  prefs: []
  type: TYPE_NORMAL
- en: There is a `SeleniumIDE` plugin that can be used to create tests by recording
    actions performed by the user. Currently, it is only supported by Firefox. Sadly,
    even though tests generated this way provide very fast results, they tend to be
    very brittle and cause problems in the long run, especially when some part of
    a page changes. For this reason, we'll stick with the code written without the
    help from that plugin.
  prefs: []
  type: TYPE_NORMAL
- en: The simplest way to execute Selenium is to run it through `JUnitRunner`.
  prefs: []
  type: TYPE_NORMAL
- en: 'All Selenium tests start by initializing `WebDriver`, the class used for communication
    with browsers:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by adding the Gradle dependency:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'As an example, we''ll create a test that searches Wikipedia. We''ll use a Firefox
    driver as our browser of choice:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '`WebDriver` is an interface that can be instantiated with one of the many drivers
    provided by Selenium:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To open a URL, the instruction would be the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the page is opened, we can search for an input element by its name and
    then type some text:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we type our search query, we should find and click the Go button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we reach our destination, it is time to validate that, in this case, the
    page title is correct:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the `driver` should be closed once we''re finished using it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: That's it. We have a small but valuable test that verifies a single use case.
    While
  prefs: []
  type: TYPE_NORMAL
- en: there is much more to be said about Selenium, hopefully, this has provided you
  prefs: []
  type: TYPE_NORMAL
- en: with enough information to realize the potential behind it.
  prefs: []
  type: TYPE_NORMAL
- en: Visit [http://www.seleniumhq.org/](http://www.seleniumhq.org/) for further information
    and more complex uses of `WebDriver`.
  prefs: []
  type: TYPE_NORMAL
- en: The complete source code can be found in the `SeleniumTest` class in the [https://bitbucket.org/vfarcic/tdd-java-ch02-example-web](https://bitbucket.org/vfarcic/tdd-java-ch02-example-web) repository.
  prefs: []
  type: TYPE_NORMAL
- en: While Selenium is the most commonly used framework to work with browsers, it
    is still very low-level and requires a lot of tweaking. Selenide was born out
    of the idea that Selenium would be much more useful if there was a higher-level
    library that could implement some of the common patterns and solve often-repeated
    needs.
  prefs: []
  type: TYPE_NORMAL
- en: Selenide
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What we have seen about Selenium is very cool. It brings the opportunity to
    probe that our application is doing things well, but sometimes it is a bit tricky
    to configure and use. Selenide is a project based on Selenium that offers a good
    syntax for writing tests and makes them more readable. It hides the usage of `WebDriver`
    and configurations from you, while still maintaining a high-level of customization:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Like all the other libraries we have used until now, the first step is to add
    the Gradle dependency:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Let's see how we can write the previous Selenium test using Selenide
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'instead. The syntax might be familiar to for those who know JQuery ([https://jquery.com/](https://jquery.com/)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: This was a more expressive way to write a test. On top of a more fluent syntax,
    there are some things that happen behind this code and would require additional
    lines of Selenium. For example, a click action will wait until an element in question
    is available, and will fail only if the predefined period of time has expired.
    Selenium, on the other hand, would fail immediately. In today's world, with many
    elements being loaded dynamically through JavaScript, we cannot expect everything
    to appear at once. Hence, this Selenide feature proves to be useful and saves
    us from using repetitive boilerplate code. There are many other benefits Selenide
    brings to the table. Due to the benefits that Selenide provides when compared
    with Selenium, it will be our framework of choice throughout this book. Furthermore,
    there is a whole chapter dedicated to web testing using this framework. Visit [http://selenide.org/](http://selenide.org/)
    for more information on ways to use web drivers in your tests.
  prefs: []
  type: TYPE_NORMAL
- en: No matter whether tests were written with one framework or another, the effect
    is the same. When tests are run, a Firefox browser window will emerge and execute
    all steps defined in the test sequentially. Unless a headless browser was chosen
    as your driver of choice, you will be able to see what is going on throughout
    the test. If something goes wrong, a failure trace is available. On top of that,
    we can take browser screenshots at any point. For example, it is a common practice
    to record the situation at the time of a failure.
  prefs: []
  type: TYPE_NORMAL
- en: The complete source code can be found in the `SelenideTest` class in the
  prefs: []
  type: TYPE_NORMAL
- en: '[https://bitbucket.org/vfarcic/tdd-java-ch02-example-web](https://bitbucket.org/vfarcic/tdd-java-ch02-example-web)
    repository.'
  prefs: []
  type: TYPE_NORMAL
- en: Armed with a basic knowledge of web-testing frameworks, it is time to take a
    short look at BDD.
  prefs: []
  type: TYPE_NORMAL
- en: Behavior-driven development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Behavior-driven development** (**BDD**) is an agile process designed to keep
    the focus on stakeholder value throughout the whole project. The premise of BDD
    is that the requirement has to be written in a way that everyone, be it the business
    representative, analyst, developer, tester, manager, and so on, understands it.
    The key is to have a unique set of artifacts that are understood and used by everyone—a
    collection of user stories. Stories are written by the whole team and used as
    both requirements and executable test cases. It is a way to perform TDD with a
    clarity that cannot be accomplished with unit testing. It is a way to describe
    and test functionality in (almost) natural language and make it runnable and repeatable.'
  prefs: []
  type: TYPE_NORMAL
- en: A story is composed of scenarios. Each scenario represents a concise behavioral
    use case and is written in natural language using steps. Steps are a sequence
    of the preconditions, events, and outcomes of a scenario. Each step must start
    with the words `Given`, `When`, or `Then`. `Given` is for preconditions, `When`
    is for actions, and `Then` is for performing validations.
  prefs: []
  type: TYPE_NORMAL
- en: This was only a brief introduction. There is a whole chapter, [Chapter 8](bc95db7c-af59-4643-9f40-b004910ac22f.xhtml),
    *BDD – Working Together with the Whole Team*, dedicated to this topic. Now it
    is time to introduce JBehave and Cucumber as two of the many available frameworks
    for writing and executing stories.
  prefs: []
  type: TYPE_NORMAL
- en: JBehave
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'JBehave is a Java BDD framework used for writing acceptance tests that are
    able to be executed and automated. The steps used in stories are bound to Java
    code through several annotations provided by the framework:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, add JBehave to Gradle dependencies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s go through a few example steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the `Given` type of step. It represents a precondition that needs to
    be fulfilled for some actions to be performed successfully. In this particular
    case, it will open a Wikipedia page. Now that we have our precondition specified,
    it is time to define some actions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, actions are defined with the `When` annotation. In our case,
    we can use those steps to set some value to a field or click on a specific button.
    Once actions are performed, we can deal with validations. Note
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'that steps can be more flexible by introducing parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Validations are declared using the `Then` annotation. In this example, we are
    validating the page title as expected.
  prefs: []
  type: TYPE_NORMAL
- en: These steps can be found in the `WebSteps` class in the [https://bitbucket.org/vfarcic/tdd-java-ch02-example-web](https://bitbucket.org/vfarcic/tdd-java-ch02-example-web)
    repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have defined our steps, it is time to use them. The following story
    combines those steps in order to validate a desired behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'It starts with naming the scenario. The name should be as concise as possible,
    but enough to identify the user case unequivocally; it is for informative purposes
    only:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we are using the same steps text that we defined earlier. The
    code related to those steps will be executed in a sequential order. If any of
    them are halted, the execution is halted and the scenario itself is considered
    failed.
  prefs: []
  type: TYPE_NORMAL
- en: Even though we defined our steps ahead of stories, it can be done the other
    way around with a story being defined first and the steps following. In that case,
    the status of a scenario would be pending, meaning that the required steps are
    missing.
  prefs: []
  type: TYPE_NORMAL
- en: This story can be found in the `wikipediaSearch.story` file in the [https://bitbucket.org/vfarcic/tdd-java-ch02-example-web](https://bitbucket.org/vfarcic/tdd-java-ch02-example-web)
    repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run this story, execute the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'While the story is running, we can see that actions are taking place in the
    browser. Once it is finished, a report with the results of an execution is generated.
    It can be found in `build/reports/jbehave`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dca745ce-04ef-448e-a573-18d765ad28e2.png)'
  prefs: []
  type: TYPE_IMG
- en: JBehave story execution report
  prefs: []
  type: TYPE_NORMAL
- en: For brevity, we excluded the `build.gradle` code to run JBehave stories. The
    completed source code can be found in the [https://bitbucket.org/vfarcic/tdd-java-ch02-example-web](https://bitbucket.org/vfarcic/tdd-java-ch02-example-web)
    repository.
  prefs: []
  type: TYPE_NORMAL
- en: For further information on JBehave and its benefits, visit [http://jbehave.org/](http://jbehave.org/).
  prefs: []
  type: TYPE_NORMAL
- en: Cucumber
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cucumber was originally a Ruby BDD framework. These days it supports several
    languages including Java. It provides functionality that is very similar to JBehave.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see the same examples written in Cucumber.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same as any other dependency we have used until now, Cucumber needs to
    be added to `build.gradle` before we can start using it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'We will create the same steps as we did with JBehave, using the Cucumber way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: The only noticeable difference between these two frameworks is the way Cucumber
    defines steps text. It uses regular expressions to match variables types, unlike
    JBehave which deduces them from a method signature.
  prefs: []
  type: TYPE_NORMAL
- en: 'The steps code can be found in the `WebSteps` class in the [https://bitbucket.org/vfarcic/tdd-java-ch02-example-web](https://bitbucket.org/vfarcic/tdd-java-ch02-example-web)
    repository:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how the story looks when written using the Cucumber syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Note that there are almost no differences. This story can be found in the `wikipediaSearch.feature`
    file in the [https://bitbucket.org/vfarcic/tdd-java-ch02-example-web](https://bitbucket.org/vfarcic/tdd-java-ch02-example-web)
    repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you might have guessed, to run a Cucumber story, all you need to do is run
    the following Gradle task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The result reports are located in the `build/reports/cucumber-report` directory.
    This is the report for the preceding story:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00ef22c3-dab2-47a2-a9b5-9677e2487c12.png)'
  prefs: []
  type: TYPE_IMG
- en: Cucumber story execution report
  prefs: []
  type: TYPE_NORMAL
- en: The full code example can be found in the [https://bitbucket.org/vfarcic/tdd-java-ch02-example-web](https://bitbucket.org/vfarcic/tdd-java-ch02-example-web)
    repository.
  prefs: []
  type: TYPE_NORMAL
- en: For a list of languages supported by Cucumber or for any other details, visit [https://cukes.info/](https://cukes.info/).
  prefs: []
  type: TYPE_NORMAL
- en: Since both JBehave and Cucumber offer a similar set of features, we decided
    to use JBehave throughout the rest of this book. There is a whole chapter dedicated
    to BDD and JBehave.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we took a break from TDD and introduced many tools and frameworks
    that will be used for code demonstrations in the rest of the chapters. We set
    up everything from version control, virtual machines, building tools, and IDEs,
    until we reached frameworks that are commonly used as today's testing tools.
  prefs: []
  type: TYPE_NORMAL
- en: We are big proponents of the open source movement. Following this spirit, we
    made a special effort to select free tools and frameworks in every category.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have set up all the tools that we will need, in the next chapter,
    we will go deeper into TDD, starting with the Red-Green-Refactor procedure-TDD's
    cornerstone.
  prefs: []
  type: TYPE_NORMAL
