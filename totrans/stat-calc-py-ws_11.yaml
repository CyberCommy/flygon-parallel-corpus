- en: 11\. More Calculus with Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn how to calculate the length of a curve, given
    its equation. You'll be introduced to partial derivatives in three dimensions
    and how to use them to calculate the area of a surface. Following in the footsteps
    of the mathematicians of the Middle Ages, you'll use an infinite series to calculate
    constants such as pi and determine the interval of convergence of a series. Like
    the mathematicians and machine learning engineers of the modern day, you'll learn
    how to find the minimum point on a surface using partial derivatives. By the end
    of this chapter, you will be able to use calculus to solve a variety of mathematical
    problems.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, we learned how to calculate derivatives and integrals.
    Now, we''re going to use those tools to find the lengths of curves and spirals
    and extend this reasoning to three dimensions to find the area of a complicated
    surface. We''ll also look at a common tool that''s used in calculus, the infinite
    series, which is used to calculate important constants and approximate complicated
    functions. Finally, we''ll look at an important idea in machine learning: finding
    the minimum point on a curve. When you use a neural network, you create a kind
    of "error function" and work hard to find the point on the surface that gives
    the minimum error. We''ll create our own kind of gradient descent function to
    keep traveling downward until we''re at the bottom of the surface.'
  prefs: []
  type: TYPE_NORMAL
- en: Length of a Curve
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A major use of derivatives and integrals is finding the length of a curve.
    There''s a formula for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.1: Formula to calculate the length of a curve'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_11_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.1: Formula to calculate the length of a curve'
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding formula contains an integral *and* a derivative. To find the
    length of a curve, we''ll need both our derivative and integral functions. Copy
    and paste them into your code if you don''t have them yet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the Python version of the formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Notice we simply converted the math notation into Python code. We defined the
    `g` function inside the `f` function. The `g` function is everything under the
    square root in the formula. Then, we use our `trap_integral` function to find
    the accumulated value of the `g` function between `a` and `b`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s check that using a curve we know the length of, such as the line *y
    = 2x*. We can calculate the distance of the curve''s line between *x = (0,0)*
    and *x = (2,4)* using the Pythagorean theorem with 2√5 or 4.47 units:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code prints out 4.47... as the output.
  prefs: []
  type: TYPE_NORMAL
- en: 'But when we try to check an actual curve that we know the length of, such as
    a semicircle, we run into a problem. We know the length of the curve of the following
    equation because it''s half the circumference of a circle with radius 1\. So,
    we should get π or 3.1415... as the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.2: Formula to calculate the length of a semicircle'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_11_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.2: Formula to calculate the length of a semicircle'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s change `f(x)` to the equation for the preceding semicircle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'When you execute the preceding code, you get an error. The last line of the
    error message (the first line I read) says the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This happens because the derivative of the semicircle at -1 and at 1, it is
    infinite. The tangent lines at those points are vertical, as shown in the following
    graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.3: Vertical tangent lines, with an infinite slope'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_11_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.3: Vertical tangent lines, with an infinite slope'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, already, this method runs into a problem. Let''s see if it''ll find the
    length of a regular polynomial, such as the one shown in the following graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.4: A complicated polynomial'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_11_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.4: A complicated polynomial'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a polynomial of degree 5, meaning the highest exponent of *x* is *5*.
    The equation for the curve is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.5: Equation of the curve'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_11_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.5: Equation of the curve'
  prefs: []
  type: TYPE_NORMAL
- en: Complicated as it may seem, nowhere on the curve is the derivative infinite,
    as it was in *Figure 11.3*. That means we can use our curve length function on
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the code for the polynomial:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'And the length of the curve is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use Wolfram Alpha to solve this by putting in *length of curve y = ...
    from –2 to 1* and checking whether it''s a good approximation. But using Python,
    there''s a more straightforward way of calculating the length of a curve that
    doesn''t run into the problem we run into with derivatives. In fact, it doesn''t
    even use derivatives or integrals. You can simply find the length of a tiny bit
    of the curve using the Pythagorean theorem and add up all those tiny bits, as
    shown in the following diagram. We know the width, and we''re interested in the
    hypotenuse of the tiny right triangle. We can calculate the height, which is the
    difference between the function at *x* and the function at *x*, plus the width:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.6: Finding the length of a tiny part of a curve'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_11_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.6: Finding the length of a tiny part of a curve'
  prefs: []
  type: TYPE_NORMAL
- en: 'The hypotenuse of the right triangle shown in the preceding diagram is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image/B15968_11_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.7: Formula to calculate the hypotenuse of the right-angled triangle'
  prefs: []
  type: TYPE_NORMAL
- en: 'All we have to do is go through the interval from `a` to `b`, counting up all
    those lengths. Here''s how to do that in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This should remind you of the integral program: create a running sum, then
    loop over each *slice* of the curve, adding the areas (in this case, the arc lengths)
    as you go. Finally, return the final value of the running sum.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the curve length of the interval we''re interested in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This gives us the length of the curve as `9.614118659973549`. This is even closer
    than the previous version, and with much less fuss. Now, it's your turn to do
    the same in the following exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 11.01: Finding the Length of a Curve'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, you''re provided with the following equation of a curve.
    Using this equation, determine the length of the curve between two given *x* values:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.8: Equation of the curve'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_11_08.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.8: Equation of the curve'
  prefs: []
  type: TYPE_NORMAL
- en: These values will be from *x = -1* to *x = 1*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to create a `circle` function with the preceding equation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: It's the semicircle again. This time, our `curve_length2` function will have
    no problem adding up the tiny slices of the arc.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we''ll run the `curve_length2` function (which we''ve already coded) on
    that curve to add up all the tiny segments, as we did previously:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we print the output of the function, measuring from *x = -1* to *x = 1*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: There's no error message this time. We get a good approximation of half the
    circumference of a circle with radius 1, which we know is π.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to [https://packt.live/3gkI5Qi](https://packt.live/3gkI5Qi).
  prefs: []
  type: TYPE_NORMAL
- en: You can also run this example online at [https://packt.live/3eVpSbz](https://packt.live/3eVpSbz).
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 11.02: Finding the Length of a Sine Wave'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A very important and useful function in math and science is the sine wave.
    It makes one cycle between 0 and 2π, as shown in the following graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.9: One cycle of the sine wave'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_11_09.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.9: One cycle of the sine wave'
  prefs: []
  type: TYPE_NORMAL
- en: It's easy to measure its wavelength (2π) and its amplitude (how far up and down
    it goes, that it, 1 unit), but how long is the actual curve? In this exercise,
    we'll find the length of the sine wave from 0 to 2π.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re going to use our `curve_length2` function again, but now we have to
    import our `sin` and `pi` functions from the `math` module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve already written our `curve_length2` function, which will add up all
    the segments of the curve. We just need to tell it the function to use, and the
    beginning and ending *x* values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, using the `curve_length2` function, it becomes very easy to
    calculate the length of a sine wave.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to [https://packt.live/3dUy3nk](https://packt.live/3dUy3nk).
  prefs: []
  type: TYPE_NORMAL
- en: You can also run this example online at [https://packt.live/2VFy2xd](https://packt.live/2VFy2xd).
  prefs: []
  type: TYPE_NORMAL
- en: Length of a Spiral
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What about spirals, which are expressed in polar coordinates, where *r*, the
    distance from the origin, is a function of the theta (θ) angle that''s made with
    the *x* axis? We can''t use our *x* and *y* functions to measure the spiral shown
    in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.10: An Archimedean spiral'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_11_10.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.10: An Archimedean spiral'
  prefs: []
  type: TYPE_NORMAL
- en: 'What we have in the preceding diagram is a spiral that starts at (5,0) and
    makes 7.5 turns, ending at (11,π). The formula for that curve is *r(θ) = 5 + 0.12892θ*.
    The number of radians turned is 7.5 times 2π, which is 15π. We''re going to use
    the same idea as in the previous section: we''re going to find the length of the
    straight line from *r(θ)* to *r(θ+step)* for some tiny step in the central angle,
    as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.11: Approximating the length of a tiny part of the curve'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_11_11.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.11: Approximating the length of a tiny part of the curve'
  prefs: []
  type: TYPE_NORMAL
- en: 'The opposite side to the central angle of the triangle shown in the preceding
    diagram is just like the slice in our integration problems or the hypotenuse of
    the triangle in our previous length of curve program. This time, it isn''t a right
    triangle, so we can''t use the hypotenuse. But for this problem, there''s a formula
    called the law of cosines. In triangle ABC, the length of the side opposite angle,
    C, is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.12: Law of cosines'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_11_12.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.12: Law of cosines'
  prefs: []
  type: TYPE_NORMAL
- en: 'All we need to do is put that into a function, like this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we just need to write a function that will start at the starting angle
    and take tiny steps around the curve, measuring the sides opposite each tiny angle
    until it gets to the ending angle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Our function is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'So, all we have to do is execute our spiral function on that spiral, from 0
    to 15π:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the length of the spiral is `378.8146271783955`. In the next
    exercise, we'll look at how to find the length of a polar spiral curve.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 11.03: Finding the Length of the Polar Spiral Curve'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, you will find the length of the polar spiral curve, which
    starts at (3,0), makes 12 complete revolutions around the center, and ends at
    (16,0).
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps to find the required length:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We don''t know the formula for this spiral, but we do know that the radius
    increases 13 units (from 3 to 16) in 12 revolutions. This means that for every
    increase of 2π in the angle, θ, the radius increases 13/12 units. So, we divide
    13/12 by 2π. The increase in radius can be expressed as follows:![Figure 11.13:
    Formula to calculate the increase in radius'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/B15968_11_13.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.13: Formula to calculate the increase in radius'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can express that in Python this way:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We can check to make sure *r(0) = 3* and *r(24π) = 16* this way:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we simply put that in our spiral function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In this exercise, we easily found the length of this spiral curve, that is,
    `716.3778471288748`, just by knowing the start and end values of the curve and
    the number of revolutions it made around the center.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to [https://packt.live/2YT70EH](https://packt.live/2YT70EH).
  prefs: []
  type: TYPE_NORMAL
- en: You can also run this example online at [https://packt.live/2YV4wFT](https://packt.live/2YV4wFT).
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 11.04: Finding the Length of Insulation in a Roll'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You have been asked to find the (approximate) length of insulation that remains
    in the roll shown in the following picture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.14: Measuring rolled up materials using calculus'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_11_14.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.14: Measuring rolled up materials using calculus'
  prefs: []
  type: TYPE_NORMAL
- en: You measure the roll and find that the center is an empty circle whose diameter
    is 4 inches (so *r(0) = 2*). The outer diameter of the roll is 26 inches. You
    count the layers from the center to the outside and estimate that the spiral takes
    23 and a half turns, so *r(2π*23.5)= 26/2 = 13*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps to calculate the length:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Calculate the equation using the preceding data:![Figure 11.15: Formula to
    calculate radius'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/B15968_11_15.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.15: Formula to calculate radius'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s what the graph of the spiral looks like:![Figure 11.16: A graph of
    the roll of insulation'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/B15968_11_16.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.16: A graph of the roll of insulation'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, it''s not hard to change our `r` code to this spiral:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can run our spiral function on this function from *0* to *2*π*23.5*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 1,107 inches is just over 92 feet of insulation.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to [https://packt.live/2VE9YKZ](https://packt.live/2VE9YKZ).
  prefs: []
  type: TYPE_NORMAL
- en: You can also run this example online at [https://packt.live/31D43tG](https://packt.live/31D43tG).
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 11.05: Finding the Length of an Archimedean Spiral'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this exercise, you have been given the equation of an Archimedean spiral.
    Find the length of the spiral from *θ=0* to *θ=2π*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.17: Equation of an Archimedean spiral'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_11_17.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.17: Equation of an Archimedean spiral'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This works on both logarithmic spirals as well as Archimedean spirals.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps to find the length:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We simply redefine `r` with the exponential function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Then. we run the spiral function from *0* to *2π*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The length of this spiral is `41.518256747758976`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to [https://packt.live/2VEtjfo](https://packt.live/2VEtjfo).
  prefs: []
  type: TYPE_NORMAL
- en: You can also run this example online at [https://packt.live/2VHasQN](https://packt.live/2VHasQN).
  prefs: []
  type: TYPE_NORMAL
- en: Area of a Surface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's learn how to take this from two to three dimensions and calculate the
    area of a 3D surface. In *Chapter 10*, *Foundational Calculus with Python*, we
    learned how to calculate the area of a surface of revolution, but this is a surface
    where the third dimension, *z*, is a function of the values of *x* and *y*.
  prefs: []
  type: TYPE_NORMAL
- en: The Formulas
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The traditional, algebraic way to solve this analytically is given by a double
    integral over a surface:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.18: Formula to calculate area of a surface'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_11_18.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.18: Formula to calculate area of a surface'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, *z = f(x,y)* or *(x,y,f(x,y))*. Those curly d''s are deltas, meaning
    we''ll be dealing with partial derivatives. Partial derivatives are derivatives
    but only with respect to one variable, even if the function is dependent on more
    than one variable. Here''s a function that returns the partial derivative of a
    function, `f`, with respect to a variable, `u`, at a specific point (`v,w`). Depending
    on which variable we''re interested in, *x* or *y*, the function will take a tiny
    step in that direction and calculate the derivative, as we''ve done already:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: There is a `try...except` block in the code in case a `ValueError` is thrown.
    This happens if the slope gets too big, as in a vertical line. If that happens,
    it'll ignore it and keep going.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we''ll need a 3D vector and a `cross` function for the cross product in
    the area formula. The cross product gives the length of the vector perpendicular
    to both the given vectors, but also the area of the parallelogram that''s formed
    by the given vectors:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.19: The cross product of two vectors'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_11_19.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.19: The cross product of two vectors'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you know the angle between the vectors, you can use that to find the cross
    product:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.20: Formula to calculate cross product of two vectors'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_11_20.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.20: Formula to calculate cross product of two vectors'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you don''t, as in our case, you can use 3D vectors to express the displacement
    of the vector in each direction, *x*, *y*, and *z*. For example, let''s say we
    have two vectors, *u = 2i + 3j + 4k* and *v = 5i + 6j + 7k*. They''re defined
    by their displacement in each of the three dimensions. The *i* part is the displacement
    in the *x* direction, the *j* part is the displacement in the *y* direction, and
    the *k* part is the displacement in the *z* direction. The good news is that there
    will be a few zeroes to simplify things. To cross two vectors, we can put them
    into a matrix and operate on them as the determinant of the following matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.21: Calculating cross product of two vectors using matrix'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_11_21.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.21: Calculating cross product of two vectors using matrix'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll write a function to perform that operation on two 3D vectors. All we''ll
    have to put in are the coefficients of *i*, *j*, and *k*. So, if *u = ai + bj
    + ck* and *v = di + ej + fk*, we''ll get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.22: Performing mathematical operations on 3D vectors'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_11_22.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.22: Performing mathematical operations on 3D vectors'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use lists for the vectors, so *u = [a,b,c]* and *u[0] = a*, *u[1] =
    b* and *u[2] = c* for the coefficients:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We wrote a long docstring to make it clear what the function is used for, how
    to put values in, and what we''ll get as the output. Let''s check this to make
    sure we get the right output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'That works. Now, we need to write a function to find the magnitude of a 3D
    vector, since that''s going to give us the area of the parallelogram. It''s just
    an extension of the Pythagorean theorem into three dimensions. So, the magnitude
    of vector *u* if *u = ai + bj + ck* is ![a](image/B15968_11_22a.png):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s what the semicircle is going to look like, with its surface approximated
    by parallelograms. More parallelograms should mean a more accurate approximation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.23: Using more parallelograms'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_11_23.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.23: Using more parallelograms'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our area function is going to loop through all the *x* and *y* points in the
    grid, calculate the partial derivatives at each point, and use the cross product
    to find the area of the parallelogram at that point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we set the running sum of the areas to 0\. Then, we calculate *dx* and
    *dy*, the tiny changes in *x* and *y*, as we divide the surface up into equal
    slices. The `try...except` block simply ignores (`pass`) the error that will arise
    if a partial derivative is infinite, when the slope of the line tangent to the
    sphere is vertical, as we saw in *Figure 11.3*. If there''s no error, it adds
    the area of the parallelogram that has been formed at that point by the partial
    derivatives. Now, we run the area function on the hemisphere using 1,000 points
    in each direction and get a pretty accurate approximation. We know half the surface
    area of a sphere of radius 1 is 2π, or 6.28:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's quickly perform an exercise based on this concept.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 11.06: Finding the Area of a 3D Surface – Part 1'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, let''s find the area of a complicated surface, which would be difficult
    to find using algebraic methods. Consider the surface for the following equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.24: Equation of the surface'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_11_24.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.24: Equation of the surface'
  prefs: []
  type: TYPE_NORMAL
- en: 'The surface is shown in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.25: A complicated 3D surface'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_11_25.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.25: A complicated 3D surface'
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps to find the area:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s put the function into our area program and see what we get:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the program to see the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Looking at the preceding code, we can clearly see how easy it is to find the
    area of even complicated surfaces in just a few lines of code using Python.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to [https://packt.live/3gwd6kr](https://packt.live/3gwd6kr).
  prefs: []
  type: TYPE_NORMAL
- en: You can also run this example online at [https://packt.live/2ZpgwOQ](https://packt.live/2ZpgwOQ).
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 11.07: Finding the Area of a 3D Surface – Part 2'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Find the area of the surface ![a](image/B15968_11_25a.png).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how the surface looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.26: Another 3D surface'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_11_26.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.26: Another 3D surface'
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps to find the area:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define our surface function to return the expression:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the `surface` function to get the value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The area of this 3D surface is `99.80676808568984`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to [https://packt.live/2VCaObq](https://packt.live/2VCaObq).
  prefs: []
  type: TYPE_NORMAL
- en: You can also run this example online at [https://packt.live/2NPXvQo](https://packt.live/2NPXvQo).
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 11.08: Finding the Area of a Surface – Part 3'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Find the area of the surface ![b](image/B15968_11_26a.png).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how the surface looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.27: The surface of'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_11_27.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.27: The surface of ![a](image/B15968_11_27a.png)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps to find the area:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define our surface function to return the new expression:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the `surface` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The area of this surface is `42.80527549685105`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to [https://packt.live/3gwdLlV](https://packt.live/3gwdLlV).
  prefs: []
  type: TYPE_NORMAL
- en: You can also run this example online at [https://packt.live/3dUNWdt](https://packt.live/3dUNWdt).
  prefs: []
  type: TYPE_NORMAL
- en: Infinite Series
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mathematicians have often run into functions that are too complicated for them
    to solve or otherwise deal with, and approximations have always been an important
    component in doing math. For mathematicians trying to take derivatives and integrals
    algebraically, many expressions have no nice neat solutions, derivatives, integrals,
    and so on. In general, no differential equations that scientists come across in
    real life have algebraic solutions, so they have to use other methods. More on
    differential equations later, but there's an important family of approximations
    that use *easy* functions to approximate *hard* ones.
  prefs: []
  type: TYPE_NORMAL
- en: Polynomial Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It''s easy to solve, differentiate, and integrate polynomial equations—ones
    such as *y = x*2 and even the following equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.28: A polynomial equation'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_11_28.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.28: A polynomial equation'
  prefs: []
  type: TYPE_NORMAL
- en: 'The terms are all added (or subtracted) one after the other, and there are
    no trigonometric, logarithmic, or exponential functions involved to make things
    difficult. Here''s the formula for approximating a *hard* function with an *easy*
    polynomial:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.29: The Taylor series'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_11_29.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.29: The Taylor series'
  prefs: []
  type: TYPE_NORMAL
- en: 'This formula is named Taylor series: any function (which is derivable) can
    be approximated with a certain precision in a specific point using only polynomials
    with a certain page.'
  prefs: []
  type: TYPE_NORMAL
- en: Series
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Mathematicians have a notation to represent adding together a bunch of numbers
    that follow a pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.30: Formula for calculating series'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_11_30.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.30: Formula for calculating series'
  prefs: []
  type: TYPE_NORMAL
- en: 'The big symbol that looks like an *E* is actually the Greek letter sigma, or
    *S*, which represents the sum of the numbers. The equation below the sigma is
    where the variable starts (in this case, 1) and above the sigma is the last integer
    value for *i* (in this case, 10). To the right of the sigma is an expression for
    what to do with the variable. In this case, we''re just adding *i*, the variable,
    as it goes from 1 to 10\. This is almost exactly how you''d write a list comprehension
    in Python. Here''s how:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The first term in the list comprehension is what you see in the sigma series
    expression—in this case, *i*. For example, the series for the sum of the squares
    of the integers up to *n* would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.31: Series for sum of squares of integers from 1 to n'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_11_31.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.31: Series for sum of squares of integers from 1 to n'
  prefs: []
  type: TYPE_NORMAL
- en: 'In Python, we''d write it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'An old but useful series is the arctangent series. It calculates the angle
    (in radians) that has the given tangent; for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.32: Equation of an arctangent series'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_11_32.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.32: Equation of an arctangent series'
  prefs: []
  type: TYPE_NORMAL
- en: 'From the preceding equation, the equation for arctan will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.33: Equation of an arctan'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_11_33.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.33: Equation of an arctan'
  prefs: []
  type: TYPE_NORMAL
- en: 'The series is calculated by this pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.34: Equation for series of arctan'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_11_34.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.34: Equation for series of arctan'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the sigma expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.35: A sigma expression'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_11_35.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.35: A sigma expression'
  prefs: []
  type: TYPE_NORMAL
- en: 'By plugging in the tangent for *x*, we can calculate a close approximation
    to the angle:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.36: Substituting the value of x in the equation'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_11_36.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.36: Substituting the value of x in the equation'
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s quite a bit of calculation for a mathematician centuries ago, but here''s
    the Python equivalent. Notice how close the first part of the list comprehension
    is to the preceding sigma expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'So, after 10 terms, we get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: This is very close to ![a](image/B15968_11_36a.png).
  prefs: []
  type: TYPE_NORMAL
- en: Convergence
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Mathematicians wanted to simplify the arctan series to easily calculate *π*
    using the fact that:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.37: Trigonometric function of a tangent'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_11_37.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.37: Trigonometric function of a tangent'
  prefs: []
  type: TYPE_NORMAL
- en: 'From the preceding equation, the equation for arctan will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.38: Formula to calculate arctan'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_11_38.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.38: Formula to calculate arctan'
  prefs: []
  type: TYPE_NORMAL
- en: 'They figured replacing *x* with *1* in the arctan series would make calculating
    *π* a walk in the park. Here are the first few terms:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.39: Substituting x = 1 in the arctan series'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_11_39.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.39: Substituting x = 1 in the arctan series'
  prefs: []
  type: TYPE_NORMAL
- en: 'This expression gives the approximation for *pi*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.40: Equation to find the approximate value of pi'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_11_40.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.40: Equation to find the approximate value of pi'
  prefs: []
  type: TYPE_NORMAL
- en: 'We just write the code for the part to the right of the sigma, add code for
    the range of *n*, and sum them up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'We can show the progress toward approximating *pi* in the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'This is not very close to *π*. How about skipping up to higher numbers of terms?
    Let''s change code for the loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: After 1 million terms, it only gets us five correct decimal places. This series
    *converges* to (that is, gets very close to or *tends toward*) π/4 too slowly
    for any practical use. So, for centuries, mathematicians have looked for better
    and better series to approximate π.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 11.09: Calculating 10 Correct Digits of π'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In 1706, English mathematician and astronomer John Machine used his improved
    series to calculate 100 decimal places of *pi*. Here''s the series:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.41: An arctan function'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_11_41.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.41: An arctan function'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the preceding arctan function to calculate 10 correct digits of *π*. Follow
    these steps to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Simply call our arctan function. 10 terms should be sufficient:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the preceding code to see the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: We get a pretty good approximation using 10 terms. It gives even more than 10
    correct digits.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to [https://packt.live/3dPjVvD](https://packt.live/3dPjVvD).
  prefs: []
  type: TYPE_NORMAL
- en: You can also run this example online at [https://packt.live/3dVlTKR](https://packt.live/3dVlTKR).
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 11.10: Calculating the Value of π Using Euler''s Expression'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The great German mathematician Euler came up with the following expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.42: Euler''s expression'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_11_42.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.42: Euler''s expression'
  prefs: []
  type: TYPE_NORMAL
- en: Use this expression to approximate *π*. Does it converge more quickly than the
    adjusted arctan formula?
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the code for approximating *π* using Euler''s series:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Does it converge more quickly? Run the preceding code to see the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: It doesn't seem like it converges any quicker. After 1 million terms, you'll
    still only have five correct decimal places.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to [https://packt.live/2NRnnLD](https://packt.live/2NRnnLD).
  prefs: []
  type: TYPE_NORMAL
- en: You can also run this example online at [https://packt.live/38lHXgm](https://packt.live/38lHXgm).
  prefs: []
  type: TYPE_NORMAL
- en: A 20th Century Formula
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here is the brilliant Indian mathematician Ramanujan''s formula to approximate
    π:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.43: Ramanujan''s formula to approximate π'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_11_43.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.43: Ramanujan''s formula to approximate π'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how to code that in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The output after 10 terms is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: That's very accurate!!
  prefs: []
  type: TYPE_NORMAL
- en: Interval of Convergence
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The range of values for which a series converges (tends toward a value) is
    called the interval of convergence. Using Python, finding this interval is rather
    straightforward: you run some numbers through the series, and if they get infinitely
    large, they''re not in the interval. If they produce a number, they''re in the
    interval. For example, let''s have a look at a very common textbook question and
    solve it using Python.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 11.11: Determining the Interval of Convergence – Part 1'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Determine the interval of convergence for the following power series:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.44: A power series'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_11_44.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.44: A power series'
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the sum into Python:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Since we can't use the number "infinity," we find the sum of all the terms from
    n = 1 to 1 million.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run all the integers from -10 to 10 to see if there is any converge to a number:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run this, you''ll get an `OverflowError`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: All this means is that some of the numbers got became large, which is what we
    expected. We need to add a condition so that if we get that error, it'll simply
    return `Infinity`. This is done with a `try...except` block.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s tell Python to try a line of code. If it throws a specific error (in
    this case, `OverflowError`), don''t stop the program, just do this instead:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the output gives us some infinities and some actual values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: It looks like our interval of convergence is -5 < x < -1\. This means we can
    use the series to get useful values if *x* is in the interval. Otherwise, we can't
    use it.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to [https://packt.live/38k30A2](https://packt.live/38k30A2).
  prefs: []
  type: TYPE_NORMAL
- en: You can also run this example online at [https://packt.live/31AtmMU](https://packt.live/31AtmMU).
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 11.12: Determining the Interval of Convergence – Part 2'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Determine the interval of convergence for the following power series:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.45: A power series'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_11_45.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.45: A power series'
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define the sum in Python:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s some of the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: All the output for *x* between -25 and 25 stayed small (between 0 and 600),
    no matter how many terms we used, so we'll call the interval of convergence *-25
    < x < 25*.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to [https://packt.live/38pwuwC](https://packt.live/38pwuwC).
  prefs: []
  type: TYPE_NORMAL
- en: You can also run this example online at [https://packt.live/2YS46jl](https://packt.live/2YS46jl).
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 11.13: Finding the Constant'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will express an infinite series in Python and find the
    sum. We will use a famous constant, which is defined as the sum of the series:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.46: Sum of the series'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_11_46.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.46: Sum of the series'
  prefs: []
  type: TYPE_NORMAL
- en: 'What is the value of this famous constant? Let''s follow these steps to determine
    this value:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the factorial module and convert the preceding equation into Python,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the preceding code to see the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: The famous constant is *e*, the base of the natural logarithms.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to [https://packt.live/2AoyubH](https://packt.live/2AoyubH).
  prefs: []
  type: TYPE_NORMAL
- en: You can also run this example online at [https://packt.live/2BZ4aVw](https://packt.live/2BZ4aVw).
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 11.01: Finding the Minimum of a Surface'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A major task in machine learning is minimizing a function. When you're training
    a neural network, you're changing values in a matrix or tensor to see which ones
    provide a better approximation of your test data. At every value in your network,
    you can see how much it contributes to your error. This sounds like the partial
    derivatives at different points on a surface, doesn't it?
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of this is the process of gradient descent. Let''s consider that
    we want to find the location of the minimum value of our function. Every point
    in our surface has a partial derivative, and we can use those to move a little
    bit toward a lower value. We''ll start somewhere random, calculate the partial
    derivatives at that point, and then move in the direction that lowers the value
    of *z*, that is, the up-down value. So, if the partial derivative of *z* with
    respect to *x* (which we call *dz_dx*) is negative, that means *z* is decreasing
    as *x* is increasing, and we''ll want to move in the positive *x* direction. If
    *dz_dx* is positive, that means *z* is increasing as *x* is increasing, so we''ll
    want to go in the opposite direction, so we''ll move in the negative *x* direction.
    We''ll do the same for the *y* direction. This will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.47: The path of descent to a minimum value'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_11_47.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.47: The path of descent to a minimum value'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part of this activity is to create a function that finds the minimum
    point of a surface. This function can be written by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Write a function that will create a random (x, y) location on a surface. You
    can call the `uniform` function of the `random` module to generate these values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Calculate the partial derivatives of *z* with respect to *x* and *y*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change *x* and *y* by the negative of the partial derivatives, multiplied by
    a tiny *step* amount in case the partial derivative is large.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Calculate the partial derivatives at this new location and keep looping until
    the partial derivatives are both really small (less than 0.0001) or the location
    is off the surface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the function on a bunch of random locations, saving the minimum *z* values
    to a *mins* list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, print the minimum of the mins list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once you have written the function, test it on a function that you already
    know the value of to verify that it works as intended. You can then run it on
    a function that you don''t already know the minimum point of, in order to determine
    this unknown location. The steps for this are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Test your function on the surface ![6](image/B15968_11_InlineEquation6.png).
    Your function should find that the minimum value is 0, at the point (0, 0).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you're confident in your function, use it to determine the minimum of ![7](image/B15968_11_InlineEquation8.png)
    with *-1 < x < 5* and *-1 < y < 5*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You should find that, depending on your starting point, your function will converge
    to different minimum points—a local minimum and a global minimum.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 696.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned the power of derivatives and integrals,
    so in this chapter, we built on those tools to solve some pretty difficult problems,
    such as the length of a spiral and the area of a 3D surface. We even extended
    derivatives and integrals to three dimensions by introducing partial derivatives.
    In a calculus class, we would be using lots of algebra in order to use these tools,
    but by using Python, we modeled the situation and tested our functions. We created
    variables that will contain our changing values and looped through the calculations
    millions of times, if necessary. To the mathematicians of previous centuries,
    this would have seemed like some kind of magic lamp.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll deal with more changing rates and amounts and avoid
    a lot of algebra by using Python. We'll find out how much salt is in an ever-changing
    mixture, when and where a predator will catch its prey, and how long we'll have
    to invest our money to make 1 million dollars.
  prefs: []
  type: TYPE_NORMAL
- en: FAB62
  prefs: []
  type: TYPE_NORMAL
- en: RUC47
  prefs: []
  type: TYPE_NORMAL
