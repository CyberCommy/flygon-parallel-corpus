- en: Working with D3.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: aahis chapter will introduce you to **Data-Drive Documents** (**D3**), a powerful
    visualization library and one of the most popular open source projects in the
    world. Interestingly, while it's most important for its data manipulation features,
    D3 is simply one of the most powerful libraries for working with SVG, full stop.
    Even in the context of being a `helper` library of the sort we discussed in the
    previous chapter, it has many very useful features for working with SVG documents,
    including many that replicate the sorts of things that `Snap.svg` and SVG.js offer
    and many more beyond that.
  prefs: []
  type: TYPE_NORMAL
- en: D3 doesn't stop there, however. It goes well beyond that SVG authoring and utility
    feature set and goes on to offer a rich suite of tools to do data manipulation
    and subsequent generation of data visualizations. What's more, D3 uses the same
    web standards under the hood that you've been working with throughout the book
    and marries it with a robust API to offer up a true playground for working with
    SVG and data.
  prefs: []
  type: TYPE_NORMAL
- en: Born out of an earlier visualization library called Protovis ( [http://mbostock.github.io/protovis/](http://mbostock.github.io/protovis/)),
    D3 has been around since the early 2010s and remains under the watchful eye of
    the project's original developer, Mike Bostock. The project is under active development,
    and offers up copious documentation and a wonderful selection of examples to learn
    from.
  prefs: []
  type: TYPE_NORMAL
- en: It's also, once you get the hang of it, a lot of fun. This is the last new technology
    introduced in the book that's used for working with SVG directly, so it's nice
    to be ending this phase of the book on a high note.
  prefs: []
  type: TYPE_NORMAL
- en: Let's have some fun.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll learn about several topics, including:'
  prefs: []
  type: TYPE_NORMAL
- en: How to install D3 and how to do basic SVG manipulations with the library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do a bar chart with D3 using scales and functions that help define the
    *x* and *y* axes of a chart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use the `d3-fetch` utility to get and parse JSON and CSV data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use the `enter` and `exit` selections to manipulate the SVG DOM based
    on the changes to a dataset
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to implement a donut chart in D3 using the `arc` and `pie` functions from
    D3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to implement a chord diagram; a complicated visualization with multiple
    components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting started with D3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The D3 API can take some getting used to. The examples in this chapter will
    strive to illustrate some of the basic concepts as well as dive deeper as we move
    forward to show some of the best that D3 has to offer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we can do any of that, you need to get D3 into your page. To do so,
    you can use `npm` to install it into your project folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you''ve got it installed, you can link to the minified D3 source from
    your document using a script tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'If you''d prefer not to use `npm`, it''s also available to be linked to from
    [d3js.org](https://d3js.org/) directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Additionally, if you want a local copy, you can clone the project from GitHub
    ( [https://github.com/d3/d3)](https://github.com/d3/d3)), or download the project
    from [d3js.org](https://d3js.org/) and then organize your files in any way you
    like.
  prefs: []
  type: TYPE_NORMAL
- en: Once you've got the project installed, you're ready to start to explore the
    D3 API.
  prefs: []
  type: TYPE_NORMAL
- en: The following example shows how to implement a simple bar chart using D3\. You've
    seen some of the concepts used to generate a bar chart already in this book, but
    the difference here is that D3 will do it for you. D3 knows all about visualizations
    so it will generate the required metrics for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'This visualization will compare the top ten individual comic book sales of
    all time. The data ([https://itsalljustcomics.com/all-time-record-comic-book-sales/](https://itsalljustcomics.com/all-time-record-comic-book-sales/))
    it will illustrate is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Title/Issue #/Grade** | **Date of sale** | **Sale price** |'
  prefs: []
  type: TYPE_TB
- en: '| Action Comics 1 9.0  | 2014/08/24  | $3,207,852.00 |'
  prefs: []
  type: TYPE_TB
- en: '| Action Comics 1 9.0 | 2011/11/30 | $2,161,000.00 |'
  prefs: []
  type: TYPE_TB
- en: '| Action Comics 1 8.5 | 2018/06/13 | $2,052,000.00 |'
  prefs: []
  type: TYPE_TB
- en: '| Action Comics 1 8.5 | 2010/03/29 |  $1,500,000.00 |'
  prefs: []
  type: TYPE_TB
- en: '| Amazing Fantasy 15 9.6 | 2011/03/09  | $1,100,000.00 |'
  prefs: []
  type: TYPE_TB
- en: '| Detective Comics 27 8.0 | 2010/02/25  | $1,075,000.00 |'
  prefs: []
  type: TYPE_TB
- en: '| Action Comics 1 Kansas City 8.0  | 2010/02/22  | $1,000,000.00 |'
  prefs: []
  type: TYPE_TB
- en: '| Action Comics 1 5.5  | 2016/08/04  | $956,000.00 |'
  prefs: []
  type: TYPE_TB
- en: '| All Star Comics 8 9.4 | 2017/08/27  | $936,223.00 |'
  prefs: []
  type: TYPE_TB
- en: '| Action Comics 1 5.0 | 2018/03/20  | $815,000.00 |'
  prefs: []
  type: TYPE_TB
- en: 'The end result of the visualization will look like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c63a1b78-0cc5-4b3b-87c0-909679e0da39.png)'
  prefs: []
  type: TYPE_IMG
- en: All JavaScript code in this chapter is written to take advantage of ES6 features,
    such as arrow functions, const, and let.
  prefs: []
  type: TYPE_NORMAL
- en: 'The markup, which follows, is very simple. We once again include Bootstrap
    for simple layout tasks and `Raleway`, our font of choice in this book. Then we
    set some base CSS styles for text elements and set up a simple container to hold
    the visualization. After that, we include three files: `d3.min.js`, the main D3
    file, `d3-fetch.min.js`, a Fetch utility from D3 ([https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)),
    and our visualization file, `bar.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Since the JavaScript here is complicated and introduces many new concepts, I'm
    going to go through each block separately. Look at the full file in the downloaded
    source code if you'd like to see the entire file in one go.
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking at `bar.js`, it consists of one function that draws the entire visualization
    on screen. The start of the function sets several constants that are used throughout
    the visualization: `width`, `height`,  `chartHeight` (used to set the size of
    the chart itself versus the size of the overall SVG), and a `margin` const used
    to ensure that there''s enough margin to hold the entirety of the visualization
    in the SVG element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Following that, we start to work directly with D3\. D3 allows you to access
    and manipulate existing SVG elements and also, as in the case of the D3 demos
    in this book, generate a D3-enhanced SVG element and append it to the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we're using D3's query selector utility, `d3.select`, to select
    the `#target` element and then append a new SVG element into it. We then use the
    increasingly familiarly named function `attr` to set the `height` and `width`
    of the SVG element. Once the SVG element is in the document, we append a new `g`
    element and immediately translate it by the `margin` on the *x* and *y* axes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Chained D3 methods behave like jQuery or other libraries that use this pattern
    so the variable `svg` is a D3-enabled reference to the final element in the chain,
    the newly added `g`. Anything that interacts with that variable will start from
    within the context of that `g` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Next, we use some methods to set the scale for the *x* and *y* axes and then
    actually generate both the *x* and *y* axes. This is where D3 really shines. Doing
    this work isn't impossible. It's often simple math. It's just that no one wants
    to write these functions all the time and D3 makes it easy with an entire suite
    of scale functions ([https://github.com/d3/d3-scale](https://github.com/d3/d3-scale)).
  prefs: []
  type: TYPE_NORMAL
- en: The `x` variable holds the return value of a `scaleBand` method call. `scaleBand`
    allows you to break up a numeric scale into component *bands*, which we will use
    to create the horizontal spacing of our bar chart. The initial call is chained
    to two subsequent calls, each of which inform the band about our specific visualization.
    The `range` method call sets the *x* scale to range from `10` pixels up to a calculated
    upper bound (the `width` minus two horizontal margins). `paddingInner `sets the
    inner padding of the bands. This property allows us to create some space between
    the columns.
  prefs: []
  type: TYPE_NORMAL
- en: The `y` variable is created as a linear scale. Linear scales are continuous,
    regular scales between two values. The values for this particular scale are set
    with a call to `range` with `chartHeight` and `0` as the range values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following that, we use the newly created `x` and `y` scales to call two convenience
    methods, `axisLeft` and `axisBottom`. These methods render human-readable reference
    marks for scales. The `xAxis` is created and then the just-created `x` scale is
    passed in to wire up `xAxis` with the values from the `x` scale. The `y` axis
    is generated in exactly the same way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We then use another scale method, `scaleOrdinal`, to create a map between our
    discrete data values and a corresponding set of colors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The rest of the method uses a utility from `d3-fetch` and `d3.json` to access
    our data file and then, as `callback` to the fetch request, process the data and
    generate our visualization.
  prefs: []
  type: TYPE_NORMAL
- en: The `callback` methods begin with two calls to `domain` for both the `x` and
    `y` axes.
  prefs: []
  type: TYPE_NORMAL
- en: For an ordinal scale, the `xAxis` and `domain` accept an array and sets the
    domain for the scale to the specific set of values in the array. Here, we `map`
    the returned `data` to create a collection of the `title` properties as the values
    to use in the `xAxis`.
  prefs: []
  type: TYPE_NORMAL
- en: For a linear scale, calling `domain` limits the continuous scale to the specific
    set of values. In this case, we're setting the scale to `0` at the minimum and
    the return value of `d3.max`, which returns the largest value in an array, as
    the maximum.
  prefs: []
  type: TYPE_NORMAL
- en: Following that we start manipulating SVG elements to create the actual visualization.
  prefs: []
  type: TYPE_NORMAL
- en: The first set of chained methods appends a new SVG group element, `g`, and adds
    a pair of classes to it, `x` and `axis`, and then translates it to a point at
    (`0`, `chartHeight`). This places this group at the bottom of the chart, which
    is precisely where you want the legend for the *x*-axis to be.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we use the `d3.call` function to call `xAxis` and generate our *x*-axis.
    `d3.call` is a utility method that allows you to call a function on a selection
    and then return the modified selection. This allows you to encapsulate some functionality
    in a reusable function in a way that enables chaining. Here, we call `xAxis`, the
    configured `axisBottom` method we created earlier, in order to create the *x*-axis
    – complete with all the elements that make up the *x*-axis. Without doing anything
    else, the *x*-axis now looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/df12a31f-1b9e-4a3d-a55e-c8d1628e5c62.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, for some values that layout might be okay, but for our purposes,
    it's not functional. Because of the length of our titles, we need to tweak our
    labels to be legible. We'll rotate them 90 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: To do so, we chain a few more methods onto our current chain. First we `select`
    all `text` elements that are child nodes of the current selection. These are all
    the `text` elements we just created with `xAxis`. Once we have that selection,
    we apply a transformation of -90 degrees to the text elements. This reorients
    the `text` to be vertical. Following that, we adjust the `dx` and `dy` properties
    to line the text up neatly.
  prefs: []
  type: TYPE_NORMAL
- en: Next up, we append a new `g` element.
  prefs: []
  type: TYPE_NORMAL
- en: Using these groups is not strictly necessary, but they help to organize the
    generated code for debugging and allow you to more easily create selections that
    are easy to manipulate. This is what groups are for.
  prefs: []
  type: TYPE_NORMAL
- en: This new `g` element will hold the *y*-axis. The *y*-axis is created in a similar
    way to the *x*-axis – although it's a simpler process, since there's no need to
    manipulate the text elements. A horizontal text layout is fine for the *y*-axis.
    In this call, we add classes to the `g` element, `y` and `axis`, and then call
    `yAxis`, which generates all of the elements that make up the *y*-axis.
  prefs: []
  type: TYPE_NORMAL
- en: The final method chain in this `callback` function illustrates a common pattern
    when working in D3\. The first call is to `d3.selectAll`. `selectAll` will access
    *all* the elements that match the provided selector. This returned value is called
    the *selection *in D3\. The selection can either be a list of DOM elements or,
    in this case, an array of placeholder elements matching the items in the data.
    So, empty, in this context is okay, as we will go through the process of manipulating
    the selection and adding our elements to it based on the received data.
  prefs: []
  type: TYPE_NORMAL
- en: We'll illustrate `enter` and the associated method, `exit`, in more depth in
    the next section, but in short, if your selection has fewer elements than the
    number of points in the dataset, then those extra data points are stored in what's
    referred to as the *enter selection*. Calling `enter` allows us to enter into
    and manipulate this enter selection. In our case, we're adding a number of `rect`
    elements to the SVG element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each of those `rect` elements is manipulated in the following ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Its `fill` is set referencing a member of the `color` scale.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `x` property is created based on the members of the `x` scale.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `width` is calculated using `x-bandwidth`, which is a method that takes
    the member of the `x` scale and calculates a width based on that scale, including
    any defined padding.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `y` property is created based on the `y` scale previously created
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `height` is calculated by subtracting this data point's *y* scale value
    from the `chartHeight`. This, in effects, hangs the box from the `y` value down
    to the bottom of the chart.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All of these properties combine to create the heart of the visualization:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The final line of the file simply calls `bar()` to create the visualization.
  prefs: []
  type: TYPE_NORMAL
- en: D3's enter and exit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As I mentioned in the last section, I want to take a quick, simplified look
    at `enter` and the associated method, `exit`. These methods are important for
    dealing with dynamic datasets. With these methods, you can take an arbitrary selection,
    blend it with data and then manipulate it with D3's tools to craft visualizations.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you'll see three examples. The first shows an example of using
    `enter` that illustrates calling the method against a completely empty selection.
    The second illustrates calling `enter` on a selection with existing elements.
    The third illustrates how `exit` works.
  prefs: []
  type: TYPE_NORMAL
- en: In this first example, we select the `#target` element and then call `selectAll`
    with `p` as the argument. Since there are no paragraphs in that `#target` element,
    this is an empty selection. Calling `data` on it binds that empty selection to
    our data. Calling `enter` on that bound selection allows us to manipulate our
    selection based on each data point.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you were to log out the return value of `d3.select("#target").selectAll("p").data(data).enter()`
    at this point, it would look like the following screenshot, showing an array of
    five elements with the original data stored as an internal `__data__` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2b23bbf2-7266-4d18-b7e8-cc3b4362a068.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next we simply `append` a paragraph to the document for each data point and
    use the `text` method to insert a text node representing the data into the document:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the code in the browser results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b8179d05-c82f-481d-b425-4bc16f455d21.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The next example is similar, except for the fact that it has an existing paragraph
    element in the `#target div`. Since there''s an existing `p` element, calling
    `d3.select("#target").selectAll("p").data(data).enter()` on the selection results
    in the following output. As you can see, the `_groups` array has the same five
    members, but the first entry, the one that corresponds to the existing member
    in `selection` is empty. That''s because it''s not part of the enter selection
    (as it corresponds to an *existing* element):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0677d8c8-621e-40b5-97a3-cfede4a6b9b2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Everything else about this example is the same as the previous example of using
    `enter`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we''re only updating the enter selection in this example, running the
    preceding code in the browser produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/46baebc7-0833-4c4a-b616-43523ce639f0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To update the *entire* selection, you simply need to manipulate the original
    selection before you update the enter selection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `exit` selection allows you to clean up elements that no longer have data
    associated with them. The following example shows how this works.
  prefs: []
  type: TYPE_NORMAL
- en: The `render` function initially goes through some patterns we've already seen.
    The function calls `selectAll` on `p` elements that are children of `#target div`,
    loads it up with data, enters the enter selection, and appends a series of paragraph
    elements with the correct data.
  prefs: []
  type: TYPE_NORMAL
- en: Next we repeat the process and instead of calling `enter`, we call `exit` and
    then immediately call `remove`. The `exit` selection returns any elements in the
    selection that don't correspond to a data point*. *`remove` removes those elements
    from the document. The first time this runs, no elements are removed because the
    data has just been loaded. All elements in the selection are populated with the
    proper data.
  prefs: []
  type: TYPE_NORMAL
- en: The interesting thing happens in `setTimeout`. In that `callback` function,
    if there are still members of the data array, `data.pop()` is called. `pop` removes
    the last element from the array and then `render` is called, recursively after
    `1` second. When the function runs again and we get to the exit selection, where
    we call `exit.remove`, there *is *a mismatch between the data and the selection.
    The first time this is called recursively, there are five paragraphs, but only
    four data points. Because the fifth paragraph doesn't have a data point associated
    with it, it's removed from the document.
  prefs: []
  type: TYPE_NORMAL
- en: 'This process repeats until there are no data points or paragraphs left and
    the recursive calls stop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Hopefully, these simplified examples, dealing with the simplest possible element,
    a humble paragraph, are enough to illustrate the way that this very powerful pattern
    can help to work with datasets.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've taken a look at these two methods, let's return to some more
    of the fun stuff, with a new, slightly more complicated visualization.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a donut chart with D3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This next sample illustrates another basic data visualization: in this case,
    a donut chart. Slightly more complicated than a pie chart, this visualization
    illustrates some new features of D3\. When complete, the visualization will look
    like the following screenshot.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It represents the distribution of individual comic books (referenced by title
    and issue number) among the top 50 comic book sales of all time (public sales,
    at the time of writing). There are a few comics that dominate lists like that
    and this chart will show which ones dominate the most:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fbc62d23-dba6-4d33-a0aa-57a67117cb73.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The data looks like the following CSV:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The HTML file is very simple. It includes, once again, `Raleway`, Bootstrap,
    `d3-fetch`, and D3 for dependencies. It includes the same markup we''ve been working
    within several examples in this book and then includes our `donut.js` file, which
    is where everything interesting happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Looking at `donut.js`, there's a lot going on, so we'll once again go through
    the file section by section. If you want to see the whole file, please look at
    the full source code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The file starts with setting several constants for the `height`, `width`, and
    `radius` of the visualization. We then create a color scale that steps through
    13 shades of blue and green:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The next two method calls are there just to set up for the later visualization.
    At this point, we don't have any data to work with, but we can still create some
    loaded D3 tools to work with the data when it arrives. The first constant, `arc`,
    will allow us to draw arcs with an `outerRadius` that reaches near to the edge
    of the SVG element and an `innerRadius 200` pixels in from the `outerRadius`. That
    creates a 190 pixel ring.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following that we call `d3.ie`, which is a method that takes data and returns
    `arc`s that represent the correct proportional slice of data for a pie or donut
    chart. We don''t have data yet, but we set the method up to know to use the `numbers`
    property of the data object when it creates the `arc`s:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Next we start to implement some SVG. The first call should be common to you
    by this point. We call `d3.select` to grab the `#target` element and then append
    an SVG element into the DOM. Then we use `attr` to set the `height` and `width`
    and then append a group, `g`, element to the SVG document. That `g` is then transformed
    to the center of the SVG element, translating it by half the width and half the
    height of the SVG element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following that we append a new `text` element to the `g` element that contains
    a small legend for the visualization:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Now that we've done all of this setup, it's time to crunch some data and draw
    the visualization. We're starting by using another method from `d3-fetch`, `d3.csv`,
    to fetch a CSV file that contains our data and work with it after D3 parses it.
  prefs: []
  type: TYPE_NORMAL
- en: Inside `callback`, there's the now familiar D3 pattern. First, there is a call
    to `svg.selectAll("arc")`, which at this point returns an empty selection. Then
    we call `data`, passing in `pie(data).` `pie` takes the data in and returns the
    start and end angles that we'll use for our donut chart. Next we go into the enter
    selection and append `g` elements for every member of the selection. We haven't
    drawn anything yet, but we have groups set up for each of our data points and
    we have calculated start and end angles applied to the dataset.
  prefs: []
  type: TYPE_NORMAL
- en: The next section illustrates just how nice it can be to work with D3.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we've got the angles generated by the call to `pie`, attached
    to a number of empty `g` elements. In this next call, we append a `path` element,
    and, with a call to the previously created `arc` method, we populate the `d` attribute
    with the full `arc` required to draw the visualization. That's all it takes.
  prefs: []
  type: TYPE_NORMAL
- en: All that's left now, for the chart itself, is to populate the fill of the arc
    by returning a value from the color scale we created earlier. This is selected
    based on the index of the data. The data is sorted by its ranking among the comic
    book titles. This creates the nice gradient we see when we run this visualization.
    And if you stopped here, you would actually have a visualization. It wouldn't
    have any text associated with it, but you'd have a nice looking donut chart. Such
    is the power of D3.
  prefs: []
  type: TYPE_NORMAL
- en: That said, we should add some labels, so let's look at how that works. The initial
    pattern is one you should start to be familiar with. We call `selectAll(".label")`,
    load it up with data (manipulated by another call to `pie` to get the same start
    and end angles) and then we manipulate it in the enter selection. In the enter
    selection, we append a `text` element and then take several steps to place the
    text in a useful place across the entire visualization.
  prefs: []
  type: TYPE_NORMAL
- en: The first step is to translate the text element to be in the center of `arc`
    using the `arc.centroid` method. Again, this is a great example of how useful
    D3 can be. One small call will allow you to access the geometric center of a complicated
    shape. This works for most of the text elements. We're nearly done.
  prefs: []
  type: TYPE_NORMAL
- en: 'We just need to tweak the text in two specific cases. Without the next call,
    the text overlaps in unattractive ways in the last few elements of the visualization,
    as can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/61ef5499-ed86-42fd-ae21-2ded41d86a74.png)'
  prefs: []
  type: TYPE_IMG
- en: To adjust the placement of those two overlapping elements, we need to figure
    out which ones they are. we know that they are the last two and that they would
    be near the end of the circle. The angles here are measured in radians (360 degrees
    is 2PI or around 6.28 radians). Using rough shorthand for one slice (0.125 radians
    represents roughly one slice in our visualization), we work backward from the
    full circle to test for the last two slices and adjust them slightly using the
    `dy` attribute. The first one is adjusted by `.6em`. The next, final, text element
    is adjusted by `1.5em`. This means that every label is clear to read.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final call actually appends the text to the element using a call to `text` with
    the data''s `title` as an argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Now that we've done two standard charts, it's time to do one that's a little
    bit more fun, a chord diagram. This final example will illustrate even more features
    of D3\. It'll be fun.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a chord diagram in D3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This final visualization is more complicated on both the data and coding fronts.
    The visualization is based on data released several years ago as part of the Hubway
    Data Visualization Challenges ([http://hubwaydatachallenge.org/](http://hubwaydatachallenge.org/)).
    It's a large dataset that represents every trip, including departure and arrival
    stations, on Boston's Hubway bike-share program (now called Blue Bikes). This
    visualization shows the relationship between the top ten most popular stations,
    illustrating the number of trips that happened between stations in the top ten.
    This is interesting to see which of the major hubs are illustrating potential
    holes in the public transportation network (lots of people are taking trips between
    transit hubs like North Station and South Station) or are potentially being used
    by tourists to see the sights in Boston (many South Station trips return back
    to South Station).
  prefs: []
  type: TYPE_NORMAL
- en: 'The final visualization looks like this. Each `arc` represents a departure
    station and the ribbons between the two stations show the relative weight of trips
    between the two stations. The width of the bar when it leaves the `arc` represents
    the numbers of trips. The color of the `arc` is owned by the station in the pair
    that generated more trips between the two:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0e8f63c5-9a15-438f-b6bf-05c99c3b2d91.png)'
  prefs: []
  type: TYPE_IMG
- en: The HTML for this visualization, like the rest of these D3 examples is very
    simple. We have `Raleway` and Bootstrap in the head. Then there's a block of CSS
    at the top to add some text styles, as well as a small definition to add a stroke
    color to the small ticks that show the scale numbers along the outer edge of the
    circle.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, there''s an `H1` with a legend describing the visualization.
    Then we include just the main D3 file and our visualization file. Everything important
    happens in `chord.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Let's start looking at `chord.js` by looking at the data. The top of the file
    has hardcoded data for the entire visualization. This is a distillation of a much
    larger dataset and in the original version of this visualization, there was a
    lot of code written to create this data in the specific format required for the
    visualization. The code to generate this data is available on GitHub along with
    the rest of the source code for the book.
  prefs: []
  type: TYPE_NORMAL
- en: A chord diagram requires a *square matrix*. This is an array of arrays where
    the total number of members in the array matches the total number of members in
    the child arrays and you can map between them. In our example, the parent array
    represents a *departure* station and the values of the child arrays represent
    the total trips to each *arrival* station. The indices of the child arrays match
    up to the indices of the parent array. A departure station can also be an arrival
    station.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `names` `const` holds the names for each departure station, matched to
    the index of the departure station in the `matrix` array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Now that we've got the data sorted out, let's start to take a look at how we
    generate the actual visualization. The first five blocks of code are all for setup.
    This is what you do with D3, in general, and this one is a little more complicated
    than others so there's more need to do the setup.
  prefs: []
  type: TYPE_NORMAL
- en: The first block involves just the creation of consts for various metrics that
    are required for the visualization. `width` and `height` are common to all of
    our D3 examples. `radius` is a calculated value that represents the full radius
    of a circle that would fit in a square created by the height and width. The `padding`
    const is used to calculate the `outerRadius` of the actual circle of the visualization.
    We then use `outerRadius` to calculate `innerRadius`.
  prefs: []
  type: TYPE_NORMAL
- en: Following that, we will start to work directly with D3\. The first call is to
    `d3.chord`, the result of which is stored in a const, `chord`. `chord` is a loaded
    method that will generate a chord diagram with our settings. The first setting,
    `padAngle`, is a `radians` argument indicating the space between the `arc`s. With
    a complicated visualization like this, it's nice to have a little space between
    the `arc`s in order to bring some clarity to the separate sections. The second
    setting indicates whether or not we want to sort the sub-groups. In our case,
    we do want that, so we pass in `d3.descending` as the predefined sort.
  prefs: []
  type: TYPE_NORMAL
- en: The next variable, `arc`, loads up an instance of `d3.arc` with our calculated
    `innerRadius` and `outerRadius`, just like the donut chart. Once you start to
    think about these things as components you can fit together, possibilities open
    up.
  prefs: []
  type: TYPE_NORMAL
- en: Following that, we will create an instance of D3 `ribbon` with `innerRadius`
    as the only configuration setting, passed in as an argument to the `radius` method.
    This method is used with the `chord` method to create the core of the visualization,
    joining the two ends of the ribbons that connect, which, in our example, are the
    departure and arrival stations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we create a `color` scale to map the stations to a rainbow set of
    colors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Now that we've set all of that up, it's time to work on getting the visualization
    on the screen. The first block should be very familiar at this point. In it we
    select the `#target` element, append an SVG element, and then set its `width`
    and `height`.
  prefs: []
  type: TYPE_NORMAL
- en: The next block should be mostly familiar as well. In it we add a `g` group to
    the SVG element, and then translate it to the center of the screen. The interesting
    bit here is a call to `datum`, which is a method very similar to `data`, except
    it propagates the data all the way down the tree. Here we pass in our instance
    of `chord`, along with our `matrix`, and the `chord` method returns the building
    blocks for our data visualization.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final block in this section creates the groups that will hold our arc sections,
    paths, and group ticks. We enter the `enter` selection and append a child `g`
    element for the each item of `matrix`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: At this point, we've done *all* of our setup. It's time, now, to actually draw
    some elements onto the screen.
  prefs: []
  type: TYPE_NORMAL
- en: The first sections added to the visualization are the `arc`s. This pattern will
    be familiar to you from the donut chart. This is exactly the same pattern; just
    here it's part of a larger visualization.
  prefs: []
  type: TYPE_NORMAL
- en: The `group` variable is *already part of an* Enter selection so both this and
    the next section, where we add the legends, are already operating on the full
    dataset.
  prefs: []
  type: TYPE_NORMAL
- en: First we append a `path` and we set the `d` attribute of the `path` with the
    result of our call to `arc`. This returns angles for the start and end of the
    slice. Then we give it a `fill` and a `stroke`. The `stroke` provides our first
    glimpse of another one of D3's utilities. D3.color ([https://github.com/d3/d3-color](https://github.com/d3/d3-color)) offers
    up several options to work with colors. Here, we're using `d3.color.darker` to
    return a slightly darker shade of the color chosen for the `arc` in question,
    in order to give it just enough contrast to show the edges. Finally, we add two
    event handlers that will allow a user to mouse over this station's arc and fade
    all other station's arcs and ribbons. This will allow them to examine this specific
    station's connections without any of the other stations getting in the way. We'll
    talk more about that feature later on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next we add the ribbons. This is a very similar pattern to the `arc`. We start
    with the core `g` group, and append a new group to it, adding a class of ribbons.
    Then we call `selectAll("path")` to get a selection, call `data` to it to apply
    the chord data, and then we go into the `enter` selection to build out the ribbons.
    For each member of the dataset, we append a new `path` and set the path''s `d`
    attribute with a call to `ribbon`. The return value of `ribbon` creates a path
    that connects two angles on one side of the `arc` to two angles on the other side
    of the `arc`. After that, we set the `stroke` and `fill` in the exact same manner
    that we did with the arcs, so everything matches up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: At this point, the visualization is drawn onto the screen. We can still make
    it better though, so let's do that.
  prefs: []
  type: TYPE_NORMAL
- en: The next section adds the small label for each station. As before, we're already
    in an enter selection, so we're already operating on the correct dataset. The
    first call in this chain is to `each`, which allows us to run a function on each
    member of the selection. The `callback` function passed in adds a new property
    to the dataset, `angle`. `angle` is calculated by adding together the start angle
    and finishing angle of the `arc` and dividing it by two, getting the middle of
    the `arc`. We'll use that angle to place the labels in the very next call.
  prefs: []
  type: TYPE_NORMAL
- en: The labels we did with the donut chart sat on top of the `arc`. That won't actually
    look all that great with the chord diagram that we have set up and the long text
    labels we have, so we want to move the labels off of the circle. We do that with
    some trigonometry.
  prefs: []
  type: TYPE_NORMAL
- en: The following diagram shows how this works. All of these `text` elements are
    in a group that is in the center of the SVG element. We're looking to move them
    to their new position, outside the circle in line with the middle of the arc they
    are labeling. To do that we take the `d.angle` property that we calculated and
    use that as the hypotenuse (longest side) of a right-angled triangle. Once we've
    got that angle, we can calculate the sine (the ratio of the length of the opposite
    side to the length of the hypotenuse) and the cosine (the ratio of the length
    of the adjacent side to the length of the hypotenuse). Once we have those ratios,
    we simply multiply them by the `outerRadius` (plus a few extra pixels to give
    it some room) to get the length of the adjacent and opposite sides of the triangle.
    We use those values as the *x* and *y* needed to translate the text elements to
    their new position.
  prefs: []
  type: TYPE_NORMAL
- en: 'This technique will come in handy, all the time:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/530b6391-6d4b-4469-8e6c-c1f362eef330.png)'
  prefs: []
  type: TYPE_IMG
- en: The next section adjusts the `text-anchor` property based on the position of
    the text element on the `arc`. If it's greater than halfway (there are two PI
    radians in a circle, so `Math.PI` is equivalent to halfway around the circle),
    then we need to set `text-anchor` to `end` in order to balance them with the labels
    on the right side of the circle. If we don't adjust the text-anchor in this way,
    text elements on the left side of the visualization will overlap with the arcs
    on that side.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we append the text itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The final SVG elements we're going to do for this visualization is to add the
    group ticks and tick labels to the outer edge. These will allow us to indicate,
    in a friendly way, the scale of the visualization, in thousands.
  prefs: []
  type: TYPE_NORMAL
- en: We start off by creating a new const, `groupTick`, which sets up a new enter
    selection based on the data returned by a call to the `groupTicks` method. `groupTick` takes
    in the existing data from the chain and returns a newly manipulated set of data,
    representing a new tick for every 1,000 units. These new `groupTick` data entries
    have a new angle corresponding to the correct placement on the arc for the tick,
    and a reference to the original data's `value`. Once the `groupTick` data is returned,
    we enter the selection, append a new group and add a class, `group-tick`. Then
    we rotate the element to visually circle the outer edge and translate it to a
    point on `outerRadius`.
  prefs: []
  type: TYPE_NORMAL
- en: Once that's done, we add a six pixel long gray `line` at each tick. Remember,
    `groupTick` is still in an enter selection in this new chain so we can still operate
    on every data point even though we broke the previous chain.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we enter the selection again and `filter` the data, guarding against
    empty data and then testing whether or not the value is divisible by 5,000 with
    no remainder using the modulus (or remainder) operator ([https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Arithmetic_Operators#Remainder_()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Arithmetic_Operators#Remainder_())).
    If it is divisible by 5,000, we need to add some text to indicate that we've hit
    5,000 trips for this station. The steps to do this are as follows. Adjust the
    `x` property, to move it further off of `outerRadius`. Adjust the `dy` property
    to move the text element up just a little bit to line up better against the tick
    line.
  prefs: []
  type: TYPE_NORMAL
- en: Transform the `text` element if the angle is past the halfway point of the circle.
    Once again, we test against `Math.PI` and then, if it is past the halfway point,
    we `rotate` the text by 180 degrees and then translate it by negative 16 pixels,
    to fit it nicely along the edge of `outerRadius`. We also do the same test to
    see if the `text` element is past the halfway point of the circle and if it is
    we change the `text-anchor` property to pin the right edge of the text to the
    circle's edge. Finally, we add a class, `ticks`, to the `text` element and append
    the actual text, using `d3.formatPrefix`. `d3.formatPrefix` formats the number
    to be a friendlier representation of the value. `d3.formatPrefix` returns a function
    that formats numbers based on the supplied formatting argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, we are looking to format the numbers with SI (system of units)
    prefixes ([https://en.wikipedia.org/wiki/Metric_prefix#List_of_SI_prefixes](https://en.wikipedia.org/wiki/Metric_prefix#List_of_SI_prefixes)),
    which will convert `5000` to `5k`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The final code is the `fade` method referenced earlier. This function selects
    all elements that match the CSS selector. `.ribbons path` filters out any that
    are associated with the current selection and sets their `opacity` to the provided
    `opacity` argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The effect looks like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eaa04668-dc32-4142-9109-fe294dc6f380.png)'
  prefs: []
  type: TYPE_IMG
- en: And with that, the chord diagram is complete. It's not the most complicated
    visualization you'll ever see with D3, but it's pretty good. Along with the donut
    chart and the bar chart, these three combine to illustrate many of the important
    features of D3.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter has introduced you to the world of D3\. As deep as this chapter
    has been, it only brushed the surface of what D3 has to offer. Hopefully, you'll
    take what you've learned here and you'll continue to experiment with it in the
    months and years to come. It's a rewarding tool to master.
  prefs: []
  type: TYPE_NORMAL
- en: We have just one, short chapter, remaining in this book where we'll talk about
    some ways to optimize SVG for serving over the web. It's a vital area to at least
    have some knowledge of, especially if you're doing a lot of SVG in your site or
    application.
  prefs: []
  type: TYPE_NORMAL
