- en: Memory Management Techniques in .NET Core
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Memory management significantly affects the performance of any application.
    When the application is run, .NET CLR (Common Language Runtime) allocates many
    objects in memory, and they stay there until they are not needed, until new objects
    are created and are allocated space, or until the GC runs (as it does occasionally)
    to release unused objects and make more space available for other objects. Most
    of the job is done by the GC itself, which runs intelligently and frees up space
    for the objects by removing those that are not needed. However, there are certain
    practices that can help any application to avoid performance issues and run smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 2](part0059.html#1O8H60-84c100e6bea3438e8844d99ae7f5dfa9), *Understanding
    .NET Core Internals and Measuring Performance*, we already learned about how garbage
    collection works and how generations are maintained in .NET. In this chapter,
    we will focus on some recommended best practices and patterns that avoid memory
    leakage and make the application performant.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the topics that we will learn:'
  prefs: []
  type: TYPE_NORMAL
- en: Memory allocation process overview
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analysing memory through SOS debugging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory fragmentation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoiding finalizers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Best practices to dispose of objects in .NET Core
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory allocation process overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Memory allocation is the process of allocating objects in memory when the application
    is running. It is done by the **Common Language Runtime** (**CLR**). When the
    object is initialized (using a `new` keyword), the GC checks whether the generation
    reaches the threshold and performs garbage collection. This means that when the
    system memory reaches its limit, the GC is invoked. When an application runs,
    the GC register itself receives an event notification about the system memory,
    and when the system reaches its particular limit, it invokes garbage collection.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, we can also programmatically invoke the GC using the `GC.Collect`
    method. However, as the GC is a highly fine-tuned algorithm and automatically
    behaves as per memory allocation patterns, calling it explicitly can affect performance,
    and so it is strongly recommended that you don't use it in production.
  prefs: []
  type: TYPE_NORMAL
- en: Analysing CLR internals through the SOS debugger in .NET Core
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SOS is a debugging extension that is shipped with Windows and is available for
    Linux as well. It helps to debug .NET Core applications by providing information
    about CLR internals, especially memory allocation, the number of objects created,
    and other details about the CLR. We can use the SOS extension in .NET Core to
    debug the native machine code, which is specific to each platform.
  prefs: []
  type: TYPE_NORMAL
- en: To install the SOS extension for Windows, install the **Windows Driver Kit**
    (**WDK**) from [https://developer.microsoft.com/en-us/windows/hardware/download-kits-windows-hardware-development.](https://developer.microsoft.com/en-us/windows/hardware/download-kits-windows-hardware-development)
  prefs: []
  type: TYPE_NORMAL
- en: When the Windows Driver Kit is installed, we can use various commands to analyze
    the CLR internals about the application and identify which objects are taking
    up the most memory in the heap and optimize them accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we know that, in .NET Core, there is no executable file generated, we can
    use *dotnet cli* commands to execute the .NET Core application. The commands to
    run the .NET Core application are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dotnet run`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dotnet applicationpath/applicationname.dll`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can run either of the preceding commands to run the .NET Core application.
    In the case of the ASP.NET Core application, we can go to the root of the application
    folder, where `Views`, `wwwroot`, `Models`, `Controllers` and other files reside,
    and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00066.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'On the other hand, debugging tools usually require the `.exe` file or the process
    ID to dump information related to the CLR internals. To run the SOS debugger,
    we can go to the path where the Windows Driver Kit is installed (the directory
    path will be `{driveletter}:Program Files (x86)Windows Kits10Debuggersx64`) and
    run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a screenshot that shows you how to run the ASP.NET Core application
    using the `windbg` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00067.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'Once you run the preceding command, it will open up the Windbg window and the
    debugger, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00068.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: You can stop the debugger by clicking Debug | Break and running the `SOS` command
    to load the information about .NET Core CLR.
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the following command from the Windbg window and hit *Enter*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot is of the interface from which you can type and run
    the preceding command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00069.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, we can run the `!DumpHeap` command to see the complete statistical
    details of the objects heap:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00070.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'In the preceding screenshot, the first three columns as shown in the following
    screenshot, represent the `Address`, `Method` table and `Size` of each method:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00071.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Using the preceding information, it provides the statistics that classify the
    objects stored on the heap by their type. `MT` is the method table of that type,
    `Count` is the total number of instances of that type, `TotalSize` is the total
    memory size occupied by all the instances of that type, and `Classname` represents
    the actual type that takes up that space on the heap.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few more commands that we can use to get specific details, listed
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Switch** | **Command** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| **Statistics** | `!DumpHeap -stat` | Shows only statistical details |'
  prefs: []
  type: TYPE_TB
- en: '| **Type** | `!DumpHeap -type TypeName` | Shows the statistics for a particular
    type stored on the heap |'
  prefs: []
  type: TYPE_TB
- en: '| **Finalization queue** | `!FinalizationQueue` | Show details about the finalizers
    |'
  prefs: []
  type: TYPE_TB
- en: This tool helps developers to investigate how objects are allocated on the heap.
    In a practical scenario, we can run our application on a test or staging server
    by running this tool in the background and examining the detailed statistics about
    the objects stored on the heap for a particular point of time.
  prefs: []
  type: TYPE_NORMAL
- en: Memory fragmentation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Memory fragmentation is one of the primary causes of performance issues in .NET
    applications. When the object is instantiated, it occupies space in the memory,
    and when it is not needed, it is garbage collected, and that allocated memory
    block becomes available. This occurs when the object is allocated a larger space
    with respect to the size available in that memory segment/block and waits until
    space becomes available. Memory fragmentation is a problem that occurs when most
    of the memory is allocated in a larger number of non-contiguous blocks. When a
    larger size of object stores or occupies the larger memory block and the memory
    only contains smaller chunks of free blocks that are available, this causes fragmentation,
    and the system fails to allocate that object in memory.
  prefs: []
  type: TYPE_NORMAL
- en: .NET maintains two types of heap—namely the **small object heap** (**SOH**)
    and **large object heap** (**LOH**). Objects that are greater than 85,000 bytes
    are stored in LOH. The key difference between SOH and LOH is that in LOH there
    is no compaction being done by the GC. Compaction is the process that is done
    at the time of garbage collection, where objects stored in the SOH are moved to
    eliminate the smaller chunks of free space available and increase the total space
    available as one form of large memory chunk that can be used by other objects,
    which reduces fragmentation. However, in LOH, there is no compaction being done
    by the GC implicitly. Objects that are large in size are stored in LOH and create
    fragmentation issues. Moreover, if we compare LOH with SOH, the compaction cost
    for LOH is moderately high and involves significant overhead, where the GC needs
    twice as much memory space to move objects for defragmentation. This is another
    reason why LOH is not defragmented implicitly by the GC.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a representation of memory fragmentation, where the white
    blocks represent the unallocated memory space, and are followed by an allocated
    block:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00072.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'Suppose an object that has a size of 1.5 MB wants to be allocated some memory.
    It will not find any free space available, even though the total amount of memory
    available is 1.8 MB. The reason for this is memory fragmentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00073.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'On the other hand, if the memory is defragmented, the object can easily use
    the space that is available and will be allocated:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00074.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In .NET Core, we can perform compaction in LOH explicitly using `GCSettings`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Avoiding finalizers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using finalizers is not a good practice to use in .NET Core applications. Objects
    that use finalizers stay in memory longer and ultimately affect the application's
    performance.
  prefs: []
  type: TYPE_NORMAL
- en: Objects that are not required by the application at a particular point in time
    stay in the memory so that their `Finalizer` method can be called. For example,
    if the object is considered dead by the GC in generation 0, it will always survive
    in generation 1.
  prefs: []
  type: TYPE_NORMAL
- en: In .NET Core, CLR maintains a separate thread to run the `Finalizer` method.
    All the objects that contain the `Finalizer` method are placed into the finalization
    queue. Any object that is no longer required by the application is placed in the
    F-Reachable queue, which is then executed by the dedicated finalizer thread.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows an `object1` object that contains a `Finalizer`
    method. The `Finalizer` method is placed in the finalization queue and the object
    occupies the memory space in the Gen0 (generation 0) heap:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00075.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: When the object is no longer required, it will be moved from Gen0 (generation
    0) to Gen1 (generation 1) and from the Finalizer Queue to the F-Reachable Queue*:*
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00076.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Once the finalizer thread runs the method in the F-Reachable Queue, it will
    be removed from the memory by the GC.
  prefs: []
  type: TYPE_NORMAL
- en: 'In .NET Core, the finalizer can be defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Usually, this method is used to dispose of unmanaged objects and contains some
    code. However, a code can contain bugs that affect performance. For example, we
    have three objects that are queued in a finalization queue, which then waits for
    the first object to be released by the finalizer thread so they can be processed.
    Now, suppose that a bug in the first `Finalizer` method causes a problem and delays
    the finalizer thread in returning and processing the rest of the methods. After
    some time, more objects will come into the finalization queue and wait for the
    finalizer thread to process, impacting the applications, performance.
  prefs: []
  type: TYPE_NORMAL
- en: The best practice to dispose of objects is to use the `IDisposable` interface
    rather than implementing the `Finalizer` method. If you are using the `Finalizer`
    method for some reason, it is always good to implement the `IDisposable` interface
    as well and suppress finalization by calling the `GC.SuppressFinalize` method.
  prefs: []
  type: TYPE_NORMAL
- en: Best practices for disposing of objects in .NET Core
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have learned in the previous section that object disposal in .NET Core is
    automatically done by the GC. Nevertheless, disposing of objects in your code
    is always a good practice, and is highly recommended when you are working with
    unmanaged objects. In this section, we will explore some best practices that can
    be used to dispose of objects while writing code in .NET Core.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to the IDisposable interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`IDisposable` is a simple interface that contains one `Dispose` method, takes
    no parameter, and returns `void`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: It is used to release unmanaged resources. So if any class implements the `IDisposable`
    interface, it means that the class contains unmanaged resources and these have
    to be released by calling the `Dispose` method of the class.
  prefs: []
  type: TYPE_NORMAL
- en: What are unmanaged resources?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Any resource that is outside of your application boundary is considered an unmanaged
    resource. It could be a database, filesystem, web service, or a similar resource.
    To access the database, we use the managed .NET API to open or close the connection
    and execute various commands. However, the actual connection to the database is
    not managed. The same is true for the filesystem and web services where we use
    managed .NET APIs to interact with them, but they use unmanaged resources in the
    backend that are not managed. The `IDisposable` interface is the best fit for
    all such scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Using IDisposable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here is a simple `DataManager` class that uses a `System.Data.SQL` API to perform
    database operations on an SQL server database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we have implemented the `IDisposable` interface which,
    in turn, implemented the `Dispose` method to clean up the SQL connection object.
    We have also called the connection's `Dispose` method, which will chain up the
    process in the pipeline and close the underlying objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the calling program, we can use the `using` block to instantiate the `DatabaseManager`
    object that invokes the `Dispose` method after calling the `GetUsers` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The `using` block is a C# construct that is rendered by the compiler in a `try
    finally` block and calls the `Dispose` method in the `finally` block. So this
    means that when you are using a `using` block, we don''t have to call the `Dispose`
    method explicitly. Alternatively, the preceding code can be written in the following
    way as well, and this particular code format is internally managed by the `using`
    block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: When to implement the IDisposable interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We already know that the `IDisposable` interface should be used whenever we
    need to release unmanaged resources. However, there is a standard rule that should
    be considered when dealing with the disposal of objects. The rule states that
    if the instance within the class implements the `IDisposable` interface, we should
    implement `IDisposable` on the consuming class as well. For example, the preceding
    class `DatabaseManager` class uses `SqlConnection`, where `SqlConnection` implements
    the `IDisposable` interface internally. To address this rule, we will implement
    the `IDisposable` interface and invoke the instance's `Dispose` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a better example that invokes the `protected Dispose` method from the
    `DatabaseManager Dispose` method and passes a `Boolean` value indicating that
    the object is being disposed of. Ultimately, we will call the `GC.SuppressFinalize`
    method that tells the GC that the object is already cleaned up, preventing a redundant
    garbage collection from being called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The reason we have kept the parameterized `Dispose` method `protected` and `virtual` is
    so that the child classes if derived from the `DatabaseManager` class can override
    the `Dispose` method and clean up their own resources. This ensures that each
    class in the object tree will clean up its resources. Child classes dispose of
    their resources and call `Dispose` on the base class, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Finalizer and Dispose
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Finalizer` method is called by the GC, whereas the `Dispose` method has
    to be called by the developer explicitly in the program. The GC doesn't know if
    the class contains a `Dispose` method, and it needs to be called when the object
    is disposing to clean up the unmanaged resources. In this scenario, where we need
    to strictly clean up the resources rather than relying on the caller to call the `Dispose`
    method of the object, we should implement the `Finalizer` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a modified example of the `DatabaseManager` class that implements
    the  `Finalizer` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter was focused on memory management. We learned some best practices
    and the actual underlying process of how memory management is done in .NET. We
    explored the debugging tool, which can be used by developers to investigate an
    object's memory allocation on the heap. We also learned about memory fragmentation,
    finalizers, and how to implement a dispose pattern to clean up resources by implementing
    the `IDisposable` interface.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be creating an application following a microservices
    architecture. A microservice architecture is a highly performant and scalable
    architecture that helps the application to scale out easily. The following chapter
    provides you with a complete understanding of how an application can be developed
    following the best practices and principles.
  prefs: []
  type: TYPE_NORMAL
