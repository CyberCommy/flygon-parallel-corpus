- en: Chapter 8. Build Automation
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We saw how to create an application from the ground up using tests with Jasmine.
    However, as the application grows and the number of files starts to increase,
    managing the dependencies between them can become a little difficult.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, we have a dependency between the Investment and Stock models,
    and they must be loaded in a proper order to work. So, we do what we can; we order
    the loading of the scripts so that Stock is available once Investment is loaded.
    Here''s how we do it:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-3
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: However, that can soon become cumbersome and unmanageable.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Another problem is the number of requests the application uses to load all of
    its files; it can get up to hundreds once the application starts to grow.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: So, we have a paradox here; although it is good to break it up into small modules
    for code maintainability, it is bad for the client performance, where a single
    file is much more desirable.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: 'A perfect world would be to match the following two requirements at the same
    time:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: In development, we have a bunch of small files containing different modules
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In production, we have a single file with the content of all those modules
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clearly, what we need is some sort of build process. There are many different
    ways to achieve these goals with JavaScript, but we are going to focus on **webpack**.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Module bundler – webpack
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Webpack is a module bundler created by Tobias Koppers to help create big and
    modular frontend JavaScript applications.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Its main difference from other solutions is its support for any type of module
    system (AMD and CommonJS), languages (CoffeeScript, TypeScript, and JSX) and even
    assets (images and templates) through loaders.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: You read it right, even images; if in a React application, everything is a component,
    in a webpack project, everything is a module.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: It builds a dependency graph of all your assets, serving them in a development
    environment and optimizing them for production.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Module definition
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JavaScript is a language based on the ECMA Script specification that, until
    version 6, still didn't have a standard definition of a module. This lack of formal
    standards led to a number of competing community standards (AMD and CommonJS)
    and implementations (RequireJS and browserify).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Now, there is a standard to follow, but unfortunately there is no support for
    it in modern browsers, so which style should we use to write our modules?
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: The good news is that it is possible to use ES6 today through transpilers, which
    gives us a future-proof advantage.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: A popular transpiler is **Babel** ([http://babeljs.io/](http://babeljs.io/)),
    which we are going to use with webpack through a loader.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll see how to use it with webpack in a moment, but first it is important
    to understand what makes an ES6 module. Here is a simple definition without any
    dependency:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let''s compare it to the way we''ve been declaring modules until now. The next
    example shows how that code would be if written using the conventions presented
    in [Chapter 3](ch03.html "Chapter 3. Testing Frontend Code"), *Testing Frontend
    Code*:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The biggest difference is the lack of an IIFE. An ES6 module, by default, has
    a scope of its own, so it is impossible to pollute the global namespace by accident.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: 'The second difference is that the module value is no longer being attached
    to the global object, but instead being exported as the default module value:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Regarding a module''s dependencies, up until now, everything was globally available,
    so we passed the dependencies to the module as parameters to the IIFE, as shown
    here:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: However, as you start using ES6 modules on the project, there will be no more
    global variables. So, how do you get those dependencies into the module?
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: 'If you remember from before, the ES6 example was exporting the module value
    through the `export default` syntax. So, given a module has a value, all we have
    to do is ask for it as a dependency. Let''s add the jQuery dependency to our ES6
    module:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, `$` represents the name of the variable the dependency will be loaded
    into, and `jQuery` is the filename.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: It is also possible to export multiple values as the result of a module and
    import these values into different variables, but for the scope of this book,
    default values will suffice.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: The ES6 standard introduces a number of different constructs to the JavaScript
    language that are also beyond the scope of this book. For more information, check
    Babel's excellent documentation at [http://babeljs.io/docs/learn-es6/](http://babeljs.io/docs/learn-es6/).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: Webpack project setup
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Webpack is available as an NPM package, and its setup is very simple as it is
    going to be demonstrated in the next sections.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is important to understand the difference between NPM and Node.js. NPM is
    both a package manager and a package format, while Node.js is a platform that
    NPM modules usually run.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Managing dependencies with NPM
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We already got an embryo of a Node.js project, but as we are going to start
    using more dependencies throughout this chapter, we are going to need a formal
    definition of all the NPM packages that the project depends on.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: 'To define the project as an NPM package, and at the same time all of its dependencies,
    we need to create a special file called `package.json` at the root folder of the
    application. It can be easily created through a single command:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'It will prompt for a number of questions about the project that can all be
    left with their default values. In the end, you should have a file with content
    similar to the following output depending on your folder name:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The next step is to install all of our dependencies, which, at the moment, is
    only express.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The previous command will not only install express as described in [Chapter
    4](ch04.html "Chapter 4. Asynchronous Testing – AJAX"), *Asynchronous Testing
    – AJAX*, but will also add it as a dependency to the `package.json` file. On running
    the `npm init` command as done previously, we get the following output showing
    the `dependencies` attribute:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now that we understand how to manage the dependencies of our project, we can
    install **webpack** and **Babel** as development dependencies to start bundling
    our modules, as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The final step is to add a script in `package.json` to start the development
    server:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This allows us to start the development server with a simple command:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The actual location of the `webpack-dev-server` executable is in the `./node_modules/.bin`
    folder. So, `npm run dev` is the same as:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: It works because when you run `npm run <scriptName>`, NPM adds the `./node_modules/.bin`
    folder to the path.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: Webpack configuration
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next, we need to configure webpack so that it knows what files to bundle. This
    can be achieved by creating a `webpack.config.js` file at the root folder of the
    project. Its content should be:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'There are a few key points about this configuration file:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: The `context` directive tells webpack to look for modules in `__dirname`, meaning
    the project's root folder.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `entry` directive specifies the application's entry points. Since we are
    only doing testing at the moment, there is a single entry point named `spec` that
    refers to all of our spec files.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `output.filename` directive is here to inform the filename of each of the
    entry points. The `[name]` pattern will be replaced by an entry point name on
    compilation. So `spec.js` will actually contain all of our spec code.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `module.loaders` final directive tells webpack how to deal with different
    file types. We are using the `babel-loader` parameter here to add support for
    ES6 modules and the JSX syntax on our source files. The `exclude` directive is
    important so as not to waste compiling any dependency from the `node_modules`
    folder.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With this setup completed, you can start the development server and check what
    the transpiled bundle looks like at `http://localhost:8080/spec.js` (the filename
    defined in the configuration file).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: At this point, the webpack configuration is complete, and we can move to adapt
    the Jasmine runner to run the specs.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: The spec runner
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As stated previously, we are using webpack to compile and bundle the source
    files, so the Jasmine spec is about to become a lot simpler:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'There are a few takeaways:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: First, we no longer need the JSX transformer hack explained in the previous
    chapter; the transformation is now done by webpack and the babel-loader. As a
    result, we can use the default Jasmine boot just fine.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: Second, we've chosen to leave the test runner dependencies as global (Jasmine,
    Mock Ajax, Jasmine JQuery, and the Spec helper). Leaving them global makes things
    a lot simpler for our test runner, and we don't hurt our code as far as modularity
    is concerned.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: At this moment, trying to run the tests at `http://localhost:8080/SpecRunner.html`
    should produce a lot of fails due to missing references. That is because we still
    need to convert our specs and sources into ES6 modules.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: Testing a module
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To be able to run all the tests requires that all the source and spec files
    be converted into ES6 modules. At the specs, it means adding, as dependencies
    all the source modules:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'At the source files, it means declaring all the dependencies as well as exporting
    its default value, as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Once all the code is converted, the tests should work upon starting the development
    server and pointing the browser once again to the runner URL.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: 'Test runner: Karma'
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Remember we said back in the introduction that we could execute Jasmine without
    the need of a browser window? To do so, we are going to use **PhantomJS**, a scriptable
    headless WebKit browser (the same rendering engine that powers the Safari browser)
    and **Karma**, a test runner.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: 'The setup is very simple; using NPM, we once again install some dependencies:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The only strange dependency here is the `es5-shim`, which is used to give PhantomJS
    support for some ES5 features that it still is missing, and React requires.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is creating a configuration file, named `karma.conf.js`, for
    Karma at the project''s'' root folder:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In it, we set up the Jasmine framework and the PhantomJS browser:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Fix the browser compatibility issues on PhantomJS by loading `es5-shim`, as
    shown in the following code:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Load the test runner dependencies, which were previously global in the `SpecRunner.html`
    file, as shown in the following code:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Finally, load all the specs, as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: By now, you can remove the `SpecRunner.html` file, the spec entry in the `webpack.config.js`
    file, and the `lib/jasmine-2.1.3` folder.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the tests by invoking Karma, which will print the test results in the console,
    as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'To make it simpler to run the tests, it is possible to change the `package.json`
    project file and describe its test script:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'You can then run the tests by simply invoking the following:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Quick feedback loop
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Automated testing is all about the quick feedback loop, so imagine being able
    to have the tests running in the console and the application refreshing on the
    browser after any file change. Would that be possible? The answer is yes!
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: Watch and run the tests
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Via a simple parameter while starting Karma, we can achieve testing nirvana,
    as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Try it by yourself; run this command, change a file, and see the tests running
    automatically—like magic.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: 'Once again, we don''t want to remember these complicated commands, so let''s
    add another script to the `package.json` file:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We can run it through the following command:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Watch and update the browser
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To achieve development nirvana, we are also just a parameter away.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: 'While starting the development server, add the following to the `package.json`
    file:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Once again, try it on your browser; change a file in the text editor and the
    browser should refresh.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: You are also encouraged to update the `package.json` file with these new parameters
    so that running `npm run dev` gets you the goodness of "live reload".
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing for production
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The final step of our module bundler goal is to generate a minified and ready-for-production
    file.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: Most of the configuration is complete, missing just a few more steps.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to set up an entry point for the application, then an index
    file that will start it all, `index.js`, is to be placed inside the `src` folder
    with the contents as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We haven't covered in detail the implementation of this file in the book, so
    be sure to check the attached source files to understand better how it works.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: 'In the webpack configuration file, we need to add both an output path to indicate
    where the bundled files will be placed and the new entry file we just created,
    as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Then, all that it is left is to create a build task in our `package.json` file:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Run it and check the built files into the `dist` folder, as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Static code analysis: JSHint'
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As stated in the first chapter, JavaScript is not a compiled language, but running
    the code (as in the case of automated testing) is not the only way to check for
    errors.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: A whole class of tools is able to read source files, interpret them, and look
    for common errors or bad practices without needing to actually run the source
    files.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: 'A very popular tool is **JSHint**—a simple binary that can also be installed
    through NPM, as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: You can see that we are also installing **JSXHint**, another tool to perform
    static analysis of JSX files. It is basically a wrapper around the original JSHint
    while performing the JSX transformations.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: If you remember from the previous chapter, JSXTransformer doesn't change the
    line numbers, so a warning in a given line number on a JavaScript file will be
    in the same line number in the original JSX file.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: 'To execute them is very simple, as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'However, it is also a good idea to have them running whenever we run the tests:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The final step is configuring what errors we want JSHint and JSXHint to catch.
    Once again, we create another configuration file at the root folder of our project,
    this time called `.jshintrc`:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This is a list of option flags either being enabled or disabled, where the
    most important are the following:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '`esnext`: This flag tells us we are using the ES6 version'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unused`: This flag breaks on any unused declared variable'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`undef`: This option flag breaks on any variable being used without being declared'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is also a list of `globals` variables used by the tests to prevent errors
    due to the `undef` flag.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: Head over to the JSHint website at [http://jshint.com/docs/options/](http://jshint.com/docs/options/)
    for a complete list of options.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: 'The only missing step is preventing the linter from running in other people''s
    code (Jasmine, React, and so on). This is possible by simply creating a file with
    the folders it should ignore. This file called `.jshintignore` should contain:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '`node_modules`'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lib`'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To run the static analysis and all the tests is now as simple as this:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Continuous integration – Travis-CI
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have created a great deal of automation around the project, which is great
    for onboarding a new developer on the team; running the test is just two commands
    away:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: However, that is not the only advantage; we can have the tests running via these
    same two commands while on a continuous integration environment.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate a possible setup, we are going to use Travis-CI ([https://travis-ci.org](https://travis-ci.org)),
    a free solution for open source projects.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: Before we can start, it is required that you have a GitHub ([https://github.com/](https://github.com/))
    account and that the project is already hosted there. I expect that you are already
    familiar with git ([http://www.git-scm.com/](http://www.git-scm.com/)) and GitHub.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: Once you are ready, we can start the Travis-CI setup.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Adding a project to Travis-CI
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we can add Travis-CI support to the project, first we need to add the
    project to Travis-CI.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: Go to the Travis-CI website at [https://travis-ci.org](https://travis-ci.org)
    and click on **Sign in with GitHub** in the top-right corner.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter your GitHub credentials and once you have signed in, it should show you
    the list with all your repositories:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 输入您的GitHub凭据，一旦您登录，它应该显示您所有存储库的列表：
- en: If your repository doesn't show up, you can click on the **Sync Now** button
    to make Travis-CI update the list.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的存储库没有显示出来，您可以点击**立即同步**按钮，让Travis-CI更新列表。
- en: Once your repository appears, enable it by clicking on the switch. This will
    set up hooks on your GitHub project, so Travis-CI gets notified on any change
    pushed to the repository.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您的存储库出现，点击开关启用它。这将在您的GitHub项目上设置钩子，因此Travis-CI会在对存储库进行任何更改时收到通知。
- en: Project setup
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 项目设置
- en: Setting up a Travis-CI project couldn't be simpler. Since we have our build
    process and tests all scripted, all we have to do is tell Travis-CI what runtime
    it should use.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 设置Travis-CI项目再简单不过了。因为我们的构建过程和测试都已经脚本化，我们所要做的就是告诉Travis-CI应该使用什么运行时。
- en: Travis-CI knows that Node.js project dependencies are installed through `npm
    install` and that tests are run through `npm test`, so there is no extra step
    to get our tests running.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Travis-CI知道Node.js项目依赖项是通过`npm install`安装的，并且测试是通过`npm test`运行的，因此没有额外的步骤来运行我们的测试。
- en: 'Create a new file at the project root directory called `.travis.yml` and configure
    the language for Travis as Node.js:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目根目录创建一个名为`.travis.yml`的新文件，并将Travis的语言配置为Node.js：
- en: '[PRE41]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: And that is all there is to it.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。
- en: The steps taken to use Travis-CI were pretty straightforward, and it should
    be pretty simple to apply these same concepts to other continuous integration
    environments, such as Jenkins ([http://jenkins-ci.org/](http://jenkins-ci.org/)).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Travis-CI的步骤非常简单，将这些概念应用到其他持续集成环境，比如Jenkins（[http://jenkins-ci.org/](http://jenkins-ci.org/)）应该也很简单。
- en: Summary
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, I hope to have showed you the power of automation and how we
    can use scripts to make our life easier. You learned about webpack and how it
    can be used to manage the dependencies between your modules and help you generate
    the production code (packed and minified).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我希望向您展示自动化的力量，以及我们如何使用脚本来使生活更轻松。您了解了webpack以及它如何用于管理模块之间的依赖关系，并帮助您生成生产代码（打包和压缩）。
- en: The power of static code analysis in helping us find bugs even before the code
    runs.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 静态代码分析的力量帮助我们在代码运行之前甚至找到错误。
- en: You have also seen how to run your specs headlessly, and even automatically,
    letting you focus on the code editor all the time.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 您还看到了如何在无头模式下甚至自动运行您的规范，让您始终专注于代码编辑器。
- en: Finally, we have seen how simple it is to use a continuous integration environment
    and how we can use this powerful concept to keep our projectsalways tested.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们已经看到了使用持续集成环境是多么简单，以及我们如何使用这个强大的概念来保持我们的项目始终得到测试。
