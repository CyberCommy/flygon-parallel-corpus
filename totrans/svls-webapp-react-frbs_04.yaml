- en: Connecting React to Redux and Firebase
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 3](dede285d-2924-4fcf-a208-57337e4b853f.xhtml), *Authentication
    with Firebase*, we saw how React components can be built and how they manage their
    own state. In this chapter, we will take a look at how to efficiently manage the
    application state. We will explore Redux in detail and see how and when we need
    to use Redux in our React app. We will also see how we can integrate all three—React,
    Redux, and Firebase—with a sample seat booking application. It will be a general
    seat booking app, and it can be used as any seat booking, such as bus seat booking,
    a stadium seat booking, or a theater seat booking, with some minor changes in
    the data structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a list of the topics we will cover in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: React setup with React Starter Kit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integration of Firebase Realtime Database and React
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Redux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integration of React, Redux, and Firebase Realtime Database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Seat Booking Application covering all the above concepts practically
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's set up our development environment.
  prefs: []
  type: TYPE_NORMAL
- en: To set up the React development environment, you will need to have node version
    6.0 or greater.
  prefs: []
  type: TYPE_NORMAL
- en: React setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To set up our development environment, the first step will be the React setup.
    There are different options available to install React. If you already have an
    existing app and want to add React, you can install it using a package manager
    such as `npm` using this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if you are starting a new project, the easiest way to get started
    is with the React Starter Kit. Just go to the Command Prompt and execute the following
    command to install the React Starter kit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This command will install and set up the local development environment by downloading
    all the required dependencies. There are a number of benefits to have your development
    environment with node, such as optimized production builds, installing libraries
    using simple `npm` or `yarn` commands, and such.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have it installed, you can create your first app using the given command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: It will create a frontend application and will not include any backend logic
    or integration. It is just frontend and hence you can integrate it with any backend
    technology or in your existing project.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding command will take a while to download all dependencies and create
    the project, so keep patience.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the project is created, just go into that folder and run the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Once the server is started, you can access the application at `http://localhost:3000`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The start kit is the best way to start with React. However, if you are an advanced
    user, you can manually configure your project by adding React dependencies using
    the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: For this sample seat booking app, we will use the `create-react-app` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'The project structure will look as follows if you see it in the Visual Code
    editor:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/37f874ca-9617-45a8-9649-46267854875f.png)'
  prefs: []
  type: TYPE_IMG
- en: The created app structure is good enough to get started, but for our seat booking
    app, we will need to organize our source code in a better package structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we will create the different folders for actions, components, containers,
    and reducers, as shown in the following screenshot. For now, just focus on the
    `components` folder, because in that, we will put our React components. The rest
    of the folders are related to Redux, which we will see in the Redux section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/aec2a88f-30e4-4346-80ae-33af5243949d.png)'
  prefs: []
  type: TYPE_IMG
- en: It is very important to identify the components at the start of application
    development so that you can have a better code structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just to start with, we will have the following React components in our seat
    booking application:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Seat`: `Seat` Object and basic building block of the application'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SeatRow`: It represents a row of seats'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SeatList`: It represents the list of all seats'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Cart`: It represents the cart that will have information on selected seats'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that the design of components depends on the application complexity and
    data structure of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with our first component called Seat. This will be under the `components`
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: '`components/Seat.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Here, an important thing to note is that we are using JSX syntax, which we already
    saw in [chapter 2](77d4d4ec-e6e1-47c4-8b2a-8c9620341ba7.xhtml), *Integrate React
    App with Firebase*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we have defined the `Seat` component with three properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`number`: refers to the number or ID given to that seat'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`price`: refers to the amount to be charged to book this seat'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`status`: refers to the seat status if it is booked or available'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PropTypes` in React is used to validate the inputs your component receives;
    for example, the price should be a number and not a String. A warning will be
    shown in the JavaScript console if an invalid value is provided for a prop. For
    performance reasons, `PropTypes` checking will only take place in the development
    mode.'
  prefs: []
  type: TYPE_NORMAL
- en: In our seat booking app, when a user selects a seat, we need to add it to the
    cart so that the user can check out/book the ticket(s). To do so, we need to handle
    an `onClick()` for a seat. For now, we are just printing a console statement in
    the click handler function, but we will need to write a logic to push the selected
    seats to the cart. We will look into it in the later section when we will integrate
    Redux in our app.
  prefs: []
  type: TYPE_NORMAL
- en: If any seat is already booked, obviously we won't allow the user to select it
    and hence based on the status, we are disabling seats if they are booked.
  prefs: []
  type: TYPE_NORMAL
- en: Seat is our basic building block, and it will receive data from the parent component,
    which is the `SeatRow` component.
  prefs: []
  type: TYPE_NORMAL
- en: '`components/SeatRow.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: A `SeatRow` represents a row of seats. We are creating loosely coupled components
    that can be maintained easily and can be reused wherever required. Here, we are
    iterating the array of seats JSON data to render corresponding `Seat` objects.
  prefs: []
  type: TYPE_NORMAL
- en: You can see in the preceding code block that we are validating our values using
    `PropTypes`. The `PropTypes.arrayOf` represents an array of Seats and `PropTypes.shape`
    represents the `Seat` object props.
  prefs: []
  type: TYPE_NORMAL
- en: Our next component is the `SeatList` component.
  prefs: []
  type: TYPE_NORMAL
- en: '`components/SeatList.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have defined a `SeatList` component with two properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`title`: A title to be displayed for seat booking'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`children`: It represents the list of Seats'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are two important things related to proptypes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Proptypes.string.isRequired`: `isRequired` can be chained to ensure that you
    see a warning in the console if the data received is not valid.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Proptypes.node`: Node represents that anything can be rendered: number, string,
    elements, or an array (or fragment) containing these types.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next and final component in our app is `Cart`.
  prefs: []
  type: TYPE_NORMAL
- en: '`components/Cart.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Our cart component will have a button called `Checkout` to book the tickets.
    It will also show the summary of the selected seats and total payment to be done.
    As of now, we are just putting a button and a label. We will modify it once we
    integrate Firebase and Redux in our app.
  prefs: []
  type: TYPE_NORMAL
- en: So, we have our presentational components ready. Now, let's integrate Firebase
    with our application.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating Firebase Realtime Database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's time to integrate Firebase in our application. Though we have already seen
    the detailed description and features of Firebase Realtime Database in [Chapter
    2](77d4d4ec-e6e1-47c4-8b2a-8c9620341ba7.xhtml)*, Connecting React to Redux and
    Firebase, *we will see key concepts for JSON data architecture and best practices
    for the same. Firebase database stores data as a JSON tree.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take into consideration this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The database uses a JSON tree, but data stored in the database can be represented
    as certain native types to help you write more maintainable code. As shown in
    the preceding example, we have created a tree structure like `seats > seat-#`.
    We are defining our own keys, such as `seat-1`, `seat-2`, and more, but if you
    use the `push` method, it will be autogenerated.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is worth noting that Firebase Realtime Database data nesting can go up to
    32 levels deep. However, it is recommended that you avoid the nesting as much
    as possible and have the flat data structure. If you have a flattened data structure,
    it provides you with two main benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Load/Fetch data that is needed: You will fetch only the required data and not
    a complete tree, because in the case of a nested tree if you load a node, you
    will load all the children of that node too.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Security: You give limited access to data because in the case of a nested tree,
    if you give access to a parent node, it essentially means that you also grant
    access to the data under that node.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The best practices here are as listed:'
  prefs: []
  type: TYPE_NORMAL
- en: Avoid Nested Data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use Flatten data structures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create Scalable Data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s first create our Realtime Firebase database:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/9f0aa2aa-8870-49f5-9390-a237f5d58d8a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can directly create this structure on Firebase console or create this JSON
    and import it in Firebase. We have the following structure to our data:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Seats: Seats is our main node and contains a list of Seats'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Seat: Seat is an individual object that represents a seat with a unique number,
    price, and status'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can design a three-level deep nested data structure, such as `seats > row
    > seat`, for our sample application, but as mentioned in the best practices earlier,
    we should design a flattened data structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have our data designed, let''s integrate the Firebase in our application. In
    this application, instead of adding Fireabase dependency through URL, we will
    add its module using `npm`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This command will install Firebase module in our application, and we can import
    it using the following statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The import statement is ES6 feature, so if you are not aware of it, refer to
    ES6 documentation at [http://es6-features.org/](http://es6-features.org/).
  prefs: []
  type: TYPE_NORMAL
- en: We will put our DB related files in a folder called API.
  prefs: []
  type: TYPE_NORMAL
- en: '`api/firebase.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code will initialize the Firebase instance that can be used to
    connect to Firebase. For better separation of concern, we will also create a file
    called `service.js`, which will interact with our database.
  prefs: []
  type: TYPE_NORMAL
- en: '`api/service.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In this file, we have mainly defined two functions—`getSeats()` and `bookSelSeats()`—which
    are to read database for list of seats and update seats when user checks them out
    from the cart, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Firebase provides two methods—`on()` and `once()`—to read data at a path and
    listen for changes. There is a difference between the `on` and `once` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The on method: It will listen for the data changes and will receive the data
    at the specified location in the database at the time of the event. Also, it doesn''t
    return a `Promise` object.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The once method: It will be called only once and will not listen for changes.
    It will return a `Promise` object.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As we are using the once method, we get a `Promise` object returned to our component
    object, since the call from our component to the service will be async. You will
    understand it better in the following `App.js` file.
  prefs: []
  type: TYPE_NORMAL
- en: To read a static snapshot of the contents at a given path, we can use `value` event.
    This method is executed once when the listener is attached and every time the
    data changes including children. The event callback is passed a snapshot containing
    all data at that location, including child data. If there is no data, the snapshot
    returned is null.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that the `value` event will be fired every time the
    data is changed at the given path, including data changes in children. Hence,
    it is recommended that we attach the listener only at the lowest level needed
    to limit the snapshot size.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we are getting the data from Firebase Realtime Database and get all the
    seats. Once we get the data, we create a JSON object according to the format we
    need and return it.
  prefs: []
  type: TYPE_NORMAL
- en: '`App.js` will be our container component and will look like the one that follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`App.js`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see that the `App` component maintains the state. However, our
    goal is to separate the state management from our presentational component and
    use Redux for it.
  prefs: []
  type: TYPE_NORMAL
- en: So, now we have all functional pieces ready, but how will it look without proper
    design and CSS. We have to design a seat layout that is user-friendly, so let's
    apply CSS. We have a file called `App.css` for the entire app. We can separate
    them out in different files if required.
  prefs: []
  type: TYPE_NORMAL
- en: '`App.css`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We are done with our minimal seat booking app. Yay! The following are the screenshots
    of the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next screenshot shows the default layout where all the seats are available
    for booking:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/903148b7-631c-40f9-aaa0-003a43cb1cef.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following screenshot shows that the Booked tickets are marked as X, so
    the user can''t select them. It also shows that when a user selects a seat, it
    turns out to be red so that they can know which seats have been selected by them:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/fcf1691c-713f-48d0-a225-8ca629b3bd8b.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, we have our seat booking app ready where we are loading data from Firebase
    database and showing them using React. However, after looking at the preceding
    screenshot, you must be thinking that though we have selected two seats, the cart
    is empty and is not showing any data of the seats. If you remember, we haven't
    written any logic in the `seat click handler` function to add the selected seats
    in cart and hence our cart remains empty.
  prefs: []
  type: TYPE_NORMAL
- en: So, now the question would be, since `Seat` and `Cart` components are not directly
    related to each other, how will a `Seat` component communicate with the `Cart`
    component? Let's find an answer to this question.
  prefs: []
  type: TYPE_NORMAL
- en: When components are not related or are related but too far away in the hierarchy,
    we can use an external event system to notify anyone who wants to listen.
  prefs: []
  type: TYPE_NORMAL
- en: Redux is a popular choice to handle the data and events in a React application.
    It's a *simplified *version of the Flux pattern. Let's explore Redux in detail.
  prefs: []
  type: TYPE_NORMAL
- en: What is Redux?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this technological era, since the requirements for web applications have
    become increasingly complicated, the state management of an application has a
    lot of challenges at the code level. For example, in Realtime applications, a
    lot of data is stored in the cache for faster retrieval apart from the data that
    is persisted in the database. Similarly, on the UI side, due to complex User Interfaces
    such as multiple tabs, multiple routes, pagination, filters, and breadcrumbs and
    more, application state management becomes a very difficult task.
  prefs: []
  type: TYPE_NORMAL
- en: In any application, different components exist, which interact with each other
    to produce a particular output or a state. There will also be chances that this
    interaction is so complex that you lost control over the application state. For
    example, a component or a model updating another component or a model that in
    turn causes an update of another view. This type of code is difficult to manage.
    It becomes challenging to add a new feature or fix any bugs because you don't
    know when a small change will affect another working functionality.
  prefs: []
  type: TYPE_NORMAL
- en: To reduce such issues, libraries like React removed the direct DOM manipulation
    and also asynchrony. However, it is only applied to view or presentation layer.
    The state management of your data is up to the application developers. This is
    where Redux comes into the picture.
  prefs: []
  type: TYPE_NORMAL
- en: 'Redux is a framework that manages states in a JavaScript app. This is what
    the official site says:'
  prefs: []
  type: TYPE_NORMAL
- en: Redux is a predictable state container for JavaScript apps.
  prefs: []
  type: TYPE_NORMAL
- en: Redux attempts to make state mutations predictable by imposing certain restrictions
    on how and when updates can happen. We will see what these restrictions are and
    how they work shortly, but before that, let's understand the core concept of Redux.
  prefs: []
  type: TYPE_NORMAL
- en: 'Redux is very simple. When we talk about Redux, we need to remember three core
    terms: Store, Action, and Reducer. Here''s what they are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Store**: The state of your application will be managed by Store, which is
    an object that maintains the application''s state tree. Remember that there should
    be a single Store in your Redux app. Also, due to imposed restrictions, you can''t
    directly manipulate or mutate the application store.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Action**: To change something in your store, you need to dispatch an Action.
    An action is nothing but a plain JavaScript object that describes what has happened.
    Actions allow us to understand what is happening in the app and why and hence
    makes the state predictable.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Reducer**: Finally, to glue actions and state together, we write a Reducer,
    which is a simple JavaScript function that takes state and action as arguments
    and returns the new state of the app.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Since we now have a basic understanding of Redux, let’s check the three fundamental
    principles of Redux, which are as listed:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Single source of truth**: A store is simply a state container. As mentioned,
    in your React App, there should be only a single store and hence it is considered
    as source of Truth. A single object tree also makes it easy to debug the app.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**State is Read Only**: To change the state, application has to emit an Action
    that describes what has happened. No views or other functions can directly write
    to the state. This restriction prevents any unwanted state changes. Each action
    will be performed on a centralized object and in order so that we can get an up-to-date
    state at any point of time. As actions are just plain objects, we can debug and
    serialize them for testing purposes.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Changes are made with Pure Functions**: To describe transformation of the
    state tree by dispatched actions, write Pure Functions/Reducers. What does the
    term Pure Function mean? A function is pure if it returns the same value every
    time a given set of arguments is passed to it. Pure functions do not modify their
    input arguments. Instead, they use the input to calculate a value and then return
    that calculated value. Our reducers are pure functions that take state and action
    as inputs and return new state and not the mutated state. You can have as many
    reducers as you want, and it is also recommended that you split big reducers to
    smaller reducers that can manage a specific part of your application tree. Reducers
    are JavaScript functions, so you can pass additional data to them. They can be
    built like common functions, which can be used across the application of Presentational
    and Container components.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Presentational and Container components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our application, Seat List is responsible of fetching the data and rendering
    it. This is okay and works well for small or sample applications, but with this,
    we lose a few benefits of React, one of which is reusability. `SeatList` can't
    be reused easily unless under the exact same circumstances, so what's the solution?
  prefs: []
  type: TYPE_NORMAL
- en: We know that this kind of issue is common across different programming languages,
    and we have solutions in terms of Design Patterns. Similarly, the solution to
    our problem is a pattern called **Container Component pattern**.
  prefs: []
  type: TYPE_NORMAL
- en: So, instead of our React component, out Container component will take the responsibility
    of fetching the data and passing it to the corresponding subcomponent. In simple
    terms, a container fetches the data and then renders its subcomponent.
  prefs: []
  type: TYPE_NORMAL
- en: React bindings for Redux has also accepted the idea of separation of **Presentational
    and Container components. **Presentational Components are concerned about how
    things will look to the user rather than being concerned about how things will
    work. Similarly, Container components are concerned about how things work rather
    than how things look.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the comparison in this table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Presentational Components** | **Container Components** |'
  prefs: []
  type: TYPE_TB
- en: '| Concerned about the user view or how things will look | Concerned about the
    data and how things will work |'
  prefs: []
  type: TYPE_TB
- en: '| Get/read data from parent components as props | Are connected to Redux State
    |'
  prefs: []
  type: TYPE_TB
- en: '| Have DOM markup and styles on their own | Very less or no DOM markup and
    no styles on their own |'
  prefs: []
  type: TYPE_TB
- en: '| Rarely Stateful | Are often Stateful |'
  prefs: []
  type: TYPE_TB
- en: '| Handwritten | Can be handwritten or generated by React Redux |'
  prefs: []
  type: TYPE_TB
- en: 'As we now know the difference between Presentational and Container Components,
    we should know the benefits of this separation of concerns:'
  prefs: []
  type: TYPE_NORMAL
- en: Reusability of components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can reduce the duplicate code and have more manageable applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Different teams, such as Designers and JS/Application developers can work parallelly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before we start integrating Redux into our app, let's go through the basic building
    blocks and API of Redux.
  prefs: []
  type: TYPE_NORMAL
- en: Basics of Redux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Redux is quite simple, so don't be afraid by just looking at the fancy terms
    such as Reducers, Actions, and such. We will go through the basic building blocks
    of Redux application, and you will also feel the same.
  prefs: []
  type: TYPE_NORMAL
- en: Actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we saw at the beginning of the chapter, an action is nothing but a plain
    JavaScript object that describes what has happened. To change the state is to
    emit an action that describes what has happened. Also, for store, actions are
    only the source of truth or information.
  prefs: []
  type: TYPE_NORMAL
- en: Here's an example action creator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each action type should be defined as a constant:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `type` of an action describes the kind of the action that has occurred.
    If your application is large enough, you may separate out the action types as
    string constants to a separate module/file and use it in actions.
  prefs: []
  type: TYPE_NORMAL
- en: Now, you might be having a question—what should be the structure of my action
    ? We
  prefs: []
  type: TYPE_NORMAL
- en: have here type and then have directly added rows. The answer to your question
    is that except the type, you can have any structure of your action. However, there
    is a standard for defining an action.
  prefs: []
  type: TYPE_NORMAL
- en: An action must be a JavaScript Object and must have a type property. Also, an
    action may have an error or payload property. The payload property can be any
    type of value. In the preceding example, `rows` represent a payload.
  prefs: []
  type: TYPE_NORMAL
- en: Action creators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Action creators are functions that create actions; for example, `function fetchSeats(){return{type:FETCH_SEATS,rows}}`.
  prefs: []
  type: TYPE_NORMAL
- en: Actions often trigger a dispatch when invoked, for example, `dispatch(fetchSeats(seats))`.
  prefs: []
  type: TYPE_NORMAL
- en: Note that action creators can also be asynchronous and hence we need to handle
    async flow in our logic. It is an advanced topic and can be referred to on the
    Redux website.
  prefs: []
  type: TYPE_NORMAL
- en: Reducers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Actions only specify what has happened but do not specify what is the effect
    of that action on the application state. The reducer function specifies how the
    application state is changed. It is a pure function that takes the two arguments—previous
    state and an action—and returns the next updated state.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Things you should **never** do inside a reducer:'
  prefs: []
  type: TYPE_NORMAL
- en: Modify its arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API calls and routing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Call other non-pure functions, for example, `Date.now()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In Redux, a single object represents the application state. So, before we write
    any code, it is very important to think and decide the structure of the application
    state object.
  prefs: []
  type: TYPE_NORMAL
- en: It is recommended that we keep our state object as normalized as possible and
    avoid nesting of objects.
  prefs: []
  type: TYPE_NORMAL
- en: Store
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As described initially, the store is the main object that holds the application
    state tree. It's important to note that there will be a single store in a Redux
    application. When there is a requirement of splitting the data handling logic,
    you'll use the Reducer Composition pattern instead of creating many stores.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following methods are available for Store:'
  prefs: []
  type: TYPE_NORMAL
- en: '`getState()`: Gives the current state tree of the application'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dispatch(action)`: Used to dispatch an action'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`subscribe(listener)`: Subscribe to the store changes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`replaceReducer(nextReducer)`: It is an advanced API that replaces the currently
    used Reducer by Store'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data flow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen the core components of the Redux architecture. Now, let's understand
    how all these components actually work together. Redux architecture supports only
    single directional data flow, as illustrated in the following diagram. This means
    that all the data in an application passes through the defined workflow in a single
    direction, which makes the logic of your application more easy.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/50dda9ee-e249-413a-9f9c-166313267921.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Advanced topics in Redux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once you are through the basics, there are some advanced topics to go through,
    such as **React Router**, **Ajax and Async Actions**, and **Middleware**. We will
    not cover them here since they are out of the scope of this book. However, we
    will just look at the important topic of Middleware in brief.
  prefs: []
  type: TYPE_NORMAL
- en: By default, Redux supports synchronous data flow only. To have asynchronous
    data flow, you will need to use Middleware. Middleware is nothing but a framework
    or library that provides a wrapper for your dispatch method and allows to pass
    functions and promises rather than just actions. Middleware is being used to mainly
    support asynchronous actions. There are many middlewares out there, such as redux-thunk
    for asynchronous actions. Middlewares are also useful for logging or crash reporting.
    We will also use redux-thunk in our application. To enhance `createStore()`, we
    need to use the `applyMiddleware(...middleware)` function.
  prefs: []
  type: TYPE_NORMAL
- en: Seat booking with Redux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's enhance our seat booking app by integrating the Redux.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can install React Bindings explicitly, using the following command, since
    they are not included in Redux by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Now, we will extend our seat booking app by integrating Redux. There will be
    a lot of changes as it will impact all of our components. Here, we will start
    with our entry point.
  prefs: []
  type: TYPE_NORMAL
- en: '`src/index.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s understand our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<Provide store>`: Makes the Redux Store available to the component hierarchy.
    Note that you cannot use `connect()` without wrapping a parent component in a
    provider.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<SeatBookingApp>`: It is our parent component and will be defined under Container
    components package. It will have code similar to what we have in `App.js`, which
    we saw earlier.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Middleware`: It is like an interceptor in other languages that provides a
    third-party extension point between dispatching an action and the moment it reaches
    the reducer, for example, Logging or Logger. If you don''t apply a middleware,
    you would need to add loggers manually in all the actions and reducers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`applyMiddleware`: It tells Redux store how to handle and set up the middleware.
    Note the usage of a rest parameter (...middleware); it denotes that the `applyMiddleware`
    function accepts multiple arguments (any number) and can get them as an array.
    A key feature of Middleware is that multiple middleware can be combined together.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will also need to change our presentational components little bit as per
    Redux state management.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with Cart component.
  prefs: []
  type: TYPE_NORMAL
- en: '`components/Cart.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Our cart component receives a checkout function from the parent component that
    will dispatch checkout action along with seats, which are added in cart.
  prefs: []
  type: TYPE_NORMAL
- en: '`components/Seat.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Our Seat component receives its state from the parent component along with the `handleClick`
    function that dispatches the `ADD_TO_CART` action.
  prefs: []
  type: TYPE_NORMAL
- en: '`components/SeatList.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '`SeatList` receives seats data from the container component.'
  prefs: []
  type: TYPE_NORMAL
- en: '`components/SeatRow.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '`SeatRow` receives all seats for that particular row.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's check our container components.
  prefs: []
  type: TYPE_NORMAL
- en: '`containers/SeatBookingApp.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'It is our parent component and includes the other child container components:
    `SeatContainer` and `CartContainer`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`container/SeatCartContainer.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This container component will be interacting with the store and will pass data
    to child component—Cart.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s understand the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mapStateToProps`: It is a function that will be called each time the Store
    is updated which means component is subscribed to store updates.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`{bookSeats}`: It can be a function or an object that Redux provides so that
    container can easily pass that function to the child component on its props. We
    are passing the `bookSeats` function so that the `Checkout` button in the Cart
    component can call it.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`connect()`: Connects a React component to a Redux store.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's see our next container—`SeatContainer`.
  prefs: []
  type: TYPE_NORMAL
- en: '`containers/SeatContainer.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: As explained earlier for `CartContainer`, we will have a similar code structure
    for `SeatContainer`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will create a `constants` file that defines the constants for our `Actions`.
    Though you can directly define constants in the file where you have your action,
    it is a good practice to define the constants in a separate file as it is much
    easier to maintain the clean code.
  prefs: []
  type: TYPE_NORMAL
- en: '`constants/ActionTypeConstants.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We will have three actions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GET_SEATS`: To fetch the seats data from Firebase and populate on UI'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ADD_TO_CART`: To add the selected seats in user cart'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CHECKOUT`: Book the seats'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's define the actions in a file called `index.js`.
  prefs: []
  type: TYPE_NORMAL
- en: '`actions/index.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '**Actions** send data from your application to your store using the `dispatcher()`
    method. Here, we have two functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`fetchSeats()`: It is action creator, which creates the `GET_SEATS` action'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getAllSeats()`: It is actual action that dispatches data to store, which we
    get by calling the `getSeats()` method of our service'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Likewise, we can define our actions for the rest of the two actions: `ADD_TO_CART`
    and `CHECKOUT`.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's see the reducers. We will start with seats reducer.
  prefs: []
  type: TYPE_NORMAL
- en: '`reducers/seats.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s understand this piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`combineReducers`: We have split our Reducer into different functions—`rowIds`
    and `seatRow`—and defined the root reducer as a function that calls the reducers
    managing different parts of the state and combines them into a single object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Similarly, we will have cart reducer.
  prefs: []
  type: TYPE_NORMAL
- en: '`reducers/cart.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: It exposes reducer functions related to cart operations.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will have a final combine reducer.
  prefs: []
  type: TYPE_NORMAL
- en: '`reducers/index.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: It is a `combineReducers` for seats and cart. It also exposes some common function
    to calculate total in cart and to get the seats added in cart. That's it. We have
    finally introduced Redux to manage our state of the application, and we have our
    seat booking app ready using React, Redux, and Firebase.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored React and Firebase in depth. We talked about the
    structure of the data in Firebase database and have seen that we should avoid
    data nesting as much as possible. We have also seen the usage of the `on` and
    `once` methods with respect to data reading and also the event called 'value',
    which gets fired when data changes in your database. We also went through the
    core concepts of Redux and saw how easy it is to use Redux for the state management
    of the application. We also looked at the difference between Presentational and
    Container components and how they should be designed. Then, we talked about the
    basics of Redux and also talked briefly about the advanced topics of Redux.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, we created a seat booking application with the usage of all three—React,
    Redux and Firebase—and saw a real-life practical example of the smooth integration
    of all them.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore Firebase Admin SDK and see how to implement
    User and Access Management.
  prefs: []
  type: TYPE_NORMAL
