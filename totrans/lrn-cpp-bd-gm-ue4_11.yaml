- en: Monsters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will be adding opponents for the player. We'll be creating
    a new landscape to roam around in, with monsters that will start walking toward
    the player when they are close enough to detect them. They will also attack once
    they get within range of the player, giving you some basic gameplay.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/099dee92-144b-4d95-8154-49031935ac34.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s take a look at the topics covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Landscape
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating Monsters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monster attacks on the player
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Landscape
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We haven''t covered how to sculpt the landscape in this book yet, so we''ll
    do that here. First, you must have a landscape to work with. To do that, follow
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start a new file by navigating to File | New Level.... You can choose an empty
    level or a level with a sky. I chose the one without the sky in this example.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To create a landscape, we have to work from the Modes panel. Make sure that
    the Modes panel is displayed by navigating to Window | Modes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/8a3fa3b5-85bb-480e-a634-504b05e0fe5e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'A landscape can be created in three steps, which are shown in the following
    screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/94d517c5-c8a8-4b22-af61-ae788248c780.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The three steps are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Click on the landscape icon (the picture of the mountains) in the Modes panel
  prefs:
  - PREF_OL
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the Manage button
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the Create button in the lower right-hand corner of the screen
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You should now have a landscape to work with. It will appear as a gray, tiled
    area in the main window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7a6f7cb0-afd0-4851-ac58-07423d5fd68e.png)'
  prefs: []
  type: TYPE_IMG
- en: The first thing you will want to do with your landscape scene is add some color
    to it. What's a landscape without colors?
  prefs: []
  type: TYPE_NORMAL
- en: 'Click anywhere on your gray, tiled landscape object. In the Details panel on
    the right, you will see that it is populated with information, as shown in the
    following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d385810c-148a-4e9e-8c31-ac63d7f20a8b.png)'
  prefs: []
  type: TYPE_IMG
- en: Scroll down until you see the Landscape Material property. You can select the M_Ground_Grass
    material for a realistic-looking ground.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a light to the scene. You should probably use a directional light so that
    all of the ground has some light on it. We went over how to do this in [Chapter
    8](2f46e9ad-37ad-433a-bf6b-ba297c65565d.xhtml), *Actors and Pawns*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sculpting the landscape
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A flat landscape can be boring. We should at least add some curves and hills
    to the place. To do so, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the Sculpt button in the Modes panel:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/08ac4743-6ac4-4870-951b-963bf391d7e9.png)'
  prefs: []
  type: TYPE_IMG
- en: The strength and size of your brush are determined by the Brush Size and Tool
    Strength parameters in the Modes window.
  prefs: []
  type: TYPE_NORMAL
- en: Click on your landscape and drag the mouse to change the height of the turf.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once you''re happy with what you''ve got, click on the Play button to try it
    out. The resultant output can be seen in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/1930fd27-8065-41f2-ba2c-671e3ad97354.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Play around with your landscape and create a scene. What I did was lower the
    landscape around a flat ground plane so that the player has a well-defined flat
    area to walk on, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/cdb0d0a7-010b-4ffc-93f4-7aaeeed000db.png)'
  prefs: []
  type: TYPE_IMG
- en: Feel free to do whatever you like with your landscape. You can use what I'm
    doing here as inspiration, if you like.
  prefs: []
  type: TYPE_NORMAL
- en: I recommend that you import assets from ContentExamples or from StrategyGame
    so that you can use them inside your game. To do this, refer to the *Importing
    assets* section in [Chapter 10](45ff2a5d-da41-49dd-90af-8be3fb8c30d5.xhtml), *Inventory
    System and Pickup Items*. When you're done importing assets, we can proceed to
    bringing monsters into our world.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Monsters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll start programming monsters in the same way we programmed NPCs and `PickupItem`.
    We will write a base class (by deriving from character) to represent the `Monster`
    class, then derive a bunch of blueprints for each monster type. Each monster will
    have a couple of properties in common that determine its behavior. The following are
    the common properties:'
  prefs: []
  type: TYPE_NORMAL
- en: It will have a `float` variable for speed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It will have a `float` variable for the `HitPoints` value (I usually use floats
    for HP, so we can easily model HP leeching effects such as walking through a pool
    of lava).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It will have an `int32` variable for the experience gained in defeating the
    monster.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It will have a `UClass` function for the loot dropped by the monster.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It will have a `float` variable for the `BaseAttackDamage` done by each attack.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It will have a `float` variable for `AttackTimeout`, which is the amount of
    time for which the monster rests between attacking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It will have two `USphereComponents` objects: one of them is `SightSphere`—how
    far the monster can see. The other is `AttackRangeSphere`, which is how far its
    attack reaches. The `AttackRangeSphere` object is always smaller than `SightSphere`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Derive from the `Character` class to create your class for `Monster`. You can
    do this in UE4 by going to File | New C++ Class... and then selecting the Character
    option from the menu for your base class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fill out the `Monster` class with the base properties.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Make sure that you declare `UPROPERTY(EditAnywhere, BlueprintReadWrite, Category
    = MonsterProperties)` so that the properties of the monsters can be changed in
    the blueprints. This is what you should have in `Monster.h`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You will need some bare minimum code in your `Monster` constructor to get the
    monster''s properties initialized. Use the following code in the `Monster.cpp`
    file (this should replace the default constructor):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Compile and run the code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open Unreal Editor and derive a blueprint based on your `Monster` class (call
    it `BP_Monster`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we can start configuring our monster's `Monster` properties. For the skeletal
    mesh, we won't use the same model for the monster because we need the monster
    to be able to do melee attacks, and the same model does not come with a melee
    attack. However, some of the models in the Mixamo Animation Pack file have melee
    attack animations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'So, download the Mixamo Animation Pack file from the UE4 marketplace (free):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/362f9aaa-ae15-478b-b496-a3508975a84b.png)'
  prefs: []
  type: TYPE_IMG
- en: Inside the pack are some pretty gross models that I'd avoid, but others are
    quite good.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should add the Mixamo Animation Pack file to your project. It hasn''t been
    updated for a while, but you can add it by checking Show all projects and selecting
    version 4.10 from the drop-down list, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/0e166f02-471a-4ebc-a3ef-148acd63bdc0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Edit the `BP_Monster` blueprint''s class properties and select Mixamo_Adam
    (it is actually typed as Maximo_Adam in the current issue of the package) as the
    skeletal mesh. Make sure that you line it up with the capsule component. Also,
    select MixamoAnimBP_Adam as the animation blueprint:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ca4ed3fc-b5ba-466d-9847-8cf08e780dae.png)'
  prefs: []
  type: TYPE_IMG
- en: We'll modify the animation blueprint to correctly incorporate the melee attack
    animation later.
  prefs: []
  type: TYPE_NORMAL
- en: While you're editing your `BP_Monster` blueprint, change the sizes of the `SightSphere`
    and `AttackRangeSphere` objects to values that make sense to you. I made my monster's
    `AttackRangeSphere` object just big enough to be about an arm's reach (60 units)
    and his `SightSphere` object to be 25 times bigger than that (about 1,500 units).
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember that the monster will start moving toward the player once he enters
    the monster''s `SightSphere`, and the monster will start attacking the player
    once he is inside the monster''s `AttackRangeSphere` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ebed74f3-72a6-4d98-80f4-72c22542739a.png)'
  prefs: []
  type: TYPE_IMG
- en: Place a few of your `BP_Monster` instances inside your game; compile and run.
    Without any code to drive the `Monster` character to move, your monsters should
    just stand there idly.
  prefs: []
  type: TYPE_NORMAL
- en: Basic monster intelligence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In our game, we''ll add only basic intelligence to the `Monster` characters.
    The monsters will know how to do two basic things:'
  prefs: []
  type: TYPE_NORMAL
- en: Track the player and follow him
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attack the player
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The monster won't do anything else. You can have the monster taunt the player
    when the player is first seen as well, but we'll leave that as an exercise for
    you.
  prefs: []
  type: TYPE_NORMAL
- en: Moving the monster – steering behavior
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Monsters in very basic games don't usually have complex motion behaviors. Usually,
    they just walk toward the target and attack it. We'll program that type of monster
    in this game, but you can get more interesting play with monsters that position
    themselves advantageously on the terrain to perform ranged attacks and so on.
    We're not going to program that here, but it's something to think about.
  prefs: []
  type: TYPE_NORMAL
- en: In order to get the `Monster` character to move toward the player, we need to
    dynamically update the direction of the `Monster` character moving in each frame.
    To update the direction that the monster is facing, we write code in the `Monster::Tick()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Tick` function runs in every frame of the game. The signature of the `Tick`
    function is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'You need to add this function''s prototype to your `AMonster` class in your
    `Monster.h` file. If we override `Tick`, we can place our own custom behavior
    that the `Monster` character should do in each frame. Here''s some basic code
    that will move the monster toward the player during each frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You also have to add the following includes at the top of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'For `AddMovementInput` to work, you must have a controller selected under the
    AIController Class panel in your blueprint, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/65466d23-e455-432a-b7e6-7cf73d2f5dd2.png)'
  prefs: []
  type: TYPE_IMG
- en: If you have selected `None`, calls to `AddMovementInput` won't have any effect.
    To prevent this, select either the `AIController` class or the `PlayerController`
    class as your AIController Class. Make sure that you check this for every monster
    you've placed on the map.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding code is very simple. It comprises the most basic form of enemy
    intelligence—simply move toward the player by an incrementally small amount in
    each frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b7ef6c0c-c7db-4051-a3c5-9dd6eb8a64c8.png)'
  prefs: []
  type: TYPE_IMG
- en: If your monsters are facing away from the player, try changing the rotation
    of the mesh -90 degrees in the Z direction.
  prefs: []
  type: TYPE_NORMAL
- en: 'The result, after a series of frames, will be that the monster tracks and follows
    the player around the level. To understand how this works, you must remember that
    the `Tick` function is called on average about 60 times per second. What this
    means is that, in each frame, the monster moves a tiny bit closer to the player.
    Since the monster moves in very small steps, its action looks smooth and continuous
    (while in reality, it is making small jumps and leaps in each frame):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/90504cda-d36b-4541-b6f1-7d83149666b3.png)'
  prefs: []
  type: TYPE_IMG
- en: Discrete nature of tracking—a monster's motion over three superimposed frames
  prefs: []
  type: TYPE_NORMAL
- en: The reason why the monster moves about 60 times a second is because of a hardware
    constraint. The refresh rate of a typical monitor is 60 Hz, so it acts as a practical
    limiter on how many updates per second are useful. Updating at a frame rate faster
    than the refresh rate is possible, but it is not necessarily useful for games
    since you will only see a new picture once every 1/60 of a second on most hardware.
    Some advanced physics modeling simulations do almost 1,000 updates a second, but
    arguably, you don't need that kind of resolution for a game and you should reserve
    the extra CPU time for something that the player will enjoy instead, such as better
    AI algorithms. Some newer hardware boasts of a refresh rate of up to 120 Hz (look
    up gaming monitors, but don't tell your parents I asked you to blow all your money
    on one).
  prefs: []
  type: TYPE_NORMAL
- en: The discrete nature of monster motion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Computer games are discrete in nature. In the preceding screenshot of superimposed
    sequences of frames, the player is seen as moving straight up the screen, in tiny
    steps. The motion of the monster is also in small steps. In each frame, the monster
    takes one small discrete step toward the player. The monster is following an apparently
    curved path as it moves directly toward where the player is in each frame.
  prefs: []
  type: TYPE_NORMAL
- en: 'To move the monster toward the player, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: We have to get the player's position. Since the player is accessible in a global
    function, `UGameplayStatics::GetPlayerPawn`, we simply retrieve our pointer to
    the player using this function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We find the vector pointing from the `Monster` function (`GetActorLocation()`)
    that points to the player (`avatar->GetActorLocation()`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We need to find the vector that points from the monster to the avatar. To do
    this, you have to subtract the location of the monster from the location of the
    avatar, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ba693371-ca92-4022-a37f-db4bafa740c2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'It''s a simple math rule to remember, but often easy to get wrong. To get the
    right vector, always subtract the source (the starting point) vector from the
    target (the terminal point) vector. In our system, we have to subtract the `Monster`
    vector from the `Avatar` vector. This works because subtracting the `Monster`
    vector from the system moves the `Monster` vector to the origin, and the `Avatar`
    vector will be to the lower left-hand side of the `Monster` vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/28a26f5a-99e2-4765-b5d9-d592214bbbec.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Be sure to try out your code. At this point, the monsters will be running toward
    your player and crowding around him. With the preceding code that is outlined,
    they won''t attack; they''ll just follow him around, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/57fafe09-5b16-444e-82e9-518cebc00290.png)'
  prefs: []
  type: TYPE_IMG
- en: Monster SightSphere
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Right now, the monsters are not paying attention to the `SightSphere` component.
    That is, wherever the player is in the world, the monsters will move toward him
    in the current setup. We want to change that now.
  prefs: []
  type: TYPE_NORMAL
- en: To do so, all we have to do is have `Monster` respect the `SightSphere` restriction.
    If the player is inside the monster's `SightSphere` object, the monster will give
    chase. Otherwise, the monsters will be oblivious to the player's location and
    not chase the player.
  prefs: []
  type: TYPE_NORMAL
- en: 'Checking to see if an object is inside a sphere is simple. In the following
    screenshot, the point **p** is inside the sphere if the distance **d** between
    **p** and the center **c** is less than the sphere radius, **r**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9cc450f6-dc51-49ea-aa6c-e85521cf4c98.png)'
  prefs: []
  type: TYPE_IMG
- en: P is inside the sphere when d is less than r
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in our code, the preceding screenshot translates to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code adds additional intelligence to the `Monster` character.
    The `Monster` character can now stop chasing the player if the player is outside
    the monster''s `SightSphere` object. This is how the result will look:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5cf683b3-17bb-4e80-b390-fe36c15f53e8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'A good thing to do here will be to wrap up the distance comparison into a simple
    inline function. We can provide these two inline member functions in the `Monster`
    header, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: These functions return the value `true` when the passed parameter, `d`, is inside
    the spheres in question.
  prefs: []
  type: TYPE_NORMAL
- en: An inline function means that the function is more like a macro than a function.
    Macros are copied and pasted to the calling location, while functions are jumped
    to by C++ and executed at their location. Inline functions are good because they
    give good performance while keeping the code easy to read. They are reusable.
  prefs: []
  type: TYPE_NORMAL
- en: Monster attacks on the player
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a few different types of attacks that monsters can do. Depending on
    the type of the `Monster` character, a monster's attack might be melee (close
    range) or ranged (projectile weapon).
  prefs: []
  type: TYPE_NORMAL
- en: The `Monster` character will attack the player whenever the player is in its `AttackRangeSphere`
    object. If the player is out of the range of the monster's `AttackRangeSphere` object
    but the player is in the `SightSphere` object of the monster, then the monster
    will move closer to the player until the player is in the monster's `AttackRangeSphere`
    object.
  prefs: []
  type: TYPE_NORMAL
- en: Melee attacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The dictionary definition of *melee* is a confused mass of people. A melee attack
    is one that is done at a close range. Picture a bunch of *zerglings* battling
    it out with a bunch of *ultralisks* (if you're a StarCraft player, you'll know
    that both zerglings and ultralisks are melee units). Melee attacks are basically
    close range, hand-to-hand combat. To do a melee attack, you need a melee attack
    animation that turns on when the monster begins its melee attack. To do this,
    you need to edit the animation blueprint in UE4's animation editor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Zak Parrish''s series is an excellent place to get started with programming
    animations in blueprints: [https://www.youtube.com/watch?v=AqYmC2wn7Cg&list=PL6VDVOqa_mdNW6JEu9UAS_s40OCD_u6yp&index=8](https://www.youtube.com/watch?v=AqYmC2wn7Cg&list=PL6VDVOqa_mdNW6JEu9UAS_s40OCD_u6yp&index=8).'
  prefs: []
  type: TYPE_NORMAL
- en: For now, we'll just program the melee attack and then worry about modifying
    the animation in blueprints later.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a melee weapon
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are going to be three parts to defining our melee weapon. They are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The C++ code that represents it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A UE4 blueprint that connects the code and model together
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coding for a melee weapon in C++
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll define a new class, `AMeleeWeapon` (derived from `AActor`), to represent
    hand-held combat weapons (as you might have figured out by now, the A is added
    automatically to the name you use). I will attach a couple of blueprint-editable
    properties to the `AMeleeWeapon` class, and the `AMeleeWeapon` class will look
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Notice how I used a bounding box for `ProxBox` and not a bounding sphere. This
    is because swords and axes will be better approximated by boxes rather than spheres.
    There are two member functions, `Rest()` and `Swing()`, which let `MeleeWeapon`
    know what state the actor is in (resting or swinging). There's also a `TArray<AActor*>
    ThingsHit` property inside this class that keeps track of the actors hit by this
    melee weapon on each swing. We are programming it so that the weapon can only
    hit each thing once per swing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `AMeleeWeapon.cpp` file will contain just a basic constructor and some
    simple code to send damages to `OtherActor` when our sword hits it. We''ll also
    implement the `Rest()` and `Swing()` functions to clear the list of things hit.
    The `MeleeWeapon.cpp` file has the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Downloading a sword
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To complete this exercise, we need a sword to put into the model''s hand. I
    added a sword to the project called *Kilic* from [http://tf3dm.com/3d-model/sword-95782.html](http://tf3dm.com/3d-model/sword-95782.html)
    by Kaan Gülhan. The following is a list of other places where you will get free
    models:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.turbosquid.com/](http://www.turbosquid.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://tf3dm.com/](http://tf3dm.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://archive3d.net/](http://archive3d.net/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://www.3dtotal.com/](http://www.3dtotal.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Secret tip
  prefs: []
  type: TYPE_NORMAL
- en: 'It might appear at first on [TurboSquid.com](http://TurboSquid.com) that there
    are no free models. In fact, the secret is that you have to select free under
    Price:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a490b27f-7f26-432b-b5aa-42cc31a5c2f0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'I had to edit the kilic sword mesh slightly to fix the initial sizing and rotation.
    You can import any mesh in the **Filmbox** (**FBX**) format into your game. The
    kilic sword model is in the sample code package for this chapter. To import your
    sword into the UE4 editor, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on any folder you want to add the model to
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to New Asset | Import to (path)...
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the file explorer that pops up, select the new asset you want to import.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If a Models folder doesn't exist, you can create one by simply right-clicking
    on the tree view at the left and selecting New Folder in the pane on the left-hand
    side of the Content Browser tab
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'I selected the `kilic.fbx` asset from my desktop:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/45784dd7-4728-40b3-9c87-5ac514e17acb.png)'
  prefs: []
  type: TYPE_IMG
- en: Creating a blueprint for your melee weapon
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The steps to create a blueprint for your melee weapon are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Inside the UE4 editor, create a blueprint based off of `AMeleeWeapon` called
    `BP_MeleeSword`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Configure `BP_MeleeSword` to use the kilic blade model (or any blade model
    you choose), as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/cca72232-e787-4af8-b8df-e39c6920a0e5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `ProxBox` class will determine whether something was hit by the weapon,
    so we''ll modify the `ProxBox` class so that it just encloses the blade of the
    sword, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/557119be-e6aa-4e96-98b5-2f2afe4b1341.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Under the Collision Presets panel, it is important to select the NoCollision
    option for the mesh (not BlockAll). This is illustrated in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/bd4c4809-0985-44e7-91bc-afe6a6e32a7d.png)'
  prefs: []
  type: TYPE_IMG
- en: If you select BlockAll, then the game engine will automatically resolve all
    the interpenetration between the sword and the characters by pushing away things
    that the sword touches whenever it is swung. The result is that your characters
    will appear to go flying whenever a sword is swung.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sockets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A socket in UE4 is a receptacle on one skeletal mesh for another `Actor`. You
    can place a socket anywhere on a skeletal mesh body. After you have correctly
    placed the socket, you can attach another `Actor` to this socket in UE4 code.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if we want to put a sword in our monster's hand, we'd just have
    to create a socket in our monster's hand. We can attach a helmet to the player
    by creating a socket on his head.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a skeletal mesh socket in the monster's hand
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To attach a socket to the monster''s hand, we have to edit the skeletal mesh
    that the monster is using. Since we used the Mixamo_Adam skeletal mesh for the
    monster, we have to open and edit this skeletal mesh. To do so, perform the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Double-click on the Mixamo_Adam skeletal mesh in the Content Browser tab (this
    will appear as the T-pose) to open the skeletal mesh editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you don''t see Mixamo Adam in your Content Browser tab, make sure that you
    have imported the Mixamo Animation Pack file into your project from the Unreal
    Launcher app:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/38214ed6-eb3e-41ec-9713-af15d7a21f2f.png)'
  prefs: []
  type: TYPE_IMG
- en: Click on Skeleton at the top-right corner of the screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Scroll down the tree of bones in the left-hand side panel until you find the
    RightHand bone.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We''ll attach a socket to this bone. Right-click on the RightHand bone and
    select Add Socket, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/8804beca-cfb9-4430-b55d-a345d5a9b4fc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can leave the default name (RightHandSocket) or rename the socket if you
    like, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ef650814-b14d-40e9-9416-df4685a222ff.png)'
  prefs: []
  type: TYPE_IMG
- en: Next, we need to add a sword to the actor's hand.
  prefs: []
  type: TYPE_NORMAL
- en: Attaching the sword to the model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The steps to attach the sword are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: With the Adam skeletal mesh open, find the RightHandSocket option in the tree
    view. Since Adam swings with his right hand, you should attach the sword to his
    right hand.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Right-click on the RightHandSocket option, select Add Preview Asset, and find
    the skeletal mesh for the sword in the window that appears:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/4fef8179-57ae-4873-926e-6151ac4dd213.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You should see Adam grip the sword in the image of the model, on the right-hand
    side of the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/4f3f2584-be87-4dc2-9467-423e25a01453.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, click on RightHandSocket and zoom in on Adam's hand. We need to adjust
    the positioning of the socket in the preview so that the sword fits in it correctly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use the move and rotate manipulators or manually change the socket parameters
    in the Details window to line the sword up so that it fits in his hand correctly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/35148bf0-82e2-46c0-9c75-6e6e48946a84.png)'
  prefs: []
  type: TYPE_IMG
- en: A real-world tip
  prefs: []
  type: TYPE_NORMAL
- en: If you have several sword models that you want to switch in and out of the same
    `RightHandSocket`, you will need to ensure quite a bit of uniformity (lack of
    anomalies) between the different swords that are supposed to go in that same socket.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can preview your animations with the sword in the hand by going to the
    Animation tab in the top-right corner of the screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d85e7871-26ca-400d-900a-882e7f37f0df.png)'
  prefs: []
  type: TYPE_IMG
- en: However, if you launch your game, Adam won't be holding a sword. That's because
    adding the sword to the socket in Persona is for preview purposes only.
  prefs: []
  type: TYPE_NORMAL
- en: Code to equip the player with a sword
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To equip your player with a sword from the code and permanently bind it to the
    actor, instantiate an `AMeleeWeapon` instance and attach it to `RightHandSocket`
    after the monster instance is initialized. We do this in `PostInitializeComponents()`
    since, in this function, the `Mesh` object will have been fully initialized already.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `Monster.h` file, add a hook to select the `Blueprint` class name (`UClass`)
    of a melee weapon to use. Also, add a hook for a variable to actually store the
    `MeleeWeapon` instance using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Also, make sure that you add `#include "MeleeWeapon.h"` at the top of the file.
    Now, select the `BP_MeleeSword` blueprint in your monster's blueprint class.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the C++ code, you need to instantiate the weapon. To do so, we need to declare
    and implement a `PostInitializeComponents` function for the `Monster` class. In
    `Monster.h`, add a prototype declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '`PostInitializeComponents` runs after the monster object''s constructor has
    completed and all of the components of the object are initialized (including the
    blueprint construction). So, it is the perfect time to check whether the monster
    has a `MeleeWeapon` blueprint attached to it or not and to instantiate this weapon
    if it does. The following code is added to instantiate the weapon in the `Monster.cpp`
    implementation of `AMonster::PostInitializeComponents()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, make sure to put `#include "Engine/SkeletalMeshSocket.h"` at the top
    of the file. The monsters will now start with swords in hand if `BPMeleeWeapon`
    is selected for that monster''s blueprint:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c8ca07fb-67ea-4ec5-bc93-e6994e0512ef.png)'
  prefs: []
  type: TYPE_IMG
- en: Triggering the attack animation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By default, there is no connection between our C++ `Monster` class and triggering
    the attack animation; in other words, the `MixamoAnimBP_Adam` class has no way
    of knowing when the monster is in the attack state.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, we need to update the animation blueprint of the Adam skeleton (`MixamoAnimBP_Adam`)
    to include a query in the `Monster` class variable listing and check whether the
    monster is in an attacking state. We haven't worked with animation blueprints
    (or blueprints in general) in this book before, but follow these instructions
    step by step and you should see it come together.
  prefs: []
  type: TYPE_NORMAL
- en: I'll introduce blueprints terminology gently here, but I'll encourage you to
    have a look at Zak Parrish's tutorial series at [https://www.youtube.com/playlist?list=PLZlv_N0_O1gbYMYfhhdzfW1tUV4jU0YxH](https://www.youtube.com/playlist?list=PLZlv_N0_O1gbYMYfhhdzfW1tUV4jU0YxH)
    for your first introduction to blueprints.
  prefs: []
  type: TYPE_NORMAL
- en: Blueprint basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A UE4 blueprint is a visual realization of the code (not to be confused with
    how sometimes people say that a C++ class is a metaphorical blueprint of a class
    instance). In UE4 blueprints, instead of actually writing code, you drag and drop
    elements onto a graph and connect them to achieve the desired play. By connecting
    the right nodes to the right elements, you can program anything you want in your
    game.
  prefs: []
  type: TYPE_NORMAL
- en: This book does not encourage the use of blueprints since we are trying to encourage
    you to write your own code instead. Animations, however, are best worked with
    blueprints, because that is what artists and designers will know.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start writing a sample blueprint to get a feel of how they work:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the Blueprints menu bar at the top and select Open Level Blueprint,
    as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/30c64367-3938-4bd3-9bff-a4ab5a4d36ea.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The Level Blueprint option executes automatically when you begin the level.
    Once you open this window, you should see a blank slate to create your gameplay
    on, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/69ea554d-fcca-457e-9d6c-c9918fbb4acd.png)'
  prefs: []
  type: TYPE_IMG
- en: Right-click anywhere on the graph paper.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start typing `begin` and click on the Event Begin Play option from the drop-down
    list that appears.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Ensure that the Context Sensitive checkbox is checked, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/09a8efff-e8c0-4d7b-a7e2-66fe5ebd1646.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Immediately after you click on the Event Begin Play option, a red box will
    appear on your screen. It has a single white pin on the right-hand side. This
    is called the execution pin, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/856e15bb-4a78-448d-a1a5-2f62f37d9da2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The first thing that you need to know about animation blueprints is the white
    pin execution path (the white line). If you''ve seen a blueprint graph before,
    you must have noticed a white line going through the graph, as shown in the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8afd6b4b-eab7-435c-837a-957a1427358a.png)'
  prefs: []
  type: TYPE_IMG
- en: The white pin execution path is pretty much equivalent to having lines of code
    lined up and run one after the other. The white line determines which nodes will
    get executed and in what order. If a node does not have a white execution pin
    attached to it, then that node will not get executed at all.
  prefs: []
  type: TYPE_NORMAL
- en: Drag the white execution pin off Event Begin Play.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start by typing `draw debug box` in the Executable actions dialog.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select the first thing that pops up (fDraw Debug Box), as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/44282d51-4c34-4c01-bd77-187c8efa5ab9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Fill in some details for how you want the box to look. Here, I selected the
    color blue for the box, the center of the box at (0, 0, 100), the size of the
    box to be (200, 200, 200), and a duration of 180 seconds (be sure to enter a duration
    that is long enough that you can see the result), as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/83031d3b-4f34-4633-9969-fbc4a60e86fe.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, click on the Play button to realize the graph. Remember that you have to
    find the world's origin to see the debug box.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Find the world''s origin by placing a golden egg at (`0, 0`, (some `z` value)),
    as shown in the following screenshot, or try increasing the line thickness to
    make it more visible:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/0847a7b9-141e-4370-828b-fffb37162f92.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This is how the box will look in the level:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ec1eee36-0d8a-4f42-a3ad-ab2455b7b498.png)'
  prefs: []
  type: TYPE_IMG
- en: Modifying the animation blueprint for Mixamo Adam
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To integrate our attack animation, we have to modify the blueprint. Under Content
    Browser, open up `MixamoAnimBP_Adam`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing you''ll notice is that the graph has two sections above the
    Event Notifies section:'
  prefs: []
  type: TYPE_NORMAL
- en: The top section is marked as Basic Character movement....
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The bottom section says Mixamo Example Character Animation....
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Basic character movement is in charge of the walking and running movements
    of the model. We''ll be working in the Mixamo Example Character Animation with
    Attack and Jump section, which is responsible for the attack animation. We''ll
    be working in the latter section of the graph, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ebebd7b4-e25e-4b79-859c-395edd3b50d9.png)'
  prefs: []
  type: TYPE_IMG
- en: When you first open the graph, it starts out by zooming in on a section near
    the bottom. To scroll up, right-click the mouse and drag it upwards. You can also
    zoom out using the mouse wheel or by holding down the *Alt* key and the right
    mouse button while moving the mouse up.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before proceeding, you might want to duplicate the MixamoAnimBP_Adam resource
    so that you don''t damage the original, in case you need to go back and change
    something later. This allows you to easily go back and correct things if you find
    that you''ve made a mistake in one of your modifications, without having to reinstall
    a fresh copy of the whole animation package into your project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b1e64964-84fe-4a34-8d19-cac80acc6293.png)'
  prefs: []
  type: TYPE_IMG
- en: When assets are added to a project from the Unreal Launcher, a copy of the original
    asset is made, so you can modify MixamoAnimBP_Adam in your project now and get
    a fresh copy of the original assets in a new project later.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re going to do only a few things to make Adam swing the sword when he is
    attacking. Let''s do it in this order:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Delete the node that says Attacking?:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a854e233-ab67-4e0f-9f14-5235f6478623.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Rearrange the nodes, as follows, with the Enable Attack node by itself at the
    bottom:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c60e121a-d732-400c-8326-59e9c536c342.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We''re going to handle the monster that this animation is animating. Scroll
    up the graph a bit and drag the blue dot marked as Return Value in the Try Get
    Pawn Owner dialog. Drop it into your graph and, when the pop-up menu appears,
    select Cast to Monster (ensure that Context Sensitive is checked, or the Cast
    to Monster option will not appear). The Try Get Pawn Owner option gets the `Monster`
    instance that owns the animation, which is just the `AMonster` class object, as
    shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/af2cf342-af78-4cff-b678-654390089ac3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on + in the Sequence dialog and drag another execution pin from the Sequence
    group to the Cast to Monster node instance, as shown in the following screenshot.
    This ensures that the Cast to Monster instance actually gets executed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/bbee93c5-cb1f-435a-bbc1-cd9b4d36e413.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The next step is to pull out the pin from the As Monster terminal of the Cast
    to Monster node and look for the Is in Attack Range property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For this to show up, you need to go back to `Monster.h` and add the following
    line before the is in Attack Range function and compile the project (this will
    be explained a little later):'
  prefs: []
  type: TYPE_NORMAL
- en: '`UFUNCTION(BlueprintCallable, Category = Collision)`'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/17dac8e2-421b-4e46-933a-76910aa82edc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'There should automatically be a line from the white execution pin from the
    Cast to Monster node on the left-hand side of the Is in Attack Range node on the
    right-hand side. Next, drag another line from As Monster and this time look for
    Get Distance To:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d6c28419-9dd2-4087-964b-a534901f7447.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You need to add a node to get the Player character to send to the Other Actor
    node of Get Distance To. Just right-click anywhere and look for Get Player Character:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b4197cef-65b9-4ab1-a66b-2b2223366a1b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Connect the Return Value node from Get Player Character to Other Actor, and
    Return Value from Get Distance To to D in Is In Attack Range:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a346fb6f-3da4-4e9c-baf1-ad7ef4f63973.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Pull the white and red pins over to the SET node, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/35f5c1f6-8cbe-45e6-a86e-324565b2024b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The equivalent pseudocode of the preceding blueprint is something similar to
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Test your animation. The monster should swing only when it's within the player's
    range. If it doesn't work and you created a duplicate, make sure that you switched
    the `animBP` to the duplicate. Also, the default animation is shooting, not swinging
    a sword. We will be fixing that later.
  prefs: []
  type: TYPE_NORMAL
- en: Code to swing the sword
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We want to add an animation notify event when the sword is swung:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Declare and add a blueprint callable C++ function to your `Monster` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `BlueprintCallable` statement means that it will be possible to call this
    function from blueprints. In other words, `SwordSwung()` will be a C++ function
    that we can invoke from a blueprints node, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Open the Mixamo_Adam_Sword_Slash animation by double-clicking on it from your
    Content Browser (it should be in MixamoAnimPack/Mixamo_Adam/Anims/Mixamo_Adam_Sword_Slash).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find the point where Adam starts swinging his sword.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Right-click that point on the Notifies bar and select New Notify under Add
    Notify..., as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b8e6713c-cf27-4651-b2d0-95376742a1e6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Name the notification `SwordSwung`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/40f7087a-a2a0-49da-99d7-7ac61a68c4d9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The notification name should appear in your animation''s timeline, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0f5f2318-f089-4e65-abb2-28e50f1f3ce4.png)'
  prefs: []
  type: TYPE_IMG
- en: Save the animation and then open up your version of MixamoAnimBP_Adam again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Underneath the SET group of nodes, create the following graph:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e70c5fcf-6cba-47f1-bacd-2174d596cd80.png)'
  prefs: []
  type: TYPE_IMG
- en: The AnimNotify_SwordSwung node appears when you right-click in the graph (with
    Context Sensitive turned on) and start typing `SwordSwung`. The Cast To Monster
    node is again fed in from the Try Get Pawn Owner node, as in step 2 of the *Modifying
    the animation blueprint for Mixamo Adam* section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sword Swung is our blueprint-callable C++ function in the `AMonster` class (you
    will need to compile the project for this to show up).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You also need to go into the AnimGraph tab of MaximoAnimBP_Adam.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Double-click on State Machine to open that graph.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Double-click on the attacking state to open that.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the one on the left that says Play Mixamo_Adam Shooting.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Shooting is the default animation, but that''s clearly not what we want to
    happen. So, delete that and right-click and look for Play Mixamo_Adam_Sword_Slash.
    Then, click from the little icon of a person and drag it the Result of Final Animation
    Pose:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a5be2291-79fe-4c79-946c-cbebc67ae619.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you start the game now, your monsters will execute their attack animation
    whenever they actually attack. If you also override `TakeDamage` in the `AAvatar`
    class to reduce HP when the sword''s bounding box comes into contact with you,
    you will see your HP bar go down a bit (recall that the HP bar was added at the
    end of [Chapter 8](2f46e9ad-37ad-433a-bf6b-ba297c65565d.xhtml), *Actors and Pawns*,
    as an exercise):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e4885b2d-6c9b-4228-9cec-1e4a0e84cf1f.png)'
  prefs: []
  type: TYPE_IMG
- en: Projectile or ranged attacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ranged attacks usually involve a projectile of some sort. Projectiles are things
    such as bullets, but they can also include things such as lightning magic attacks
    or fireball attacks. To program a projectile attack, you should spawn a new object
    and only apply the damage to the player if the projectile reaches the player.
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement a basic bullet in UE4, we should derive a new object type. I derived
    an `ABullet` class from the `AActor` class, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ABullet` class has a couple of important members in it, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A `float` variable for the damage that a bullet does on contact
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `Mesh` variable for the body of the bullet
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `ProxSphere` variable to detect when the bullet finally hits something
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A function to be run when `Prox` is detected near an object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The constructor for the `ABullet` class should have the initialization of the
    `Mesh` and `ProxSphere` variables. In the constructor, we set `RootComponent` as
    the `Mesh` variable and then attached the `ProxSphere` variable to the `Mesh`
    variable. The `ProxSphere` variable will be used for collision checking. Collision
    checking for the `Mesh` variable should be turned off, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We initialized the `Damage` variable to `1` in the constructor, but this can
    be changed in the UE4 editor once we create a blueprint out of the `ABullet` class.
    Next, the `ABullet::Prox_Implementation()` function should deal damage to the
    actor if we collide with the other actor''s `RootComponent.` We can implement
    this by code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Bullet physics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To make bullets fly through the level, you can use UE4's physics engine.
  prefs: []
  type: TYPE_NORMAL
- en: Create a blueprint based on the `ABullet` class. I selected Shape_Sphere for
    the mesh and scaled it down to a more appropriate size. The bullet's mesh should
    have collision physics enabled, but the bullet's bounding sphere will be used
    to calculate damage.
  prefs: []
  type: TYPE_NORMAL
- en: 'Configuring the bullet to behave properly is mildly tricky, so we''ll cover
    this in four steps, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Select Mesh (Inherited) in the Components tab. The `ProxSphere` variable should
    be under the Mesh.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Details tab, check both Simulate Physics and Simulation Generates Hit
    Events.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the Collision Presets drop-down list, select Custom....
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select Collision Enabled (Query and Physics) from the Collision Enabled dropdown.
    Also, check the Collision Responses boxes, as shown; check Block for most types
    (WorldStatic, WorldDynamic, and so on) and check Overlap, but only for Pawn:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d6763116-289f-4124-b346-e15ac551212a.png)'
  prefs: []
  type: TYPE_IMG
- en: The Simulate Physics checkbox makes the `ProxSphere` property experience gravity
    and the impulse forces exerted on it. An impulse is a momentary thrust of force,
    which we'll use to drive the shot of the bullet. If you do not check the Simulation
    Generate Hit Events checkbox, then the ball will drop to the floor. What Blocking
    All Collision does is ensure that the ball can't pass through anything.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you drag and drop a couple of these `BP_Bullet` objects from the Content
    Browser tab directly into the world now, they will simply fall to the floor. You
    can kick them once they are on the floor. The following screenshot shows the ball
    object on the floor:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/28db3eff-f0db-4e40-af94-d77fa0d03978.png)'
  prefs: []
  type: TYPE_IMG
- en: However, we don't want our bullets falling on the floor. We want them to be
    shot. So, let's put our bullets in the `Monster` class.
  prefs: []
  type: TYPE_NORMAL
- en: Adding bullets to the monster class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s look at a step-by-step way to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a member to the `Monster` class that receives a blueprint instance reference.
    That''s what the `UClass` object type is for. Also, add a blueprint configurable
    `float` property to adjust the force that shoots the bullet, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Compile and run the C++ project and open your `BP_Monster` blueprint.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can now select a blueprint class under `BPBullet`, as shown in the following
    screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7bcb73ca-41ea-41f4-8b58-b8002a16b82c.png)'
  prefs: []
  type: TYPE_IMG
- en: Once you've selected a blueprint class type to instantiate when the monster
    shoots, you have to program the monster to shoot when the player is in its range.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Where does the monster shoot from? Actually, it should shoot from a bone. If
    you're not familiar with this terminology, bones are just reference points in
    the model's mesh. A model mesh is usually made up of many "bones."
  prefs: []
  type: TYPE_NORMAL
- en: 'To see some bones, open up the Mixamo_Adam mesh by double-clicking on the asset
    in the Content Browser tab, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/4bab18f9-4d0a-41ae-9488-852cb695ec28.png)'
  prefs: []
  type: TYPE_IMG
- en: Go to the Skeleton tab and you will see all the monster's bones in a tree view
    list in the left-hand side. What we want to do is select a bone from which bullets
    will be emitted. Here, I've selected the `LeftHand` option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An artist will normally insert an additional bone into the model mesh to emit
    the particle, which is likely to be on the tip of the nozzle of a gun.
  prefs: []
  type: TYPE_NORMAL
- en: Working from the base model mesh, we can get the `Mesh` bone's location and
    have the monster emit the `Bullet` instances from that bone in the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The complete monster `Tick` and `Attack` functions can be obtained using the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The `AMonster::Attack` function is relatively simple. Of course, we first need
    to add a prototype declaration in the `Monster.h` file in order to write our function
    in the `.cpp` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In `Monster.cpp`, we implement the `Attack` function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Also, make sure that you add `#include "Bullet.h"` at the top of the file. We
    leave the code that implements the melee attack as it is. Assuming that the monster
    is not holding a melee weapon, we then check whether the `BPBullet` member is
    set. If the `BPBullet` member is set, it means that the monster will create and
    fire an instance of the `BPBullet` blueprinted class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay special attention to the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This is how we add a new actor to the world. The `SpawnActor()` function puts
    an instance of `UCLASS` that you pass in `spawnLoc`, with some initial orientation.
  prefs: []
  type: TYPE_NORMAL
- en: After we spawn the bullet, we call the `AddImpulse()` function on its `ProxSphere`
    variable to rocket it forward.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, add the following line to Bullet.h:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Player knockback
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To add a knockback to the player, I added a member variable to the `Avatar`
    class called `knockback`. A knockback happens whenever the avatar gets hurt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'To figure out the direction to knock the player back when he gets hit, we need
    to add some code to `AAvatar::TakeDamage`. This overrides the version in the `AActor`
    class, so first, add this to Avatar.h:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Compute the direction vector from the attacker toward the player and store
    this vector in the `knockback` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'In `AAvatar::Tick`, we apply the knockback to the avatar''s position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Since the knockback vector reduces in size with each frame, it becomes weaker
    over time, unless the knockback vector gets renewed with another hit.
  prefs: []
  type: TYPE_NORMAL
- en: For the bullets to work, you need to set BPMelee Weapon to None. You should
    also increase the size of AttackRangeSphere and adjust Bullet Launch Impulse to
    a value that works.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored how to instantiate monsters on the screen that
    run after the player and attack him. We used different spheres to detect whether
    the monster was in sight or attack range, and added the ability to have either
    melee or shooting attacks, depending on whether or not the monster has a melee
    weapon. If you want to experiment further, you can try changing animations for
    shooting, or add an extra sphere and have the monster fire while still moving
    and switch to melee when in attack range. In the next chapter, we'll expand the
    capabilities of the monsters further by looking into advanced Artificial Intelligence
    techniques.
  prefs: []
  type: TYPE_NORMAL
