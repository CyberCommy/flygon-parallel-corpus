- en: Bash Scripting Is Fun
  prefs: []
  type: TYPE_NORMAL
- en: To complete a specific task in Linux, you will often find yourself running the
    same set of commands over and over again. This process can waste a lot of your
    precious time. In this chapter, you will learn how to create bash scripts so that
    you can be much more efficient in Linux.
  prefs: []
  type: TYPE_NORMAL
- en: Creating simple scripts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our first bash script will be a simple script that will output the line "Hello
    Friend!" to the screen. In Elliot''s home directory, create a file named `hello.sh`
    and insert the following two lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need to make the script executable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, run the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Congratulations! You have now created your first bash script! Let''s take a
    minute here and discuss a few things; every bash script must do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`#!/bin/bash`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Be executable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You have to insert `#!/bin/bash` at the first line of any bash script; the character
    sequence `#!` is referred to as a shebang or hashbang and is followed by the path
    of the bash shell.
  prefs: []
  type: TYPE_NORMAL
- en: The PATH variable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You may have noticed that I used `./hello.sh` to run the script; you will get
    an error if you omit the leading `./`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The shell can't find the command `hello.sh`. When you run a command on your
    terminal, the shell looks for that command in a set of directories that are stored
    in the `PATH` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the `echo` command to view the contents of your `PATH` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The colon character separates the path of each of the directories. You don''t
    need to include the full path of any command or script (or any executable) that
    resides in these directories. All the commands you have learned so far reside
    in `/bin` and `/sbin`, which are both stored in your `PATH` variable. As a result,
    you can run the `pwd` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'There is no need to include its full path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The good news is that you can easily add a directory to your `PATH` variable.
    For example, to add `/home/elliot` to your `PATH` variable, you can use the `export`
    command as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you don''t need the leading `./` to run the `hello.sh` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'It will run because the shell is now looking for executable files in the `/home/elliot`
    directory as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Alright! Now let''s create a few more bash scripts. We will create a script
    named `hello2.sh` that prints out "Hello Friend!" then displays your current working
    directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Shoot! I forgot to make it executable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Reading user input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s create a better version of our `hello.sh` script. We will let the user
    input his/her name and then we will greet the user; create a script named `greet.sh`
    with the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now make the script executable and then run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run the script, it will prompt you to enter your name; I entered `Elliot`
    as my name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The script greeted me with "Hello Elliot!". We used the `read` command to get
    the user input, and notice in the `echo` statement, we used a dollar sign, `$`,
    to print the value of the variable `name`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create another script that reads a filename from the user and then outputs
    the size of the file in bytes; we will name our script `size.sh`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'And never forget to make the script executable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s run the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'I used `size.sh` as the file path, and the output was 128 bytes; is that true?
    Let''s check:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Indeed it is; notice in the script the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'It stores the result of the command `du -bs $file | cut -f1` in the variable
    `filesize`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Also notice that the command `du -bs $file cut -f1` is surrounded by parentheses
    and a dollar sign (on the left); this is called command substitution. In general,
    the syntax of command substitution goes as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The result of the `command` will be stored in the variable `var`.
  prefs: []
  type: TYPE_NORMAL
- en: Passing arguments to scripts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Instead of reading input from users, you can also pass arguments to a bash
    script. For example, let''s create a bash script named `size2.sh` that does the
    same thing as the script `size.sh`, but instead of reading the file from the user,
    we will pass it to the script `size2.sh` as an argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s make the script executable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, you can run the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: You will get the same output as `size.sh`. Notice that we provided the file
    path
  prefs: []
  type: TYPE_NORMAL
- en: '`/home/elliot/size.sh` as an argument to the script `size2.sh`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We only used one argument in the script `size2.sh`, and it is referenced by
    `$1`. You can pass multiple arguments as well; let''s create another script `size3.sh`
    that takes two files (two arguments) and outputs the size of each file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now make the script executable and run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Awesome! As you can see, the first argument is referenced by `$1`, and the
    second argument is referenced by `$2`. So in general:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Using the if condition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can add intelligence to your bash script by making it behave differently
    in different scenarios. To do that, we use the conditional `if` statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'In general, the syntax of the `if condition` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, let''s create a script `empty.sh` that will examine whether a
    file is empty or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s make the script executable and also create an empty file named `zero.txt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s run the script on the file `zero.txt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the script correctly detects that `zero.txt` is an empty file;
    that''s because the test condition is true in this case as the file `zero.txt` is
    indeed zero bytes in size:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We used `-eq` to test for equality. Now if you run the script on a non-empty
    file, there will be no output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to modify the script `empty.sh` so that it displays an output whenever
    it''s passed a non-empty file; for that, we will use the `if-else` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s edit the `empty.sh` script by adding the following `else` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s rerun the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, it now works perfectly!
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use the `elif` (**else-if**) statement to create multiple test
    conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create a script `filetype.sh` that detects a file type. The script will
    output whether a file is a regular file, a soft link, or a directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s make the script executable and also create a soft link to `/tmp`
    named `tempfiles`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Now run the script on any directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'It correctly detects that `/bin` is a directory. Now run the script on any
    regular file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'It correctly detects that `zero.txt` is a regular file. Finally, run the script
    on any soft link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: It correctly detects that `tempfiles` is a soft link.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following `man` page contains all the test conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: So NEVER memorize! Utilize and make use of the man pages.
  prefs: []
  type: TYPE_NORMAL
- en: Looping in bash scripts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The ability to loop is a very powerful feature of bash scripting. For example,
    let's say you want to print out the line "Hello world" 20 times on your terminal;
    a naive approach would be to create a script that has 20 `echo` statements. Luckily,
    looping offers a smarter solution.
  prefs: []
  type: TYPE_NORMAL
- en: Using the for loop
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `for` loop has a few different syntaxes. If you are familiar with C++ or
    C programming, then you will recognize the following `for` loop syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the aforementioned C-style syntax; the following `for` loop will print
    out "Hello World" twenty times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The loop initializes the integer variable `i` to `0`, then it tests the condition
    (`i < 20`); if true, it then executes the line echo "Hello World" and increments
    the variable `i` by one, and then the loop runs again and again until `i` is no
    longer less than `20`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s create a script `hello20.sh` that has the `for` loop we just discussed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Now make the script executable and run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'It outputs the line "Hello World" twenty times as we expected. Instead of the
    C-style syntax, you can also use the range syntax with the `for` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'This will also output "Hello World" 20 times. This range syntax is particularly
    useful when working with a list of files. To demonstrate, create the following
    five files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Now let's say we want to rename the extension for all five files from `.doc`
    to
  prefs: []
  type: TYPE_NORMAL
- en: '`.document`. We can create a script `rename.sh` that has the following `for`
    loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Make the script executable and run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, it renamed all the files with the `.doc` extension to `.document`.
    Now imagine if you wanted to do this for a million files. If you don't know bash
    scripting, you would probably spend ten years doing it. We should all thank the
    Linux Gods for bash scripting.
  prefs: []
  type: TYPE_NORMAL
- en: Using the while loop
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `while` loop is another popular and intuitive loop. The general syntax
    for a `while` loop is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, we can create a simple script `numbers.sh` that prints the numbers
    from one to ten:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Make the script executable and run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The script is simple to understand; we first initialized the variable number
    to `1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we created a test condition that will keep the `while` loop running as
    long as the variable `number` is less than or equal to 10:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the body of the `while` loop, we first print out the value of the variable
    `number`, and then we increment it by one. Notice that to evaluate an arithmetic
    expression, it needs to be within double parentheses as `$((arithmetic-expression))`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Now it''s time for some fun! We will create a number guessing game. But before
    we do that, let me introduce you to a pretty cool command. You can use the shuffle
    command `shuf` to generate random permutations. For example, to generate a random
    permutation of the numbers between 1 and 10, you can run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Keep in mind that my output will most likely be different from your output because
    it is random! There is a one in a million chance that you will have the same output
    as me.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can use the `-n` option to select one number out of the permutation.
    This number will be random as well. So to generate a random number between 1 and
    10, you can run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: The output will be a random number between 1 and 10\. The `shuf` command will
    play a key role in our game. We will generate a random number between 1 and 10,
    and then we will see how many tries it will take the user (player) to guess the
    random number correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is our lovely handcrafted script `game.sh`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Now make the script executable and run it to start the game:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: It took me four tries in my first attempt at the game; I bet you can easily
    beat me!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go over our game script line by line. We first generate a random number
    between 1 and 10 and assign it to the variable `random`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Notice that you can add comments in your bash script as I did here by using
    the hash character, followed by your comment.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then print three lines that explain the game to the player:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we initialize the variable `tries` to `1` so that we can keep track of
    how many guesses the player took:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'We then enter the game loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Notice the test condition `while [ true ]` will always be `true`, and so the
    loop will keep running forever (infinite loop).
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we do in the game loop is that we ask the player to enter a
    number between 1 and 10:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'We then test to see if the number the player has entered is greater than, less
    than, or equal to the `random` number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: If `number` is bigger than `random`, we tell the player that the guess is too
    high to make it easier for the player to have a better guess next time. Likewise,
    if `number` is smaller than `random`, we tell the player the guess is too low.
    Otherwise, if it is a correct guess, then we print the total number of tries the
    player exhausted to make the correct guess, and we break from the loop.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that you need the `break` statement to exit from the infinite loop. Without
    the `break` statement, the loop will run forever.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we increment the number of `tries` by 1 for each incorrect guess (high
    or low):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: I have to warn you that this game is addictive! Especially when you play it
    with a friend to see who will get the correct guess in the least number of tries.
  prefs: []
  type: TYPE_NORMAL
- en: Using the until loop
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Both the `for` and `while` loops run as long as the test condition is `true`.
    On the flip side, the `until` loop keeps running as long as the test condition
    is `false`. That's to say, it stops running as soon as the test condition is `true`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The general syntax of an `until` loop is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, we can create a simple script `3x10.sh` that prints out the first
    ten multiples of `3`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Now make the script executable and then run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'The script is easy to understand, but you might scratch your head a little
    bit trying to understand the test condition of the `until` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'The test condition basically says: "until `counter` is greater than 10, keep
    running!"'
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that we can achieve the same result with a `while` loop that has the
    opposite test condition. You simply negate the test condition of the `until` loop
    and you will get the `while` loop equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: In mathematics, the opposite (negation) of greater than (`>`) is less than or
    equal to (`≤`). A lot of people forget the `equal to` part. Don't be one of those
    people!
  prefs: []
  type: TYPE_NORMAL
- en: Bash script functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When your scripts get bigger and bigger, things can get very messy. To overcome
    this problem, you can use bash functions. The idea behind functions is that you
    can reuse parts of your scripts, which in turn produces better organized and readable
    scripts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The general syntax of a bash function is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create a function named `hello` that prints out the line "Hello World".
    We will put the `hello` function in a new script named `fun1.sh`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Now make the script executable and run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: The script outputs the line "Hello World" three times to the terminal. Notice
    that we called (used) the function `hello` three times.
  prefs: []
  type: TYPE_NORMAL
- en: Passing function arguments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Functions can also take arguments the same way a script can take arguments.
    To demonstrate, we will create a script `math.sh` that has two functions `add`
    and `sub`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Make the script executable and then run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: The script has two functions `add` and `sub`. The `add` function calculates
    and outputs the total of any given two numbers. On the other hand, the `sub` function
    calculates and outputs the difference of any given two numbers.
  prefs: []
  type: TYPE_NORMAL
- en: No browsing for you
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will conclude this chapter with a pretty cool bash script `noweb.sh` that
    makes sure no user is having fun browsing the web on the Firefox browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Now open Firefox as a background process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, make the script executable and run the script in the background:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: The moment you run your script, Firefox will shut down. Moreover, if you run
    the script as the `root` user, none of the system users will be able to enjoy
    Firefox!
  prefs: []
  type: TYPE_NORMAL
- en: Knowledge check
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For the following exercises, open up your terminal and try to solve the following
    tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a bash script that will display the calendar of the current month.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modify your script so it displays the calendar for any year (passed as an argument).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modify your script so it displays the calendar for all the years from `2000`
    to `2020`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
