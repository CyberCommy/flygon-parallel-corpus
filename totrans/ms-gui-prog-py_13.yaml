- en: Multithreading with QTimer and QThread
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Despite the ever-increasing power of computer hardware, programs are still often
    called upon to perform tasks that take seconds, if not minutes, to complete. While
    such delays may be due to factors outside the programmer's control, it nevertheless
    reflects poorly on an application to become unresponsive while background tasks
    are running. In this chapter, we're going to learn about some tools that can help
    us to retain our application's responsiveness by deferring heavy operations or
    moving them out of the thread entirely. We'll also learn how to use a multithreaded
    application design to speed up these operations on multicore systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter is broken into the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Delayed actions with `QTimer`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multithreading with `QThread`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: High concurrency with `QThreadPool` and `QRunner`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter requires only the basic Python and PyQt5 setup you've been using
    throughout the book. You can also reference the example code at [https://github.com/PacktPublishing/Mastering-GUI-Programming-with-Python/tree/master/Chapter10](https://github.com/PacktPublishing/Mastering-GUI-Programming-with-Python/tree/master/Chapter10).
  prefs: []
  type: TYPE_NORMAL
- en: Check out the following video to see the code in action: [http://bit.ly/2M6iSPl](http://bit.ly/2M6iSPl)
  prefs: []
  type: TYPE_NORMAL
- en: Delayed actions with QTimer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Being able to delay action in a program is useful in a variety of situations.
    For example, let's say that we want a modeless **pop-up** dialog that closes itself
    after a defined number of seconds rather than waiting for a user to click on a
    button.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start by subclassing `QDialog`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Having saved a `timeout` value, we now want to override the dialog box's `show()`
    method so that it closes after that number of seconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'A naive approach might be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Python's `time.sleep()` function will halt program execution for the number
    of seconds we pass in as an argument. At first glance, it appears like this should
    do what we want—that is, show the window, pause for `timeout` seconds, and then
    hide the window.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s add some code in our `MainWindow.__init__()` method to test it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: If you run the program, you'll find that things don't go quite as expected.
    Since this dialog is modeless, it should appear alongside our main window and
    not block anything. Additionally, since we called `show()` before calling `sleep()`,
    it should display itself before pausing. Instead, you most likely got a blank
    and frozen dialog window that paused the entire program for the duration of its
    existence. So, what's happening here?
  prefs: []
  type: TYPE_NORMAL
- en: Remember from [Chapter 1](bce5f3b1-2979-4f78-817b-3986e7974725.xhtml), *Getting
    Started with PyQt,* that Qt programs have an **event loop**, which is started
    when we call `QApplication.exec()`. When we call a method such as `show()`, which
    involves many behind-the-scenes actions such as painting widgets and communicating
    with the window manager, these tasks aren't executed immediately. Instead, they
    are placed in a task queue. The event loop works through this task queue one job
    at a time until it's empty. This process is **asynchronous**, so a call to the `QWidget.show()` method
    doesn't wait for the window to be shown before it returns; it merely places the
    tasks involved in showing the widget on the event queue and returns.
  prefs: []
  type: TYPE_NORMAL
- en: Our call to the `time.sleep()` method creates an immediate blocking delay in
    the program, halting all other processing until the function exits. This includes
    halting the Qt event loop, which means that all of those drawing operations that
    are still in the queue won't happen. In fact, no events will be processed until
    `sleep()` completes. This is why the widget was not fully drawn, and why the program
    did not continue while `sleep()` was executing.
  prefs: []
  type: TYPE_NORMAL
- en: In order to work correctly, we need to place our `hide()` call on the event
    loop, so that our call to `AutoCloseDialog.show()` can return immediately and
    let the event loop handle hiding the dialog, in the same way that it handles showing
    it. But we don't want to do this right away—we want to delay its execution on
    the event queue until a certain amount of time has passed. This is what the `QtCore.QTimer`
    class can do for us.
  prefs: []
  type: TYPE_NORMAL
- en: Single shot timers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`QTimer` is a simple `QObject` subclass that can emit a `timeout` signal after
    a certain period of time.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest way to defer a single action with `QTimer` is to use the `QTimer.singleShot()`
    static method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '`singleShot()` takes two arguments: an interval in milliseconds and a callback
    function. In this case, we''re calling the `self.hide()` method after a number
    of `self.timeout` seconds (we will multiply by 1,000 to convert this into milliseconds).'
  prefs: []
  type: TYPE_NORMAL
- en: Running this script again, you should now see your dialog behaving as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Repeating timers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes in an application, we need to repeat an action at specified intervals,
    such as autosaving a document, polling a network socket, or nagging a user incessantly
    to give the application a 5-star review in the app store (well, maybe not that
    one).
  prefs: []
  type: TYPE_NORMAL
- en: '`QTimer` can handle this too, as you can see from the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we're creating a `QTimer` object explicitly rather than using
    the static `singleShot()` method. Then, we're using the `setInterval()` method
    to configure a timeout interval in milliseconds. When that interval has passed,
    the timer object will emit a `timeout` signal. By default, the `QTimer` object
    will repeatedly issue the `timeout` signal every time reaches the end of the specified
    interval. You can use the `setSingleShot()` method to convert it into a single
    shot as well, though, in general, it's easier to use the static method that we
    demonstrated in the *Single shot timers* section.
  prefs: []
  type: TYPE_NORMAL
- en: After creating the `QTimer` object and configuring the interval, we just connect
    its `timeout` signal to the `show()` method of another `AutoCloseDialog` object
    and then start the timer by calling the `start()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also stop the timer and restart it again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `QTimer.stop()` method stops the timer and the `start()` method will start
    it again from the beginning. It's worth noting that there is no `pause()` method
    here; the `stop()` method will clear any current progress and the `start()` method will
    start over from the configured interval.
  prefs: []
  type: TYPE_NORMAL
- en: Getting information from timers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`QTimer` has a few methods that we can use to extract information about the
    state of the timer. For example, let''s keep our user updated on how things are
    going with the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve set up yet another timer that will call `self.update_status()` once
    every second. `update_status()` will then query the first time for information,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `QTimer.isActive()` method tells us whether a timer is currently running,
    while `remainingTime()` tells us how many milliseconds remain until the next `timeout`
    signal.
  prefs: []
  type: TYPE_NORMAL
- en: Running this program now, you should see a status update about your next dialog
    box.
  prefs: []
  type: TYPE_NORMAL
- en: Limitations of timers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While timers allow us to defer actions to the event queue and can help to prevent
    awkward pauses in our programs, it's important to understand that functions connected
    to the `timeout` signal are still executed in—and will therefore block—the main
    execution thread.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, suppose that we have a long blocking method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'You might think that calling this method from a single shot timer will prevent
    it from locking up your application. Let''s test that theory by adding this code
    to `MainView.__init__()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Calling `singleShot()` with a `1` millisecond delay is a simple way of scheduling
    an event almost immediately. So, does it work?
  prefs: []
  type: TYPE_NORMAL
- en: Well, no, it doesn't; if you run the program, then you'll see that it locks
    up for 30 seconds. Despite the fact that we deferred the action, it's still a
    long blocking action that will freeze up the program when it runs. It may be that
    we can play with the delay value to make sure it's deferred to a more opportune
    moment (such as after the application has painted itself or after a splash screen
    displays), but sooner or later, the application will have to freeze and become
    unresponsive while the task runs.
  prefs: []
  type: TYPE_NORMAL
- en: There is a solution to such a problem, however; in the next section, *Multithreading
    with QThread*, we'll look at how to push heavy, blocking tasks like this to another
    thread so that our program can keep running without freezing.
  prefs: []
  type: TYPE_NORMAL
- en: Multithreading with QThread
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Waiting is sometimes unavoidable. Whether querying the network, accessing a
    filesystem, or running a complex computation, sometimes a program just needs time
    to complete a process. While we're waiting, though, there's no reason for our
    GUI to become completely unresponsive. Modern systems with multiple CPU cores
    and threading technology allow us to run concurrent processes, and there's no
    reason why we can't take advantage of this to make responsive GUIs. Although Python
    has its own threading library, Qt offers us the `QThread` object, which can be
    used to build multithreaded applications easily. It has the additional advantage
    of being integrated into Qt and being compatible with signals and slots.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we'll build a somewhat slow file searching tool and then use
    `QThread` to ensure that the GUI remains responsive.
  prefs: []
  type: TYPE_NORMAL
- en: The SlowSearcher file search engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to talk effectively about threading, we first require a slow process
    that can be run on a separate thread. Open a new copy of the Qt application template
    and call it `file_searcher.py`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s begin by implementing a file searching engine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re calling this `SlowSearcher` because it''s going to be deliberately non-optimized.
    It starts with defining a few signals, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The `match_found` signal will be emitted when a filename matches the search
    term and will contain the matched filename
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `directory_changed` signal will be emitted whenever we start searching in
    a new directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `finished` signal will be emitted when the whole filesystem tree has been
    searched
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we override `__init__()` just to define an instance variable called
    `self.term`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we''ll create a setter method for `term`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: If you're wondering why we're bothering with such a simple setter method when
    we could just set the variable directly, the reason for this will soon become
    apparent as we discuss some of the limitations of `QThread`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we''ll create the searching methods, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This method will be the slot that we call to start off the search process. It
    begins by locating the root directory as a `QDir` object and then calls the `_search()`
    method. Once `_search()` returns, it emits the `finished` signal.
  prefs: []
  type: TYPE_NORMAL
- en: 'The actual `_search()` method is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '`_search()` is a recursive search method. It begins by emitting the `directory_changed`
    signal to indicate that we''re searching in a new directory and then creates a
    `QDir` object for the current path. Next, it sets the `filter` property so that,
    when we query the `entryInfoList()` method, it won''t include symbolic links or
    the `.` and `..` shortcuts (this is to avoid infinite loops in the search). Finally,
    we iterate the contents of the directory retrieved by `entryInfoList()` and emit
    a `match_found` signal for each matched item. For each directory found, we run
    the `_search()` method on it.'
  prefs: []
  type: TYPE_NORMAL
- en: In this way, our method will recurse through all of the directories on the filesystem,
    looking for matches to our search term. This is not the most optimized approach,
    and intentionally so. Depending on your hardware, platform, and the number of
    files on your drive, this search can take anywhere from a few seconds to several
    minutes to complete, so it's perfect for looking at how threading can help an
    application that must execute a slow process.
  prefs: []
  type: TYPE_NORMAL
- en: In multithreading terminology, a class that performs the actual work is referred
    to as a `Worker` class. `SlowSearcher` is an example of a `Worker` class.
  prefs: []
  type: TYPE_NORMAL
- en: A non-threaded searcher
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To implement a searching application, let's add a GUI form for entering a search
    term and displaying the search results.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s call it `SearchForm`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This GUI only contains a `QLineEdit` widget for entering a term and a `QListWidget` widget
    for displaying the results. We're forwarding the `QLineEdit` widget's `returnPressed`
    and `textChanged` signals to identically named signals on the `SearchForm` object
    so that we can connect them more easily in our `MainView` method. We've also connected
    `returnPressed` to the list widget's `clear` slot so that starting a new search
    clears the results area.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `SearchForm()` method will also require a method to add a new item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This is simply a convenience method so that, once again, the main application
    doesn't have to directly manipulate the widgets in the form.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our `MainWindow.__init__()` method, we can create a searcher and form object
    and connect them, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'After creating the `SlowSearcher` and `SearchForm` objects and setting the
    form as the central widget, we connect the appropriate signals together, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The form's `textChanged` signal, which emits the string entered, is connected
    to the searcher's `set_term()` setter method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The form's `returnPressed` signal is connected to the searcher's `do_search()`
    method to trigger the search.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The searcher's `match_found` signal, which carries the pathname found, is connected
    to the form's `addResult()` method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally, let''s add two `MainWindow` methods to keep the user informed about
    the status of the search:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The first will show a status indicating that the search is finished, while the
    second will show a status indicating the current path that the searcher is searching.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back in `__init__()`, these will be connected to the searcher, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Testing our non-threaded search application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our expectation with this script is that, as we search through directories on
    the system, we'll get a steady printout of search results to the results area,
    as well as constant updates on the current directory being searched in the status
    bar.
  prefs: []
  type: TYPE_NORMAL
- en: If you run it, however, you'll find that this is not what actually happens.
    Instead, the moment the search starts, the GUI freezes up. Nothing is shown in
    the status bar and no entries appear in the list widget, even though matches are
    being printed to the console. Only when the search finally finishes do the results
    appear and the status gets updated.
  prefs: []
  type: TYPE_NORMAL
- en: To fix this, we need to introduce threading.
  prefs: []
  type: TYPE_NORMAL
- en: So, why does the program print to the console in real time but not update our
    GUI in real time? It's because `print()` is synchronous—it executes as soon as
    it's called and does not return until the text is written to the console. Our
    GUI methods, however, are asynchronous—they are queued in the Qt event queue and
    will not execute until the main event loop finishes executing the `SlowSearcher.search()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Adding threads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **thread** is an independent code execution context. By default, all of our
    code runs in a single thread, so we refer to it as a **single-threaded** application.
    Using the `QtCore.QThread` class, we can create new threads and move portions
    of our code to them, making it a **multithreaded** application.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the `QThread` object as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We start by creating a `QThread` object, and then use the `SlowSearcher.moveToThread()`
    method to move our `SlowSearcher` object to the new thread. `moveToThread()` is
    a `QObject` method inherited by any class that subclasses `QObject`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we connect the searcher's `finished` signal to the thread's `quit` slot;
    this will cause the thread to stop executing when the search is finished. Since
    the search thread isn't part of our main execution thread, it must have some way
    to quit on its own or it will continue to run after the search is over.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to call the search thread's `start()` method to begin executing
    the code and allow our main thread to interact with the `SlowSearcher` object.
  prefs: []
  type: TYPE_NORMAL
- en: This code needs to be inserted after the `SlowSearcher` object is created, but
    before any signals or slots are connected to it (we'll discuss why in the *Threading
    tips and caveats* section).
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we''re quitting the thread after each search, we need to restart the
    thread each time a new search is started. We can do this by using the following
    connection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This is all that is needed to use a thread. Run the script again and you'll
    see that the GUI is updated as the search progresses.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s recap the process, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an instance of the `Worker` class of your `QObject` object
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `QThread` object
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `Worker` class' `moveToThread()` method to move it to the new thread
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect any other signals and slots
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call the thread's `start()` method
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An alternate method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although the `moveToThread()` method of working with `QThread` is the preferred
    approach recommended by the documentation, there is another way that works perfectly
    well and, in some way, simplifies our code. This approach is to create our `Worker`
    class by subclassing `QThread` and overriding the `run()` method using our worker
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, create a copy of `SlowSearcher` and alter it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we''ve altered only three things:'
  prefs: []
  type: TYPE_NORMAL
- en: We've renamed the class to `SlowSearcherThread`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We've changed the parent class to `QThread`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We've renamed `do_search()` to `run()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Our `MainWindow.__init__()` method will now be considerably simpler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Now, we only need to connect `returnPressed` to `SlowSearcher.start()`. The
    `start()` method creates the new thread and executes the object's `run()` method
    inside the new thread. This means that, by overriding that method, we can effectively
    place that code in a new thread.
  prefs: []
  type: TYPE_NORMAL
- en: Always remember to implement `run()` but call `start()`. Don't get this mixed
    up, or your multithreading won't work!
  prefs: []
  type: TYPE_NORMAL
- en: While there are some valid use cases for such an approach, it can create subtle
    problems with the thread ownership of the object's data. Even though a `QThread`
    object provides a control interface for a secondary thread, the object itself
    lives in the main thread. When we call `moveToThread()` on a `worker` object,
    we can be assured that the `worker` object is moved entirely to the new thread.
    However, when the `worker` object is a subclass of `QThread`, those `QThread`
    parts must remain in the main thread even though the executed code is moved to
    the new thread. This can lead to subtle bugs as it is difficult to untangle which
    parts of the `worker` object are in which thread.
  prefs: []
  type: TYPE_NORMAL
- en: Ultimately, unless you have clear reasons for subclassing `QThread5`, you should
    use `moveToThread()`.
  prefs: []
  type: TYPE_NORMAL
- en: Threading tips and caveats
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous example may have made multithreaded programming seem simple, but
    that's because the code was carefully designed to avoid some of the problems that
    can arise when working with threads. In reality, retrofitting multithreading on
    a single-threaded application can be much more difficult.
  prefs: []
  type: TYPE_NORMAL
- en: One common problem is when a `worker` object gets stuck in the main thread,
    causing us to lose the benefits of multithreading. This can happen in a few ways.
  prefs: []
  type: TYPE_NORMAL
- en: For example, in our original threading script (the one that used `moveToThread()`),
    we had to move the worker to the thread before connecting any signals. If you
    try moving the threading code after the signal connections, you will find that
    the GUI locks up as though you hadn't used a thread.
  prefs: []
  type: TYPE_NORMAL
- en: 'The reason this happens is that our worker''s methods are Python methods and
    connecting to them creates a connection in Python, which must persist in the main
    thread. One way around this is to use the `pyqtSlot()` decorator to make the worker''s
    methods into true Qt slots, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Once you do this, the order won't matter because the connections will exist
    entirely between the Qt objects rather than between the Python objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also trap a `worker` object in the main thread by calling one of its
    methods directly in the main thread:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Placing the preceding lines in `__init__()` will cause the GUI to remain hidden
    until a filesystem search for `foo` has completed. Sometimes, this issue can be
    subtle; for example, the following `lambda` callback suggests that we are simply
    connecting the signal directly to the slot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: However, this connection breaks threading because the `lambda` function is itself
    part of the main thread and, therefore, the call to `search()` will be executed
    in the main thread.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, this limitation also means that you cannot use a `MainWindow`
    method as a slot to call the worker methods either; for example, we cannot run
    the following code in `MainWindow`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Using this as a callback for `returnPressed` rather than connecting the signal
    to the `worker` object's methods individually causes the threading to fail and
    the GUI to lock.
  prefs: []
  type: TYPE_NORMAL
- en: In short, it's best to constrain your interactions with the `worker` object
    to pure Qt signal and slot connections with no intermediate functions.
  prefs: []
  type: TYPE_NORMAL
- en: High concurrency with QThreadPool and QRunner
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`QThreads` are ideal for putting a single long process into the background,
    especially when we want to communicate with that process using signals and slots.
    Sometimes, however, what we need to do is run a number of computationally intensive
    operations in parallel using as many threads as possible. This can be done with
    `QThread`, but a better alternative is found in `QThreadPool` and `QRunner`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`QRunner` represents a single runnable task that we want our worker threads
    to perform. Unlike `QThread`, it is not derived from `QObject` and cannot use
    signals and slots. However, it is very efficient and is much simpler to use when
    you want many threads.'
  prefs: []
  type: TYPE_NORMAL
- en: The `QThreadPool` object's job is to manage a queue of `QRunner` objects, spinning
    up new threads to execute the objects as compute resources become available.
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate how to work with this, let's build a file hashing utility.
  prefs: []
  type: TYPE_NORMAL
- en: The file hasher GUI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our file hasher utility will take a source directory, a destination file, and
    a number of threads to use. It will use the number of threads to calculate the
    MD5 hash of each file in the directory and then write the information out to the
    destination file as it does so.
  prefs: []
  type: TYPE_NORMAL
- en: A **hashing function** such as MD5 is used to calculate a unique, fixed-length
    binary value from any arbitrary piece of data. Hashes are often used to determine
    the authenticity of a file since any change to the file will result in a different
    hash value.
  prefs: []
  type: TYPE_NORMAL
- en: Make a clean copy of your Qt template from [Chapter 4](9281bd2a-64a1-4128-92b0-e4871b79c040.xhtml),
    *Building Applications with QMainWindow,* calling it `hasher.py`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we''ll start with our GUI form class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This form is very similar to the forms we've designed in previous chapters,
    with a `submitted` signal to publish the data, `QPushButton` objects to store
    the selected files, a spin box to select the number of threads, and another push
    button to submit the form.
  prefs: []
  type: TYPE_NORMAL
- en: 'The file button callbacks will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Here, we're using `QFileDialog` static functions (which you learned about in
    [Chapter 5](61ff4931-02af-474a-996c-5da827e0684f.xhtml), *Creating Data Interfaces
    with Model-View Classes*) to retrieve a directory name to examine and a filename
    that we'll use to save the output to.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, our `on_submit()` callback is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This callback simply gathers the data from our widgets and publishes it with
    the `submitted` signal.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `MainWindow.__init__()`, create a form and make it the central widget:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: That takes care of our GUI, so let's now build the backend.
  prefs: []
  type: TYPE_NORMAL
- en: A hash runner
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `HashRunner` class will represent a single instance of the actual task that
    we're going to perform. For each file that we need to process, we'll create a
    unique `HashRunner` instance so its constructor will need to receive an input
    filename and an output filename as arguments. Its task will be to calculate the
    MD5 hash of the input file and append it along with the input filename to the
    output file.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start it by subclassing `QRunnable`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The first thing we do is create a `QMutex` object. In multithreading terminology,
    a **mutex** is an object shared between threads that can be locked or unlocked.
  prefs: []
  type: TYPE_NORMAL
- en: You can think of a mutex in the same way as the door of a single-user restroom
    facility; suppose that Bob attempts to enter the restroom and lock the door. If
    Alice is in the restroom already, then the door won't open, and Bob will have
    to wait patiently outside until Alice has unlocked the door and exited the restroom.
    Then, Bob will be able to enter and lock the door.
  prefs: []
  type: TYPE_NORMAL
- en: Likewise, when a thread attempts to lock a mutex that another thread has already
    locked, it has to wait until the first thread has finished and unlocked the mutex
    before it can acquire the lock.
  prefs: []
  type: TYPE_NORMAL
- en: In `HashRunner`, we're going to use our `file_lock` mutex to ensure that two
    threads don't attempt to write to the output file at the same time. Note that
    this object is created in the class definition so it will be shared by all instances
    of `HashRunner`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s create the `__init__()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The object will receive paths to the input file and output file and store them
    as instance variables. It also creates an instance of `QtCore.QCryptographicHash`.
    This object is able to calculate various cryptographic hashes of data, such as
    MD5, SHA-256, or Keccak-512\. A complete list of hashes supported by this class
    can be found at [https://doc.qt.io/qt-5/qcryptographichash.html](https://doc.qt.io/qt-5/qcryptographichash.html).
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we set the `autoDelete` property of the class to `True`. This property
    of `QRunnable` will cause the object to be deleted whenever the `run()` method
    returns, saving us memory and resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'The actual work done by the runner is defined in the `run()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Our function starts by printing a message to the console and resetting the `QCryptographicHash`
    object, clearing out any data that might be in it.
  prefs: []
  type: TYPE_NORMAL
- en: We then read the binary contents of our file into the hash object using the `addData()`
    method. The hash value can be calculated and retrieved as a `QByteArray` object
    from the hash object using the `result()` method. We then convert the byte array
    into a hexadecimal string using the `toHex()` method and then into a Python Unicode
    string by way of a `bytes` object.
  prefs: []
  type: TYPE_NORMAL
- en: Now all that's left is to write this hash string to the output file. This is
    where our mutex object comes in.
  prefs: []
  type: TYPE_NORMAL
- en: 'Traditionally, the way to use the mutex is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: We call the mutex's `lock()` method inside a `try` block and then perform our
    file operation. Inside the `finally` block, we call the `unlock` method. The reason
    this is done inside the `try` and `finally` blocks is so that the mutex is sure
    to be released even if something goes wrong with the `file` method.
  prefs: []
  type: TYPE_NORMAL
- en: In Python, however, whenever we have an operation like this that has initialization
    and cleanup code, it is best to use a **context manager** object in conjunction
    with the `with` keyword. PyQt provides us with such an object: `QMutexLocker`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use this object as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This method is much cleaner. By using the mutex context manager, we are assured
    that anything done inside the `with` block is done by only one thread at a time,
    and other threads will wait until the object finishes.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the thread pool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The final piece of this application will be a `HashManager` object. The job
    of this object is to take the form output, locate the files to be hashed, and
    then start up a `HashRunner` object for each file.
  prefs: []
  type: TYPE_NORMAL
- en: 'It will begin like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: We've based the class on `QObject` so that we can define a `finished` signal.
    This signal will be emitted when all of the runners have completed their tasks.
  prefs: []
  type: TYPE_NORMAL
- en: In the constructor, we're creating our `QThreadPool` object. Rather than creating
    a new object, however, we're using the `globalInstance()` static method to access
    the global thread pool object that already exists in every Qt application. You
    don't have to do this, but it is sufficient for most applications and removes
    some complexities involved in having multiple thread pools.
  prefs: []
  type: TYPE_NORMAL
- en: 'The real work of this class will happen in a method we''ll call `do_hashing`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This method is designed to be hooked directly to the `HashForm.submitted` signal,
    so we've made it a slot with a matching signal. It begins by setting the thread
    pool's maximum number of threads (as defined by the `maxThreadCount` property)
    to the number received in the function call. Once this is set, we can queue up
    any number of `QRunnable` objects in the thread pool, but only `maxThreadCount`
    threads will actually be started up concurrently.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we'll use the `QDir` object's `entryList()` method to iterate through
    the files in the directory and create a `HashRunner` object for each one. The
    runner object is then passed to the thread pool's `start()` method, which adds
    it to the pool's work queue.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, all of our runners are running in separate execution threads,
    but we'd like to emit a signal when they are done. Unfortunately, there is no
    signal built-in to `QThreadPool` to tell us this, but the `waitForDone()` method
    will continue to block until all of the threads are done.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, add the following code to `do_hashing()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Back in `MainWindow.__init__()`, let''s create our manager object and add our
    connections:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: After creating our `HashManager`, we move it to a separate thread using `moveToThread()`.
    This is because our `do_hashing()` method is going to block until all of the runners
    are completed, and we don't want the GUI to freeze up while waiting for that to
    happen. Had we left out the last two lines of `do_hashing()`, this wouldn't be
    necessary (but we'd also never know when it was done).
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to get feedback on what''s happening, let''s add two more connections:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The first connection will set the status when the form is submitted, indicating
    details about the job that is commencing; the second will notify us when the job
    is done.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Go ahead and launch this script and let's see how it works. Point your source
    directory at a folder full of large files, such as DVD images, archive files,
    or video files. Leave the threads' spin box at its default setting and click on Go.
  prefs: []
  type: TYPE_NORMAL
- en: Notice from the console output that the files are being hashed two at a time.
    As soon as one completes, another one starts until all of the files have been
    hashed.
  prefs: []
  type: TYPE_NORMAL
- en: Try it again, but this time bump the threads up to four or five. Notice that
    more files are being processed at once. As you play with this value, you may also
    notice that there is a point of diminishing returns, especially as you approach
    the number of cores in your CPU. This is an important lesson about parallelization—sometimes,
    too much causes the performance to drop.
  prefs: []
  type: TYPE_NORMAL
- en: Threading and the Python GIL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: No discussion of multithreading in Python is complete without addressing the
    **global interpreter lock** (**GIL**). The GIL is part of the memory management
    system in the official Python implementation (CPython). Essentially, it is like
    the mutex that we used in our `HashRunner` class—just as a `HashRunner` class
    has to acquire the `file_lock` mutex before it can write to the output, any thread
    in a Python application must acquire the GIL before it can execute any Python
    code. In other words, only one thread can execute Python code at a time.
  prefs: []
  type: TYPE_NORMAL
- en: At first glance, this may appear to make multithreading in Python a futile pursuit;
    after all, what's the point of creating multiple threads if only one thread can
    execute Python code at a time?
  prefs: []
  type: TYPE_NORMAL
- en: 'The answer involves two exceptions to the GIL requirement:'
  prefs: []
  type: TYPE_NORMAL
- en: The long-running code can be **CPU-bound** or **I/O-bound**. CPU-bound means
    that most of the processing time is spent running heavy CPU operations, such as
    cryptographic hashing. I/O-bound operations are those that spend most of their
    time waiting on **i****nput/output** (**I/O**) calls, such as writing a large
    file to a disk or reading data from a network socket. When a thread makes an I/O
    call and begins waiting on a response, it releases the GIL. Therefore, if our
    worker code is mostly I/O-bound, we can benefit from multithreading because other
    code can run while we wait on the I/O operation to finish.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CPU-bound code also releases the GIL if the code is running outside of Python.
    In other words, if we use a C or C++ function or object to perform a CPU-bound
    operation, then the GIL is released and only reacquired when the next Python operation
    is run.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is why our `HashRunner` works; its two heaviest operations are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Reading the large file from disk (which is an I/O-bound operation)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hashing the file contents (which is handled inside of the `QCryptographicHash`
    object—a C++ object that operates outside of Python)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we were to implement a hashing algorithm in pure Python instead, then we'd
    likely find that our multithreaded code actually ran slower than even a single-threaded
    implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Ultimately, multithreading is not a magic bullet to speed up the code in Python;
    it must be carefully planned out to avoid problems with the GIL and the pitfalls
    that we discussed in the *Threading tips and caveats* section. With proper care,
    however, it can help us to create fast and responsive programs.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to keep your application responsive when running
    a slow code. You learned how to use `QTimer` to defer actions to a later time,
    either as a one-time or repeating action. You learned how to push code to another
    thread using `QThread`, both by using `moveToThread()` and by subclassing `QThread`.
    Finally, you learned how to use `QThreadPool` and `QRunnable` to build highly
    concurrent data processing applications.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 11](a9b58d41-a0ec-41f8-8f59-39ae2bc921ee.xhtml), *Creating Rich
    Text with QTextDocument,* we're going to take a look at working with rich text
    in PyQt. You'll learn how to define rich text using an HTML-like markup and how
    to inspect and manipulate documents using the `QDocument` API. You'll also learn
    how to take advantage of Qt's printing support to bring documents into the real
    world.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Try answering these questions to test your knowledge from this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Create code to call the `self.every_ten_seconds()` method every 10 seconds.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The following code uses `QTimer` incorrectly. Can you fix it?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: You've created the following word-counting `Worker` class and want to move it
    to another thread to prevent large documents from slowing the GUI. But it's not
    working—what do you need to change about this class?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The following code is blocking rather than running in a separate thread. Why
    is this the case?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Will this `Worker` class run correctly? If not, why?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The following code is a `run()` method from a `QRunnable` class designed for
    processing large data files output from scientific equipment. The files consist
    of millions of long rows of space-delimited numbers. Is this code likely to be
    slowed down by the Python GIL? Could you make it less likely that the GIL will
    interfere?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The following is a `run()` method from a `QRunnable` class in a multithreaded
    TCP Server application you're writing. All of the threads share a server socket
    instance accessed through `self.datastream`. This code is not thread-safe, however.
    What do you need to do to fix it?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For further information, please refer to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A **semaphore** is similar to a mutex but allows for an arbitrary number of
    locks to be taken rather than just a single lock. You can read more about Qt's
    implementation, the `QSemaphore` class, at [https://doc.qt.io/qt-5/qsemaphore.html](https://doc.qt.io/qt-5/qsemaphore.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: David Beazley's talk from PyCon 2010, available at [https://www.youtube.com/watch?v=Obt-vMVdM8s](https://www.youtube.com/watch?v=Obt-vMVdM8s),
    provides deeper insight into the operation of the Python GIL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
