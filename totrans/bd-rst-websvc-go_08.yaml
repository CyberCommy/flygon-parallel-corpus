- en: Building a REST API Client in Go and Unit Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are going to discuss how Go client applications work in
    depth. We will explore `grequests`, a Python request-style library that allows
    us to make API calls from the Go code. Then, we will write a client software that
    uses the GitHub API. In the course of this, we will try to learn about two wonderful
    libraries called `cli` and `cobra`.After these fundamentals, we will try to use
    the knowledge to write an API testing tool on the command line. Then we will see
    about Redis, an in-memory database which we can use to cache the API responses
    to backup the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What is a client software?</li>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basics for writing a command-line tool in Go
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing `grequests`, a Python request-like library in Go
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inspecting GitHub REST API from a Go client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an API client in Go
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Caching an API for later use
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a unit testing tool for the API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting the code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can get the code samples for this chapter at the GitHub repository link [https://github.com/narenaryan/gorestful/tree/master/chapter8](https://github.com/narenaryan/gorestful/tree/master/chapter8).
    This chapter has examples that are a combination of single programs, as well as
    projects. So, copy the respective directory to your `GOPATH` to run the code samples
    properly. For the last example of unit testing the URL shortening service, the
    tests are available at [https://github.com/narenaryan/gorestful/tree/master/chapter7](https://github.com/narenaryan/gorestful/tree/master/chapter7).
  prefs: []
  type: TYPE_NORMAL
- en: Plan for building a REST API client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Till now, we mainly focused on writing server-side REST APIs. Basically, they
    are server programs. In a few cases, such as GRPC, we also needed the client.
    But a true client program takes input from the user and executes some logic. For
    working with a Go client, we should know the `flag` library in Go. Before that,
    we should know how to make requests for an API from a Go program. In previous
    chapters, we assumed the clients could be CURL, Browser, Postman, and so on. But
    how do we consume an API from Go?
  prefs: []
  type: TYPE_NORMAL
- en: Command-line tools are equally important as web user interfaces to perform system
    tasks. In **business-to-business** (**B2B**) companies, the software is packaged
    as a single binary instead of having multiple different pieces. As a Go developer,
    you should know how to achieve the goal of writing apps for the command line.
    Then, that knowledge can be leveraged to create REST API-related web clients very
    easily and elegantly.
  prefs: []
  type: TYPE_NORMAL
- en: Basics for writing a command-line tool in Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Go provides a basic library called `flag`. It refers to the command-line flags.
    Since it is already packed with the Go distribution, there is no need to install
    anything externally. We can see the absolute basics of writing the command-line
    tool. The `flag`package has multiple functions, such as `Int` and `String`, to
    handle the input given as command-line flags. Suppose we need to take a name from
    the user and print it back to the console. We use the `flag.String`method, as
    shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us write a short program for clear details. Create a file called `flagExample.go`in
    your `$GOPATH/src/github.com/narenaryan` and add the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In this program, we are creating a flag called `name`. It is a string pointer.
    `flag.String`takes three arguments. The first one is the name of the argument.
    The second and third are the default values of that flag and the help text, respectively.
    We then ask the program to parse all flag pointers. When we run the program, it
    actually fills the values from the command line to the respective variables. To
    access the value of a pointer, we use `*`. First build and then run the program
    using the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates a binary in the same directory. We can run it like a normal executable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'It gives the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we didn''t give any argument called `name`. But we have assigned the
    default value to that argument. Go''s flag takes the default value and proceeds
    further. Now, in order to see what options are available and to know about them,
    ask for help:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This is the reason we passed help text as the third argument for the flag command.
  prefs: []
  type: TYPE_NORMAL
- en: In Windows, `flagExample.exe` will be generated when we build a `.go` file.
    After that, from the command line, we can run the program by calling the program
    name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now try to add the argument, and it prints the given name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Both work fine as arguments which give the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If we need multiple parameters to collect, we need to modify the preceding
    program to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This takes two parameters, just one more addition of a different type. If we
    run this, we see the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This is exactly what we expected. Instead of using the pointers, we can bind
    a variable to the parsed output. This binding is done through the `init()`function,
    which will run in a Go program irrespective of whether main exists or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In this way, the value will directly come and sit in the variable. The complete
    rewrite of the preceding program  using the `init()` function is shown in the
    following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '`initFlag.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The output is exactly the same as the preceding program. Here, instead of using
    pointers, we are able to load data directly into our variables.
  prefs: []
  type: TYPE_NORMAL
- en: In Go, execution starts from the main program. But a Go program can have any
    number of `init` functions. If a package has an `init` function in it, that will
    be executed.
  prefs: []
  type: TYPE_NORMAL
- en: This `flag`library is very basic to work. But in order to write advanced client
    applications, we need to take the help of the library. In the next section, we
    look at such a library.
  prefs: []
  type: TYPE_NORMAL
- en: CLI – a library for building beautiful clients
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is the next step for a Go developer after playing with the `flag`package.
    It provides an intuitive API for creating command-line applications with ease.
    It allows us to collect arguments and flags. It could be quite handy for designing
    complex applications. To install the package, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, let us write a program that does exactly the same job as the preceding
    programs:'
  prefs: []
  type: TYPE_NORMAL
- en: '`cli/cliBasic.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This is lengthier than the one before, but it is more expressive. We created
    a new app using the `cli.NewApp` function. It creates a new struct. We need to
    attach a few parameters to this struct. They are the `Flags` struct and the `Action`
    function. The `Flags`struct is a list that defines all possible flags for this
    application. The structure of `Flag`from** GoDoc** ([https://godoc.org/github.com/urfave/cli#Flag](https://godoc.org/github.com/urfave/cli#Flag))is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The inbuilt structs, such as `StringFlag` and `IntFlag`, implement this `Flag`
    interface. `Name`, `Value`, and `Usage` are straightforward. They are similar
    to the ones used in the `flag` package. The `Action` function takes the argument
    `cli.Context`.That context object holds all of the information about flags and
    command-line arguments. We can use them and apply logic to them. The `c.String`,
    `c.Int`, and other functions are used to look up the flag variables. For example,
    in the preceding program, `c.String("name")` fetches a flag variable whose name
    is `name`. This program runs the same as the previous programs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Collecting command-line arguments in CLI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is a difference between command-line arguments and flags. The following
    diagram clearly specifies the distinction between them:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/aaebeab6-0adf-407a-87a8-5c2b5e00dd03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Suppose that we have a command-line app called storeMarks for saving the marks
    of a student. It has a flag (called `save`) to specify whether details should
    be pushed to DB or not. The arguments that are given are the name and actual marks
    of the student. We already saw how to collect the flag values in the program.
    In this section, we will see how to collect program arguments in an expressive
    way.
  prefs: []
  type: TYPE_NORMAL
- en: 'For collecting arguments, we use the `c.Args`function, where `c` is the `cli`
    context of the `Action` function. Create a directory called `cli` and add a new
    program, `cli/storeMarks.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '`c.Args`keeps all of the arguments we entered. Since we know the order of the
    arguments, we deduced that the first argument is the name and the remaining values
    are the marks. We are checking a flag called `save` to save those details in a
    database or not (we don''t have database logic here, for simplicity). `app.Version`
    sets the version of the tool. All other things remain the same as the last program.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us run this program and see the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'If we don''t give any flag, the default is `save=no`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Everything looks good till now. But how can the tool display help when a user
    needs it? The `cli`library already creates a nice help section for the given app.
    Type any of these commands and help text will be autogenerated:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./storeMarks -h` (or)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`./storeMarks -help` (or)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`./storeMarks --help`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`./storeMarks help`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A nice help section appears, like this one showing version details and available
    flags (global options), commands, and arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This actually makes building client applications easier. It is way faster and
    more intuitive than the internal `flag`package.
  prefs: []
  type: TYPE_NORMAL
- en: Command-line tools are binaries that are generated after building the program.
    They need to be run with the options. It is like any system program and not related
    to Go compiler anymore
  prefs: []
  type: TYPE_NORMAL
- en: grequests – a REST API package for Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The developers who worked on Python know about the `Requests`library. It is
    a clean, short library that is not included in the standard library of Python.
    The Go package `grequests`is inspired by that library. It provides a simple set
    of functions, using which we can make API requests such as `GET`, `POST`, `PUT`,
    and `DELETE`from our Go code. Using `grequests` allows us to encapsulate the inbuilt
    HTTP request and response. To install the `grequests` package for your Go, run
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, see this basic program illustrating the use of the `grequests` library
    to make a `GET` request to a REST API. Create a directory called `grequests` in
    your Go source directory and add a file called `basicRequest.go`, as shown in
    the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The `grequests` package has methods for performing all REST actions. The preceding
    program uses the `Get`function from the package. It takes two function arguments.
    The first one is the URL of the API, and the second one is the request parameters
    object. Since we are not passing any request parameters, the second argument is
    `nil` here. `resp`is returned from the request, and it has a function called `String()`that
    returns the response body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is the JSON response returned by the `httpbin`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: API overview of grequests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The most important thing to explore in `grequests` is not the HTTP functions,
    but the `RequestOptions` struct. It is a very big struct that holds various kinds
    of information on the type of API method. If the REST method is `GET`, the `RequestOptions`
    holds the `Params`property. If the method is a `POST`, the struct will have a
    `Data` property. Whenever we make a request, we get a response back. Let us see
    the structure of the response. From the official documentation, the response looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Ok`property of response holds the information about whether a request
    is successful or not. If something went wrong, an error will be filled into the `Error`
    property. `RawResponse` is the Go HTTP response that will be used by other functions
    of the `grequests` response. `StatusCode` and `Header` store the status codes
    of the response and header details, respectively. There are a few functions in
    `Response` that are useful:'
  prefs: []
  type: TYPE_NORMAL
- en: JSON
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: XML
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: String
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bytes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These can be called on the obtained response by passing an empty interface
    to the functions—`grequests/jsonRequest.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We declared an interface to hold the JSON values. We then populated the `returnData`
    (empty interface) using the `resp.JSON`function. This program prints the map instead
    of plain JSON.
  prefs: []
  type: TYPE_NORMAL
- en: Getting comfortable with the GitHub REST API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'GitHub provides a well-written REST API to consume from the users. It opens
    up the data about users, repositories, repository statistics, and so on, to the
    clients through the API. The current stable version is v3. The API documentation
    can be found at [https://developer.github.com/v3/](https://developer.github.com/v3/).
    The root endpoint of the API is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The other API will be added to this base API. Now let us see how to make a few
    queries and get data related to various elements. For the unauthenticated user,
    the rate limit is 60/hour, whereas for clients who are passing `client_id` (which
    one can get from the GitHub account), it is 5,000/hour.
  prefs: []
  type: TYPE_NORMAL
- en: If you have a GitHub account (if not, it is recommended you create one), you
    can find access tokens in the Your Profile | Personal Access Tokens area or by
    visiting [https://github.com/settings/tokens](https://github.com/settings/tokens).
    Create a new access token using the Generate new tokenbutton. It asks for various
    permissions for types for the resource. Tick all of them. A new string will be
    generated. Save it to some private place. The token we have generated can be used
    to access the GitHub API (for longer rate limits).
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to save that access token to an environment variable, **`GITHUB_TOKEN`. **To
    do that, open your  **`~/.profile`** or **`~/.bashrc` **file and add this as the
    last line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '`YOUR_GITHUB_ACCESS_TOKEN` is what was generated and saved previously from
    the GitHub account. Let us create a program for fetching all the repos of the
    given user. Create a new directory called `githubAPI`and create a program file
    called `getRepos.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the program, and you will see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The printed output is not JSON but a list of the Go Repo `struct`. The preceding
    program illustrates how we can query the GitHub API and load that data into our
    custom struct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the struct we used for saving the details of our repository. The JSON
    returned has many fields, but for simplicity''s sake, we are just plucking a few
    important fields out of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In the first line, we are fetching the environment variable called `GITHUB_TOKEN`.
    The `os.Getenv`function returns the value of an environment variable by the given
    name. For GitHub to assume the origin of the `GET` request, we should set the
    authentication. For that, pass an argument to the `RequestOptions` struct. That
    argument should be a list of the username and password.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a CLI tool as an API client for the GitHub REST API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After looking at this example, we are able to easily access the GitHub API
    from our Go client. We can combine both of the techniques we learned in this chapter
    so far to come up with a command-line tool that consumes the GitHub API. Let us
    create a new command-line application which:'
  prefs: []
  type: TYPE_NORMAL
- en: Provides options to get repo details by username
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uploads any file to GitHub gists (text snippets) with a given description
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authenticates using a personal access token
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gists are snippets provided by GitHub to store text content. For more details,
    visit [https://gist.github.com](https://gist.github.com).
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a program called **`gitTool.go` **in the `githubAPI` directory. This
    will be the logic for the preceding program specification:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us run the program before jumping into the details of explanation. It makes
    clear how we implemented the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'It creates a binary in the same directory. If you type `./gitTool -h`, it shows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'If you see the help commands, there are two commands, `fetch` and `create`. `fetch`
    fetches the repositories of a given user and `create` creates a `gist` with the
    supplied files. Let us create two sample files in the same directory of the program
    to test the `create` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the tool with the first command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'It returns all repositories belonging to the great Linus Torvalds.The log message
    prints the struct that filled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let us check the second command. It creates the `gist` with the given
    description and a set of files as arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'It returns the JSON details about the created `gist`. It is a very lengthy
    JSON, so the output is skipped here. Then, open your [gist.github.com](https://gist.github.com/)
    account, and you will see the created `gist`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ff1620ca-8fee-48f9-8bec-ebc3d694ef84.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, coming to the explanation, we first imported `grequests`for making API
    calls and `cli`for building the command-line tool. Other imports are necessary
    to read files, log to the console, and encode JSON. We then defined three structs: `Repo`,
    `File`, and `Gist`. The GitHub `gists` API expects a JSON data to create:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The `grequests` `POST` request takes `requestOptions` that have `Data` as the
    field. But the signature of it is `Map[string]string]`,which is not enough to
    create the preceding structure. `grequests`allows us to pass a JSON string with
    any structure to the API. We created structs so that data can be filled and marshalled
    into proper JSON to `POST` request get succeeded.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we created two functions: `getStats` (that returns all repo details of
    a given user) and `createGist` (that creates new `gist` files with the given description
    and filenames). The second function is more interesting. We are passing a URL
    for the `POST` request, description, and `file_names` in the form of an `args`array.
    Then, we are iterating on each and every file and getting the content. We are
    adjusting our structs so that the final JSON body for the `POST` request will
    be in the same structure. Finally, we are making a `POST` request with the **`requestOptions` **that
    have our JSON.
  prefs: []
  type: TYPE_NORMAL
- en: In this way, we combined both of the libraries to build an API client which
    can do any task. The beauty of Go is that we can ship the final binary in which
    both the logic for the command-line tool and the REST API calling the logic were
    buried.
  prefs: []
  type: TYPE_NORMAL
- en: For any Go program to read and understand soon, follow the `main` function and
    then step into the other functions. In that way, we can come across imported packages
    and their APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Using Redis for caching the API data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Redis** is an in-memory database that can store key/value pairs. It best
    suits the caching use cases where we need to store information temporarily but
    for huge traffic. For example, sites such as BBC and The Guardian show the latest
    articles on the dashboard. Their traffic is so high, if documents (articles) are
    fetched from the database, they need to maintain a huge cluster of databases all
    the time. Since the given set of articles does not change (at least for hours),
    the BBC can maintain a cache which saves the articles. When the first customer
    visits the page, a copy is pulled from the DB, sent to the browser, and placed
    in the Redis cache. The next time a customer appears, the BBC application server
    reads content from Redis instead of going to the DB. Since Redis runs in primary
    memory, latency is reduced. The customer sees his page loaded in a flash. The
    benchmarks on the web can tell more about how efficiently a site can optimize
    its contents.'
  prefs: []
  type: TYPE_NORMAL
- en: What if data is no longer relevant in Redis? (For example, the BBC updated its
    top stories.) Redis provides a way to expire the `keys:values` stored in it. We
    can run a scheduler that updates the Redis whenever the expiration time has passed.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, we can cache the third-party API responses for the given request
    (`GET`). We need to do it, because third-party systems like GitHub are giving
    us a rate limit (telling us to be conservative). For a given `GET URL`, we can
    store the `URL` as key and the `Response` as value. Whenever the same request
    is given within the next time (before key expiration), just pull the response
    out of Redis instead of hitting the GitHub servers. This method is applicable
    to our REST API, too. The most frequent and unchanged REST API can be cached in
    order to reduce the load on the primary database.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a wonderful library available for Go to talk to Redis. It is [https://github.com/go-redis/redis](https://github.com/go-redis/redis).
    It is a well-known library which many developers suggest you use. The following
    diagram illustrates the concept very well:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4ec5f6f5-dcf7-4cc9-b427-14e8ce28865e.jpg)'
  prefs: []
  type: TYPE_IMG
- en: One caveat to note here is the expiration of the API. A real-time API should
    not be cached because of its dynamic nature. Caching brings performance optimization
    to our plate, as well as a few headaches. Be careful while caching. There are
    many better practices available globally. Please go through them to get an understanding
    of various architectures.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a unit testing tool for our URL shortening service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, we created a URL shortening service. The structure
    of the URL shortener project we worked on previously looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `main.go` file, we created two API handlers: one for `GET` and one for `POST`.
    We are going to write the unit tests for both of those handlers. Add a file called
    `main_test.go` in the root directory of the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to test our API, we need to test our API handlers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: There is a testing package in Go named `testing`. It allows us to create a few
    assertions and lets us make a pass or fail test. We are testing the API `TestGetOriginalURL`by
    making a simple HTTP request. Make sure you have at least one record inserted
    in the database. The advanced testing topics of database connections are out of
    the scope of this book. We can test this using Go test command inside the project
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We started our chapter with understanding client software: how a software client
    works and how we can create a few. We saw the basics of writing a command-line
    application. CLI is a third-party package that enables us to create beautiful
    command-line applications. After installing it, we saw how to collect command-line
    arguments through the tool. We also explored commands and flags in our CLI application.
    Next, we looked into `grequests`,a package similar to Python requests to make
    API requests from Go code. We saw how to make `GET`, `POST`, and so on, requests
    from the client programs.'
  prefs: []
  type: TYPE_NORMAL
- en: We next explored the GitHub API on how to fetch details like repositories. With
    the knowledge of both concepts, we developed a client that lists the repositories
    for a given user and also creates a `gist` (a text file on GitHub). We introduced
    Redis architecture on how caching could help handle rate-limited API. Finally,
    we wrote a unit test for the URL shortening service we created in the previous
    chapter.
  prefs: []
  type: TYPE_NORMAL
