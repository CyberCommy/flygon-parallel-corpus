- en: Chapter 8. Architecting an IDS/IPS Range
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn the techniques of designing and building a variety
    of IDS/IPS capabilities into our network range. We will also look at the deployment
    of typical host and endpoint security configurations. We will discuss the following
    topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Deploying a network-based IDS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a host-based IPS and endpoint security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with virtual switches
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Evasion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter will provide us with a methodology to use when we encounter a number
    of different monitoring devices. In this chapter, we will look at evasion, that
    is, techniques to avoid detection. While this is a popular topic, as a professional
    security tester, the reality is that it is rarely asked for; furthermore, it is
    dependent on so many factors, it is not something that is easy to prepare for.
    The success is largely determined by the type and location of the IDS sensors
    as well as their configuration. There is a possibility that you will be asked
    to evade detection as part of the scope of your work and this is why we cover
    it in the book.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying a network-based IDS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we previously discussed in [Chapter 6](ch06.html "Chapter 6. Creating an
    External Attack Architecture"), *Creating an External Attack Architecture*, when
    we deploy a network-based **Intrusion Detection System (IDS)**, we place a sensor
    on each segment of the network. The sensor consists of a network card that is
    placed in promiscuous mode, and this turns the MAC address filtering off. All
    of the traffic is passed up the stack and to the application that is monitoring
    the sensor. We also discussed the challenges of deploying sensors on a switch
    since the traffic is not sent out of all ports, and this can pose a challenge
    to provide data to the sensor.
  prefs: []
  type: TYPE_NORMAL
- en: 'With a network-based IDS, the function of the IDS is to process the network
    traffic at the packet level and then analyze it for characteristics or patterns
    that might be indications of an attack. As you think about this, keep in mind
    that the network sensor is capturing packets; so how many packets are traversing
    the network at any one time? This is one of the challenges of the network-based
    IDS (how to process traffic at ever increasing speeds of a network). However,
    we are getting ahead of ourselves. The first thing we want to do is design our
    architecture so that we have a good representation of a typical IDS we might see
    on a client''s network. We will be using the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Deploying a network-based IDS](img/477-1_08-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Our architecture
  prefs: []
  type: TYPE_NORMAL
- en: We can build the architecture and test sensors at every point, but there really
    is no point in doing that. This is because we have the luxury of using a virtual
    environment such as VMware. So, once we decide what we want to test with, we just
    change the network adapter to be connected to that switch. Again, this is another
    reason why we have made the choices that we have.
  prefs: []
  type: TYPE_NORMAL
- en: Another thing to note is that we want to have a victim to attack and see how
    the IDS responds, but an even better method, especially when it comes to evasion,
    is to channelize the attack traffic directly at the network sensor. This would
    provide us with the power to see whether the attack at the sensor can get through
    without being detected. We will do this later in the *Evasion* section.
  prefs: []
  type: TYPE_NORMAL
- en: The next thing we will do is start up our three machines and verify whether
    we have the IDS up and functioning. Before we do this, you should verify your
    settings with the Network Security Toolkit, the Kali machine, and the victim and
    check that they are all connected to the VMnet2 switch. You might be wondering
    why we do not use the VMnet8 switch, as it would provide us with Internet connectivity
    and other built-in features of the VMware too. This is a valid question, and the
    biggest reason why we have selected another switch is that we want to ensure we
    do not have any spurious or abnormal traffic that could cause us problems with
    the sensor. The VMnet8 switch shares the adapter configuration with the host machine,
    and often, there are packets that are transmitted and can interfere with our results.
    Once the machines are started, we will start the Snort sensor. Log in to the Network
    Security Toolkit virtual machine, then click on **Activities** and select the
    Firefox icon.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the Firefox web browser starts, if the username and password details are
    not filled in, enter the required information and click on **OK**. This should
    place you at the home page of the Network Security Toolkit Web User Interface.
    Then, navigate to **Security** | **Intrusion Detection** | **Snort IDS**, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Deploying a network-based IDS](img/477-1_08-3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Once the Snort page opens, you will want to see which state you left the machine
    in when you either suspended or shutdown the virtual machine. If you do not see
    a sensor in a state listed, then you have to configure the interface for the sensor.
    Even though we explained this earlier, we will work through it again so that you
    do not have to look for it. If you do not see a sensor listed, then you need to
    scroll down and select the appropriate interface. For the book, we are using the
    eth1 interface, so the examples that follow will be based on this. If you have
    set the VMnet2 switch on another interface, then you will have to select that
    interface and not the one we are using.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have selected the radio button for the appropriate interface, then
    click on **Setup/Start Snort** to start the sensor on the interface.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You will most likely have to click on the button twice to get the sensor to
    actually start.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the sensor has successfully started, you should see that the Snort sensor
    is in the **Running** state, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Deploying a network-based IDS](img/477-1_08-4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Screen showing Snort sensor is in the Running state (the cropped text is not
    important)
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the process is in the state we want it to be in, we will verify whether
    our rule is turned on. Click on **Rules** and verify whether the **Scan** rules
    are selected. An example of this is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Deploying a network-based IDS](img/477-1_08-5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Screen to verify that the Scan rules are selected (the cropped text is not important)
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You will have to reload the sensor if you made a change to the rules. The reload
    button is located to the right of the **Rules** button.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that our rules do what we want them to do, we are ready to verify whether
    our sensor is operating. We covered the steps for this earlier, but we won''t
    make you go find them. We have to open a terminal window and enter the following
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Once you have started Snort, open another window and use an illegal flag combination
    scan to verify the sensor is working. As a reminder, we used the Christmas tree
    scan in [Chapter 6](ch06.html "Chapter 6. Creating an External Attack Architecture"),
    *Creating an External Attack Architecture*, you can use this or any scan that
    contains illegal flags such as a FIN or a NULL scan.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another thing that we like about Network Security Toolkit in addition to the
    ease of setup of Snort is the fact that we have excellent tools for Snort. We
    will look at the tool **Base Analysis Search Engine** (**BASE**). To start BASE,
    you need to navigate to **Security** | **Intrusion Detection** | **BASE**. An
    example is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Deploying a network-based IDS](img/477-1_08-6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'When the BASE tool starts, you will be asked to authenticate yourself. The
    credentials should already be entered for you, and if not, then you will have
    to enter the appropriate credentials to access the GUI. Once you have done this,
    click on **OK**, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Deploying a network-based IDS](img/477-1_08-7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The BASE GUI allows us to record the alerts that the sensor detects in the
    graphical display. Return to your Kali machine and run the Christmas tree scan
    again. As a reminder, you configure the scan using the **X** option. Once the
    scan is complete, return to the **BASE** display and refresh the display, and
    you should now see detected TCP traffic as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Deploying a network-based IDS](img/477-1_08-8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'A nice thing about the BASE tool is the information that you can examine from
    the alerts. We will do this now. Click on the percentage number and this will
    bring up another window with a list of the alerts that have been detected by the
    sensor. An example of this is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Deploying a network-based IDS](img/477-1_08-9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The next thing we want to do is to examine the alerts. We do this by clicking
    on an alert. When you click on the alert, you will see additional information
    about the alert. An example of this is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Deploying a network-based IDS](img/477-1_08-10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As the previous screenshot shows, the composition of the packet, including the
    display of the encapsulated data, is available for review. This shows that the
    **Nmap** tool sets the FIN, PUSH, and URGENT flags to represent the scan. Some
    tools will set all the six flags when they perform the scan.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two links located in the **Meta** section and under the **Triggered
    Signature**. Click on the Snort link and it will bring up the rule that triggered
    the signature. An example of this is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Deploying a network-based IDS](img/477-1_08-11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The previous screenshot shows information that you can examine to discover
    additional details not only about the signature, but also about the impact of
    the triggered event. Furthermore, you can address information on the false positive
    rating. This is important because many administrators that implement an IDS will
    turn off signatures that generate a high number of false alerts. In fact, as you
    may recall, we had to turn the scan rule on, and this is because it has a tendency
    for a high false positive rating. We will now examine the false positive rating
    of the Nmap XMAS scan. Scroll down and review the information. An example of this
    is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Deploying a network-based IDS](img/477-1_08-12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We now have an IDS range that we can use to observe how our different tools
    and techniques will react. Before we do this, we will clear any alerts in the
    machine, and to do this, you need to go to the bottom of the **Query Results**
    screen and navigate to **action** | **Delete alert(s)**. Once you have done this,
    click on the **Entire Query** button to delete the alerts and then return to the
    main screen by clicking on **Home**. We will use the Nikto web scanning tool to
    see how the Snort sensor reacts when the scanner is used. We are going to scan
    the Network Security Toolkit web server that is on the network of the Snort sensor.
    To conduct the scan in the Kali Linux machine, open a terminal window and enter
    `nikto –ssl –h <IP address of the Sensor>`, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Deploying a network-based IDS](img/477-1_08-13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `ssl` option is used to force the check of **Secure Sockets Layer** (**SSL**),
    since in the default configuration, the Network Security Toolkit does not have
    a web server at port 80; only HTTPS port 443 is accessible. When the scan has
    finished, you will notice that there are several findings. To review the findings,
    you will need to scroll back through and look for them. As with most tools, there
    is a better way and we will explore this now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the terminal window, we will use the output capability of the tool to write
    it to a file. Enter `nikto –ssl –h <IP address of the Sensor> -o file.html`, as
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Deploying a network-based IDS](img/477-1_08-14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This has taken the output from the tool findings and written it to an HTML
    file. Open **Iceweasel** by navigating to **Applications** | **Internet** | **Iceweasel
    Web Browser**. When the browser opens, open the file that you have created and
    review the results. You will see the output is much easier to read, as shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Deploying a network-based IDS](img/477-1_08-15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'It is now time to return to our Snort sensor and BASE display to see whether
    we have any alerts. We have conducted a number of web scans and want to see what
    has been detected. Return to your Network Security Toolkit and refresh the BASE
    display and review the information. An example is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Deploying a network-based IDS](img/477-1_08-16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As the previous screenshot shows, we have no alerts! Why is this? Well, this
    is part of the process of trial and error. We know that specific rules were loaded
    when we configured the Snort sensor because we had to enable some in the past.
    So, the process from here will be to try to enable more rules and see what happens.
    There is also a good chance that there is another problem, but as long as we send
    our illegal flag combination packets in, we get some sort of an alert, and this
    tells us the sensor is working. In this case, if you turn all of the rules on,
    there will still not be an alert. We will save the answer to this till we get
    to the section on evasion.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the host-based IDS and endpoint security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a number of different ways that a site can configure and deploy their
    host-based protection or moreover, their endpoint security. As a tester, it is
    a matter of experimentation when it comes to implementing this on our target range.
    The majority of these products are commercial and you have to get trial versions
    or request a proof of concept implementation from the vendor. Either way, your
    ability to deploy this on your network range will be largely dependent on what
    your client has. This is information that can be obtained during the early stages
    of your non-intrusive target searching. However, it is usually provided to you
    at meetings to determine the scope of work, or during the social engineering phase
    of testing when it is allowed and is in scope.
  prefs: []
  type: TYPE_NORMAL
- en: We will look at some popular endpoint protection software from Symantec. As
    we said in the previous paragraph, there will be others you might encounter, but
    with the majority of these detection solutions, there is some alert or alarm threshold
    that is set. As a tester, that is what we have to determine. Consequently, this
    will be discussed in the section on evasion.
  prefs: []
  type: TYPE_NORMAL
- en: The version of Symantec we are going to look at is an older one (Version 11.0),
    but it will serve our purpose. The intent here is when you are preparing for an
    engagement, you will create as much as you can in your lab environment. Once you
    install an host-based IDS or an IPS, you look at its configuration to see what
    the tool uses to detect and/or block events.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the Symantec tool, we look at the options in the tool configuration to
    gain this information. An example of the dashboard is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing the host-based IDS and endpoint security](img/477-1_08-17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As the previous screenshot shows, there are three main areas of protection.
    We only have one enabled at this time, and this is what we will look at first.
    We will navigate to **Options** | **Change Settings** | **Intrusion Prevention**
    to bring up the menu to change the settings for blocking suspected attack traffic.
    An example of this is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing the host-based IDS and endpoint security](img/477-1_08-18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As the previous screenshot shows, we have a number of values we can configure
    and customize, and this is one of the challenges we have as testers. If the administrator
    has tuned or changed the settings to something different, we might not be able
    to evade detection, but we are getting ahead of ourselves as we are not in the
    evasion section. We have changed the default values here.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next thing we need to do is see whether we can detect a potential attack
    and actually block the IP address. We can use Nmap, but we prefer to use more
    of an attack tool and that is where Nikto comes in. We will direct it at the IP
    address of the Symantec machine and see what happens. An example of the results
    is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing the host-based IDS and endpoint security](img/477-1_08-19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As the previous screenshot shows, the attack was detected and the IP address
    is now blocked; this is why we changed the block to 60 seconds so that the Nikto
    scan will not take too long. Once the scan is complete, we can view the history
    of the detection and the corresponding blocks in the Symantec tool. All of these
    features are great for the user and are easy to use, but they are also good for
    the attacker. An example of the log results from a Nikto scan is shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing the host-based IDS and endpoint security](img/477-1_08-20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As the previous screenshot shows, the intrusion prevention tool has detected
    and subsequently blocked the attack attempts from the tool. The problem is that,
    as many of you reading this probably know, an IP block is not always a good idea,
    because we can spoof an IP address and then the user will be blocked. This is
    one of the reasons why the IP blocking is usually only configured for something
    that could lead to a significant loss.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several other parts of the Symantec tool and we will not cover them
    all here. However, we will look at one that is not network-related, but is actually
    host-related. The capability we are going to look at now is **Antivirus and Antispyware
    Protection**. The first thing we will do is click on the **Fix All** button and
    this will turn all of the protections on, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing the host-based IDS and endpoint security](img/477-1_08-21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Screen showing all of the protections on (the cropped text is not important)
  prefs: []
  type: TYPE_NORMAL
- en: 'We now have all of the endpoint protections enabled; consequently, any program
    that we try to put on the machine that is considered a threat will be flagged
    by the protection mechanisms. To demonstrate this, we will use the FU rootkit
    written in 2005 by Jamie Butler to show the weaknesses with the usage of the Intel
    architecture rings by Microsoft. A detailed explanation of this is beyond the
    scope of the book, but for those of you who want to know more, you can get the
    book *Rootkits: Subverting the Windows Kernel, Addison Wessely* that he co-authored
    with Greg Hoglund.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When we copy the executable file for the FU rootkit to the protected machine,
    it is instantly detected as a threat, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing the host-based IDS and endpoint security](img/477-1_08-22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As the previous screenshot shows, it has been detected and classified as a
    **Hacktool.Rootkit** and as it was considered a threat, it was deleted. We can
    look at more details of the detection by clicking on Antivirus and Antispyware
    Protection. Navigate to **Options** | **View Logs** | **Risk Log** to view the
    risks that have been detected. An example is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing the host-based IDS and endpoint security](img/477-1_08-23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As the previous screenshot shows, the detection was made on two files, the executable
    is one and `msdirectx.sys`, which is the driver that is loaded and used to get
    access to the kernel memory. The FU rootkit was a pioneer since it was the first
    to achieve **Direct Kernel Object Memory** (**DKOM**) manipulation.
  prefs: []
  type: TYPE_NORMAL
- en: So, where does this leave us with our range architecture? Well, as it has been
    mentioned, the products that you are going to encounter are going to be of a wide
    variety. So, for the most part, we wait and see what the client has available,
    and then we start researching to get a copy of it and lab it up and experiment.
    The key, as many of you probably know, is that we have been detected because of
    the signature of the files. So, we will use a tool to change that signature; however,
    this is evasion so we will cover that later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Working with virtual switches
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we are building our range, we have to take into account the types of switches
    that we have and whether we need to configure either a **Switch Port Analyzer**
    (**SPAN**) or a **Test Access Point** (**TAP**). Like most things, there are advantages
    and disadvantages to each. You can find out more at the website [http://www.networktaps.com](http://www.networktaps.com).
    An example of a comparison from the website is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with virtual switches](img/477-1_08-24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you are building your range with physical switches, then this is something
    you will have to take into consideration. However, if you are using virtual switches,
    then we do not have this challenge. We have looked at this once, but we want to
    look at it from an intrusion detection perspective. To do this, we are going to
    run our scans but this time not directly at the sensor. You will need the Kali
    Linux machine, OWASP, and the Network Security Toolkit. Start all the three virtual
    machines before we continue.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the machines are online, we will conduct a scan from our Kali Linux machine
    against the OWASP machine and across the VMnet2 switch with the Network Security
    Toolkit running a Snort sensor. The setup is shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with virtual switches](img/477-1_08-25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You will next need to start the Snort sensor on the Network Security Toolkit
    machine. We covered the steps for this earlier in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Start the sensor on the correct interface, select the one that is attached to
    VMnet2\. For the purposes of this book, we are using the eth1 interface.
  prefs: []
  type: TYPE_NORMAL
- en: Once the sensor is up and running, start the BASE GUI and clear all of the alerts
    that are currently listed. The next thing we want to do is conduct a scan against
    the OWASP machine from the Kali Linux machine. We can use any tool we want, but
    for the demonstration, we will use the Nikto tool that we used earlier. The target
    IP address for our OWASP machine is `10.2.0.132`, and this is the address we will
    use in our tools. In a Kali Linux terminal window, enter `nikto –h 10.2.0.132`
    to scan the OWASP machine. Return to the BASE display and see whether the attack
    has been detected.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with virtual switches](img/477-1_08-26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Screen showing the BASE display (the cropped text is not important)
  prefs: []
  type: TYPE_NORMAL
- en: 'As the previous screenshot shows, the traffic has generated some alerts. The
    next thing we will do is look at the alerts that the sensor generated. Click on
    **100%** and this will bring up a list of the alerts that the sensor reported.
    As we are using the Nikto tool, we are looking for the alerts that are related
    to web traffic. An example is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with virtual switches](img/477-1_08-27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We now have the alerts, so select one of them and examine it further. Earlier
    in the chapter when we examined the alerts, we saw additional information about
    the packet that generated the alert. However, we did not have any information
    on the payload of the packet. This is because there was no payload to capture.
    As these packets are attack patterns, we have a better chance of finding a payload.
    An example of a payload for a directory traversal attack is shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with virtual switches](img/477-1_08-28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can see that the sensor on a virtual switch does not require a SPAN or mirror
    to see the network traffic as a physical switch would, so we are ready to move
    on to another section.
  prefs: []
  type: TYPE_NORMAL
- en: Evasion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to discuss the topic of evasion. This comes from
    the often referred to concept of **Never Get Caught!** While this does make for
    good theatre, the reality is that this is rarely asked for in a penetration test.
    Furthermore, it is highly dependent on how the administrator has configured their
    environment. There is no guarantee that we will get through, but we can lab it
    up and at least find some things that might work if it is a part of our scope
    of work.
  prefs: []
  type: TYPE_NORMAL
- en: Determining thresholds
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What we want to focus on is the fact that all of these tools have to have some
    form of threshold, and will be alert when they reach this threshold. This is where
    we can find ways to evade detection. If we revisit our Snort sensor and clear
    all of the existing alerts, we can attempt a few different things to see when
    we get detected and when we do not get detected.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One thing to keep in mind is that any scan with illegal flag combinations will
    be detected instantly, so avoid these if evasion is part of your scope of work.
  prefs: []
  type: TYPE_NORMAL
- en: For the Snort sensor, the threshold seems to be around five closed ports, that
    is, the receipt of RST packets can get you detected; therefore, as long as you
    stay below five scanned ports at any one time you should not be detected.
  prefs: []
  type: TYPE_NORMAL
- en: Stress testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another type of testing we might need to perform against our IDS sensor is stress
    testing. With this technique, we generate a lot of noise and see whether the attack
    can be masked by the noise, or alternatively whether the sensor can be overwhelmed
    and stop working. Within the Kali distribution, there are a number of tools for
    this, and you are welcome to try them out. You can find them by navigating to
    **Applications** | **Kali Linux** | **Stress Testing** and reviewing the programs
    that are there. We will leave this testing to you for homework. You will discover
    that the IDS tools have been around long enough to not be flooded with these attacks.
    Having said that, there is always a chance and this is why we covered it.
  prefs: []
  type: TYPE_NORMAL
- en: Shell code obfuscation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When it comes to the detection of exploits, the data that gets detected is
    the shell code; furthermore, the signature of that code. As it is a standard,
    it is easy for the tool to detect it. We will look at this now. You will need
    your Kioptrix machine as we are going to exploit it. We have discussed a number
    of ways to do this, and for our purposes, we are going to exploit it using the
    metasploit tool. There are a number of parameters that we can manipulate when
    we try to avoid detection, and unfortunately, there are no guarantees. If you
    use the Armitage tool, then you can select **Show Advanced Options** to view the
    additional parameters we can use. An example of this is shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Shell code obfuscation](img/477-1_08-29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We will conduct the exploit with the default settings first to see what is
    detected by the BASE tool. Again, there are no guarantees when it comes to evasion,
    so it is a matter of experimentation and documenting your findings. An example
    of the exploit attempt is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Shell code obfuscation](img/477-1_08-30.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As the previous screenshot shows, we have not been successful, so now we will
    modify the payload and see whether we have any better luck. This is the process:
    you try different things and find what works and does not work. This is why it
    is a good thing that evasion is rarely asked for.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the advanced options, we can modify a number of the parameters, but at the
    time of writing this book, we were not able to successfully evade detection with
    any of these tools. If you want to learn more, you can gather more information
    and see a script that is written for antivirus evasion at: [http://healthtalkie.com/discussion/script-for-av-evasion-uz3mb.php](http://healthtalkie.com/discussion/script-for-av-evasion-uz3mb.php).'
  prefs: []
  type: TYPE_NORMAL
- en: We have one last thing to try with respect to evasion. Sometimes, it is easier
    to just try different ports that you know are not checked by default by an IDS.
    This omission is normal because of the fact that the traffic generates too many
    false positives.
  prefs: []
  type: TYPE_NORMAL
- en: Earlier in the chapter, we conducted a scan against the Network Security Toolkit
    using the Nikto tool and there was nothing detected. We will now take a closer
    look at this. The scan we did against the NST was against the port 443 and the
    protocol *HTTPS*. There can be more than one reason why it was not detected. First,
    we will test whether it was not detected because the attack was directed at the
    port 443, which in fact would be encrypted traffic and the IDS is blind to that.
    We have a couple of choices on how we can accomplish this test. We can turn on
    the web server on the NST virtual machine, or we can activate the HTTPS protocol
    on the server of the OWASP machine. We will use the NST machine; we have to navigate
    to the configuration file and uncomment the HTTP line to get it running on the
    machine. In a terminal window, enter `gvim /etc/httpd/conf/httpd.conf` to open
    the configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Scroll down to the section of the server configuration and remove the `#` to
    uncomment `Listen 80`, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Shell code obfuscation](img/477-1_08-31.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once you have finished editing, exit the editor by navigating to **File** |
    **Save-Exit**. The next thing you have to do is restart the web server. In the
    terminal window, enter `service httpd restart` to restart the service. Once the
    service has restarted, we will scan using Nikto against the NST machine. For the
    first scan, we will use the SSL option, but before you do this, make sure that
    you clear all of the queries in BASE. Return to your Kali machine and scan the
    IP address of the NST machine. In our example, the machine address is 10.2.0.144
    and this is what we will use. In the terminal window, enter `nikto -ssl -h 10.2.0.144`.
    When the scan finishes, return to your BASE and see whether the scan was detected.
    Were you detected? The answer should be no! Why is this? Well, before we answer
    this, as with all good testing, we will prove it. There should not be any alerts
    in your BASE display. Return to your Kali machine and run the scan again without
    forcing it to go over SSL. In the terminal window, enter `nikto -h 10.2.0.144`.
    Once the scan finishes, return to the BASE display and see whether the scan was
    detected. An example of the dashboard is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Shell code obfuscation](img/477-1_08-32.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Screen showing the BASE display (the cropped text is not important)
  prefs: []
  type: TYPE_NORMAL
- en: As the previous screenshot shows, we can direct our attacks at the SSL port
    443, but the sensor does not set an alert. This is quite common, but there always
    is a chance that the administrator has turned on the rule to check HTTPS traffic.
    However, it does give us a potential method to evade detection. Again, your success
    will vary, but if it is a part of the scope of work, some of these techniques
    might assist you in evading the monitoring capability of the client. This technique
    is also the process of tunneling, where we tunnel a protocol over another port,
    such as the SSH port so that the IDS might not check it as it is usually encrypted.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed the requirement to build an IDS/IPS capability
    in our range architecture. We discussed how to deploy a network-based IDS and
    the configuration of a sensor placed on each network segment. We deployed the
    Snort IDS and detected a number of attacks once we deployed it.
  prefs: []
  type: TYPE_NORMAL
- en: Following the network IDS, we looked at host-based protections and a product
    from Symantec that provides a number of methods for endpoint protection. We attempted
    to attack the machine using the web attack tool Nikto, and triggered the software
    to block the IP address once the attack was detected. We finished the section
    on endpoint protection by attempting to transfer a malicious file into the machine
    and the Symantec tool successfully detected the file and deleted it before the
    file was transferred to the machine.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we closed the chapter with a discussion on the topic of evasion. We
    explained that this is rarely asked for in a professional testing scope, but there
    is a chance that it could be. As discussed in the chapter, there are no guarantees
    when it comes to this, because we will only be as successful as the administrator
    who has configured the devices allows us to be. Having said that, one of the highest
    rates of success is found when we use ports that are known for containing encrypted
    data. Furthermore, we verified this by scanning the Network Security Toolkit virtual
    machine on port 443 without being detected, but when we ran the attack at port
    80, we were detected.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes the chapter. You have now deployed IDS/IPS into your range environment
    and you have seen methods to evade detection. In the next chapter, we will look
    at adding web servers and web applications to our range architecture.
  prefs: []
  type: TYPE_NORMAL
