- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Working with Data Using Entity Framework Core
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is about reading and writing to data stores, such as Microsoft
    SQL Server, SQLite, and Azure Cosmos DB, by using the object-to-data store mapping
    technology named **Entity Framework Core** (**EF Core** ).
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding modern databases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up EF Core
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining EF Core models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Querying EF Core models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loading patterns with EF Core
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manipulating data with EF Core
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with transactions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code First EF Core models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding modern databases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Two of the most common places to store data are in a **Relational Database Management
    System** (**RDBMS** ) such as Microsoft SQL Server, PostgreSQL, MySQL, and SQLite,
    or in a **NoSQL** database such as Microsoft Azure Cosmos DB, Redis, MongoDB,
    and Apache Cassandra.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding legacy Entity Framework
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Entity Framework** (**EF** ) was first released as part of .NET Framework
    3.5 with Service Pack 1 back in late 2008\. Since then, Entity Framework has evolved,
    as Microsoft has observed how programmers use an **object-relational mapping**
    (**ORM** ) tool in the real world.'
  prefs: []
  type: TYPE_NORMAL
- en: ORMs use a mapping definition to associate columns in tables to properties in
    classes. Then, a programmer can interact with objects of different types in a
    way that they are familiar with, instead of having to deal with knowing how to
    store the values in a relational table or another structure provided by a NoSQL
    data store.
  prefs: []
  type: TYPE_NORMAL
- en: The version of EF included with .NET Framework is **Entity Framework 6** (**EF6**
    ). It is mature, stable, and supports an EDMX (XML file) way of defining the model
    as well as complex inheritance models, and a few other advanced features.
  prefs: []
  type: TYPE_NORMAL
- en: EF 6.3 and later have been extracted from .NET Framework as a separate package
    so it can be supported on .NET Core 3.0 and later. This enables existing projects
    like web applications and services to be ported and run cross-platform. However,
    EF6 should be considered a legacy technology because it has some limitations when
    running cross-platform and no new features will be added to it.
  prefs: []
  type: TYPE_NORMAL
- en: Using the legacy Entity Framework 6.3 or later
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To use the legacy Entity Framework in a .NET Core 3.0 or later project, you
    must add a package reference to it in your project file, as shown in the following
    markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: <PackageReference Include="EntityFramework"
  prefs: []
  type: TYPE_NORMAL
- en: Version="6.4.4"
  prefs: []
  type: TYPE_NORMAL
- en: />
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice** : Only use legacy EF6 if you have to, for example, when migrating
    a WPF app that uses it. This book is about modern cross-platform development so,
    in the rest of this chapter, I will only cover the modern Entity Framework Core.
    You will not need to reference the legacy EF6 package as shown above in the projects
    for this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Entity Framework Core
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The truly cross-platform version, **EF Core** , is different from the legacy
    Entity Framework. Although EF Core has a similar name, you should be aware of
    how it varies from EF6\. The latest EF Core is version 6.0 to match .NET 6.0.
  prefs: []
  type: TYPE_NORMAL
- en: EF Core 5 and later only support .NET 5 and later. EF Core 3.0 and later only
    run on platforms that support .NET Standard 2.1, meaning .NET Core 3.0 and later.
    It does not support .NET Standard 2.0 platforms like .NET Framework 4.8.
  prefs: []
  type: TYPE_NORMAL
- en: As well as traditional RDBMSs, EF Core supports modern cloud-based, nonrelational,
    schema-less data stores, such as Microsoft Azure Cosmos DB and MongoDB, sometimes
    with third-party providers.
  prefs: []
  type: TYPE_NORMAL
- en: EF Core has so many improvements that this chapter cannot cover them all. I
    will focus on the fundamentals that all .NET developers should know and some of
    the cooler new features.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two approaches to working with EF Core:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Database First** : A database already exists, so you build a model that matches
    its structure and features.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Code First** : No database exists, so you build a model and then use EF Core
    to create a database that matches its structure and features.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will start by using EF Core with an existing database.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a console app for working with EF Core
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we will create a console app project for this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Use your preferred code editor to create a new solution/workspace named `Chapter10`
    .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a console app project, as defined in the following list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Project template: **Console Application** / `console`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Workspace/solution file and folder: `Chapter10`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Project file and folder: `WorkingWithEFCore`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using a sample relational database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To learn how to manage an RDBMS using .NET, it would be useful to have a sample
    one so that you can practice on one that has a medium complexity and a decent
    amount of sample records. Microsoft offers several sample databases, most of which
    are too complex for our needs, so instead, we will use a database that was first
    created in the early 1990s known as **Northwind** .
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a minute to look at a diagram of the Northwind database. You can
    use the following diagram to refer to as we write code and queries throughout
    this book:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram Description automatically generated](img/Image00089.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.1: The Northwind database tables and relationships'
  prefs: []
  type: TYPE_NORMAL
- en: 'You will write code to work with the `Categories` and `Products` tables later
    in this chapter and other tables in later chapters. But before we do, note that:'
  prefs: []
  type: TYPE_NORMAL
- en: Each category has a unique identifier, name, description, and picture.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each product has a unique identifier, name, unit price, units in stock, and
    other fields.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each product is associated with a category by storing the category's unique
    identifier.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The relationship between `Categories` and `Products` is one-to-many, meaning
    each category can have zero or more products.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Microsoft SQL Server for Windows
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Microsoft offers various editions of its popular and capable SQL Server product
    for Windows, Linux, and Docker containers. We will use a free version that can
    run standalone, known as SQL Server Developer Edition. You can also use the Express
    edition or the free SQL Server LocalDB edition that can be installed with Visual
    Studio for Windows.
  prefs: []
  type: TYPE_NORMAL
- en: If you do not have a Windows computer or you want to use a cross-platform database
    system, then you can skip ahead to the topic *Using SQLite* .
  prefs: []
  type: TYPE_NORMAL
- en: Downloading and installing SQL Server
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can download SQL Server editions from the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.microsoft.com/en-us/sql-server/sql-server-downloads](https://www.microsoft.com/en-us/sql-server/sql-server-downloads)'
  prefs: []
  type: TYPE_NORMAL
- en: Download the **Developer** edition.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the installer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **Custom** installation type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select a folder for the installation files and then click **Install** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Wait for the 1.5 GB of installer files to download.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In **SQL Server Installation Center** , click **Installation** , and then click
    **New SQL Server stand-alone installation or add features to an existing installation**
    .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Developer** as the free edition and then click **Next** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Accept the license terms and then click **Next** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Review the install rules, fix any issues, and then click **Next** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In **Feature Selection** , select **Database Engine Services** , and then click
    **Next** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In **Instance Configuration** , select **Default instance** , and then click
    **Next** . If you already have a default instance configured, then you could create
    a named instance, perhaps called `cs10dotnet6` .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In **Server Configuration** , note the **SQL Server** **Database Engine** is
    configured to start automatically. Set the **SQL Server Browser** to start automatically,
    and then click **Next** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In **Database Engine Configuration** , on the **Server Configuration** tab,
    set **Authentication Mode** to **Mixed** , set the **sa** account password to
    a strong password, click **Add Current User** , and then click **Next** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In **Ready to Install** , review the actions that will be taken, and then click
    **Install** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In **Complete** , note the successful actions taken, and then click **Close**
    .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In **SQL Server Installation Center** , in **Installation** , click **Install
    SQL Server Management Tools** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the browser window, click to download the latest version of SSMS.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the installer and click **Install** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the installer has finished, click **Restart** if needed or **Close** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating the Northwind sample database for SQL Server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now we can run a database script to create the Northwind sample database:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have not previously downloaded or cloned the GitHub repository for this
    book, then do so now using the following link: [https://github.com/markjprice/cs10dotnet6/](https://github.com/markjprice/cs10dotnet6/)
    .'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Copy the script to create the Northwind database for SQL Server from the following
    path in your local Git repository: `/sql-scripts/Northwind4SQLServer.sql` into
    the `WorkingWithEFCore` folder.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start **SQL Server Management Studio** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Connect to Server** dialog, for **Server name** , enter `.` (a dot)
    meaning the local computer name, and then click **Connect** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you had to create a named instance, like `cs10dotnet6` , then enter `.\cs10dotnet6`
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to **File** | **Open** | **File...** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Browse to select the `Northwind4SQLServer.sql` file and then click **Open**
    .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the toolbar, click **Execute** , and note the **the Command(s) completed
    successfully** message.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In **Object Explorer** , expand the **Northwind** database, and then expand
    **Tables** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click **Products** , click **Select Top 1000 Rows** , and note the returned
    results, as shown in *Figure 10.2* :![](img/Image00090.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 10.2: The Products table in SQL Server Management Studio'
  prefs: []
  type: TYPE_NORMAL
- en: In the **Object Explorer** toolbar, click the **Disconnect** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Exit SQL Server Management Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Managing the Northwind sample database with Server Explorer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We did not have to use SQL Server Management Studio to execute the database
    script. We can also use tools in Visual Studio including the **SQL Server Object
    Explorer** and **Server Explorer** :'
  prefs: []
  type: TYPE_NORMAL
- en: In Visual Studio, choose **View** | **Server Explorer** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Server Explorer** window, right-click **Data Connections** and choose
    **Add Connection...** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you see the **Choose Data Source** dialog, as shown in *Figure 10.3* , select
    **Microsoft SQL Server** and then click **Continue** :![Graphical user interface,
    application Description automatically generated](img/Image00091.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 10.3: Choosing SQL Server as the data source'
  prefs: []
  type: TYPE_NORMAL
- en: In the **Add Connection** dialog, enter the server name as `.` , enter the database
    name as `Northwind` , and then click **OK** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In **Server Explorer** , expand the data connection and its tables. You should
    see 13 tables, including the **Categories** and **Products** tables.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click the **Products** table, choose **Show Table Data** , and note the
    77 rows of products are returned.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To see the details of the **Products** table columns and types, right-click
    **Products** and choose **Open Table Definition** , or double-click the table
    in **Server Explorer** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using SQLite
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SQLite is a small, cross-platform, self-contained RDBMS that is available in
    the public domain. It's the most common RDBMS for mobile platforms such as iOS
    (iPhone and iPad) and Android. Even if you use Windows and set up SQL Server in
    the previous section, you might want to set up SQLite too. The code that we write
    will work with both and it can be interesting to see the subtle differences.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up SQLite for macOS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: SQLite is included in macOS in the `/usr/bin/` directory as a command-line application
    named `sqlite3` .
  prefs: []
  type: TYPE_NORMAL
- en: Setting up SQLite for Windows
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'On Windows, we need to add the folder for SQLite to the system path so it will
    be found when we enter commands at a command prompt or terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start your favorite browser and navigate to the following link: [https://www.sqlite.org/download.html](https://www.sqlite.org/download.html)
    .'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Scroll down the page to the **Precompiled Binaries for Windows** section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **sqlite-tools-win32-x86-3360000.zip** . Note the file might have a higher
    version number after this book is published.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Extract the ZIP file into a folder named `C:\Sqlite\` .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to **Windows Settings** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Search for `environment` and choose **Edit the system environment variables**
    . On non-English versions of Windows, please search for the equivalent word in
    your local language to find the setting.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the **Environment Variables** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In **System variables** , select **Path** in the list, and then click **Edit…**
    .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **New** , enter `C:\Sqlite` , and press Enter .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **OK** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **OK** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **OK** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Close **Windows Settings** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Setting up SQLite for other OSes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'SQLite can be downloaded and installed for other OSes from the following link:
    [https://www.sqlite.org/download.html](https://www.sqlite.org/download.html) .'
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Northwind sample database for SQLite
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now we can create the Northwind sample database for SQLite using an SQL script:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have not previously cloned the GitHub repository for this book, then
    do so now using the following link: [https://github.com/markjprice/cs10dotnet6/](https://github.com/markjprice/cs10dotnet6/)
    .'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Copy the script to create the Northwind database for SQLite from the following
    path in your local Git repository: `/sql-scripts/Northwind4SQLite.sql` into the
    `WorkingWithEFCore` folder.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Start a command line in the `WorkingWithEFCore` folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On Windows, start **File Explorer** , right-click the `WorkingWithEFCore` folder,
    and select **New Command Prompt at Folder** or **Open in Windows Terminal** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On macOS, start **Finder** , right-click the `WorkingWithEFCore` folder, and
    select **New Terminal at Folder** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter the command to execute the SQL script using SQLite and create the `Northwind.db`
    database, as shown in the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: sqlite3 Northwind.db -init Northwind4SQLite.sql
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Be patient because this command might take a while to create the database structure.
    Eventually, you will see the SQLite command prompt, as shown in the following
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: -- Loading resources from Northwind4SQLite.sql
  prefs: []
  type: TYPE_NORMAL
- en: SQLite version 3.36.0 2021-08-24 15:20:15
  prefs: []
  type: TYPE_NORMAL
- en: Enter ".help" for usage hints.
  prefs: []
  type: TYPE_NORMAL
- en: sqlite>
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Press Ctrl + C on Windows or Ctrl + D on macOS to exit SQLite command mode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Leave your terminal or command prompt window open because you will use it again
    soon.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Managing the Northwind sample database with SQLiteStudio
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can use a cross-platform graphical database manager named **SQLiteStudio**
    to easily manage SQLite databases:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to the following link, [https://sqlitestudio.pl](https://sqlitestudio.pl)
    , and download and extract the application to your preferred location.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start **SQLiteStudio** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the **Database** menu, choose **Add a database** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Database** dialog, in the **File** section, click on the yellow folder
    button to browse for an existing database file on the local computer, select the
    `Northwind.db` file in the `WorkingWithEFCore` folder, and then click **OK** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the **Northwind** database and choose **Connect to the database**
    . You will see the 10 tables that were created by the script. (The script for
    SQLite is simpler than the one for SQL Server; it does not create as many tables
    or other database objects.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the **Products** table and choose **Edit the table** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the table editor window, note the structure of the `Products` table, including
    column names, data types, keys, and constraints, as shown in *Figure 10.4* :![Graphical
    user interface, text, application Description automatically generated](img/Image00092.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 10.4: The table editor in SQLiteStudio showing the structure of the
    Products table'
  prefs: []
  type: TYPE_NORMAL
- en: In the table editor window, click the **Data** tab, and you will see 77 products,
    as shown in *Figure 10.5* :![Graphical user interface, text, application Description
    automatically generated](img/Image00093.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 10.5: The Data tab showing the rows in the Products table'
  prefs: []
  type: TYPE_NORMAL
- en: In the **Database** window, right-click **Northwind** and select **Disconnect
    from the database** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Exit SQLiteStudio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Setting up EF Core
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we dive into the practicalities of managing data using EF Core, let's
    briefly talk about choosing between EF Core data providers.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing an EF Core database provider
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To manage data in a specific database, we need classes that know how to efficiently
    talk to that database.
  prefs: []
  type: TYPE_NORMAL
- en: EF Core database providers are sets of classes that are optimized for a specific
    data store. There is even a provider for storing the data in the memory of the
    current process, which can be useful for high-performance unit testing since it
    avoids hitting an external system.
  prefs: []
  type: TYPE_NORMAL
- en: 'They are distributed as NuGet packages, as shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| To manage this data store | Install this NuGet package |'
  prefs: []
  type: TYPE_TB
- en: '| Microsoft SQL Server 2012 or later | `Microsoft.EntityFrameworkCore.SqlServer`
    |'
  prefs: []
  type: TYPE_TB
- en: '| SQLite 3.7 or later | `Microsoft.EntityFrameworkCore.SQLite` |'
  prefs: []
  type: TYPE_TB
- en: '| MySQL | `MySQL.Data.EntityFrameworkCore` |'
  prefs: []
  type: TYPE_TB
- en: '| In-memory | `Microsoft.EntityFrameworkCore.InMemory` |'
  prefs: []
  type: TYPE_TB
- en: '| Azure Cosmos DB SQL API | `Microsoft.EntityFrameworkCore.Cosmos` |'
  prefs: []
  type: TYPE_TB
- en: '| Oracle DB 11.2 | `Oracle.EntityFrameworkCore` |'
  prefs: []
  type: TYPE_TB
- en: You can install as many EF Core database providers in the same project as you
    need. Each package includes the shared types as well as provider-specific types.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to a database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To connect to an SQLite database, we just need to know the database filename,
    set using the parameter `Filename` .
  prefs: []
  type: TYPE_NORMAL
- en: 'To connect to an SQL Server database, we need to know multiple pieces of information,
    as shown in the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: The name of the server (and the instance if it has one).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The name of the database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security information, such as username and password, or if we should pass the
    currently logged-on user's credentials automatically.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We specify this information in a **connection string** .
  prefs: []
  type: TYPE_NORMAL
- en: 'For backward compatibility, there are multiple possible keywords we can use
    in an SQL Server connection string for the various parameters, as shown in the
    following list:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Data Source` or `server` or `addr` : These keywords are the name of the server
    (and an optional instance). You can use a dot `.` to mean the local server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Initial Catalog` or `database` : These keywords are the name of the database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Integrated Security` or `trusted_connection` : These keywords are set to `true`
    or `SSPI` to pass the thread''s current user credentials.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MultipleActiveResultSets` : This keyword is set to `true` to enable a single
    connection to be used to work with multiple tables simultaneously to improve efficiency.
    It is used for lazy loading rows from related tables.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As described in the list above, when you write code to connect to an SQL Server
    database, you need to know its server name. The server name depends on the edition
    and version of SQL Server that you will connect to, as shown in the following
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| SQL Server edition | Server name \ Instance name |'
  prefs: []
  type: TYPE_TB
- en: '| LocalDB 2012 | `(localdb)\v11.0` |'
  prefs: []
  type: TYPE_TB
- en: '| LocalDB 2016 or later | `(localdb)\mssqllocaldb` |'
  prefs: []
  type: TYPE_TB
- en: '| Express | `.\sqlexpress` |'
  prefs: []
  type: TYPE_TB
- en: '| Full/Developer (default instance) | `.` |'
  prefs: []
  type: TYPE_TB
- en: '| Full/Developer (named instance) | `.\cs10dotnet6` |'
  prefs: []
  type: TYPE_TB
- en: '**Good Practice** : Use a dot `.` as shorthand for the local computer name.
    Remember that server names for SQL Server are made of two parts: the name of the
    computer and the name of an SQL Server instance. You provide instance names during
    custom installation.'
  prefs: []
  type: TYPE_NORMAL
- en: Defining the Northwind database context class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Northwind` class will be used to represent the database. To use EF Core,
    the class must inherit from `DbContext` . This class understands how to communicate
    with databases and dynamically generate SQL statements to query and manipulate
    data.
  prefs: []
  type: TYPE_NORMAL
- en: Your `DbContext` -derived class should have an overridden method named `OnConfiguring`
    , which will set the database connection string.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make it easy for you to try SQLite and SQL Server, we will create a project
    that supports both, with a `string` field to control which is used at runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `WorkingWithEFCore` project, add package references to the EF Core data
    provider for both SQL Server and SQLite, as shown in the following markup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: <ItemGroup>
  prefs: []
  type: TYPE_NORMAL
- en: <PackageReference
  prefs: []
  type: TYPE_NORMAL
- en: Include="Microsoft.EntityFrameworkCore.Sqlite"
  prefs: []
  type: TYPE_NORMAL
- en: Version="6.0.0"
  prefs: []
  type: TYPE_NORMAL
- en: />
  prefs: []
  type: TYPE_NORMAL
- en: <PackageReference
  prefs: []
  type: TYPE_NORMAL
- en: Include="Microsoft.EntityFrameworkCore.SqlServer"
  prefs: []
  type: TYPE_NORMAL
- en: Version="6.0.0"
  prefs: []
  type: TYPE_NORMAL
- en: />
  prefs: []
  type: TYPE_NORMAL
- en: </ItemGroup>
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Build the project to restore packages.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a class file named `ProjectConstants.cs` .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `ProjectConstants.cs` , define a class with a public string constant to
    store the database provider name that you want to use, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: namespace
  prefs: []
  type: TYPE_NORMAL
- en: Packt.Shared
  prefs: []
  type: TYPE_NORMAL
- en: ;
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: class
  prefs: []
  type: TYPE_NORMAL
- en: ProjectConstants
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: const
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: DatabaseProvider = "SQLite"
  prefs: []
  type: TYPE_NORMAL
- en: ; // or "SQLServer"
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs` , import the `Packt.Shared` namespace and output the database
    provider, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine($"Using
  prefs: []
  type: TYPE_NORMAL
- en: '{ProjectConstants.DatabaseProvider}'
  prefs: []
  type: TYPE_NORMAL
- en: database provider."
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Add a class file named `Northwind.cs` .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Northwind.cs` , define a class named `Northwind` , import the main namespace
    for EF Core, make the class inherit from `DbContext` , and in an `OnConfiguring`
    method, check the `provider` field to either use SQLite or SQL Server, as shown
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft.EntityFrameworkCore; // DbContext, DbContextOptionsBuilder
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: static
  prefs: []
  type: TYPE_NORMAL
- en: System.Console;
  prefs: []
  type: TYPE_NORMAL
- en: namespace
  prefs: []
  type: TYPE_NORMAL
- en: Packt.Shared
  prefs: []
  type: TYPE_NORMAL
- en: ;
  prefs: []
  type: TYPE_NORMAL
- en: // this manages the connection to the database
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: class
  prefs: []
  type: TYPE_NORMAL
- en: Northwind
  prefs: []
  type: TYPE_NORMAL
- en: ': DbContext'
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: protected
  prefs: []
  type: TYPE_NORMAL
- en: override
  prefs: []
  type: TYPE_NORMAL
- en: void
  prefs: []
  type: TYPE_NORMAL
- en: OnConfiguring
  prefs: []
  type: TYPE_NORMAL
- en: (
  prefs: []
  type: TYPE_NORMAL
- en: DbContextOptionsBuilder optionsBuilder
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: if
  prefs: []
  type: TYPE_NORMAL
- en: (ProjectConstants.DatabaseProvider == "SQLite"
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: path = Path.Combine(
  prefs: []
  type: TYPE_NORMAL
- en: Environment.CurrentDirectory, "Northwind.db"
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine($"Using
  prefs: []
  type: TYPE_NORMAL
- en: '{path}'
  prefs: []
  type: TYPE_NORMAL
- en: database file."
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: optionsBuilder.UseSqlite($"Filename=
  prefs: []
  type: TYPE_NORMAL
- en: '{path}'
  prefs: []
  type: TYPE_NORMAL
- en: '"'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: else
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: connection = "Data Source=.;"
  prefs: []
  type: TYPE_NORMAL
- en: +
  prefs: []
  type: TYPE_NORMAL
- en: '"Initial Catalog=Northwind;"'
  prefs: []
  type: TYPE_NORMAL
- en: +
  prefs: []
  type: TYPE_NORMAL
- en: '"Integrated Security=true;"'
  prefs: []
  type: TYPE_NORMAL
- en: +
  prefs: []
  type: TYPE_NORMAL
- en: '"MultipleActiveResultSets=true;"'
  prefs: []
  type: TYPE_NORMAL
- en: ;
  prefs: []
  type: TYPE_NORMAL
- en: optionsBuilder.UseSqlServer(connection);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: If you are using Visual Studio for Windows, then the compiled application executes
    in the `WorkingWithEFCore\bin\Debug\net6.0` folder so it will not find the database
    file.
  prefs: []
  type: TYPE_NORMAL
- en: In **Solution Explorer** , right-click the `Northwind.db` file and select **Properties**
    .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In **Properties** , set **Copy to Output Directory** to **Copy always** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open `WorkingWithEFCore.csproj` and note the new elements, as shown in the
    following markup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: <ItemGroup>
  prefs: []
  type: TYPE_NORMAL
- en: <None Update="Northwind.db"
  prefs: []
  type: TYPE_NORMAL
- en: '>'
  prefs: []
  type: TYPE_NORMAL
- en: <CopyToOutputDirectory>Always</CopyToOutputDirectory>
  prefs: []
  type: TYPE_NORMAL
- en: </None>
  prefs: []
  type: TYPE_NORMAL
- en: </ItemGroup>
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: If you are using Visual Studio Code, then the compiled application executes
    in the `WorkingWithEFCore` folder so it will find the database file without it
    being copied.
  prefs: []
  type: TYPE_NORMAL
- en: Run the console application and note the output showing which database provider
    you chose to use.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Defining EF Core models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: EF Core uses a combination of **conventions** , **annotation attributes** ,
    and **Fluent API** statements to build an entity model at runtime so that any
    actions performed on the classes can later be automatically translated into actions
    performed on the actual database. An entity class represents the structure of
    a table and an instance of the class represents a row in that table.
  prefs: []
  type: TYPE_NORMAL
- en: First, we will review the three ways to define a model, with code examples,
    and then we will create some classes that implement those techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Using EF Core conventions to define the model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The code we will write will use the following conventions:'
  prefs: []
  type: TYPE_NORMAL
- en: The name of a table is assumed to match the name of a `DbSet<T>` property in
    the `DbContext` class, for example, `Products` .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The names of the columns are assumed to match the names of properties in the
    entity model class, for example, `ProductId` .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `string` .NET type is assumed to be a `nvarchar` type in the database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `int` .NET type is assumed to be an `int` type in the database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The primary key is assumed to be a property that is named `Id` or `ID` , or
    when the entity model class is named `Product` , then the property can be named
    `ProductId` or `ProductID` . If this property is an integer type or the `Guid`
    type, then it is also assumed to be an `IDENTITY` column (a column type that automatically
    assigns a value when inserting).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Good Practice** : There are many other conventions that you should know,
    and you can even define your own, but that is beyond the scope of this book. You
    can read about them at the following link: [https://docs.microsoft.com/en-us/ef/core/modeling/](https://docs.microsoft.com/en-us/ef/core/modeling/)'
  prefs: []
  type: TYPE_NORMAL
- en: Using EF Core annotation attributes to define the model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Conventions often aren't enough to completely map the classes to the database
    objects. A simple way of adding more smarts to your model is to apply annotation
    attributes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some common attributes are shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Attribute | Description |'
  prefs: []
  type: TYPE_TB
- en: '| `[Required]` | Ensures the value is not `null` . |'
  prefs: []
  type: TYPE_TB
- en: '| `[StringLength(50)]` | Ensures the value is up to 50 characters in length.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `[RegularExpression(expression)]` | Ensures the value matches the specified
    regular expression. |'
  prefs: []
  type: TYPE_TB
- en: '| `[Column(TypeName = "money", Name = "UnitPrice")]` | Specifies the column
    type and column name used in the table. |'
  prefs: []
  type: TYPE_TB
- en: 'For example, in the database, the maximum length of a product name is 40, and
    the value cannot be null, as shown highlighted in the following **Data Definition
    Language** (**DDL** ) code that defines how to create a table named `Products`
    with its columns, data types, keys, and other constraints:'
  prefs: []
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: CREATE
  prefs: []
  type: TYPE_NORMAL
- en: TABLE
  prefs: []
  type: TYPE_NORMAL
- en: Products (
  prefs: []
  type: TYPE_NORMAL
- en: ProductId       INTEGER
  prefs: []
  type: TYPE_NORMAL
- en: PRIMARY KEY
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: ProductName     NVARCHAR
  prefs: []
  type: TYPE_NORMAL
- en: (40
  prefs: []
  type: TYPE_NORMAL
- en: ) NOT
  prefs: []
  type: TYPE_NORMAL
- en: 'NULL'
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: SupplierId      "INT"
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: CategoryId      "INT"
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: QuantityPerUnit NVARCHAR
  prefs: []
  type: TYPE_NORMAL
- en: (20
  prefs: []
  type: TYPE_NORMAL
- en: ),
  prefs: []
  type: TYPE_NORMAL
- en: UnitPrice       "MONEY"
  prefs: []
  type: TYPE_NORMAL
- en: CONSTRAINT
  prefs: []
  type: TYPE_NORMAL
- en: DF_Products_UnitPrice DEFAULT
  prefs: []
  type: TYPE_NORMAL
- en: (0
  prefs: []
  type: TYPE_NORMAL
- en: ),
  prefs: []
  type: TYPE_NORMAL
- en: UnitsInStock    "SMALLINT"
  prefs: []
  type: TYPE_NORMAL
- en: CONSTRAINT
  prefs: []
  type: TYPE_NORMAL
- en: DF_Products_UnitsInStock DEFAULT
  prefs: []
  type: TYPE_NORMAL
- en: (0
  prefs: []
  type: TYPE_NORMAL
- en: ),
  prefs: []
  type: TYPE_NORMAL
- en: UnitsOnOrder    "SMALLINT"
  prefs: []
  type: TYPE_NORMAL
- en: CONSTRAINT
  prefs: []
  type: TYPE_NORMAL
- en: DF_Products_UnitsOnOrder DEFAULT
  prefs: []
  type: TYPE_NORMAL
- en: (0
  prefs: []
  type: TYPE_NORMAL
- en: ),
  prefs: []
  type: TYPE_NORMAL
- en: ReorderLevel    "SMALLINT"
  prefs: []
  type: TYPE_NORMAL
- en: CONSTRAINT
  prefs: []
  type: TYPE_NORMAL
- en: DF_Products_ReorderLevel DEFAULT
  prefs: []
  type: TYPE_NORMAL
- en: (0
  prefs: []
  type: TYPE_NORMAL
- en: ),
  prefs: []
  type: TYPE_NORMAL
- en: Discontinued    "BIT"
  prefs: []
  type: TYPE_NORMAL
- en: NOT
  prefs: []
  type: TYPE_NORMAL
- en: 'NULL'
  prefs: []
  type: TYPE_NORMAL
- en: CONSTRAINT
  prefs: []
  type: TYPE_NORMAL
- en: DF_Products_Discontinued DEFAULT
  prefs: []
  type: TYPE_NORMAL
- en: (0
  prefs: []
  type: TYPE_NORMAL
- en: ),
  prefs: []
  type: TYPE_NORMAL
- en: CONSTRAINT
  prefs: []
  type: TYPE_NORMAL
- en: FK_Products_Categories FOREIGN
  prefs: []
  type: TYPE_NORMAL
- en: KEY
  prefs: []
  type: TYPE_NORMAL
- en: (
  prefs: []
  type: TYPE_NORMAL
- en: CategoryId
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: REFERENCES
  prefs: []
  type: TYPE_NORMAL
- en: Categories (CategoryId),
  prefs: []
  type: TYPE_NORMAL
- en: CONSTRAINT
  prefs: []
  type: TYPE_NORMAL
- en: FK_Products_Suppliers FOREIGN
  prefs: []
  type: TYPE_NORMAL
- en: KEY
  prefs: []
  type: TYPE_NORMAL
- en: (
  prefs: []
  type: TYPE_NORMAL
- en: SupplierId
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: REFERENCES
  prefs: []
  type: TYPE_NORMAL
- en: Suppliers (SupplierId),
  prefs: []
  type: TYPE_NORMAL
- en: CONSTRAINT
  prefs: []
  type: TYPE_NORMAL
- en: CK_Products_UnitPrice CHECK
  prefs: []
  type: TYPE_NORMAL
- en: (UnitPrice >= 0
  prefs: []
  type: TYPE_NORMAL
- en: ),
  prefs: []
  type: TYPE_NORMAL
- en: CONSTRAINT
  prefs: []
  type: TYPE_NORMAL
- en: CK_ReorderLevel CHECK
  prefs: []
  type: TYPE_NORMAL
- en: (ReorderLevel >= 0
  prefs: []
  type: TYPE_NORMAL
- en: ),
  prefs: []
  type: TYPE_NORMAL
- en: CONSTRAINT
  prefs: []
  type: TYPE_NORMAL
- en: CK_UnitsInStock CHECK
  prefs: []
  type: TYPE_NORMAL
- en: (UnitsInStock >= 0
  prefs: []
  type: TYPE_NORMAL
- en: ),
  prefs: []
  type: TYPE_NORMAL
- en: CONSTRAINT
  prefs: []
  type: TYPE_NORMAL
- en: CK_UnitsOnOrder CHECK
  prefs: []
  type: TYPE_NORMAL
- en: (UnitsOnOrder >= 0
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'In a `Product` class, we could apply attributes to specify this, as shown in
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: '[Required'
  prefs: []
  type: TYPE_NORMAL
- en: ']'
  prefs: []
  type: TYPE_NORMAL
- en: '[StringLength(40)'
  prefs: []
  type: TYPE_NORMAL
- en: ']'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: ProductName { get
  prefs: []
  type: TYPE_NORMAL
- en: ; set
  prefs: []
  type: TYPE_NORMAL
- en: ; }
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: When there isn't an obvious map between .NET types and database types, an attribute
    can be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, in the database, the column type of `UnitPrice` for the `Products`
    table is `money` . .NET does not have a `money` type, so it should use `decimal`
    instead, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: '[Column(TypeName ='
  prefs: []
  type: TYPE_NORMAL
- en: '"money"'
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: ']'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: decimal
  prefs: []
  type: TYPE_NORMAL
- en: '? UnitPrice { get'
  prefs: []
  type: TYPE_NORMAL
- en: ; set
  prefs: []
  type: TYPE_NORMAL
- en: ; }
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another example is for the `Categories` table, as shown in the following DDL
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: CREATE
  prefs: []
  type: TYPE_NORMAL
- en: TABLE
  prefs: []
  type: TYPE_NORMAL
- en: Categories (
  prefs: []
  type: TYPE_NORMAL
- en: CategoryId   INTEGER
  prefs: []
  type: TYPE_NORMAL
- en: PRIMARY KEY
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: CategoryName NVARCHAR
  prefs: []
  type: TYPE_NORMAL
- en: (15
  prefs: []
  type: TYPE_NORMAL
- en: ) NOT
  prefs: []
  type: TYPE_NORMAL
- en: 'NULL'
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: Description  "NTEXT"
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: Picture      "IMAGE"
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Description` column can be longer than the maximum 8,000 characters that
    can be stored in a `nvarchar` variable, so it needs to map to `ntext` instead,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: '[Column(TypeName ='
  prefs: []
  type: TYPE_NORMAL
- en: '"ntext"'
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: ']'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: Description { get
  prefs: []
  type: TYPE_NORMAL
- en: ; set
  prefs: []
  type: TYPE_NORMAL
- en: ; }
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Using the EF Core Fluent API to define the model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The last way that the model can be defined is by using the Fluent API. This
    API can be used instead of attributes, as well as being used in addition to them.
    For example, to define the `ProductName` property, instead of decorating the property
    with two attributes, an equivalent Fluent API statement could be written in the
    `OnModelCreating` method of the database context class, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: modelBuilder.Entity<Product>()
  prefs: []
  type: TYPE_NORMAL
- en: .Property(product => product.ProductName)
  prefs: []
  type: TYPE_NORMAL
- en: .IsRequired()
  prefs: []
  type: TYPE_NORMAL
- en: .HasMaxLength(40
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: This keeps the entity model class simpler.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding data seeding with the Fluent API
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another benefit of the Fluent API is to provide initial data to populate a database.
    EF Core automatically works out what insert, update, or delete operations must
    be executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if we wanted to make sure that a new database has at least one
    row in the `Product` table, then we would call the `HasData` method, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: modelBuilder.Entity<Product>()
  prefs: []
  type: TYPE_NORMAL
- en: .HasData(new
  prefs: []
  type: TYPE_NORMAL
- en: Product
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: ProductId = 1
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: ProductName = "Chai"
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: UnitPrice = 8.99
  prefs: []
  type: TYPE_NORMAL
- en: M
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Our model will map to an existing database that is already populated with data
    so we will not need to use this technique in our code.
  prefs: []
  type: TYPE_NORMAL
- en: Building an EF Core model for the Northwind tables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that you've learned about ways to define an EF Core model, let's build a
    model to represent two tables in the `Northwind` database.
  prefs: []
  type: TYPE_NORMAL
- en: 'The two entity classes will refer to each other, so to avoid compiler errors,
    we will create the classes without any members first:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `WorkingWithEFCore` project, add two class files named `Category.cs`
    and `Product.cs` .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Category.cs` , define a class named `Category` , as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: namespace
  prefs: []
  type: TYPE_NORMAL
- en: Packt.Shared
  prefs: []
  type: TYPE_NORMAL
- en: ;
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: class
  prefs: []
  type: TYPE_NORMAL
- en: Category
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Product.cs` , define a class named `Product` , as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: namespace
  prefs: []
  type: TYPE_NORMAL
- en: Packt.Shared
  prefs: []
  type: TYPE_NORMAL
- en: ;
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: class
  prefs: []
  type: TYPE_NORMAL
- en: Product
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Defining the Category and Product entity classes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `Category` class, also known as an entity model, will be used to represent
    a row in the `Categories` table. This table has four columns, as shown in the
    following DDL:'
  prefs: []
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: CREATE
  prefs: []
  type: TYPE_NORMAL
- en: TABLE
  prefs: []
  type: TYPE_NORMAL
- en: Categories (
  prefs: []
  type: TYPE_NORMAL
- en: CategoryId   INTEGER
  prefs: []
  type: TYPE_NORMAL
- en: PRIMARY KEY
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: CategoryName NVARCHAR
  prefs: []
  type: TYPE_NORMAL
- en: (15
  prefs: []
  type: TYPE_NORMAL
- en: ) NOT
  prefs: []
  type: TYPE_NORMAL
- en: 'NULL'
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: Description  "NTEXT"
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: Picture      "IMAGE"
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use conventions to define:'
  prefs: []
  type: TYPE_NORMAL
- en: Three of the four properties (we will not map the `Picture` column).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The primary key.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The one-to-many relationship to the `Products` table.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To map the `Description` column to the correct database type, we will need to
    decorate the `string` property with the `Column` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Later in this chapter, we will use the Fluent API to define that `CategoryName`
    cannot be null and is limited to a maximum of 15 characters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the `Category` entity model class, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: System.ComponentModel.DataAnnotations.Schema; // [Column]
  prefs: []
  type: TYPE_NORMAL
- en: namespace
  prefs: []
  type: TYPE_NORMAL
- en: Packt.Shared
  prefs: []
  type: TYPE_NORMAL
- en: ;
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: class
  prefs: []
  type: TYPE_NORMAL
- en: Category
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: // these properties map to columns in the database
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: int
  prefs: []
  type: TYPE_NORMAL
- en: CategoryId { get
  prefs: []
  type: TYPE_NORMAL
- en: ; set
  prefs: []
  type: TYPE_NORMAL
- en: ; }
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: '? CategoryName { get'
  prefs: []
  type: TYPE_NORMAL
- en: ; set
  prefs: []
  type: TYPE_NORMAL
- en: ; }
  prefs: []
  type: TYPE_NORMAL
- en: '[Column(TypeName ='
  prefs: []
  type: TYPE_NORMAL
- en: '"ntext"'
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: ']'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: '? Description { get'
  prefs: []
  type: TYPE_NORMAL
- en: ; set
  prefs: []
  type: TYPE_NORMAL
- en: ; }
  prefs: []
  type: TYPE_NORMAL
- en: // defines a navigation property for related rows
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: virtual
  prefs: []
  type: TYPE_NORMAL
- en: ICollection<Product> Products { get
  prefs: []
  type: TYPE_NORMAL
- en: ; set
  prefs: []
  type: TYPE_NORMAL
- en: ; }
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: Category
  prefs: []
  type: TYPE_NORMAL
- en: ()
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: // to enable developers to add products to a Category we must
  prefs: []
  type: TYPE_NORMAL
- en: // initialize the navigation property to an empty collection
  prefs: []
  type: TYPE_NORMAL
- en: Products = new
  prefs: []
  type: TYPE_NORMAL
- en: HashSet<Product>();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: The `Product` class will be used to represent a row in the `Products` table,
    which has ten columns.
  prefs: []
  type: TYPE_NORMAL
- en: 'You do not need to include all columns from a table as properties of a class.
    We will only map six properties: `ProductId` , `ProductName` , `UnitPrice` , `UnitsInStock`
    , `Discontinued` , and `CategoryId` .'
  prefs: []
  type: TYPE_NORMAL
- en: Columns that are not mapped to properties cannot be read or set using the class
    instances. If you use the class to create a new object, then the new row in the
    table will have `NULL` or some other default value for the unmapped column values
    in that row. You must make sure that those missing columns are optional or have
    default values set by the database or an exception will be thrown at runtime.
    In this scenario, the rows already have data values and I have decided that I
    do not need to read those values in this application.
  prefs: []
  type: TYPE_NORMAL
- en: We can rename a column by defining a property with a different name, like `Cost`
    , and then decorating the property with the `[Column]` attribute and specifying
    its column name, like `UnitPrice` .
  prefs: []
  type: TYPE_NORMAL
- en: The final property, `CategoryId` , is associated with a `Category` property
    that will be used to map each product to its parent category.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the `Product` class, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: System.ComponentModel.DataAnnotations; // [Required], [StringLength]
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: System.ComponentModel.DataAnnotations.Schema; // [Column]
  prefs: []
  type: TYPE_NORMAL
- en: namespace
  prefs: []
  type: TYPE_NORMAL
- en: Packt.Shared
  prefs: []
  type: TYPE_NORMAL
- en: ;
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: class
  prefs: []
  type: TYPE_NORMAL
- en: Product
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: int
  prefs: []
  type: TYPE_NORMAL
- en: ProductId { get
  prefs: []
  type: TYPE_NORMAL
- en: ; set
  prefs: []
  type: TYPE_NORMAL
- en: ; } // primary key
  prefs: []
  type: TYPE_NORMAL
- en: '[Required'
  prefs: []
  type: TYPE_NORMAL
- en: ']'
  prefs: []
  type: TYPE_NORMAL
- en: '[StringLength(40)'
  prefs: []
  type: TYPE_NORMAL
- en: ']'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: ProductName { get
  prefs: []
  type: TYPE_NORMAL
- en: ; set
  prefs: []
  type: TYPE_NORMAL
- en: ; } = null
  prefs: []
  type: TYPE_NORMAL
- en: '!;'
  prefs: []
  type: TYPE_NORMAL
- en: '[Column('
  prefs: []
  type: TYPE_NORMAL
- en: '"UnitPrice"'
  prefs: []
  type: TYPE_NORMAL
- en: ', TypeName ='
  prefs: []
  type: TYPE_NORMAL
- en: '"money"'
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: ']'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: decimal
  prefs: []
  type: TYPE_NORMAL
- en: '? Cost { get'
  prefs: []
  type: TYPE_NORMAL
- en: ; set
  prefs: []
  type: TYPE_NORMAL
- en: ; } // property name != column name
  prefs: []
  type: TYPE_NORMAL
- en: '[Column('
  prefs: []
  type: TYPE_NORMAL
- en: '"UnitsInStock"'
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: ']'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: short
  prefs: []
  type: TYPE_NORMAL
- en: '? Stock { get'
  prefs: []
  type: TYPE_NORMAL
- en: ; set
  prefs: []
  type: TYPE_NORMAL
- en: ; }
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: bool
  prefs: []
  type: TYPE_NORMAL
- en: Discontinued { get
  prefs: []
  type: TYPE_NORMAL
- en: ; set
  prefs: []
  type: TYPE_NORMAL
- en: ; }
  prefs: []
  type: TYPE_NORMAL
- en: // these two define the foreign key relationship
  prefs: []
  type: TYPE_NORMAL
- en: // to the Categories table
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: int
  prefs: []
  type: TYPE_NORMAL
- en: CategoryId { get
  prefs: []
  type: TYPE_NORMAL
- en: ; set
  prefs: []
  type: TYPE_NORMAL
- en: ; }
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: virtual
  prefs: []
  type: TYPE_NORMAL
- en: Category Category { get
  prefs: []
  type: TYPE_NORMAL
- en: ; set
  prefs: []
  type: TYPE_NORMAL
- en: ; } = null
  prefs: []
  type: TYPE_NORMAL
- en: '!;'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: The two properties that relate the two entities, `Category.Products` and `Product.Category`
    , are both marked as `virtual` . This allows EF Core to inherit and override the
    properties to provide extra features, such as lazy loading.
  prefs: []
  type: TYPE_NORMAL
- en: Adding tables to the Northwind database context class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Inside your `DbContext` -derived class, you must define at least one property
    of the `DbSet<T>` type. These properties represent the tables. To tell EF Core
    what columns each table has, the `DbSet<T>` properties use generics to specify
    a class that represents a row in the table. That entity model class has properties
    that represent its columns.
  prefs: []
  type: TYPE_NORMAL
- en: The `DbContext` -derived class can optionally have an overridden method named
    `OnModelCreating` . This is where you can write Fluent API statements as an alternative
    to decorating your entity classes with attributes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s write some code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the `Northwind` class to add statements to define two properties for
    the two tables and an `OnModelCreating` method, as shown highlighted in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: class
  prefs: []
  type: TYPE_NORMAL
- en: Northwind
  prefs: []
  type: TYPE_NORMAL
- en: ': DbContext'
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: '**// these properties map to tables in the database**'
  prefs: []
  type: TYPE_NORMAL
- en: '**public**'
  prefs: []
  type: TYPE_NORMAL
- en: '**DbSet<Category>? Categories {**'
  prefs: []
  type: TYPE_NORMAL
- en: '**get**'
  prefs: []
  type: TYPE_NORMAL
- en: '**;**'
  prefs: []
  type: TYPE_NORMAL
- en: '**set**'
  prefs: []
  type: TYPE_NORMAL
- en: '**; }**'
  prefs: []
  type: TYPE_NORMAL
- en: '**public**'
  prefs: []
  type: TYPE_NORMAL
- en: '**DbSet<Product>? Products {**'
  prefs: []
  type: TYPE_NORMAL
- en: '**get**'
  prefs: []
  type: TYPE_NORMAL
- en: '**;**'
  prefs: []
  type: TYPE_NORMAL
- en: '**set**'
  prefs: []
  type: TYPE_NORMAL
- en: '**; }**'
  prefs: []
  type: TYPE_NORMAL
- en: protected
  prefs: []
  type: TYPE_NORMAL
- en: override
  prefs: []
  type: TYPE_NORMAL
- en: void
  prefs: []
  type: TYPE_NORMAL
- en: OnConfiguring
  prefs: []
  type: TYPE_NORMAL
- en: (
  prefs: []
  type: TYPE_NORMAL
- en: DbContextOptionsBuilder optionsBuilder
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '**protected**'
  prefs: []
  type: TYPE_NORMAL
- en: '**override**'
  prefs: []
  type: TYPE_NORMAL
- en: '**void**'
  prefs: []
  type: TYPE_NORMAL
- en: '**OnModelCreating**'
  prefs: []
  type: TYPE_NORMAL
- en: '**(**'
  prefs: []
  type: TYPE_NORMAL
- en: '**ModelBuilder modelBuilder**'
  prefs: []
  type: TYPE_NORMAL
- en: '**)**'
  prefs: []
  type: TYPE_NORMAL
- en: '**{**'
  prefs: []
  type: TYPE_NORMAL
- en: '**// example of using Fluent API instead of attributes**'
  prefs: []
  type: TYPE_NORMAL
- en: '**// to limit the length of a category name to 15**'
  prefs: []
  type: TYPE_NORMAL
- en: '**modelBuilder.Entity<Category>()**'
  prefs: []
  type: TYPE_NORMAL
- en: '**.Property(category => category.CategoryName)**'
  prefs: []
  type: TYPE_NORMAL
- en: '**.IsRequired()**'
  prefs: []
  type: TYPE_NORMAL
- en: '**// NOT NULL**'
  prefs: []
  type: TYPE_NORMAL
- en: '**.HasMaxLength(**'
  prefs: []
  type: TYPE_NORMAL
- en: '**15**'
  prefs: []
  type: TYPE_NORMAL
- en: '**);**'
  prefs: []
  type: TYPE_NORMAL
- en: '**if**'
  prefs: []
  type: TYPE_NORMAL
- en: '**(ProjectConstants.DatabaseProvider ==**'
  prefs: []
  type: TYPE_NORMAL
- en: '**"SQLite"**'
  prefs: []
  type: TYPE_NORMAL
- en: '**)**'
  prefs: []
  type: TYPE_NORMAL
- en: '**{**'
  prefs: []
  type: TYPE_NORMAL
- en: '**// added to "fix" the lack of decimal support in SQLite**'
  prefs: []
  type: TYPE_NORMAL
- en: '**modelBuilder.Entity<Product>()**'
  prefs: []
  type: TYPE_NORMAL
- en: '**.Property(product => product.Cost)**'
  prefs: []
  type: TYPE_NORMAL
- en: '**.HasConversion<**'
  prefs: []
  type: TYPE_NORMAL
- en: '**double**'
  prefs: []
  type: TYPE_NORMAL
- en: '**>();**'
  prefs: []
  type: TYPE_NORMAL
- en: '**}**'
  prefs: []
  type: TYPE_NORMAL
- en: '**}**'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: In EF Core 3.0 and later, the `decimal` type is not supported by the SQLite
    database provider for sorting and other operations. We can fix this by telling
    the model that `decimal` values can be converted to `double` values when using
    the SQLite database provider. This does not actually perform any conversion at
    runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have seen some examples of defining an entity model manually, let's
    see a tool that can do some of the work for you.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the dotnet-ef tool
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: .NET has a command-line tool named `dotnet` . It can be extended with capabilities
    useful for working with EF Core. It can perform design-time tasks like creating
    and applying migrations from an older model to a newer model and generating code
    for a model from an existing database.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `dotnet` `ef` command-line tool is not automatically installed. You have
    to install this package as either a **global** or **local tool** . If you have
    already installed an older version of the tool, then you should uninstall any
    existing version:'
  prefs: []
  type: TYPE_NORMAL
- en: 'At a command prompt or terminal, check if you have already installed `dotnet-ef`
    as a global tool, as shown in the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: dotnet tool list --global
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check in the list if an older version of the tool has been installed, like
    the one for .NET Core 3.1, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: Package Id      Version     Commands
  prefs: []
  type: TYPE_NORMAL
- en: '-------------------------------------'
  prefs: []
  type: TYPE_NORMAL
- en: dotnet-ef       3.1.0       dotnet-ef
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'If an old version is already installed, then uninstall the tool, as shown in
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: dotnet tool uninstall --global dotnet-ef
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the latest version, as shown in the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: dotnet tool install --global dotnet-ef --version 6.0.0
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: If necessary, follow any OS-specific instructions to add the `dotnet tools`
    directory to your PATH environment variable as described in the output of installing
    the `dotnet-ef` tool.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Scaffolding models using an existing database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Scaffolding is the process of using a tool to create classes that represent
    the model of an existing database using reverse engineering. A good scaffolding
    tool allows you to extend the automatically generated classes and then regenerate
    those classes without losing your extended classes.
  prefs: []
  type: TYPE_NORMAL
- en: If you know that you will never regenerate the classes using the tool, then
    feel free to change the code for the automatically generated classes as much as
    you want. The code generated by the tool is just the best approximation.
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice** : Do not be afraid to overrule a tool when you know better.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see if the tool generates the same model as we did manually:'
  prefs: []
  type: TYPE_NORMAL
- en: Add the `Microsoft.EntityFrameworkCore.Design` package to the `WorkingWithEFCore`
    project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At a command prompt or terminal in the `WorkingWithEFCore` folder, generate
    a model for the `Categories` and `Products` tables in a new folder named `AutoGenModels`
    , as shown in the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: dotnet ef dbcontext scaffold "Filename=Northwind.db" Microsoft.EntityFrameworkCore.Sqlite
    --table Categories --table Products --output-dir AutoGenModels --namespace WorkingWithEFCore.AutoGen
    --data-annotations --context Northwind
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The command action: `dbcontext scaffold`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The connection string: `"Filename=Northwind.db"`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The database provider: `Microsoft.EntityFrameworkCore.Sqlite`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The tables to generate models for: `--table Categories --table Products`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The output folder: `--output-dir AutoGenModels`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The namespace: `--namespace WorkingWithEFCore.AutoGen`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To use data annotations as well as the Fluent API: `--data-annotations`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To rename the context from [database_name]Context: `--context Northwind`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For SQL Server, change the database provider and connection string, as shown
    in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: dotnet ef dbcontext scaffold "Data Source=.;Initial Catalog=Northwind;Integrated
    Security=true;" Microsoft.EntityFrameworkCore.SqlServer --table Categories --table
    Products --output-dir AutoGenModels --namespace WorkingWithEFCore.AutoGen --data-annotations
    --context Northwind
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note the build messages and warnings, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: Build started...
  prefs: []
  type: TYPE_NORMAL
- en: Build succeeded.
  prefs: []
  type: TYPE_NORMAL
- en: To protect potentially sensitive information in your connection string, you
    should move it out of source code. You can avoid scaffolding the connection string
    by using the Name= syntax to read it from configuration - see https://go.microsoft.com/fwlink/?linkid=2131148\.
    For more guidance on storing connection strings, see http://go.microsoft.com/fwlink/?LinkId=723263.
  prefs: []
  type: TYPE_NORMAL
- en: Skipping foreign key with identity '0' on table 'Products' since principal table
    'Suppliers' was not found in the model. This usually happens when the principal
    table was not included in the selection set.
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `AutoGenModels` folder and note the three class files that were automatically
    generated: `Category.cs` , `Northwind.cs` , and `Product.cs` .'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open `Category.cs` and note the differences compared to the one you created
    manually, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: System;
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: System.Collections.Generic;
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: System.ComponentModel.DataAnnotations;
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: System.ComponentModel.DataAnnotations.Schema;
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft.EntityFrameworkCore;
  prefs: []
  type: TYPE_NORMAL
- en: namespace
  prefs: []
  type: TYPE_NORMAL
- en: WorkingWithEFCore.AutoGen
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: '[Index(nameof(CategoryName), Name ='
  prefs: []
  type: TYPE_NORMAL
- en: '"CategoryName"'
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: ']'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: partial
  prefs: []
  type: TYPE_NORMAL
- en: class
  prefs: []
  type: TYPE_NORMAL
- en: Category
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: Category
  prefs: []
  type: TYPE_NORMAL
- en: ()
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: Products = new
  prefs: []
  type: TYPE_NORMAL
- en: HashSet<Product>();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[Key'
  prefs: []
  type: TYPE_NORMAL
- en: ']'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: long
  prefs: []
  type: TYPE_NORMAL
- en: CategoryId { get
  prefs: []
  type: TYPE_NORMAL
- en: ; set
  prefs: []
  type: TYPE_NORMAL
- en: ; }
  prefs: []
  type: TYPE_NORMAL
- en: '[Required'
  prefs: []
  type: TYPE_NORMAL
- en: ']'
  prefs: []
  type: TYPE_NORMAL
- en: '[Column(TypeName ='
  prefs: []
  type: TYPE_NORMAL
- en: '"nvarchar (15)"'
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '] // SQLite'
  prefs: []
  type: TYPE_NORMAL
- en: '[StringLength(15)'
  prefs: []
  type: TYPE_NORMAL
- en: '] // SQL Server'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: CategoryName { get
  prefs: []
  type: TYPE_NORMAL
- en: ; set
  prefs: []
  type: TYPE_NORMAL
- en: ; }
  prefs: []
  type: TYPE_NORMAL
- en: '[Column(TypeName ='
  prefs: []
  type: TYPE_NORMAL
- en: '"ntext"'
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: ']'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: '? Description { get'
  prefs: []
  type: TYPE_NORMAL
- en: ; set
  prefs: []
  type: TYPE_NORMAL
- en: ; }
  prefs: []
  type: TYPE_NORMAL
- en: '[Column(TypeName ='
  prefs: []
  type: TYPE_NORMAL
- en: '"image"'
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: ']'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: byte
  prefs: []
  type: TYPE_NORMAL
- en: '[]? Picture { get'
  prefs: []
  type: TYPE_NORMAL
- en: ; set
  prefs: []
  type: TYPE_NORMAL
- en: ; }
  prefs: []
  type: TYPE_NORMAL
- en: '[InverseProperty(nameof(Product.Category))'
  prefs: []
  type: TYPE_NORMAL
- en: ']'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: virtual
  prefs: []
  type: TYPE_NORMAL
- en: ICollection<Product> Products { get
  prefs: []
  type: TYPE_NORMAL
- en: ; set
  prefs: []
  type: TYPE_NORMAL
- en: ; }
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note the following:'
  prefs: []
  type: TYPE_NORMAL
- en: It decorates the entity class with the `[Index]` attribute that was introduced
    in EF Core 5.0\. This indicates properties that should have an index. In earlier
    versions, only the Fluent API was supported for defining indexes. Since we are
    working with an existing database, this is not needed. But if we want to recreate
    a new empty database from our code then this information will be needed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The table name in the database is `Categories` but the `dotnet-ef` tool uses
    the **Humanizer** third-party library to automatically singularize the class name
    to `Category` , which is a more natural name when creating a single entity.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The entity class is declared using the `partial` keyword so that you can create
    a matching `partial` class for adding additional code. This allows you to rerun
    the tool and regenerate the entity class without losing that extra code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `CategoryId` property is decorated with the `[Key]` attribute to indicate
    that it is the primary key for this entity. The data type for this property is
    `int` for SQL Server and `long` for SQLite.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Products` property uses the `[InverseProperty]` attribute to define the
    foreign key relationship to the `Category` property on the `Product` entity class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Open `Product.cs` and note the differences compared to the one you created manually.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open `Northwind.cs` and note the differences compared to the one you created
    manually, as shown in the following edited-for-space code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft.EntityFrameworkCore;
  prefs: []
  type: TYPE_NORMAL
- en: namespace
  prefs: []
  type: TYPE_NORMAL
- en: WorkingWithEFCore.AutoGen
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: partial
  prefs: []
  type: TYPE_NORMAL
- en: class
  prefs: []
  type: TYPE_NORMAL
- en: Northwind
  prefs: []
  type: TYPE_NORMAL
- en: ': DbContext'
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: Northwind
  prefs: []
  type: TYPE_NORMAL
- en: ()
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: Northwind
  prefs: []
  type: TYPE_NORMAL
- en: (
  prefs: []
  type: TYPE_NORMAL
- en: DbContextOptions<Northwind> options
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: ':'
  prefs: []
  type: TYPE_NORMAL
- en: base
  prefs: []
  type: TYPE_NORMAL
- en: (
  prefs: []
  type: TYPE_NORMAL
- en: options
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: virtual
  prefs: []
  type: TYPE_NORMAL
- en: DbSet<Category> Categories { get
  prefs: []
  type: TYPE_NORMAL
- en: ; set
  prefs: []
  type: TYPE_NORMAL
- en: ; } = null
  prefs: []
  type: TYPE_NORMAL
- en: '!;'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: virtual
  prefs: []
  type: TYPE_NORMAL
- en: DbSet<Product> Products { get
  prefs: []
  type: TYPE_NORMAL
- en: ; set
  prefs: []
  type: TYPE_NORMAL
- en: ; } = null
  prefs: []
  type: TYPE_NORMAL
- en: '!;'
  prefs: []
  type: TYPE_NORMAL
- en: protected
  prefs: []
  type: TYPE_NORMAL
- en: override
  prefs: []
  type: TYPE_NORMAL
- en: void
  prefs: []
  type: TYPE_NORMAL
- en: OnConfiguring
  prefs: []
  type: TYPE_NORMAL
- en: (
  prefs: []
  type: TYPE_NORMAL
- en: DbContextOptionsBuilder optionsBuilder
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: if
  prefs: []
  type: TYPE_NORMAL
- en: (!optionsBuilder.IsConfigured)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: '#'
  prefs: []
  type: TYPE_NORMAL
- en: warning
  prefs: []
  type: TYPE_NORMAL
- en: To protect potentially sensitive information in your connection string, you
    should move it out of source code. You can avoid scaffolding the connection string
    by using the Name= syntax to read it from configuration - see https://go.microsoft.com/fwlink/?linkid=2131148\.
    For more guidance on storing connection strings, see http://go.microsoft.com/fwlink/?LinkId=723263.
  prefs: []
  type: TYPE_NORMAL
- en: optionsBuilder.UseSqlite("Filename=Northwind.db"
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: protected
  prefs: []
  type: TYPE_NORMAL
- en: override
  prefs: []
  type: TYPE_NORMAL
- en: void
  prefs: []
  type: TYPE_NORMAL
- en: OnModelCreating
  prefs: []
  type: TYPE_NORMAL
- en: (
  prefs: []
  type: TYPE_NORMAL
- en: ModelBuilder modelBuilder
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: modelBuilder.Entity<Category>(entity =>
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  prefs: []
  type: TYPE_NORMAL
- en: modelBuilder.Entity<Product>(entity =>
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  prefs: []
  type: TYPE_NORMAL
- en: OnModelCreatingPartial(modelBuilder);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: partial
  prefs: []
  type: TYPE_NORMAL
- en: void
  prefs: []
  type: TYPE_NORMAL
- en: OnModelCreatingPartial
  prefs: []
  type: TYPE_NORMAL
- en: (
  prefs: []
  type: TYPE_NORMAL
- en: ModelBuilder modelBuilder
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: ;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Northwind` data context class is `partial` to allow you to extend it and
    regenerate it in the future.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It has two constructors: a default parameter-less one and one that allows options
    to be passed in. This is useful in apps where you want to specify the connection
    string at runtime.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The two `DbSet<T>` properties that represent the `Categories` and `Products`
    tables are set to the `null` -forgiving value to prevent static compiler analysis
    warnings at compile time. It has no effect at runtime.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the `OnConfiguring` method, if options have not been specified in the constructor,
    then it defaults to using a connection string that looks for the database file
    in the current folder. It has a compiler warning to remind you that you should
    not hardcode security information in this connection string.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the `OnModelCreating` method, the Fluent API is used to configure the two
    entity classes, and then a partial method named `OnModelCreatingPartial` is invoked.
    This allows you to implement that partial method in your own partial `Northwind`
    class to add your own Fluent API configuration that will not be lost if you regenerate
    the model classes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Close the automatically generated class files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configuring preconvention models
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Along with support for the `DateOnly` and `TimeOnly` types for use with the
    SQLite database provider, one of the new features introduced with EF Core 6 is
    configuring preconvention models.
  prefs: []
  type: TYPE_NORMAL
- en: As models become more complex, relying on conventions to discover entity types
    and their properties and successfully map them to tables and columns becomes harder.
    It would be useful if you could configure the conventions themselves before they
    are used to analyze and build a model.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, you might want to define a convention to say that all `string`
    properties should have a maximum length of 50 characters as a default, or any
    property types that implement a custom interface should not be mapped, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: protected
  prefs: []
  type: TYPE_NORMAL
- en: override
  prefs: []
  type: TYPE_NORMAL
- en: void
  prefs: []
  type: TYPE_NORMAL
- en: ConfigureConventions
  prefs: []
  type: TYPE_NORMAL
- en: (
  prefs: []
  type: TYPE_NORMAL
- en: ModelConfigurationBuilder configurationBuilder
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: configurationBuilder.Properties<string
  prefs: []
  type: TYPE_NORMAL
- en: '>().HaveMaxLength(50'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: configurationBuilder.IgnoreAny<IDoNotMap>();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: In the rest of this chapter, we will use the classes that you manually created.
  prefs: []
  type: TYPE_NORMAL
- en: Querying EF Core models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have a model that maps to the Northwind database and two of its
    tables, we can write some simple LINQ queries to fetch data. You will learn much
    more about writing LINQ queries in *Chapter 11* , *Querying and Manipulating Data
    Using LINQ* .
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, just write the code and view the results:'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the top of `Program.cs` , import the main EF Core namespace to enable the
    use of the `Include` extension method to prefetch from a related table:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft.EntityFrameworkCore; // Include extension method
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the bottom of `Program.cs` , define a `QueryingCategories` method, and add
    statements to do these tasks, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an instance of the `Northwind` class that will manage the database. Database
    context instances are designed for short lifetimes in a unit of work. They should
    be disposed of as soon as possible so we will wrap it in a `using` statement.
    In *Chapter 14* , *Building Websites Using ASP.NET Core Razor Pages* , you will
    learn how to get a database context using dependency injection.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a query for all categories that include their related products.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Enumerate through the categories, outputting the name and number of products
    for each one:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: static
  prefs: []
  type: TYPE_NORMAL
- en: void
  prefs: []
  type: TYPE_NORMAL
- en: QueryingCategories
  prefs: []
  type: TYPE_NORMAL
- en: ()
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: (Northwind db = new
  prefs: []
  type: TYPE_NORMAL
- en: ())
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("Categories and how many products they have:"
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: // a query to get all categories and their related products
  prefs: []
  type: TYPE_NORMAL
- en: IQueryable<Category>? categories = db.Categories?
  prefs: []
  type: TYPE_NORMAL
- en: .Include(c => c.Products);
  prefs: []
  type: TYPE_NORMAL
- en: if
  prefs: []
  type: TYPE_NORMAL
- en: (categories is
  prefs: []
  type: TYPE_NORMAL
- en: 'null'
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("No categories found."
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: return
  prefs: []
  type: TYPE_NORMAL
- en: ;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: // execute query and enumerate results
  prefs: []
  type: TYPE_NORMAL
- en: foreach
  prefs: []
  type: TYPE_NORMAL
- en: (Category c in
  prefs: []
  type: TYPE_NORMAL
- en: categories)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine($"
  prefs: []
  type: TYPE_NORMAL
- en: '{c.CategoryName}'
  prefs: []
  type: TYPE_NORMAL
- en: has
  prefs: []
  type: TYPE_NORMAL
- en: '{c.Products.Count}'
  prefs: []
  type: TYPE_NORMAL
- en: products."
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the top of `Program.cs` , after outputting the database provider name, call
    the `QueryingCategories` method, as shown highlighted in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine($"Using
  prefs: []
  type: TYPE_NORMAL
- en: '{ProjectConstants.DatabaseProvider}'
  prefs: []
  type: TYPE_NORMAL
- en: database provider."
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '**QueryingCategories();**'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code and view the result (if run with Visual Studio 2022 for Windows
    using the SQLite database provider), as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: Using SQLite database provider.
  prefs: []
  type: TYPE_NORMAL
- en: 'Categories and how many products they have:'
  prefs: []
  type: TYPE_NORMAL
- en: Using C:\Code\Chapter10\WorkingWithEFCore\bin\Debug\net6.0\Northwind.db database
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Beverages has 12 products.
  prefs: []
  type: TYPE_NORMAL
- en: Condiments has 12 products.
  prefs: []
  type: TYPE_NORMAL
- en: Confections has 13 products.
  prefs: []
  type: TYPE_NORMAL
- en: Dairy Products has 10 products.
  prefs: []
  type: TYPE_NORMAL
- en: Grains/Cereals has 7 products.
  prefs: []
  type: TYPE_NORMAL
- en: Meat/Poultry has 6 products.
  prefs: []
  type: TYPE_NORMAL
- en: Produce has 5 products.
  prefs: []
  type: TYPE_NORMAL
- en: Seafood has 12 products.
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: If you run with Visual Studio Code using the SQLite database provider, then
    the path will be the `WorkingWithEFCore` folder. If you run using the SQL Server
    database provider, then there is no database file path output.
  prefs: []
  type: TYPE_NORMAL
- en: '**Warning!** If you see the following exception when using SQLite with Visual
    Studio 2022, the most likely problem is that the `Northwind.db` file is not being
    copied to the output directory. Make sure **Copy to Output Directory** is set
    to **Copy always** :'
  prefs: []
  type: TYPE_NORMAL
- en: '`Unhandled exception. Microsoft.Data.Sqlite.SqliteException (0x80004005): SQLite
    Error 1: ''no such table: Categories''.`'
  prefs: []
  type: TYPE_NORMAL
- en: Filtering included entities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'EF Core 5.0 introduced **filtered includes** , which means you can specify
    a lambda expression in the `Include` method call to filter which entities are
    returned in the results:'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the bottom of `Program.cs` , define a `FilteredIncludes` method, and add
    statements to do these tasks, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an instance of the `Northwind` class that will manage the database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prompt the user to enter a minimum value for units in stock.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a query for categories that have products with that minimum number of
    units in stock.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Enumerate through the categories and products, outputting the name and units
    in stock for each one:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: static
  prefs: []
  type: TYPE_NORMAL
- en: void
  prefs: []
  type: TYPE_NORMAL
- en: FilteredIncludes
  prefs: []
  type: TYPE_NORMAL
- en: ()
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: (Northwind db = new
  prefs: []
  type: TYPE_NORMAL
- en: ())
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write("Enter a minimum for units in stock: "'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: unitsInStock = ReadLine() ?? "10"
  prefs: []
  type: TYPE_NORMAL
- en: ;
  prefs: []
  type: TYPE_NORMAL
- en: int
  prefs: []
  type: TYPE_NORMAL
- en: stock = int
  prefs: []
  type: TYPE_NORMAL
- en: .Parse(unitsInStock);
  prefs: []
  type: TYPE_NORMAL
- en: IQueryable<Category>? categories = db.Categories?
  prefs: []
  type: TYPE_NORMAL
- en: .Include(c => c.Products.Where(p => p.Stock >= stock));
  prefs: []
  type: TYPE_NORMAL
- en: if
  prefs: []
  type: TYPE_NORMAL
- en: (categories is
  prefs: []
  type: TYPE_NORMAL
- en: 'null'
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("No categories found."
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: return
  prefs: []
  type: TYPE_NORMAL
- en: ;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: foreach
  prefs: []
  type: TYPE_NORMAL
- en: (Category c in
  prefs: []
  type: TYPE_NORMAL
- en: categories)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine($"
  prefs: []
  type: TYPE_NORMAL
- en: '{c.CategoryName}'
  prefs: []
  type: TYPE_NORMAL
- en: has
  prefs: []
  type: TYPE_NORMAL
- en: '{c.Products.Count}'
  prefs: []
  type: TYPE_NORMAL
- en: products with a minimum of
  prefs: []
  type: TYPE_NORMAL
- en: '{stock}'
  prefs: []
  type: TYPE_NORMAL
- en: units in stock."
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: foreach
  prefs: []
  type: TYPE_NORMAL
- en: (Product p in
  prefs: []
  type: TYPE_NORMAL
- en: c.Products)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine($"
  prefs: []
  type: TYPE_NORMAL
- en: '{p.ProductName}'
  prefs: []
  type: TYPE_NORMAL
- en: has
  prefs: []
  type: TYPE_NORMAL
- en: '{p.Stock}'
  prefs: []
  type: TYPE_NORMAL
- en: units in stock."
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs` , comment out the `QueryingCategories` method and invoke the
    `FilteredIncludes` method, as shown highlighted in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine($"Using
  prefs: []
  type: TYPE_NORMAL
- en: '{ProjectConstants.DatabaseProvider}'
  prefs: []
  type: TYPE_NORMAL
- en: database provider."
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '**// QueryingCategories();**'
  prefs: []
  type: TYPE_NORMAL
- en: '**FilteredIncludes();**'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code, enter a minimum for units in stock like `100` , and view the
    result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter a minimum for units in stock: 100'
  prefs: []
  type: TYPE_NORMAL
- en: Beverages has 2 products with a minimum of 100 units in stock.
  prefs: []
  type: TYPE_NORMAL
- en: Sasquatch Ale has 111 units in stock.
  prefs: []
  type: TYPE_NORMAL
- en: Rhönbräu Klosterbier has 125 units in stock.
  prefs: []
  type: TYPE_NORMAL
- en: Condiments has 2 products with a minimum of 100 units in stock.
  prefs: []
  type: TYPE_NORMAL
- en: Grandma's Boysenberry Spread has 120 units in stock.
  prefs: []
  type: TYPE_NORMAL
- en: Sirop d'érable has 113 units in stock.
  prefs: []
  type: TYPE_NORMAL
- en: Confections has 0 products with a minimum of 100 units in stock.
  prefs: []
  type: TYPE_NORMAL
- en: Dairy Products has 1 products with a minimum of 100 units in stock.
  prefs: []
  type: TYPE_NORMAL
- en: Geitost has 112 units in stock.
  prefs: []
  type: TYPE_NORMAL
- en: Grains/Cereals has 1 products with a minimum of 100 units in stock.
  prefs: []
  type: TYPE_NORMAL
- en: Gustaf's Knäckebröd has 104 units in stock.
  prefs: []
  type: TYPE_NORMAL
- en: Meat/Poultry has 1 products with a minimum of 100 units in stock.
  prefs: []
  type: TYPE_NORMAL
- en: Pâté chinois has 115 units in stock.
  prefs: []
  type: TYPE_NORMAL
- en: Produce has 0 products with a minimum of 100 units in stock.
  prefs: []
  type: TYPE_NORMAL
- en: Seafood has 3 products with a minimum of 100 units in stock.
  prefs: []
  type: TYPE_NORMAL
- en: Inlagd Sill has 112 units in stock.
  prefs: []
  type: TYPE_NORMAL
- en: Boston Crab Meat has 123 units in stock.
  prefs: []
  type: TYPE_NORMAL
- en: Röd Kaviar has 101 units in stock.
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Unicode characters in the Windows console
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is a limitation with the console provided by Microsoft on versions of
    Windows before the Windows 10 Fall Creators Update. By default, the console cannot
    display Unicode characters, for example, in the name Rhönbräu.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have this issue, then you can temporarily change the code page (also
    known as the character set) in a console to Unicode UTF-8 by entering the following
    command at the prompt before running the app:'
  prefs: []
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: chcp 65001
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Filtering and sorting products
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s explore a more complex query that will filter and sort data:'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the bottom of `Program.cs` , define a `QueryingProducts` method, and add
    statements to do the following, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an instance of the `Northwind` class that will manage the database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prompt the user for a price for products. Unlike the previous code example,
    we will loop until the input is a valid price.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a query for products that cost more than the price using LINQ.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Loop through the results, outputting the Id, name, cost (formatted in US dollars),
    and the number of units in stock:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: static
  prefs: []
  type: TYPE_NORMAL
- en: void
  prefs: []
  type: TYPE_NORMAL
- en: QueryingProducts
  prefs: []
  type: TYPE_NORMAL
- en: ()
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: (Northwind db = new
  prefs: []
  type: TYPE_NORMAL
- en: ())
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("Products that cost more than a price, highest at top."
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: '? input;'
  prefs: []
  type: TYPE_NORMAL
- en: decimal
  prefs: []
  type: TYPE_NORMAL
- en: price;
  prefs: []
  type: TYPE_NORMAL
- en: do
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write("Enter a product price: "'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: input = ReadLine();
  prefs: []
  type: TYPE_NORMAL
- en: '} while'
  prefs: []
  type: TYPE_NORMAL
- en: (!decimal
  prefs: []
  type: TYPE_NORMAL
- en: .TryParse(input, out
  prefs: []
  type: TYPE_NORMAL
- en: price));
  prefs: []
  type: TYPE_NORMAL
- en: IQueryable<Product>? products = db.Products?
  prefs: []
  type: TYPE_NORMAL
- en: .Where(product => product.Cost > price)
  prefs: []
  type: TYPE_NORMAL
- en: .OrderByDescending(product => product.Cost);
  prefs: []
  type: TYPE_NORMAL
- en: if
  prefs: []
  type: TYPE_NORMAL
- en: (products is
  prefs: []
  type: TYPE_NORMAL
- en: 'null'
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("No products found."
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: return
  prefs: []
  type: TYPE_NORMAL
- en: ;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: foreach
  prefs: []
  type: TYPE_NORMAL
- en: (Product p in
  prefs: []
  type: TYPE_NORMAL
- en: products)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine(
  prefs: []
  type: TYPE_NORMAL
- en: '"{0}: {1} costs {2:$#,##0.00} and has {3} in stock."'
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: p.ProductId, p.ProductName, p.Cost, p.Stock);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: In `Program.cs` , comment out the previous method, and call the `QueryingProducts`
    method
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the code, enter `50` when prompted to enter a product price, and view the
    result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: Products that cost more than a price, highest at top.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter a product price: 50'
  prefs: []
  type: TYPE_NORMAL
- en: '38: Côte de Blaye costs $263.50 and has 17 in stock.'
  prefs: []
  type: TYPE_NORMAL
- en: '29: Thüringer Rostbratwurst costs $123.79 and has 0 in stock.'
  prefs: []
  type: TYPE_NORMAL
- en: '9: Mishi Kobe Niku costs $97.00 and has 29 in stock.'
  prefs: []
  type: TYPE_NORMAL
- en: '20: Sir Rodney''s Marmalade costs $81.00 and has 40 in stock.'
  prefs: []
  type: TYPE_NORMAL
- en: '18: Carnarvon Tigers costs $62.50 and has 42 in stock.'
  prefs: []
  type: TYPE_NORMAL
- en: '59: Raclette Courdavault costs $55.00 and has 79 in stock.'
  prefs: []
  type: TYPE_NORMAL
- en: '51: Manjimup Dried Apples costs $53.00 and has 20 in stock.'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Getting the generated SQL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You might be wondering how well written the SQL statements are that are generated
    from the C# queries we write. EF Core 5.0 introduced a quick and easy way to see
    the SQL generated:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `FilteredIncludes` method, before using the `foreach` statement to enumerate
    the query, add a statement to output the generated SQL, as shown highlighted in
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: '**WriteLine(**'
  prefs: []
  type: TYPE_NORMAL
- en: '**$"ToQueryString:**'
  prefs: []
  type: TYPE_NORMAL
- en: '**{categories.ToQueryString()}**'
  prefs: []
  type: TYPE_NORMAL
- en: '**"**'
  prefs: []
  type: TYPE_NORMAL
- en: '**);**'
  prefs: []
  type: TYPE_NORMAL
- en: foreach
  prefs: []
  type: TYPE_NORMAL
- en: (Category c in
  prefs: []
  type: TYPE_NORMAL
- en: categories)
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: In `Program.cs` , comment out the call to the `QueryingProducts` method and
    uncomment the call to the `FilteredIncludes` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the code, enter a minimum for units in stock like `99` , and view the result
    (when run with SQLite), as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter a minimum for units in stock: 99'
  prefs: []
  type: TYPE_NORMAL
- en: Using SQLite database provider.
  prefs: []
  type: TYPE_NORMAL
- en: 'ToQueryString: .param set @_stock_0 99'
  prefs: []
  type: TYPE_NORMAL
- en: SELECT "c"."CategoryId", "c"."CategoryName", "c"."Description",
  prefs: []
  type: TYPE_NORMAL
- en: '"t"."ProductId", "t"."CategoryId", "t"."UnitPrice", "t"."Discontinued",'
  prefs: []
  type: TYPE_NORMAL
- en: '"t"."ProductName", "t"."UnitsInStock"'
  prefs: []
  type: TYPE_NORMAL
- en: FROM "Categories" AS "c"
  prefs: []
  type: TYPE_NORMAL
- en: LEFT JOIN (
  prefs: []
  type: TYPE_NORMAL
- en: SELECT "p"."ProductId", "p"."CategoryId", "p"."UnitPrice",
  prefs: []
  type: TYPE_NORMAL
- en: '"p"."Discontinued", "p"."ProductName", "p"."UnitsInStock"'
  prefs: []
  type: TYPE_NORMAL
- en: FROM "Products" AS "p"
  prefs: []
  type: TYPE_NORMAL
- en: WHERE ("p"."UnitsInStock" >= @_stock_0)
  prefs: []
  type: TYPE_NORMAL
- en: ) AS "t" ON "c"."CategoryId" = "t"."CategoryId"
  prefs: []
  type: TYPE_NORMAL
- en: ORDER BY "c"."CategoryId", "t"."ProductId"
  prefs: []
  type: TYPE_NORMAL
- en: Beverages has 2 products with a minimum of 99 units in stock.
  prefs: []
  type: TYPE_NORMAL
- en: Sasquatch Ale has 111 units in stock.
  prefs: []
  type: TYPE_NORMAL
- en: Rhönbräu Klosterbier has 125 units in stock.
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Note the SQL parameter named `@_stock_0` has been set to a minimum stock value
    of `99` .
  prefs: []
  type: TYPE_NORMAL
- en: 'For SQL Server, the SQL generated is slightly different, for example, it uses
    square brackets instead of double-quotes around object names, as shown in the
    following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter a minimum for units in stock: 99'
  prefs: []
  type: TYPE_NORMAL
- en: Using SqlServer database provider.
  prefs: []
  type: TYPE_NORMAL
- en: 'ToQueryString: DECLARE @__stock_0 smallint = CAST(99 AS smallint);'
  prefs: []
  type: TYPE_NORMAL
- en: SELECT [c].[CategoryId], [c].[CategoryName], [c].[Description], [t].[ProductId],
    [t].[CategoryId], [t].[UnitPrice], [t].[Discontinued], [t].[ProductName], [t].[UnitsInStock]
  prefs: []
  type: TYPE_NORMAL
- en: FROM [Categories] AS [c]
  prefs: []
  type: TYPE_NORMAL
- en: LEFT JOIN (
  prefs: []
  type: TYPE_NORMAL
- en: SELECT [p].[ProductId], [p].[CategoryId], [p].[UnitPrice], [p].[Discontinued],
    [p].[ProductName], [p].[UnitsInStock]
  prefs: []
  type: TYPE_NORMAL
- en: FROM [Products] AS [p]
  prefs: []
  type: TYPE_NORMAL
- en: WHERE [p].[UnitsInStock] >= @__stock_0
  prefs: []
  type: TYPE_NORMAL
- en: ) AS [t] ON [c].[CategoryId] = [t].[CategoryId]
  prefs: []
  type: TYPE_NORMAL
- en: ORDER BY [c].[CategoryId], [t].[ProductId]
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Logging EF Core using a custom logging provider
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To monitor the interaction between EF Core and the database, we can enable
    logging. This requires the following two tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: The registering of a **logging provider** .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The implementation of a **logger** .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s see an example of this in action:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a file to your project named `ConsoleLogger.cs` .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Modify the file to define two classes, one to implement `ILoggerProvider` and
    one to implement `ILogger` , as shown in the following code, and note the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`ConsoleLoggerProvider` returns an instance of `ConsoleLogger` . It does not
    need any unmanaged resources, so the `Dispose` method does not do anything, but
    it must exist.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ConsoleLogger` is disabled for log levels `None` , `Trace` , and `Information`
    . It is enabled for all other log levels.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ConsoleLogger` implements its `Log` method by writing to `Console` :'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft.Extensions.Logging; // ILoggerProvider, ILogger, LogLevel
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: static
  prefs: []
  type: TYPE_NORMAL
- en: System.Console;
  prefs: []
  type: TYPE_NORMAL
- en: namespace
  prefs: []
  type: TYPE_NORMAL
- en: Packt.Shared
  prefs: []
  type: TYPE_NORMAL
- en: ;
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: class
  prefs: []
  type: TYPE_NORMAL
- en: ConsoleLoggerProvider
  prefs: []
  type: TYPE_NORMAL
- en: ': ILoggerProvider'
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: ILogger
  prefs: []
  type: TYPE_NORMAL
- en: CreateLogger
  prefs: []
  type: TYPE_NORMAL
- en: (
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: categoryName
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: // we could have different logger implementations for
  prefs: []
  type: TYPE_NORMAL
- en: // different categoryName values but we only have one
  prefs: []
  type: TYPE_NORMAL
- en: return
  prefs: []
  type: TYPE_NORMAL
- en: new
  prefs: []
  type: TYPE_NORMAL
- en: ConsoleLogger();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: // if your logger uses unmanaged resources,
  prefs: []
  type: TYPE_NORMAL
- en: // then you can release them here
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: void
  prefs: []
  type: TYPE_NORMAL
- en: Dispose
  prefs: []
  type: TYPE_NORMAL
- en: ()
  prefs: []
  type: TYPE_NORMAL
- en: '{ }'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: class
  prefs: []
  type: TYPE_NORMAL
- en: ConsoleLogger
  prefs: []
  type: TYPE_NORMAL
- en: ': ILogger'
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: // if your logger uses unmanaged resources, you can
  prefs: []
  type: TYPE_NORMAL
- en: // return the class that implements IDisposable here
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: IDisposable
  prefs: []
  type: TYPE_NORMAL
- en: BeginScope
  prefs: []
  type: TYPE_NORMAL
- en: <
  prefs: []
  type: TYPE_NORMAL
- en: TState
  prefs: []
  type: TYPE_NORMAL
- en: '>('
  prefs: []
  type: TYPE_NORMAL
- en: TState state
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: return
  prefs: []
  type: TYPE_NORMAL
- en: 'null'
  prefs: []
  type: TYPE_NORMAL
- en: ;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: bool
  prefs: []
  type: TYPE_NORMAL
- en: IsEnabled
  prefs: []
  type: TYPE_NORMAL
- en: (
  prefs: []
  type: TYPE_NORMAL
- en: LogLevel logLevel
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: // to avoid overlogging, you can filter on the log level
  prefs: []
  type: TYPE_NORMAL
- en: switch
  prefs: []
  type: TYPE_NORMAL
- en: (logLevel)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: case
  prefs: []
  type: TYPE_NORMAL
- en: 'LogLevel.Trace:'
  prefs: []
  type: TYPE_NORMAL
- en: case
  prefs: []
  type: TYPE_NORMAL
- en: 'LogLevel.Information:'
  prefs: []
  type: TYPE_NORMAL
- en: case
  prefs: []
  type: TYPE_NORMAL
- en: 'LogLevel.None:'
  prefs: []
  type: TYPE_NORMAL
- en: return
  prefs: []
  type: TYPE_NORMAL
- en: 'false'
  prefs: []
  type: TYPE_NORMAL
- en: ;
  prefs: []
  type: TYPE_NORMAL
- en: case
  prefs: []
  type: TYPE_NORMAL
- en: 'LogLevel.Debug:'
  prefs: []
  type: TYPE_NORMAL
- en: case
  prefs: []
  type: TYPE_NORMAL
- en: 'LogLevel.Warning:'
  prefs: []
  type: TYPE_NORMAL
- en: case
  prefs: []
  type: TYPE_NORMAL
- en: 'LogLevel.Error:'
  prefs: []
  type: TYPE_NORMAL
- en: case
  prefs: []
  type: TYPE_NORMAL
- en: 'LogLevel.Critical:'
  prefs: []
  type: TYPE_NORMAL
- en: default
  prefs: []
  type: TYPE_NORMAL
- en: ':'
  prefs: []
  type: TYPE_NORMAL
- en: return
  prefs: []
  type: TYPE_NORMAL
- en: 'true'
  prefs: []
  type: TYPE_NORMAL
- en: ;
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: void
  prefs: []
  type: TYPE_NORMAL
- en: Log
  prefs: []
  type: TYPE_NORMAL
- en: <
  prefs: []
  type: TYPE_NORMAL
- en: TState
  prefs: []
  type: TYPE_NORMAL
- en: '>('
  prefs: []
  type: TYPE_NORMAL
- en: LogLevel logLevel,
  prefs: []
  type: TYPE_NORMAL
- en: EventId eventId, TState state, Exception? exception,
  prefs: []
  type: TYPE_NORMAL
- en: Func<TState, Exception,
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: formatter
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: // log the level and event identifier
  prefs: []
  type: TYPE_NORMAL
- en: 'Write($"Level:'
  prefs: []
  type: TYPE_NORMAL
- en: '{logLevel}'
  prefs: []
  type: TYPE_NORMAL
- en: ', Event Id:'
  prefs: []
  type: TYPE_NORMAL
- en: '{eventId.Id}'
  prefs: []
  type: TYPE_NORMAL
- en: '"'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: // only output the state or exception if it exists
  prefs: []
  type: TYPE_NORMAL
- en: if
  prefs: []
  type: TYPE_NORMAL
- en: (state != null
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write($", State:'
  prefs: []
  type: TYPE_NORMAL
- en: '{state}'
  prefs: []
  type: TYPE_NORMAL
- en: '"'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: if
  prefs: []
  type: TYPE_NORMAL
- en: (exception != null
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write($", Exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '{exception.Message}'
  prefs: []
  type: TYPE_NORMAL
- en: '"'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the top of `Program.cs` , add statements to import the namespaces needed
    for logging, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft.EntityFrameworkCore.Infrastructure;
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft.Extensions.DependencyInjection;
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft.Extensions.Logging;
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'We already used the `ToQueryString` method to get the SQL for `FilteredIncludes`
    so we do not need to add logging to that method. To both the `QueryingCategories`
    and `QueryingProducts` methods, add statements immediately inside the `using`
    block for the `Northwind` database context to get the logging factory and register
    your custom console logger, as shown highlighted in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: (Northwind db = new
  prefs: []
  type: TYPE_NORMAL
- en: ())
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: '**ILoggerFactory loggerFactory = db.GetService<ILoggerFactory>();**'
  prefs: []
  type: TYPE_NORMAL
- en: '**loggerFactory.AddProvider(**'
  prefs: []
  type: TYPE_NORMAL
- en: '**new**'
  prefs: []
  type: TYPE_NORMAL
- en: '**ConsoleLoggerProvider());**'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: At the top of `Program.cs` , comment out the call to the `FilteredIncludes`
    method and uncomment the call to the `QueryingProducts` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the code and view the logs, which are partially shown in the following
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: 'Level: Debug, Event Id: 20000, State: Opening connection to database ''main''
    on server ''/Users/markjprice/Code/Chapter10/WorkingWithEFCore/Northwind.db''.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Level: Debug, Event Id: 20001, State: Opened connection to database ''main''
    on server ''/Users/markjprice/Code/Chapter10/WorkingWithEFCore/Northwind.db''.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Level: Debug, Event Id: 20100, State: Executing DbCommand [Parameters=[@__price_0=''?''],
    CommandType=''Text'', CommandTimeout=''30'']'
  prefs: []
  type: TYPE_NORMAL
- en: SELECT "p"."ProductId", "p"."CategoryId", "p"."UnitPrice", "p"."Discontinued",
    "p"."ProductName", "p"."UnitsInStock"
  prefs: []
  type: TYPE_NORMAL
- en: FROM "Products" AS "p"
  prefs: []
  type: TYPE_NORMAL
- en: WHERE "p"."UnitPrice" > @__price_0
  prefs: []
  type: TYPE_NORMAL
- en: ORDER BY "product"."UnitPrice" DESC
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Your logs might vary from those shown above based on your chosen database provider
    and code editor, and future improvements to EF Core. For now, note that different
    events like opening a connection or executing a command have different event ids.
  prefs: []
  type: TYPE_NORMAL
- en: Filtering logs by provider-specific values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The event id values and what they mean will be specific to the .NET data provider.
    If we want to know how the LINQ query has been translated into SQL statements
    and is executing, then the event Id to output has an `Id` value of `20100` :'
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the `Log` method in `ConsoleLogger` to only output events with an `Id`
    of `20100` , as highlighted in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: void
  prefs: []
  type: TYPE_NORMAL
- en: Log
  prefs: []
  type: TYPE_NORMAL
- en: <
  prefs: []
  type: TYPE_NORMAL
- en: TState
  prefs: []
  type: TYPE_NORMAL
- en: '>('
  prefs: []
  type: TYPE_NORMAL
- en: LogLevel logLevel, EventId eventId,
  prefs: []
  type: TYPE_NORMAL
- en: TState state, Exception? exception,
  prefs: []
  type: TYPE_NORMAL
- en: Func<TState, Exception,
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: formatter
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: '**if**'
  prefs: []
  type: TYPE_NORMAL
- en: '**(eventId.Id ==**'
  prefs: []
  type: TYPE_NORMAL
- en: '**20100**'
  prefs: []
  type: TYPE_NORMAL
- en: '**)**'
  prefs: []
  type: TYPE_NORMAL
- en: '**{**'
  prefs: []
  type: TYPE_NORMAL
- en: // log the level and event identifier
  prefs: []
  type: TYPE_NORMAL
- en: 'Write("Level: {0}, Event Id: {1}, Event: {2}"'
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: logLevel, eventId.Id, eventId.Name);
  prefs: []
  type: TYPE_NORMAL
- en: // only output the state or exception if it exists
  prefs: []
  type: TYPE_NORMAL
- en: if
  prefs: []
  type: TYPE_NORMAL
- en: (state != null
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write($", State:'
  prefs: []
  type: TYPE_NORMAL
- en: '{state}'
  prefs: []
  type: TYPE_NORMAL
- en: '"'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: if
  prefs: []
  type: TYPE_NORMAL
- en: (exception != null
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write($", Exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '{exception.Message}'
  prefs: []
  type: TYPE_NORMAL
- en: '"'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine();
  prefs: []
  type: TYPE_NORMAL
- en: '**}**'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: In `Program.cs` , uncomment the `QueryingCategories` method and comment out
    the other methods so that we can monitor the SQL statements that are generated
    when joining two tables.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the code, and note the following SQL statements that were logged, as shown
    in the following output that has been edited for space:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: Using SQLServer database provider.
  prefs: []
  type: TYPE_NORMAL
- en: 'Categories and how many products they have:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Level: Debug, Event Id: 20100, State: Executing DbCommand [Parameters=[], CommandType=''Text'',
    CommandTimeout=''30'']'
  prefs: []
  type: TYPE_NORMAL
- en: SELECT [c].[CategoryId], [c].[CategoryName], [c].[Description], [p].[ProductId],
    [p].[CategoryId], [p].[UnitPrice], [p].[Discontinued], [p].[ProductName], [p].[UnitsInStock]
  prefs: []
  type: TYPE_NORMAL
- en: FROM [Categories] AS [c]
  prefs: []
  type: TYPE_NORMAL
- en: LEFT JOIN [Products] AS [p] ON [c].[CategoryId] = [p].[CategoryId]
  prefs: []
  type: TYPE_NORMAL
- en: ORDER BY [c].[CategoryId], [p].[ProductId]
  prefs: []
  type: TYPE_NORMAL
- en: Beverages has 12 products.
  prefs: []
  type: TYPE_NORMAL
- en: Condiments has 12 products.
  prefs: []
  type: TYPE_NORMAL
- en: Confections has 13 products.
  prefs: []
  type: TYPE_NORMAL
- en: Dairy Products has 10 products.
  prefs: []
  type: TYPE_NORMAL
- en: Grains/Cereals has 7 products.
  prefs: []
  type: TYPE_NORMAL
- en: Meat/Poultry has 6 products.
  prefs: []
  type: TYPE_NORMAL
- en: Produce has 5 products.
  prefs: []
  type: TYPE_NORMAL
- en: Seafood has 12 products.
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Logging with query tags
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When logging LINQ queries, it can be tricky to correlate log messages in complex
    scenarios. EF Core 2.2 introduced the query tags feature to help by allowing you
    to add SQL comments to the log.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can annotate a LINQ query using the `TagWith` method, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: IQueryable<Product>? products = db.Products?
  prefs: []
  type: TYPE_NORMAL
- en: .TagWith("Products filtered by price and sorted."
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: .Where(product => product.Cost > price)
  prefs: []
  type: TYPE_NORMAL
- en: .OrderByDescending(product => product.Cost);
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'This will add an SQL comment to the log, as shown in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: -- Products filtered by price and sorted.
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Pattern matching with Like
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'EF Core supports common SQL statements including `Like` for pattern matching:'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the bottom of `Program.cs` , add a method named `QueryingWithLike` , as
    shown in the following code, and note:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We have enabled logging.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We prompt the user to enter part of a product name and then use the `EF.Functions.Like`
    method to search anywhere in the `ProductName` property.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For each matching product, we output its name, stock, and if it is discontinued:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: static
  prefs: []
  type: TYPE_NORMAL
- en: void
  prefs: []
  type: TYPE_NORMAL
- en: QueryingWithLike
  prefs: []
  type: TYPE_NORMAL
- en: ()
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: (Northwind db = new
  prefs: []
  type: TYPE_NORMAL
- en: ())
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: ILoggerFactory loggerFactory = db.GetService<ILoggerFactory>();
  prefs: []
  type: TYPE_NORMAL
- en: loggerFactory.AddProvider(new
  prefs: []
  type: TYPE_NORMAL
- en: ConsoleLoggerProvider());
  prefs: []
  type: TYPE_NORMAL
- en: 'Write("Enter part of a product name: "'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: '? input = ReadLine();'
  prefs: []
  type: TYPE_NORMAL
- en: IQueryable<Product>? products = db.Products?
  prefs: []
  type: TYPE_NORMAL
- en: .Where(p => EF.Functions.Like(p.ProductName, $"%
  prefs: []
  type: TYPE_NORMAL
- en: '{input}'
  prefs: []
  type: TYPE_NORMAL
- en: '%"'
  prefs: []
  type: TYPE_NORMAL
- en: ));
  prefs: []
  type: TYPE_NORMAL
- en: if
  prefs: []
  type: TYPE_NORMAL
- en: (products is
  prefs: []
  type: TYPE_NORMAL
- en: 'null'
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("No products found."
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: return
  prefs: []
  type: TYPE_NORMAL
- en: ;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: foreach
  prefs: []
  type: TYPE_NORMAL
- en: (Product p in
  prefs: []
  type: TYPE_NORMAL
- en: products)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("{0} has {1} units in stock. Discontinued? {2}"
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: p.ProductName, p.Stock, p.Discontinued);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: In `Program.cs` , comment out the existing methods, and call `QueryingWithLike`
    .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the code, enter a partial product name such as `che` , and view the result,
    as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: Using SQLServer database provider.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter part of a product name: che'
  prefs: []
  type: TYPE_NORMAL
- en: 'Level: Debug, Event Id: 20100, State: Executing DbCommand [Parameters=[@__Format_1=''?''
    (Size = 40)], CommandType=''Text'', CommandTimeout=''30'']'
  prefs: []
  type: TYPE_NORMAL
- en: SELECT "p"."ProductId", "p"."CategoryId", "p"."UnitPrice",
  prefs: []
  type: TYPE_NORMAL
- en: '"p"."Discontinued", "p"."ProductName", "p"."UnitsInStock" FROM "Products" AS
    "p"'
  prefs: []
  type: TYPE_NORMAL
- en: WHERE "p"."ProductName" LIKE @__Format_1
  prefs: []
  type: TYPE_NORMAL
- en: Chef Anton's Cajun Seasoning has 53 units in stock. Discontinued? False
  prefs: []
  type: TYPE_NORMAL
- en: Chef Anton's Gumbo Mix has 0 units in stock. Discontinued? True
  prefs: []
  type: TYPE_NORMAL
- en: Queso Manchego La Pastora has 86 units in stock. Discontinued? False
  prefs: []
  type: TYPE_NORMAL
- en: Gumbär Gummibärchen has 15 units in stock. Discontinued? False
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: EF Core 6.0 introduces another useful function, `EF.Functions.Random` , that
    maps to a database function returning a pseudo-random number between 0 and 1 exclusive.
    For example, you could multiply the random number by the count of rows in a table
    to select one random row from that table.
  prefs: []
  type: TYPE_NORMAL
- en: Defining global filters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Northwind products can be discontinued, so it might be useful to ensure that
    discontinued products are never returned in results, even if the programmer does
    not use `Where` to filter them out in their queries:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Northwind.cs` , modify the `OnModelCreating` method to add a global filter
    to remove discontinued products, as shown highlighted in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: protected
  prefs: []
  type: TYPE_NORMAL
- en: override
  prefs: []
  type: TYPE_NORMAL
- en: void
  prefs: []
  type: TYPE_NORMAL
- en: OnModelCreating
  prefs: []
  type: TYPE_NORMAL
- en: (
  prefs: []
  type: TYPE_NORMAL
- en: ModelBuilder modelBuilder
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: '**// global filter to remove discontinued products**'
  prefs: []
  type: TYPE_NORMAL
- en: '**modelBuilder.Entity<Product>()**'
  prefs: []
  type: TYPE_NORMAL
- en: '**.HasQueryFilter(p => !p.Discontinued);**'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code, enter the partial product name `che` , view the result, and note
    that **Chef Anton''s Gumbo Mix** is now missing, because the SQL statement generated
    includes a filter for the `Discontinued` column, as shown highlighted in the following
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: SELECT "p"."ProductId", "p"."CategoryId", "p"."UnitPrice",
  prefs: []
  type: TYPE_NORMAL
- en: '"p"."Discontinued", "p"."ProductName", "p"."UnitsInStock"'
  prefs: []
  type: TYPE_NORMAL
- en: FROM "Products" AS "p"
  prefs: []
  type: TYPE_NORMAL
- en: WHERE
  prefs: []
  type: TYPE_NORMAL
- en: '**("p"."Discontinued" = 0)**'
  prefs: []
  type: TYPE_NORMAL
- en: AND "p"."ProductName" LIKE @__Format_1
  prefs: []
  type: TYPE_NORMAL
- en: Chef Anton's Cajun Seasoning has 53 units in stock. Discontinued? False
  prefs: []
  type: TYPE_NORMAL
- en: Queso Manchego La Pastora has 86 units in stock. Discontinued? False
  prefs: []
  type: TYPE_NORMAL
- en: Gumbär Gummibärchen has 15 units in stock. Discontinued? False
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Loading patterns with EF Core
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are three loading patterns that are commonly used with EF Core:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Eager loading** : Load data early.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lazy loading** : Load data automatically just before it is needed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Explicit loading** : Load data manually.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, we're going to introduce each of them.
  prefs: []
  type: TYPE_NORMAL
- en: Eager loading entities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the `QueryingCategories` method, the code currently uses the `Categories`
    property to loop through each category, outputting the category name and the number
    of products in that category.
  prefs: []
  type: TYPE_NORMAL
- en: This works because when we wrote the query, we enabled eager loading by calling
    the `Include` method for the related products.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see what happens if we do not call `Include` :'
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the query to comment out the `Include` method call, as shown in the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: IQueryable<Category>? categories =
  prefs: []
  type: TYPE_NORMAL
- en: db.Categories; //.Include(c => c.Products);
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: In `Program.cs` , comment out all methods except `QueryingCategories` .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the code and view the result, as shown in the following partial output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: Beverages has 0 products.
  prefs: []
  type: TYPE_NORMAL
- en: Condiments has 0 products.
  prefs: []
  type: TYPE_NORMAL
- en: Confections has 0 products.
  prefs: []
  type: TYPE_NORMAL
- en: Dairy Products has 0 products.
  prefs: []
  type: TYPE_NORMAL
- en: Grains/Cereals has 0 products.
  prefs: []
  type: TYPE_NORMAL
- en: Meat/Poultry has 0 products.
  prefs: []
  type: TYPE_NORMAL
- en: Produce has 0 products.
  prefs: []
  type: TYPE_NORMAL
- en: Seafood has 0 products.
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Each item in `foreach` is an instance of the `Category` class, which has a property
    named `Products` , that is, the list of products in that category. Since the original
    query is only selected from the `Categories` table, this property is empty for
    each category.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling lazy loading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Lazy loading was introduced in EF Core 2.1, and it can automatically load missing
    related data. To enable lazy loading, developers must:'
  prefs: []
  type: TYPE_NORMAL
- en: Reference a NuGet package for proxies.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configure lazy loading to use a proxy.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s see this in action:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `WorkingWithEFCore` project, add a package reference for EF Core proxies,
    as shown in the following markup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: <PackageReference
  prefs: []
  type: TYPE_NORMAL
- en: Include="Microsoft.EntityFrameworkCore.Proxies"
  prefs: []
  type: TYPE_NORMAL
- en: Version="6.0.0"
  prefs: []
  type: TYPE_NORMAL
- en: />
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Build the project to restore packages.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open `Northwind.cs` , and call an extension method to use lazy loading proxies
    at the top of the `OnConfiguring` method, as shown highlighted in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: protected
  prefs: []
  type: TYPE_NORMAL
- en: override
  prefs: []
  type: TYPE_NORMAL
- en: void
  prefs: []
  type: TYPE_NORMAL
- en: OnConfiguring
  prefs: []
  type: TYPE_NORMAL
- en: (
  prefs: []
  type: TYPE_NORMAL
- en: DbContextOptionsBuilder optionsBuilder
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: '**optionsBuilder.UseLazyLoadingProxies();**'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Now, every time the loop enumerates, and an attempt is made to read the `Products`
    property, the lazy loading proxy will check if they are loaded. If not, it will
    load them for us "lazily" by executing a `SELECT` statement to load just that
    set of products for the current category, and then the correct count will be returned
    to the output.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code and note that the product counts are now correct. But you will
    see that the problem with lazy loading is that multiple round trips to the database
    server are required to eventually fetch all the data, as shown in the following
    partial output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: 'Categories and how many products they have:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Level: Debug, Event Id: 20100, State: Executing DbCommand [Parameters=[], CommandType=''Text'',
    CommandTimeout=''30'']'
  prefs: []
  type: TYPE_NORMAL
- en: SELECT "c"."CategoryId", "c"."CategoryName", "c"."Description" FROM "Categories"
    AS "c"
  prefs: []
  type: TYPE_NORMAL
- en: 'Level: Debug, Event Id: 20100, State: Executing DbCommand [Parameters=[@ p_0=''?''],
    CommandType=''Text'', CommandTimeout=''30'']'
  prefs: []
  type: TYPE_NORMAL
- en: SELECT "p"."ProductId", "p"."CategoryId", "p"."UnitPrice",
  prefs: []
  type: TYPE_NORMAL
- en: '"p"."Discontinued", "p"."ProductName", "p"."UnitsInStock"'
  prefs: []
  type: TYPE_NORMAL
- en: FROM "Products" AS "p"
  prefs: []
  type: TYPE_NORMAL
- en: WHERE ("p"."Discontinued" = 0) AND ("p"."CategoryId" = @ p_0)
  prefs: []
  type: TYPE_NORMAL
- en: Beverages has 11 products.
  prefs: []
  type: TYPE_NORMAL
- en: 'Level: Debug, Event ID: 20100, State: Executing DbCommand [Parameters=[@ p_0=''?''],
    CommandType=''Text'', CommandTimeout=''30'']'
  prefs: []
  type: TYPE_NORMAL
- en: SELECT "p"."ProductId", "p"."CategoryId", "p"."UnitPrice",
  prefs: []
  type: TYPE_NORMAL
- en: '"p"."Discontinued", "p"."ProductName", "p"."UnitsInStock"'
  prefs: []
  type: TYPE_NORMAL
- en: FROM "Products" AS "p"
  prefs: []
  type: TYPE_NORMAL
- en: WHERE ("p"."Discontinued" = 0) AND ("p"."CategoryId" = @ p_0)
  prefs: []
  type: TYPE_NORMAL
- en: Condiments has 11 products.
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Explicit loading entities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another type of loading is explicit loading. It works in a similar way to lazy
    loading, with the difference being that you are in control of exactly what related
    data is loaded and when:'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the top of `Program.cs` , import the change tracking namespace to enable
    us to use the `CollectionEntry` class to manually load related entities, as shown
    in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft.EntityFrameworkCore.ChangeTracking; // CollectionEntry
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `QueryingCategories` method, modify the statements to disable lazy loading
    and then prompt the user as to whether they want to enable eager loading and explicit
    loading, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: IQueryable<Category>? categories;
  prefs: []
  type: TYPE_NORMAL
- en: // = db.Categories;
  prefs: []
  type: TYPE_NORMAL
- en: // .Include(c => c.Products);
  prefs: []
  type: TYPE_NORMAL
- en: db.ChangeTracker.LazyLoadingEnabled = false
  prefs: []
  type: TYPE_NORMAL
- en: ;
  prefs: []
  type: TYPE_NORMAL
- en: 'Write("Enable eager loading? (Y/N): "'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: bool
  prefs: []
  type: TYPE_NORMAL
- en: eagerloading = (ReadKey().Key == ConsoleKey.Y);
  prefs: []
  type: TYPE_NORMAL
- en: bool
  prefs: []
  type: TYPE_NORMAL
- en: explicitloading = false
  prefs: []
  type: TYPE_NORMAL
- en: ;
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine();
  prefs: []
  type: TYPE_NORMAL
- en: if
  prefs: []
  type: TYPE_NORMAL
- en: (eagerloading)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: categories = db.Categories?.Include(c => c.Products);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: else
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: categories = db.Categories;
  prefs: []
  type: TYPE_NORMAL
- en: 'Write("Enable explicit loading? (Y/N): "'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: explicitloading = (ReadKey().Key == ConsoleKey.Y);
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `foreach` loop, before the `WriteLine` method call, add statements to
    check if explicit loading is enabled, and if so, prompt the user as to whether
    they want to explicitly load each individual category, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: if
  prefs: []
  type: TYPE_NORMAL
- en: (explicitloading)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: Write($"Explicitly load products for
  prefs: []
  type: TYPE_NORMAL
- en: '{c.CategoryName}'
  prefs: []
  type: TYPE_NORMAL
- en: '? (Y/N): "'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: ConsoleKeyInfo key = ReadKey();
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine();
  prefs: []
  type: TYPE_NORMAL
- en: if
  prefs: []
  type: TYPE_NORMAL
- en: (key.Key == ConsoleKey.Y)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: CollectionEntry<Category, Product> products =
  prefs: []
  type: TYPE_NORMAL
- en: db.Entry(c).Collection(c2 => c2.Products);
  prefs: []
  type: TYPE_NORMAL
- en: if
  prefs: []
  type: TYPE_NORMAL
- en: (!products.IsLoaded) products.Load();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine($"
  prefs: []
  type: TYPE_NORMAL
- en: '{c.CategoryName}'
  prefs: []
  type: TYPE_NORMAL
- en: has
  prefs: []
  type: TYPE_NORMAL
- en: '{c.Products.Count}'
  prefs: []
  type: TYPE_NORMAL
- en: products."
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press `N` to disable eager loading.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then press `Y` to enable explicit loading.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For each category, press `Y` or `N` to load its products as you wish.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'I chose to load products for only two of the eight categories, Beverages and
    Seafood, as shown in the following output that has been edited for space:'
  prefs: []
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: 'Categories and how many products they have:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Enable eager loading? (Y/N): n'
  prefs: []
  type: TYPE_NORMAL
- en: 'Enable explicit loading? (Y/N): y'
  prefs: []
  type: TYPE_NORMAL
- en: 'Level: Debug, Event Id: 20100, State: Executing DbCommand [Parameters=[], CommandType=''Text'',
    CommandTimeout=''30'']'
  prefs: []
  type: TYPE_NORMAL
- en: SELECT "c"."CategoryId", "c"."CategoryName", "c"."Description" FROM "Categories"
    AS "c"
  prefs: []
  type: TYPE_NORMAL
- en: 'Explicitly load products for Beverages? (Y/N): y'
  prefs: []
  type: TYPE_NORMAL
- en: 'Level: Debug, Event Id: 20100, State: Executing DbCommand [Parameters=[@ p_0=''?''],
    CommandType=''Text'', CommandTimeout=''30'']'
  prefs: []
  type: TYPE_NORMAL
- en: SELECT "p"."ProductId", "p"."CategoryId", "p"."UnitPrice",
  prefs: []
  type: TYPE_NORMAL
- en: '"p"."Discontinued", "p"."ProductName", "p"."UnitsInStock"'
  prefs: []
  type: TYPE_NORMAL
- en: FROM "Products" AS "p"
  prefs: []
  type: TYPE_NORMAL
- en: WHERE ("p"."Discontinued" = 0) AND ("p"."CategoryId" = @ p_0)
  prefs: []
  type: TYPE_NORMAL
- en: Beverages has 11 products.
  prefs: []
  type: TYPE_NORMAL
- en: 'Explicitly load products for Condiments? (Y/N): n'
  prefs: []
  type: TYPE_NORMAL
- en: Condiments has 0 products.
  prefs: []
  type: TYPE_NORMAL
- en: 'Explicitly load products for Confections? (Y/N): n'
  prefs: []
  type: TYPE_NORMAL
- en: Confections has 0 products.
  prefs: []
  type: TYPE_NORMAL
- en: 'Explicitly load products for Dairy Products? (Y/N): n'
  prefs: []
  type: TYPE_NORMAL
- en: Dairy Products has 0 products.
  prefs: []
  type: TYPE_NORMAL
- en: 'Explicitly load products for Grains/Cereals? (Y/N): n'
  prefs: []
  type: TYPE_NORMAL
- en: Grains/Cereals has 0 products.
  prefs: []
  type: TYPE_NORMAL
- en: 'Explicitly load products for Meat/Poultry? (Y/N): n'
  prefs: []
  type: TYPE_NORMAL
- en: Meat/Poultry has 0 products.
  prefs: []
  type: TYPE_NORMAL
- en: 'Explicitly load products for Produce? (Y/N): n'
  prefs: []
  type: TYPE_NORMAL
- en: Produce has 0 products.
  prefs: []
  type: TYPE_NORMAL
- en: 'Explicitly load products for Seafood? (Y/N): y'
  prefs: []
  type: TYPE_NORMAL
- en: 'Level: Debug, Event ID: 20100, State: Executing DbCommand [Parameters=[@ p_0=''?''],
    CommandType=''Text'', CommandTimeout=''30'']'
  prefs: []
  type: TYPE_NORMAL
- en: SELECT "p"."ProductId", "p"."CategoryId", "p"."UnitPrice",
  prefs: []
  type: TYPE_NORMAL
- en: '"p"."Discontinued", "p"."ProductName", "p"."UnitsInStock"'
  prefs: []
  type: TYPE_NORMAL
- en: FROM "Products" AS "p"
  prefs: []
  type: TYPE_NORMAL
- en: WHERE ("p"."Discontinued" = 0) AND ("p"."CategoryId" = @ p_0)
  prefs: []
  type: TYPE_NORMAL
- en: Seafood has 12 products.
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice** : Carefully consider which loading pattern is best for your
    code. Lazy loading could literally make you a lazy database developer! Read more
    about loading patterns at the following link: [https://docs.microsoft.com/en-us/ef/core/querying/related-data](https://docs.microsoft.com/en-us/ef/core/querying/related-data)'
  prefs: []
  type: TYPE_NORMAL
- en: Manipulating data with EF Core
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Inserting, updating, and deleting entities using EF Core is an easy task to
    accomplish.
  prefs: []
  type: TYPE_NORMAL
- en: '`DbContext` maintains change tracking automatically, so the local entities
    can have multiple changes tracked, including adding new entities, modifying existing
    entities, and removing entities. When you are ready to send those changes to the
    underlying database, call the `SaveChanges` method. The number of entities successfully
    changed will be returned.'
  prefs: []
  type: TYPE_NORMAL
- en: Inserting entities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start by looking at how to add a new row to a table:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs` , create a new method named `AddProduct` , as shown in the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: static
  prefs: []
  type: TYPE_NORMAL
- en: bool
  prefs: []
  type: TYPE_NORMAL
- en: AddProduct
  prefs: []
  type: TYPE_NORMAL
- en: (
  prefs: []
  type: TYPE_NORMAL
- en: int
  prefs: []
  type: TYPE_NORMAL
- en: categoryId,
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: productName,
  prefs: []
  type: TYPE_NORMAL
- en: decimal
  prefs: []
  type: TYPE_NORMAL
- en: '? price'
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: (Northwind db = new
  prefs: []
  type: TYPE_NORMAL
- en: ())
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: Product p = new
  prefs: []
  type: TYPE_NORMAL
- en: ()
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: CategoryId = categoryId,
  prefs: []
  type: TYPE_NORMAL
- en: ProductName = productName,
  prefs: []
  type: TYPE_NORMAL
- en: Cost = price
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: // mark product as added in change tracking
  prefs: []
  type: TYPE_NORMAL
- en: db.Products.Add(p);
  prefs: []
  type: TYPE_NORMAL
- en: // save tracked change to database
  prefs: []
  type: TYPE_NORMAL
- en: int
  prefs: []
  type: TYPE_NORMAL
- en: affected = db.SaveChanges();
  prefs: []
  type: TYPE_NORMAL
- en: return
  prefs: []
  type: TYPE_NORMAL
- en: (affected == 1
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs` , create a new method named `ListProducts` that outputs the
    Id, name, cost, stock, and discontinued properties of each product sorted with
    the costliest first, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: static
  prefs: []
  type: TYPE_NORMAL
- en: void
  prefs: []
  type: TYPE_NORMAL
- en: ListProducts
  prefs: []
  type: TYPE_NORMAL
- en: ()
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: (Northwind db = new
  prefs: []
  type: TYPE_NORMAL
- en: ())
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("{0,-3} {1,-35} {2,8} {3,5} {4}"
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: '"Id"'
  prefs: []
  type: TYPE_NORMAL
- en: ', "Product Name"'
  prefs: []
  type: TYPE_NORMAL
- en: ', "Cost"'
  prefs: []
  type: TYPE_NORMAL
- en: ', "Stock"'
  prefs: []
  type: TYPE_NORMAL
- en: ', "Disc."'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: foreach
  prefs: []
  type: TYPE_NORMAL
- en: (Product p in
  prefs: []
  type: TYPE_NORMAL
- en: db.Products
  prefs: []
  type: TYPE_NORMAL
- en: .OrderByDescending(product => product.Cost))
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("{0:000} {1,-35} {2,8:$#,##0.00} {3,5} {4}"
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: p.ProductId, p.ProductName, p.Cost, p.Stock, p.Discontinued);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Remember that `1,-35` means left-align argument 1 within a 35-character-wide
    column and `3,5` means right-align argument 3 within a 5-character-wide column.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs` , comment out previous method calls, and then call `AddProduct`
    and `ListProducts` , as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: // QueryingCategories();
  prefs: []
  type: TYPE_NORMAL
- en: // FilteredIncludes();
  prefs: []
  type: TYPE_NORMAL
- en: // QueryingProducts();
  prefs: []
  type: TYPE_NORMAL
- en: // QueryingWithLike();
  prefs: []
  type: TYPE_NORMAL
- en: if
  prefs: []
  type: TYPE_NORMAL
- en: '(AddProduct(categoryId: 6'
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: 'productName: "Bob''s Burgers"'
  prefs: []
  type: TYPE_NORMAL
- en: ', price: 500'
  prefs: []
  type: TYPE_NORMAL
- en: M))
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("Add product successful."
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: ListProducts();
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code, view the result, and note the new product has been added, as
    shown in the following partial output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: Add product successful.
  prefs: []
  type: TYPE_NORMAL
- en: Id  Product Name              Cost Stock Disc.
  prefs: []
  type: TYPE_NORMAL
- en: 078 Bob's Burgers          $500.00       False
  prefs: []
  type: TYPE_NORMAL
- en: 038 Côte de Blaye          $263.50    17 False
  prefs: []
  type: TYPE_NORMAL
- en: 020 Sir Rodney's Marmalade  $81.00    40 False
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Updating entities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, let''s modify an existing row in a table:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs` , add a method to increase the price of the first product with
    a name that begins with a specified value (we''ll use Bob in our example) by a
    specified amount like $20, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: static
  prefs: []
  type: TYPE_NORMAL
- en: bool
  prefs: []
  type: TYPE_NORMAL
- en: IncreaseProductPrice
  prefs: []
  type: TYPE_NORMAL
- en: (
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: productNameStartsWith,
  prefs: []
  type: TYPE_NORMAL
- en: decimal
  prefs: []
  type: TYPE_NORMAL
- en: amount
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: (Northwind db = new
  prefs: []
  type: TYPE_NORMAL
- en: ())
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: // get first product whose name starts with name
  prefs: []
  type: TYPE_NORMAL
- en: Product updateProduct = db.Products.First(
  prefs: []
  type: TYPE_NORMAL
- en: p => p.ProductName.StartsWith(productNameStartsWith));
  prefs: []
  type: TYPE_NORMAL
- en: updateProduct.Cost += amount;
  prefs: []
  type: TYPE_NORMAL
- en: int
  prefs: []
  type: TYPE_NORMAL
- en: affected = db.SaveChanges();
  prefs: []
  type: TYPE_NORMAL
- en: return
  prefs: []
  type: TYPE_NORMAL
- en: (affected == 1
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs` , comment out the whole `if` block that calls `AddProduct`
    , and add a call to `IncreaseProductPrice` before the call to list products, as
    shown highlighted in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: '**/***'
  prefs: []
  type: TYPE_NORMAL
- en: 'if (AddProduct(categoryId: 6,'
  prefs: []
  type: TYPE_NORMAL
- en: 'productName: "Bob''s Burgers", price: 500M))'
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("Add product successful.");
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '***/**'
  prefs: []
  type: TYPE_NORMAL
- en: '**if**'
  prefs: []
  type: TYPE_NORMAL
- en: '**(IncreaseProductPrice(**'
  prefs: []
  type: TYPE_NORMAL
- en: '**productNameStartsWith:**'
  prefs: []
  type: TYPE_NORMAL
- en: '**"Bob"**'
  prefs: []
  type: TYPE_NORMAL
- en: '**, amount:**'
  prefs: []
  type: TYPE_NORMAL
- en: '**20**'
  prefs: []
  type: TYPE_NORMAL
- en: '**M))**'
  prefs: []
  type: TYPE_NORMAL
- en: '**{**'
  prefs: []
  type: TYPE_NORMAL
- en: '**WriteLine(**'
  prefs: []
  type: TYPE_NORMAL
- en: '**"Update product price successful."**'
  prefs: []
  type: TYPE_NORMAL
- en: '**);**'
  prefs: []
  type: TYPE_NORMAL
- en: '**}**'
  prefs: []
  type: TYPE_NORMAL
- en: ListProducts();
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code, view the result, and note that the existing entity for Bob''s
    Burgers has increased in price by $20, as shown in the following partial output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: Update product price successful.
  prefs: []
  type: TYPE_NORMAL
- en: Id  Product Name              Cost Stock Disc.
  prefs: []
  type: TYPE_NORMAL
- en: 078 Bob's Burgers          $520.00       False
  prefs: []
  type: TYPE_NORMAL
- en: 038 Côte de Blaye          $263.50    17 False
  prefs: []
  type: TYPE_NORMAL
- en: 020 Sir Rodney's Marmalade  $81.00    40 False
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Deleting entities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can remove individual entities with the `Remove` method. `RemoveRange` is
    more efficient when you want to delete multiple entities.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s see how to delete rows from a table:'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the bottom of `Program.cs` , add a method to delete all products with a
    name that begins with a specified value (Bob in our example), as shown in the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: static
  prefs: []
  type: TYPE_NORMAL
- en: int
  prefs: []
  type: TYPE_NORMAL
- en: DeleteProducts
  prefs: []
  type: TYPE_NORMAL
- en: (
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: productNameStartsWith
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: (Northwind db = new
  prefs: []
  type: TYPE_NORMAL
- en: ())
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: IQueryable<Product>? products = db.Products?.Where(
  prefs: []
  type: TYPE_NORMAL
- en: p => p.ProductName.StartsWith(productNameStartsWith));
  prefs: []
  type: TYPE_NORMAL
- en: if
  prefs: []
  type: TYPE_NORMAL
- en: (products is
  prefs: []
  type: TYPE_NORMAL
- en: 'null'
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("No products found to delete."
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: return
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  prefs: []
  type: TYPE_NORMAL
- en: ;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: else
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: db.Products.RemoveRange(products);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: int
  prefs: []
  type: TYPE_NORMAL
- en: affected = db.SaveChanges();
  prefs: []
  type: TYPE_NORMAL
- en: return
  prefs: []
  type: TYPE_NORMAL
- en: affected;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs` , comment out the whole `if` statement block that calls `IncreaseProductPrice`
    , and add a call to `DeleteProducts` , as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: int
  prefs: []
  type: TYPE_NORMAL
- en: 'deleted = DeleteProducts(productNameStartsWith: "Bob"'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine($"
  prefs: []
  type: TYPE_NORMAL
- en: '{deleted}'
  prefs: []
  type: TYPE_NORMAL
- en: product(s) were deleted."
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code and view the result, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: 1 product(s) were deleted.
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: If multiple product names started with Bob, then they are all deleted. As an
    optional challenge, modify the statements to add three new products that start
    with Bob and then delete them.
  prefs: []
  type: TYPE_NORMAL
- en: Pooling database contexts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `DbContext` class is disposable and is designed following the single-unit-of-work
    principle. In the previous code examples, we created all the `DbContext` -derived
    Northwind instances in a `using` block so that `Dispose` is properly called at
    the end of each unit of work.
  prefs: []
  type: TYPE_NORMAL
- en: A feature of ASP.NET Core that is related to EF Core is that it makes your code
    more efficient by pooling database contexts when building websites and services.
    This allows you to create and dispose of as many `DbContext` -derived objects
    as you want, knowing that your code is still as efficient as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Working with transactions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every time you call the `SaveChanges` method, an **implicit** **transaction**
    is started so that if something goes wrong, it will automatically roll back all
    the changes. If the multiple changes within the transaction succeed, then the
    transaction and all changes are committed.
  prefs: []
  type: TYPE_NORMAL
- en: Transactions maintain the integrity of your database by applying locks to prevent
    reads and writes while a sequence of changes is occurring.
  prefs: []
  type: TYPE_NORMAL
- en: 'Transactions are **ACID** , which is an acronym explained in the following
    list:'
  prefs: []
  type: TYPE_NORMAL
- en: '**A is for atomic** . Either all the operations in the transaction commit,
    or none of them do.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**C is for consistent** . The state of the database before and after a transaction
    is consistent. This is dependent on your code logic; for example, when transferring
    money between bank accounts, it is up to your business logic to ensure that if
    you debit $100 in one account, you credit $100 in the other account.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**I is for isolated** . During a transaction, changes are hidden from other
    processes. There are multiple isolation levels that you can pick from (refer to
    the following table). The stronger the level, the better the integrity of the
    data. However, more locks must be applied, which will negatively affect other
    processes. Snapshot is a special case because it creates multiple copies of rows
    to avoid locks, but this will increase the size of your database while transactions
    occur.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**D is for durable** . If a failure occurs during a transaction, it can be
    recovered. This is often implemented as a two-phase commit and transaction logs.
    Once the transaction is committed it is guaranteed to endure even if there are
    subsequent errors. The opposite of durable is volatile.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling transactions using isolation levels
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A developer can control transactions by setting an **isolation level** , as
    described in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Isolation level | Lock(s) | Integrity problems allowed |'
  prefs: []
  type: TYPE_TB
- en: '| `ReadUncommitted` | None | Dirty reads, nonrepeatable reads, and phantom
    data |'
  prefs: []
  type: TYPE_TB
- en: '| `ReadCommitted` | When editing, it applies read lock(s) to block other users
    from reading the record(s) until the transaction ends | Nonrepeatable reads and
    phantom data |'
  prefs: []
  type: TYPE_TB
- en: '| `RepeatableRead` | When reading, it applies edit lock(s) to block other users
    from editing the record(s) until the transaction ends | Phantom data |'
  prefs: []
  type: TYPE_TB
- en: '| `Serializable` | Applies key-range locks to prevent any action that would
    affect the results, including inserts and deletes | None |'
  prefs: []
  type: TYPE_TB
- en: '| `Snapshot` | None | None |'
  prefs: []
  type: TYPE_TB
- en: Defining an explicit transaction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can control explicit transactions using the `Database` property of the
    database context:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs` , import the EF Core storage namespace to use the `IDbContextTransaction`
    interface, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft.EntityFrameworkCore.Storage; // IDbContextTransaction
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `DeleteProducts` method, after the instantiation of the `db` variable,
    add statements to start an explicit transaction and output its isolation level.
    At the bottom of the method, commit the transaction, and close the brace, as shown
    highlighted in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: static
  prefs: []
  type: TYPE_NORMAL
- en: int
  prefs: []
  type: TYPE_NORMAL
- en: DeleteProducts
  prefs: []
  type: TYPE_NORMAL
- en: (
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: name
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: (Northwind db = new
  prefs: []
  type: TYPE_NORMAL
- en: ())
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: '**using**'
  prefs: []
  type: TYPE_NORMAL
- en: '**(IDbContextTransaction t = db.Database.BeginTransaction())**'
  prefs: []
  type: TYPE_NORMAL
- en: '**{**'
  prefs: []
  type: TYPE_NORMAL
- en: '**WriteLine(**'
  prefs: []
  type: TYPE_NORMAL
- en: '**"Transaction isolation level: {0}"**'
  prefs: []
  type: TYPE_NORMAL
- en: '**,**'
  prefs: []
  type: TYPE_NORMAL
- en: '**arg0: t.GetDbTransaction().IsolationLevel);**'
  prefs: []
  type: TYPE_NORMAL
- en: IQueryable<Product>? products = db.Products?.Where(
  prefs: []
  type: TYPE_NORMAL
- en: p => p.ProductName.StartsWith(name));
  prefs: []
  type: TYPE_NORMAL
- en: if
  prefs: []
  type: TYPE_NORMAL
- en: (products is
  prefs: []
  type: TYPE_NORMAL
- en: 'null'
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("No products found to delete."
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: return
  prefs: []
  type: TYPE_NORMAL
- en: '0'
  prefs: []
  type: TYPE_NORMAL
- en: ;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: else
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: db.Products.RemoveRange(products);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: int
  prefs: []
  type: TYPE_NORMAL
- en: affected = db.SaveChanges();
  prefs: []
  type: TYPE_NORMAL
- en: '**t.Commit();**'
  prefs: []
  type: TYPE_NORMAL
- en: return
  prefs: []
  type: TYPE_NORMAL
- en: affected;
  prefs: []
  type: TYPE_NORMAL
- en: '**}**'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code and view the result using SQL Server, as shown in the following
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: 'Transaction isolation level: ReadCommitted'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code and view the result using SQLite, as shown in the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: 'Transaction isolation level: Serializable'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Code First EF Core models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes you will not have an existing database. Instead, you define the EF
    Core model as Code First, and then EF Core can generate a matching database using
    create and drop APIs.
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice** : The create and drop APIs should only be used during development.
    Once you release the app, you do not want it to delete a production database!'
  prefs: []
  type: TYPE_NORMAL
- en: For example, we might need to create an application for managing students and
    courses for an academy. One student can sign up to attend multiple courses. One
    course can be attended by multiple students. This is an example of a many-to-many
    relationship between students and courses.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s model this example:'
  prefs: []
  type: TYPE_NORMAL
- en: Use your preferred code editor to add a new console app named `CoursesAndStudents`
    to the `Chapter10` solution/workspace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Visual Studio, set the startup project for the solution to the current selection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Visual Studio Code, select `CoursesAndStudents` as the active OmniSharp project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `CoursesAndStudents` project, add package references for the following
    packages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Microsoft.EntityFrameworkCore.Sqlite`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Microsoft.EntityFrameworkCore.SqlServer`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Microsoft.EntityFrameworkCore.Design`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build the `CoursesAndStudents` project to restore packages.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add classes named `Academy.cs` , `Student.cs` , and `Course.cs` .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Modify `Student.cs` , and note that it is a POCO (plain old CLR object) with
    no attributes decorating the class, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: namespace
  prefs: []
  type: TYPE_NORMAL
- en: CoursesAndStudents
  prefs: []
  type: TYPE_NORMAL
- en: ;
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: class
  prefs: []
  type: TYPE_NORMAL
- en: Student
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: int
  prefs: []
  type: TYPE_NORMAL
- en: StudentId { get
  prefs: []
  type: TYPE_NORMAL
- en: ; set
  prefs: []
  type: TYPE_NORMAL
- en: ; }
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: '? FirstName { get'
  prefs: []
  type: TYPE_NORMAL
- en: ; set
  prefs: []
  type: TYPE_NORMAL
- en: ; }
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: '? LastName { get'
  prefs: []
  type: TYPE_NORMAL
- en: ; set
  prefs: []
  type: TYPE_NORMAL
- en: ; }
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: ICollection<Course>? Courses { get
  prefs: []
  type: TYPE_NORMAL
- en: ; set
  prefs: []
  type: TYPE_NORMAL
- en: ; }
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify `Course.cs` , and note that we have decorated the `Title` property with
    some attributes to provide more information to the model, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: System.ComponentModel.DataAnnotations;
  prefs: []
  type: TYPE_NORMAL
- en: namespace
  prefs: []
  type: TYPE_NORMAL
- en: CoursesAndStudents
  prefs: []
  type: TYPE_NORMAL
- en: ;
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: class
  prefs: []
  type: TYPE_NORMAL
- en: Course
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: int
  prefs: []
  type: TYPE_NORMAL
- en: CourseId { get
  prefs: []
  type: TYPE_NORMAL
- en: ; set
  prefs: []
  type: TYPE_NORMAL
- en: ; }
  prefs: []
  type: TYPE_NORMAL
- en: '[Required'
  prefs: []
  type: TYPE_NORMAL
- en: ']'
  prefs: []
  type: TYPE_NORMAL
- en: '[StringLength(60)'
  prefs: []
  type: TYPE_NORMAL
- en: ']'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: '? Title { get'
  prefs: []
  type: TYPE_NORMAL
- en: ; set
  prefs: []
  type: TYPE_NORMAL
- en: ; }
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: ICollection<Student>? Students { get
  prefs: []
  type: TYPE_NORMAL
- en: ; set
  prefs: []
  type: TYPE_NORMAL
- en: ; }
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify `Academy.cs` , as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft.EntityFrameworkCore;
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: static
  prefs: []
  type: TYPE_NORMAL
- en: System.Console;
  prefs: []
  type: TYPE_NORMAL
- en: namespace
  prefs: []
  type: TYPE_NORMAL
- en: CoursesAndStudents
  prefs: []
  type: TYPE_NORMAL
- en: ;
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: class
  prefs: []
  type: TYPE_NORMAL
- en: Academy
  prefs: []
  type: TYPE_NORMAL
- en: ': DbContext'
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: DbSet<Student>? Students { get
  prefs: []
  type: TYPE_NORMAL
- en: ; set
  prefs: []
  type: TYPE_NORMAL
- en: ; }
  prefs: []
  type: TYPE_NORMAL
- en: public
  prefs: []
  type: TYPE_NORMAL
- en: DbSet<Course>? Courses { get
  prefs: []
  type: TYPE_NORMAL
- en: ; set
  prefs: []
  type: TYPE_NORMAL
- en: ; }
  prefs: []
  type: TYPE_NORMAL
- en: protected
  prefs: []
  type: TYPE_NORMAL
- en: override
  prefs: []
  type: TYPE_NORMAL
- en: void
  prefs: []
  type: TYPE_NORMAL
- en: OnConfiguring
  prefs: []
  type: TYPE_NORMAL
- en: (
  prefs: []
  type: TYPE_NORMAL
- en: DbContextOptionsBuilder optionsBuilder
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: string
  prefs: []
  type: TYPE_NORMAL
- en: path = Path.Combine(
  prefs: []
  type: TYPE_NORMAL
- en: Environment.CurrentDirectory, "Academy.db"
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine($"Using
  prefs: []
  type: TYPE_NORMAL
- en: '{path}'
  prefs: []
  type: TYPE_NORMAL
- en: database file."
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: optionsBuilder.UseSqlite($"Filename=
  prefs: []
  type: TYPE_NORMAL
- en: '{path}'
  prefs: []
  type: TYPE_NORMAL
- en: '"'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: // optionsBuilder.UseSqlServer(@"Data Source=.;Initial Catalog=Academy;Integrated
    Security=true;MultipleActiveResultSets=true;");
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: protected
  prefs: []
  type: TYPE_NORMAL
- en: override
  prefs: []
  type: TYPE_NORMAL
- en: void
  prefs: []
  type: TYPE_NORMAL
- en: OnModelCreating
  prefs: []
  type: TYPE_NORMAL
- en: (
  prefs: []
  type: TYPE_NORMAL
- en: ModelBuilder modelBuilder
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: // Fluent API validation rules
  prefs: []
  type: TYPE_NORMAL
- en: modelBuilder.Entity<Student>()
  prefs: []
  type: TYPE_NORMAL
- en: .Property(s => s.LastName).HasMaxLength(30
  prefs: []
  type: TYPE_NORMAL
- en: ).IsRequired();
  prefs: []
  type: TYPE_NORMAL
- en: // populate database with sample data
  prefs: []
  type: TYPE_NORMAL
- en: Student alice = new
  prefs: []
  type: TYPE_NORMAL
- en: () { StudentId = 1
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: FirstName = "Alice"
  prefs: []
  type: TYPE_NORMAL
- en: ', LastName = "Jones"'
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: Student bob = new
  prefs: []
  type: TYPE_NORMAL
- en: () { StudentId = 2
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: FirstName = "Bob"
  prefs: []
  type: TYPE_NORMAL
- en: ', LastName = "Smith"'
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: Student cecilia = new
  prefs: []
  type: TYPE_NORMAL
- en: () { StudentId = 3
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: FirstName = "Cecilia"
  prefs: []
  type: TYPE_NORMAL
- en: ', LastName = "Ramirez"'
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: Course csharp = new
  prefs: []
  type: TYPE_NORMAL
- en: ()
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: CourseId = 1
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: Title = "C# 10 and .NET 6"
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: Course webdev = new
  prefs: []
  type: TYPE_NORMAL
- en: ()
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: CourseId = 2
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: Title = "Web Development"
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: Course python = new
  prefs: []
  type: TYPE_NORMAL
- en: ()
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: CourseId = 3
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: Title = "Python for Beginners"
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: '};'
  prefs: []
  type: TYPE_NORMAL
- en: modelBuilder.Entity<Student>()
  prefs: []
  type: TYPE_NORMAL
- en: .HasData(alice, bob, cecilia);
  prefs: []
  type: TYPE_NORMAL
- en: modelBuilder.Entity<Course>()
  prefs: []
  type: TYPE_NORMAL
- en: .HasData(csharp, webdev, python);
  prefs: []
  type: TYPE_NORMAL
- en: modelBuilder.Entity<Course>()
  prefs: []
  type: TYPE_NORMAL
- en: .HasMany(c => c.Students)
  prefs: []
  type: TYPE_NORMAL
- en: .WithMany(s => s.Courses)
  prefs: []
  type: TYPE_NORMAL
- en: .UsingEntity(e => e.HasData(
  prefs: []
  type: TYPE_NORMAL
- en: // all students signed up for C# course
  prefs: []
  type: TYPE_NORMAL
- en: new
  prefs: []
  type: TYPE_NORMAL
- en: '{ CoursesCourseId = 1'
  prefs: []
  type: TYPE_NORMAL
- en: ', StudentsStudentId = 1'
  prefs: []
  type: TYPE_NORMAL
- en: '},'
  prefs: []
  type: TYPE_NORMAL
- en: new
  prefs: []
  type: TYPE_NORMAL
- en: '{ CoursesCourseId = 1'
  prefs: []
  type: TYPE_NORMAL
- en: ', StudentsStudentId = 2'
  prefs: []
  type: TYPE_NORMAL
- en: '},'
  prefs: []
  type: TYPE_NORMAL
- en: new
  prefs: []
  type: TYPE_NORMAL
- en: '{ CoursesCourseId = 1'
  prefs: []
  type: TYPE_NORMAL
- en: ', StudentsStudentId = 3'
  prefs: []
  type: TYPE_NORMAL
- en: '},'
  prefs: []
  type: TYPE_NORMAL
- en: // only Bob signed up for Web Dev
  prefs: []
  type: TYPE_NORMAL
- en: new
  prefs: []
  type: TYPE_NORMAL
- en: '{ CoursesCourseId = 2'
  prefs: []
  type: TYPE_NORMAL
- en: ', StudentsStudentId = 2'
  prefs: []
  type: TYPE_NORMAL
- en: '},'
  prefs: []
  type: TYPE_NORMAL
- en: // only Cecilia signed up for Python
  prefs: []
  type: TYPE_NORMAL
- en: new
  prefs: []
  type: TYPE_NORMAL
- en: '{ CoursesCourseId = 3'
  prefs: []
  type: TYPE_NORMAL
- en: ', StudentsStudentId = 3'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: ));
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice** : Use an anonymous type to supply data for the intermediate
    table in a many-to-many relationship. The property names follow the naming convention
    `NavigationPropertyNamePropertyName` , for example, `Courses` is the navigation
    property name and `CourseId` is the property name so `CoursesCourseId` will be
    the property name of the anonymous type.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs` , at the top of the file, import the namespace for EF Core
    and working with tasks, and statically import `Console` , as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft.EntityFrameworkCore; // for GenerateCreateScript()
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: CoursesAndStudents; // Academy
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: static
  prefs: []
  type: TYPE_NORMAL
- en: System.Console;
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs` , add statements to create an instance of the `Academy` database
    context and use it to delete the database if it exists, create the database from
    the model and output the SQL script it uses, and then enumerate the students and
    their courses, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: using
  prefs: []
  type: TYPE_NORMAL
- en: (Academy a = new
  prefs: []
  type: TYPE_NORMAL
- en: ())
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: bool
  prefs: []
  type: TYPE_NORMAL
- en: deleted = await
  prefs: []
  type: TYPE_NORMAL
- en: a.Database.EnsureDeletedAsync();
  prefs: []
  type: TYPE_NORMAL
- en: 'WriteLine($"Database deleted:'
  prefs: []
  type: TYPE_NORMAL
- en: '{deleted}'
  prefs: []
  type: TYPE_NORMAL
- en: '"'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: bool
  prefs: []
  type: TYPE_NORMAL
- en: created = await
  prefs: []
  type: TYPE_NORMAL
- en: a.Database.EnsureCreatedAsync();
  prefs: []
  type: TYPE_NORMAL
- en: 'WriteLine($"Database created:'
  prefs: []
  type: TYPE_NORMAL
- en: '{created}'
  prefs: []
  type: TYPE_NORMAL
- en: '"'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("SQL script used to create database:"
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine(a.Database.GenerateCreateScript());
  prefs: []
  type: TYPE_NORMAL
- en: foreach
  prefs: []
  type: TYPE_NORMAL
- en: (Student s in
  prefs: []
  type: TYPE_NORMAL
- en: a.Students.Include(s => s.Courses))
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine("{0} {1} attends the following {2} courses:"
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: s.FirstName, s.LastName, s.Courses.Count);
  prefs: []
  type: TYPE_NORMAL
- en: foreach
  prefs: []
  type: TYPE_NORMAL
- en: (Course c in
  prefs: []
  type: TYPE_NORMAL
- en: s.Courses)
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: WriteLine($"
  prefs: []
  type: TYPE_NORMAL
- en: '{c.Title}'
  prefs: []
  type: TYPE_NORMAL
- en: '"'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code, and note that the first time you run the code it will not need
    to delete the database because it does not exist yet, as shown in the following
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: Using C:\Code\Chapter10\CoursesAndStudents\bin\Debug\net6.0\Academy.db database
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Database deleted: False'
  prefs: []
  type: TYPE_NORMAL
- en: 'Database created: True'
  prefs: []
  type: TYPE_NORMAL
- en: 'SQL script used to create database:'
  prefs: []
  type: TYPE_NORMAL
- en: CREATE TABLE "Courses" (
  prefs: []
  type: TYPE_NORMAL
- en: '"CourseId" INTEGER NOT NULL CONSTRAINT "PK_Courses" PRIMARY KEY AUTOINCREMENT,'
  prefs: []
  type: TYPE_NORMAL
- en: '"Title" TEXT NOT NULL'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: CREATE TABLE "Students" (
  prefs: []
  type: TYPE_NORMAL
- en: '"StudentId" INTEGER NOT NULL CONSTRAINT "PK_Students" PRIMARY KEY AUTOINCREMENT,'
  prefs: []
  type: TYPE_NORMAL
- en: '"FirstName" TEXT NULL,'
  prefs: []
  type: TYPE_NORMAL
- en: '"LastName" TEXT NOT NULL'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: CREATE TABLE "CourseStudent" (
  prefs: []
  type: TYPE_NORMAL
- en: '"CoursesCourseId" INTEGER NOT NULL,'
  prefs: []
  type: TYPE_NORMAL
- en: '"StudentsStudentId" INTEGER NOT NULL,'
  prefs: []
  type: TYPE_NORMAL
- en: CONSTRAINT "PK_CourseStudent" PRIMARY KEY ("CoursesCourseId", "StudentsStudentId"),
  prefs: []
  type: TYPE_NORMAL
- en: CONSTRAINT "FK_CourseStudent_Courses_CoursesCourseId" FOREIGN KEY ("CoursesCourseId")
    REFERENCES "Courses" ("CourseId") ON DELETE CASCADE,
  prefs: []
  type: TYPE_NORMAL
- en: CONSTRAINT "FK_CourseStudent_Students_StudentsStudentId" FOREIGN KEY ("StudentsStudentId")
    REFERENCES "Students" ("StudentId") ON DELETE CASCADE
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: INSERT INTO "Courses" ("CourseId", "Title")
  prefs: []
  type: TYPE_NORMAL
- en: VALUES (1, 'C# 10 and .NET 6');
  prefs: []
  type: TYPE_NORMAL
- en: INSERT INTO "Courses" ("CourseId", "Title")
  prefs: []
  type: TYPE_NORMAL
- en: VALUES (2, 'Web Development');
  prefs: []
  type: TYPE_NORMAL
- en: INSERT INTO "Courses" ("CourseId", "Title")
  prefs: []
  type: TYPE_NORMAL
- en: VALUES (3, 'Python for Beginners');
  prefs: []
  type: TYPE_NORMAL
- en: INSERT INTO "Students" ("StudentId", "FirstName", "LastName")
  prefs: []
  type: TYPE_NORMAL
- en: VALUES (1, 'Alice', 'Jones');
  prefs: []
  type: TYPE_NORMAL
- en: INSERT INTO "Students" ("StudentId", "FirstName", "LastName")
  prefs: []
  type: TYPE_NORMAL
- en: VALUES (2, 'Bob', 'Smith');
  prefs: []
  type: TYPE_NORMAL
- en: INSERT INTO "Students" ("StudentId", "FirstName", "LastName")
  prefs: []
  type: TYPE_NORMAL
- en: VALUES (3, 'Cecilia', 'Ramirez');
  prefs: []
  type: TYPE_NORMAL
- en: INSERT INTO "CourseStudent" ("CoursesCourseId", "StudentsStudentId")
  prefs: []
  type: TYPE_NORMAL
- en: VALUES (1, 1);
  prefs: []
  type: TYPE_NORMAL
- en: INSERT INTO "CourseStudent" ("CoursesCourseId", "StudentsStudentId")
  prefs: []
  type: TYPE_NORMAL
- en: VALUES (1, 2);
  prefs: []
  type: TYPE_NORMAL
- en: INSERT INTO "CourseStudent" ("CoursesCourseId", "StudentsStudentId")
  prefs: []
  type: TYPE_NORMAL
- en: VALUES (2, 2);
  prefs: []
  type: TYPE_NORMAL
- en: INSERT INTO "CourseStudent" ("CoursesCourseId", "StudentsStudentId")
  prefs: []
  type: TYPE_NORMAL
- en: VALUES (1, 3);
  prefs: []
  type: TYPE_NORMAL
- en: INSERT INTO "CourseStudent" ("CoursesCourseId", "StudentsStudentId")
  prefs: []
  type: TYPE_NORMAL
- en: VALUES (3, 3);
  prefs: []
  type: TYPE_NORMAL
- en: CREATE INDEX "IX_CourseStudent_StudentsStudentId" ON "CourseStudent" ("StudentsStudentId");
  prefs: []
  type: TYPE_NORMAL
- en: 'Alice Jones attends the following 1 course(s):'
  prefs: []
  type: TYPE_NORMAL
- en: C#
  prefs: []
  type: TYPE_NORMAL
- en: 10 and .NET 6
  prefs: []
  type: TYPE_NORMAL
- en: 'Bob Smith attends the following 2 course(s):'
  prefs: []
  type: TYPE_NORMAL
- en: C#
  prefs: []
  type: TYPE_NORMAL
- en: 10 and .NET 6
  prefs: []
  type: TYPE_NORMAL
- en: Web Development
  prefs: []
  type: TYPE_NORMAL
- en: 'Cecilia Ramirez attends the following 2 course(s):'
  prefs: []
  type: TYPE_NORMAL
- en: C#
  prefs: []
  type: TYPE_NORMAL
- en: 10 and .NET 6
  prefs: []
  type: TYPE_NORMAL
- en: Python for Beginners
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Title` column is `NOT NULL` because the model was decorated with `[Required]`
    .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `LastName` column is `NOT NULL` because the model used `IsRequired()` .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An intermediate table named `CourseStudent` was created to hold information
    about which students attend which courses.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use Visual Studio Server Explorer or SQLiteStudio to connect to the `Academy`
    database and view the tables, as shown in *Figure 10.6* :![](img/Image00094.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 10.6: Viewing the Academy database in SQL Server using Visual Studio
    2022 Server Explorer'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding migrations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After publishing a project that uses a database, it is likely that you will
    later need to change your entity data model and therefore the database structure.
    At that point, you should not use the `Ensure` methods. Instead, you need to use
    a system that allows you to incrementally update the database schema while preserving
    any existing data in the database. EF Core migrations are that system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Migrations get complex fast, so are beyond the scope of this book. You can
    read about them at the following link: [https://docs.microsoft.com/en-us/ef/core/managing-schemas/migrations/](https://docs.microsoft.com/en-us/ef/core/managing-schemas/migrations/)'
  prefs: []
  type: TYPE_NORMAL
- en: Practicing and exploring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Test your knowledge and understanding by answering some questions, get some
    hands-on practice, and explore this chapter's topics with deeper research.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 10.1 – Test your knowledge
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Answer the following questions:'
  prefs: []
  type: TYPE_NORMAL
- en: What type would you use for the property that represents a table, for example,
    the `Products` property of a database context?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What type would you use for the property that represents a one-to-many relationship,
    for example, the `Products` property of a `Category` entity?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the EF Core convention for primary keys?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When might you use an annotation attribute in an entity class?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why might you choose the Fluent API in preference to annotation attributes?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does a transaction isolation level of `Serializable` mean?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does the `DbContext.SaveChanges()` method return?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between eager loading and explicit loading?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How should you define an EF Core entity class to match the following table?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '```cs'
  prefs: []
  type: TYPE_NORMAL
- en: CREATE
  prefs: []
  type: TYPE_NORMAL
- en: TABLE
  prefs: []
  type: TYPE_NORMAL
- en: Employees(
  prefs: []
  type: TYPE_NORMAL
- en: EmpId INT
  prefs: []
  type: TYPE_NORMAL
- en: IDENTITY
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: FirstName NVARCHAR
  prefs: []
  type: TYPE_NORMAL
- en: (40
  prefs: []
  type: TYPE_NORMAL
- en: ) NOT
  prefs: []
  type: TYPE_NORMAL
- en: 'NULL'
  prefs: []
  type: TYPE_NORMAL
- en: ','
  prefs: []
  type: TYPE_NORMAL
- en: Salary MONEY
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: What benefit do you get from declaring entity navigation properties as `virtual`
    ?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Exercise 10.2 – Practice exporting data using different serialization formats
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the `Chapter10` solution/workspace, create a console application named `Exercise02`
    that queries the Northwind database for all the categories and products, and then
    serializes the data using at least three formats of serialization available to
    .NET. Which format of serialization uses the least number of bytes?
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 10.3 – Explore topics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the links on the following page to learn more detail about the topics covered
    in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/markjprice/cs10dotnet6/blob/main/book-links.md#chapter-10---working-with-data-using-entity-framework-core](https://github.com/markjprice/cs10dotnet6/blob/main/book-links.md#chapter-10---working-with-data-using-entity-framework-core)'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 10.4 – Explore NoSQL databases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This chapter focused on RDBMSs such as SQL Server and SQLite. If you wish to
    learn more about NoSQL databases, such as Cosmos DB and MongoDB, and how to use
    them with EF Core, then I recommend the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Welcome to Azure Cosmos DB** : [https://docs.microsoft.com/en-us/azure/cosmos-db/introduction](https://docs.microsoft.com/en-us/azure/cosmos-db/introduction)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use NoSQL databases as a persistence infrastructure** : [https://docs.microsoft.com/en-us/dotnet/standard/microservices-architecture/microservice-ddd-cqrs-patterns/nosql-database-persistence-infrastructure](https://docs.microsoft.com/en-us/dotnet/standard/microservices-architecture/microservice-ddd-cqrs-patterns/nosql-database-persistence-infrastructure)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Document Database Providers for Entity Framework Core** : [https://github.com/BlueshiftSoftware/EntityFrameworkCore](https://github.com/BlueshiftSoftware/EntityFrameworkCore)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to connect to an existing database, how to
    execute a simple LINQ query and process the results, how to use filtered includes,
    how to add, modify, and delete data, and how to build entity data models for an
    existing database, such as Northwind. You also learned how to define a Code First
    model and use it to create a new database and populate it with data.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn how to write more advanced LINQ queries
    to select, filter, sort, join, and group.
  prefs: []
  type: TYPE_NORMAL
