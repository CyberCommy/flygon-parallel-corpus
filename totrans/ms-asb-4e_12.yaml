- en: '*Chapter 10*: Extending Ansible'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It must be said that **Ansible** takes the *kitchen sink* approach to functionality
    and tries to provide, out of the box, every piece of functionality you might ever
    need. With the `ansible-core` package and its associated collections, there are
    almost 6,000 modules available for use within Ansible at the time of writing –
    compare that to the (roughly) 800 that were included when the second edition of
    this book was published! In addition to these, there is a rich plugin and filter
    architecture with numerous callback plugins, lookup plugins, filter plugins, and
    dynamic inventory plugins included. Now, collections provide a whole new vector
    through which new functionality can be provided.
  prefs: []
  type: TYPE_NORMAL
- en: Despite this, there will always be cases where Ansible doesn't quite perform
    the tasks required, especially in large and complex environments, or ones where
    bespoke in-house systems have been developed. Luckily, the design of Ansible,
    coupled with its open source nature, makes it easy for anyone to extend it by
    developing features. The advent of collections with Ansible 3.0 has meant it is
    easier than ever to extend functionality. However, in this chapter, we will focus
    on the specifics of contributing to the `ansible-core` package. If you wish to
    contribute by creating a collection, you can easily follow the steps provided
    in this chapter to develop the code you require (for example, creating a new module)
    and then package it as a collection, as we described in *Chapter 2*, *Migrating
    from Earlier Ansible Versions*. How you contribute is up to you and your target
    audience – if you feel your code will help everyone who uses Ansible, then you
    may wish to submit it to `ansible-core`; otherwise, it is probably best built
    into a collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will explore the following ways in which new capabilities can
    be added to Ansible:'
  prefs: []
  type: TYPE_NORMAL
- en: Developing modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing plugins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing dynamic inventory plugins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Contributing code to the Ansible project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To follow the examples presented in this chapter, you will need a Linux machine
    running **Ansible 4.3** or newer. Almost any flavor of Linux should do – for those
    interested in the specifics, all the code presented in this chapter was tested
    on **Ubuntu Server 20.04 LTS** unless stated otherwise and on Ansible 4.3\. The
    example code that accompanies this chapter can be downloaded from GitHub at [https://github.com/PacktPublishing/Mastering-Ansible-Fourth-Edition/tree/main/Chapter10](https://github.com/PacktPublishing/Mastering-Ansible-Fourth-Edition/tree/main/Chapter10).
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the code in action: [https://bit.ly/3DTKL35](https://bit.ly/3DTKL35).'
  prefs: []
  type: TYPE_NORMAL
- en: Developing modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Modules are the workhorse of Ansible. They provide just enough abstraction so
    that playbooks can be stated simply and clearly. There are over 100 modules and
    plugins maintained by the core Ansible development team and they are distributed
    as part of the `ansible-core` package, covering commands, files, package management,
    source control, system, utilities, and so on. In addition, there are nearly 6,000
    other modules maintained by community contributors that expand functionality in
    many of these categories and many others, such as public cloud providers, databases,
    networking, and so on, through collections. The real magic happens inside the
    module's code, which takes in the arguments that are passed to it and works to
    establish the desired outcome.
  prefs: []
  type: TYPE_NORMAL
- en: Modules in Ansible are the pieces of code that get transported to the remote
    host to be executed. They can be written in any language that the remote host
    can execute; however, Ansible provides some very useful shortcuts for writing
    modules in Python, and you will find that most are indeed written in Python.
  prefs: []
  type: TYPE_NORMAL
- en: The basic module construct
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A module exists to satisfy a need – the need to do a piece of work on a host.
    Modules usually, but not always, expect input, and will return some sort of output.
    Modules also strive to be idempotent, allowing the module to be run over and over
    again without it having a negative impact. In Ansible, the input is in the form
    of command-line arguments to the module, and the output is delivered as JSON to
    `STDOUT`.
  prefs: []
  type: TYPE_NORMAL
- en: Input is generally provided in the space-separated `key=value` syntax, and it's
    up to the module to deconstruct these into usable data. If you're using Python,
    there are convenience functions to manage this, and if you're using a different
    language, then it is up to your module code to fully process the input.
  prefs: []
  type: TYPE_NORMAL
- en: The output is JSON formatted. Convention dictates that in a successful scenario,
    the JSON output should have at least one key, changed, which is a Boolean, to
    indicate whether the module execution resulted in a change. Additional data can
    be returned as well, which may be useful for defining what changed or to provide
    important information back to the playbook for later use. Additionally, host facts
    can be returned in the JSON data to automatically create host variables based
    on the module execution results. We will look at this in more detail later, in
    the *Providing fact data* section.
  prefs: []
  type: TYPE_NORMAL
- en: Custom modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ansible provides an easy mechanism to utilize custom modules other than those
    that come with Ansible. As we learned in [*Chapter 1*](B17462_01_Final_JC_ePub.xhtml#_idTextAnchor015),
    *The System Architecture and Design of Ansible*, Ansible will search many locations
    to find a requested module. One such location, and indeed the first location,
    is the `library/` subdirectory of the path where the top-level playbook resides.
    This is where we will place our custom module so that we can use it in our example
    playbook, as our focus is on developing for the `ansible-core` package. However,
    as we have already stated, you can also distribute modules via collections, and
    [*Chapter 2*](B17462_02_Final_JC_ePub.xhtml#_idTextAnchor047), *Migrating from
    Earlier Ansible Versions*, described (with a practical example taken from this
    chapter) how to package up modules for distribution via a collection.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to this, modules can also be embedded within roles to deliver the
    added functionality that a role may depend upon. These modules are only available
    to the role that contains the module, or any other roles or tasks that are executed
    after the role containing the module. To deliver a module with a role, place the
    module in the `library/` subdirectory of the role's root. While this is still
    a viable route, it is expected that as Ansible releases of 3.0 and later become
    commonplace, you will distribute your modules via collections. A period of overlap
    is being provided to support the many Ansible 2.9 and earlier distributions that
    exist.
  prefs: []
  type: TYPE_NORMAL
- en: Example – simple module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To demonstrate the ease of writing Python-based modules, let''s create a simple
    module. The purpose of this module will be to remotely copy a source file to a
    destination file, a simple task that we can build up from. To start our module,
    we need to create the module file. For easy access to our new module, we''ll create
    the file in the `library/` subdirectory of the working directory we''ve already
    been using. We''ll call this module `remote_copy.py`, and to start it off, we''ll
    need to put in a shebang line to indicate that this module is to be executed with
    Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'For Python-based modules, the convention is to use `/usr/bin/python` as the
    listed executable. When executed on a remote system, the configured Python interpreter
    for the remote host is used to execute the module, so fret not if your Python
    code doesn''t exist in this path. Next, we''ll import a Python library we''ll
    use later in the module, called `shutil`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now, we're ready to create our `main` function. The `main` function is essentially
    the entry point to the module, where the arguments to the module will be defined
    and where the execution will start. When creating modules in Python, we can take
    some shortcuts in this `main` function to bypass a lot of boilerplate code and
    get straight to the argument definitions.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can do this by creating an `AnsibleModule` object and giving it an `argument_spec`
    dictionary for the arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In our module, we're providing two arguments. The first argument is `source`,
    which we'll use to define the source file for the copy. The second argument is
    `dest`, which is the destination for the copy. Both of these arguments are marked
    as required, which will raise an error when executed if one of the two is not
    provided. Both arguments are of the `string` type. The location of the `AnsibleModule`
    class has not been defined yet as that happens later in the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'With a module object at our disposal, we can now create the code that will
    do the actual work on the remote host. We''ll make use of `shutil.copy` and our
    provided arguments to accomplish this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The `shutil.copy` function expects a source and a destination, which we''ve
    provided by accessing `module.params`. The `module.params` dictionary holds all
    of the parameters for the module. Having completed the copy, we are now ready
    to return the results to Ansible. This is done via another `AnsibleModule` method,
    `exit_json`. This method expects a set of `key=value` arguments and will format
    it appropriately for a JSON return. Since we''re always performing a copy, we
    will always return a change for simplicity''s sake:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This line will exit the function, and thus the module. This function assumes
    a successful action and will exit the module with the appropriate return code
    for success: `0`. We''re not done with our module''s code, though; we still have
    to account for the `AnsibleModule` location. This is where a bit of magic happens,
    where we tell Ansible what other code to combine with our module to create a complete
    work that can be transported:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s all it takes! That one line gets us access to all of the basic `module_utils`,
    a decent set of helper functions and classes. There is one last thing we should
    put into our module: a couple of lines of code telling the interpreter to execute
    the `main()` function when the module file is executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, our module file is complete, which means we can test it with a playbook.
    We''ll call our playbook `simple_module.yaml` and store it in the same directory
    as the `library/` directory, where we''ve just written our module file. We''ll
    run the play on `localhost` for simplicity''s sake and use a couple of filenames
    in `/tmp` for the source and destination. We''ll also use a task to ensure that
    we have a source file to begin with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'As our new module is being run from a `library/` directory local to the playbook,
    it does not have a **fully qualified collection name** (**FQCN**), so we will
    reference it by its short name only in the playbook. To run this playbook, we''ll
    run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'If the `remote_copy` module file is written to the correct location, everything
    will work just fine, and the screen output will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.1 – Running a simple playbook to test our first custom Ansible
    module'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_10_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.1 – Running a simple playbook to test our first custom Ansible module
  prefs: []
  type: TYPE_NORMAL
- en: Our first task touches on the `/tmp/rcfoo` path to ensure that it exists, and
    then our second task makes use of `remote_copy` to copy `/tmp/rcfoo` to `/tmp/rcbar`.
    Both tasks are successful, resulting in a `changed` status each time.
  prefs: []
  type: TYPE_NORMAL
- en: Documenting a module
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: No module should be considered complete unless it contains documentation regarding
    how to operate it. Documentation for a module exists within the module itself,
    in special variables called `DOCUMENTATION`, `EXAMPLES`, and `RETURN`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `DOCUMENTATION` variable contains a specially formatted string describing
    the module''s name, the version of either `ansible-core` or the parent collection
    that it was added to, a short description of the module, a longer description,
    a description of the module arguments, the author and license information, additional
    requirements, and any extra notes that are useful to users of the module. Let''s
    add a `DOCUMENTATION` string to our module under the existing `import shutil`
    statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The format of the string is essentially YAML, with some top-level keys containing
    hash structures within it (the same as the `options` key). Each option has sub-elements
    to describe the option, indicate whether the option is required, list any aliases
    for the option, list static choices for the option, or indicate a default value
    for the option. With this string saved to the module, we can test our formatting
    to ensure that the documentation will render correctly. This is done via the `ansible-doc`
    tool, with an argument to indicate where to search for the modules. If we run
    it from the same place as our playbook, the command will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.2 – Using the ansible-doc tool to view our new module''s documentation'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_10_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.2 – Using the ansible-doc tool to view our new module's documentation
  prefs: []
  type: TYPE_NORMAL
- en: In this example, I've piped the output into `cat` to prevent the pager from
    hiding the execution line. Our documentation string appears to be formatted correctly
    and provides the user with important information regarding the usage of the module.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `EXAMPLES` string is used to provide one or more example uses of the module,
    snippets of the task code that you would use in a playbook. Let''s add an example
    task to demonstrate its usage. This variable definition traditionally goes after
    the `DOCUMENTATION` definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'With this variable defined, our `ansible-doc` output will now include the example,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.3 – Expanding our module documentation with an EXAMPLES section'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_10_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.3 – Expanding our module documentation with an EXAMPLES section
  prefs: []
  type: TYPE_NORMAL
- en: 'The last documentation variable, `RETURN`, is used to describe the return data
    from a module''s execution. Return data is often useful as a registered variable
    for later usage and having documentation of what return data to expect can aid
    playbook development. Our module doesn''t have any return data yet; so, before
    we can document any, we have to add return data. This can be done by modifying
    the `module.exit_json` line to add more information. Let''s add the `source` and
    `dest` data to the return output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Rerunning the playbook will show extra data being returned, as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.4 – Running our expanded module with return data added'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_10_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.4 – Running our expanded module with return data added
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking closely at the return data, we can see more data than we put in our
    module. This is a bit of helper functionality within Ansible; when a return dataset
    includes a `dest` variable, Ansible will gather more information about the destination
    file. The extra data that''s gathered is `gid` (group ID), `group` (group name),
    `mode` (permissions), `uid` (owner ID), `owner` (owner name), `size`, and `state`
    (file, link, or directory). We can document all of these return items in our `RETURN`
    variable, which is added after the `EXAMPLES` variable. Everything between the
    two sets of three single quotes (`''''''`) is returned – thus, this first part
    returns the file paths and ownership:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Continuing with this part of the module definition file, this section returns
    the details about the file''s size, state, and permissions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Each returned item is listed with a description, the cases when the item would
    be in the return data, the type of item it is, and a sample of the value. The
    `RETURN` string is parsed by `ansible-doc` but the return values are sorted into
    alphabetical order, wherein the previous version of this book, we saw that the
    values were printed in the order in which they are listed in the module itself.
    The following screenshot shows this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.5 – Adding return data documentation to our module'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_10_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.5 – Adding return data documentation to our module
  prefs: []
  type: TYPE_NORMAL
- en: In this way, we have built up a module that contains documentation that's incredibly
    useful for others if we are contributing it to the community, or even for ourselves
    when we come back to it after a while.
  prefs: []
  type: TYPE_NORMAL
- en: Providing fact data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Similar to data returned as part of a module, such as `exit`, a module can
    directly create facts for a host by returning data in a key named `ansible_facts`.
    Providing facts directly from a module eliminates the need to register the return
    of a task with a subsequent `set_fact` task. To demonstrate this usage, let''s
    modify our module to return the `source` and `dest` data as facts. Because these
    facts will become top-level host variables, we''ll want to use more descriptive
    fact names than `source` and `dest`. Replace the current `module.exit_json` line
    in our module with the code listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll also add a task to our playbook to use one of the facts in a `debug`
    statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, running the playbook will show the new return data, plus the use of the
    variable, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.6 – Adding facts to our custom module and viewing their values
    during playbook execution'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_10_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.6 – Adding facts to our custom module and viewing their values during
    playbook execution
  prefs: []
  type: TYPE_NORMAL
- en: 'If our module does not return facts (and our previous version of `remote_copy.py`
    didn''t), we will have to register the output and use `set_fact` to create the
    fact for us, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Although it is useful to be able to do this, when designing our modules, it
    is better to have the module define the facts required. If this is not done, then
    the previous register and the `set_fact` code would need to be repeated for every
    use of our module in a playbook!
  prefs: []
  type: TYPE_NORMAL
- en: Check mode
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since the early days of its existence, Ansible has supported **check mode**,
    a mode of operation that will pretend to make changes to a system without actually
    changing the system. Check mode is useful for testing whether a change will happen,
    or whether a system state has drifted since the last Ansible run. Check mode depends
    on modules to support it and return data, as if it had completed the change. Supporting
    check mode in our module requires two changes; the first is to indicate that the
    module supports check mode, while the second is to detect when check mode is active
    and return data before execution.
  prefs: []
  type: TYPE_NORMAL
- en: Supporting check mode
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To indicate that a module supports check mode, an argument has to be set when
    creating the module object. This can be done before or after the `argument_spec`
    variable is defined in the module object; here, we will do it after it has been
    defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: If you're modifying your existing code, don't forget to add the comma after
    the `argument_spec` dictionary definition, as shown in the preceding code.
  prefs: []
  type: TYPE_NORMAL
- en: Handling check mode
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Detecting when check mode is active is very easy. The module object will have
    a `check_mode` attribute, which will be set to a Boolean value of `true` when
    check mode is active. In our module, we want to detect whether check mode is active
    before performing the copy. We can simply move the copy action into an `if` statement
    to avoid copying when check mode is active. No further changes to the module are
    necessary beyond this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can run our playbook and add the `-C` argument to our execution. This
    argument engages check mode. We''ll also test to ensure that the playbook did
    not create and copy the files. The following screenshot shows this in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.7 – Adding check mode support to our Ansible module'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_10_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.7 – Adding check mode support to our Ansible module
  prefs: []
  type: TYPE_NORMAL
- en: Although the module's output looks as though it created and copied files, we
    can see that the files referenced did not exist before execution and still do
    not exist after execution, a clear indication that our simple module was run in
    check mode.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've looked at our simple example module, we'll explore how to extend
    the functionality of Ansible through another important item – plugins.
  prefs: []
  type: TYPE_NORMAL
- en: Developing plugins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Plugins are another way of extending or modifying the functionality of Ansible.
    While modules are executed as tasks, plugins are utilized in a variety of other
    places. Plugins are broken down into a few types, based on where they would plug
    into the Ansible execution. Ansible ships some plugins for each of these areas,
    and end users can create their own to extend the functionality of these specific
    areas.
  prefs: []
  type: TYPE_NORMAL
- en: Connection-type plugins
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Any time Ansible makes a connection to a host to perform a task, a connection
    plugin is used. Ansible ships with a few connection plugins, including `ssh`,
    `community.docker.docker`, `local`, and `winrm`. Additional connection mechanisms
    can be utilized by Ansible to connect to remote systems by creating a connection
    plugin, which may be useful if you must connect to some new type of system, such
    as a network switch, or perhaps your refrigerator someday. To create a new connection
    plugin, we would have to understand and work with an underlying communication
    protocol, which in itself could have a book devoted to it; as such, we won''t
    attempt to create one here. However, the easiest way to get started is to read
    through the existing plugins that ship with Ansible and pick one to modify as
    necessary. The existing plugins can be found in `plugins/connection/` wherever
    the Ansible Python libraries are installed on your system, such as `/usr/local/lib/python3.8/dist-packages/ansible/plugins/connection/`
    on my system. You can also view them on GitHub – for example, if you wanted to
    look up the files relevant to the `2.11.1` release of `ansible-core`, you could
    look here: [https://github.com/ansible/ansible/tree/v2.11.1/lib/ansible/plugins/connection](https://github.com/ansible/ansible/tree/v2.11.1/lib/ansible/plugins/connection).'
  prefs: []
  type: TYPE_NORMAL
- en: Shell plugins
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Much like connection plugins, Ansible makes use of **shell plugins** to execute
    things in a shell environment. Each shell has subtle differences that Ansible
    cares about to properly execute commands, redirect output, discover errors, and
    other such interactions. Ansible supports several shells, including `sh`, `ansible.posix.csh`,
    `ansible.posix.fish`, and `powershell`. We can add more shells by implementing
    a new shell plugin. You can view the code for them (for the `2.11.1` release of
    `ansible-core`) here: [https://github.com/ansible/ansible/tree/v2.11.1/lib/ansible/plugins/shell](https://github.com/ansible/ansible/tree/v2.11.1/lib/ansible/plugins/shell).'
  prefs: []
  type: TYPE_NORMAL
- en: Lookup plugins
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Lookup plugins** are how Ansible accesses outside data sources from the host
    system and implements language features, such as looping constructs (`loop` or
    `with_*`). A lookup plugin can be created to access data from an existing data
    store or to create a new looping mechanism. The existing lookup plugins can be
    found in `plugins/lookup/` or on GitHub here: [https://github.com/ansible/ansible/tree/v2.11.1/lib/ansible/plugins/lookup](https://github.com/ansible/ansible/tree/v2.11.1/lib/ansible/plugins/lookup).
    Lookup plugins can be added to introduce new ways of looping over content, or
    for looking up resources in external systems.'
  prefs: []
  type: TYPE_NORMAL
- en: Vars plugins
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Constructs to inject variable data exist in the form of **vars plugins**. Data
    such as `host_vars` and `group_vars` are implemented via plugins. While it's possible
    to create new variable plugins, most often, it is better to create a custom inventory
    source or a fact module instead.
  prefs: []
  type: TYPE_NORMAL
- en: Fact-caching plugins
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ansible can cache facts between playbook runs. Where facts are cached depends
    on the configured cache plugin that is used. Ansible includes plugins to cache
    facts in `memory` (they're not cached between runs as this is not persistent),
    `community.general.memcached`, `community.general.redis`, and `jsonfile`. Creating
    a **fact-caching plugin** can enable additional caching mechanisms.
  prefs: []
  type: TYPE_NORMAL
- en: Filter plugins
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While Jinja2 includes several filters, Ansible has made filters pluggable to
    extend the Jinja2 functionality. Ansible includes several filters that are useful
    for Ansible operations, and users of Ansible can add more. Existing plugins can
    be found in `plugins/filter/`.
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate the development of a filter plugin, we will create a simple filter
    plugin to do a silly thing to text strings. We will create a filter that will
    replace any occurrence of the words `the cloud` with the string `somebody else's
    computer`. We'll define our filter in a file within a new directory, `filter_plugins/`,
    in our existing working directory. The name of the file doesn't matter, as we'll
    define the name of the filter within the file; so, let's name our file `filter_plugins/sample_filter.py`.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to define the function that will perform the translation and
    provide the code to translate the strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''ll need to construct a `FilterModule` object and define our filter
    within it. This object is what Ansible will load, and Ansible expects there to
    be a `filters` function within the object that returns a set of filter names to
    functions within the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can use this filter in a playbook, which we''ll call `simple_filter.yaml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s run our playbook and see our filter in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.8 – Executing a playbook to test our new filter plugin'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_10_08.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.8 – Executing a playbook to test our new filter plugin
  prefs: []
  type: TYPE_NORMAL
- en: Our filter worked, and it turned the words `the cloud` into `somebody else's
    computer`. This is a silly example without any error handling, but it demonstrates
    our capability to extend Ansible and Jinja2's filter capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: Although the name of the file that contains a filter definition can be whatever
    the developer wants, a best practice is to name it after the filter itself so
    that it can easily be found in the future, potentially by other collaborators.
    This example did not follow this, to demonstrate that the filename is not attached
    to the filter name.
  prefs: []
  type: TYPE_NORMAL
- en: Callback plugins
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Callbacks** are places in Ansible execution that can be plugged into for
    added functionality. There are expected callback points that can be registered
    against to trigger custom actions at those points. Here is a list of possible
    points that can be used to trigger functionality at the time of writing:'
  prefs: []
  type: TYPE_NORMAL
- en: '`v2_on_any`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`v2_runner_on_failed`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`v2_runner_on_ok`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`v2_runner_on_skipped`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`v2_runner_on_unreachable`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`v2_runner_on_async_poll`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`v2_runner_on_async_ok`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`v2_runner_on_async_failed`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`v2_runner_on_start`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`v2_playbook_on_start`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`v2_playbook_on_notify`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`v2_playbook_on_no_hosts_matched`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`v2_playbook_on_no_hosts_remaining`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`v2_playbook_on_task_start`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`v2_playbook_on_cleanup_task_start`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`v2_playbook_on_handler_task_start`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`v2_playbook_on_vars_prompt`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`v2_playbook_on_import_for_host`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`v2_playbook_on_not_import_for_host`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`v2_playbook_on_play_start`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`v2_playbook_on_stats`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`v2_on_file_diff`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`v2_playbook_on_include`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`v2_runner_item_on_ok`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`v2_runner_item_on_failed`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`v2_runner_item_on_skipped`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`v2_runner_retry`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As an Ansible run reaches each of these states, any plugins that have code to
    run at these points will be executed. This provides the tremendous ability to
    extend Ansible without having to modify the base code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Callbacks can be utilized in a variety of ways: to change how things are displayed
    on the screen, to update a central status system of progress, to implement a global
    locking system, or nearly anything imaginable. It''s the most powerful way to
    extend the functionality of Ansible. However, you will note that the previously
    listed items do not appear on the official Ansible documentation website ([https://docs.ansible.com](https://docs.ansible.com)),
    nor are they listed by the `ansible-doc` command. A great place to go to look
    up these callbacks to learn more about them is the `plugins/callback/__init__.py`
    file, under your `ansible-core` installation directory. For example, on my system,
    where Ansible was installed with pip, the full path is `/usr/local/lib/python3.8/dist-packages/ansible/plugins/callback/__init__.py`
    (if you want to look this up on the internet, the file for the `2.11.1` release
    of `ansible-core` can be found here: [https://github.com/ansible/ansible/blob/v2.11.1/lib/ansible/plugins/callback/__init__.py](https://github.com/ansible/ansible/blob/v2.11.1/lib/ansible/plugins/callback/__init__.py)).'
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate our ability to develop a callback plugin, we''ll create a simple
    plugin that will print something silly on the screen when the playbook prints
    the summary of the play at the end:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we'll need to make a new directory to hold our callback. The location
    Ansible will look for is `callback_plugins/`. Unlike the `filter` plugin earlier,
    we do need to name our callback plugin file carefully, as it will also have to
    be reflected in an `ansible.cfg` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We''ll name ours `callback_plugins/shrug.py`. As Ansible versions greater than
    3.0 are being moved toward Python 3 support only (though Python 2.7 is supported
    still at the time of writing), your plugin code should be written for Python 3\.
    Start by adding the following Python 3 header to your plugin:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Next up, you will need to add a documentation block, much like we did in the
    *Developing modules* section of this chapter. In the previous edition of this
    book, there was no need to do this, but now, you will get a deprecation warning
    if you don''t, and your callback plugin may not work when `ansible-core` 2.14
    is released. Our documentation block will look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Most of the items in the documentation are self-explanatory, but the `extends_documentation_fragment`
    item is worth noting. This particular part of the documentation block is the piece
    that is required for compatibility with `ansible-core` 2.14, and as we are extending
    the `default_callback` plugin here, we need to tell Ansible that we are extending
    this piece of documentation.
  prefs: []
  type: TYPE_NORMAL
- en: With this complete, we'll need to create a `CallbackModule` class, subclassed
    from `CallbackModule`, defined in the `default` callback plugin found in `ansible.plugins.callback.default`,
    since we only need to change one aspect of the normal output.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Within this class, we will define variable values to indicate that it is a `2.0`
    version callback, that it is an `stdout` type of callback, and that it has the
    name `shrug`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Also, within this class, we must initialize it so that we can define one or
    more of the callback points listed earlier that we'd like to plug into to make
    something happen. In our example, we want to modify the display of the playbook
    summary that is produced at the end of the run, for which we will modify the `v2_playbook_on_stats`
    callback.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To round off our plugin, we must call the original callback module itself.
    Ansible now only supports one `stdout` plugin at a time, so if we don''t call
    the original plugin, we will find that the output from our plugin is the only
    output that''s produced – all the other information regarding the playbook run
    will be missing! The final code below the documentation block should look like
    this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'As this callback is `stdout_callback`, we''ll need to create an `ansible.cfg`
    file and, within it, indicate that the `shrug` `stdout` callback should be used.
    The `ansible.cfg` file can be found in `/etc/ansible/` or in the same directory
    as the playbook:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s all we have to write in our callback. Once it''s saved, we can rerun
    our previous playbook, which exercised our `sample_filter`, but this time, we''ll
    see something different on the screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.9 – Adding our shrug plugin to modify the playbook run output'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_10_09.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.9 – Adding our shrug plugin to modify the playbook run output
  prefs: []
  type: TYPE_NORMAL
- en: This is very silly, but it demonstrates the ability to plug into various points
    of a playbook execution. We chose to display a series of shrugs on screen, but
    we could have just as easily interacted with some internal audit and control system
    to record actions, or to reported progress to an IRC or Slack channel.
  prefs: []
  type: TYPE_NORMAL
- en: Action plugins
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Action plugins** exist to hook into the task construct without actually causing
    a module to be executed, or to execute code locally on the Ansible host before
    executing a module on the remote host. Several action plugins are included with
    Ansible and they can be found in `plugins/action/`. One such action plugin is
    the `template` plugin, which can be used in place of a `template` module. When
    a playbook author writes a `template` task, that task will call the `template`
    plugin to do the work. The plugin, among other things, will render the template
    locally before copying the content to the remote host. Because actions have to
    happen locally, the work is done by an action plugin. Another action plugin we
    should be familiar with is the `debug` plugin, which we''ve used heavily in this
    book to print content. Creating a custom action plugin is useful when we''re trying
    to accomplish both local work and remote work in the same task.'
  prefs: []
  type: TYPE_NORMAL
- en: Distributing plugins
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Much like distributing custom modules, there are standard places to store custom
    plugins alongside playbooks that expect to use plugins. The default locations
    for plugins are the locations that are shipped with the Ansible code install,
    subdirectories within `~/.ansible/plugins/`, and subdirectories of the project
    root (the place where the top-level playbook is stored). Plugins can be distributed
    within the same subdirectories of a role as well, as well as collections, as we
    covered in [*Chapter 2*](B17462_02_Final_JC_ePub.xhtml#_idTextAnchor047), *Migrating
    from Earlier Ansible Versions*. To utilize plugins from any other location, we
    need to define the location to find the plugin for the plugin type in an `ansible.cfg`
    file or reference the collection, as we demonstrated by loading our example filter
    module in [*Chapter 2*](B17462_02_Final_JC_ePub.xhtml#_idTextAnchor047), *Migrating
    from Earlier Ansible Versions*.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you''re distributing plugins inside the project root, each plugin type gets
    its own top-level directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '`action_plugins/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cache_plugins/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`callback_plugins/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`connection_plugins/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`shell_plugins/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lookup_plugins/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`vars_plugins/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`filter_plugins/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As with other Ansible constructs, the first plugin with a given name that's
    found will be used, and just as with modules, the paths relative to the project
    root are checked first, allowing a local override of an existing plugin. Simply
    place the filter file in the appropriate subdirectory, and it will be automatically
    used when referenced.
  prefs: []
  type: TYPE_NORMAL
- en: Developing dynamic inventory plugins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Inventory plugins** are bits of code that will create inventory data for
    an Ansible execution. In many environments, the simple `ini` file-style inventory
    source and variable structure are not sufficient for representing the actual infrastructure
    being managed. In such cases, a dynamic inventory source is desired, one that
    will discover the inventory and data at runtime at every execution of Ansible.
    A number of these dynamic sources ship with Ansible, primarily to operate Ansible
    with the infrastructure built into one cloud computing platform or another. A
    short, incomplete list of dynamic inventory plugins that ship with Ansible 4.3
    (there are now over 40) includes the following – note from the FQCNs that many
    of these that were once shipped as part of the Ansible 2.x releases are now being
    included as part of the wider set of collections that form Ansible 4.3:'
  prefs: []
  type: TYPE_NORMAL
- en: '`azure.azcollection.azure_rm`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`community.general.cobbler`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`community.digitalocean.digitalocean`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`community.docker.docker_containers`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`amazon.aws.aws_ec2`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`google.cloud.gcp_compute`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`community.libvirt.libvirt`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`community.general.linode`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kubernetes.core.openshift`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`openstack.cloud.openstack`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`community.vmware.vmware_vm_inventory`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`servicenow.servicenow.now`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An inventory plugin is essentially an executable script. Ansible calls the script
    with set arguments (`--list` or `--host <hostname>`) and expects JSON formatted
    output on `STDOUT`. When the `--list` argument is provided, Ansible expects a
    list of all the groups to be managed. Each group can list host membership, child
    group membership, and group variable data. When the script is called with the
    `--host <hostname>` argument, Ansible expects host-specific data to be returned
    (or an empty JSON dictionary).
  prefs: []
  type: TYPE_NORMAL
- en: Using a dynamic inventory source is easy. A source can be used directly by referring
    to it with the `-i` (`--inventory-file`) option to `ansible` and `ansible-playbook`,
    or by putting the plugin file inside the directory referred to by the inventory
    path in `ansible.cfg`.
  prefs: []
  type: TYPE_NORMAL
- en: Before creating an inventory plugin, we must understand the expected format
    for when `--list` or `--host` is used with our script.
  prefs: []
  type: TYPE_NORMAL
- en: Listing hosts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the `--list` argument is passed to an inventory script, Ansible expects
    the JSON output data to have a set of top-level keys. These keys are named for
    the groups in the inventory. Each group gets a key. The structure within a group
    key varies, depending on what data needs to be represented in the group. If a
    group just has hosts and no group-level variables, the data within the key can
    simply be a list of hostnames. If the group has variables or children (a group
    of groups), then the data needs to be a hash, which can have one or more keys
    named `hosts`, `vars`, or `children`. The `hosts` and `children` subkeys have
    list values, a list of the hosts that exist in the group, or a list of the child
    groups. The `vars` subkey has a hash value, where each variable's name and value
    is represented by a key and value.
  prefs: []
  type: TYPE_NORMAL
- en: Listing host variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the `--host <hostname>` argument is passed to an inventory script, Ansible
    expects the JSON output data to simply be a hash of the variables, where each
    variable name and value is represented by a key and a value. If there are no variables
    for a given host, an empty hash is expected.
  prefs: []
  type: TYPE_NORMAL
- en: Simple inventory plugin
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To demonstrate developing an inventory plugin, we''ll create one that simply
    prints some static inventory host data – it won''t be dynamic, but this is a great
    first step to understanding the basics and the output formats required. This is
    based on some of the inventories we have used throughout this book, so they may
    seem familiar in parts. We''ll write our inventory plugin to a file in the top
    level of our project root named `mastery-inventory.py` and make it executable.
    We''ll use Python for this file, to handle execution arguments and JSON formatting
    with ease, but remember that you can write inventory scripts in any language that
    you please, so long as they produce the required JSON output:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll need to add a shebang line to indicate that this script is to
    be executed with Python:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''ll need to import a couple of Python modules that we will need later
    in our plugin:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we''ll create a Python dictionary to hold all of our groups. Some of our
    groups just have hosts while others have variables or children. We''ll format
    each group accordingly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: To create our `failtest` group (you'll see this in action in the next chapter),
    which in our inventory file will be represented as `failer[01:10]`, we can use
    a Python list comprehension to produce the list for us, formatting the items in
    the list just the same as our `ini`-formatted inventory file. Every other group
    entry should be self-explanatory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Our original inventory also had an `all` group variable, which provided a default
    variable, `ansible_ssh_user`, to all groups (which groups could override), which
    we''ll define here and make use of later in the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to enter the host-specific variables in their own dictionary.
    Only one node in our original inventory had host-specific variables – we''ll also
    add a new host, `scsihost`, to develop our example further:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'With all our data defined, we can now move on to the code that will handle
    argument parsing. This can be done via the `argparse` module we imported earlier
    in the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'After parsing the arguments, we can deal with either the `--list` or `--host`
    actions. If a list is requested, we simply print a JSON representation of our
    inventory. This is where we''ll take the `allgroupvars` data into account; the
    default `ansible_ssh_user` for each group. We''ll loop through each group, create
    a copy of the `allgroupvars` data, update that data with any data that may already
    exist in the group, then replace the group''s variable data with the newly updated
    copy. Finally, we''ll print out the result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we''ll handle the `--host` action by building up a dictionary of all
    the variables that can be applied to the host that is passed to this script. We''ll
    do this using an approximation of the precedence order that''s used in Ansible
    when parsing an `ini` format inventory. This code is iterative, and the nested
    loops would not be efficient in a production environment, but for this example,
    it serves us well. The output is the JSON formatted variable data for the provided
    host, or an empty hash if there is no host-specific variable data for the provided
    host:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, our inventory is ready to be tested! We can execute it directly and pass
    the `--help` argument we get for free using `argparse`. This will show us the
    usage of our script based on the `argparse` data we provided earlier in the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.10 – Testing the built-in help function of our dynamic inventory
    script'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_10_10.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.10 – Testing the built-in help function of our dynamic inventory script
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: Don't forget to make the dynamic inventory script executable; for example, `chmod
    +x mastery-inventory.py`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we pass `--list`, we''ll get the output of all our groups, along with all
    the hosts in each group and all the associated inventory variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.11 – Displaying the JSON output produced by the --list parameter
    of our dynamic inventory script'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_10_11.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.11 – Displaying the JSON output produced by the --list parameter of
    our dynamic inventory script
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, if we run this Python script with the `--host` argument and a hostname
    we know is in the inventory, we''ll see the host variables for the hostname that
    was passed. If we pass a group name, nothing should be returned, as the script
    only returns data for valid individual hostnames:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.12 – Displaying the JSON output produced by the --list parameter
    of our dynamic inventory script'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_10_12.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.12 – Displaying the JSON output produced by the --list parameter of
    our dynamic inventory script
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we''re ready to use our inventory file with Ansible. Let''s make a new
    playbook (`inventory_test.yaml`) to display the hostname and the `ssh` username
    data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'There is one more thing we have to do before we can use our new inventory plugin.
    By default (and as a security feature), most of Ansible''s inventory plugins are
    disabled. To ensure our dynamic inventory script will run, open the applicable
    `ansible.cfg` file in an editor and look for the `enable_plugins` line in the
    `[inventory]` section. At a minimum, it should look like this (though you may
    choose to enable more plugins if you wish):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'To use our new inventory plugin with this playbook, we can simply refer to
    the plugin file with the `-i` argument. Because we are using the `all` hosts group
    in our playbook, we''ll also limit the run to a few groups to save screen space.
    We''ll also time the execution, which will become important in the next section,
    so run the following command to execute the playbook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The output from this run should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.13 – Running a test playbook against our dynamic inventory script'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_10_13.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.13 – Running a test playbook against our dynamic inventory script
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we get the hosts we expect, and we get the default `ssh` user
    for `master.example.name`. `backend.example.name` and `scsihost` each show their
    host-specific `ssh` usernames.
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing script performance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'With this inventory script, when Ansible starts, it will execute the script
    once with `--list` to gather the group data. Then, Ansible will execute the script
    again with `--host <hostname>` for each host it discovered in the first call.
    With our script, this takes very little time as there are very few hosts and our
    execution is very fast. However, in an environment with a large number of hosts
    or a plugin that takes a while to run, gathering the inventory data can be a lengthy
    process. Fortunately, there is an optimization that can be made in the return
    data from a `--list` call that will prevent Ansible from rerunning the script
    for every host. The host-specific data can be returned all at once inside the
    group data return, inside a top-level key named `_meta`, which has a subkey named
    `hostvars` that contains a hash of all the hosts that have host variables and
    the variable data itself. When Ansible encounters a `_meta` key in the `--list`
    return, it''ll skip the `--host` calls and assume that all of the host-specific
    data was already returned, potentially saving a significant amount of time! Let''s
    modify our inventory script to return host variables inside `_meta`, and then
    create an error condition inside the `--host` option to show that `--host` is
    not being called:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll add the `_meta` key to the inventory dictionary once all of `hostvars`
    has been built up using the same algorithm as before, and just before argument
    parsing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''ll change the `--host` handling to raise an exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Now, we'll rerun the `inventory_test.yaml` playbook using the same command as
    we did previously to ensure that we're still getting the right data:![Figure 10.14
    – Running our optimized dynamic inventory script
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](Images/B17462_10_14.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.14 – Running our optimized dynamic inventory script
  prefs: []
  type: TYPE_NORMAL
- en: 'Just to be sure, we''ll manually run the inventory plugin with the `--host`
    argument to show the exception:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.15 – Demonstrating that the --host parameter does not work on our
    newly optimized script'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_10_15.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.15 – Demonstrating that the --host parameter does not work on our
    newly optimized script
  prefs: []
  type: TYPE_NORMAL
- en: With this optimization, our simple playbook, which is using our inventory module,
    now runs a good few percent faster because of the gained efficiency in inventory
    parsing. This might not seem like much here, but when scaled up to a more complex
    inventory, this would be significant.
  prefs: []
  type: TYPE_NORMAL
- en: Contributing to the Ansible project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Not all modifications need to be for local site requirements. Ansible users
    will often identify an enhancement that could be made to the project that others
    would benefit from. These enhancements can be contributed via a collection, and
    in the new structure of Ansible that proceeds from version 3.0, this is likely
    to be the most suitable route for most people. In this case, you will be able
    to follow the guidance given in [*Chapter 2*](B17462_02_Final_JC_ePub.xhtml#_idTextAnchor047),
    *Migrating from Earlier Ansible Versions,* to build and release a collection.
    However, what if you develop the next killer plugin or filter that should be added
    to the `ansible-core` project itself? In this section, we'll look at how you can
    do this. Contributions could be in the form of updates to an existing built-in
    module or core Ansible code, updates to documentation, new filters or plugins,
    or simply testing proposed contributions from other community members.
  prefs: []
  type: TYPE_NORMAL
- en: Contribution submissions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Ansible project uses GitHub ([https://github.com](https://github.com))
    to manage code repositories, issues, and other aspects of the project. The Ansible
    organization ([https://github.com/ansible](https://github.com/ansible)) is where
    the code repositories can be found. The main repository is the `ansible` repository
    (which now houses the `ansible-core` code) and for legacy reasons, it is located
    here: [https://github.com/ansible/ansible](https://github.com/ansible/ansible).
    This is where the `ansible-core` code, the built-in modules, and the documentation
    can be found. This is the repository that should be forked to develop a contribution.'
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: The Ansible project uses a development branch named `devel` instead of the traditional
    name of `master`. Most contributions target the `devel` branch or a stable release
    branch.
  prefs: []
  type: TYPE_NORMAL
- en: The Ansible repository
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Ansible repository has several files and folders at its root. These files
    are mostly high-level documentation files, code licenses, or continuous integration
    test platform configurations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of the directories, a few are worth noting:'
  prefs: []
  type: TYPE_NORMAL
- en: '`bin`: Source for the various ansible core executables'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docs`: Source for the API documentation, the [https://docs.ansible.com](https://docs.ansible.com)
    website, and the main pages'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hacking`: Guides and utilities for hacking on the Ansible source'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lib/ansible`: The core Ansible source code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`test`: Unit and integration testing code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Contributions to Ansible will likely occur in one of those key folders.
  prefs: []
  type: TYPE_NORMAL
- en: Executing tests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before any submission can be accepted by Ansible, the change must pass tests.
    These tests fall into three categories: unit tests, integration tests, and code-style
    tests. Unit tests cover very narrow aspects of source code functions, while integration
    tests take a more holistic approach and ensure the desired functionality happens.
    Code-style tests examine the syntax used, as well as whitespace and other style
    aspects.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before any tests can be executed, the shell environment must be prepared to
    work with the Ansible code checkout. A shell environment file exists to set the
    required variables, which can be activated with this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Ensuring tests are passing before modifications are made can save a lot of debugging
    time later, as the `devel` branch is bleeding edge and there are possibilities
    that code that has been committed to this branch does not pass all tests.
  prefs: []
  type: TYPE_NORMAL
- en: Unit tests
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: All of the unit tests are located within the directory tree starting at `test/units`.
    These tests should all be self-contained and do not require access to external
    resources. Running the tests is as simple as executing `make tests` from the root
    of the Ansible source checkout. This will test much of the code base, including
    the module code.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: Executing the tests may require installing additional software. When using a
    Python virtualenv to manage Python software installations, it's best to create
    a new `venv` to use for testing Ansible – one that does not have Ansible installed
    in it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To target a specific set of tests to run, the `pytest` (sometimes accessed
    as `py.test`) utility can be called directly, with a path provided to a directory
    or a specific file to test. On Ubuntu Server 20.04, you can install this tool
    with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Assuming you have checked out the `ansible-core` repository code, you could
    run just the `parsing` unit tests with the following commands. Note that some
    of the tests require that you install additional Python modules and that Ansible
    runs under Python 3 now by default, so you should always ensure you are installing
    and working with Python 3-based modules and tools. The following commands may
    not be sufficient for running all tests, but they are sufficient for running the
    parsing tests and give you an idea of the kinds of things you need to do to prepare
    for running the included test suite:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should look as follows if all goes well, with any warnings and/or
    errors displayed, along with a summary at the end:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.16 – Using the pytest tool for Python 3 to run the parsing unit
    tests included with the ansible-core source code'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_10_16.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.16 – Using the pytest tool for Python 3 to run the parsing unit tests
    included with the ansible-core source code
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the `pytest-3` utility is running through the defined unit tests
    and will report any errors it finds, aiding you greatly in checking any code you
    might be planning to submit. Everything seems to be going well in the preceding
    screenshot!
  prefs: []
  type: TYPE_NORMAL
- en: Integration tests
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Ansible integration tests are tests designed to validate playbook functionality.
    Testing is executed by playbooks as well, making things a bit recursive. The tests
    are broken down into a few main categories:'
  prefs: []
  type: TYPE_NORMAL
- en: Non-destructive
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Destructive
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Legacy Cloud
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Windows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A more detailed explanation of these test categories can be found here: [https://docs.ansible.com/ansible/latest/dev_guide/testing_integration.html](https://docs.ansible.com/ansible/latest/dev_guide/testing_integration.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: Many of the integration tests require `ssh` to localhost to be functional. Be
    sure that `ssh` works, ideally without a password prompt. Remote hosts can be
    used by altering the inventory file included with specific integration tests that
    require them. For example, if you are running the `connection_ssh` integration
    tests, be sure to look in `test/integration/targets/connection_ssh/test_connection.inventory`
    and update it as required. It is left as an exercise for you to explore this directory
    tree and locate the appropriate inventory files that you might need to update.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with unit tests, individual integration tests can be executed by using the
    `ansible-test` utility located at `bin/ansible-test`. Many of the integration
    tests require external resources, such as computer cloud accounts, and again,
    you will need to explore the documentation and directory tree to establish what
    you need to configure to run these tests in your environment. Each directory in
    `test/integration/targets` is a target that can be tested individually. Let''s
    choose a simple example for testing ping functionality with the `ping` target.
    This can be done with the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Note that we have specifically set the Python environment to test against here.
    This is important as my Ubuntu Server 20.04 test machine has some Python 2.7 installed
    and Ansible has been installed and configured to use Python 3.8 (which is also
    present). If the `ansible-test` tool makes use of the Python 2.7 environment,
    it might find that modules are missing and the tests will fail, but not because
    of anything that's wrong with our code – rather because we have failed to set
    the environment up correctly.
  prefs: []
  type: TYPE_NORMAL
- en: When you run `ansible-test`, ensure you know which Python environment you are
    using and set it accordingly in the command. If you want to test against another
    Python version, you will need to ensure that all the prerequisite Python modules
    that Ansible depends upon (such as Jinja2) are installed under that Python environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'A successful test run should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.17 – Running the Ansible ping integration test against a Python
    3.8 environment'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_10_17.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.17 – Running the Ansible ping integration test against a Python 3.8
    environment
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that there is even a test in this suite that''s designed to fail – and
    that, in the end, we will see `ok=7` and `failed=0`, meaning all the tests passed.
    A large set of POSIX-compatible non-destructive integration tests run by continuous
    integration systems on proposed changes to Ansible can be executed with the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: To ensure a consistent and stable testing environment, these tests are run in
    a local Fedora 32 container. You will need to ensure that Docker is set up and
    accessible on your test host for this command to work.
  prefs: []
  type: TYPE_NORMAL
- en: Code-style tests
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The third category of Ansible tests is the code-style category. These tests
    examine the syntax used in the Python files, ensuring a cohesive look across the
    code base. The code style that''s enforced is defined by PEP8, a style guide for
    Python. More information is available here: [https://docs.ansible.com/ansible/latest/dev_guide/testing/sanity/pep8.html](https://docs.ansible.com/ansible/latest/dev_guide/testing/sanity/pep8.html).
    This style is enforced via the `pep8` sanity test target. For this test to run,
    you must have installed the `pycodestyle` module for Python 3\. So, your commands
    from the root of your Ansible source directory might be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'If there are no errors, this target does not output any text; however, the
    return code can be verified. An exit code of `0` means there were no errors, as
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.18 – A successful run of the pep8 Python code style test'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_10_18.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.18 – A successful run of the pep8 Python code style test
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: As you have seen already, additional Python modules might be required to run
    any of the Ansible tests – the method for installing them will vary from system
    to system, and the modules required will vary from test to test. These could typically
    be installed by using the `pip3` tool or local operating system packages, as we
    have done here.
  prefs: []
  type: TYPE_NORMAL
- en: 'If a Python file does have a `pep8` violation, the output will reflect the
    violation – for example, we''ll deliberately edit the code for the `ansible.builtin.file`
    module, which can be found in `lib/ansible/modules/file.py` under the source code
    root. We''ll introduce several deliberate errors such as blank lines with whitespace,
    and we''ll replace some of the all-important indentation spaces with tabs, then
    rerun the test just as we did previously. We won''t need to reinstall the Python
    module or set up the environment again; the output of this test will show us exactly
    where the errors exist, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.19 – Rerunning the pep8 sanity test with deliberate coding style
    errors introduced to the file module'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_10_19.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.19 – Rerunning the pep8 sanity test with deliberate coding style errors
    introduced to the file module
  prefs: []
  type: TYPE_NORMAL
- en: '`pep8` errors will indicate an error code, which can be looked up for detailed
    explanations and guidance, along with a location and a filename, and even a line
    and column number to help you rapidly locate and rectify the issue.'
  prefs: []
  type: TYPE_NORMAL
- en: Making a pull request
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once all the tests have passed, a submission can be made. The Ansible project
    uses GitHub pull requests to manage submissions. To create a pull request, your
    changes must be committed and pushed to GitHub. Developers use a fork of the Ansible
    repository under their account to push proposed changes.
  prefs: []
  type: TYPE_NORMAL
- en: Once pushed, a pull request can be opened using the GitHub website. This will
    create the pull request, which will start continuous integration tests and notify
    reviewers of a new submission. Further information about GitHub pull requests
    can be found at [https://docs.github.com/en/github/collaborating-with-pull-requests](https://docs.github.com/en/github/collaborating-with-pull-requests).
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the pull request is open, reviewers will comment on the pull request,
    either asking for more information, suggesting changes, or approving the change.
    For new module submissions, you are encouraged to go down the collections route,
    but if you wish to explore this further, there is a great deal of valuable information
    available to would-be developers here: [https://docs.ansible.com/ansible/latest/dev_guide/index.html](https://docs.ansible.com/ansible/latest/dev_guide/index.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Submissions that are found acceptable and merged will be made generally available
    in the next release of Ansible. That concludes our look at contributing code back
    to the Ansible project and this chapter on extending Ansible. Hopefully, this
    chapter has given you some ideas and inspiration on how to build on the excellent
    foundation that Ansible provides to solve your automation challenges.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ansible is a great tool; however, sometimes, it doesn't offer all the functionality
    you might desire. Not every bit of functionality is appropriate to submit to the
    `ansible-core` project, nor is it possible to provide bespoke integration with
    custom proprietary data sources, as these would be different in every case. As
    a result, there are many facilities within Ansible to extend its functionality.
    Creating and using custom modules is made easy by the shared module base code.
    Many different types of plugins can be created and used with Ansible to affect
    operations in a variety of ways. Inventory sources beyond those provided with
    the Ansible release collections can still be used with relative ease and efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you learned about developing modules and including them in
    your playbooks. You then learned about extending Ansible through plugins, and
    we went into specific details about creating dynamic inventory plugins. Finally,
    you learned how to contribute code back to the Ansible project to enhance the
    code for everyone in the community. In summary, you learned that, in all cases,
    there are mechanisms to provide modules, plugins, and inventory sources alongside
    the playbooks and roles that depend on the enhanced functionality, making it seamless
    to distribute. This enables an almost infinite amount of expansion or customization
    of Ansible to your requirements, and the ability to easily contribute to the wider
    community if desired.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 12*](B17462_12_Final_JC_ePub.xhtml#_idTextAnchor224), *Infrastructure
    Provisioning*, we will explore the use of Ansible in creating the infrastructure
    to be managed.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For Ansible releases after 3.0, you would almost always develop a new module
    and distribute it via which of the following?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) The `ansible-core` project.
  prefs: []
  type: TYPE_NORMAL
- en: b) Your collection.
  prefs: []
  type: TYPE_NORMAL
- en: c) An existing collection with overlapping functionality, with the project maintainer's
    approval.
  prefs: []
  type: TYPE_NORMAL
- en: d) A role.
  prefs: []
  type: TYPE_NORMAL
- en: e) b, c, and maybe d only
  prefs: []
  type: TYPE_NORMAL
- en: The easiest way to develop a custom module is to write it in what language?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) Bash
  prefs: []
  type: TYPE_NORMAL
- en: b) Perl
  prefs: []
  type: TYPE_NORMAL
- en: c) Python
  prefs: []
  type: TYPE_NORMAL
- en: d) C++
  prefs: []
  type: TYPE_NORMAL
- en: Providing facts from a custom module does what?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) Saves you from needing to register the output to a variable and then using
    `set_fact`.
  prefs: []
  type: TYPE_NORMAL
- en: b) Gives your code greater capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: c) Helps you debug your code.
  prefs: []
  type: TYPE_NORMAL
- en: d) Shows you how the module is running.
  prefs: []
  type: TYPE_NORMAL
- en: Callback plugins allow you to do what?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) Help you call other playbooks.
  prefs: []
  type: TYPE_NORMAL
- en: b) Easily alter the behavior of Ansible at key operational points without having
    to alter the `ansible-core` code.
  prefs: []
  type: TYPE_NORMAL
- en: c) Provide an efficient means of altering the code's state.
  prefs: []
  type: TYPE_NORMAL
- en: d) Help you to call back to your playbook during runtime.
  prefs: []
  type: TYPE_NORMAL
- en: To distribute plugins, where would you place them?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) In a specially named directory relevant to their function (for example, callback
    plugins would go in the `callback_plugins/` directory).
  prefs: []
  type: TYPE_NORMAL
- en: b) In the Ansible installation directory.
  prefs: []
  type: TYPE_NORMAL
- en: c) Under `~/.ansible/plugins`.
  prefs: []
  type: TYPE_NORMAL
- en: d) It doesn't matter where, provided you specify them in `ansible.cfg`.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic inventory plugins should be written in what language?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) Python.
  prefs: []
  type: TYPE_NORMAL
- en: b) Bash.
  prefs: []
  type: TYPE_NORMAL
- en: c) C++.
  prefs: []
  type: TYPE_NORMAL
- en: d) Any language, provided the output is returned in the correct JSON data structure.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic inventory plugins should parse which two command-line arguments?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) `--list` and `--hostname`
  prefs: []
  type: TYPE_NORMAL
- en: b) `--list` and `--host`
  prefs: []
  type: TYPE_NORMAL
- en: c) `--list-all` and `--hosts`
  prefs: []
  type: TYPE_NORMAL
- en: d) `--list` and `--server`
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic inventory performance can be improved by doing what?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) Returning all host-specific data under a `_meta` key when the `--list` parameter
    is passed.
  prefs: []
  type: TYPE_NORMAL
- en: b) Returning all host-specific data, regardless of which arguments are passed.
  prefs: []
  type: TYPE_NORMAL
- en: c) Caching the output of the script's run.
  prefs: []
  type: TYPE_NORMAL
- en: d) Compressing your output data to reduce transmission times.
  prefs: []
  type: TYPE_NORMAL
- en: If you wish to contribute code to the `ansible-core` project, you should submit
    it via which of the following methods?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) A ticket raised against the project detailing your changes
  prefs: []
  type: TYPE_NORMAL
- en: b) Submitting a support ticket to Red Hat
  prefs: []
  type: TYPE_NORMAL
- en: c) A GitHub pull request once your code is passing all included tests
  prefs: []
  type: TYPE_NORMAL
- en: d) Complaining loudly on Twitter
  prefs: []
  type: TYPE_NORMAL
- en: Which utility is used to launch and control most of the Ansible code tests?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) `test-runner`
  prefs: []
  type: TYPE_NORMAL
- en: b) `integration-test`
  prefs: []
  type: TYPE_NORMAL
- en: c) Jenkins
  prefs: []
  type: TYPE_NORMAL
- en: d) `ansible-test`
  prefs: []
  type: TYPE_NORMAL
