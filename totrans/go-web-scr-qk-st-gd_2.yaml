- en: The Request/Response Cycle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before you can build a web scraper, you must take a second and think about how
    the internet works. At its core, the internet is a network of computers connected
    together, discoverable through **Domain Lookup System** (**DNS**) servers. When
    you want to visit a website, your browser sends the website URL to a DNS server,
    the URL is translated into an IP address, and your browser then sends a request
    to the machine at that IP address. The machine, called a web server, receives
    and inspects the request, and makes a decision on what to send back to your browser.
    Your browser then parses the information sent by the server and displays content
    on your screen depending on the format of the data. The web server and browser
    are able to communicate because of the adherence to a global set of rules called
    the HTTP. In this chapter, you will learn some of the key points on the HTTP request
    and response cycle.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What do HTTP requests look like?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What do HTTP responses look like?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are HTTP status codes?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What do HTTP requests/responses look like in Go?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What do HTTP requests look like?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When a client (such as a browser) requests a web page from a server, it sends
    an HTTP request. The format for such a request defines an action, a resource,
    and the Version of the HTTP protocol. Some HTTP requests include extra information
    for the server to process, such as a query or specific metadata. Depending on
    the action, you also may be sending the server new information for the server
    to process.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP request methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are nine current HTTP request methods, which define a general action
    desired by the client. Each method carries a particular connotation as to how
    the server should process the request. The nine request methods are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GET`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`POST`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PUT`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DELETE`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HEAD`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CONNECT`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TRACE`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OPTIONS`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PATCH`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The most common request methods that you will need are `GET`, `POST`, and `PUT`. `GET`
    requests are used for retrieving information from a website. `POST` and `PUT`
    requests are for sending information, such as user login data, to a website. These
    types of requests are usually sent only when submitting some type of form data,
    which we will cover in later chapters in this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'In building a web scraper, the vast majority of the time you will be sending
    HTTP `GET` requests to a server in order to get a web page. The simplest example
    of a `GET` request for [http://example.com/index.html](http://example.com/index.html)
    looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The client sends this message to the server with the `GET` action to obtain
    the `index.html` resource using the `1.1` Version of the HTTP protocol. This first
    line of an HTTP request is called the request line and is the core of an HTTP
    request.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP headers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Below the request line are a series of key-value pairs that provide metadata
    describing how the request should be handled. These metadata fields are called
    HTTP headers. In our simple request, made earlier, we have a single HTTP header
    that defines the target host we are trying to reach. This information is not required
    by the HTTP protocol; however, it is almost always sent in order to provide clarification
    on who should be receiving the request.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you were to inspect the HTTP request sent by your web browser, you would
    see many more HTTP headers. The following is an example sent by a Google Chrome
    browser to the same [example.com](http://example.com) website:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The basics of the HTTP request are the same, however, your browser provides
    significantly more request headers, mostly related to how to handle cached HTML
    pages. We will discuss some of these headers in more detail in the following chapters.
  prefs: []
  type: TYPE_NORMAL
- en: The server reads the request and processes all of the headers to decide how
    to respond to your request. In the most basic scenario, the server will respond
    saying Your request is OK and deliver the contents of `index.html`.
  prefs: []
  type: TYPE_NORMAL
- en: Query parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For some HTTP requests, extra information needs to be provided by the client
    in order to refine the request. This is usually done in two different ways. For
    HTTP `GET` requests, there is a defined way to include extra information in a
    request using the URL. Placing a `?` at the end of a URL defines the end of the
    URL resource, and the next section defines query parameters. These parameters
    are key-value pairs defining the extra information sent to the server. The key
    value pairs are written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see this quite commonly when you are performing searches. As a hypothetical
    example, if you were on a site searching for shoes, you might encounter a paginated
    results page and the URL might look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the resource is `product_search`, which is followed by the query
    parameters for the `keyword` and the `page`. This way, you can collect the products
    from all pages by adjusting the query.
  prefs: []
  type: TYPE_NORMAL
- en: Query parameters are defined by the website. There are no standard parameters
    that all websites must have, so it will take some investigation on your part depending
    on the site you are scraping.
  prefs: []
  type: TYPE_NORMAL
- en: Request body
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Query parameters are typically only used on HTTP `GET` requests. For requests
    where you are sending data to the server, such as `POST` and `PUT` requests, you
    would send a request body that holds all of your extra information. Request bodies
    are placed after the HTTP headers in an HTTP request, with a one-line space between
    them. The following is a hypothetical `POST` request for logging into an imaginary
    website:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In this request, we are sending our `username` and `password` to `myprotectedsite.com/login`.
    The headers for this request must describe the request body so the server is able
    to process it. In this case, we declare that the request body be in the `x-www-form-urlencoded`
    format, which is the same format used for the query parameters in the *Query parameters *section.
    We could use alternative formats, such as `JSON` or `XML` or even plain text,
    but only if it is supported by the server. The `x-www-form-urlencoded` format
    is the most widely supported and is generally a safe bet. The second parameter
    we define in the header is the length of the request body in bytes. This allows
    the server to efficiently prepare for processing the data, or rejecting the request
    completely if it is too large.
  prefs: []
  type: TYPE_NORMAL
- en: The Go standard library has good support for building HTTP requests quite simply—if
    you are familiar with the structure, at least. We will revisit how this is done
    later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: What do HTTP responses look like?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When the server responds to your request, it will provide a status code, some
    response headers, and the content of the resource in most cases. Staying with
    our previous request for [http://www.example.com/index.html](http://www.example.com/index.html),
    you will be able to see what a typical response looks like, section by section.
  prefs: []
  type: TYPE_NORMAL
- en: Status line
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first line of an HTTP response is called the status line and typically
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: First, it tells you what Version of the HTTP protocol the server is using. This
    should always match the version sent by the client HTTP request. In this case,
    our server is using version `1.1`. The next portion is the HTTP status code. This
    is code used to indicate the status of the response. Most of the time, you should
    see a status code of 200, indicating that the request was successful and a response
    body will follow. This is not always the case, and we will look deeper into HTTP
    status codes in the next section. The OK is a human-readable description of the
    status code, which is only used for your own reference.
  prefs: []
  type: TYPE_NORMAL
- en: Response headers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'HTTP response headers follow the status line and look very similar to HTTP
    request headers. These also provide metadata specific to the response, much like
    request headers do. Here are the headers from our [example.com](http://example.com)
    response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In this response, you can see some headers describing the content of the page,
    how to cache it, and the size of the remaining data. This information is useful
    for processing the data after it has been received.
  prefs: []
  type: TYPE_NORMAL
- en: Response body
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The rest of the response is the actual web page that renders `index.html`.
    Your browser would take this and draw the text, images, and styling for the web
    page itself, but for the purpose of scraping, it is not necessary. An abbreviated
    version of the response body looks similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The majority of the time, you will be handling responses from a web server that
    has a status code of 200, meaning that the request was OK. However, from time
    to time, you will encounter other status codes that your web scraper should be
    aware of.
  prefs: []
  type: TYPE_NORMAL
- en: What are HTTP status codes?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: HTTP status codes are used to inform the HTTP client of the status of the HTTP
    request. In some cases, the HTTP server needs to inform the client that the request
    was not understood, or that extra actions need to be taken in order to get a full
    response. The HTTP status codes are divided into four separate ranges, each one
    covering a specific type of response.
  prefs: []
  type: TYPE_NORMAL
- en: 100–199 range
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: These codes are used to provide information to the HTTP client on how to deliver
    a request. These codes are usually processed by the HTTP client itself and will
    be handled before your web scraper needs to worry about them.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the client may prefer that requests be sent using the HTTP 2.0
    protocol and request the server to change. If the server can support HTTP 2.0,
    it will respond with a status code of 101, meaning switching protocols. A case
    like this would be handled by the client under the hood, so you need not to be
    concerned about it.
  prefs: []
  type: TYPE_NORMAL
- en: 200–299 range
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `200-299` range of status codes indicates that the request was successfully
    processed with no issues. The most important code to note here is a status code
    of 200\. This means you have a response body coming your way and everything was
    perfect!
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, you might be downloading chunks of a large file (think on the
    scale of gigabytes) where you are requesting ranges of bytes to download from
    the server. In this case, a successful response should be a 206, meaning the server
    is returning partial content from the original file.
  prefs: []
  type: TYPE_NORMAL
- en: Other codes in this range indicate that the request was successful but the server
    is processing information in the background, or there is no content at all. These
    are not typically seen in web scraping.
  prefs: []
  type: TYPE_NORMAL
- en: 300–399 range
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you encounter a status code in this range, it means that the request is understood
    but extra steps are necessary to get to the actual content. The most common cases
    you will run into here are for redirection.
  prefs: []
  type: TYPE_NORMAL
- en: 'The 301, 302, 307, and 308 status codes all indicate that the resource you
    are looking for can be found at another location. In the header for this response,
    the server should indicate where the final location in the response header is.
    For example, a 301 response might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The server includes a `Location` header telling the client where the location
    of the resource was moved to, and that the client should send the next request
    to that location. The content here can be ignored in most cases.
  prefs: []
  type: TYPE_NORMAL
- en: Other status codes in this range are related to the use of proxies and cached
    information, both of which we will discuss in future chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 400–499 range
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you encounter status codes in this range, you should be concerned. The
    `400` range indicates that there was something wrong with your request. There
    are many different issues that can trigger these responses, such as poor formatting,
    authentication issues, or unusual requests. Servers send these codes back to their
    clients to tell them that they will not fulfill the request because something
    looks sketchy.
  prefs: []
  type: TYPE_NORMAL
- en: One status code you may already be familiar with is 404 Not Found. This occurs
    when your request a resource that the server cannot seem to find. This could be
    due to a misspelling of the resource or because the page does not exist at all.
    Sometimes, websites update files on their servers and possibly forget to update
    the links in the web pages with their new locations. This can cause **broken links**,
    and it is especially common when a page links to an external website.
  prefs: []
  type: TYPE_NORMAL
- en: Other common status codes in this range that you may encounter are 401 Unauthorized
    and 403 Forbidden. In both cases, this means that you are trying to access pages
    that require proper authentication credentials. There are many different forms
    of authentication for the web, and this book will cover only the basics in the
    future chapters.
  prefs: []
  type: TYPE_NORMAL
- en: The last status code that I would like to highlight in this range is 429 Too
    Many Requests. Some web servers are configured with rate limits, meaning that
    you can only maintain a certain number of requests over a certain period of time.
    If you are surpassing this rate, then you are not only putting unreasonable stress
    on the web server, but you are also exposing your web scraper, which puts it at
    risk for being blacklisted. Following the proper web scraping etiquette is beneficial
    for both you and your target website.
  prefs: []
  type: TYPE_NORMAL
- en: 500–599 range
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Status codes in this range usually represent errors pertaining to the server
    itself. Although these errors are usually not your fault, you will still need
    to be aware of them and adapt to the situation.
  prefs: []
  type: TYPE_NORMAL
- en: The status codes 502 Bad Gateway and 503 Service Temporarily Unavailable indicate
    that the server was unable to produce the resource due to a problem within the
    server. This does not necessarily mean that the resource does not exist, or that
    you are not allowed to access it. When you encounter these codes, it is best to
    put the request aside and try again later. If you are seeing these codes often,
    you may want to stop all requests and allow the server to address its issues.
  prefs: []
  type: TYPE_NORMAL
- en: There are cases where something in the web server breaks for no particular reason.
    In this case, you will receive a status code of 500 Internal Server Error. These
    errors are generic and are often the cause of a crash in the server code. The
    same advice for retrying your request, or having your scraper back off, are also
    relevant in this case.
  prefs: []
  type: TYPE_NORMAL
- en: What do HTTP requests/responses look like in Go?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you are familiar with the basics of HTTP requests and responses, it's
    time to see what this looks like in Go. The standard library in Go provides a
    package named `net/http`, which contains all of the tools you will need to build
    a client that is capable of requesting pages from web servers and processing the
    responses with very little effort.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the example from the beginning of this chapter, where
    we were accessing the web page at [http://www.example.com/index.html](http://www.example.com/index.html).
    The underlying HTTP request instructs the web server at [example.com](http://example.com)
    to `GET` the `index.html` resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the Go `net/http` package, you would use the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The Go programming language allows for multiple variables to be returned from
    a single function. This is also how errors are typically thrown and handled.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is using the `net/http` package''s default HTTP client to request the
    `index.html` resource, which returns two objects: the HTTP response (`r`) and
    an error (`err`). In Go, errors are returned as values, instead of being thrown
    and caught by other code. If the `err` is equal to `nil`, then we know there were
    no issues communicating with the web server.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the response from the beginning of this chapter. If the request
    were successful, the server would return something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'All of this information is contained in the `r` variable, which is a `*http.Response` that
    was returned from the `http.Get()` function. Let''s take a look at the definition
    of what an `http.Response` object looks like in Go. The following `struct` is
    defined in the Go standard library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `http.Response` object contains all of the fields you need to process an
    HTTP response. Most notably, the `StatusCode`, `Header`, and `Body` would be useful
    in scraping. Let's put the request and response together in a simple example that
    saves the `index.html` file to your computer.
  prefs: []
  type: TYPE_NORMAL
- en: A simple request example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Inside the `$GOPATH/src` folder that you set up, create a folder called `simplerequest`.
    Inside `simplerequest`, create a file called `main.go`. Set the contents of `main.go`
    to be the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The example given here is a little verbose in order to show you the basics of
    Go programming. As you progress through the book, you will be introduced to tips
    and tricks to make your code more succinct.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can run this code from inside the `simplerequest` folder by typing following
    command inside of a terminal window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: If all goes well, you should not see messages printed, and there should be a
    new file called `index.html` containing the contents of the response body. You
    can even open the file with a web browser!
  prefs: []
  type: TYPE_NORMAL
- en: With these basics in mind, you should be on your way to creating a web scraper
    in Go that can create HTTP requests and read HTTP responses with just a few lines
    of code.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered the basic formats of HTTP requests and responses.
    We also saw how HTTP requests are made in Go, as well as how the `http.Response`
    struct relates to real HTTP responses. Finally, we created a small program that
    sent an HTTP response to [http://www.example.com/index.html](http://www.example.com/index.html) and
    processed the HTTP response. For the full HTTP specification, I encourage you
    to visit [https://www.w3.org/Protocols/](https://www.w3.org/Protocols/).
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](16487efd-3a75-4823-ad19-627a83752cd4.xhtml), *Web Scraping Etiquette*,
    we look at the best practices for being a good citizen of the web.
  prefs: []
  type: TYPE_NORMAL
