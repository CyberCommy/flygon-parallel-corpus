- en: Packaging and Running Applications as Docker Containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Docker reduces the logical view of your infrastructure to three core components:
    hosts, containers, and images. Hosts are servers that run containers, and each
    container is an isolated instance of an application. Containers are created from
    images, which are packaged applications. A Docker container image is conceptually
    very simple: it''s a single unit that contains a complete, self-contained application.
    The image format is very efficient, and the integration between the image and
    the container runtime is very smart, so mastering images is your first step to
    using Docker effectively.'
  prefs: []
  type: TYPE_NORMAL
- en: You've already seen some images in [Chapter 1](59b504fb-1012-4118-aa49-c5e0efce06d3.xhtml),
    *Getting Started with Docker on Windows**,* by running some basic containers to
    check your Docker installation was working correctly, but I didn't closely examine
    the image or how Docker used it. In this chapter, you'll get a thorough understanding
    of Docker images, learning how they're structured, understanding how Docker uses
    them, and looking at how to package your own applications as Docker images.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing to understand is the difference between an image and a container,
    which you can see very clearly by running different types of container from the
    same image.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you''ll learn more about the basics of Docker, including:'
  prefs: []
  type: TYPE_NORMAL
- en: Running containers from images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building images from Dockerfiles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Packaging your own applications as Docker images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with data in images and containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Packaging legacy ASP.NET web apps as Docker images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need Docker running on Windows 10 with update 18.09, or Windows Server
    2019 to follow along with the examples. The code for this chapter is available
    at [https://github.com/sixeyed/docker-on-windows/tree/second-edition/ch02](https://github.com/sixeyed/docker-on-windows/tree/second-edition/ch02).
  prefs: []
  type: TYPE_NORMAL
- en: Running a container from an image
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `docker container run` command creates a container from an image and starts
    the application inside the container. It's actually equivalent to running two
    separate commands, `docker container create` and `docker container start`, which
    shows that containers can have different states. You can create a container without
    starting it, and you can pause, stop, and restart running containers. Containers
    can be in different states, and you can use them in different ways.
  prefs: []
  type: TYPE_NORMAL
- en: Doing one thing with a task container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `dockeronwindows/ch02-powershell-env:2e` image is an example of a packaged
    application which is meant to run in a container and perform a single task. The
    image is based on Microsoft Windows Server Core and is set up to run a simple
    PowerShell script when it starts, printing details about the current environment.
    Let''s see what happens when I run a container directly from the image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Without any options, the container runs a PowerShell script which is built into
    the image, and the script prints out some basic information about the operating
    system environment. I call this a **task container** because the container performs
    one task and then exits.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run `docker container ls`, which lists all the active containers, you
    won''t see this container. But if you run `docker container ls --all`, which shows
    containers in all states, you''ll see it in the `Exited` status:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Task containers are very useful in automating repetitive tasks, like running
    scripts to set up an environment, backing up data, or collecting log files. Your
    container image packages the script to run, along with the exact version of all
    the requirements that the script needs, so anyone with Docker installed can run
    the script without having to install pre-requisites.
  prefs: []
  type: TYPE_NORMAL
- en: This is especially useful for PowerShell, where scripts can be dependent on
    several PowerShell modules. The modules may be publicly available, but your script
    can be dependent on specific versions. Instead of sharing a script that requires
    users to install the correct version of many different modules, you build an image
    that has the modules already installed. Then you only need Docker to run the script
    task.
  prefs: []
  type: TYPE_NORMAL
- en: Images are self-contained units, but you can also use them as a template. An
    image may be configured to do one thing, but you can run containers from an image
    in different ways to do different things.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to an interactive container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An **interactive container** is one that has an open connection to the Docker
    command line, so you work with the container as if you were connected to a remote
    machine. You can run an interactive container from the same Windows Server Core
    image by specifying the interactive options and a command to run when the container
    starts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `--interactive` option runs an interactive container, and the `--tty` flag
    attaches a terminal connection to the container. The `powershell` statement after
    the name of the container image is the command to run when the container starts.
    By specifying a command you replace the startup command that's been set up in
    the image. In this case, I start a PowerShell session and that runs instead of
    the configured command, so the environment printout script doesn't run.
  prefs: []
  type: TYPE_NORMAL
- en: An interactive container keeps running as long as the command inside is running.
    While you're connected to PowerShell, running `docker container ls` in another
    window on the host will show that the container is still running. When you type
    `exit` in the container, the PowerShell session ends, so there's no process running
    and the container exits too.
  prefs: []
  type: TYPE_NORMAL
- en: Interactive containers are useful when you're building your own container images,
    they let you can work through the steps interactively first and verify that everything
    will work as you expect. They're good exploratory tools too. You can pull someone
    else's image from a Docker registry and explore the contents before you run the
    application.
  prefs: []
  type: TYPE_NORMAL
- en: You'll see as you read through this book that Docker can host complex distributed
    systems in a virtual network, with each component running in its own container.
    If you want to examine parts of the system, you can run an interactive container
    inside the network and check on individual components, without having to make
    the parts publicly accessible.
  prefs: []
  type: TYPE_NORMAL
- en: Keeping a process running in a background container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last type of container is the one that you'll use most in production, the
    background container, which keeps a long-running process running in the background.
    It's a container that behaves like a Windows service. In Docker terminology, it's
    called a **detached container**, and it's the Docker Engine that keeps it running
    in the background. Inside the container, the process runs in the foreground. The
    process might be a web server or a console application polling a message queue
    for work, but as long as the process keeps running, Docker will keep the container
    alive.
  prefs: []
  type: TYPE_NORMAL
- en: 'I can run a background container from the same image again, specifying the
    `detach` option and a command that runs for some minutes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case when the container has launched, control returns to the terminal;
    the long random string is the ID of the new container. You can run `docker container
    ls` and see the container running, and the `docker container logs` command shows
    you the console output from the container. For commands operating on specific
    containers, you can reference them by the container name or by part of the container
    ID - IDs are random, in my case this container ID begins `bb3`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `--detach` flag detaches the container so that it moves into the background,
    and the command in this case just pings `localhost` repeatedly one hundred times.
    After a few minutes, the PowerShell command completes so there's no process running
    and the container exits.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a key thing to remember: if you want to keep a container running in
    the background, the process that Docker starts when it runs the container has
    to keep running.'
  prefs: []
  type: TYPE_NORMAL
- en: Now you've seen that a container is created from an image, but it can run in
    different ways. So you can use the image exactly as it was prepared, or treat
    the image as a template with a default startup mode built in. Next, I'll show
    you how to build that image.
  prefs: []
  type: TYPE_NORMAL
- en: Building a Docker image
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Docker images are layered. The bottom layer is the operating system, which can
    be a full OS like Windows Server Core, or a minimal OS like Microsoft Nano Server.
    On top of this are layers for each change you make to the base OS when you build
    an image, by installing software, copying files, and running commands. Logically,
    Docker treats the image as a single unit, but physically each layer is stored
    as a separate file in Docker's cache, so images with a lot of common features
    can share layers from the cache.
  prefs: []
  type: TYPE_NORMAL
- en: Images are built using a text file with the Dockerfile language – specifying
    the base OS image to start with and all the steps to add on top. The language
    is very simple, and there are only a few commands you need to master in order
    to build production-grade images. I'll start by looking at the basic PowerShell
    image I've been using so far in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Dockerfiles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A Dockerfile is just a deployment script which packages software into a Docker
    image. The complete code for the PowerShell image is just three lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: It's pretty easy to guess what's happening even if you've never seen a Dockerfile
    before. By convention the instructions (`FROM`, `COPY`, and `CMD`) are uppercase
    and the arguments are lowercase, but this is not mandatory. Also by convention,
    you save the text in a file called `Dockerfile`, but this is not mandatory either
    (a file with no extension looks odd in Windows, but remember that Docker's heritage
    is in Linux).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the instructions in the Dockerfile line by line:'
  prefs: []
  type: TYPE_NORMAL
- en: '`FROM mcr.microsoft.com/windows/servercore:ltsc2019` uses an image called `windows/servercore`
    as the starting point for this image, specifying the `ltsc2019` version of the
    image and the registry where it is hosted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`COPY scripts/print-env-details.ps1 C:\\print-env.ps1` copies the PowerShell
    script from the local computer to a specific location in the image.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CMD ["powershell.exe", "C:\\print-env.ps1"]` specifies the startup command
    when a container runs, which in this case is running the PowerShell script.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are a few obvious questions here. Where does the base image come from?
    Built into Docker is the concept of an image registry, which is a store for container
    images. The default registry is a free public service called **Docker Hub**. Microsoft
    publishes some images on Docker Hub, but Windows base images are hosted on the **Microsoft
    Container Registry** (**MCR**).
  prefs: []
  type: TYPE_NORMAL
- en: The 2019 release of the Windows Server Core image is called `windows/servercore:ltsc2019`.
    The first time you use the image, Docker will download it from MCR to your local
    machine and then cache it for further use.
  prefs: []
  type: TYPE_NORMAL
- en: Docker Hub is where all the Microsoft images are listed for discovery, as MCR
    doesn't have a web UI. Even if images are hosted on MCR, they will be listed on
    Docker Hub, so that's the place to go when you're looking for images.
  prefs: []
  type: TYPE_NORMAL
- en: Where does the PowerShell script get copied from? When you build an image, the
    directory containing the Dockerfile is used as the context for the build. When
    you build an image from this Dockerfile, Docker will expect to find a folder called
    `scripts` in the context directory, containing a file called `print-env-details.ps1`.
    If it doesn't find that file, the build will fail.
  prefs: []
  type: TYPE_NORMAL
- en: Dockerfiles use the backslash as an escape character in order to continue instructions
    onto a new line. This clashes with Windows file paths, so you have to write `C:\print.ps1`
    as `C:\\print.ps1` or `C:/print.ps1`. There is a nice way to get around this,
    using a processor directive at the start of the Dockerfile, which I'll demonstrate
    later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: How do you know PowerShell is available for use? It's part of the Windows Server
    Core base image, so you can rely on it being there. You can install any software
    that isn't in the base image with additional Dockerfile instructions. You can
    add Windows features, set registry values, copy or download files into the image,
    extract ZIP files, deploy MSIs and do whatever else you need.
  prefs: []
  type: TYPE_NORMAL
- en: This is a very simple Dockerfile, but even so two of the instructions are optional.
    Only the `FROM` instruction is mandatory, so if you want to build an exact clone
    of Microsoft's Windows Server Core image, you can do so with just a `FROM` statement
    in your Dockerfile, and call the cloned image anything you like.
  prefs: []
  type: TYPE_NORMAL
- en: Building an image from a Dockerfile
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you have a Dockerfile, you use the `docker` command line to build it
    into an image. Like most Docker commands, the `image build` command is straightforward
    and has very few required options, preferring conventions instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'To build an image, open a command line and navigate to the directory where
    your Dockerfile is. Then, run `docker image build` and give your image a tag,
    which is the name that will identify the image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Every image needs a tag, specified with the `--tag` option, which is a unique
    identifier for the image in your local image cache and in image registries. The
    tag is how you''ll refer to the image when you run containers. A full tag specifies
    the registry to use: the repository name, which is the identifier for the application,
    and a suffix, which is the identifier for this version of the image.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you''re building an image for yourself, you can call it anything, but
    the convention is to name your repository as your username for the registry, followed
    by the application name: `{user}/{app}`. You can also use the tag to identify
    application versions or variations, such as `sixeyed/git` and `sixeyed/git:2.17.1-windowsservercore-ltsc2019`,
    which are two of my images on Docker Hub.'
  prefs: []
  type: TYPE_NORMAL
- en: The period at the end of the `image build` command tells Docker the location
    of the context to use for the image. `.` is the current directory. Docker copies
    the contents of the directory tree into a temporary folder for the build, so the
    context needs to contain any files you reference in the Dockerfile. After copying
    the context, Docker starts executing the instructions in the Dockerfile.
  prefs: []
  type: TYPE_NORMAL
- en: Examining how Docker builds an image
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Understanding how Docker images are constructed will help you build efficient
    images. The `image build` command produces a lot of output, which tells you exactly
    what Docker does for each step of the build. Each instruction in the Dockerfile
    is executed as a separate step that produces a new image layer, and the final
    image will be a combined stack of all of the layers. The following code snippet
    is the output from building my image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This is what happens when Docker builds the image:'
  prefs: []
  type: TYPE_NORMAL
- en: The `FROM` image already exists in my local cache, so Docker doesn't need to
    download it. The output is the ID of Microsoft's Windows Server Core image (starting
    `8b79`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Docker copies the script file from the build context into a new image layer
    (ID `5e9e`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Docker configures the command to execute when a container is run from the image.
    It creates a temporary container from the *Step 2* image, configures the startup
    command, saves the container as a new image layer (ID `5f27`), and deletes the
    intermediate container (ID `c14c`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The final layer is tagged with the image name, but all the intermediate layers
    are also added to the local cache. This layered approach means Docker can be very
    efficient when it builds images and runs containers. The latest Windows Server
    Core image is over 4 GB uncompressed, but when you run multiple containers based
    on Windows Server Core, they will all use the same base image layers, so you don't
    end up with multiple copies of the 4 GB image.
  prefs: []
  type: TYPE_NORMAL
- en: You'll understand more about image layers and storage later in the chapter,
    but first I'll look at some more complex Dockerfiles which package .NET and .NET
    Core applications.
  prefs: []
  type: TYPE_NORMAL
- en: Packaging your own applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The goal of building an image is to package your application in a portable,
    self-contained unit. The image should be as small as possible, so it's easy to
    move around when you want to run the application, and it should have as few OS
    features as possible, so it has a fast startup time and a small attack vector.
  prefs: []
  type: TYPE_NORMAL
- en: Docker doesn't impose restrictions on the image size. Your long-term goal may
    be to build minimal images that run lightweight .NET Core applications on Linux
    or Nano Server. But you can start by packaging your existing ASP.NET apps in their
    entirety as Docker images to run on Windows Server Core. Docker doesn't impose
    restrictions on how to package your app either, so you can choose from different
    approaches.
  prefs: []
  type: TYPE_NORMAL
- en: Compiling the application during the build
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are two common approaches to packaging your own apps in Docker images.
    The first is to use a base image which contains the application platform and the
    build tools. So in your Dockerfile, you copy the source code into the image and
    compile the app as a step during the image-building process.
  prefs: []
  type: TYPE_NORMAL
- en: This is a popular approach for public images, because it means that anyone can
    build the image without having the application platform installed locally. It
    also means that the tooling for the application is bundled with the image, so
    it can make it possible to debug and troubleshoot the application running in the
    container.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example with a simple .NET Core application. This Dockerfile is
    for the `dockeronwindows/ch02-dotnet-helloworld:2e` image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The Dockerfile uses Microsoft's .NET Core image from Docker Hub as the base
    image. It's a specific variation of the image, one that is based on Nano Server
    release 1809 and has the .NET Core 2.2 SDK installed. The build copies in the
    application source code from the context, and compiles the application as part
    of the container build process.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three new instructions in this Dockerfile that you haven''t seen
    before:'
  prefs: []
  type: TYPE_NORMAL
- en: '`WORKDIR` specifies the current working directory. Docker creates the directory
    in the intermediate container if it doesn''t already exist, and sets it to be
    the current directory. It remains the working directory for the subsequent instructions
    in the Dockerfile, and for containers when they run from the image.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`USER` changes the current user in the build. Nano Server uses a least-privilege
    user by default. This switches to a built-in account in the container image, which
    has administrative rights.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`RUN` executes a command inside an intermediate container and saves the state
    of the container after the command completes, creating a new image layer.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When I build this image, you''ll see the `dotnet` command output, which is
    the application being compiled from the `RUN` instruction in the image build:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: You'll see this approach a lot on Docker Hub for applications built with languages
    like .NET Core, Go, and Node.js, where the tooling is easy to add to a base image.
    It means that you can set up an automated build on Docker Hub so Docker's servers
    build your image from a Dockerfile when you push code changes to GitHub. Servers
    can do this without having .NET Core, Go, or Node.js installed, because all the
    build dependencies are inside the base image.
  prefs: []
  type: TYPE_NORMAL
- en: This option means that the final image will be a lot bigger than it needs to
    be for a production application. Language SDKs and tooling will probably use more
    disk space than the app itself, but your end result should be the application;
    all the build tools taking up space in your image will never be used when the
    container runs in production. An alternative is to build the application first,
    and then package the compiled binaries into your container image.
  prefs: []
  type: TYPE_NORMAL
- en: Compiling the application before the build
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Building the application first fits in neatly with existing build pipelines.
    Your build servers need to have all of the application platforms and build tools
    installed to compile the application, but your finished container image only has
    the minimum it needs to run the app. With this approach, the Dockerfile for my
    .NET Core app becomes even simpler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This Dockerfile uses a different `FROM` image, one that contains just the .NET
    Core 2.2 runtime and not the tooling (so it can run a compiled application, but
    it can't compile one from source). You can't build this image without building
    the application first, so you'll need to wrap the `docker image build` command
    in a build script that also runs the `dotnet publish` command to compile the binaries.
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple build script, which compiles the application and builds the Docker
    image, looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If you put your Dockerfile instructions in a file called something other than
    **Dockerfile**, you need to specify the filename with the `--file` option: `docker
    image build --file Dockerfile.slim`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'I''ve moved the requirements for the platform tooling from the image to the
    build server, and that results in a much smaller final image: 410 MB for this
    version, compared to 1.75 GB for the previous one. You can see the size difference
    by listing images and filtering on the image repository name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This new version is also a more restricted image. The source code and the .NET
    Core SDK aren't packaged in the image, so you can't connect to a running container
    and inspect the application code, or make changes to the code and recompile the
    app.
  prefs: []
  type: TYPE_NORMAL
- en: 'For enterprise environments, or for commercial applications, you''re likely
    to already have a well-equipped build server, and packaging the built app can
    be part of a more comprehensive workflow:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/d09a1ae3-e97a-4318-8118-f2d2a39c5828.png)'
  prefs: []
  type: TYPE_IMG
- en: In this pipeline the developer pushes their changes to the central source code
    repository (**1**). The build server compiles the application and runs unit tests;
    if they pass, then the container image is built and deployed in a staging environment
    (2). Integration tests and end-to-end tests are run against the staging environment,
    and if they pass, then your version of the container image is a good release candidate
    for testers to verify (3).
  prefs: []
  type: TYPE_NORMAL
- en: You deploy a new release by running a container from the image in production,
    and you know that your whole application stack is the same set of binaries that
    passed all of the tests.
  prefs: []
  type: TYPE_NORMAL
- en: The downside to this approach is that you need to have the application SDK installed
    on all of your build agents, and the versions of the SDK and all of its dependencies
    need to match what the developers are using. Often in Windows projects, you find
    CI servers with Visual Studio installed, to ensure the server has the same tools
    as the developer. This makes for very heavy build servers, which take a lot of
    effort to commission and maintain.
  prefs: []
  type: TYPE_NORMAL
- en: It also means that you can't build this Docker image from the source code for
    this chapter yourself unless you have the .NET Core 2.2 SDK installed on your
    machine.
  prefs: []
  type: TYPE_NORMAL
- en: You can get the best of both options by using a multi-stage build, where your
    Dockerfile defines one step to compile your application, and another step to package
    it into the final image. Multi-stage Dockerfiles are portable, so anyone can build
    the image with no prerequisites, but the final image only contains the minimum
    needed for the app.
  prefs: []
  type: TYPE_NORMAL
- en: Compiling with multi-stage builds
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a multi-stage build you have multiple `FROM` instructions in your Dockerfile,
    where each `FROM` instruction starts a new stage in the build. Docker executes
    all the instructions when you build the image, and later stages can access the
    output from earlier stages, but only the final stage is used for the completed
    image.
  prefs: []
  type: TYPE_NORMAL
- en: 'I can write a multi-stage Dockerfile for the .NET Core console app by combining
    the previous two Dockerfiles into one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: There are a couple of things that are new here. The first stage uses a large
    base image, with the .NET Core SDK installed. I've named this stage `builder`,
    using the `AS` option in the `FROM` instruction. The rest of the stage goes on
    to copy in the source code and publish the application. When the builder stage
    completes, the published application will be stored in an intermediate container.
  prefs: []
  type: TYPE_NORMAL
- en: The second stage uses the runtime .NET Core image, which doesn't have the SDK
    installed. In this stage I copy the published output from the previous stage,
    specifying `--from=builder` in the `COPY` instruction. Anyone can compile this
    application from the source using Docker, without needing .NET Core installed
    on their machine.
  prefs: []
  type: TYPE_NORMAL
- en: Multi-stage Dockerfiles for Windows apps are completely portable. To compile
    the app and build the image, the only prerequisite is to have a Windows machine
    with Docker installed, and a copy of the code. The builder stage contains the
    SDK and all the compiler tools, but the final image just has the minimum needed
    to run the application.
  prefs: []
  type: TYPE_NORMAL
- en: This approach isn't just for .NET Core. You can write a multi-stage Dockerfile
    for a .NET Framework app, where the first stage uses an image with MSBuild installed,
    which you use to compile your application. There are plenty of examples of this
    later in the book.
  prefs: []
  type: TYPE_NORMAL
- en: Whichever approach you take, there are just a few more Dockerfile instructions
    that you need to understand in order to build more complex application images,
    for software which integrates with other systems.
  prefs: []
  type: TYPE_NORMAL
- en: Using the main Dockerfile instructions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Dockerfile syntax is very simple. You've already seen `FROM`, `COPY`, `USER`,
    `RUN`, and `CMD`, which are enough to package up a basic application to run as
    a container. For real-world images you'll need to do more than that, and there
    are three more key instructions to understand.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a Dockerfile for a simple static website; it uses **Internet Information
    Services** (**IIS**) and serves an HTML page on the default website, which shows
    some basic details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This Dockerfile starts differently, with the `escape` directive. This tells
    Docker to use the backtick [PRE15]
  prefs: []
  type: TYPE_NORMAL
- en: docker image build --build-arg ENV_NAME=TEST --tag dockeronwindows/ch02-static-website:2e
    .
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: docker container run --detach --publish 8081:80 dockeronwindows/ch02-static-website:2e
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 6e3df776cb0c644d0a8965eaef86e377f8ebe036e99961a0621dcb7912d96980
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: docker container port 6e
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 80/tcp -> 0.0.0.0:8081
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: escape=` FROM mcr.microsoft.com/windows/nanoserver:1809 RUN md c:\data & `echo
    'from image 1' > c:\data\file1.txt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: FROM dockeronwindows/ch02-fs-1:2e RUN echo 'from image 2' > c:\data\file2.txt
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: docker container run -it --name c1 dockeronwindows/ch02-fs-2:2e
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: C:\>dir C:\data
  prefs: []
  type: TYPE_NORMAL
- en: Volume in drive C has no label.
  prefs: []
  type: TYPE_NORMAL
- en: Volume Serial Number is BC8F-B36C
  prefs: []
  type: TYPE_NORMAL
- en: Directory of C:\data
  prefs: []
  type: TYPE_NORMAL
- en: 02/06/2019  11:00 AM    <DIR>          .
  prefs: []
  type: TYPE_NORMAL
- en: 02/06/2019  11:00 AM    <DIR>          ..
  prefs: []
  type: TYPE_NORMAL
- en: 02/06/2019  11:00 AM                17 file1.txt
  prefs: []
  type: TYPE_NORMAL
- en: 02/06/2019  11:00 AM                17 file2.txt
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: C:\>echo ' * ADDITIONAL * ' >> c:\data\file2.txt
  prefs: []
  type: TYPE_NORMAL
- en: C:\>echo 'New!' > c:\data\file3.txt
  prefs: []
  type: TYPE_NORMAL
- en: C:\>dir C:\data
  prefs: []
  type: TYPE_NORMAL
- en: Volume in drive C has no label.
  prefs: []
  type: TYPE_NORMAL
- en: Volume Serial Number is BC8F-B36C
  prefs: []
  type: TYPE_NORMAL
- en: Directory of C:\data
  prefs: []
  type: TYPE_NORMAL
- en: 02/06/2019  01:10 PM    <DIR>          .
  prefs: []
  type: TYPE_NORMAL
- en: 02/06/2019  01:10 PM    <DIR>          ..
  prefs: []
  type: TYPE_NORMAL
- en: 02/06/2019  11:00 AM                17 file1.txt
  prefs: []
  type: TYPE_NORMAL
- en: 02/06/2019  01:10 PM                38 file2.txt
  prefs: []
  type: TYPE_NORMAL
- en: 02/06/2019  01:10 PM                 9 file3.txt
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: C:\> exit
  prefs: []
  type: TYPE_NORMAL
- en: PS> docker container run -it --name c2 dockeronwindows/ch02-fs-2:2e
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: C:\>dir C:\data
  prefs: []
  type: TYPE_NORMAL
- en: Volume in drive C has no label.
  prefs: []
  type: TYPE_NORMAL
- en: Volume Serial Number is BC8F-B36C
  prefs: []
  type: TYPE_NORMAL
- en: Directory of C:\data
  prefs: []
  type: TYPE_NORMAL
- en: 02/06/2019  11:00 AM    <DIR>          .
  prefs: []
  type: TYPE_NORMAL
- en: 02/06/2019  11:00 AM    <DIR>          ..
  prefs: []
  type: TYPE_NORMAL
- en: 02/06/2019  11:00 AM                17 file1.txt
  prefs: []
  type: TYPE_NORMAL
- en: 02/06/2019  11:00 AM                17 file2.txt
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: escape=`
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: FROM mcr.microsoft.com/windows/nanoserver:1809 VOLUME C:\app\config VOLUME C:\app\logs
    USER ContainerAdministrator ENTRYPOINT cmd /S /C
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: docker container run --name source dockeronwindows/ch02-volumes:2e "echo 'start'
    > c:\app\logs\log-1.txt"
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: docker container run -it --volumes-from source dockeronwindows/ch02-volumes:2e
    cmd
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: ls C:\app
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Directory: C:\app'
  prefs: []
  type: TYPE_NORMAL
- en: Mode     LastWriteTime      Length  Name
  prefs: []
  type: TYPE_NORMAL
- en: '----     -------------      ------  ----'
  prefs: []
  type: TYPE_NORMAL
- en: d----l   6/22/2017 8:11 AM          config
  prefs: []
  type: TYPE_NORMAL
- en: d----l   6/22/2017 8:11 AM          logs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: C:\>type C:\app\logs\log-1.txt
  prefs: []
  type: TYPE_NORMAL
- en: '''start'''
  prefs: []
  type: TYPE_NORMAL
- en: C:\>echo 'more' >> C:\app\logs\log-1.txt
  prefs: []
  type: TYPE_NORMAL
- en: C:\>type C:\app\logs\log-1.txt
  prefs: []
  type: TYPE_NORMAL
- en: '''start'''
  prefs: []
  type: TYPE_NORMAL
- en: '''more'''
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: docker container run -it --volumes-from source:ro dockeronwindows/ch02-volumes:2e
    cmd
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: C:\>type C:\app\logs\log-1.txt
  prefs: []
  type: TYPE_NORMAL
- en: '''start'''
  prefs: []
  type: TYPE_NORMAL
- en: '''more'''
  prefs: []
  type: TYPE_NORMAL
- en: C:\>echo 'more' >> C:\app\logs\log-1.txt
  prefs: []
  type: TYPE_NORMAL
- en: Access is denied.
  prefs: []
  type: TYPE_NORMAL
- en: C:\>echo 'new' >> C:\app\logs\log-2.txt
  prefs: []
  type: TYPE_NORMAL
- en: Access is denied.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: docker container inspect --format '{{ json .Mounts }}' source | ConvertFrom-Json
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Type        : volume'
  prefs: []
  type: TYPE_NORMAL
- en: 'Name        : 65ab1b420a27bfd79d31d0d325622d0868e6b3f353c74ce3133888fafce972d9'
  prefs: []
  type: TYPE_NORMAL
- en: 'Source      : C:\ProgramData\docker\volumes\65ab1b42...\_data'
  prefs: []
  type: TYPE_NORMAL
- en: 'Destination : c:\app\config'
  prefs: []
  type: TYPE_NORMAL
- en: 'Driver      : local'
  prefs: []
  type: TYPE_NORMAL
- en: 'RW          : TruePropagation :'
  prefs: []
  type: TYPE_NORMAL
- en: 'Type        : volume'
  prefs: []
  type: TYPE_NORMAL
- en: 'Name        : b1451fde3e222adbe7f0f058a461459e243ac15af8770a2f7a4aefa7516e0761'
  prefs: []
  type: TYPE_NORMAL
- en: 'Source      : C:\ProgramData\docker\volumes\b1451fde...\_data'
  prefs: []
  type: TYPE_NORMAL
- en: 'Destination : c:\app\logs'
  prefs: []
  type: TYPE_NORMAL
- en: 'Driver      : local'
  prefs: []
  type: TYPE_NORMAL
- en: 'RW          : True'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: ls C:\ProgramData\docker\volumes\b1451fde...\_data
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Directory: C:\ProgramData\docker\volumes\b1451fde3e222adbe7f0f058a461459e243ac15af8770a2f7a4aefa7516e0761\_data'
  prefs: []
  type: TYPE_NORMAL
- en: Mode                LastWriteTime         Length Name
  prefs: []
  type: TYPE_NORMAL
- en: '----                -------------         ------ ----'
  prefs: []
  type: TYPE_NORMAL
- en: -a----       06/02/2019     13:33             19 log-1.txt
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: PS> mkdir C:\app-config | Out-Null
  prefs: []
  type: TYPE_NORMAL
- en: PS> echo 'VERSION=18.09' > C:\app-config\version.txt
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: docker container run `
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: --volume C:\app-config:C:\app\config `
  prefs: []
  type: TYPE_NORMAL
- en: dockeronwindows/ch02-volumes:2e `
  prefs: []
  type: TYPE_NORMAL
- en: type C:\app\config\version.txt
  prefs: []
  type: TYPE_NORMAL
- en: VERSION=18.09
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'escape=` FROM microsoft/dotnet:2.2-sdk-nanoserver-1809 AS builder WORKDIR C:\src
    COPY src . USER ContainerAdministrator RUN dotnet restore && dotnet publish #
    app image FROM microsoft/dotnet:2.2-aspnetcore-runtime-nanoserver-1809'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: EXPOSE 80 WORKDIR C:\dotnetapp RUN mkdir app-state CMD ["dotnet", "HitCountWebApp.dll"]
    COPY --from=builder C:\src\bin\Debug\netcoreapp2.2\publish .
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: docker image build --tag dockeronwindows/ch02-hitcount-website:2e-v1 .
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: mkdir C:\app-state
  prefs: []
  type: TYPE_NORMAL
- en: docker container run -d --publish-all `
  prefs: []
  type: TYPE_NORMAL
- en: -v C:\app-state:C:\dotnetapp\app-state `
  prefs: []
  type: TYPE_NORMAL
- en: --name appv1 `
  prefs: []
  type: TYPE_NORMAL
- en: dockeronwindows/ch02-hitcount-website:2e-v1
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: docker container port appv1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 80/tcp -> 0.0.0.0:51377
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: PS> docker container stop appv1
  prefs: []
  type: TYPE_NORMAL
- en: appv1
  prefs: []
  type: TYPE_NORMAL
- en: PS> docker container run -d --publish-all `
  prefs: []
  type: TYPE_NORMAL
- en: -v C:\app-state:C:\dotnetapp\app-state `
  prefs: []
  type: TYPE_NORMAL
- en: --name appv2 `
  prefs: []
  type: TYPE_NORMAL
- en: dockeronwindows/ch02-hitcount-website:2e-v2
  prefs: []
  type: TYPE_NORMAL
- en: db8a39ba7af43be04b02d4ea5d9e646c87902594c26a62168c9f8bf912188b62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: escape=` FROM microsoft/dotnet-framework:4.7.2-sdk-windowsservercore-ltsc2019
    AS builder WORKDIR C:\src\NerdDinner COPY src\NerdDinner\packages.config . RUN
    nuget restore packages.config -PackagesDirectory ..\packages COPY src C:\src RUN
    msbuild NerdDinner.csproj /p:OutputPath=c:\out /p:Configuration=Release
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: FROM mcr.microsoft.com/dotnet/framework/aspnet:4.7.2-windowsservercore-ltsc2019
    SHELL ["powershell", "-Command", "$ErrorActionPreference = 'Stop'] ENV BING_MAPS_KEY
    bing_maps_key WORKDIR C:\nerd-dinner RUN Remove-Website -Name 'Default Web Site';
    `
  prefs: []
  type: TYPE_NORMAL
- en: New-Website -Name 'nerd-dinner' ` -Port 80 -PhysicalPath 'c:\nerd-dinner' `-ApplicationPool
    '.NET v4.5' RUN & c:\windows\system32\inetsrv\appcmd.exe ` unlock config /section:system.webServer/handlers
    COPY --from=builder C:\out\_PublishedWebsites\NerdDinner C:\nerd-dinner
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: docker container run -d -P dockeronwindows/ch02-nerd-dinner:2e
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'I can get the container''s published port with `docker container port`, and
    browse to the NerdDinner home page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/2e704bc2-8b9b-4e32-a63d-4207c87a2d38.png)'
  prefs: []
  type: TYPE_IMG
- en: That's a six-year old application running in a Docker container with no code
    changes. Docker is a great platform for building new apps and modernizing old
    apps, but it's also a great way to get your existing applications out of the data
    center and into the cloud, or to move them from old versions of Windows which
    no longer have support, like Windows Server 2003 and (soon) Windows Server 2008.
  prefs: []
  type: TYPE_NORMAL
- en: At this point the app isn't fully functional, I just have a basic version running.
    The Bing Maps object doesn't show a real map because I haven't provided an API
    key. The API key is something that will change for every environment (each developer,
    the test environments, and production will have different keys).
  prefs: []
  type: TYPE_NORMAL
- en: In Docker, you manage environment configuration with environment variables and
    config objects, which I will use for the next iteration of the Dockerfile in [Chapter
    3](ee527f27-ee07-40e1-a39d-86aa2d11da72.xhtml), *Developing Dockerized .NET Framework
    and .NET Core Applications*.
  prefs: []
  type: TYPE_NORMAL
- en: If you navigate around this version of NerdDinner and try to register a new
    user or search for a dinner, you'll see a yellow crash page telling you the database
    isn't available. In its original form NerdDinner uses SQL Server LocalDB as a
    lightweight database and stores the database file in the app directory. I could
    install the LocalDB runtime into the container image, but that doesn't fit with
    the Docker philosophy of having one application per container. Instead, I'll build
    a separate image for the database so I can run it in its own container.
  prefs: []
  type: TYPE_NORMAL
- en: I'll be iterating on the NerdDinner example in the next chapter, adding configuration
    management, running SQL Server as a separate component in its own container, and
    demonstrating how you can start modernizing traditional ASP.NET apps by making
    use of the Docker platform.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter I took a closer look at Docker images and containers. Images
    are packaged versions of applications, and containers are instances of an application,
    run from an image. You can use containers to do simple fire-and-forget tasks,
    work with them interactively, or have them running in the background. As you start
    to use Docker more, you'll find yourself doing all three.
  prefs: []
  type: TYPE_NORMAL
- en: The Dockerfile is the source script for building an image. It's a simple text
    file with a small number of instructions to specify a base image, copy files,
    and run commands. You use the Docker command-line to build the image, which is
    very easy to add as a step to your CI build. When a developer pushes code that
    passes all the tests, the output of the build will be a versioned Docker image,
    which you can deploy to any host knowing that it will always run in the same way.
  prefs: []
  type: TYPE_NORMAL
- en: I looked at a few simple Dockerfiles in this chapter, and finished with a real-world
    application. NerdDinner is a legacy ASP.NET MVC app that was built to run on Windows
    Server and IIS. Using multi-stage builds, I packaged that legacy app into a Docker
    image and ran it in a container. This shows that the new model of compute which
    Docker offers isn't just for greenfield projects using .NET Core and Nano Server
    - you can migrate existing apps to Docker and put yourself in a good position
    to start modernizing them.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter I'll use Docker to modernize the architecture of NerdDinner,
    breaking features out into separate components, and using Docker to plug them
    all together.
  prefs: []
  type: TYPE_NORMAL
