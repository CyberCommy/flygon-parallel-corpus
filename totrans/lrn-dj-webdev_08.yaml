- en: Chapter 8. Creating an Administration Interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn the features of the administrator interface
    using Django''s inbuilt features. We will also cover how to show tweets in a customized
    way, with sidebar or pagination enabled. We will deal with the following topics
    in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Customizing the administration interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customizing listing pages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overriding administration templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Users, groups, and permissions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User permissions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Group permissions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using permissions in views
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Organizing content into pages (pagination)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customizing the administration interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The administration interface provided by Django is very powerful and flexible,
    and from the version 1.6, it comes activated by default. This will give you a
    fully featured administration kit for your site. Although the administration application
    should be sufficient for most needs, Django offers several ways to customize and
    enhance it. In addition to specifying which models are available in the administration
    interface, you can also specify how listing pages are presented and even override
    the templates used to render the administration pages. So, let's learn about these
    features.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing listing pages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we saw in the previous chapter, we registered our model classes to the administration
    interface using the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`admin.site.register` (`Tweet`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`admin.site.register` (`Hashtag`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`admin.site.register` (`UserFollower`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can also customize several aspects of the administration pages. Let''s learn
    about this by example. The tweet listing page displays the string representation
    of each tweet, as we can see in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Customizing listing pages](img/image00306.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Wouldn't this page be more useful if it were to display the name of the user
    who has posted the tweet, as well as the time of posting, in separate columns?
    It turns out that implementing this functionality only requires adding a few lines
    of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the tweet model in `tweet/admin.py` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Add new lines of code above `#Register your models here` and the updated code
    will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This code adds the extra column in the administrator view for the `TweetAdmin()`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Moreover, we have passed an extra parameter to register calls for the administrator
    tweet; that is, `admin.site.register(Tweet)` becomes `admin.site.register(Tweet,
    TweetAdmin)` now. Refresh the same page and note the changes, as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Customizing listing pages](img/image00307.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The table is now better organized! We simply defined a tuple attribute called
    `list_display` in the `TweetAdmin()` class of the `Tweet` model. This tuple contains
    the names of the fields to be used in the listing page.
  prefs: []
  type: TYPE_NORMAL
- en: There are other attributes that we can define in the Admin class; each one should
    be defined as a tuple of one or more field names.
  prefs: []
  type: TYPE_NORMAL
- en: '`list_filter`: If defined, this creates a sidebar with links that can be used
    to filter objects according to one or more fields in the model.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ordering`: The fields that are used to order objects in the listing page.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`search_fields`: If defined, it creates a search field that can be used to
    search. The field name is preceded by a minus sign, and descending order is used
    instead of ascending order for the available objects in the data model according
    to one or more fields.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s utilize each of the preceding attributes in the tweet listing page.
    Again, edit the Tweet model in the `tweet/admin.py` file and append the following
    highlighted lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This is how it looks after using these attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Customizing listing pages](img/image00308.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, we were able to customize and enhance the tweet listing page
    with only a few lines of code. Next, we will learn about customizing the templates
    used to render administration pages, which will give us even greater control over
    the administration interface.
  prefs: []
  type: TYPE_NORMAL
- en: Overriding administration templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are times when you want to change the look and feel of the administration
    interface or to move the elements on the various administration pages and rearrange
    them. Fortunately, the administration interface is flexible enough to do all of
    this and more by allowing us to override its templates. The process of customizing
    an administration template is simple. First, you copy the template from the administration
    application folder to your project''s templates folder, and then you edit this
    template and customize it to your liking. The location of the administration templates
    depends on where Django is installed. Here is a list of the default installation
    paths of Django under the major operating systems:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Windows**: `C:\PythonXX\Lib\site-packages\django`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**UNIX and Linux**: `/usr/lib/pythonX.X/site-packages/django`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mac OS X**: `/Library/Python/X.X/site-packages/django`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (Here, **X.X** is the version of Python on your system. The `site-packages`
    folder can also be found as `dist-packages`.)
  prefs: []
  type: TYPE_NORMAL
- en: If you cannot find Django in the default installation path for your operating
    system, perform a file system search for `django-admin.py`. You will get multiple
    hits, but the one that you want will be under the Django installation path, inside
    a folder called `bin`.
  prefs: []
  type: TYPE_NORMAL
- en: After locating the Django installation path, open `django/contrib/admin/templates/`
    and you will find the templates used by the administration application.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many files in this directory, but the most important ones are these:'
  prefs: []
  type: TYPE_NORMAL
- en: '`admin/base_site.html`: This is the base template for the administration. This
    template generates the interface. All pages inherit from this template in the
    following model.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`admin/change_list.html`: This template generates a list of available objects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`admin/change_form.html`: This template generates a form for adding or editing
    an object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`admin/delete_confirmation.html`: This template generates the confirmation
    page when an object is deleted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s try to customize one of these templates. Suppose that we want to change
    the string **Django administration** located at the top of all admin pages. To
    do so, create a folder called `admin` inside the `templates` folder of our project,
    and copy the `admin/base_site.html` file to it. After that, edit the file to change
    all instances of `Django` to `Django Tweet`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The result will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Overriding administration templates](img/image00309.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Because of the modular design of the admin templates, it is usually neither
    necessary nor advisable to replace an entire template. It is almost always better
    to override only the section of the template that you need to change.
  prefs: []
  type: TYPE_NORMAL
- en: The process was pretty simple, wasn't it? Feel free to experiment with other
    templates. For example, you may want to add a help message to a listing or edit
    pages.
  prefs: []
  type: TYPE_NORMAL
- en: The administration templates make use of many advanced features of the Django
    template system, so if you see a template tag that you are not familiar with,
    you can refer to the Django documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Users, groups, and permissions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have been logged in to the administration interface using the superuser
    account that we created with the `manage.py syncdb` command. In reality, however,
    you may have other trusted users who need access to the administration page. In
    this section, we will see how to allow other users to use the administration interface,
    and we will learn more about the Django permissions system in the process.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, before we continue, I want to emphasize this: only trusted users should
    be given access to the administration pages. The administration interface is a
    very powerful tool, so only those whom you know well should be granted access
    to it.'
  prefs: []
  type: TYPE_NORMAL
- en: User permissions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you don't have users in the database other than the superuser, create a new
    user account using the registration form that we built in [Chapter 7](part0056.xhtml#aid-1LCVG2
    "Chapter 7. Following and Commenting"), *Following and Commenting*. Alternatively,
    you could use the administration interface itself by clicking on **Users** and
    then **Add User**.
  prefs: []
  type: TYPE_NORMAL
- en: Next, return to the users list and click on the name of the newly created user.
    You will get a form that can be used to edit various aspects of the user account,
    such as name and e-mail information. Under the **Permissions** section of the
    edit form, you will find a checkbox labelled **Staff status**. Enabling this checkbox
    will let the new user enter the administration interface. However, they won't
    be able to do much after they log in because this checkbox only grants access
    to the administration area; it does not give the ability to see or change data.
  prefs: []
  type: TYPE_NORMAL
- en: To give the new user enough permissions to change data models, you can enable
    the **Superuser status** checkbox, which will grant the new user full permission
    to perform any function that they want. This option makes the account as powerful
    as the superuser account created by the `manage.py syncdb` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the whole, however, it''s not desirable to grant a user full access to everything.
    Therefore, Django gives you the ability to have fine control over what users can
    do through the permissions system. Below the **Superuser status** checkbox, you
    will find a list of permissions that you can grant to the user. If you examine
    this list, you will find that each data model has three types of permissions:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding an object to the data model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing an object in the data model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deleting an object from the data model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These permissions are automatically generated by Django for data models that
    contain an Admin class. Use the arrow button to grant some permissions to the
    account that we are editing. For example, give the account the ability to add,
    edit, and delete tweets and hashtags. Next, log out and then log in to the administration
    interface again using the new account. You will notice that you will only be able
    to manage the tweets and hashtags data models.
  prefs: []
  type: TYPE_NORMAL
- en: The permissions section of the user edit page also contains a checkbox called
    **Active**. This checkbox can be used as a global switch to enable and disable
    the account. When unchecked, the user won't be able to log in to the main site
    or the administration area.
  prefs: []
  type: TYPE_NORMAL
- en: Group permissions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you have a considerable number of users who share the same permissions,
    it would be a tedious and error-prone task to edit each user''s account and assign
    the same permissions to them. Therefore, Django provides another user management
    facility: groups. To put it simply, groups are a way of categorizing users who
    share the same permissions. You can create a group and assign permissions to it.
    When you add a user to the group, this user is granted all of the group''s permissions.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a group is not very different from other data models. Click on **Groups**
    on the main page of the administration interface, and then click on **Add Group**.
    Next, enter a group name and assign some permissions to the group; finally, click
    on **Save**.
  prefs: []
  type: TYPE_NORMAL
- en: To add a user to a group, edit the user account, scroll to the **Groups** section
    in the edit form, and select whichever group you want to add the user to.
  prefs: []
  type: TYPE_NORMAL
- en: Using permissions in views
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although we have only used permissions in the administration interface so far,
    Django also lets us utilize the permission system while writing views. It is possible
    to use permissions while programming a view to grant a group of users access to
    a particular feature or page, such as private content. We will learn about the
    methods that can be used to do so in this section. We won't actually make changes
    to the code of our application, but feel free to do so if you want to experiment
    with the methods explained.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you wanted to check whether a user has a particular permission, you could
    use the `has_perm()` method on the `User` object. This method takes a string that
    represents the permission in the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `app` parameter specifies the name of the application where the model is
    located; the `operation` parameter could be `add`, `change` or `delete`; the `model`
    parameter specifies the name of the model.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to check whether the user can add tweets, use this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'To check if the user can change tweets, use this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Furthermore, Django provides a function named `decorator` that can be used to
    restrict a view to users who have a particular permission. The decorator is called
    `permission_required`, and it is located in the `django.contrib.auth.decorators`
    package.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using this decorator is similar to how we used the `login_required` function.
    The decorator function is to restrict pages to logged in users. Let''s say we
    want to restrict the `tweet_save_page` view (in the `tweets/views.py` file) to
    users who have the `tweet.add_tweet` permission. To do so, we can use the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This decorator takes two parameters: the permission to check for and where
    to redirect the user if they don''t have the required permission.'
  prefs: []
  type: TYPE_NORMAL
- en: The question of whether to use the `has_perm` method or the `permission_required`
    decorator depends on the level of control that you want. If you need to control
    access to a view as a whole, use the `permission_required` decorator. However,
    if you need finer control over permissions inside a view, use the `has_perm` method.
    These two approaches should be sufficient for any permission-related needs.
  prefs: []
  type: TYPE_NORMAL
- en: Organizing content into pages – pagination
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In previous chapters, we have covered things such as listing down the tweets
    of users and listing down most followed users, but consider a use case when these
    small numbers scale up and we start getting a large number of results for each
    type of query. To cover such a situation, we should manipulate our code so as
    to make it support pagination.
  prefs: []
  type: TYPE_NORMAL
- en: 'The page would increase in size, and finding an item within the page would
    become difficult. Fortunately, there is a simple and intuitive solution to this:
    pagination. **Pagination** is the process of breaking content into pages. And,
    as always, Django already has a component that implements this functionality,
    ready for us to use!'
  prefs: []
  type: TYPE_NORMAL
- en: If we have a large set of tweets, we split the set into pages with ten (or so)
    items on each page, present the first page to the user, and provide links to browse
    other pages.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Django pagination functionality is encapsulated in a class called `Paginator`,
    which is located in the `django.core.paginator` package. Let''s learn the interface
    of this class using the interactive console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Open the Django shell with the `python manage.py shell` command.
  prefs: []
  type: TYPE_NORMAL
- en: Here we import some classes, build a query set containing all bookmarks, and
    instantiate an object called `Paginator`. The constructor of this class takes
    the query set to be paginated, and the number of items on each page is set.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how to retrieve information from the `Paginator` object (of course,
    the results will vary depending on the amount of bookmarks that you have):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, `Paginator` does the heavy lifting for us. It takes a query
    set, breaks it into pages, and enables us to render the query set into multiple
    pages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s implement pagination into one of our views, the tweet page for example.
    Open `tweet/views.py` and modify the `user_page` view as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We have our user profile page listing with the following class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to modify the preceding code to use pagination:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code snippet mainly works the pagination magic in the preceding
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: To make this code work, add the `TWEET_PER_PAGE = 5` parameter in the `settings.py`
    file, and, in the preceding code, just add the `import settings.py` statement
    at the top of the code.
  prefs: []
  type: TYPE_NORMAL
- en: We read a `get` variable called `page` from the request, which tells Django
    which page has been requested. We also set the `TWEET_PER_PAGE` parameter in the
    `settings.py` file to show the number of tweets on a single page. For this specific
    case, we choose it to be `5`.
  prefs: []
  type: TYPE_NORMAL
- en: The `paginator = Paginator(tweets, TWEET_PER_PA` `GE)` method creates a pagination
    object that holds all the information about the query.
  prefs: []
  type: TYPE_NORMAL
- en: Now, just with a URL `user/<username>/?page=<page_numer>`, the page will look
    as shown in the following screenshot. The first image shows the user's tweet with
    the page number in the URL.
  prefs: []
  type: TYPE_NORMAL
- en: '![Organizing content into pages – pagination](img/image00310.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following screenshot shows the tweet list of a user on their homepage:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Organizing content into pages – pagination](img/image00311.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although this chapter is relatively short, we learned how to implement a lot
    of things. This emphasizes the fact that Django lets you do a lot with only a
    few lines of code. You learned how to utilize Django's powerful administration
    interface, how to customize it, and how to take advantage of the comprehensive
    permission system offered by Django.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn about several exciting features found in
    almost every Web 2.0 application nowadays.
  prefs: []
  type: TYPE_NORMAL
