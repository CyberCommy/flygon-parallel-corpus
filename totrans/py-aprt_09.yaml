- en: Chapter 4 – Built-in types and the object model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the most fundamental design elements of the Python language is its use
    of *objects*. Objects are the central data structure not only of user-level constructs
    but also many of the inner workings of the language itself. In this chapter we’ll
    start to to develop a sense of what this means, both in principle and in practice,
    and hopefully you’ll start to appreciate just how pervasive objects are throughout
    Python.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll take a look at what objects are, how you use them, and how you manage
    references to them. We’ll also start to explore the notion of *types* in Python,
    and we’ll see how Python’s types are both similar to and different from those
    in many other popular languages. As part this exploration we’ll take a more in-depth
    look at some collection types we’ve met already, and introduce a few more collection
    types as well.
  prefs: []
  type: TYPE_NORMAL
- en: The nature of Python object references
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In previous chapters we’ve already talked about and used “variables” in Python,
    but what exactly is a variable? Consider something as straightforward as assigning
    an integer to a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: What’s really happening when we do this? First, Python creates an `int` *object*
    with a value of `1000`. This object is anonymous in the sense that it doesn’t,
    in and of itself, have a name (`x` or otherwise). It’s an object allocated and
    tracked by the Python runtime system.
  prefs: []
  type: TYPE_NORMAL
- en: 'After creating the object, Python then creates an *object reference* with the
    name `x` and arranges for `x` ^([6](chap21.xhtml#fn-reference-names)) to refer
    to the `int(1000)` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Assign the name ''x'' to an integer object with the value 1000](images/m04----x_equals_1000.png)'
  prefs: []
  type: TYPE_IMG
- en: Assign the name ‘x’ to an integer object with the value 1000
  prefs: []
  type: TYPE_NORMAL
- en: Reassigning a reference
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now we’ll modify the value of `x` with another assignment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This does **not** result any sort of change to the `int(1000)` object we previously
    constructed. Integer objects in Python are immutable and cannot be changed. In
    fact, what happens here is that Python first creates a new immutable integer object
    with the value 500 and then redirects the `x` reference to point at the new object:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Reassign the name ''x'' to a new integer object with the value 500](images/m04----x_equals_500.png)'
  prefs: []
  type: TYPE_IMG
- en: Reassign the name ‘x’ to a new integer object with the value 500
  prefs: []
  type: TYPE_NORMAL
- en: Since we have no other references to the original `int(1000)` object, we now
    have no way of reaching it from our code. As a result, the Python garbage collector
    is free to collect it when and if it chooses. ^([7](chap21.xhtml#fn-garbage-collection))
  prefs: []
  type: TYPE_NORMAL
- en: Assigning one reference to another
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we assign from one variable to another, what we’re really doing is assigning
    from one object reference to another object reference, so that both references
    then refer to the same object. For example, let’s assign our existing variable
    `x` to a new variable `y`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'That gives us this resulting reference-object diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Assign the existing name ''x'' to the name ''y''](images/m04----y_equals_x.png)'
  prefs: []
  type: TYPE_IMG
- en: Assign the existing name ‘x’ to the name ‘y’
  prefs: []
  type: TYPE_NORMAL
- en: 'Now both references refer to the same object. We now reassign `x` to another
    new integer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Doing this gives us a reference-object diagram showing our two references and
    our two objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Assign a new integer 3000 to ''x''](images/m04----x_equals_3000.png)'
  prefs: []
  type: TYPE_IMG
- en: Assign a new integer 3000 to ‘x’
  prefs: []
  type: TYPE_NORMAL
- en: In this case there is no work for the garbage collector to do because all of
    the objects are reachable from live references.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring value vs. identity with `id()`
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s dig a little deeper into the relationship between objects and references
    using the built-in `id()` function. `id()` accepts any object as an argument and
    returns an integer identifier which is unique and constant for the lifetime of
    the object. Let’s re-run the previous experiment using `id()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here we see that initially `a` and `b` refer to different objects and, thus,
    `id()` gives us different values for each variable. However, when we then assign
    `a` to `b`, both names refer to the same object so `id()` gives the same value
    for both. The main lesson here is that `id()` can be used to establish the *identity*
    of an object independent of any particular reference to it.
  prefs: []
  type: TYPE_NORMAL
- en: Testing for equality of identity with `is`
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In reality, the `id()` function is seldom used in production Python code. Its
    main use is in object model tutorials (such as this one!) and as a debugging tool.
    Much more commonly used than the `id()` function is the `is` operator which tests
    for equality of identity. That is, `is` tests whether two references refer to
    the same object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ve already met the `is` operator earlier, in Chapter 1, when we tested for
    `None`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: It’s critical to remember that `is` is always testing *identity equality*, that
    is, whether two references refer to the exact same object. We’ll look in-depth
    at the other primary type of equality, *value equality*, in just a bit.
  prefs: []
  type: TYPE_NORMAL
- en: Mutating without mutating
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Even operations which seem naturally mutating in nature are not necessarily
    so. Consider the augmented assignment operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: At first glance, it appears that we’re asking Python to increment the integer
    value `t` by two. But the `id()` results here clearly show that `t` refers to
    two different objects before and after the augmented assignment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rather than modifying integer objects, here’s a depiction of what’s actually
    happening. Initially, we have the name `t` referring to an `int(5)` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '![''x'' refers to the integer 5](images/m04----t_plus_eq_2_01.png)'
  prefs: []
  type: TYPE_IMG
- en: ‘x’ refers to the integer 5
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, to perform the augmented assignment of `2` to `t`, Python create an `int(2)`
    object behind the scenes. Note that we never have a named reference to this object;
    it’s managed completely by Python on our behalf:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Python creates an integer 2 behind the scenes](images/m04----t_plus_eq_2_02.png)'
  prefs: []
  type: TYPE_IMG
- en: Python creates an integer 2 behind the scenes
  prefs: []
  type: TYPE_NORMAL
- en: 'Python then performs the addition operation between `t` and the anonymous `int(2)`
    giving us — you guessed it! — another integer object, this time an `int(7)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Python creates a new integer as the result of the addition](images/m04----t_plus_eq_2_03.png)'
  prefs: []
  type: TYPE_IMG
- en: Python creates a new integer as the result of the addition
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, Python’s augmented assignment operator reassigns the name `t` to the
    new `int(7)` object, leaving the other integer objects to be handled by the garbage
    collector:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Python reassigned the name ''t'' to the result of the addition](images/m04----t_plus_eq_2_04.png)'
  prefs: []
  type: TYPE_IMG
- en: Python reassigned the name ‘t’ to the result of the addition
  prefs: []
  type: TYPE_NORMAL
- en: References to mutable objects
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Python objects show this name-binding behavior for all types. *The assignment
    operator only ever binds object to names, it never copies an object by value*.
    To help make this point crystal clear, let’s look at another example using mutable
    objects: lists. Unlike the immutable `int`s that we just looked at, `list` objects
    have mutable state, meaning that the value of a `list` object can change over
    time.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate this, we first create an list object with three elements, binding
    the list object to a reference named `r`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We then assign the reference `r` to a new reference `s`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The reference-object diagram for this situation makes it clear that we have
    two names referring to a single `list` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '![''s'' and ''r'' refer to the same list object](images/m04----s_r_list.png)'
  prefs: []
  type: TYPE_IMG
- en: ’s’ and ‘r’ refer to the same list object
  prefs: []
  type: TYPE_NORMAL
- en: 'When we modify the list referred to by `s` by changing the middle element,
    we see that the list referred to by `r` has changed as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, this is because the names `s` and `r` refer to the same *mutable* object
    ^([8](chap21.xhtml#fn-copying-lists)), a fact that we can verify by using the
    `is` keyword which we learned about earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The main point of this discussion is that Python doesn’t really have variables
    in the metaphorical sense of a box holding a value. It only has named references
    to objects, and these references behave more like labels which allow us to retrieve
    objects. That said, it’s still common to talk about variables in Python because
    it’s convenient. We will continue to do so throughout this book, secure in the
    knowledge that you now understand what’s *really* going on behind the scenes.
  prefs: []
  type: TYPE_NORMAL
- en: Equality of value (equivalence) versus equality of identity
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s contrast that behavior with a test for value-equality, or equivalence.
    We’ll create two identical lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Here we see that `p` and `q` refer to different objects, but that the objects
    they refer to have the same value.
  prefs: []
  type: TYPE_NORMAL
- en: '![''p'' and ''q'' different list objects with identical values](images/m04----p_q_lists.png)'
  prefs: []
  type: TYPE_IMG
- en: ‘p’ and ‘q’ different list objects with identical values
  prefs: []
  type: TYPE_NORMAL
- en: 'As you would expect when testing for value-equality, an object should always
    be equivalent to itself ^([9](chap21.xhtml#fn-non-identical-objects)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Value-equality and identity are fundamentally different notions of “equality”,
    and it’s important to keep them separate in your mind.
  prefs: []
  type: TYPE_NORMAL
- en: It’s also worth noting that value comparison is something that is defined programatically.
    When you define types, you can control how that class determines value-equality.
    In contrast, identity comparison is defined by the language and you can’t change
    that behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Argument passing semantics – pass by object-reference
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now let’s look at how all this relates to function arguments and return values.
    When we call a function, we literally create new name bindings — those declared
    in the function definition — to existing objects — those passed in at the call
    itself. ^([10](chap21.xhtml#fn-parameters-vs-arguments)) As such, it’s important
    to really understand Python reference semantics if you want to know how your functions
    work.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying external objects in a function
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To demonstrate Python’s argument passing semantics, we’ll define a function
    at the REPL which appends a value to a list and prints the modified list. First
    we’ll create a `list` and give it the name `m`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we’ll define a function `modify()` which appends to, and prints, the list
    passed to it. The function accepts a single formal argument named `k`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We then call `modify()`, passing our list `m` as the actual argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This indeed prints the modified list with four elements. But what does our list
    reference `m` outside the function now refer to?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The list referred to by `m` has been modified because it is the self-same list
    referred to by `k` inside the function. As we mentioned at the beginning of the
    section, when we pass an object-reference to a function we’re essentially assigning
    from the actual argument reference, in this case `m`, to the formal argument reference,
    in this case `k`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Referring to the same list in and out of a function](images/m04----list_argument.png)'
  prefs: []
  type: TYPE_IMG
- en: Referring to the same list in and out of a function
  prefs: []
  type: TYPE_NORMAL
- en: As we have seen, assignment causes the assigned-to reference to refer to the
    same object as the assigned-from reference. This is exactly what’s going on here.
    If you want a function to modify a copy of an object, it’s the responsibility
    of the function to do the copying.
  prefs: []
  type: TYPE_NORMAL
- en: Binding new objects in a function
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s look at another instructive example. First, we’ll create a new list `f`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we’ll create new a function `replace()`. As the name suggests, rather
    than modifying its arguments `replace()` will change the object that its parameter
    refers to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We now call `replace()` with actual argument `f`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This is much as we’d expect. But what’s the value of the external reference
    `f` now?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '`f` still refers to the original, unmodified list. This time, the function
    did not modify the object that was passed in. What’s going on?'
  prefs: []
  type: TYPE_NORMAL
- en: 'The answer is this: the object reference `f` was assigned to the formal argument
    named `g`, so `g` and `f` did indeed refer to the same object, just as in the
    previous example.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Initially ''f'' and ''g'' refer to the same list object](images/m04----f_g_list_01.png)'
  prefs: []
  type: TYPE_IMG
- en: Initially ‘f’ and ‘g’ refer to the same list object
  prefs: []
  type: TYPE_NORMAL
- en: However, on the first line the of the function we re-assigned the reference
    `g` to point to a newly constructed list `[17, 28, 45]`, so within the function
    the reference to the original `[14, 23, 37]` list was overwritten, although the
    unmodified object itself was still pointed to by the `f` reference outside the
    function.
  prefs: []
  type: TYPE_NORMAL
- en: '![After reassignment, ''f'' and ''g'' refer to different objects](images/m04----f_g_list_02.png)'
  prefs: []
  type: TYPE_IMG
- en: After reassignment, ‘f’ and ‘g’ refer to different objects
  prefs: []
  type: TYPE_NORMAL
- en: Argument passing is reference binding
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'So we’ve seen that it’s quite possible to modify the objects through function
    argument references, but also that it’s possible to rebind the argument references
    to new values. If you want to change the contents of a list parameter and have
    the changes seen outside the function, you could modify the contents of the list
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'And indeed, if you check the contents of `f` you’ll see that they have been
    modified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Function arguments are transferred by what is called “pass by object reference”.
    This means that the value of the *reference* is copied into the function argument,
    not the value of the referred to object; no objects are copied.
  prefs: []
  type: TYPE_NORMAL
- en: Python return semantics
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Python’s `return` statement uses the same pass-by-object-reference semantics
    as function arguments. When you return an object from a function in Python, what
    you’re really doing is passing an object reference back to the caller. If the
    caller assigns the return value to a reference, they are doing nothing more than
    assigning a new reference to the returned object. This uses the exact same semantics
    and mechanics that we saw with explicit reference assignment and argument passing.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can demonstrate this by writing a function which returns its only argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'If we create an object such as a list and pass it through this simple function,
    we see that it returns the very same object that we passed in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Remember that `is` only returns `True` when two names refer to the exact same
    objects, so example this shows that no copies of the list were made.
  prefs: []
  type: TYPE_NORMAL
- en: Function arguments in detail
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we understand the distinction between object references and objects,
    we’ll look at some more capabilities of function arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Default parameter values
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The formal function arguments specified when a function is defined with the
    `def` keyword are a comma-separated list of the argument names. These arguments
    can be made optional by providing default values. Consider a function which prints
    a simple banner to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This function takes two arguments, and we provide a default value — in this
    case `'-'` — in a literal string. When we define functions using default arguments,
    the parameters with default arguments must come after those without defaults,
    otherwise we will get a `SyntaxError`.
  prefs: []
  type: TYPE_NORMAL
- en: On line 2 of the function we multiply our border string by the length of the
    message string. This line shows two interesting features. First, it demonstrates
    how we can determine the number of items in a Python collection using the built-in
    `len()` function. Secondly, it shows how multiplying a string (in this case the
    single character string border) by an integer results in a new string containing
    the original string repeated a number of times. We use that feature here to make
    a string equal in length to our message.
  prefs: []
  type: TYPE_NORMAL
- en: On lines 3 through 5 we print the full-width border, the message, and the border
    again.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we call our `banner()` function, we don’t need to supply the border string
    because we’ve provided a default value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if we do provide the optional argument, it is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Keyword arguments
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In production code, this function call is not particularly self documenting.
    We can improve that situation by naming the `border` argument at the call site:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case the `message` string is called a “positional argument” and the
    `border` string a “keyword argument”. In a call, the positional arguments are
    matched up in sequence with the formal arguments declared in the function definition.
    The keyword arguments, on the other hand, are matched by name. If we use keyword
    arguments for both of our parameters, we have the freedom to supply them in any
    order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Remember, though, that all keyword arguments must be specified after any positional
    arguments.
  prefs: []
  type: TYPE_NORMAL
- en: When are default arguments evaluated?
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When you supply a default parameter value for a function, you do so by providing
    an *expression*. This expression can be a simple literal value, or it can be a
    more complex function call. In order to actually use the default value that you
    provide, Python has to at some point evaluate that expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s crucial, then, to have an appreciation of exactly *when* Python evaluates
    the default value expression. This will help you to avoid a common pitfall which
    frequently ensnares newcomers to Python. Let’s examine this question closely using
    the Python standard library `time` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We can easily get the current time as a readable string by using the `ctime()`
    function of the `time` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s write a function which uses a value retrieved from `ctime()` as a default
    argument value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'So far so good, but notice what happens when you call `show_default()` again
    a few seconds later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'and again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the displayed time never progresses.
  prefs: []
  type: TYPE_NORMAL
- en: Recall how we said that `def` is a statement that when executed binds a function
    definition to a function name? Well, the default argument expressions are evaluated
    only once, when the `def` statement is executed. In many cases the default value
    is a simple immutable constant like and integer or a string, so this does not
    cause any problems. But it can be a confusing trap for the unwary that usually
    shows up when you use mutable collections like lists as argument defaults.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a closer look. Consider this function which uses an empty list as
    a default argument. It accepts a menu as a list of strings, appends the item `"spam"`
    to the list, and returns the modified menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s create a simple breakfast of bacon and eggs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Naturally, we’ll add spam to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll do something similar for lunch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Nothing unexpected so far. But look what happens when you rely on the default
    argument by not passing an existing menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'When we append `''spam''` to an empty menu we get just `spam`. This is probably
    still what you expected, but if we do that again we get two `spam`s added to our
    menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'And three:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'And four:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: What’s happening here is this. First, the empty list used for the default argument
    is created exactly once, when the `def` statement is executed. This is a normal
    list like any other we’ve seen so far, and Python will use this exact list for
    the entire execution of your program.
  prefs: []
  type: TYPE_NORMAL
- en: The first time we actually use the default, then, we end up adding `spam` directly
    to the default list object. When we use the default a second time, we’re using
    the same default list object — the one to which we just added `spam` – and we
    end up adding a second instance of `"spam"` to it. The third call adds a third
    spam, *ad infinitum*. Or perhaps *ad nauseum*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution to this is straightforward, but perhaps not obvious: **Always
    use immutable objects such as integers or strings for default values**. Following
    this advice, we can solve this particular case by using the immutable `None` object
    as a sentinel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: and now our `add_spam()` function works as expected.
  prefs: []
  type: TYPE_NORMAL
- en: The Python type system
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Programming languages can be distinguished by several characteristics, but one
    of the most important is the nature of their type systems. Python can be characterized
    as having a *dynamic* and *strong* type system. Let’s investigate what that means.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic typing in Python
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Dynamic typing means that the type of an object-reference isn’t resolved until
    the program is running, and it needn’t be specified up front when the program
    is written. Take a look at this simple function for adding two objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Nowhere in this definition do we mention any types. We can use `add()` with
    integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'And we can use it for floats:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'You might be surprised to see that it even works for strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Indeed, this function works for any types, like `list`, for which the addition
    operator has been defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'These examples illustrate the dynamism of the type system: the two arguments,
    `a` and `b`, of the `add()` function can reference any types of object.'
  prefs: []
  type: TYPE_NORMAL
- en: Strong typing in Python
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The strength of the type system, on the other hand, can be demonstrated by
    attempting to `add()` types for which addition has not been defined, such as strings
    and floats:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Trying to do this results in a `TypeError` because Python will not, in general,
    perform implicit conversions between object types or otherwise attempt to coerce
    one type to another. The primary exception to this is the conversion to `bool`
    used for if-statement and while-loop predicates. ^([11](chap21.xhtml#fn-not-the-type-system))
  prefs: []
  type: TYPE_NORMAL
- en: Variable declaration and scoping
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we have seen, no type declarations are necessary in Python, and variables
    are essentially just untyped name bindings to objects. As such, they can be rebound
    – or reassigned – as often as necessary, even to object of different types.
  prefs: []
  type: TYPE_NORMAL
- en: But when we bind a name to an object, where is that binding stored? To answer
    that question, we must look at scopes and scoping rules in Python.
  prefs: []
  type: TYPE_NORMAL
- en: The LEGB rule
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There are four types of *scope* in Python, and they are arranged in a hierarchy.
    Each scope is a context in which names are stored and in which they can be looked
    up. The four scopes from narrowest to broadest are:'
  prefs: []
  type: TYPE_NORMAL
- en: Local - names defined inside the current function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enclosing - names defined inside any and all enclosing functions. (This scope
    isn’t important for the contents of this book.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Global - names defined at the top-level of a module. Each module brings with
    it a new global scope.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Built-in - names built-in to the Python language through the special `builtins`
    module.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Together, these scopes comprise the LEGB rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The LEGB Rule**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '>'
  prefs: []
  type: TYPE_NORMAL
- en: Names are looked up in the narrowest relevant context.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: It’s important to note that scopes in Python do not, in general, correspond
    to the source-code blocks as demarcated by indentation. For-loops, with-blocks,
    and the like do not introduce new nested scopes.
  prefs: []
  type: TYPE_NORMAL
- en: Scopes in action
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Consider our `words.py` module. It contains the following global names:'
  prefs: []
  type: TYPE_NORMAL
- en: '`main` - bound by `def main()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sys` - bound by `import sys`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__name__` - provided by the Python runtime'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`urlopen` - bound by `from urllib.request import urlopen`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fetch_words` - bound by `def fetch_words()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`print_items` - bound by `def print_items()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Module scope name bindings are typically introduced by `import` statements and
    function or class definitions. It is possible to use other objects at module scope,
    and this is typically used for constants, although it can also be used for variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within the `fetch_words()` function we have the six local names:'
  prefs: []
  type: TYPE_NORMAL
- en: '`word` - bound by the inner for-loop'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`line_words` - bound by assignment'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`line` - bound by the outer for-loop'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`story_words` - bound by assignment'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`url` - bound by the formal function argument'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`story` - bound by the with-statement'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each of these bindings is brought into existence at first use and continues
    to live within the function scope until the function completes, at which point
    the references will be destroyed.
  prefs: []
  type: TYPE_NORMAL
- en: Identical names in global and local scope
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Very occasionally we need to rebind a global name at module scope from within
    a function. Consider the following simple module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'If we save this module in `scopes.py`, we can import it into the REPL for experimentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: When `show_count()` is called Python looks up the name `count` in the local
    namespace (L). It doesn’t find it so looks in the next most outer namespace, in
    this case the global module namespace (G), where it finds the name `count` and
    prints the referred-to object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we call `set_count()` with a new value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'We then call `show_count()` again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: You might be surprised that `show_count()` displays `0` after the call to `set_count(5)`,
    so let’s work through what’s happening.
  prefs: []
  type: TYPE_NORMAL
- en: When we call `set_count()`, the assignment `count = c` creates a *new* binding
    for the name `count` in the *local* scope. This new binding refers, of course,
    to the object passed in as `c`. Critically, no lookup is performed for the global
    `count` defined at module scope. We have created a new variable which shadows,
    and thereby prevents access to, the global of the same name.
  prefs: []
  type: TYPE_NORMAL
- en: The `global` keyword
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To avoid this shadowing of names in the global scope, we need to instruct Python
    to resolve the name `count` in the `set_count()` function to the `count` defined
    in the module namespace. We can do this by using the `global` keyword. Let’s modify
    `set_count()` to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '`global` introduces a binding in the local scope to a name from the global
    scope.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Quit and restart the Python interpreter to exercise our revised module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: It now demonstrates the required behaviour.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Moment of zen
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '![](images/m04----zen-special-cases.png)'
  prefs: []
  type: TYPE_IMG
- en: As we have shown, all variables in Python are references to objects, even in
    the case of basic types such as integers. This thorough approach to object orientation
    is a strong theme in Python and practically everything in Python is an object,
    including functions and modules.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Everything is an object
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s go back to our `words` module and experiment with it further at the REPL.
    On this occasion we’ll import just the module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The `import` statement binds a module object to the name `words` in the current
    namespace. We can determine the type of any object by using the `type()` built-in
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to see the attributes of an object, we can use the `dir()` built-in
    function in a Python interactive session to introspect an object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'The `dir()` function returns a sorted list of the module attribute names, including:'
  prefs: []
  type: TYPE_NORMAL
- en: The ones we defined such as the function `fetch_words()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any imported names such as `sys` and `urlopen`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Various special *dunder* attributes such as `__name__` and `__doc__` which reveal
    the inner-workings of Python.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inspecting a function
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We can use the `type()` function on any of these attributes to learn more about
    them. For instance, we can see that `fetch_words` is a function object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'We can in turn use `dir()` on the function to reveal its attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: We can see here that function objects have *many* special attributes to do with
    how Python functions are implemented behind the scenes. For now, we’ll just look
    at a couple of simple attributes.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you might expect, its `__name__` attribute is the name of the function object
    as a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Likewise, `__doc__` is the docstring we provided, giving us some clues about
    how the built-in `help()` function might be implemented.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: This is just a small example of how you can introspect Python objects at runtime,
    and there are many more powerful tools that you can use to learn more about the
    objects you’re using. Perhaps the most instructive part of the example is that
    we were dealing with a *function object*, demonstrating that Python’s pervasive
    object orientation includes elements of the language that may not be accessible
    at all in other languages.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Python object references
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Think of Python working in terms of named references to objects rather than
    variables and values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assignment doesn’t put a value in a box. It attaches a name tag to an object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assigning from one reference to another puts two name tags on the same object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Python garbage collector will reclaim unreachable objects - those objects
    with no name tag.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Object identity and equivalence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `id()` function returns a unique and constant identifier but should rarely,
    if ever, be used in production.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `is` operator determines equality of identity. That is, whether two names
    refer to the same object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can test for equivalence using the double-equals operator.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function arguments and return values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function arguments are passed by object-reference, so functions can modify their
    arguments if they are mutable objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a formal function argument is rebound through assignment, the reference to
    the passed-in object is lost. To change a mutable argument you should replace
    its *contents* rather than replacing the whole object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The return statement also passes by object-reference. No copies are made.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function arguments can be specified with defaults.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Default argument expressions are evaluated only once when the `def` statement
    is executed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Python type system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python uses dynamic typing, so we don’t need to specify reference types in advance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python uses strong typing. Types are not coerced to match.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scopes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Python reference names are looked up in one of four nested scopes according
    to the LEGB rule: Local to functions, in Enclosing functions, in the Global (or
    module) namespace and Built-ins.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Global references can be read from a local scope
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assigning to global references from a local scope requires that the reference
    be declared global using the global keyword.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Objects and introspection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Everything in Python is an object, including modules and functions. They can
    be treated just like other objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `import` and `def` keywords result in binding to named references.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The built-in `type()` function can be used to determine the type of an object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The built-in `dir()` function can be used to introspect an object and return
    a list of its attribute names.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The name of a function or module object can be accessed through its `__name__`
    attribute.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The docstring for a function or module object can be accessed through its `__doc__`
    attribute.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Miscellaneous
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can use `len()` to measure the length of a string.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we “multiply” a string by an integer we get a new string with multiple copies
    of the operand string. This is called the “repetition” operation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
