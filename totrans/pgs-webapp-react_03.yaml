- en: Our App&#x27;s Login Page
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've spent the last couple of chapters getting our application completely set
    up for development with React. Now, let's go full steam ahead with building our
    application.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will create our application's login page in React. By the
    end, you should feel comfortable with basic React syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following key React concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: Separating the UI into components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing JSX
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functional components versus class components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Component state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating reusable components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is a React component?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **React component**, at the most basic level, is a piece of the user interface,
    more specifically, a section of UI devoted to a single purpose.
  prefs: []
  type: TYPE_NORMAL
- en: With React, your UI is split up into sections, sections within those sections,
    then sections within those, and so on; you get the picture. Each section is its
    own component, and lives in a separate file.
  prefs: []
  type: TYPE_NORMAL
- en: The beauty of this system may not be obvious now, but once we dive into it,
    you'll see how it makes our application much more comprehendible, that is, easy
    for us to understand and navigate as we're developing. We'll only be building
    a small application with a few components. The effect increases as your application
    grows to hundreds of components.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at a quick example of splitting a UI into components. Here''s the
    online store of Packt, the publishers of this book:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00022.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: If we were to rebuild this in React, we would start by dividing the UI into
    meaningful sections. Which parts are concerned with different purposes?
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that there is no single correct answer to this question; different developers
    will do it differently, but here''s a division that makes sense to me: splitting
    it up into a **FilterControl**, a **SearchBar**, and a **ResultsGrid**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00023.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Here's my thinking--the **FilterControl** (at the top) has to do with sorting
    and pagination, the **SearchSideBar** is all about searching for specific results,
    and the **ResultsGrid** is all about displaying matching results. Each has a very
    specific and distinct purpose.
  prefs: []
  type: TYPE_NORMAL
- en: Then, within those three components, we can make smaller divisions. Each book
    in the **ResultsGrid** can be a **BookCard** component, with a **BookInfo** and
    **BookImage** component within it, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: How fine-grained we want to make these divisions is up to us. Generally, a greater
    number of smaller components is better, but one does have to write more boilerplate
    the more components one decides to write.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other advantage of React componentization is reusability. Let''s say that,
    within our **ResultsGrid**, we make a **BookCard** component for each result.
    Then, on the Packt home page, we can reuse the same component! No more rewriting
    the same code twice in two places:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00024.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Code reusability is also why smaller components are better. If you build your
    components to maximize reusability (to fit in the greatest number of contexts),
    you can build new features out of the existing parts. This increases development
    speed and ease. We'll build a reuseable component as part of our login form, and
    plug it elsewhere as our application expands.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s jump into our `App.js` file and take a look at the first component that
    we built:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Our `App` component is a function that returns a bit of JSX. That's it. This
    is a very handy way of thinking of React components, as functions that return
    part of the view. By calling certain functions in a certain order, we construct
    our UI.
  prefs: []
  type: TYPE_NORMAL
- en: 'It does, of course, get a bit more complicated than that. However, if you ever
    feel overwhelmed by the React syntax and concepts, come back to this core principle:
    React components are just functions that return parts of the UI.'
  prefs: []
  type: TYPE_NORMAL
- en: Controversies and Separation of Concerns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When React first emerged on the scene, it was very controversial (and for many
    people, it still is). The core point of concern for many developers was JSX, having
    what appeared to be HTML in the middle of JavaScript code.
  prefs: []
  type: TYPE_NORMAL
- en: For years, developers had been writing their HTML, CSS, and JavaScript in separate
    files. React violated that tradition. Some developers accused the library of violating
    the programming principle of **Separation of Concerns** (**SoC**)--the idea that
    code should be separated into files, each intended to do one thing. In this sense,
    they argued that you should have an HTML file, a CSS file, and a JavaScript file—no
    mingling of HTML and JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: What the React developers pointed out is that separating files based on type
    (HTML versus JavaScript) was a separation of technology, not a Separation of Concerns.
    The HTML and JavaScript were both concerned with rendering a functional UI—they
    belonged together.
  prefs: []
  type: TYPE_NORMAL
- en: React proposed that if you had a button, both the HTML structure of the button
    and what made it functional (what happened when it was clicked on) should live
    in the same file, since that was all the same concern.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, the important thing to remember with React is the idea of Separation of
    Concerns—you can draw lines between your components based on what their purpose
    is.
  prefs: []
  type: TYPE_NORMAL
- en: The missing piece of all of this is, of course, CSS. Shouldn't it be in the
    same file as well? Many think so, but a mature solution to do so has yet to emerge.
    You can read more about CSS in JS at [https://medium.freecodecamp.org/css-in-javascript-the-future-of-component-based-styling-70b161a79a32](https://medium.freecodecamp.org/css-in-javascript-the-future-of-component-based-styling-70b161a79a32).
  prefs: []
  type: TYPE_NORMAL
- en: Class components versus functional components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We just defined React components as functions that return a piece of the UI.
    This is a useful way of thinking about them, and is certainly true for our `App`
    component. However, there's another way of writing React components.
  prefs: []
  type: TYPE_NORMAL
- en: Right now, our `App` component is a functional component. This means it's literally
    written as a function, but you can also write components as JavaScript classes.
    These are called **class-based** or **stateful** components (we'll talk about
    the stateful part in a bit).
  prefs: []
  type: TYPE_NORMAL
- en: 'JavaScript classes are a new feature of ES6\. They work in a similar (but not
    identical) way to classes in other languages. We won''t delve too deep into them
    here, but for our purpose, you can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Have a class extend another class (and inherit its properties)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create an instance of a class with the new keyword (that is, instantiate it)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's see an example by converting our `App` component into a class-based component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Every class component must do two things: it must extend the `Component` class
    from the React library, and it must have a `render` method.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by importing the `Component` class from React:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'For those of you unfamiliar with this syntax, it''s an example of object destructuring
    in ES6\. Consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Object destructuring turns the preceding code into this, which saves some typing,
    but does the same thing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Anyway, now that we''ve imported our `Component` class, let''s make a class
    that extends it; delete our `App` function, and write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'JavaScript classes function a lot like objects. They can have properties that
    are either values or functions (called methods). As we said earlier, we need a
    `render` method. Here''s what that looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'What does the `render` method do? In essence, when we wrote our `App` as a
    functional component, it consisted solely of a `render` method. The whole thing
    was just a big `render()`. So, the render method does what we expect from a React
    component: it returns a bit of the view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: If you start up the app (or if it's already running), you'll note that nothing
    has changed at all.
  prefs: []
  type: TYPE_NORMAL
- en: So, what is the difference between a class component and a functional component?
  prefs: []
  type: TYPE_NORMAL
- en: A best practice is to try to make as many small, functional components as possible
    in your application. They're a bit faster performance-wise, and the React team
    has expressed an interest in optimizing the library for functional components.
    They're also easier to understand.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, class components give us a lot of handy functionality. They can have
    properties, which we then use in the `render` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We can call methods from the `render` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As we discussed earlier, classes can be instantiated (in syntax such as `const
    app = new App()`). This is what React does in our `ReactDOM.render` call; it instantiates
    our `App` and then calls the `render` method to get the JSX.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, it's still useful to think of React components as functions that
    return bits of view. Class components just add a little extra functionality wrapped
    around that `render` function.
  prefs: []
  type: TYPE_NORMAL
- en: Our second component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've made one React component; let's make another!
  prefs: []
  type: TYPE_NORMAL
- en: As we discussed earlier, the goal of this chapter is to create our application's
    login page. First, let's create a folder called `components/` in our `src` folder,
    and then inside, let's create a file called `LoginContainer.js`.
  prefs: []
  type: TYPE_NORMAL
- en: If you still have the folder from our [Chapter 2](part0048.html#1DOR00-7dd7c66301294003b85168009fe95fa4),
    *Getting Started with* *Webpack*, with `Component1.js`, `Component2.js`, and `Component3.js`,
    feel free to delete those files now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `LoginContainer` will be another class component, for reasons that we''ll
    look at down the road. Just as with our app, let''s set up a basic class component
    skeleton:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Let's test out rendering our component before we dive any further in. Return
    a simple `<h1>Hello from LoginContainer</h1>` from our `render` method; then,
    let's jump back to our `App.js`.
  prefs: []
  type: TYPE_NORMAL
- en: 'I''m a bit of a stickler for code organization, so before we go on, let''s
    move our `App.js` inside our `components` folder. This also means that we''ll
    have to change our import statement in `index.js` to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, move our `app.css` inside the `components` folder, and then change our
    hot reloader configuration inside `index.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Now that all our components are living together in the same folder, it's much
    better.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside `App.js`, we first import the `LoginContainer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we `render` it instead of the `<h1>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Flip back to the app, and you should see the Hello from LoginContainer of our
    new component:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00025.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'As we shall see as we build more components, our `App` will be a wrapper for
    our main `Container` component. It''ll be, in essence, a container for our Containers.
    Inside `App.js`, let''s wrap our `LoginContainer` in a `div#container` for CSS
    purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Alright, getting back to `LoginContainer.js`, let's write some JSX!
  prefs: []
  type: TYPE_NORMAL
- en: 'Delete our `<h1>` tag and replace it with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This is a pattern I really like--having most React components wrapped in a `div`
    with an `id` of the class name; it's just a preference, though (a preference you'll
    have to follow for this book, since I wrote the CSS!).
  prefs: []
  type: TYPE_NORMAL
- en: Note the brackets around the JSX! This format makes multiline JSX much more
    readable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The essence of our login form is, of course, a form. This form will handle
    both login and signup. Here''s the basic JSX:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding JSX, you may note that I wrote `className` instead of class
    for the `<button>`. Remember that I said JSX had a few caveats? This is one: since
    class is a protected keyword in JavaScript, we can''t use it, so we use `className`
    instead. You''ll get used to it in no time.'
  prefs: []
  type: TYPE_NORMAL
- en: On that note, pay attention to the `ID` and `className` in the preceding JSX,
    otherwise your CSS won't look spiffy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Above our form, we''ll write a basic header with our logo:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Your app should now look like this (if you haven''t done so, delete the `<h1>`
    and `<img>` tags from `index.html`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00026.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Looks pretty, but what does it do?
  prefs: []
  type: TYPE_NORMAL
- en: State in React
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every React component has something called **state.** You can think of this
    as the configuration of the component at a certain point of time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take, for example, a heart icon that turns red when you click on it, as in
    the case of Twitter. The button has two states: **unclicked** and **clicked***.*
    Clicking on the button causes its state, and thus its appearance, to change.'
  prefs: []
  type: TYPE_NORMAL
- en: That's the flow in React; user actions or events cause the component state to
    change, which causes the component's appearance to change.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding statement comes with an enormous helping of "Well, not always…,"
    but it''s a useful starting point to understand state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Let's add some `state` to our `LoginContainer`, and then go from there.
  prefs: []
  type: TYPE_NORMAL
- en: 'State is easy to define; it''s an object that is the property of the class.
    We can define it as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We always define `state` at the top of our component.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then access our `state` right in the `render` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the curly braces inside JSX mean we're inserting some
    Javascript code.
  prefs: []
  type: TYPE_NORMAL
- en: This is how we initialize our `state`, but this state isn't very useful, since
    there’s no mechanism for changing it.
  prefs: []
  type: TYPE_NORMAL
- en: What we need to do is to provide a way to respond to user events, and modify
    the state based on them.
  prefs: []
  type: TYPE_NORMAL
- en: What if the text changed when the user clicked on Hello from state!?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add an `onClick` property to our `h1` tag, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'It references a method on our class called `handleClick`, which we can define
    as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Inside `handleClick`, we want to change our state. We can do that in React via
    a function called `this.setState`, into which we pass the new state object.
  prefs: []
  type: TYPE_NORMAL
- en: Try it out! When you click on Hello from state!, it should immediately change
    to the new text.
  prefs: []
  type: TYPE_NORMAL
- en: So, how does this work? What `setState` does is to take the object passed in
    as an argument and merge it into the current state (if you have multiple properties
    in state but only pass in an object with one property to `setState`, it'll change
    only that property, rather than overwriting the rest). Then, it calls the `render()`
    method again, and our component is updated in the DOM to reflect the new state.
  prefs: []
  type: TYPE_NORMAL
- en: If this seems confusing, don't worry, we have a couple more examples to go through,
    so you’ll get a bit more practice with component state.
  prefs: []
  type: TYPE_NORMAL
- en: Our `LoginContainer` will have two pieces of state, one to go with each `<input>`
    tag. We will store what the user types in the email and password fields in state
    so that when they submit the form, we can access them.
  prefs: []
  type: TYPE_NORMAL
- en: '"Hold on Scott," you may say, "Why don''t we just reach into the DOM and grab
    the value of each input when the user submits the form, the jQuery way?"'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can certainly do that, but it will break the React flow, which is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This way, our input's value is stored in state and the view is kept in sync
    with it, rather than having our input's value stored as a property of a DOM element,
    and accessed when needed.
  prefs: []
  type: TYPE_NORMAL
- en: The advantage of this approach may not seem obvious at this point, but it makes
    our code much more explicit and understandable.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in the preceding flow, we need to update our state whenever the user changes
    an input. First, let''s change how our state initializes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, let''s delete `handleClick` and add the `handleEmailChange` and `handlePasswordChange`
    methods to our component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The preceding methods take in an event (the user typing in the field), grab
    the value from the event, and then set state to that value.
  prefs: []
  type: TYPE_NORMAL
- en: Again, note that we don't have to define both the email and password every time
    we call `setState`; it will merge in the changes to the existing state object
    without overwriting the other values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, now the last step. Let''s add the `onChange` properties to our inputs,
    which call our change handlers. Another crucial step is that our input''s `value`
    must be derived from state. We can do so like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: You can reset your `h1` to `<h1>Chatastrophe</h1>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If everything worked out, you should note no change in how your input functions
    (if there''s a typo in your code, you won''t be able to type in one or the other).
    Let''s ensure that it''s actually working by adding a handler for when our form
    submits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'And our method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The preceding method will just log out the state for us when the user submits
    the form (clicks on the button), and prevent the form from actually submitting.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try typing in both fields and then click on Submit. You should see a console
    log with the `state` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We did it! Our first React component with state.
  prefs: []
  type: TYPE_NORMAL
- en: 'I hope you''ve gotten a sense of the React data flow. Our application has state
    (stored in different components), which updates in response to events (often user-initiated),
    which causes parts of our application to rerender in response to the new state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: It's a simple pattern once you wrap your head around it, and makes it easy to
    trace why your application looks the way it does at any point of time.
  prefs: []
  type: TYPE_NORMAL
- en: Reusing components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There's one more change I want to make before we finish up with our `LoginContainer`
    skeleton.
  prefs: []
  type: TYPE_NORMAL
- en: We talked earlier about making React components reusable, so you can implement
    the same code in multiple places in your application. We should try to split our
    UI into as many small and reusable pieces as possible to save us time, and I see
    a great candidate in our `LoginContainer`.
  prefs: []
  type: TYPE_NORMAL
- en: '`LoginContainer` won''t be our only container. In the next few chapters, we''ll
    create new pages with different content, but we want them to have the same look,
    and we''ll want to have the Chatastrophe logo and title at the top in the same
    place as it is now.'
  prefs: []
  type: TYPE_NORMAL
- en: What I propose is that we make a new `Header` component that we can save for
    future use.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we made our `LoginContainer` a class component because we needed to use
    state and methods. Our header, on the other hand, won't have any state or functionality;
    it's literally just a piece of UI. The best choice is to make it a functional
    component, because we can.
  prefs: []
  type: TYPE_NORMAL
- en: The rule for a class versus a functional component is essentially make a component
    functional wherever you can, unless you need state or methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside our `src/` components folder, make a new file called `Header.js`. Then,
    we can create the skeleton of a functional component. Copy and paste the relevant
    `div#Header` from `LoginContainer` and add it as the `return` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, back in our `LoginContainer`, we want to import our header, as illustrated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we can replace the `div#Header` with a simple `<Header />` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Another JSX gotcha--all JSX tags must be closed. You can’t just use `<Header>`.
  prefs: []
  type: TYPE_NORMAL
- en: That's it! That's all it takes to make a small, reusable component. Our `LoginContainer`
    now looks cleaner, and we’ve saved ourselves some typing down the road.
  prefs: []
  type: TYPE_NORMAL
- en: Our login form looks fantastic, but there's a problem. As you demo it for the
    team at Chatastrophe headquarters (the team having somehow swelled to twenty,
    despite you being the only developer), an intern raises her hand--"How does it
    actually, you know, work?"
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We created our first stateful React component, a login form. We learned all
    about React components, and best practices for creating them. We then built our
    login form and covered how to handle changes to the form, updating our state.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, a login form that only logs out the email and password isn't
    that useful (or secure!). Our next step will be to set up the backend of our application
    so that users can actually create accounts and log in.
  prefs: []
  type: TYPE_NORMAL
