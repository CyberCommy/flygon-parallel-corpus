- en: '*Chapter 9*: Angular and the Angular CDK'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Angular has an amazing ecosystem of tools and libraries, be it Angular Material,
    the **Angular command-line interface** (**Angular CLI**), or the beloved **Angular
    Component Dev Kit** (**Angular CDK**). I call it "beloved" because if you are
    to implement your own custom interactions and behaviors in Angular apps without
    having to rely on an entire set of libraries, Angular CDK is going to be your
    best friend. In this chapter, you'll learn what an amazing combination Angular
    and the Angular CDK are. You'll learn about some neat components built into the
    CDK and will also use some CDK **application programming interfaces (APIs)** to
    create amazing and optimized content.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the recipes we''re going to cover in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Using Virtual Scroll for huge lists
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keyboard navigation for lists
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pointy little popovers with the Overlay API
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using CDK Clipboard to work with the system clipboard
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using CDK Drag and Drop to move items from one list to another
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a multi-step game with the CDK Stepper API
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resizing text inputs with the CDK TextField API
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the recipes in this chapter, make sure you have **Git** and **Node.js**
    installed on your machine. You also need to have the `@angular/cli` package installed,
    which you can do with `npm install -g @angular/cli` from your terminal. The code
    for this chapter can be found at [https://github.com/PacktPublishing/Angular-Cookbook/tree/master/chapter09.](https://github.com/PacktPublishing/Angular-Cookbook/tree/master/chapter09.)
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Using Virtual Scroll for huge lists
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There might be certain scenarios in your application where you might have to
    show a huge set of items. This could be from either your backend API or the browser's
    local storage. In either case, rendering a lot of items at once causes performance
    issues because the **Document Object Model** (**DOM**) struggles, and also because
    of the fact that the JS thread gets blocked and the page becomes unresponsive.
    In this recipe, we'll render a list of 10,000 users and will use the Virtual Scroll
    functionality from the Angular CDK to improve the rendering performance.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The project that we are going to work with resides in `chapter09/start_here/using-cdk-virtual-scroll`,
    inside the cloned repository. Proceed as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Open the project in **Visual Studio Code** (**VS Code**).
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the terminal and run `npm install` to install the dependencies of the project.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once done, run `ng serve -o`.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This should open the app in a new browser tab, and it should look like this:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1 – The using-cdk-virtual-scroll app running on http://localhost:4200'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_9.1_B15150.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.1 – The using-cdk-virtual-scroll app running on http://localhost:4200
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the app running locally, let's see the steps of the recipe
    in the next section.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have a pretty simple Angular app, but with a lot of data. Right now, it
    shows a loader (button) for about 3 seconds, and then is supposed to show the
    data. However, you''ll notice that right after 3 seconds, the loader keeps showing,
    the button is unresponsive, and we see a blank screen, as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.2 – App stuck with a blank screen while rendering list items'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_9.2_B15150.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.2 – App stuck with a blank screen while rendering list items
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: 'In fact, our entire application becomes unresponsive. If you scroll through—or
    even hover over—the items, you''ll see that the hover animation on the list items
    is not smooth and is a bit laggy. Let''s see the steps to use Angular CDK Virtual
    Scroll to improve the rendering performance, as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: 'First, open a new terminal window/tab and make sure you''re inside the `ch8/start_here/using-cdk-virtual-scroll`
    folder. Once inside, run the following command to install the Angular CDK:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You'll have to restart your Angular server, so rerun the `ng serve` command.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the `ScrollingModule` class from the `@angular/cdk` package into your `app.module.ts`
    file, as follows:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We now have to implement the virtual scroll, modify the `the-amazing-list-item.component.html`
    file to use the `*cdkVirtualFor` directive instead of the `*ngFor` directive,
    and change the container `<div>` element to a `<cdi-virtual-scroll-viewport>`
    element, as follows:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Kaboom! Within a few steps, and by using the Angular CDK Virtual Scroll, we
    were able to fix a big rendering issue within our Angular app. Now that you know
    how the basic routing is implemented, see the next section to understand how it
    works.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Angular CDK provides the Scrolling APIs, which include the `*cdkVirtualFor`
    directive and the `<cdk-virtual-scroll-viewport>` element. It is necessary to
    have `<cdk-virtual-scroll-viewport>` wrapping the element that has the `*cdkVirtualFor`
    directive being applied to it. Notice that we have an attribute on the `cdk-virtual-scroll-viewport`
    element named `[itemSize]`, having its value set to `"110"`. The reason for this
    is that each list item has a height of approximately 110 pixels, as shown in the
    following screenshot:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.3 – Each list item has a height of approximately 110 pixels'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_9.3_B15150.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.3 – Each list item has a height of approximately 110 pixels
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: But how does it improve the rendering performance? Glad you asked! In the original
    code for this recipe, when we loaded the 10,000 users, it would create a separate
    `<div>` element with the `class="list__item list-group-item"` attribute for each
    user, thus creating 10,000 DOM elements all being rendered at once. With virtual
    scroll in place, the CDK only creates a few `<div>` elements, renders them, and
    just replaces the content of those few `<div>` elements as we scroll through items.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: 'For our example, it creates exactly nine `<div>` elements, as shown in the
    following screenshot:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.4 – Showing only a few <div> elements rendered on DOM due to virtual
    scroll'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_9.4_B15150.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.4 – Showing only a few <div> elements rendered on DOM due to virtual
    scroll
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: Since we only have a few elements rendered on the DOM, we don't have performance
    issues anymore, and the hover animation also seems super-smooth now.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: When implementing virtual scroll in your own applications, make sure that you
    set a specific height to the `<cdk-virtual-scroll viewport>` element, and also
    set the `[itemSize]` attribute equal to the expected list-item height in pixels,
    otherwise the list won't show.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: CDK scrolling examples ([https://material.angular.io/cdk/scrolling/examples](https://material.angular.io/cdk/scrolling/examples))
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keyboard navigation for lists
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Accessibility is one of the most important aspects of building apps with a great
    user experience. The apps should not only be fast and performant but also accessible.
    While there are a lot of things to consider when it comes to accessibility, in
    this recipe, we're going to make lists and list items more accessible by providing
    keyboard navigation for the items. With Angular CDK, it is super simple. We're
    going to use the **ListKeyManager** service from Angular to implement keyboard
    navigation for the users list in our target application.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The project for this recipe resides in `chapter09/start_here/using-list-key-manager`.
    Proceed as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: Open the project in VS Code.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the terminal and run `npm install` to install the dependencies of the project.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once done, run `ng serve -o`.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This should open the app in a new browser tab, as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.5 – The using-list-key-manager app running on http://localhost:4200'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_9.5_B15150.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.5 – The using-list-key-manager app running on http://localhost:4200
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: "Now that we have the app running locally, let's see the steps of the recipe\
    \ in the \Lnext section."
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have an app that already has some of the goodness of the Angular CDK—that
    is, it has virtual scroll implemented from the previous recipe. We''ll now start
    making changes to the app to implement keyboard navigation, as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to create a new component for each item in the list as we''ll
    need them to be able to work with the `ListKeyManager` class. Create a component
    by running the following command in the project:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, we''ll move the code from the `the-amazing-list-component.html` file to
    the `the-amazing-list-item.component.html` file for the item''s markup. The code
    in the `the-amazing-list-item.component.html` file should look like this:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let''s update the respective component as well to include this `item` property
    used in the template. We''ll make it an `@Input()` item for the `TheAmazingListItemComponent`
    class. Update the `the-amazing-list-item.component.ts` file, as follows:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let''s add the styles as well. We''ll copy the styles from the `the-amazing-list.component.scss`
    file and paste them into the `the-amazing-list-item.component.scss` file, as follows:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Update the `the-amazing-list.component.scss` file to contain only the styles
    for the list, as follows:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, update the `the-amazing-list.component.html` file to use the `<app-the-amazing-list-item>`
    component and to pass the `[item]` attribute to it, as follows:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，更新`the-amazing-list.component.html`文件，使用`<app-the-amazing-list-item>`组件，并将`[item]`属性传递给它，如下所示：
- en: '[PRE8]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The **user interface** (**UI**) is almost done now. We''ll now implement the
    `FocusableOption` interface and some accessibility factors to our `TheAmazingListItemComponent`
    class, as follows:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**用户界面**（**UI**）现在几乎完成了。我们现在将实现`FocusableOption`接口和一些辅助功能到我们的`TheAmazingListItemComponent`类，如下所示：'
- en: '[PRE9]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We now need to implement what happens in the `focus()` method. We''ll use the
    `ElementRef` service to get the `nativeElement` and will set `focus()` on it,
    as follows:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要实现`focus()`方法中发生的事情。我们将使用`ElementRef`服务来获取`nativeElement`，并将`focus()`设置为它，如下所示：
- en: '[PRE10]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We now need to implement the `FocusKeyManager` class in our `TheAmazingListComponent`
    class. We''ll have to query our list items in the component to create an instance
    of the `FocusKeyManager` class. Update the `the-amazing-list.component.ts` file,
    as follows:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要在我们的`TheAmazingListComponent`类中实现`FocusKeyManager`类。我们将不得不在组件中查询我们的列表项，以创建`FocusKeyManager`类的实例。更新`the-amazing-list.component.ts`文件，如下所示：
- en: '[PRE11]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Finally, we need to listen to the keyboard events. For this, you could either
    use a `keydown` event or a `window:keydown` event. For simplicity of the recipe,
    we''ll go with the `window:keydown` event, as follows:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要监听键盘事件。为此，您可以使用`keydown`事件或`window:keydown`事件。为了简化示例，我们将使用`window:keydown`事件，如下所示：
- en: '[PRE12]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Awesomesauce! You've just learned how to implement keyboard navigation using
    the Angular CDK. See the next section to understand how it works.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！您刚刚学会了如何使用Angular CDK实现键盘导航。请查看下一节以了解其工作原理。
- en: How it works…
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The Angular CDK provides the `ListKeyManager` class, which allows you to implement
    keyboard navigation. There are a bunch of techniques we can use with the `ListKeyManager`
    class, and for this particular recipe, we chose the `FocusKeyManager` class. In
    order to make it work for a list of items, we need to do the following things:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Angular CDK提供了`ListKeyManager`类，允许您实现键盘导航。我们可以使用`ListKeyManager`类的一堆技术，对于这个特定的示例，我们选择了`FocusKeyManager`类。为了使其适用于项目列表，我们需要做以下事情：
- en: Create a component for each item in the list.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为列表中的每个项目创建一个组件。
- en: Use `ViewChildren()` with `QueryList` in the list component to query all the
    list-item components.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在列表组件中使用`ViewChildren()`和`QueryList`查询所有列表项组件。
- en: Create a `FocusKeyManager` instance in the list component, providing the type
    of the list-item component.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在列表组件中创建一个`FocusKeyManager`实例，提供列表项组件的类型。
- en: Add a keyboard listener to the list component and pass the event to the instance
    of the `FocusKeyManager` class.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为列表组件添加键盘监听器，并将事件传递给`FocusKeyManager`类的实例。
- en: When we define the `listKeyManager` property in the `TheAmazingListComponent`
    class, we define its type as well by specifying it as `FocusKeyManager<TheAmazingListItemComponent>`.
    This makes it easier to understand that our `FocusKeyManager` class is supposed
    to work with an array of `TheAmazingListItemComponent` elements. Therefore, in
    the `ngAfterViewInit()` method, we specify `this.listKeyManager = new FocusKeyManager(this.listItemsElements);`,
    which provides a queried list of `TheAmazingListItemComponent` elements.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在`TheAmazingListComponent`类中定义`listKeyManager`属性时，我们还通过将其指定为`FocusKeyManager<TheAmazingListItemComponent>`来定义其类型。这样更容易理解我们的`FocusKeyManager`类应该与`TheAmazingListItemComponent`元素数组一起工作。因此，在`ngAfterViewInit()`方法中，我们指定`this.listKeyManager
    = new FocusKeyManager(this.listItemsElements);`，这提供了一个查询到的`TheAmazingListItemComponent`元素列表。
- en: Finally, when we listen to the `window:keydown` event, we take the `keydown`
    event received in the handler and provide it to the instance of our `FocusKeyManager`
    class as `this.listKeyManager.onKeydown(event);`. This tells our `FocusKeyManager`
    instance which key was pressed and what it has to do.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当我们监听 `window:keydown` 事件时，我们将在处理程序中接收到的 `keydown` 事件提供给我们的 `FocusKeyManager`
    类的实例作为 `this.listKeyManager.onKeydown(event);`。这告诉我们的 `FocusKeyManager` 实例哪个键被按下以及它必须做什么。
- en: Notice that our `TheAmazingListItemComponent` class implements the `FocusableOption`
    interface, and it also has the `focus()` method, which the `FocusKeyManager` class
    uses behind the scenes when we press the keyboard arrow-down or arrow-up keys.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们的 `TheAmazingListItemComponent` 类实现了 `FocusableOption` 接口，并且它还有 `focus()`
    方法，当我们按下键盘的向下箭头或向上箭头键时，`FocusKeyManager` 类在幕后使用它。
- en: See also
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Angular CDK accessibility documentation ([https://material.angular.io/cdk/a11y/overview](https://material.angular.io/cdk/a11y/overview))
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular CDK 可访问性文档 ([https://material.angular.io/cdk/a11y/overview](https://material.angular.io/cdk/a11y/overview))
- en: Pointy little popovers with the Overlay API
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Overlay API 创建尖尖的小弹出窗口
- en: This is one of the advanced recipes in this book, especially for those of you
    who have already been working with Angular for a while. In this recipe, we'll
    not only create some popovers using the CDK Overlay API, but we'll also make them
    pointy, just like tooltips, and that's where the fun lies.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这是本书中的高级食谱之一，特别是对于那些已经使用 Angular 一段时间的人来说。在这个食谱中，我们不仅将使用 CDK Overlay API 创建一些弹出窗口，还将使它们变得尖尖，就像工具提示一样，这就是乐趣所在。
- en: Getting ready
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The project for this recipe resides in `chapter09/start_here/pointy-little-popovers`.
    Proceed as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 此食谱的项目位于 `chapter09/start_here/pointy-little-popovers`。请按照以下步骤进行：
- en: Open the project in VS Code.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 VS Code 中打开项目。
- en: Open the terminal and run `npm install` to install the dependencies of the project.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并运行 `npm install` 来安装项目的依赖项。
- en: Once done, run `ng serve -o`.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，运行 `ng serve -o`。
- en: 'This should open the app in a new browser tab, as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该在新的浏览器选项卡中打开应用程序，如下所示：
- en: '![Figure 9.6 – The pointy-little-popovers app running on http://localhost:4200'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.6 - pointy-little-popovers 应用程序在 http://localhost:4200 上运行'
- en: '](image/Figure_9.6_B15150.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_9.6_B15150.jpg)'
- en: Figure 9.6 – The pointy-little-popovers app running on http://localhost:4200
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.6 - pointy-little-popovers 应用程序在 http://localhost:4200 上运行
- en: Now that we have the app running locally, let's see the steps of the recipe
    in the next section.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在本地运行了应用程序，让我们在下一节中看一下食谱的步骤。
- en: How to do it…
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Our app has a list of users that we can scroll through on the page. We''ll
    add a popover menu to each item so that a drop-down menu is shown with some actions.
    We already have the `@angular/cdk` package installed, so we don''t need to worry
    about that. Let''s start with the recipe, as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序有一个用户列表，我们可以在页面上滚动查看。我们将为每个项目添加一个弹出菜单，以便显示带有一些操作的下拉菜单。我们已经安装了 `@angular/cdk`
    包，所以我们不需要担心。让我们按照以下食谱开始：
- en: 'First, we need to install the `@angular/cdk` as we need to import the `OverlayModule`
    class into our `AppModule` class so that we can use the Overlay API. Update the
    `app.module.ts` file, as follows:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要安装 `@angular/cdk`，因为我们需要将 `OverlayModule` 类导入到我们的 `AppModule` 类中，以便我们可以使用
    Overlay API。更新 `app.module.ts` 文件，如下所示：
- en: '[PRE13]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We''ll first add the Overlay''s default styles so that when the overlay is
    displayed, it is positioned correctly. Open the `src/styles.scss` file and update
    it as per the following gist:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先添加 Overlay 的默认样式，以便在显示覆盖层时，它能正确定位。打开 `src/styles.scss` 文件，并按照以下要点进行更新：
- en: '[https://gist.github.com/AhsanAyaz/b039814e898b3ebe471b13880c7b4270](https://gist.github.com/AhsanAyaz/b039814e898b3ebe471b13880c7b4270)'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://gist.github.com/AhsanAyaz/b039814e898b3ebe471b13880c7b4270](https://gist.github.com/AhsanAyaz/b039814e898b3ebe471b13880c7b4270)'
- en: 'Now, we''ll create variables to hold the overlay trigger (for the origin of
    the positions of the opened overlay) and the actual relative position''s settings.
    Open the `the-amazing-list.component.ts` file and update it, as follows:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将创建变量来保存覆盖层触发器（用于打开覆盖层的位置起点）和实际相对位置的设置。打开`the-amazing-list.component.ts`文件并进行更新，如下所示：
- en: '[PRE14]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, open the `the-amazing-list.component.html` file and add the `cdkOverlayOrigin`
    directive to the `<app-the-amazing-list-item>` selector so that we can have each
    list item as an origin for the pop-up menu, as follows:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开`the-amazing-list.component.html`文件，并将`cdkOverlayOrigin`指令添加到`<app-the-amazing-list-item>`选择器中，以便我们可以将每个列表项作为弹出菜单的起点，如下所示：
- en: '[PRE15]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We need to somehow pass the `#itemTrigger` variable from the template to assign
    its value to the `popoverMenuTrigger` property in the `TheAmazingListComponent`
    class. To do so, create a method named `openMenu()` in the `the-amazing-list.component.ts`
    file, as follows:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要以某种方式将模板中的`#itemTrigger`变量传递到`TheAmazingListComponent`类中的`popoverMenuTrigger`属性上。为此，在`the-amazing-list.component.ts`文件中创建一个名为`openMenu()`的方法，如下所示：
- en: '[PRE16]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We also need a property to show/hide the popover menu. Let''s create it and
    set it to `true` in the `openMenu()` method as well. Update the `the-amazing-list.component.ts`
    file, as follows:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要一个属性来显示/隐藏弹出菜单。让我们在`openMenu()`方法中创建它，并将其设置为`true`。更新`the-amazing-list.component.ts`文件，如下所示：
- en: '[PRE17]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We''ll now create an actual overlay. To do so, we''ll create an `<ng-template>`
    element with the `cdkConnectedOverlay` directive. Modify your `the-amazing-list.component.html`
    file, as follows:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个实际的覆盖层。为此，我们将创建一个带有`cdkConnectedOverlay`指令的`<ng-template>`元素。修改您的`the-amazing-list.component.html`文件，如下所示：
- en: '[PRE18]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We need to pass the `#itemTrigger` variable that we have on each list item
    to the `openMenu()` method on a click of the list item. Update the file, as follows:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要在单击列表项时将每个列表项上的`#itemTrigger`变量传递给`openMenu()`方法。更新文件，如下所示：
- en: '[PRE19]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: If you refresh the app now and click on any of the list items, you should see
    a drop-down menu being shown, as follows:![Figure 9.7 – Working drop-down menu
    for each list item
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果现在刷新应用程序并单击任何列表项，您应该看到显示一个下拉菜单，如下所示：![图9.7 - 每个列表项的工作下拉菜单
- en: '](image/Figure_9.7_B15150.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_9.7_B15150.jpg)'
- en: Figure 9.7 – Working drop-down menu for each list item
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.7 - 每个列表项的工作下拉菜单
- en: 'We now have to implement the part where we show a pointy little arrow with
    the drop-down menu so that we can correlate the drop-down menu with the list item.
    First, add the following styles to the `.popover-menu` class in the `src/styles.scss`
    file:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要实现一个部分，其中我们显示一个带有下拉菜单的尖小箭头，以便我们可以将下拉菜单与列表项相关联。首先，在`src/styles.scss`文件的`.popover-menu`类中添加以下样式：
- en: '[PRE20]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'You should now be able to see a pointy arrow on the top right of the drop-down
    menu, but if you try clicking the last item on the screen, you''ll see that the
    drop-down menu opens upward but still shows the pointer at the top, as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您应该能够在下拉菜单的右上方看到一个尖箭头，但是如果您尝试点击屏幕上的最后一个项目，您会发现下拉菜单向上打开，但仍然显示在顶部的指针，如下所示：
- en: '![Figure 9.8 – Drop-down arrow pointing at the wrong list item'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.8 - 指向错误列表项的下拉箭头'
- en: '](image/Figure_9.8_B15150.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_9.8_B15150.jpg)'
- en: Figure 9.8 – Drop-down arrow pointing at the wrong list item
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.8 - 指向错误列表项的下拉箭头
- en: 'To point to the actual origin of the popover/drop-down menu, we need to implement
    a custom directive that applies a custom class. Let''s start by creating a directive,
    as follows:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了指向弹出菜单/下拉菜单的实际起点，我们需要实现一个应用自定义类的自定义指令。让我们首先创建一个指令，如下所示：
- en: '[PRE21]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Update the code in the `popover-positional-class.directive.ts` generated file
    as per the following gist:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据以下要点更新`popover-positional-class.directive.ts`生成的文件中的代码：
- en: '[https://gist.github.com/AhsanAyaz/f28893e90b71cc03812287016192d294](https://gist.github.com/AhsanAyaz/f28893e90b71cc03812287016192d294)'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://gist.github.com/AhsanAyaz/f28893e90b71cc03812287016192d294](https://gist.github.com/AhsanAyaz/f28893e90b71cc03812287016192d294)'
- en: 'Now, open the `the-amazing-list.component.html` file to apply our directive
    to the `cdkConnectedOverlay` directive. Update the `<ng-template>` element in
    the file, as follows:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开`the-amazing-list.component.html`文件，将我们的指令应用到`cdkConnectedOverlay`指令上。更新文件中的`<ng-template>`元素如下：
- en: '[PRE22]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We now need to create a `menuPopoverOrigin` property and a `popoverPositionChanged()`
    method in our `the-amazing-list.component.ts` file. Update this, as follows:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要在`the-amazing-list.component.ts`文件中创建一个`menuPopoverOrigin`属性和一个`popoverPositionChanged()`方法。更新如下：
- en: '[PRE23]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Finally, let''s reverse the popover pointer using this inverse class. Update
    the `src/styles.scss` file to add the following styles:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们使用这个反转类来反转弹出指针。更新`src/styles.scss`文件以添加以下样式：
- en: '[PRE24]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'And voilà! If you now refresh the page and tap each of the list items, you''ll
    see the arrows point in the correct direction. See the following screenshot to
    view the popover arrow pointing downward for the last item, due to the popover
    being shown above the item:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，刷新页面并点击每个列表项，你会看到箭头指向正确的方向。查看下面的截图，查看由于弹出框显示在项目上方，箭头指向最后一个项目的下方：
- en: '![Figure 9.9 – Drop-down arrow pointing at the correct list item (pointing
    downward)'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.9 - 下拉箭头指向正确的列表项（向下指）'
- en: '](image/Figure_9.9_B15150.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_9.9_B15150.jpg)'
- en: Figure 9.9 – Drop-down arrow pointing at the correct list item (pointing downward)
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.9 - 下拉箭头指向正确的列表项（向下指）
- en: Great! You now know how to use the Angular CDK to work with overlays to create
    custom pop-up/drop-down menus. Moreover, you now know how to quickly implement
    the pointy arrows on the menu using a custom directive. See the next section to
    understand how it all works.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！现在你知道如何使用Angular CDK来处理叠加层，创建自定义弹出/下拉菜单。此外，你现在知道如何快速实现菜单上的尖箭头，使用自定义指令。查看下一节，了解它是如何工作的。
- en: How it works…
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Implementing an overlay using the Angular CDK Overlay API includes a couple
    of pieces to work with. We first have to import the `OverlayModule` class in our
    `AppModule` imports. Then, for creating an overlay, we need to have an overlay
    and an overlay trigger. In this recipe, since we're using the overlay to create
    a popover menu for each list item, we use the `cdkOverlayOrigin` directive on
    the `<app-the-amazing-list-item>` elements. Notice that the `<app-the-amazing-list-item>`
    elements are being rendered through the `*ngFor` directive. Therefore, in order
    to know which item was clicked or precisely which item we need to show the popover
    for, we create a `#itemTrigger` template variable on each list-item element, and
    you'll notice that we also bind the `(click)` event on the list items to call
    the `openMenu()` method, passing this `itemTrigger` template variable into it.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Angular CDK Overlay API实现叠加层包括一些要处理的部分。首先，我们必须在`AppModule`的imports中导入`OverlayModule`类。然后，为了创建一个叠加层，我们需要有一个叠加层和一个叠加触发器。在这个示例中，因为我们使用叠加层为每个列表项创建一个弹出菜单，我们在`<app-the-amazing-list-item>`元素上使用`cdkOverlayOrigin`指令。注意，`<app-the-amazing-list-item>`元素是通过`*ngFor`指令渲染的。因此，为了知道点击了哪个项目或者准确地说我们需要为哪个项目显示弹出框，我们在每个列表项元素上创建一个`#itemTrigger`模板变量，并且你会注意到我们还将`(click)`事件绑定到列表项上，调用`openMenu()`方法，并将这个`itemTrigger`模板变量传递给它。
- en: 'Now, if you have noticed the `openMenu()` method in the `the-amazing-list.component.ts`
    file, it looks like this:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你注意到`the-amazing-list.component.ts`文件中的`openMenu()`方法，它看起来像这样：
- en: '[PRE25]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Notice that we assign the `itemTrigger` property to our class's `popoverMenuTrigger`
    property. This is because this `popoverMenuTrigger` property is being bound with
    the actual overlay in our template. You can also see that we set the `menuShown`
    property to `true`, and this is because it will decide whether the overlay should
    be shown or hidden.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s see the code for the actual overlay, as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Let''s discuss each of the `cdkConnectedOverlay` directive''s attributes, one
    by one:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: 'The `cdkConnectedOverlay` attribute: This is the actual overlay directive that
    makes the `<ng-template>` element an Angular CDK overlay.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `[cdkConnectedOverlayOrigin]` attribute: This tells the Overlay API what
    the origin of this overlay is This is to help the CDK decide where to position
    the overlay when opened.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `[cdkConnectedOverlayOpen]` attribute: This decides whether the overlay
    should be shown or not.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `[cdkConnectedOverlayHasBackdrop]` attribute: This decides whether the
    overlay should have a backdrop or not—that is, if it has a backdrop, the user
    shouldn''t be able to click anything else apart from the overlay when it is open.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `(backdropClick)` attribute: This is the event handler for when we click
    the backdrop. In this case, we''re setting the `menuShown` property to `false`,
    which hides/closes the overlay.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `[cdkConnectedOverlayPositions]` attribute: This provides the positioning
    configuration to the Overlay API. It is an array of preferred positions that defines
    whether the overlay should be shown below the origin, on top of the origin, on
    the left, on the right, how far from the origin, and so on.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `[cdkConnectedOverlayPanelClass]` attribute: A **Cascading Style Sheets**
    (**CSS**) class to be applied to the generated overlay. This is used for styling.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With all of the attributes set correctly, we are able to see the overlay working
    when tapping the list items. *"But what about the pointy arrows, Ahsan?"* Well,
    hold on! We'll discuss them too.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: 'So, the Angular CDK Overlay API already has a lot of things covered, including
    where to position the overlay based on the available space, and since we want
    to show the pointy arrows, we''ll have to analyze whether the overlay is being
    shown above the item or below the item. By default, we have the following styles
    set in the `src/styles.scss` file to show the pointy arrow below the popover:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'And then, we have the `--up` modifier class, as follows, to show the overlay
    *above* the popover:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Notice in the preceding code snippet that we rotate the arrow to `180deg` to
    invert its pointer.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s talk about how and when this `--up` modifier class is applied.
    We have created a custom directive named `appPopoverPositionalClass`. This directive
    is also applied to the `<ng-template>` element we have for the overlay—that is,
    this directive is applied with the `cdkConnectedOverlay` directive and expects
    the following input attributes:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: 'The `appPopoverPositionalClass` attribute: The actual directive selector.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `targetSelector` attribute: The query selector for the element that is
    generated by the Angular CDK Overlay API. Ideally, this should be the same as
    what we use in `cdkConnectedOverlayPanelClass`.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `inverseClass` attribute: The class to be applied when the vertical position
    (`originY`) of the overlay is changed—that is, from `"top"` to `"bottom"`, and
    vice versa.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `originY` attribute: The `originY` position of the overlay at the moment.
    The value is either `"top"` or `"bottom"`, based on the overlay position.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have a `(positionChange)` listener on the CDK Overlay `<ng-template>` element
    that triggers the `popoverPositionChanged()` method as soon as the overlay position
    changes. Notice that inside the `popoverPositionChanged()` method, upon getting
    a new position, we update the `popover.originY` property that is updating `menuPopoverOrigin.originY`,
    and then we're also passing `menuPopoverOrigin.originY` as the `[originY]` attribute
    to our `appPopoverPositionalClass` directive. Since we're passing it to the directive,
    the directive knows if the overlay position is `"top"` or `"bottom"` at any particular
    time. How? Because we're using the `ngOnChanges` life cycle hook in the directive
    to listen to the `originY` attribute/input, and as soon as we get a different
    value for `originY`, we either add the value of `inverseClass` as a CSS class
    to the Overlay element or remove it based on the value of the `originY` attribute.
    Also, based on the applied CSS classes, the direction of the popover arrow is
    decided for the overlay.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Angular CDK Overlay API ([https://material.angular.io/cdk/overlay/overview](https://material.angular.io/cdk/overlay/overview))
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CdkOverlayOrigin` directive documentation ([https://material.angular.io/cdk/overlay/api#CdkOverlayOrigin](https://material.angular.io/cdk/overlay/api#CdkOverlayOrigin))'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using CDK Clipboard to work with the system clipboard
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may have visited hundreds of websites over time, and you might have seen
    a feature called **Click to copy** on some of them. This is usually used when
    you have a long text or a link that you need to copy, and you'll find it way more
    convenient to just click to copy instead of selecting and then pressing the keyboard
    shortcuts. In this recipe, we're going to learn how to use the Angular CDK Clipboard
    API to copy text to the clipboard.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The project for this recipe resides in `chapter09/start_here/using-cdk-clipboard-api`.
    Proceed as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: Open the project in VS Code.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the terminal and run `npm install` to install the dependencies of the project.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once done, run `ng serve -o`.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This should open the app in a new browser tab, as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.10 – using-cdk-clipboard-api running on http://localhost:4200'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_9.10_B15150.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.10 – using-cdk-clipboard-api running on http://localhost:4200
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the app running locally, let's see the steps of the recipe
    in the next section.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have an app right now with a couple of options that don't work—that is, we
    should be able to copy the link, the text from the text area, and the image. In
    order to do so, we'll use the CDK Clipboard API. Let's get started.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we need to import the `ClipboardModule` class into the `imports`
    array of our `AppModule` class. Modify the `app.module.ts` file, as follows:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, we''ll apply the `click-to-copy` functionality to the link. In order to
    do so, we''ll use the `cdkCopyToClipboard` directive and will apply it on our
    link input in the `app.component.html` file, as follows:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: If you click on the link input now and then try to paste it anywhere (within
    or outside the app), you should see the value of the link.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll now do something similar for the text input—that is, the `<textarea>`.
    Update the template again, as follows:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Finally, we''ll do something different for the image. Since the CDK Clipboard
    API only works with strings, we will download the image, convert it into a blob,
    and copy the blob **Uniform Resource Locator** (**URL**). Let''s update the template
    first with the logic, as follows:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, let''s implement the `copyImageUrl()` method to fetch the image, convert
    it into a blob, and copy the URL to the clipboard. Update the `app.component.ts`
    file, as follows:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Great! With this change, you can try refreshing the app. Now, you should be
    able to copy the link and the text, as well as the image, by clicking the input
    link and the buttons respectively. To understand all the magic behind this recipe,
    see the next section.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the recipe, we've used two main things from the CDK Clipboard API—one is
    the `cdkCopyToClipboard` directive, and the other is the `Clipboard` service.
    The `cdkCopyToClipboard` directive binds a click handler to the element this directive
    is applied to. It works both as the selector of the directive and an `@Input()`
    item for the directive so that it knows which value is to be copied to the clipboard
    when the element is clicked. In our recipe, for the link input, notice that we
    use `[cdkCopyToClipboard]="linkInput.value"`. This binds a click handler to the
    `<input>` element and also binds the `value` property of the `linkInput` template
    variable, which points to the value of the input that is the actual link to be
    copied. When we click the input, it accesses the value of the input using the
    `linkInput.value` binding, and we do the same for the `<text-area>` input. The
    only difference is that the `cdkCopyToClipboard` directive is not bound to the
    `<text-area>` element itself. The reason is that we want to bind the click handler
    to the button below the text area instead. Therefore, on the button for copying
    the text, we have the `[cdkCopyToClipboard]="textInput.value"` binding.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: For the image, we do something different. We use the `Clipboard` service from
    the `@angular/cdk/clipboard` package to manually copy the blob URL. We create
    a method named `copyImageUrl()`, which is called when clicking the button for
    copying the image. We pass the `imageUrl` property to this method, which in turn
    downloads the image, reads it as a blob, and generates the blob URL, which is
    copied to the clipboard using the `copy()` method of the `Clipboard` service.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: CDK Clipboard documentation ([https://material.angular.io/cdk/clipboard/overview](https://material.angular.io/cdk/clipboard/overview))
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using CDK Drag and Drop to move items from one list to another
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Have you ever used the Trello board app, or maybe other apps that also allow
    you to drag and drop list items from one list to another? Well, you can do this
    easily using the Angular CDK, and in this recipe, you'll learn about the Angular
    CDK Drag and Drop API to move items from one list to another. You'll also learn
    how to reorder the lists.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The project that we are going to work with resides in `chapter09/start_here/using-cdk-drag-drop`,
    inside the cloned repository. Proceed as follows:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: Open the project in VS Code.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the terminal and run `npm install` to install the dependencies of the project.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once done, run `ng serve -o`.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This should open the app in a new browser tab, and it should look like this:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.11 – The using-cdk-drag-drop app running on http://localhost:4200'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_9.11_B15150.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.11 – The using-cdk-drag-drop app running on http://localhost:4200
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the app running locally, let's see the steps of the recipe
    in the next section.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we have an interesting app that has some folders and files.
    We're going to implement the drag-and-drop functionality for the files to be dragged
    to other folders, which should update the folder's file count instantly, and we
    should be able to see the file in the new folder as well. Let's get started.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we need to import the `DragDropModule` class into the `imports`
    array of our `AppModule` class. Modify the `app.module.ts` file, as follows:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now, we''ll apply the `cdkDrag` directive to each of our files, and will apply
    the `cdkDropList` directive to each of the folders. Update the `folders-list.component.html`
    file, as follows:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We''ll also enable reordering of the files within a folder by adding the `cdkDropList`
    directive on the container elements for the files, as follows:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We''ll now define the origin of the drag-and-drop interaction by specifying
    the `[cdkDragData]` attribute on each `<app-file>` element and the `[cdkDropListData]`
    attribute on each `<app-folder>` element, and on the files container as well.
    Update the template again, as follows:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We now need to implement what happens when the file is dropped. To do so, we''ll
    use the `(cdkDropListDropped)` event handler. Update the template, as follows:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Finally, we need to implement the `onFileDrop` method. Update the `folders-list.component.ts`
    file, as follows:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'If you now refresh the app and try to drag a file to a folder, you should see
    something like this:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.12 – Dragging and dropping a file to another folder'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_9.12_B15150.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.12 – Dragging and dropping a file to another folder
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: Ugly, isn't it? Well, this is because we have to fix the drag-and-drop previews
    in the next steps.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to handle the drag-and-drop previews, we need to enclose them into
    an element with the `cdkDropListGroup` directive. Update the `folders-list.component.html`
    file and apply the directive to the element with the `"folders"` class, as follows:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'To apply a custom drag preview, we use a custom element with the `*cdkDragPreview`
    directive applied to it. Update the `folders-list.component.html` file, as follows:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We''ll also need some styles for the drag-and-drop previews. Update the `folders-list.component.scss`
    file, as follows:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Let''s also add some styles to make sure the other list items move smoothly
    when reordering the items within a folder. Update the `src/styles.scss` file,
    as follows:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now, we need to create a drop preview template as well. For this, we use the
    `*cdkDragPlaceholder` directive on the `preview` element. Update the `folders-list.component.html`
    file, as follows:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Finally, let''s create an `upArrow` property using the `faArrowAltCircleUp`
    icon from the `@fortawesome` package. Update the `folders-list.component.ts` file,
    as follows:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: And boom! We now have a seamless **user experience** (**UX**) for the entire
    drag-and-drop flow. Like it? Make sure that you share a snapshot on your Twitter
    and tag me at `@muhd_ahsanayaz`.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've finished the recipe, let's see in the next section how it all
    works.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There were a couple of interesting directives in this recipe, and we'll go through
    them all one by one. First of all, as good Angular developers, we import the `DragDropModule`
    class into the `imports` array of our `AppModule`, just to make sure we don't
    end up with errors. Then, we start making the files draggable. We do this by adding
    the `cdkDrag` directive to each file element by applying the `*ngFor` directive
    to it. This tells the Angular CDK that this element will be dragged and, therefore,
    the Angular CDK binds different handlers to each element to be dragged.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: 'Angular components by default are not block elements. Therefore, when applying
    the `cdkDrag` directive to an Angular component such as the `<app-file>` component,
    it might restrict the animations from the CDK being applied when we''re dragging
    the elements. In order to fix this, we need to set a `display: block;` for our
    component elements. Notice that we''re applying the required styles in the `folders-list.component.scss`
    file (*line 25*) for the `.folders__selected-folder-files__file` class.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: After configuring the drag elements, we use the `cdkDropList` directive to each
    container DOM element where we're supposed to drop the file. In our recipe, that
    is each folder that we see on the screen, and we can also reorder the files within
    a folder. Therefore we apply the `cdkDropList` directive to the wrapper element
    of the currently displayed files, as well as to each `<app-folder>` item with
    the `*ngFor` looping over the `folders` array.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: Then, we specify the `data` that we're dragging by specifying `[cdkDragData]="file"`
    for each draggable file. This helps us identify it in the later process, when
    we drop it either within the current folder or within other folders. We also specify
    in which array this dragged item will be added when dropped upon the particular
    list, and we do this by specifying `[cdkDropListData]="ARRAY"` statements on the
    elements that we've applied the `cdkDropList` directive to. When the Angular CDK
    combines the information from the `cdkDragData` and the `cdkDropListData` attributes,
    it can easily identify if the item was dragged and then dropped within the same
    list or in another list.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: To handle what happens when we drop the dragged file, we use the `(cdkDropListDropped)`
    method from the Angular CDK on the element with the `cdkDropList` directive. We
    take the `$event` emitted from the CDK and pass it to our `onFileDrop()` method.
    What's great is that within the `onFileDrop()` method, we use the `moveItemInArray()`
    and `transferArrayItem()` helper methods from the Angular CDK, with a really simple
    logic to compare the containers. That is, the Angular CDK provides us enough information
    that we can get away with the whole functionality really easily.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: Toward the end of the recipe, we customize how our drag preview should look
    when we are dragging a file using a custom template, by using the `*cdkDragPreview`
    directive on it. This tells the Angular CDK to not render it right away but to
    show it with the mouse when we start dragging a file. For our recipe, we only
    show the icon of the file as the drag preview. And finally, we also customize
    the drop preview (or drag placeholder) using the `*cdkDragPlaceholder` directive,
    which shows a transparent rectangle with an upward-arrow icon to reflect where
    the item is going to be added when dropped. Of course, we had to add some custom
    styles for both the drag preview and the drop preview.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Angular CDK Drag and Drop documentation ([https://material.angular.io/cdk/drag-drop/overview](https://material.angular.io/cdk/drag-drop/overview))
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a multi-step game with the CDK Stepper API
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you try finding examples of the CDK Stepper over the internet, you'll find
    a bunch of articles revolving around creating multi-step forms using the CDK Stepper
    API, but since it is a stepper at its base, it can be used for various use cases.
    In this recipe, we're going to build a guessing game using the Angular CDK Stepper
    API, in which the user will guess what the output of a rolled dice will be.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The project that we are going to work with resides in `chapter09/start_here/using-cdk-stepper`,
    inside the cloned repository. Proceed as follows:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: Open the project in VS Code.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the terminal and run `npm install` to install the dependencies of the project.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once done, run `ng serve -o`.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This should open the app in a new browser tab, and you should see something
    like this:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.13 – The using-cdk-stepper app running on http://localhost:4200'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_9.13_B15150.jpg)'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.13 – The using-cdk-stepper app running on http://localhost:4200
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's look at how to create a multi-step game with the CDK Stepper API
    in the next section.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have a really simple yet interesting application at hand that has a couple
    of components built already, including the dice component, the value-guess component,
    and the leaderboard component. We''ll create this game as a multi-step game using
    the Stepper API. Proceed as follows:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: 'First, open a new terminal window/tab and make sure you''re inside the `ch8/start_here/using-cdk-stepper`
    folder. Once inside, run the following command to install the Angular CDK:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: You'll have to restart your Angular server, so rerun the `ng serve` command.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, import the `CdkStepperModule` class from the `@angular/cdk` package in
    your `app.module.ts` file, as follows:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Let''s create our stepper component now. Run the following command in the project
    folder:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'To make our component a `CdkStepper`, we need to provide it using the `CdkStepper`
    token and have to extend our component class from `CdkStepper` as well. We can
    remove the `constructor`, the `OnInit` implementation, and the `ngOnInit` method.
    Modify the `game-stepper.component.ts` file, as follows:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Notice that we have removed the usage of `ngOnInit` and the `OnInit` life cycle
    since we don't want these for this component.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add the template for our `<game-stepper>` component. We''ll start by
    adding the header that will show the step label. Update your `game-stepper.component.html`
    file, as follows:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Now, we''ll add the template to show our main content for the selected step—this
    is pretty simple to do. We need to add a div with the `[ngTemplateOutlet]` attribute,
    where we''ll show the content. Update the `game-stepper.component.html` file,
    as follows:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Finally, we''ll add a footer element that''ll contain the navigation buttons
    for our stepper— that is, we should be able to jump to the next and the previous
    step using those navigation buttons. Update the `game-stepper.component.html`
    file further, as follows:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Let''s add some styles to our `game-stepper` component. Modify the `game-stepper.component.scss`
    file, as follows:'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'We''ll now wrap our entire template in the `game.component.html` file with
    the `<app-game-stepper>` component. Update the file, as follows:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We''ll now modify our `game.component.html` file to break down the inner template
    into steps. For that, we''ll use the `<cdk-step>` element to wrap around the content
    for each step. Update the file, as follows:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Now, we''ll add a label for each step to show our main content for the selected
    step—this is pretty simple to do. We need to add an `<ng-template>` element within
    each `<cdk-step>` element. Update the `game.component.html` file, as follows:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'If you refresh the app, you should see the first step as the visible step,
    as well as the bottom navigation button, as follows:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.14 – The first step and the navigation button using CDKStepper'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_9.14_B15150.jpg)'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.14 – The first step and the navigation button using CDKStepper
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to make sure that we can only move forward to the second step
    once we have entered a name in the first step. Make the following changes to the
    `game.component.html` file:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'We also need to disable the next button on the first step until we have entered
    a value for the player name. To do so, update the `game-stepper.component.html`
    file—specifically, the element with the `cdkStepperNext` attribute—as follows:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'To handle the case when the user provides the name and hits the *Enter* key,
    resulting in the form submission, we can handle moving to the next step using
    a `@ViewChild()` in the `GameComponent` class. Modify the `game.component.ts`
    file as follows, and try entering the name and then pressing the *Enter* key:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Now, let''s write the flow for guessing the number. Update the `game.component.ts`
    file, as follows:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Now that we have the functions in place, let''s update the template to listen
    to the event listeners from the `<app-value-guesser>` and `<app-dice>` components
    and to act accordingly. We''ll also add `.alert` elements to show messages in
    case of a successful or wrong guess. Update the `game.component.html` file, as
    follows:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Finally, we need to populate the leaderboards. Update the `game.component.ts`
    file to use the `LeaderboardService` class, as follows:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Now, update the `game.component.html` file to pass the scores as an attribute
    to the `<app-leader-board>` component, as follows:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'If you refresh the app now and play the game, you should be able to see the
    leaderboard, as follows:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.15 – Displaying results in the leaderboard at Step 3'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_9.15_B15150.jpg)'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.15 – Displaying results in the leaderboard at Step 3
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: Phew! That was a LONG recipe! Well, perfection requires time and dedication.
    Feel free to use this game yourself or even with your friends, and if you improve
    it, do let me know on my socials.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: Now that you've finished the recipe, see the next section on how this works.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  id: totrans-331
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a lot of moving parts in this recipe, but they're super-easy. First,
    we import the `CdkStepperModule` class into the `imports` array of our `AppModule`
    class. Then, we create a component that extends the `CdkStepper` class. The reason
    for extending the `CdkStepper` class is to be able to create this `GameStepperComponent`
    component so that we can create a reusable template with some styles, and even
    some custom functionality.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: To start using the `GameStepperComponent` component, we wrap the entire template
    within the `<app-game-stepper>` element in the `game.component.html` file. Since
    the component extends the `CdkStepper` API, we can use all the functionality of
    the `CdkStepper` component here. For each step, we use the `<cdk-step>` element
    from the CDK and wrap the template of the step inside it. Notice that in the `game-stepper.component.html`
    file, we use the `[ngTemplateOutlet]` attribute for both the step's label and
    the step's actual content. This is a reflection of how amazing the `CdkStepper`
    API is. It automatically generates the `step.label` property and the `content`
    property on each step based on the values/template we provide for each step. Since
    we provide an `<ng-template cdkStepLabel>` inside each `<cdk-step>` element, the
    CDK generates a `step.stepLabel.template` automatically, which we then use inside
    the `game-stepper.component.html` file, as mentioned. If we didn't provide it,
    it would then use the `step.label` property as per our code.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: For the bottom navigation buttons, you notice that we use `<button>` elements
    with the `cdkStepperPrevious` and `cdkStepperNext` directives for going to the
    previous step and the next step respectively. We also show/hide the next and previous
    button based on the conditions to check if there is a step to go to. We hide the
    navigation button using the `[style.visibility]` binding, as you see in the code.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: One interesting thing about the `CdkStepper` API is that we can tell whether
    the user should be able to go to the next steps and backward, regardless of the
    state of the current step, or whether the user should first do something in the
    current step to go to the next one. The way we do it is by using the `[linear]`
    attribute on our `<app-game-stepper>` element, by setting its value to `true`.
    This tells the `CdkStepper` API to not move to the next step using the `cdkStepperNext`
    button, until the current step's `completed` property is `true`. While just providing
    `[linear]="true"` is enough to handle the functionality, we improve the UX by
    disabling the **Next** button—in this case, by using `[disabled]="!selected.completed"`
    on the `cdkStepperNext` button, as it makes more sense to just disable the button
    if it isn't going to do anything on click.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: Also, we needed to decide when a step is considered complete. For the first
    step, it is obvious that we should have a name entered in the input to consider
    the step completed—or, in other words, the `FormContro`l for the `'name'` property
    in the `nameForm` `FormGroup` should have a value. For the second step, it makes
    sense that after the user has guessed a number, regardless of whether the guess
    is correct or not, we mark the step as completed and let the user go to the next
    step (the leaderboard) if the user wants to. And that's pretty much about it.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-337
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Angular CDK Stepper examples ([https://material.angular.io/cdk/stepper/examples](https://material.angular.io/cdk/stepper/examples))
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resizing text inputs with the CDK TextField API
  id: totrans-339
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Text inputs are an essential part of our everyday computer usage. Be it filling
    a form, searching some content on Google, or finding your favorite YouTube video,
    we all interact with text inputs, and when we have to write a bunch of content
    into a single text input, it really is necessary to have a good UX. In this recipe,
    you'll learn how to automatically resize the `<textarea>` inputs based on the
    input value, using the CDK TextField API.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-341
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The project for this recipe resides in `chapter09/start_here/resizable-text-inputs-using-cdk`.
    Proceed as follows:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: Open the project in VS Code.
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the terminal and run `npm install` to install the dependencies of the project.
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once done, run `ng serve -o`.
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This should open the app in a new browser tab, and you should be able to see
    the app. Try typing a long text, and you''ll see the text area displaying as follows:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.16 – The resizable-text-inputs-using-cdk app running on http://localhost:4200'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_9.16_B15150.jpg)'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.16 – The resizable-text-inputs-using-cdk app running on http://localhost:4200
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the app running locally, let's see the steps of the recipe
    in the next section.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-351
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In *Figure 9.16*, you will notice that we can''t see the entire content of
    the input—this is somewhat annoying at the best of times because you can''t really
    review it before pressing the **Action** button. Let''s use the CDK TextField
    API by following these steps:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: 'First, open a new terminal window/tab and make sure you''re inside the `chapter09/start_here/resizable-text-inputs-using-cdk`
    folder. Once inside, run the following command to install the Angular CDK:'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: You'll have to restart your Angular server, so rerun the `ng serve` command.
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, we need to import the `TextFieldModule` class into the `imports` array
    of our `AppModule` class. Modify the `app.module.ts` file, as follows:'
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Now, we''ll apply the `cdkTextareaAutosize` directive to our `<text-area>`
    element so that it can be resized automatically based on the content. Update the
    `write-message.component.html` file, as follows:'
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'If you now enter some long phrases in the text input, you should see it being
    resized properly, as follows:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.17 – text-area being resized based on the content'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_9.17_B15150.jpg)'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.17 – text-area being resized based on the content
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: While this is awesome, you might notice that once the message is sent (that
    is, added to the messages list), the size of the `<text-area>` element isn't reset
    to its initial state.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to reset the size of the `<text-area>` element to its initial size,
    we''ll use the `reset()` method of the `CdkTextareaAutosize` directive. To do
    so, we''ll get the directive as a `ViewChild` and will then trigger the `reset()`
    method. Modify the `write-message.component.ts` file, as follows:'
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Great! With this change, when you refresh the page, enter a really long sentence
    in the input and hit the *Enter* key. You''ll see the size of the `<text-area>`
    element being reset, as follows:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.18 – <text-area> size being reset on new message creation'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_9.18_B15150.jpg)'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.18 – <text-area> size being reset on new message creation
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have finished the recipe, see the next section to understand how
    it works.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  id: totrans-372
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the recipe, we've used two main things from the CDK Clipboard API—one is
    the `cdkCopyToClipboard` directive, and the other is the `Clipboard` service.
    The `cdkCopyToClipboard` directive binds a click handler to the element this directive
    is applied to. It works both as the `selector` of the directive as well as an
    `@Input()` item for the directive so that it knows which value is to be copied
    to the clipboard when the element is clicked. In our recipe, for the link input,
    notice that we use `[cdkCopyToClipboard]="linkInput.value"`. This binds a click
    handler to the `<input>` element and also binds the `value` property of the `linkInput`
    template variable that points to the value of the input—that is, the actual link
    to be copied. When we click the input, it accesses the value of the input using
    the `linkInput.value` binding, and we do the same for the `<text-area>` input.
    The only difference is that the `cdkCopyToClipboard` directive is not bound to
    the `<text-area>` element itself. The reason is that we want to bind the click
    handler to the button below the text area instead. Therefore, on the button for
    copying the text, we have the `[cdkCopyToClipboard]="textInput.value"` binding.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: For the image, we do something different. We use the `Clipboard` service from
    the `@angular/cdk/clipboard` package to manually copy the blob URL. We create
    a method named `copyImageUrl()` that is called when clicking the button for copying
    the image. We pass the `imageUrl` property to this method, which in turn downloads
    the image, reads it as a blob, and generates the blob URL, which is copied to
    the clipboard using the `copy()` method of the `Clipboard` service.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-375
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: CDK `text-field` documentation ([https://material.angular.io/cdk/text-field/overview](https://material.angular.io/cdk/text-field/overview))
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
