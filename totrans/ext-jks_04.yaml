- en: Chapter 4. The API and the CLI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we looked at several ways in which we can interact
    with Jenkins and extend its use so that developers can benefit directly from within
    their development environments.
  prefs: []
  type: TYPE_NORMAL
- en: The plugins and add-ons that we looked at were obviously, somehow, able to fetch
    "live" data from Jenkins in order to convey this data directly to the client environment
    (the developers' IDE).
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will take a look at how these plugins were able to access
    this information, and we will explore the various mechanisms and interfaces that
    Jenkins provides for programmatic interactions, for example, the Jenkins **Application
    Programming Interface** (**API**). We will also explore the Jenkins **Command-line
    Interface** (**CLI**), which offers a mechanism by which you can remotely interact
    with Jenkins programmatically and/or interactively.
  prefs: []
  type: TYPE_NORMAL
- en: Both these features are extremely powerful and are the fundamental utilities
    to extend Jenkins.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three main functions for which you would normally use the Jenkins
    API; these are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving and consuming information from Jenkins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Triggering builds based on external events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating, copying, and altering the Jenkins configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an Information Radiator with the Jenkins XML API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to illustrate how you can use the Jenkins API to extract live information
    from Jenkins programmatically, we're going to take a high-level look at a practical
    example—creating an Information Radiator that fetches Jenkins information and
    displays it in an external web page. We will not be writing all of the code for
    this in detail; however, we will analyze the basic building blocks in sufficient
    detail so that you are able to adopt the general approach and develop your own
    customized solution in the language of your choice.
  prefs: []
  type: TYPE_NORMAL
- en: Information Radiators are simple but useful *live* web pages that allow people
    to easily monitor the status of your most crucial Jenkins jobs in real time. This
    is quite similar to the IDE plugins we looked at earlier, but instead these indicators
    are displayed on television screens in an office to radiate the information
  prefs: []
  type: TYPE_NORMAL
- en: The convention for Information Radiators is to *keep it simple*—to have as few
    jobs as possible and have them display a green indicator if everything is alright
    and a red indicator if there is an issue. Sometimes it's useful to show an amber
    indicator if the build is in progress. This simple system helps to highlight the
    urgent issues that need to be fixed as a top priority, and it also serves to deter
    people from checking in new changes when they can clearly see that the build is
    not currently stable; adding further alterations to an already broken system will
    only compound the issue.
  prefs: []
  type: TYPE_NORMAL
- en: In our high-level walkthrough, we will monitor the current state of just one
    Jenkins build. You will be able to reuse and extend the same approach to monitor
    as many builds as you want to, and you will see how you can additionally pull
    in and report other details from your Jenkins jobs.
  prefs: []
  type: TYPE_NORMAL
- en: Note that there are many prebuilt solutions that you could use for this, including
    a variety of plugins for different needs—we are deliberately taking a DIY approach
    here in order to demonstrate the possibilities and show you how to use the Jenkins
    API.
  prefs: []
  type: TYPE_NORMAL
- en: Getting the information from Jenkins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first step is to get our (programmatic) hands on the information. The simplest
    way to do this is via the XML API. This simply involves appending the `/api/xml`
    string to the URL for the job you would like to monitor, as shown here: `http://yourjenkinsserver:8080/job/YourJob/api/xml`.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that there is also a JSON API available; if this suits your needs better—simply
    replace `api/xml` with `api/json` to receive the same information in the JSON
    format.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you do this in a browser, you should see XML somewhat similar to my **VeryBasicJob**
    job:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting the information from Jenkins](../images/00025.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The text returned by the API is simple and the XML is quite self-explanatory;
    a quick look through it shows that it contains all the information that you would
    want on the job you just queried—it just needs to be processed and interpreted.
    There doesn't seem to be much available in the way of documentation for these
    XML elements; however, if you start off with as simplistic a job as possible and
    then make changes and additions to that, you should be able to figure out what
    each element does and what the possible values can be.
  prefs: []
  type: TYPE_NORMAL
- en: An XML processor is the best way to handle this, and your scripting or programming
    language of choice should provide you with several options to choose from. For
    example, Perl has **XML::Simple**, Python has **ElementTree**, there is **XmlParser**
    for Groovy, and **JAXP** for Java, amongst many others. If you don't have any
    of these, you could use `grep` and `awk` to find the line and the values you want
    in a shell script.
  prefs: []
  type: TYPE_NORMAL
- en: So, we now have a job that we would like to monitor, some way to fetch all the
    current information on this job, a suitable method to handle the XML, and a mechanism
    to extract the information we want.
  prefs: []
  type: TYPE_NORMAL
- en: For this example, all that we really want to know about is the current state
    of the build—the values that correspond to our red, amber, and green health indicators—and
    these are present in the XML example as the current `color` attribute of the job.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider the following XML tag: `<color>blue</color>`. This shows
    that we currently have a non-running and stable job, whereas `<color>blue_anime</color>`
    refers to the blue and animated health indicator icon for a job that was healthy
    for the last build and is currently building.'
  prefs: []
  type: TYPE_NORMAL
- en: We can simply show any mention of `anime` as amber in our Radiator. Both `<color>red</color>`
    and `<color>red_anime</color>` are the obvious equivalents for failed and running
    (but previously failed) jobs respectively. If you take a look at the XML for a
    variety of different job types and states, you will be able to spot and interpret
    the naming conventions used—just add `/api/xml` to a varied selection of jobs
    and compare them.
  prefs: []
  type: TYPE_NORMAL
- en: Automating the job
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next hurdle for our simple Information Radiator is automating and scheduling
    the job, and, as you'd expect, we can do this very quickly and easily in Jenkins.
  prefs: []
  type: TYPE_NORMAL
- en: Just create a new Jenkins job that fetches the corresponding URL (with `/api/xml`
    at the end) and feed this to your XML parsing script to extract the current values.
  prefs: []
  type: TYPE_NORMAL
- en: Many programming and scripting languages have a built-in XML or web fetching
    abilities, but if you prefer, you can use curl or wget to fetch the data and then
    pass this to your script.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Jenkins job can be scheduled to run at a frequency that suits you—you can
    do this through the inbuilt cron function using the standard cron notation; for
    example, you can set your job to run every two minutes, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Automating the job](../images/00026.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In this entry, I have specified `H/2 * * * *` to have this job run every two
    minutes. The symbol `H`, is a handy Jenkins inbuilt mechanism that allows Jenkins
    to balance and manage job scheduling. Rather than trigger all the jobs at exactly
    the same time, Jenkins is able to distribute the load for you. For more details,
    click on the **?** icon next to the **Schedule** input box, which states the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**To allow periodically scheduled tasks to produce even load on the system,
    the symbol H (for hash) should be used wherever possible. For example, using 0
    0 * * * for a dozen daily jobs will cause a large spike at midnight. In contrast,
    using H H * * * would still execute each job once a day, but not all at the same
    time, better using limited resources.**'
  prefs: []
  type: TYPE_NORMAL
- en: If you are unfamiliar with the cron syntax, take a look at the cron man page
    (type `man cron` in a terminal) on any Linux box. There are also several helpful
    cron generators online, such as this one at [http://crontab-generator.org/](http://crontab-generator.org/),
    which can be very useful.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Please note that it is highly recommended that you test and fine-tune your job
    *before* deciding on and setting a frequency for repeated builds. For example,
    if your job takes 3 minutes to run and you set it up to run every minute, things
    will not go well!
  prefs: []
  type: TYPE_NORMAL
- en: The last remaining task for this step is to store the data somewhere—I usually
    prefer a simple MySQL database, which I can update at the end of a job simply
    by passing the current runtime parameters to the MySQL binary.
  prefs: []
  type: TYPE_NORMAL
- en: Radiating the information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The final step is to display the information from the database as a color "radiator"—this
    simply involves producing a web page that queries the data and translates this
    information to the appropriate color—red, amber, or green. This can be done in
    many languages, including PHP, JSP, and ASP if you like, but the simplest approach
    may be to have your Jenkins job write out the raw HTML to a file for you, perhaps
    something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: With the job updating the value for the background color as suitable. Note that
    there's a Meta refresh tag in the preceding code to reload the page every 5 seconds—you
    will need to implement something like this, otherwise you will be looking at the
    same information for a long time!
  prefs: []
  type: TYPE_NORMAL
- en: Jenkins as a web server – the userContent directory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can even get Jenkins to act as a simple web server and host the web page
    we created for you—if you copy the file that is produced by the job to the `userContent`
    directory that is within your `JENKINS_HOME` location on the system that runs
    your Jenkins instance, you will see the file appear at this URL: `http://myjenkins:8080/userContent`'
  prefs: []
  type: TYPE_NORMAL
- en: 'This should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Jenkins as a web server – the userContent directory](../images/00027.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Clicking on the **inforad.html** link will give you the following page—our
    very simple DIY Information Radiator:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Jenkins as a web server – the userContent directory](../images/00028.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This simple exercise illustrates how you can query Jenkins via the API to retrieve
    and consume information in real time.
  prefs: []
  type: TYPE_NORMAL
- en: The Jenkins CLI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will review the Jenkins CLI—this is another Jenkins extension
    point that can be extremely useful in certain situations—typically it is used
    to run commands against a remote Jenkins server, performing functions such as
    triggering builds or updating configurations.
  prefs: []
  type: TYPE_NORMAL
- en: How to set it up
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to use the Jenkins CLI, you need the "jenkins-cli.jar" file.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be quickly and easily fetched from your own Jenkins server. If you
    append "/cli" to the web address of your Jenkins instance, you should see a page
    similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to set it up](../images/00029.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This URL provides everything you should need to get started with the Jenkins
    CLI.
  prefs: []
  type: TYPE_NORMAL
- en: There is a link to the Jenkins Wiki topic for further information, a direct
    download link for the Jenkins-cli.jar file from your server (`http://{yourserverand:port}/jnlpJars/jenkins-cli.jar`),
    and a list of available CLI commands along with brief descriptions.
  prefs: []
  type: TYPE_NORMAL
- en: How to use it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once you have saved the CLI jar locally (you can download it via the browser
    or use a command-line tool, such as `wget` or `curl`), you just need to have your
    Java environment set up and then execute the line detailed at the start of the
    help page, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`java -jar jenkins-cli.jar -s http://{yourserverand:port}/ help`'
  prefs: []
  type: TYPE_NORMAL
- en: Assuming that you have the `Jenkins-cli.jar` in the current directory and you
    updated the address to reflect your server, you should get back the basic help
    information, and you are good to go.
  prefs: []
  type: TYPE_NORMAL
- en: Triggering remote jobs via the CLI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most common and perhaps the simplest task of the CLI is triggering a remote
    job to run at a certain point in a process. This can be extremely useful when
    you are integrating Jenkins with other legacy systems and gradually introducing
    automation to a manual process. You may not be able to automate everything straight
    away, or have Jenkins control everything all at once, but if you can set up a
    Jenkins job to automate individual parts of an existing manual workflow, you can
    then introduce Jenkins gradually and work towards removing the manual steps from
    the chain piece by piece.
  prefs: []
  type: TYPE_NORMAL
- en: For example, say we have a legacy batch job that runs some form of data processing.
    This processing may take some time to run, and there may be another step that
    comes along and checks whether the processing is complete, and if so, then transfers
    the new data to another location or passes it to another process. We can start
    off by creating a Jenkins job that, when called, picks up the data, checks whether
    it is valid, and then passes it to the next part of the process. This may remove
    a manual step and reduce the overall processing time. But how does the Jenkins
    job know when to run? It may not be efficient or possible to tell whether the
    processing has completed, but we can make a small update to the process to invoke
    the Jenkins job automatically after the initial processing.
  prefs: []
  type: TYPE_NORMAL
- en: 'To remotely trigger a job to run on a simplistic Jenkins server is as easy
    as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Triggering remote jobs via the CLI](../images/00030.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, we are first downloading the Jenkins CLI jar file to the current directory
    using `curl`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This step needs to be done only once. We will then invoke the remote job with
    this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Using this simple configuration, you will get no feedback of what happens;
    however, checking out `VeryBasicJob` on the Jenkins server should reveal that
    the job was triggered, and in the console output, it should also mention the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Started from command line by anonymous**'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we can see that this has worked ok, but the lack of feedback isn''t very
    helpful. If we add the `–s` and `–v` arguments to the command, we will get the
    complete details of what is going on, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Triggering remote jobs via the CLI](../images/00031.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'This looks much better—we can now see that we have kicked off run #9 of `VeryBasicJob`,
    which simply sleeps for 20 seconds before exiting successfully.'
  prefs: []
  type: TYPE_NORMAL
- en: This output information could be used in the client scripts to check for a success
    or failure, or you could make a note of the job number, or record any other output
    that would be useful to know.
  prefs: []
  type: TYPE_NORMAL
- en: 'Obviously, we wouldn''t normally run Jenkins without some form of authentication
    in place, so in the real world things will be a little bit more complex. The user
    for whom you are running the CLI commands first needs to be granted the "Overall/Read"
    account permissions in the configure user page of Jenkins. You can then simply
    add the user name and password at the end of the command line, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This is enough to get things working, but it's still not great from the security
    point of view; the credentials will be visible in plain text in the script that
    you add them to, or within the history of the shell you have used, or within the
    HTTP stream if you are not using HTTPS. The credentials may also be visible as
    args that are passed to the running process when users run `ps` or `top`, and
    so on, on the same host.
  prefs: []
  type: TYPE_NORMAL
- en: 'A more secure method is to set up SSH keys and pass in the private key for
    the public key. If you go to "configure" in Jenkins for your user name, you can
    set up the SSH keys for your account in the textbox provided. There are detailed
    instructions on setting up SSH here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://help.github.com/articles/generating-ssh-keys/](https://help.github.com/articles/generating-ssh-keys/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once this is done, depending on the version of Jenkins you are using, Jenkins
    may automatically check for and use your SSH credentials from any of the following
    locations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you can explicitly supply the path to the key as follows (appending this
    to the command line instead of the earlier user name and password details):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'For jobs that require parameters (that is, those that you have set up to request
    information from the user at runtime), you can supply additional "-p" arg(s),
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This will be passed to the job exactly as if the user had entered the data via
    the user interface and assuming there was an input element named "sprint" configured
    for that job.
  prefs: []
  type: TYPE_NORMAL
- en: Updating Jenkins configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another very useful ability of the Jenkins CLI is to update the Jenkins configuration
    programmatically and remotely.
  prefs: []
  type: TYPE_NORMAL
- en: From the help page, we saw when we appended `/cli` to the server URL earlier
    that the two commands, `get-job` and `create-job`, can be very useful.
  prefs: []
  type: TYPE_NORMAL
- en: Running get-job will request Jenkins to supply the XML definition for that job.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'When this is run in my server, it will return the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Updating Jenkins configuration](../images/00032.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This XML can be also redirected to a file by appending "`> VeryBasicJob.xml`"
    to the end of that command for example, and the file can then be added or updated
    in your Version Control software as a periodic backup.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, you can choose to create a new job using the create-job command
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `MyNewJob.xml` file can, for example, be created programmatically via a
    combination of a Jenkins job, an XML template, and some user-specified input.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could also update an existing job using update-job in conjunction with an
    existing job name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This approach can be used to build a mechanism that will back up all or some
    of your Jenkins configuration to Version Control, and then, reload them programmatically
    (via Jenkins).
  prefs: []
  type: TYPE_NORMAL
- en: You can also expand this approach to perform some modifications to the XML files
    (and therefore, the job configurations they create) if changes are required; for
    example, updating the release or sprint details periodically.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored the possibilities that the Jenkins API and the
    Jenkins CLI open up.
  prefs: []
  type: TYPE_NORMAL
- en: We have worked through some high-level examples and illustrated how you can
    go about developing your own bespoke Information Radiator using the XML API.
  prefs: []
  type: TYPE_NORMAL
- en: We have also outlined some of the functionalities provided by the CLI and demonstrated
    how you can use them.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from the openness of both of these features, the flexibility
    of Jenkins is quite amazing—it's an open platform that provides you with numerous
    ways of adapting and extending it to suit your needs and requirements, whatever
    they may be.
  prefs: []
  type: TYPE_NORMAL
- en: The way in which the plugins that we examined earlier were able to show live
    information on a remote Jenkins server is now hopefully quite obvious, and we
    will take our usage of the API and CLI still further when we later look at how
    to develop our own plugins for Jenkins.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore Jenkins Extension Points, look at the theory
    behind them, and review the best practices of development.
  prefs: []
  type: TYPE_NORMAL
