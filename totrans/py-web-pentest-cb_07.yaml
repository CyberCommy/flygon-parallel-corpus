- en: Chapter 7. Encryption and Encoding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Generating an MD5 hash
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating an SHA 1/128/256 hash
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing SHA and MD5 hashes together
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing SHA in a real-world scenario
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating a Bcrypt hash
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cracking an MD5 hash
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encoding with Base64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encoding with ROT13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cracking a substitution cipher
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cracking the Atbash cipher
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attacking one-time pad reuse
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Predicting a linear congruential generator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identifying hashes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will be covering encryption and encoding in the world of
    Python. Encryption and encoding are two very important aspects of web applications,
    so doing them using Python!
  prefs: []
  type: TYPE_NORMAL
- en: We will be digging into the world of MD5s and SHA hashes, knocking on the door
    of Base64 and ROT13, and taking a look at some of the most popular hashing and
    ciphers out there. We will also be turning back time and looking at some very
    old methods and ways to make and break them.
  prefs: []
  type: TYPE_NORMAL
- en: Generating an MD5 hash
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The MD5 hash is one of the most commonly used hashes within web applications
    due to their ease of use and the speed at which they are hashed. The MD5 hash
    was invented in 1991 to replace the previous version, MD4, and it is still used
    to this day.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this script, we will only need the `hashlib` module.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Generating an MD5 hash within Python is extremely simple, due to the nature
    of the module we can import. We need to define the module to import and then decide
    which string we want to hash. We should hard code this into the script, but this
    means the script would have to be modified each time a new string has to be hashed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, we use the `raw_input` feature in Python to ask the user for a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `hashlib` module does the bulk of the work for us behind the scenes. Hashlib
    is a giant library that enables users to hash MD5, SHA1, SHA256, and SHA512, among
    others extremely quickly and easily. This is the reasoning for using this module.
  prefs: []
  type: TYPE_NORMAL
- en: 'We first import the module using the standard method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We then need the string that we wish to MD5 encode. As mentioned earlier, this
    could be hard-coded into the script but it''s not extremely practical. The way
    around this is to ask for the input from the user by using the `raw_input` feature.
    This can be achieved by:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have the input, we can continue to encode the string using hashlib''s
    built-in functions. For this, we simply call the `.encode()` function after defining
    the string we are going to be using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we can print the output of the string that uses the `.hexdigest()`
    function. If we do not use `hexdigest`, the hex representation of each byte will
    be printed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of the script in full swing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Generating an SHA 1/128/256 hash
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SHA hashes are also extremely commonly used, alongside MD5 hashes. The early
    implementation of SHA hashes started with SHA1, which is less frequently used
    now due to the weakness of the hash. SHA1 was followed up with SHA128, which was
    then replaced by SHA256.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once again for these scripts, we will only be requiring the `hashlib` module.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Generating SHA hashes within Python is also extremely simple by using the imported
    module. With simple tweaks, we can change whether we would like to generate an
    SHA1, SHA128, or SHA256 hash.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are three different scripts that allow us to generate the different
    SHA hashes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the script of SHA1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the script of SHA128:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the script of SHA256:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `hashlib` module once again does the bulk of the work for us here. We can
    utilize the features within the module.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by importing the module by using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We then need to prompt for the string to encode using SHA. We ask the user
    for input rather than using hard-coding, so that the script can be used over and
    over again. This can be done with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have the string, we can start the encoding process. The next part depends
    on the SHA encoding that you would like to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We need to replace `*` with either `1`, `128`, or `256`. Once we have the message
    SHA-encoded, we need to use the `hexdigest()` function once again so the output
    becomes readable.
  prefs: []
  type: TYPE_NORMAL
- en: 'We do this with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the output has become readable, we simply need to print the hash output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Implementing SHA and MD5 hashes together
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will see how SHA and MD5 hash work together.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For the following script, we will only require the `hashlib` module.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are going to tie everything previously done together to form one big script.
    This will output three versions of SHA hashes and also an MD5 hash, so the user
    can choose which one they would like to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once again, after importing the correct module into this script, we need to
    receive the user input that we wish to turn into an encoded string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'From here, we can start sending the string through all of the different encoding
    methods and ensuring they are passed through `hexdigest()` so the output becomes
    readable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have created all of the encoded strings, it is simply a matter of printing
    each of these to the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an example of the script in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Implementing SHA in a real-world scenario
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following is an example of real-life SHA implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this script, we will need the `hashlib` library and the `uuid` library.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this real-world example, we will be implementing an SHA256 encoding scheme
    and generating a salt to make it even more secure by defeating precomputed hash
    tables. We will then run it through password-checking to ensure the password was
    typed correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To begin the script, we need to import the correct libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We then need to define the function that will hash the password. We start by
    creating a salt, using the `uuid` library. Once the salt has been generated, we
    use `hashlib.sha256` to string together the salt encode and the password encode
    and make it readable by using `hexdigest` and finally appending the salt to the
    end of it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we move onto the check password function. This is what is going to confirm
    our original password is the same as the second one to ensure there were no mistakes.
    This is done by using the same method as before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have created the blocks of code that we need, we can then start asking
    the user for the required input. We start off by asking for the original password
    and using the `hash_password` function to create the hash. This then gets printed
    out to the user. After the first password has been done, we ask for the password
    again to ensure there has been no spelling mistakes. The `check_password` function
    then hashes the password again and compares the original to the new one. If they
    match, the user is informed that the password is correct; if not, the user is
    informed that the passwords do not match:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an example of the code in use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding result is an example of a user enter the same password twice.
    Here is an example of the user failing to enter the same password:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Generating a Bcrypt hash
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the less commonly used, yet more secure hash functions, is **Bcrypt**.
    Bcrypt hashes were designed to be slow when encrypting and decrypting hashes.
    This design was used to prevent hashes from being easily cracked if hashes got
    leaked to the public, for example from a database exposure.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this script, we will be using the `bcrypt` module within Python. This can
    be installed by using either `pip` or `easy_install`, albeit you will want to
    ensure version 0.4 is installed and not version 1.1.1, as version 1.1.1 removes
    some functionality from the `Bcrypt` module.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Generating Bcrypt hashes within Python is similar to generating other hashes
    such as SHA and MD5, but also slightly different. Like the other hashes, we can
    either prompt the user for a password or hard-code it into the script. The hashing
    in Bcrypt is more complex due to the use of randomly generated salts, which get
    appended to the original hash. This increases the complexity of the hash and therefore
    increases the security of the password stored within the hash function.
  prefs: []
  type: TYPE_NORMAL
- en: 'This script also has a `checking` module at the end, which relates to a real-world
    example. It requests the user to re-enter the password they want to hash and ensures
    that it matches the original input. Password confirmation is a very common practice
    among many developers and in the modern age, nearly every registration form uses
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We start the script off by importing the required module. In this case, we
    only need the `bcrypt` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then request the input from the user by using the standard `raw_input`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'After we have the input, we can get down to the nitty gritty hashing methods.
    To begin with, we use the `bcrypt.hashpw` function to hash the input. We then
    give it the value of the inputted password and then also randomly generate a salt,
    using `bcrypt.gensalt()`. This can be achieved by using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We then print the hashed value out to the user, so they can see the hash that
    has been generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we start the password confirmation. We have to prompt the user for the
    password again so that we can confirm that they entered it correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have the password, we check whether both passwords match by using the
    `==` feature within Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see the script in action as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Cracking an MD5 hash
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since MD5 is a method of encryption and is publicly available, it is possible
    to create a hash collision by using common methods of cracking hashes. This in
    turn "cracks" the hash and returns to you the value of the string before it had
    been put through the MD5 process. This is achieved most commonly by a "dictionary"
    attack. This consists of running a list of words through the MD5 encoding process
    and checking whether any of them are a match against the MD5 hash you are trying
    to crack. This works because MD5 hashes are always the same if the same word is
    hashed.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this script, we will only need the `hashlib` module.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To start cracking the MD5 hashes, we need to load a file containing a list
    of words that will be encrypted in MD5\. This will allow us to loop through the
    hashes and check whether we have a match:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We first start by loading the module into Python as normal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We need user input for both the hash we would like to crack and also the name
    of the dictionary we are going to load to crack against:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have the hash we would like to crack and the dictionary, we can continue
    with the encoding. We need to open the `dictionary` file and encode each string,
    one by one. We can then check to see whether any of the hashes match the original
    one we are aiming to crack. If there is a match, our script will then inform us
    and give us the value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Now all that''s left to do is run the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s have a look at the script in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Encoding with Base64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Base64 is an encoding method that is used frequently to this day. It is very
    easily encoded and decoded, which makes it both extremely useful and also dangerous.
    Base64 is not used as commonly anymore to encode sensitive data, but there was
    a time where it was.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Thankfully for the Base64 encoding, we do not require any external modules.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To generate the Base64 encoded string, we can use default Python features to
    help us achieve it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Encoding a string in Base64 within Python is very simple and can be done in
    a two-line script. To begin we need to have the string fed to us as a user input
    so we have something to work with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have the string, we can do the encoding as we print out the result,
    using `msg.encode(''base64'')`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an example of the script in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Encoding with ROT13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ROT13 encoding is definitely not the most secure method of encoding anything.
    Typically, ROT13 was used many years ago to hide offensive jokes on forums as
    a kind of **Not Safe For Work** (**NSFW**) tag so people wouldn't instantly see
    the remark. These days, it's mostly used within **Capture The Flag** (**CTF**)
    challenges, and you'll find out why.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this script, we will need quite specific modules. We will be needing the
    `maketrans` feature, and the lowercase and uppercase features from the `string`
    module.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To use the ROT13 encoding method, we need to replicate what the ROT13 cipher
    actually does. The 13 indicates that each letter will be moved 13 places along
    the alphabet scale, which makes the encoding very easy to reverse:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is the first of our scripts that doesn''t simply require the `hashlib`
    module; instead it requires specific features from a string. We can import these
    using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we can create a block of code to do the encoding for us. We use the `maketrans`
    feature of Python to tell the interpreter to move the letters 13 places across
    and to keep uppercase within the uppercase and lower within the lower. We then
    request that it returns the value to us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'We then need to ask the user for some input so we have a string to work with;
    this is done in the traditional way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have the user input, we can then print out the value of our string
    being passed through our `rot13` block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is an example of the code in use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Cracking a substitution cipher
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following is an example of a real-life scenario that was recently encountered.
    A substitution cipher is when letters are replaced by other letters to form a
    new, hidden message. During a CTF that was hosted by "NullCon" we came across
    a challenge that looked like a substitution cipher. The challenge was:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Find the key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this script, there is no requirement for any external libraries.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To solve this problem, we run our string against values in our periodic dictionary
    and transformed the discovered values into their ascii form. This in returned
    the output of our final answer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To start this script off, we first defined the `key` string within the script.
    The `n` variable was then defined as `2` for later use and two empty lists were
    created— list and answer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'We then started to create the list, which ran through the string and pulled
    out the sets of two letters and appended them to the list value, which was then
    printed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Each of the two letters corresponded to a value in the periodic table, which
    relates to a number. Those numbers when transformed into ascii related to a character.
    Once this was discovered, we needed to map the elements to their periodic number
    and store that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'We are then able to create a loop that will go through the list of elements
    that we previously created and named as **list**, and map them to the value in
    the `periodic` set of data that we created. As this is running, we can have it
    append the findings into our answer string while transforming the ascii number
    to the relevant letter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to have the data printed to us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an example of the script running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Cracking the Atbash cipher
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Atbash cipher is a simple cipher that uses opposite values in the alphabet
    to transform words. For example, A is equal to Z and C is equal to X.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this, we will only need the `string` module.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since the Atbash cipher works by using the opposite value of a character in
    the alphabet, we can create a `maketrans` feature to substitute characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After importing the correct module, we request the input from the user for
    the value they would like encipher into the Atbash cipher:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we create the `maketrans` feature to be used. We do this by listing the
    first set of characters that we would like to be substituted and then listing
    another set of characters that we will use to replace the previous ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we just need to give a value to the transformation, apply it, and
    print the value out to get the end result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an example of the script in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Attacking one-time pad reuse
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The concept of a one-time pad was a fundamental core to early cryptography.
    Basically, a phrase is memorized by the various parties and when a message is
    sent, it is shifted with that phrase for each step. For example, if the phrase
    is `apple` and the message is `i like them`, then we add `a` to `i` to get `j`
    and so on to eventually receive the encoded message.
  prefs: []
  type: TYPE_NORMAL
- en: More recently, a lot of malware engineers and bad software engineers used XORing
    to perform the same activity. Where the vulnerability lies and where we can create
    scripts to be useful is where the same key has been used multiple times. If multiple
    ascii-based strings have been XORed with the same ascii-based strings, we can
    brute the strings at the same time by XORing all of them with ascii values character
    by character.
  prefs: []
  type: TYPE_NORMAL
- en: The following script will take a list of XORed values from a file and brute
    them character by character.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Put a list of XORed phrases in a file. Place that file in the same folder as
    your script (or don't; it just makes it marginally easier if you do).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The script should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This script is pretty straightforward. We open a file with the XORed values
    in them and split it by lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'We shamelessly use the industry standard `XOR` python. Basically, this function
    equates two strings to the same length and `XOR` them together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'We then run through all ascii values three times to get all the combinations
    from `aaa` to `zzz` for each line in the `ciphers.txt` file. We assign the value
    of the ascii loops to the key each time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'We then encrypt the line with the generated key and print it out. We can pipe
    this a file with ease, as we''ve shown throughout the book already:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Predicting a linear congruential generator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'LCGs are used in web applications to create quick and easy pseudo-random numbers.
    They are by nature broken and can be easily made to be predictable with enough
    data. The algorithm for an LCG is:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Predicting a linear congruential generator](img/B04044_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here, **X** is the current value, **a** is a fixed multiplier, **c** is a fixed
    increment, and **m** is a fixed modulus. If any data is leaked, such as the multiplier,
    modulus, and increment in this example, it is possible to calculate the seed and
    thus the next values.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The situation here is where an application is generating random 2-digit numbers
    and returning them to you. You have the multiplier, modulus, and increment. This
    may seem strange, but this has happened in live tests.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here is the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We set our three values, the increment, the multiplier, and the modulo as `C`,
    `A`, and `M` respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'We then declare the range for the possible size of the seed, which in this
    case would be between one and eight digits long:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'We then perform our first LCG transformation and generate possible values with
    the first value taken from the web page marked highlighted in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'We take the second value generated by the web page and check the outcome of
    this transform against that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'If it works, we then perform the next transform with the numbers that matched
    the first transform:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'We repeat this process 10 times here, but it can be reproduced as many times
    as necessary until we find an output that has matched all the numbers so far.
    We print an alert with that number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: We then repeat the process 10 more times, with that number as the seed to generate
    the next 10 values to allow us to predict the new values.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying hashes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nearly every web application you use that stores a password of yours, should
    store your credentials in some form of hashed format for added security. A good
    hashing system in place for user passwords can be very useful in case your database
    is ever stolen, as this will extend the time taken for a hacker to crack them.
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, we have numerous different hashing methods, some of which are
    reused throughout different applications, such as MD5 and SHA hashes, but some
    such as Des(UNIX) are less commonly found. Because of this, it is a good idea
    to be able to match a hash value to the hashing function it belongs to. We cannot
    base this purely on hash length as many hashing functions share the same length,
    so to aid us with this we are going to use **regular expressions** (**Regex**).
    This allows us to define the length, the characters used, and whether any numerical
    values are present.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this script, we will only be using the `re` module.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As previously mentioned, we are going to be basing the script around Regex
    values and using those to map input hashes to the stored hash values. This will
    allow us to very quickly pick out potential matches for the hashes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After we import the `re` module, which we are going to be using, we start to
    build our first block of code, which will be the heart of our script. We will
    try to use conventional naming throughout the script to make it more manageable
    further on. We pick the name `hashcheck` for this reason. We use the name `hashtype`
    to represent the names of the hashes that are upcoming in the Regex block of code,
    we use `regexstr` to represent the Regex, and we finally use data.
  prefs: []
  type: TYPE_NORMAL
- en: 'We create a string called `valid_hash` and give that the value of the iteration
    values after going through the data, which will only happen if we have a valid
    match. This can be seen further down where we give the value result the name of
    matching hash values that we detect using the Regex. We finally print the match
    if one, or more, is found and add our `except` statement to the end:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'We then ask the user for their input, so we have something to match against
    the Regex. This is done as normal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Once this is done, we can move onto the nitty gritty Regex-fu. The reason we
    use Regex is so that we can differentiate between the different hashes, as they
    have different lengths and character sets. This is extremely helpful for MD5 hashes,
    as there are numerous different types of MD5 hashes, such as phpBB3 and MyBB forums.
  prefs: []
  type: TYPE_NORMAL
- en: 'We name the set of Regexs something logical like hashes, and then define them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'We then need to find a way to return the data to the user in a manageable way,
    without letting them know each time a non-match is found. We do this by creating
    a counter. We set the value of this counter to `0` and continue. We then create
    a function named `text`, which will become the value of the name of the hash,
    should a match be found. An `if` statement is then used to prevent the unwanted
    messages we previously mentioned. We tell the script that if `text is not none`
    then a match has been found, so we raise the value of the counter and print the
    text. Using the counter idea means any non-matches found will not increase the
    counter and therefore will not be printed to the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: We finish the script off by letting the user know if there is no match, in the
    most polite way possible!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are some examples of the script in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding result finds no matches as there is no hashing system listed
    that outputs two character strings. The following is an example of a successful
    find:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
