- en: Deep Dive into Memory Management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Memory turns out to be one of the core concepts when dealing with systems development.
    Allocating, freeing, and learning how memory is managed, and knowing what C++
    can offer to simplify and manage memory, are crucial. This chapter will help you
    grasp how memory works by learning how to use C++ smart pointers, aligned memory,
    memory-mapped I/O, and allocators.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Learning automatic versus dynamic memory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning when to use `unique_ptr`, and the implications for size
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning when to use `shared_ptr`, and the implications for size
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allocating aligned memory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking whether the memory allocated is aligned
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dealing with memory-mapped I/O
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dealing with allocators hands-on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to let you immediately try the programs, we've set up a Docker image that
    has all the tools and libraries we'll need throughout the book. This is based
    on Ubuntu 19.04.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to set it up, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Download and install Docker Engine from [www.docke](https://www.docker.com/)[r.com](https://www.docker.com/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Pull the image from Docker Hub by running the following command: `docker pull
    kasperondocker/system_programming_cookbook:latest`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The image should now be available. Type in the following command to view the
    image: `docker images`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You should have at least this image now: `kasperondocker/system_programming_cookbook`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the Docker image with an interactive shell, with the help of the following
    command: `docker run -it --cap-add sys_ptrace kasperondocker/system_programming_cookbook:latest /bin/bash`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The shell on the running container is now available. Type in `root@39a5a8934370/#
    cd /BOOK/` to get all the programs developed, by chapter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `--cap-add sys_ptrace` argument is needed to allow the **GNU Project Debugger** (**GDB**)
    in the Docker container to set breakpoints, which, by default, Docker does not
    allow.
  prefs: []
  type: TYPE_NORMAL
- en: '**Disclaimer**: The C++20 standard has been approved (that is, technically
    finalized) by WG21 in a meeting in Prague at the end of February. This means that
    the GCC compiler version that this book uses, 8.3.0, does not include (or has
    very, very limited support for) the new and cool C++20 features. For this reason,
    the Docker image does not include the C++20 recipe code. GCC keeps the development
    of the newest features in branches (you have to use appropriate flags for that,
    for example, `-std=c++2a`); therefore, you are encouraged to experiment with them
    by yourself. So, clone and explore the GCC contracts and module branches and have
    fun.'
  prefs: []
  type: TYPE_NORMAL
- en: Learning automatic versus dynamic memory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will focus on the two main strategies C++ offers to allocate memory: **automatic**
    and **dynamic** memory allocation. A variable is automatic when its scope lasts
    for the duration of the block in which it is defined, and its allocation and deallocation
    are automatic (that is, not up to the developer). The variable is allocated on
    the stack.
  prefs: []
  type: TYPE_NORMAL
- en: A variable is dynamic if allocated in the dynamic portion of the memory (free
    store, which is often referred to as the *heap*), and the allocation and deallocation
    are up to the developer. Greater flexibility offered by the dynamic memory allocation
    comes with a cost, in terms of more work for the developer to avoid memory leaks,
    dangling pointers, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section will show two examples of automatic and dynamic variable allocation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a utility class we''re going to need:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'And now, let''s create the `main` module to show automatic memory usage:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'And now, we''ll write the `main` module for dynamic memory usage:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: These two programs, although with the same outcome, show two different ways
    of dealing with memory.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the first step, we defined a `User` class, which is used to show the difference
    between automatic and dynamic memory allocation. Its constructor and destructor
    will be used to show when the class is allocated and deallocated.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *step 2*, we can see that the variable is just defined as `User developer;`.
    The C++ runtime will take care of allocating memory of the stack and freeing it,
    without additional work for the developer. This type of memory management is faster
    and easier, but comes with two major costs:'
  prefs: []
  type: TYPE_NORMAL
- en: The amount of memory is limited.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The variable is only valid and visible in the inner `{ }` block, where it is
    allocated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In *step 3*, the same object is allocated on the dynamic memory (that is, **heap**).
    The main difference is that the developer is now responsible for allocating and
    deallocating the quantity of memory needed. If the memory is not deallocated (by
    using `free`), there''ll be a leak. The pros of managing the memory dynamically are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Flexibility: The pointer, referencing to the allocated memory (the `developer`
    variable) can be used throughout the whole program.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The quantity of memory available is way more than that for automatic memory
    management.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the newer C++ standard (from version 11 onward), `new` and `delete` can
    be safely avoided in favor of smart pointers (`shared_ptr` and `unique_ptr`).
    These two tools will take care of deallocating the memory when it is not used
    anymore. [Chapter 2](1bf083f4-9d12-4b2e-bf5c-35a2e3d99c36.xhtml), *Revisiting
    C++*, provides a refresher on smart pointers.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next two recipes will show when to use `unique_ptr` and `shared_ptr`.
  prefs: []
  type: TYPE_NORMAL
- en: Learning when to use unique_ptr, and the implications for size
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous recipe, we''ve learned the two fundamental ways of managing
    memory in C++: automatic and dynamic. We''ve also learned that dynamic memory
    is available to the developer in a greater quantity compared to automatic memory
    (that is, available from the stack), and offers great flexibility. On the other
    hand dealing with dynamic memory can be an unpleasant experience:'
  prefs: []
  type: TYPE_NORMAL
- en: The pointer does not indicate whether it points to an array or to a single object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When freeing the allocated memory, you don't know if you have to use `delete`
    or `delete[]`, so you have to look at how the variable is defined.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is no explicit way to tell if the pointer is dangling.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are just a few issues you might encounter when dealing with dynamic memory,
    and then, with `new` and `delete`. `unique_ptr` is a smart pointer, which means
    that it knows when the memory should be deallocated, removing the burden from
    the developer. In this recipe, you'll learn how to use `unique_ptr` and `make_unique` properly.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we''ll develop a program to learn why `unique_ptr` is a convenient
    way of dealing with dynamic memory; and the second aspect is to learn whether `unique_ptr`
    is the same size as raw pointers:'
  prefs: []
  type: TYPE_NORMAL
- en: We'll reuse the `User` class developed in the previous recipe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s write the `main` program, allocating a `User` object with `make_unique`
    and using `unique_ptr`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see the memory implications:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: What do you think will be the difference in size between `developer` and `developer2`?
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In *step 2*, we used `unique_ptr` to define a variable allocated using `std::make_unique`.
    Once the variable is allocated, there is no risk of memory leak as the destructor
    will automatically deallocate the memory for us. The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a9d63859-8852-406f-8c0e-3474395f5d97.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In *step 3*, we wanted to check if `unique_ptr` added any memory compared to
    raw pointers. Well, the good news is that `unique_ptr` has the same size as the
    raw pointer version. The output of this step is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/541b1ef5-331f-4f88-b69d-1e6006d78c37.png)'
  prefs: []
  type: TYPE_IMG
- en: The `developer` and `developer2` variables are of the same size, and the developer
    can treat them the same way.
  prefs: []
  type: TYPE_NORMAL
- en: A rule of thumb is to use `unique_ptr` for variables that manage resources with
    **exclusive ownership only**, which represent most developers' use cases.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By default, `unique_ptr` calls the default `delete` destructor for the object,
    but a custom `delete` destructor can be specified. If the pointer variable does
    not represent exclusive ownership but rather shared ownership converting it to
    `shared_ptr` is easy.
  prefs: []
  type: TYPE_NORMAL
- en: One important aspect to highlight is that `make_unique` is not part of the C++11
    standard library, but part of the C++ 14 library. If you're using the C++11 standard
    library, its implementation is quite simple, though.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Chapter 2](1bf083f4-9d12-4b2e-bf5c-35a2e3d99c36.xhtml), *Revisiting C++* has
    a dedicated recipe on smart pointers, with one recipe on shared and unique pointers.
    A suggested read is *Effective Modern C++* by Scott Meyers.'
  prefs: []
  type: TYPE_NORMAL
- en: Learning when to use shared_ptr, and the implications for size
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we've learned how to manage dynamic memory (allocated
    on the heap) in a very convenient way, by using `unique_ptr`. We've learned as
    well that `unique_ptr` must be used, just in case of exclusive ownership of the
    memory, or resources managed by the memory. But what if we have a resource that
    is co-owned by more entities? What if the memory we have to manage has to be released
    when all the owners have completed their job? Well, this is exactly the use case
    for `shared_ptr`. Just as with `unique_ptr`, for `shared_ptr` we don't have to
    allocate memory with `new`, but there is a template function (part of the C++
    standard library), `make_shared`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we''ll develop a program to show how to use `shared_ptr`.
    You''ll learn that the memory is only deallocated when none of the owners use
    the memory anymore:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll reuse the `User` class developed in the first recipe. Let''s now write
    the `main` module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s see the memory used by `shared_ptr` by writing this program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: At this point, we should know the size of `unique_ptr` compared to a raw pointer
    (as we learned in the *Learning when to use unique_ptr, and the implications for
    size* recipe). What is the size of the `shared_ptr` variable? Still the same?
    In the next section, we'll learn about this important aspect.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the preceding first program, we showed how to use `shared_ptr`. First, we
    allocated a block of memory, which contained an object of type `User` with `auto
    shared1 = std::make_shared<User>();`. So far, the `User` resource is owned by
    the `shared1` variable. Next, into the block, we assigned the `shared1` variable
    to `shared2` through `auto shared2 = shared1;`. This means that the memory containing
    the `User` object is now pointed by `shared1` and `shared2`. The same goal would
    have been achieved by using the constructor copy `auto shared2 (shared1);`. As
    `User` is now pointed by two variables, the deallocation of the used memory only
    happens when all the variables go out of scope. Indeed, the output proves that
    the memory is deallocated (`User`''s destructor is called) at the end of the main
    block, and not at the end of the inner block, as happened for `unique_ptr`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a75c73de-d7b4-4ff1-9412-af044422965d.png)'
  prefs: []
  type: TYPE_IMG
- en: The impact of `shared_ptr` on memory is not the same as `unique_ptr`. The reason
    is that the `shared_ptr` implementation needs one raw pointer to keep track of
    the memory (likewise with `unique_ptr`), and another raw pointer for the resource's
    reference counting.
  prefs: []
  type: TYPE_NORMAL
- en: 'This reference-counting variable must necessarily be an atomic one, as it can
    be incremented and decremented by different threads:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2bbb9914-5677-489e-adc5-d9acef0e9550.png)'
  prefs: []
  type: TYPE_IMG
- en: The memory size of a `shared_ptr` variable is, typically, twice the size of
    a raw pointer, as we see in the preceding output, on running the second program.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One more interesting point not to overlook is that as `shared_ptr` contains
    an atomic variable, it is typically slower than normal variables.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Chapter 2](1bf083f4-9d12-4b2e-bf5c-35a2e3d99c36.xhtml), *Revisiting C++*, has
    a dedicated recipe on smart pointers, with one recipe on shared and unique pointers.
    A suggested read is *Effective Modern C++* by Scott Meyers.'
  prefs: []
  type: TYPE_NORMAL
- en: Allocating aligned memory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Writing system programs might require the use of data that is aligned in memory in
    order to access the hardware efficiently (and in some cases, to access it at all).
    For example, on a 32-bit architecture machine, we have the memory allocated aligned
    to a 4-byte boundary. In this recipe, you'll learn how to use the C++11 `std::aligned_storage` to
    allocate aligned memory. Of course, there are other, more traditional, mechanisms
    to allocate aligned memory, but the goal of this book is to use C++ standard library
    tools as much as possible.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we''ll write a program that will use the allocated memory
    with `std::aligned_storage` and will show the use of `std::alignment_of`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by writing a program to check what is the default alignment boundary
    for integers and doubles on the current machine:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s write a program to allocate memory aligned to a specific size.
    For this, let''s use `std::aligned_storage`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Allocating aligned memory can be tricky, and the C++ standard library (from
    version 11 onward) offers these two features (`std::alignment_of`, `std::aligned_storage`)
    to simplify it. The next section will describe the mechanics behind it.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first program, which is quite simple, shows the natural alignment in memory
    for two primitive types through `std::alignment_of`. By compiling (`g++ alignedStorage.cpp`)
    and running the program, we have the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cb15931f-34a9-47f0-8177-6b312346afba.png)'
  prefs: []
  type: TYPE_IMG
- en: This means that each integer will be aligned at `4` bytes of boundary and with floating-point
    types aligned to `8` bytes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the second program, we need an integer that is aligned to `8` bytes. By
    compiling it and running the executable, the output would be something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9f9a06a2-f91c-41b7-a846-570c3b5837e4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You may have noticed that I''ve compiled with the `-g` option (to add debug
    symbols). We did this to show, with the memory dump in GDB, that the memory of
    the integer is correctly aligned at `8` bytes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/71381006-7525-4b1d-9919-2163adf644e0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'From the debug session, we can see that through the `x/20bd iu` (`x` = *memory
    dump*) command, we dumped `20` bytes of the memory after the address of the `iu`
    variable. We can see something interesting here: both the `iu` and `ju` variables
    are aligned at `8` bytes. Each memory row displays `8` bytes (test it: `0x7ffc57654470`* –*
    `0x7ffc57654468` = `8`).'
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Playing with memory is always risky, and these new C++ features (and others
    available in the `std` namespace) help us to **play safe**. The recommendation
    is still the same: premature optimization must be used carefully; optimize (that
    is, use aligned memory) only when necessary. One last recommendation: using `reinterpret_cast`
    is discouraged, as it manipulates memory at a low level. You need to know what
    you''re doing when using it.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The latest version of *The C+**+ Programming Language, Fourth Edition* by Bjarne
    Stroustrup has a paragraph on *memory alignment* (*6.2.9*) and *aligned_storage *(*35.4.1*).
  prefs: []
  type: TYPE_NORMAL
- en: Checking whether the memory allocated is aligned
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous recipe, you have learned how to use C++11 to allocate aligned
    memory. The question now is: how do we know that memory is properly aligned? This
    recipe will teach you about this.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll be using the previous program, and by modifying it a little, we''ll
    see how to check whether a pointer is aligned or not:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s modify the previous program, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We created on purpose two typedefs, one for the alignment to `8` bytes (`intAligned8`)
    and one for the alignment to `4` bytes (`intAligned4`).
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the program, we defined two variables, `i` and `j`, of type `intAligned8`
    and `intAligned4` respectively. With the help of these two variables (with alignment
    to `8` and `4` bytes), we can see that they are properly aligned by checking that
    the result of the division by `8` is `0`: `((unsigned long)iu % 8 == 0)`. This
    ensures that the `iu` pointer is aligned to `8` bytes. The same is done for the
    `ju` variable. By running the preceding program, we''ll get this result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d2ddef14-28cf-4cc5-9991-e6f703144054.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As expected: `iu` is properly aligned to `8` bytes and `ju` is not.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As you might have noticed, we used `reinterpret_cast` to allow the modulus
    (`%`) operator instead of the C-style cast `((unsigned long)iu % 8 == 0)`. If
    you are developing in C++, you''re encouraged to use the named casts (`static_cast`,
    `reinterpret_cast`, `const_cast`, `dynamic_cast`) for two basic reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: To allow the programmer to express the intent of the cast
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To make the cast safe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: More info on this topic can be found in *Advanced Programming in the UNIX*^®* Environment* by
    W. Richard Stevens and Stephen A. Rago.
  prefs: []
  type: TYPE_NORMAL
- en: When a portion of memory is aligned, the compiler can make great optimization.
    A compiler doesn't have the possibility of knowing this, and therefore cannot
    make any optimizations. The last C++20 standard added the `std::assume_aligned` feature.
    This informs the compiler that the value of a pointer is a memory address aligned
    to a certain number of bytes. What can happen is that when we allocate some aligned
    memory, the pointer to that memory is then passed to other functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `std::assume_aligned` feature informs the compiler to assume that the memory
    pointed by a pointer is already aligned, so it is safe to make optimizations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `std::assume_aligned<64>(p);` feature informs the compiler that `p` is already
    aligned to at least `64` bytes. You'll get undefined behavior if the memory is
    not aligned.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with memory-mapped I/O
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, we need to operate on memory in a way that is not conventional or,
    so to speak, not common. As we've seen, memory is allocated with `new` and released
    with `delete` (or, even better, with `make_unique` and `make_shared`). There might
    be cases in which we need to skip some layer—that is, using a Linux system call;
    for the sake of performance; or because of a custom behavior that we cannot map
    with the C++ standard library. This is the case with the `mmap` Linux system call
    (`man 2 mmap`). `mmap` is a POSIX-compliant system call that allows the programmer
    to map a file to a portion of memory. Among other things, `mmap` also allows memory
    to be allocated, and this recipe will teach you how to do it.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This section will show two `mmap` use cases: the first, how to map a file to
    a portion of memory; and the second, how to allocate memory using `mmap`. Let''s
    first write a program that maps a file to memory.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In a shell, let''s create a new source file called `mmap_write.cpp`. We need
    to open a file to map:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Second, we have to create a space into the file that we''ll use later (`mmap` does
    not do this):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can map the file—represented by the `fd` file descriptor—to the `map`
    variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, we need to write some value into it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s not forget to close the resources used:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The steps seen so far are related to writing a file with `mmap`. For the sake
    of completeness, in this step, we develop the program to read a file called `mmap_read.cpp`,
    which is very similar to the one we''ve seen. Here, we''ll just see the important
    part (the Docker image contains the complete version of both the reader and the
    writer):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Let's now learn how to use `mmap` to allocate memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now allocate memory with `mmap`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Although simple, these two programs show you how to allocate memory and manage
    a file with `mmap`. In the next section, we'll see how it works.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the first program, we''ve learned the most common use of `mmap`: to map
    a file to a portion of memory. As almost any resource can be mapped to a file
    in Linux, it means that we can map almost anything to memory with `mmap`. It indeed
    accepts a file descriptor. By compiling and running the `mmap_write.cpp` program
    first, we are able to write a file in memory with a list of integers. The file
    generated will be called `mmapped.txt`. The interesting part is to run the `mmap_read.cpp` reader
    program. Let''s compile and run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/04bbe152-7fff-49a6-a27f-fc23edc804d7.png)'
  prefs: []
  type: TYPE_IMG
- en: As we can see, it correctly prints out all the integers from the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Strictly speaking, `mmap` does not allocate memory in the heap memory, nor
    on the stack. It is a separate memory area, still in the virtual space of the
    process. `munmap` does the inverse: it releases the mapped memory, and flushes
    data to file (this behavior can be controlled with the `msync` system call).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The second program shows the second use case of `mmap`: Allocating memory in an
    alternative way to `new` and `malloc`. We can see a few differences in the call
    to `mmap`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`MAP_PRIVATE`: The modifications are private. Any modification made to the
    memory is not reflected back to the file or to other mappings. The file is mapped
    as copy-on-write.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MAP_ANONYMOUS`: It indicates that a portion of the memory of size `SIZE` will
    be allocated and not associated with any specific file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fifth parameter we passed `-1` as we want to allocate memory (that is, no
    file descriptor).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We allocated 1 KB of memory and used a string. The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b4a4ef22-fc72-4027-89d9-435480e7b79c.png)'
  prefs: []
  type: TYPE_IMG
- en: Likewise, when we deallocate memory with `free` or `delete`, we need to release
    the mapped memory with `munmap`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are a few advantages worth mentioning about `mmap`:'
  prefs: []
  type: TYPE_NORMAL
- en: Reading from and writing to a memory-mapped file avoids the copy needed by the
    `read()` and `write()` from the actual file if `mmap` is used with `MAP_SHARED`
    or `MAP_SHARED_VALIDATE` flags. Indeed, when we write a chunk of data to a file,
    a buffer is moved from the user space to the kernel space, and the same is true
    when reading a chunk of data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Reading and writing a memory-mapped file turns out to be a simple memory access. A
    memory-mapped file is only read and written in memory; at the `munmap` call, the
    memory is flushed back in the file. This behavior can be controlled by the `MS_SYNC`, `MS_ASYNC`,
    and `MS_INVALIDATE` flag parameters of the `msync` system call.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Very conveniently, when multiple processes map the same file in memory, the
    data is shared among all the processes (`MAP_SHARED`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Check `man 2 mmap` for more information. Further information can be found in *Linux
    System Programming, Second Edition* by Robert Love.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with allocators hands-on
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'C++ **Standard Template Library** (**STL**) containers are a simple, as well
    as effective, way of managing resources. One huge benefit of containers is that
    they can manage (almost) any type of data. When dealing with system programming,
    though, we may need to provide an alternative way of managing memory for our container.
    Allocators are exactly this: they provide a custom implementation to a container.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, you''ll learn to implement your own custom allocator (based
    on `mmap`, in this case) to provide to a standard library container (`std::vector`):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create an empty allocator template first:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, there are copy constructor, `allocate`, and `deallocate` methods
    to implement. Let''s implement them one by one (there is no need to implement
    the default constructor, in this case):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, implement the `allocate` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, implement the `deallocate` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The `main` method looks like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The use of `std::vector`, as you can see, is seamless from the user's point
    of view. The only difference is to specify which allocator we want to use. This
    container will allocate and deallocate memory, using solely `mmap` and `munmap` and
    not the default implementation, based on `new` and `delete`.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The central part of this program is the two methods: `allocate`, which returns
    a pointer representing the memory allocated, and `deallocate`, which takes a pointer
    to the memory to be released.
  prefs: []
  type: TYPE_NORMAL
- en: In the first step, we've sketched the interface we're going to use to allocate
    and deallocate the memory. It's a template class, as we want it to be valid for
    any type. The two methods we have to implement, as discussed previously, are `allocate`
    and `deallocate`.
  prefs: []
  type: TYPE_NORMAL
- en: In the second step, we've developed the copy constructor, which will be called
    when we want to construct an object, passing in the input of an object of the
    same type. We're just returning a `typedef` that will communicate which allocator
    to use for the new object.
  prefs: []
  type: TYPE_NORMAL
- en: In the third step, we've implemented the constructor, which basically allocates
    the space of object `n` of type `T` with `mmap`. We've seen the use of `mmap`
    already in the previous recipe, so you're invited to read that recipe again.
  prefs: []
  type: TYPE_NORMAL
- en: In the fourth step, we've implemented the `deallocate` method, which in this
    case is calling the `munmap` method, which deletes the mappings for the specified
    address range.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the `main` method shows how to use our custom allocator with `std::vector`
    (it could have been any container—for example, list). In the definition of the
    variable, `mmap_vector`, we pass two parameters: the first one, `int`, to inform
    the compiler that it''ll be a vector of integers, and the second one, `mmap_allocator<int>`,
    to instruct the use of our custom allocator, `mmap_allocator`, instead of the
    default one.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In system programming, there is the concept of a **pool** of (pre-allocated)
    memory that the system reserves upfront and that must be used throughout the life
    of a resource. The `map_allocator` class seen in this recipe can be easily modified
    to pre-allocate a portion of memory in the constructor, and acquire and release
    it from the pool without affecting the system memory.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The books *Effective Modern C++* by Scott Meyers and *The C++ Programming* *Language* by Bjarne
    Stroustrup cover these topics in great detail. Refer to the *Dealing with memory-mapped
    I/O* recipe for more details on `mmap`.
  prefs: []
  type: TYPE_NORMAL
