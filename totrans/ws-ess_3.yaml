- en: Chapter 3. Configuring the Server and Transferring Real-time Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data is the heart of any application. And data transfer between the client and
    server is a very important part of it. We have seen in the last chapter how we
    can transfer data using WebSockets. Now, we will see how we can utilize it and
    make an application in which real-time data transfer can be used. Real-time data
    transfer is mainly used when we have a collaborative application or any application
    which needs reflection as soon as some of the data changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Real-time data transfer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Real-time applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collaborative presentation applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding collaboration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do it yourself
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tips and tricks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Full-duplex real-time data transfer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we all know, sending and receiving data as soon as some change happens is
    real-time data transfer. It can be for some changes that occur in that data. The
    reason for data change could be user itself or some timed event. In normal scenarios,
    the user changes should accordingly reflect to other users; for example, chatting
    applications where people send messages to each other. A chatting application
    is a very small example of real-time data transfer; let's talk about some big
    examples like games. Games are the major applications where real-time data transfer
    is required. But as the industry is growing, our daily use applications are also
    adopting real-time full-duplex data communication. If we see any stock market
    application, then we can see live data changes happening, which basically is a
    good example of server push. In this scenario, the server is pushing data, which
    is a great feature of WebSockets.
  prefs: []
  type: TYPE_NORMAL
- en: Foundation of real-time applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve understood what real-time data transfer is; now let''s see what we need
    to make a real-time data transfer application There are some foundation steps
    we need to consider before starting any application. Some of the major steps are:'
  prefs: []
  type: TYPE_NORMAL
- en: Selecting the functionality we need to make collaborative or real-time data
    transfer application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selecting the server-side technology to make it possible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selecting the client-side technology that integrates easily with the server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These three steps are the main points to keep in mind. As we know, HTML5 supports
    WebSockets and is one of the best ways of data comunication. Now for the server-side,
    we have seen how easily and seamlessly the Node.js server can be integrated. Now
    the most important part is which functionality we need to make real-time. This
    is based on the kind of application we are building. Next, keeping these points
    in mind, we will start building our application so that we understand it better.
  prefs: []
  type: TYPE_NORMAL
- en: Collaborative presentation application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Keeping the foundation elements in mind, let's build a presentation application
    where if you change the presentation, then it will also change for other users
    and vice versa. Basically, we will build a web-based collaborative presentation
    sharing application. To make this application for modern browsers, we need a JavaScript
    library, which gives us all the features we need for a presentation application,
    such as creating different pages, navigation, and so on. And then we will add
    the feature that enables collaboration between different users.
  prefs: []
  type: TYPE_NORMAL
- en: The presentation library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are different JavaScript libraries available from which we can choose.
    The library that gives us enough features to create our application is **reveal.js**.
    It is a well-made API and is fully based on HTML5\. There is also a well-made
    application to make online presentations, which is also based on the same JavaScript
    library that we are going to use. The website for the same is [www.slides.com](http://www.slides.com).
    Go ahead and visit this website; it will give you a feeling of how our presentation
    is going to look. We will be using this API and making it collaborative so that
    other users can also change the slide and the reflection can be seen by everyone.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Firstly, we need to download and set up the library file. The library that
    we are going to use can be found at [https://github.com/hakimel/reveal.js](https://github.com/hakimel/reveal.js).
    The following are the steps to set up a library:'
  prefs: []
  type: TYPE_NORMAL
- en: Download a copy for yourself and open the `index.html` file.![Setting up the
    library](img/B03854_03_01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you open the file, you can see the default presentation that comes with
    it.![Setting up the library](img/B03854_03_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The library reveal.js is a complete presentation solution which comes with its
    own navigation and presentation mechanism.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Here you can use keyboard controls to navigate to different pages. Use the right
    arrow key to go to the next slide and the left arrow key for the previous slide.
    Similarly use the up and down arrow keys for different levels of presentation.
    It supports all kind of text and you can put real code or any HTML content in
    it which is live. You can go through the slides to know more about the library
    features.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adding collaboration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To add the collaborative feature to the presentation library, let's first see
    what steps we need to follow to make this application work. It is good practice
    to write down the important steps from the client side and server side just to
    make sure that we are covering each and every step.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this application, let''s make the list of things to do for the client side:'
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to the WebSocket server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Receiving messages from WebSocket
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying the slide number received from the server to the current presentation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending slide details to the server when the user changes the slide
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that we have listed the points for the client, let''s list down the points
    for server as well:'
  prefs: []
  type: TYPE_NORMAL
- en: Initializing WebSocket server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Receiving slides data from client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing current slide data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passing current slide data for new users who joined later
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Broadcasting the slide data changes to all the users
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking for the slide data changes to reduce duplicate calls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we have the library downloaded, we need to add our custom client and server-side
    code to make it work.
  prefs: []
  type: TYPE_NORMAL
- en: Code implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The library has most of the code ready for us, so we don't need to add much
    code for the client. We need to write the server code completely. Let's check
    out the code.
  prefs: []
  type: TYPE_NORMAL
- en: The client code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'On the client side, the main file is `index.html`, so we are going to add our
    code to that file. At the end of the JavaScript code in the file, add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Code explanation
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let's see what we have written in this code.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have added the load event listener to the window so that as soon as we know
    that the browser window is loaded properly, we can start initializing our WebSocket
    connection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the `init` method is called, we write the actual code which communicates
    with the WebSocket server. Here, in this piece of code, we have instantiated the
    WebSocket object and written an event handler which will be called when the connection
    is open. Once the connection is established, this method is invoked and we come
    to know that the connection has been created. Now we send some random data, which
    can be treated as the acknowledgment for the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we add the message event handler, which is invoked when the server sends
    a message—in our case, we have to handle the data that server is going to send
    us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'So you can see that we are calling the `isJson` method and sending the message
    data to it. This method is invoked to check whether the data we have received
    is in the format we want or not; otherwise it can throw an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'After checking that we have the right type of the data, we now parse the data
    into the **JavaScript Object Notation** (**JSON**) format. The reason we have
    to parse the JSON method is because we are sending the data in JSON, which is
    converted to string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the data is converted, we get a JSON object in the obj variable. Now comes
    one of the important methods, which basically is a reveal.js library method used
    to set the current slide of the presentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This way we receive the data and set it in the presentation. Now comes the second
    part of the code—sending the data to the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'The reveal.js library gives us an event which we can listen to and get information
    about the current slide:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Once we add the listener to the `slidechanged` event, we can use the data which
    was passed under the event attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how we have created a string from the JSON object and passed it to
    the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In the WebSockets client, we use the `send` method to send the data to the server.
    Once sent, the server receives it and performs the action as we have defined.
    Now let's check how the server is set up and how it behaves.
  prefs: []
  type: TYPE_NORMAL
- en: The server code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We have already seen in the last chapter how we can create a Node.js server.
    In a similar manner, we will create another application using NPM (please refer
    to [Chapter 2](ch02.html "Chapter 2. Getting Started with WebSockets"), *Getting
    Started with WebSockets* for instructions for setting up and running the server).
    Here is the server code that we need to write in the `server.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This code is pretty standard and straightforward. Let's break this down and
    understand what we have put here and why.
  prefs: []
  type: TYPE_NORMAL
- en: Code explanation
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Here, one of the main methods you can see is the `broadcast`. We write this
    method to broadcast the slide change data to all the users connected using WebSockets.
    We are simply looping through all the clients and send the data using the `send()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'After this, we define a variable in which we will be holding the slide data
    temporarily. This variable is important because whenever we get the slide data,
    we will store it and pass it when needed. There is a situation when users join
    the meeting at a later stage; using this data stored in this variable, we can
    provide them with the current slide number as stored:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now look at the following piece of code. Here, we are handling the connection
    event so that we can pass the current slide number data to the user. This event
    gives us the indication of the new user. While sending data, you will notice that
    we have used the `JSON.stringify` method. This method is used to make a string
    from JSON as our object is in the JSON format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Within this code, we can see that we have one parameter passed: the instance
    of the WebSocket object for that particular user. To receive messages, we need
    to add a `message` event handler which you can see in the following code. And
    the parameter is the actual message which is being passed from the client side:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'After getting the message, we check if the object passed is a JSON or not.
    So for this we have the JSON method defined, which basically checks for the JSON
    string and returns true/false. After the check we parse the JSON string and check
    if the value is similar to the last value of slide index data. If not, we store
    it and broadcast the message to all the clients. The check is necessary to avoid
    duplicate calls. Following is the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: And that is all—just a simple server code which is very powerful and works fine
    for our small applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we run the application, here is how it will look:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Code explanation](img/B03854_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can see that both have same first slide which is on index zero:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Code explanation](img/B03854_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: And once we navigate to other slides, the slides for other users also change.
    Take a look at the **Console** log in the left-hand side window. We can see that
    **sending slide data** along with slide number is displayed, which shows that
    upon slide change, the data is being sent. In the right-hand side window, we can
    see that **changing slide to** is logged in the console, which shows that the
    data is received from the server and accordingly we see the slide changing for
    the user.
  prefs: []
  type: TYPE_NORMAL
- en: '![Code explanation](img/B03854_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Similarly, if we change the slide from the right-hand side window, it will
    reflect on the left-hand side window, which is clearly visible from the logs.
    This same will happen for all users. Following is the screenshot of the logs as
    seen in the command prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Code explanation](img/B03854_03_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: On the sever side, we can see the data that is received and the data broadcast
    logs shows that the data is being passed on to all the users. Putting logs on
    the server side always helps to check the steps to debug the application.
  prefs: []
  type: TYPE_NORMAL
- en: Do it yourself
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This application is a very simple and easy to build application. You have learned
    how to create a simple application with some limited features. There can be many
    additions made to this application and it can be made more powerful. Let's give
    you some tips on features that you can develop.
  prefs: []
  type: TYPE_NORMAL
- en: Input username
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Whenever the user visits the URL, the application asks for the username. The
    username that is inputted is displayed in the top-left corner of the screen. I
    think this scenario is quite easy to build. I will leave its implementation to
    you. It is easy up to the point that we want to show the list of users, which
    is basically our next scenario.
  prefs: []
  type: TYPE_NORMAL
- en: The list of users
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Make a button which will show you a list of users that are currently online.
    This scenario needs code changes both on the client as well the server side. Let
    me list down some key points that you need to implement this feature:'
  prefs: []
  type: TYPE_NORMAL
- en: As soon as the user enters the name, save it on the server side. This can be
    achieved by sending the name of the user in a particular format and handling the
    same on the server side to store it in the array or object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Maintain a list of all the users on the server side for reference.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fetch the list of users from the server as soon as we join the server. This
    can be achieved by sending a particular message like `getUsers` and adding another
    entry on the `message` event handler returning the list of users.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make a button on the UI side and slide in the list of users.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: User-based authorization to change the presentation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the user enters the meeting, ask them whether they want to join as a presenter
    or attendee. If user chooses to join as a presenter, then allow the user to change
    the slide. If the user chooses to join as an attendee, then restrict the user
    from changing the slides.
  prefs: []
  type: TYPE_NORMAL
- en: 'Asking the user when they enter the name is easy; the slightly complicated
    part is restricting the user from changing the slides. That is easy if we dig
    into the configuration of the reveal.js library. In the configuration, we can
    see some parameters which are true and false. We just need to alter them as per
    the user type: presenter/attendee.'
  prefs: []
  type: TYPE_NORMAL
- en: Making the user the presenter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have the presenter and the attendee. Now let us make a provision for the
    presenter to give permission to the attendee. So from the list of users, if the
    presenter clicks on the user name then it will make that user the presenter.
  prefs: []
  type: TYPE_NORMAL
- en: This can be achieved in a simple way by changing the configuration of reveal.js
    at runtime. The same configuration that we changed earlier on the basis of role,
    we just need to invoke the same functionality on the change of role of the user.
  prefs: []
  type: TYPE_NORMAL
- en: Tips and tricks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's talk about some tips and tricks that you can use while making an application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using JSON:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The JSON format is an easily readable format in JavaScript. It is always good
    to transfer data in the JSON format.
  prefs: []
  type: TYPE_NORMAL
- en: 'Object-based structure for WebSockets:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Normally, in any application where we have to transfer different data sets,
    it is always preferred that we finalize a proper structure for the messages. Take
    the example of a chatting application: if we finalize a structure, it is better
    to handle the message. Here is a sample structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Using ArrayBuffer:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There is another way to send data using ArrayBuffer; you can also send a **Binary
    Large Object** (**BLOB**). Here is an example of the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: These kinds of structures can help in better understanding and can be used for
    different sets of messages. Here, the type can be a message, image, audio, file,
    or anything else. And the property data is generic, which can have the data for
    all these different types.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have seen how HTML5-based JavaScript libraries can be utilized.
    We have combined WebSockets with the reveal.js library for a collaborative application.
    This was a simple example, and you have seen that with less coding we have achieved
    a good working application. You have learned how to configure the server, send
    and receive data, and broadcast the data from the server to all the clients.
  prefs: []
  type: TYPE_NORMAL
- en: In the coming chapter, we will see the use of another library along with some
    frameworks, to develop a complete application using modern technologies.
  prefs: []
  type: TYPE_NORMAL
