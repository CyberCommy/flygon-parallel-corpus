- en: Starting to Write Your Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Getting configuration options
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing any value in a container/variable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing multiple chosen types in a container/variable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a safer way to work with a container that stores multiple chosen types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returning a value or flag where there is no value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returning an array from a function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Combining multiple values into one
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Binding and reordering function parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting a human-readable type name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the C++11 move emulation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making a noncopyable class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making a noncopyable but movable class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using C++14 and C++11 algorithms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Boost** is a collection of C++ libraries. Each library has been reviewed
    by many professional programmers before being accepted by Boost. Libraries are
    tested on multiple platforms using many compilers and many C++ standard library
    implementations. While using Boost, you can be sure that you are using one of
    the most portable, fast, and reliable solutions that is distributed under a license
    suitable for commercial and open source projects.'
  prefs: []
  type: TYPE_NORMAL
- en: Many parts of Boost have been included into C++11, C++14, and C++17\. Furthermore,
    Boost libraries will be included in the next standard of C++. You will find C++
    standard-specific notes in each recipe of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Without a long introduction, let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will see some recipes for everyday use. We'll see how to
    get configuration options from different sources and what can be cooked up using
    some of the data types introduced by Boost library authors.
  prefs: []
  type: TYPE_NORMAL
- en: Getting configuration options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Take a look at some of the console programs, such as `cp` in Linux. They all
    have a fancy help; their input parameters do not depend on any position and have
    a human-readable syntax. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You can implement the same functionality for your program in 10 minutes. All
    you need is the `Boost.ProgramOptions` library.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Basic knowledge of C++ is all you need for this recipe. Remember that this library
    is not only a header, so your program has to link against the `libboost_program_options`
    library.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start with a simple program that accepts the count of `apples` and `oranges`
    as input and counts the total number of fruits. We want to achieve the following
    result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Include the `boost/program_options.hpp` header and make an alias for the `boost::program_options`
    namespace (it is too long to type it!). We would also need an `<iostream>` header:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we are ready to describe our options in the `main()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s parse the command line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s add some code for processing the `help` option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Final step. Counting fruits may be implemented in the following way:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we call our program with the `help` parameter, we''ll get the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we do not provide a type for the `help` option's value, because
    we do not expect any values to be passed to it.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This example is pretty simple to understand from code and comments. Running
    it produces the expected result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The C++ standard adopted many Boost libraries; however, you won't find `Boost.ProgramOptions`
    even in C++17\. Currently, there's no plan to adopt it into C++2a.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ProgramOptions` library is very powerful and has many features. Here''s
    how to:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Parse configuration option values directly into a variable and make that option
    a required one:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Get some mandatory string option:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Add short name for apple, set `10` as a default value for `apples`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Get the missing options from the configuration file:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The configuration file syntax differs from the command-line syntax. We do not
    need to place minuses before the options. So, our `apples_oranges.cfg` file must
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`oranges=20`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Validate that all the required options were set:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If we combine all the mentioned tips into a single executable, then its `help`
    command will produce this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Running it without a configuration file will produce the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the program with `oranges=20` in the configuration file will generate
    ++, because the default value for apples is `10`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Boost's official documentation contains many more examples and tells us about
    more advanced features of `Boost.ProgramOptions`, such as position-dependent options,
    nonconventional syntax, and more; this is available at [http://boost.org/libs/program_options](http://boost.org/libs/program_options)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can modify and run all the examples from this book online at [http://apolukhin.github.io/Boost-Cookbook](http://apolukhin.github.io/Boost-Cookbook)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing any value in a container/variable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you have been programming in Java, C#, or Delphi, you will definitely miss
    the ability of creating containers with the `Object` value type in C++. The `Object`
    class in those languages is a basic class for almost all types, so you are able
    to assign almost any value to it at any time. Just imagine how great it would
    be to have such a feature in C++:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll be working with the header-only library. The basic knowledge of C++ is
    all you need for this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Boost offers a solution, the `Boost.Any` library, that has an even better syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Great, isn't it? By the way, it has an empty state, which could be checked using
    the `empty()` member function (just like in standard library containers).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can get the value from `boost::any` using two approaches:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `boost::any` class just stores any value in it. To achieve this, it uses
    the **type erasure** technique (close to what Java or C# does with all types).
    To use this library you do not really need to know its internal implementation
    in detail, but here's a quick glance at the type erasure technique for the curious.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the assignment of some variable of type `T`, `Boost.Any` instantiates a
    `holder<T>` type that may store a value of the specified type `T` and is derived
    from some base-type `placeholder`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'A `placeholder` type has virtual functions for getting `std::type_info` of
    a stored type `T` and for cloning a stored type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '`boost::any` stores `ptr`-- a pointer to `placeholder`. When `any_cast<T>()`
    is used, `boost::any` checks that calling `ptr->type()` gives `std::type_info`
    equal to `typeid(T)` and returns `static_cast<holder<T>*>(ptr)->held`.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Such flexibility never comes without any cost. Copy constructing, value constructing,
    copy assigning, and assigning values to instances of `boost::any` do dynamic memory
    allocation; all the type casts do **RunTime Type Information** (**RTTI**) checks;
    `boost::any` uses virtual functions a lot. If you are keen on performance, the
    next recipe will give you an idea of how to achieve almost the same results without
    dynamic allocations and RTTI usage.
  prefs: []
  type: TYPE_NORMAL
- en: '`boost::any` makes use of **rvalue references** but can not be used in **constexpr**.'
  prefs: []
  type: TYPE_NORMAL
- en: The `Boost.Any` library was accepted into C++17\. If your compiler is C++17
    compatible and you wish to avoid using Boost for `any`, just replace the `boost`
    namespace with namespace `std` and include `<any>` instead of `<boost/any.hpp>`.
    Your standard library implementation may work slightly faster if you are storing
    tiny objects in `std::any`.
  prefs: []
  type: TYPE_NORMAL
- en: '`std::any` has the `reset()` function instead of `clear()` and `has_value()`
    instead of `empty()`. Almost all exceptions in Boost derived from the `std::exception`
    class or from its derivatives, for example, `boost::bad_any_cast` is derived from
    `std::bad_cast`. It means that you can catch almost all Boost exceptions using
    `catch (const std::exception& e)`.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Boost's official documentation may give you some more examples; it can be found
    at [http://boost.org/libs/any](http://www.boost.org/libs/any)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Using a safer way to work with a container that stores multiple chosen
    types* recipe for more info on the topic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing multiple chosen types in a container/variable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C++03 unions can only hold extremely simple types called **Plain Old Data**
    (**POD**). For example in C++03, you cannot store `std::string` or `std::vector`
    in a union.
  prefs: []
  type: TYPE_NORMAL
- en: Are you aware of the concept of **unrestricted unions** in C++11? Let me tell
    you about it briefly. C++11 relaxes requirements for unions, but you have to manage
    the construction and destruction of non POD types by yourself. You have to call
    in-place construction/destruction and remember what type is stored in a union.
    A huge amount of work, isn't it?
  prefs: []
  type: TYPE_NORMAL
- en: Can we have an unrestricted union like variable in C++03 that manages the object
    lifetime and remembers the type it has?
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll be working with the header-only library, which is simple to use. Basic
    knowledge of C++ is all you need for this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let me introduce the `Boost.Variant` library to you.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Boost.Variant` library can store any of the types specified at compile
    time. It also manages in-place construction/destruction and even does not even
    require the C++11 standard:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Great, isn't it?
  prefs: []
  type: TYPE_NORMAL
- en: '`Boost.Variant` has no empty state, but has an `empty()` function which is
    useless and always returns `false`. If you need to represent an empty state, just
    add some simple type at the first position of the types supported by the `Boost.Variant`
    library. When `Boost.Variant` contains that type, interpret it as an empty state.
    Here is an example in which we will use a `boost::blank` type to represent an
    empty state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'You can get a value from a variant using two approaches:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `boost::variant` class holds an array of bytes and stores values in that
    array. The size of the array is determined at compile time by applying `sizeof()`
    and functions to get alignment to each of the template types. On assignment, or
    construction of `boost::variant`, the previous values are in-place destructed
    and new values are constructed on top of the byte array, using the placement new.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Boost.Variant` variables usually do not dynamically allocate memory, and
    they do not require RTTI to be enabled. `Boost.Variant` is extremely fast and
    used widely by other Boost libraries. To achieve maximum performance, make sure
    that there is a simple type in the list of supported types at the first position.
    `boost::variant` takes advantage of C++11 rvalue references if they are available
    on your compiler.
  prefs: []
  type: TYPE_NORMAL
- en: '`Boost.Variant` is part of the C++17 standard. `std::variant` differs slightly
    from the`boost::variant`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`std::variant` is declared in the `<variant>` header file rather than in `<boost.variant.hpp>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::variant` never ever allocates memory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::variant` is usable with constexpr'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instead of writing `boost::get<int>(&variable)`, you have to write `std::get_if<int>(&variable)`
    for `std::variant`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::variant` can not recursively hold itself and misses some other advanced
    techniques'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::variant` can in-place construct objects'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::variant` has `index()` instead of `which()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Using a safer way to work with a container that stores multiple chosen
    types* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Boost''s official documentation contains more examples and descriptions of
    some other features of `Boost.Variant`, and can be found at: [http://boost.org/libs/variant](http://www.boost.org/libs/variant)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Experiment with the code online at [http://apolukhin.github.io/Boost-Cookbook](http://apolukhin.github.io/Boost-Cookbook)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a safer way to work with a container that stores multiple chosen types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine that you are creating a wrapper around some SQL database interface.
    You decided that `boost::any` will perfectly match the requirements for a single
    cell of the database table.
  prefs: []
  type: TYPE_NORMAL
- en: Some other programmer will use your classes, and his/her task would be to get
    a row from the database and count the sum of the arithmetic types in a row.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what such a code would look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'If you compile and run this example, it will output a correct answer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Do you remember what your own thoughts were when reading the implementation
    of `operator()`? I guess they were, *"And what about double, long, short, unsigned,
    and other types?"* The same thoughts will come into the head of a programmer who
    will use your interface. So, you need to carefully document values stored by your
    `cell_t` or use a more elegant solution as described in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reading the previous two recipes is highly recommended if you are not already
    familiar with the `Boost.Variant` and `Boost.Any` libraries.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Boost.Variant` library implements a visitor programming pattern for accessing
    the stored data, which is much safer than getting values via `boost::get<>`. This
    pattern forces the programmer to take care of each type in variant, otherwise
    the code will fail to compile. You can use this pattern via the `boost::apply_visitor`
    function, which takes a `visitor` functional object as the first parameter and
    a `variant` as the second parameter. If you are using a pre C++14 compiler, then
    `visitor` functional objects must derive from the `boost::static_visitor<T>` class,
    where `T` is a type being returned by a `visitor`. A `visitor` object must have
    overloads of `operator()` for each type stored by a variant.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s change the `cell_t` type to `boost::variant<int, float, string>` and
    modify our example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At compile time, the `Boost.Variant` library generates a big `switch` statement,
    each case of which calls a `visitor` for a single type from the variant''s list
    of types. At runtime, the index of the stored type is retrieved using `which()`
    and jumps to a correct case in `switch` statement is made. Something like this
    will be generated for `boost::variant<int, float, std::string>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `address()` function returns a pointer to the internal storage of
    `boost::variant<int, float, std::string>`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If we compare this example with the first example in this recipe, we''ll see
    the following advantages of `boost::variant`:'
  prefs: []
  type: TYPE_NORMAL
- en: We know what types a variable can store
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a library writer of the SQL interface adds or modifies a type held by a `variant`,
    we'll get a compile-time error instead of incorrect behavior
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::variant` from C++17 also supports visitation. Just write `std::visit`
    instead of `boost::apply_visitor` and you''re done.'
  prefs: []
  type: TYPE_NORMAL
- en: You can download the example code files for all Packt books that you have purchased
    from your account at [http://www.PacktPub.com](http://www.PacktPub.com). If you
    purchased this book elsewhere, you can visit [http://www.PacktPub.com/](http://www.PacktPub.com/)support,
    and register to have the files emailed directly to you.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After reading some recipes from [Chapter 4](part0218.html#6FSQK0-712b4ba1126a4c7c89e1d44de61b4bdd),
    *Compile-Time Tricks*, you'll be able to make generic `visitor` objects that work
    correctly even if underlying types change
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Boost''s official documentation contains more examples and a description of
    some other features of `Boost.Variant`; it is available at the following link:
    [http://boost.org/libs/variant](http://www.boost.org/libs/variant)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returning a value or flag where there is no value
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine that we have a function that does not throw an exception and returns
    a value or indicates that an error has occurred. In Java or C# programming languages,
    such cases are handled by comparing a return value from a function value with
    a `null` pointer. If the function returned `null`, then an error has occurred.
    In C++, returning a pointer from a function confuses library users and usually
    requires slow dynamic memory allocation.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Only basic knowledge of C++ is required for this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Ladies and gentlemen, let me introduce you to the `Boost.Optional` library
    using the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `try_lock_device()` function tries to acquire a lock for a device and may
    succeed or not, depending on different conditions (in our example it depends on
    some `try_lock_device_impl()` function call):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The function returns the `boost::optional` variable that can be converted to
    a `bool`. If the returned value is equal to `true`, then the lock is acquired
    and an instance of a class to work with the device can be obtained by dereferencing
    the returned optional variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This program will output the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The default constructed `optional` variable is convertible to `false` and must
    not be dereferenced, because such an `optional` does not have an underlying type
    constructed.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`boost::optional<T>` under the hood has a properly aligned array of bytes where
    the object of type `T` can be an in-place constructed. It also has a `bool` variable
    to remember the state of the object (is it constructed or not?).'
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Boost.Optional` class does not use dynamic allocation and it does not require
    a default constructor for the underlying type. The current `boost::optional` implementation
    can work with C++11 rvalue references but is not usable with constexpr.
  prefs: []
  type: TYPE_NORMAL
- en: If you have a class `T` that has no empty state but your program logic requires
    an empty state or uninitialized `T`, then you have to come up with some workaround.
    Traditionally, users create some smart pointer to the class `T`, keep a `nullptr`
    in it, and dynamically allocate `T` if non empty state is required. Stop doing
    that! Use `boost::optional<T>` instead. It's a much faster and more reliable solution.
  prefs: []
  type: TYPE_NORMAL
- en: The C++17 standard includes the `std::optional` class. Just replace `<boost/optional.hpp>`
    with `<optional>` and `boost::` with `std::` to use the standard version of this
    class. `std::optional` is usable with constexpr.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Boost''s official documentation contains more examples and describes advanced
    features of `Boost.Optional` (like in-place construction). The documentation is
    available at the following link: [http://boost.org/libs/optional.](http://www.boost.org/libs/optional)'
  prefs: []
  type: TYPE_NORMAL
- en: Returning an array from a function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's play a game of guessing! What can you tell about the following function?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Should return values be deallocated by the programmer or not? Does the function
    attempt to deallocate the input parameter? Should the input parameter be zero-terminated,
    or should the function assume that the input parameter has a specified width?
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s make the task harder! Take a look at the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Do not worry. I've also been scratching my head for half an hour before getting
    an idea of what is happening here. `vector_advance` is a function that accepts
    and returns an array of four elements. Is there a way to write such a function
    clearly?
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Only basic knowledge of C++ is required for this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can rewrite the function like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Here, `boost::array<char, 4>` is just a simple wrapper around an array of four
    `char` elements.
  prefs: []
  type: TYPE_NORMAL
- en: This code answers all the questions from our first example and is much more
    readable than the code from the second example.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`boost::array` is a fixed-size array. The first template parameter of `boost::array`
    is the element type and the second one is the size of an array. If you need to
    change the array size at runtime, use `std::vector` , `boost::container::small_vector`,
    `boost::container::stack_vector`, or `boost::container::vector` instead.'
  prefs: []
  type: TYPE_NORMAL
- en: The `boost::array<>` class has no handwritten constructors and all its members
    are public, so the compiler will treat it as a POD type.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s see some more examples of the usage of `boost::array`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: One of the biggest advantages of `boost::array` is that it does not allocated
    dynamic memory and provides exactly the same performance as a usual C array. People
    from the C++ Standard committee also liked it, so it was accepted to the C++11
    standard. Try to include the `<array>` header and check for the availability of
    `std::array`. `std::array` has a better support for usage with constexpr since
    C++17.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Boost''s official documentation gives a complete list of the `Boost.Array`
    methods with a description of the method''s complexity and throw behavior. It
    is available at the following link: [http://boost.org/libs/array.](http://www.boost.org/libs/array)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `boost::array` function is widely used across recipes; for example, refer
    to the *Binding a value as a function parameter* recipe.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Combining multiple values into one
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is a very nice present for those who like `std::pair`. Boost has a library
    called `Boost.Tuple`. It is just like `std::pair`, but it can also work with triples,
    quads, and even bigger collections of types.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Only basic knowledge of C++ and a standard library is required for this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Perform the following steps to combine multiple values into one:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To start working with tuples, you need to include a proper header and declare
    a variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Getting a specific value is implemented via the `boost::get<N>()` function,
    where `N` is a zero-based index of a required value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The `boost::get<>` function has many overloads and is used widely across Boost.
    We already saw how it can be used with other libraries in the *Storing multiple
    chosen types in a container/variable* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can construct tuples using the `boost::make_tuple()` function, which is
    shorter to write, because you do not need to fully qualify the tuple type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Another function that makes life easier is `boost::tie()`. It works almost
    as `make_tuple`, but adds a nonconst reference for each of the passed types. Such
    a tuple can be used to get values to a variable from another tuple. It can be
    better understood from the following example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Some readers may wonder why we need a tuple when we can always write our own
    structures with better names; for example, instead of writing `boost::tuple<int,
    std::string>`, we can create a structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Well, this structure is definitely clearer than `boost::tuple<int, std::string>`.
    The main idea behind the tuple's library is to simplify template programming.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A tuple works as fast as `std::pair` (it does not allocate memory on a heap
    and has no virtual functions). The C++ committee found this class to be very useful
    and it was included in the standard library. You can find it in a C++11 compatible
    implementation in the header file `<tuple>` (don't forget to replace all the `boost::`
    namespaces with `std::`).
  prefs: []
  type: TYPE_NORMAL
- en: 'The standard library version of tuple must have multiple micro optimizations
    and typically provides a slightly better user experience. However, there is no
    guarantee on the order of construction of tuple elements, so, if you need a tuple
    that constructs its elements starting from the first, you have to use the `boost::tuple`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The current Boost implementation of a tuple does not use variadic templates,
    does not support rvalue references, does not support C++17 structured bindings,
    and is not usable with constexpr.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Boost's official documentation contains more examples, information about performance,
    and abilities of `Boost.Tuple`. It is available at the link [http://boost.org/libs/tuple](http://www.boost.org/libs/tuple).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Converting all tuple elements to a string* recipe in [Chapter 8](part0425.html#CL9V20-712b4ba1126a4c7c89e1d44de61b4bdd),
    *Metaprogramming,* shows some advanced usages of tuples.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Binding and reordering function parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you work with the standard library a lot and use the `<algorithm>` header,
    you definitely write a lot of functional objects. In C++14, you can use generic
    lambdas for that. In C++11, you only have non generic lambdas. In the earlier
    versions of the C++ standard, you can construct functional objects using adapter
    functions such as `bind1st`, `bind2nd`, `ptr_fun`, `mem_fun`, `mem_fun_ref`, or
    you can write them by hand (because adapter functions look scary). Here is some
    good news: `Boost.Bind` can be used instead of ugly adapter functions, and it
    provides a more human-readable syntax.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A knowledge of standard library functions and algorithms will be helpful.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s see some examples of the usage of `Boost.Bind` along with C++11 lambda
    classes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'All the samples require the following headers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Count values greater than 5 as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'This is how we may count empty strings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s count strings with a length less than `5`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Compare the strings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `boost::bind` function returns a functional object that stores a copy of
    bound values and a copy of the original functional object. When the actual call
    to `operator()` is performed, the stored parameters are passed to the original
    functional object along with the parameters passed at the time of call.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Take a look at the previous examples. When we are binding values, we copy a
    value into a functional object. For some classes this operation is expensive.
    Is there a way to bypass copying?
  prefs: []
  type: TYPE_NORMAL
- en: 'Yes, there is! `Boost.Ref` library will help us here! It contains two functions,
    `boost::ref()` and `boost::cref()`, the first of which allows us to pass a parameter
    as a reference, and the second one passes the parameter as a constant reference.
    The `ref()` and `cref()` functions just construct an object of type `reference_wrapper<T>`
    or `reference_wrapper<const T>`, which is implicitly convertible to a reference
    type. Let''s change our last examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also reorder, ignore, and duplicate function parameters using `bind`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The functions `ref` , `cref`, and `bind` are accepted to the C++11 standard
    and are defined in the `<functional>` header in the `std::` namespace. All these
    functions do not dynamically allocate memory and do not use virtual functions.
    The objects returned by them are easy to optimize for a good compiler.
  prefs: []
  type: TYPE_NORMAL
- en: Standard library implementations of those functions may have additional optimizations
    to reduce compilation time or just compiler-specific optimizations. You may use
    the standard library versions of `bind`, `ref`, `cref` functions with any Boost
    library or even mix Boost and standard library versions.
  prefs: []
  type: TYPE_NORMAL
- en: If you are using the C++14 compiler, then use generic lambdas instead of `std::bind`
    and `boost::bind`, as they are less obscure and simpler to understand. C++17 lambdas
    are usable with constexpr, unlike `std::bind` and `boost::bind`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The official documentation contains many more examples and a description of
    advanced features at [http://boost.org/libs/bind.](http://www.boost.org/libs/bind)
  prefs: []
  type: TYPE_NORMAL
- en: Getting a human-readable type name
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is often a need to get a readable type name at runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: However, the example from earlier is not very portable. It does not work when
    RTTI is disabled, and it does not always produce a nice human-readable name. On
    some platforms, code from earlier will output just `i` or `d`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Things get worse if we need a type name without stripping the `const`, `volatile`,
    and references:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Unfortunately, the preceding code outputs `int` in the best case, which is not
    what we were expecting.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Basic knowledge of C++ is required for this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the first case, we need a human-readable type name without qualifiers. The
    `Boost.TypeIndex` library will help us out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'In the second case, we need to keep the qualifiers, so we need to call a slightly
    different function from the same library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Boost.TypeIndex` library has a lot of workarounds for different compilers
    and knows the most efficient way to produce a human-readable name for the type.
    If you provide a type as a template parameter, the library guarantees that all
    the possible type related computations will be performed at compile time and code
    will work even if RTTI is disabled.
  prefs: []
  type: TYPE_NORMAL
- en: '`cvr` in `boost::typeindex::type_id_with_cvr` stands for `const`, `volatile`,
    and reference. That makes sure that the type won''t be decayed.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the `boost::typeindex::type_id*` functions return instances of `boost::typeindex::type_index`.
    It is very close to `std::type_index`; however, it additionally, it has a `raw_name()`
    method for getting a raw type name, and `pretty_name()` for getting human-readable
    type name.
  prefs: []
  type: TYPE_NORMAL
- en: Even in C++17, `std::type_index` and `std::type_info` return platform-specific
    type names representations that are rather hard to decode or use portably.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike the standard library's `typeid()`, some classes from `Boost.TypeIndex`
    are usable with constexpr. It means that you can get a textual representation
    of your type at compile time if you use a specific `boost::typeindex::ctti_type_index`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: Users can invent their own RTTI implementations using the `Boost.TypeIndex`
    library. This could be useful for embedded developers and for applications that
    require extremely efficient RTTI tuned for particular types.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Documentation on advanced features and more examples are available at [http://boost.org/libs/type_index.](http://www.boost.org/libs/type_index)
  prefs: []
  type: TYPE_NORMAL
- en: Using the C++11 move emulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the greatest features of the C++11 standard is rvalue references. This
    feature allows us to modify temporary objects, stealing resources from them. As
    you can guess, the C++03 standard has no rvalue references, but using the `Boost.Move`
    library, you can write a portable code that emulates them.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is highly recommended that you are at least familiar with the basics of C++11
    rvalue references.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Imagine that you have a class with multiple fields, some of which are standard
    library containers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: It is time to add the move assignment and move constructors to it! Just remember
    that in the C++03 standard library, containers have neither move operators nor
    move constructors.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The correct implementation of the move assignment is the same move constructing
    an object and swapping it with `this`. The correct implementation of the move
    constructor is close to the default construct and `swap`. So, let''s start with
    the `swap` member function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, put the following macro in the `private` section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Write a copy constructor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Write a copy assignment, taking the parameter as: `BOOST_COPY_ASSIGN_REF(person_info)`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Write a `move` constructor and a move assignment, taking the parameter as `BOOST_RV_REF(person_info)`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Now, we have a portable fast implementation of the move assignment and move
    construction operators of the `person_info` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here is an example of how the move assignment can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: The `Boost.Move` library is implemented in a very efficient way. When the C++11
    compiler is used, all the macros for rvalues emulation are expanded to C++11-specific
    features otherwise (on C++03 compilers), rvalues are emulated.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Have you noticed the `boost::swap` call? It is a really helpful utility function,
    which first searches for a `swap` function in the namespace of a variable (in
    our example, it's namespace `other::`), and if there is no matching swap function,
    it uses the `std::swap`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: More information about emulation implementation can be found on the Boost website
    and in the sources of the `Boost.Move` library at [http://boost.org/libs/move.](http://www.boost.org/libs/move)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Boost.Utility` library is the one that contains `boost::swap`, and it has
    many useful functions and classes. Refer to [http://boost.org/libs/utility](http://www.boost.org/libs/utility)
    for its documentation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Initializing a base class by the member of derived* recipe in [Chapter
    2](part0108.html#36VSO0-712b4ba1126a4c7c89e1d44de61b4bdd), *Managing Resources.*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Making a noncopyable class* recipe.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the *Making a noncopyable but movable class* recipe, there is more info about
    `Boost.Move` and some examples on how we can use the movable objects in containers
    in a portable and efficient way.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making a noncopyable class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You have almost certainly encountered certain situations, where a class owns
    some resources that must not be copied for technical reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The C++ compiler in the preceding example generates a copy constructor and
    an assignment operator, so the potential user of the `descriptor_owner` class
    will be able to create the following awful things:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Only very basic knowledge of C++ is required for this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To avoid such situations, the `boost::noncopyable` class was invented. If you
    derive your own class from it, the copy constructor and assignment operator won''t
    be generated by the C++ compiler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the user won''t be able to do bad things:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A refined reader will note that we can achieve exactly the same result by:'
  prefs: []
  type: TYPE_NORMAL
- en: Making a copy constructor and an assignment operator of `descriptor_owning_fixed`
    private
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining them without actual implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explicitly deleting them using C++11 syntax `= delete;`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Yes, you are correct. Depending on the abilities of your compiler, `boost::noncopyable`
    class chooses the best way to make the class noncopyable.
  prefs: []
  type: TYPE_NORMAL
- en: '`boost::noncopyable` also serves as a good documentation for your class. It
    never raises questions such as "Is the copy constructor body defined elsewhere?"
    or "Does it have a nonstandard copy constructor (with a non-const referenced parameter)?"'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Making a noncopyable, but movable class* recipe will give you ideas on
    how to allow unique owning of a resource in C++03 by moving it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You may find a lot of helpful functions and classes in the `Boost.Core` library's
    official documentation at [http://boost.org/libs/core](http://boost.org/libs/core)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Initializing a base class by the member of derived* recipe in [Chapter
    2](part0108.html#36VSO0-712b4ba1126a4c7c89e1d44de61b4bdd), *Managing Resources*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Using C++11 move emulation* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making a noncopyable but movable class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, imagine the following situation: we have a resource that cannot be copied,
    which should be correctly freed in a destructor, and we want to return it from
    a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Actually, you can work around such situations using the `swap` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: However, such a workaround does not allow us to use `descriptor_owner` in containers.
    By the way, it looks awful!
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is highly recommended that you are at least familiar with the basics of C++11
    rvalue references. Reading the *Using C++11 move emulation* recipe is also recommended.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Those readers who use C++11, already know about the move-only classes (like
    `std::unique_ptr` or `std::thread`). Using such an approach, we can make a move-only
    `descriptor_owner` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: This will work only on the C++11 compatible compilers. That is the right moment
    for `Boost.Move`! Let's modify our example, so it can be used on C++03 compilers.
  prefs: []
  type: TYPE_NORMAL
- en: 'According to the documentation, to write a movable but noncopyable type in
    portable syntax, we need to follow these simple steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Put the `BOOST_MOVABLE_BUT_NOT_COPYABLE(classname)` macro in the `private`
    section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Write a move constructor and a move assignment, taking the parameter as `BOOST_RV_REF(classname)`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we have a movable, but non copyable, class that can be used even on C++03
    compilers and in `Boost.Containers`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Unfortunately, C++03 standard library containers still won't be able to use
    it (that is why we used a vector from `Boost.Containers` in the previous example).
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you want to use `Boost.Containers` on C++03 compilers, but standard library
    containers on C++11 compilers, you can do the following simple trick. Add the
    header file to your project with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can include `<your_project/vector.hpp>` and use a vector from the
    namespace `your_project_namespace`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: However, beware of compiler and standard library implementation-specific issues!
    For example, this code will compile on GCC 4.7 in C++11 mode only if you mark
    the move constructor, destructor, and move assignment operators with `noexcept`
    or `BOOST_NOECEPT`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Reducing code size and increasing performance of user-defined type in C++11*
    recipe in [Chapter 10](part0525.html#FKLNA0-712b4ba1126a4c7c89e1d44de61b4bdd),
    *Gathering Platform and Compiler Information*, provides more info on `noexcept`
    and `BOOST_NOEXCEPT`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More information about `Boost.Move` can be found on Boost's website [http://boost.org/libs/move.](http://www.boost.org/libs/move)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using C++14 and C++11 algorithms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'C++11 has a bunch of new cool algorithms in `<algorithm>` header. C++14 has
    even more algorithms. If you''re stuck with the pre-C++11 compiler, you have to
    write those from scratch. For example, if you wish to output characters from 65
    to 125 code points, you have to write the following code on a pre-C++11 compiler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Basic knowledge of C++ is required for this recipe along with basic knowledge
    of `Boost.Array` library.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Boost.Algorithm` library has all the new C++11 and C++14 algorithms. Using
    it, you can rewrite the previous example in the following manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you are probably aware, `Boost.Algorithm` has a header file for each algorithm.
    Just include the header file and use the required function.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s boring to have a library that just implements algorithms from C++ standard.
    That''s not innovative; that''s not the Boost way! That''s why you can find in
    `Boost.Algorithm`, functions that are not part of C++. Here, for example, is a
    function that converts input into hexadecimal representation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code outputs the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'What''s more interesting, all the functions have additional overloads that
    accept a range as a first parameter instead of two iterators. **Range** is a concept
    from **Ranges TS**. Arrays and containers that have `.begin()` and `.end()` functions
    satisfy the range concept. With that knowledge the previous example could be shortened:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: C++17 will have searching algorithms from `Boost.Algorithm`. `Boost.Algorithm`
    library will be soon extended with new algorithms and C++20 features like constexpr
    usable algorithms. Keep an eye on that library, as some day, it may get an out-of-the-box
    solution for a problem that you're dealing with.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Official documentation for `Boost.Algorithm` contains a full list of functions
    and short descriptions for them at [http://boost.org/libs/algorithm](http://boost.org/libs/algorithm)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Experiment with new algorithms online: [http://apolukhin.github.io/Boost-Cookbook](http://apolukhin.github.io/Boost-Cookbook)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
