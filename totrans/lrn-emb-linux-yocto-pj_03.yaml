- en: Chapter 3. Bootloaders
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you will be presented with one of the most important components
    necessary for using a Linux system in an embedded environment. Here, I am referring
    to the bootloader, a piece of software that offers the possibility of initializing
    a platform and making it ready to boot a Linux operating system. In this chapter,
    the benefits and roles of bootloaders will be presented. This chapter mainly focuses
    on the U-Boot bootloaders, but readers are encouraged to have a look at others,
    such as Barebox, RedBoot, and so on. All these bootloaders have their respective
    features and there isn't one in particular that suits every need; therefore, experimentation
    and curiosity are welcome when this chapter. You have already been introduced
    to the the Yocto Project reference in the last chapter; hence, you will now be
    able to understand how this development environment works with various bootloaders,
    and especially the ones available inside a **Board Support Package** (**BSP**).
  prefs: []
  type: TYPE_NORMAL
- en: The main purpose of this chapter is to present the main properties of embedded
    bootloaders and firmware, their booting mechanisms, and the problems that appear
    when firmware is updated or modified. We will also discuss the problems related
    to safety, installation, or fault tolerance. With regard to bootloader and firmware
    notions, we have multiple definitions available and a number of them refer to
    traditional desktop systems, which we are not interested in.
  prefs: []
  type: TYPE_NORMAL
- en: 'A firmware usually represents a fixed and small program that is used on a system
    to control hardware. It performs low-level operations and is usually stored on
    flash, ROM, EPROM, and so on. It is not changed very often. Since there have been
    situations where this term has confused people and was sometimes used only to
    define hardware devices or represent data and its instructions, it was avoided
    altogether. It represents a combination of the two: computer data and information,
    along with the hardware device combined in a read-only piece of software available
    on the device.'
  prefs: []
  type: TYPE_NORMAL
- en: The bootloader represents the piece of software that is first executed during
    system initialization. It is used to load, decompress, and execute one or more
    binary applications, such as a Linux kernel or a root filesystem. Its role involves
    adding the system in a state where it can execute its primary functions. This
    is done after loading and starting the correct binary applications that it receives
    or has already saved on the internal memory. Upon initializing, the hardware bootloader
    may need to initialize the **phase-locked loop** (**PLL**), set the clocks, or
    enable access to the RAM memory and other peripherals. However, these initializations
    are done on a basic level; the rest are done by kernels drivers and other applications.
  prefs: []
  type: TYPE_NORMAL
- en: Today, a number of bootloaders are available. Due to limited space available
    for this topic, and also the fact that their number is high, we will only discuss
    the most popular ones. U-Boot is one of the most popular bootloaders available
    for architectures, such as PowerPC, ARM, MIPS, and others. It will constitute
    the primary focus of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The role of the bootloader
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first time that electricity runs into a development board processor, a great
    number of hardware components need to be prepared before running a program. For
    each architecture, hardware manufacturer, and even processor, this initialization
    process is different. In most cases, it involves a set of configurations and actions
    are different for a variety of processors and ends up fetching the bootstrap code
    from a storage device available in the proximity of the processor. This storage
    device is usually a flash memory and the bootstrap code is the first stage of
    the bootloader, and the one that initializes the processor and relevant hardware
    peripherals.
  prefs: []
  type: TYPE_NORMAL
- en: The majority of the available processors when power is applied to them go to
    a default address location, and after finding the first bytes of binary data,
    start executing them. Based on this information, the hardware designers define
    the layout for the flash memory and the address ranges that could later be used
    to load and boot the Linux operating system from predictable addresses.
  prefs: []
  type: TYPE_NORMAL
- en: In the first stage of initialization, the board init is done, usually in the
    assembler language specific to the processor and after this is finished, the entire
    ecosystem is prepared for the operating system booting process. The bootloader
    is responsible for this; it is the component that offers the possibility to load,
    locate, and execute primary components of the operating system. Additionally,
    it can contain other advanced features, such as the capability to upgrade the
    OS image, validate an OS image, choose between several OS images, and even the
    possibility to upgrade itself. The difference between the traditional PC BIOS
    and an embedded bootloader is the fact that in an embedded environment, the bootloader
    is overwritten after the Linux kernel starts execution. It, in fact, ceases to
    exist after it offers control to the OS image.
  prefs: []
  type: TYPE_NORMAL
- en: Bootloaders need to carefully initialize peripherals, such as flash or DRAM,
    before they are used. This is not an easy task to do. For example, the DRAM chips
    cannot be read or written in a direct method - each chip has a controller that
    needs to be enabled for read and write operations. At the same time, the DRAM
    needs to be continually refreshed because the data will be lost otherwise. The
    refresh operation, in fact, represents the reading of each DRAM location within
    the time frame mentioned by the hardware manufacturer. All these operations are
    the DRAM controller's responsibility, and it can generate a lot of frustration
    for the embedded developer because it requires specific knowledge about the architecture
    design and DRAM chip.
  prefs: []
  type: TYPE_NORMAL
- en: A bootloader does not have the infrastructure that a normal application has.
    It does not have the possibility to only be called by its name and start executing.
    After being switched on when it gains control, it creates its own context by initializing
    the processor and necessary hardware, such as DRAM, moves itself in the DRAM for
    faster execution, if necessary and finally, starts the actual execution of code.
  prefs: []
  type: TYPE_NORMAL
- en: The first element that poses as a complexity is the compatibility of the start
    up code with the processor's boot sequence. The first executable instructions
    need to be at a predefined location in the flash memory, which is dependent of
    the processor and even hardware architecture. There is also the possibility for
    a number of processors to seek for those first executable instructions in several
    locations based on the hardware signals that are received.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another possibility is to have the same structure on many of the newly available
    development boards, such as the Atmel SAMA5D3-Xplained:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The role of the bootloader](img/image00306.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: For the Atmel SAMA5D3-Xplained board and others similar to it, the booting starts
    from an integrated boot code available in the ROM memory called BootROM on AT91
    CPUs, which loads the first stage bootloader called AT91Bootstrap on SRAM and
    starts it. The first stage bootloader initializes the DRAM memory and starts the
    second stage bootloader, which is U-Boot in this case. More information on boot
    sequence possibilities can be found in the boot sequence header available, which
    you'll read about shortly.
  prefs: []
  type: TYPE_NORMAL
- en: The lack of an execution context represents another complexity. Having to write
    even a simple `"Hello World"` in a system without a memory and, therefore, without
    a stack on which to allocate information, would look very different from the well-known
    "Hello World" example. This is the reason why the bootloader initializes the RAM
    memory to have a stack available and is able to run higher-level programs or languages,
    such as C.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing various bootloaders
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we read earlier, a number of bootloaders are available for embedded systems.
    The ones that will be presented here are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**U-Boot**: This is also called the Universal Bootloader and is available mostly
    for PowerPC and ARM architectures for embedded Linux systems'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Barebox**: This was initially known as U-Boot v2 and was started in 2007
    with the scope to solve the limitations of U-Boot; it changed its name over time
    because the design goals and community changed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**RedBoot**: This is a RedHat bootloader derived from eCos, an open-source
    real-time operating system that is portable and devised for embedded systems'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**rrload**: This is a bootloader for ARM and is based on embedded Linux systems'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PPCBOOT**: This is a bootloader for PowerPC and is based on embedded Linux
    systems'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CLR/OHH**: This represents a flash bootloader for embedded Linux systems
    based on an ARM architecture'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Alios**: This is a bootloader that is written mostly in assembler, does ROM
    and RAM initializations, and tries to completely remove the need for firmware
    on embedded systems'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are a number of bootloaders available and this is a natural outcome of
    the fact that there are a huge number of different architectures and devices,
    so many, in fact, that it is almost near impossible to have one that would be
    good for all systems. The variety of bootloaders is high; the differentiator factors
    are represented by the board types and structure, SOC differences and even CPUs.
  prefs: []
  type: TYPE_NORMAL
- en: Delving into the bootloader cycle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned previously, the bootloader is the component that is first run after
    initializing the system, and prepares the entire ecosystem for the operating system
    boot process. This process differs from one architecture to the other. For example,
    for the x86 architecture, the processor has access to BIOS, a piece of software
    available in a nonvolatile memory, which is usually a ROM. Its role starts out
    after resetting the system when it is executed and initializes the hardware components
    that will later be used by the first stage bootloader. It also executes the first
    stage of the bootloader.
  prefs: []
  type: TYPE_NORMAL
- en: The first stage bootloader is very small in terms of dimensions - in general,
    it is only 512 bytes and resides on a volatile memory. It performs the initialization
    for the full bootloader during the second stage. The second stage bootloaders
    usually reside next to the first stage ones, they contain the most number of features
    and do most of the work. They also know how to interpret various filesystem formats,
    mostly because the kernel is loaded from a filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: 'For x86 processors, there are more bootloader solutions that are available:'
  prefs: []
  type: TYPE_NORMAL
- en: '**GRUB**: The Grand Unified Bootloader is the most used and powerful bootloader
    available for Linux systems from desktop PC platforms. It is a component of the
    GNU Project and is one of the most potent bootloaders available for x86 architecture
    systems. This is because it is able to understand a large variety of filesystems
    and kernel images formats. It is able to change the the boot configuration during
    boot time. GRUB also has support for a network boot and command-line interface.
    It has a configuration file that is processed at boot time and can be modified.
    More information about it can be found at [http://www.gnu.org/software/grub/](http://www.gnu.org/software/grub/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lilo**: The Linux Loader a bootloader mostly used in commercial Linux distributions.
    Similar to the previous point, it is available for desktop PC platforms. It has
    more than one component, the first component for historical reasons is available
    on the first sector of a disk drive; it is the bootstrap component. Due to the
    same historical reasons, it is limited to the 512 bytes dimension and it loads
    and offers control to the second stage bootloader that does most of the bootloader''s
    work. Lilo has a configuration utility that is mainly used as a source of information
    for the Linux kernel booting process. More information about it can be found at
    [http://www.tldp.org/HOWTO/LILO.html](http://www.tldp.org/HOWTO/LILO.html).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Syslinux**: It is used for removable media or network booting. Syslinux is
    a Linux operating system bootloader that runs on MS-DOS or Windows FAT filesystems
    and is mainly used for rescue and first time installations of Linux. More information
    on it can be found at [http://www.kernel.org/pub/linux/utils/boot/syslinux/](http://www.kernel.org/pub/linux/utils/boot/syslinux/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For most embedded systems, this booting process does not apply, although there
    are some that replicate this behavior. There are two types of situations that
    will be presented next. The first one is a situation where the code execution
    starts from a fixed address location, and the second one refers to a situation
    where the CPU has a code available in the ROM memory that is called.
  prefs: []
  type: TYPE_NORMAL
- en: '![Delving into the bootloader cycle](img/image00307.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The right-hand side of the image is presented as the previously mentioned booting
    mechanism. In this case, the hardware requires a NOR flash memory chip, available
    at the start address to assure the start of the code execution.
  prefs: []
  type: TYPE_NORMAL
- en: A NOR memory is preferred over the NAND one because it allows random address
    access. It is the place where the first stage bootloader is programmed to start
    the execution, and this doesn't make it the most practical mechanism of booting.
  prefs: []
  type: TYPE_NORMAL
- en: Although it is not the most practical method used for the bootloader boot process,
    it is still available. However, it somehow becomes usable only on boards that
    are not suitable for more potent booting options.
  prefs: []
  type: TYPE_NORMAL
- en: The U-Boot bootloader
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many open source bootloaders available today. Almost all of them have
    features to load and execute a program, which usually involves the operating system,
    and its features are used for serial interface communication. However, not all
    of them have the possibility to communicate over Ethernet or update themselves.
    Another important factor is represented by the widespread use of the bootloader.
    It is very common for organizations and companies to choose only one bootloader
    for the diversity of boards, processors, and architectures that they support.
    A similar thing happened with the Yocto Project when a bootloader was chosen to
    represent the official supported bootloader. They, and other similar companies,
    chose U-Boot bootloader, which is quite well known in the Linux community.
  prefs: []
  type: TYPE_NORMAL
- en: The U-Boot bootloader, or Das U-Boot as its official name, is developed and
    maintained by Wolfgang Denx with the support of the community behind it. It is
    licensed under GPLv2, its source code is freely available inside a `git` repository,
    as shown in the first chapter, and it has a two month intervals between releases.
    The release version name is shown as `U-boot vYYYY.MM`. The information about
    U-Boot loader is available at [http://www.denx.de/wiki/U-Boot/ReleaseCycle](http://www.denx.de/wiki/U-Boot/ReleaseCycle).
  prefs: []
  type: TYPE_NORMAL
- en: 'The U-Boot source code has a very well defined directory structure. This can
    be easily seen with this console command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `arch` directory contains architecture-specific files and directories-specific
    to each architecture, CPU or development board. An `api` contains external applications
    that are independent of a machine or architecture type. A `board` contains inside
    boards with specific names of directories for all board-specific files. A common
    is a place where `misc` functions are located. A `disk` contains disk drive handling
    functions, and documentation is available inside the `doc` directory. Drivers
    are available in the `drivers` directory. The filesystem-specific functionality
    is available inside the `fs` directory. There are still some directories that
    would need mentioning here, such as the `include` directory, which contains the
    header files; the `lib` directory contains generic libraries with support for
    various utilities, such as the flatten device tree, various decompressions, a
    `post` (Power On Self-Test) and others, but I will let them be discovered by the
    reader's curiosity, one small hint would be to inspect the `README` file in the
    `Directory Hierachy` section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving through the U-Boot sources, which were downloaded in the previous chapter
    inside the `./include/configs` file, configuration files can be found for each
    supported board. These configuration file is an `.h` file that contains a number
    of `CONFIG_` files and defines information on memory mapping, peripherals and
    their setup, command line output, such as the boot default addresses used for
    booting a Linux system, and so on. More information on the configuration files
    could be found inside the `README` file in the *Configuration Options,* section
    or in a board specific configuration file. For Atmel SAMA5D3-Xplained, the configuration
    file is `include/configs/sama5d3_xplained.h`. Also, there are two configurations
    available for this board in the `configs` directory, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`configs/sama5d3_xplained_mmc_defconfig`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`configs/sama5d3_xplained_nandflash_defconfig`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These configurations are used to define the board **Secondary Program Loader**
    (**SPL**) initialization method. SPL represents a small binary built from the
    U-Boot source code that is placed on the SRAM memory and is used to load the U-Boot
    into the RAM memory. Usually, it has less than 4 KB of memory, and this is how
    the booting sequence looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The U-Boot bootloader](img/image00308.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Before actually starting the build for the U-Boot source code for a specific
    board, the board configuration must be specified. For the Atmel SAMA5_Xplained
    development board, as presented in the preceding image, there are two available
    configurations that could be done. The configuration is done with the make `ARCH=arm
    CROSS_COMPILE=${CC} sama5d3_xplained_nandflash_defconfig` command. Behind this
    command, the `include/config.h` file is created. This header include definitions
    that are specific for the chosen board, architecture, CPU, and also board-specific
    header includes. The defined `CONFIG_*` variable read from the `include/config.h`
    file includes determining the compilation process. After the configuration is
    completed, the build can be started for the U-Boot.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another example that can be very useful when inspected relates to the other
    scenario of booting an embedded system, one that requires the use of a NOR memory.
    In this situation, we can take a look at a particular example. This is also well
    described inside the *Embedded Linux Primer* by Christopher Hallinan, where a
    processor of the AMCC PowerPC 405GP is discussed. The hardcoded address for this
    processor is 0xFFFFFFFC and is visible using `.resetvec` , the reset vector placement.
    There also specifies the fact that the rest of this section is completed with
    only the value `1` until the end of the 0xFFFFFFFF stack; this implies that an
    empty flash memory array is completed only with values of `1`. The information
    about this section is available in `resetvec.S` file, which is located at `arch/powerpc/cpu/ppc4xx/resetvec.S`.
    The contents of `resetvec.S` file is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: On inspection of this file's source code, it can be seen that only an instruction
    is defined in this section independently of the available configuration options.
  prefs: []
  type: TYPE_NORMAL
- en: 'The configuration for the U-Boot is done through two types of configuration
    variables. The first one is `CONFIG_*`, and it makes references to configuration
    options that can be configured by a user to enable various operational features.
    The other option is called `CFG_*` and this is used for configuration settings
    and to make references to hardware-specific details. The `CFG_*` variable usually
    requires good knowledge of a hardware platform, peripherals and processors in
    general. The configure file for the SAMA5D3 Xplained hardware platform is available
    inside the `include/config.h` header file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The configuration variables available here represent the corresponding configurations
    for the SAMA5D3 Xplained board. A part of these configurations refer to a number
    of standard commands available for user interactions with the bootloader. These
    commands can be added or removed for the purpose of extending or subtracting commands
    from the available command line interface.
  prefs: []
  type: TYPE_NORMAL
- en: More information on the U-Boot configurable command interface can be found at
    [http://www.denx.de/wiki/view/DULG/UBootCommandLineInterface](http://www.denx.de/wiki/view/DULG/UBootCommandLineInterface).
  prefs: []
  type: TYPE_NORMAL
- en: Booting the U-Boot options
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In an industrial environment, interaction with the U-Boot is mainly done through
    the Ethernet interface. Not only does an Ethernet interface enable the faster
    transfer of operating system images, but it is also less prone to errors than
    a serial connection.
  prefs: []
  type: TYPE_NORMAL
- en: One of the most important features available inside a bootloader is related
    to the support for **Dynamic Host Control Protocol** (**DHCP**), **Trivial File
    Transfer Protocol** (**TFTP**), and even **Bootstrap Protocol** (**BOOTP**). BOOTP
    and DHPC enable an Ethernet connection to configure itself and acquire an IP address
    from a specialized server. TFTP enables the download of files through a TFTP server.
    The messages passed between a target device and the DHCP/BOOTP servers are represented
    in the following image in a more generic manner. Initially, the hardware platform
    sends a broadcast message that arrives at all the DHCP/BOOTP servers available.
    Each server sends back its offer, which also contains an IP address, and the client
    accepts the one that suits its purposes the best and declines the other ones.
  prefs: []
  type: TYPE_NORMAL
- en: '![Booting the U-Boot options](img/image00309.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: After the target device has finished communication with DHCP/BOOTP, it remains
    with a configuration that is specific to the target and contains information,
    such as the hostname, target IP and hardware Ethernet address (MAC address), netmask,
    tftp server IP address and even a TFTP filename. This information is bound to
    the Ethernet port and is used later in the booting process.
  prefs: []
  type: TYPE_NORMAL
- en: To boot images, U-Boot offers a number of capabilities that refer to the support
    of storage subsystems. These options include the RAM boot, MMC boot, NAND boot,
    NFS boot and so on. The support for these options is not always easy and could
    imply both hardware and software complexity.
  prefs: []
  type: TYPE_NORMAL
- en: Porting U-Boot
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I've mentioned previously that U-Boot is one of the most used and known bootloaders
    available. This is also due to the fact that its architecture enables the porting
    of new development platforms and processors in a very easy manner. At the same
    time, there are a huge number of development platforms available that could be
    used as references. The first thing that any developer who is interested in porting
    a new platform should do is to inspect the `board` and `arch` directories to establish
    their baselines, and, at the same time, also identify their similarities with
    other CPUs and available boards.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `board.cfg` file is the starting point to register a new platform. Here,
    the following information should be added as a table line:'
  prefs: []
  type: TYPE_NORMAL
- en: Status
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CPU
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SOC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vendor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Board name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Target
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Options
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maintainers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To port a machine similar to SAMA5D3 Xplained, one of the directories that could
    be consulted is the `arch` directory. It contains files, such as `board.c`, with
    information related to the initialization process for boards and SOCs. The most
    notable processes are `board_init_r()`, which does the setup and probing for board
    and peripherals after its relocation in the RAM, `board_init_f()`, which identifies
    the stack size and reserved address before its relocation in the RAM, and `init_sequence[]`,
    which is called inside the `board_init_f` for the setup of peripherals. Other
    important files inside the same locations are the `bootm.c` and `interrupts.c`
    files. The former has the main responsibility of the boot from memory of the operating
    system, and the latter is responsible for implementation of generic interrupts.
  prefs: []
  type: TYPE_NORMAL
- en: The `board` directory also has some interesting files and functions that need
    to be mentioned here, such as the `board/atmel/sama5d3_xplained/sama5d3_xplained.c`
    file. It contains functions, such as `board_init(), dram_init()`, `board_eth_init()`,
    `board_mmc_init`, `spl_board_ init()`, and `mem_init()` that are used for initialization,
    and some of them called by the `arch/arm/lib/board.c` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some other relevant directories:'
  prefs: []
  type: TYPE_NORMAL
- en: '`common`: This holds information about user commands, middleware, APIs that
    perform the interfacing between the middleware and user commands, and other functions
    and functionalities used by all available boards.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`drivers`: This contains drivers for various device drivers and middleware
    APIs, such as `drivers/mmc/mmc.c, drivers/pci/pci.c`, `drivers/watchdog/at91sam9_wdt.c`
    and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fs`: Various supported filesystems, such as USB, SD Card, Ext2 FAT, and so
    on are available here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`include`: This represents the location where all the headers necessary for
    most of the boards are present. SOCs and other software is also available. Inside
    include/configs, board-specific configurations are available, and include the
    headers imported from Linux; these could be used for various device drivers, porting,
    or other byte operations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tools`: This is the place where tools, such as `checkpatch.pl`, a patch examination
    tool used as a coding style check, are used before sending it to the mailing list
    or the `mkimage.c` tool. This is also used for the U-Boot generic header generation
    that makes Linux binaries, and assures that they are able to be booted using U-Boot.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More information about the SAMA5D3 Xplained board can be found by inspecting
    the corresponding doc directory and `README` files, such as `README.at91`, `README.at91-soc`,
    `README.atmel_mci`, `README.atmel_pmecc`, `README.ARM-memory-map`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: For people interested in committing to the changes they made while porting a
    new development board, CPU, or SOC to U-Boot, a few rules should be followed.
    All of these are related to the `git` interaction and help you to ensure the proper
    maintenance of your branches.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing that a developer should do is to track the upstream branch
    that corresponds to a local branch. Another piece of advice would be to forget
    about `git` `merge` and instead use `git` `rebase`. Keeping in contact with the
    upstream repository can be done using the `git fetch` command. To work with patches,
    some general rules need to be followed, and patches need to have only one logical
    change, which can be any one of these:'
  prefs: []
  type: TYPE_NORMAL
- en: Changes should not contain unrelated or different modifications; only one patch
    is available and acceptable per changeset
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Commits should make the use of `git-bisect` where possible while detecting bugs
    in sources, when necessary
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If multiple files are impacted by a set of modifications, all of them should
    be submitted in the same patch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Patches need to have review, and a very thorough one at that
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s take a look at following diagram, which illustrates the git rebase operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Porting U-Boot](img/image00310.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As shown in both the preceding and following diagram, the **git rebase** operation
    has recreated the work from one branch onto another. Every commit from one branch
    is made available on the succeeding one, just after the last commit from it.
  prefs: []
  type: TYPE_NORMAL
- en: '![Porting U-Boot](img/image00311.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `git merge` operation, on the other hand, is a new commit that has two
    parents: the branch from which it was ported, and the new branch on which it was
    merged. In fact, it gathers a series of commits into one branch with a different
    commit ID, which is why they are difficult to manage.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Porting U-Boot](img/image00312.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: More information related to `git` interactions can be found at [http://git-scm.com/documentation](http://git-scm.com/documentation)
    or [http://www.denx.de/wiki/U-Boot/Patches](http://www.denx.de/wiki/U-Boot/Patches).
  prefs: []
  type: TYPE_NORMAL
- en: 'Almost always when porting a new feature in U-Boot, debugging is involved.
    For a U-Boot debugger, there are two different situations that can occur:'
  prefs: []
  type: TYPE_NORMAL
- en: The first situation is when `lowlevel_init` was not executed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second situation is when the `lowlevel_init` was executed; this is the most
    well known scenario
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the next few lines, the second situation will be considered: the baseline
    enabling a debugging session for U-Boot. To make sure that debugging is possible,
    the `elf` file needs to be executed. Also, it cannot be manipulated directly because
    the linking address will be relocated. For this, a few tricks should be used:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to make sure that the environment is clean and that old objects
    are not available any more: `make clean`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The next step would be to make sure the dependencies are cleaned: `find ./
    | grep depend | xargs rm`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After the cleaning is finished, the target build can start and the output can
    be redirected inside a log file: `make sama5d3_xplained 2>&1 > make.log`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The generated output should be renamed to avoid debugging problems for multiple
    boards: `mv u-boot.bin u-boot_sama5d3_xplained.bin`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is important to enable DEBUG in the board configuration file; inside `include/configs/
    sama5d3_xplained.h`, add the `#define` DEBUG line
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An early development platform can be set up after relocation takes place and
    the proper breakpoint should be set after the relocation has ended. A symbol needs
    to be reloaded for U-Boot because the relocation will move the linking address.
    For all of these tasks, a `gdb` script is indicated as `gdb gdb-script.sh`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: More information on relocation can be found at `doc/README.arm-relocation`.
  prefs: []
  type: TYPE_NORMAL
- en: The Yocto Project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Yocto Project uses various recipes to define interactions to each of the
    supported bootloaders. Since there are multiple stages of booting, there are also
    multiple recipes and packages required inside the BSP. The recipes available for
    various bootloaders are not different from any other recipes available in the
    Yocto world. However, they have some details that make them unique.
  prefs: []
  type: TYPE_NORMAL
- en: The board that we will focus on here is the `sama5d3_xplained` development board,
    and it is available inside the `meta-atmel` layer. Inside this layer, the corresponding
    recipes for the first and second stage bootloaders can be found inside the `recipes-bsp`
    directory. Here, I am referring to the `at91bootstrap` and `u-boot` recipes. There
    are some misconceptions about first stage and second stage bootloaders. They might
    be referred to as second level and third level bootloaders, because the boot ROM
    code may or may not be taken into account during a discussion. In this book, we
    prefer to call them as first stage and second stage bootloaders.
  prefs: []
  type: TYPE_NORMAL
- en: The `AT91bootstrap` package represents the first-stage bootloader from Atmel
    available for their SOCs. It manages hardware initialization and also executes
    the second stage bootloader download from a boot media inside the memory; it starts
    it at the end. In the `meta-atmel` layer, the second stage bootloader is `u-boot`,
    and it is later used for the Linux operating system boot.
  prefs: []
  type: TYPE_NORMAL
- en: Usually, inside a BSP layer, the support for multiple development boards is
    offered, and this means that multiple versions and bootloader packages are offered
    as well. The distinction between them, however, is on the basis of machine configurations.
    For the SAMA5D3 Xplained development board, the machine configuration is available
    inside the `conf/machine/sama5d3_xplained` file. In this file, the preferred bootloader
    versions, providers, and configurations are defined. If these configurations are
    not `MACHINE` specific, they could very well be performed inside the `package`
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is one example of the configurations available for the `sama5d3_xplained`
    development board:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you were presented with information on bootloaders, with particular
    focus on the U-Boot bootloader. We also discussed topics related to U-Boot interaction,
    porting, debugging, general information on bootloaders, U-Boot alternatives and
    a boot sequence inside an embedded environment. There was also a section related
    to the Yocto Project, where you were introduced to the mechanism used to support
    various bootloaders available inside BSP. A number of exercises were presented
    across the chapter, and they offered more clarity on this subject.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss the Linux kernel, its features and source
    code, modules and drivers, and, in general, most of the information needed to
    interact with the Linux kernel. As you have already been introduced to it, we
    will also concentrate on the Yocto Project and how it is able to work with various
    kernel versions for a number of boards and exercises. This should ease the understanding
    of the information presented to you.
  prefs: []
  type: TYPE_NORMAL
