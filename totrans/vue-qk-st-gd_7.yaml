- en: Using Vuex
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we'll learn how to manage complex state in Vue by using Vuex.
    Vuex helps deal with the issue of managing state and deeply nested components
    in Vue apps.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of this chapter, you will understand what problems Vuex solves and
    how it solves them, and you should understand where all the moving parts fit in.
    You will also know how to build a simple Vuex app and the approach to take when
    thinking about extending it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, we will go over these topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: State management, data stores, and one-way data flows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hot reloading
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a very simple Vuex app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to update state from Vue DevTools' Vuex tab
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a more complex Vuex app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's begin by understanding exactly what state is.
  prefs: []
  type: TYPE_NORMAL
- en: What is state?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An application''s state is all its data at a point in time. Since we are usually
    concerned with the current app''s state, we could rephrase this to the following:
    the state is an app''s data as it is right now, resulting from the previous steps
    that our app took and based on functions inside the app responding to the user
    interacting with it.'
  prefs: []
  type: TYPE_NORMAL
- en: So, what is it in our app that changes its state? Functions, of course. The
    user interacts with our app, which triggers functions to change the current state
    to some other state.
  prefs: []
  type: TYPE_NORMAL
- en: However, as our apps grow, it is not uncommon to have components nesting several
    levels deep. If we say that state is the **source of truth** for how our app should
    display on the screen at any given time, then it would be beneficial to us to
    make that source of truth as easy to reason about and as simple to work with as
    possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, in complex apps, this is not so easy. Any part of our app, any
    component inside our app might affect any other part of our app. Managing state
    in our apps becomes a bit like playing a game of whack-a-mole: an interaction
    in one section of our app will result in something else *popping* out of place
    in some other part of our app.'
  prefs: []
  type: TYPE_NORMAL
- en: Reasoning about best practice for how to manage complex state in frontend apps
    has led to concepts such as the **data store** and **one-way data flows**.
  prefs: []
  type: TYPE_NORMAL
- en: State management, data stores, and one-way data flows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A common solution to the problem of managing complex state is the idea of a
    store: a single source of truth that keeps all of the data of our app''s state.
    Once we have that central location—**the store**—we can reason about state a lot
    easier, because now it is only a matter of sending the state data to those components
    that need to have it at any time in the app''s life cycle.'
  prefs: []
  type: TYPE_NORMAL
- en: To make the state updates simpler, we need to limit the ways in which these
    updates can be made. This is where one-way data flows come in. With one-way data
    flows, we specify rules on exactly how data can flow inside our app, which means
    that there are now only so many expected ways in which data (state) can flow through
    our apps, making it easier to reason about state and debug state when needed.
    This approach is also a great time saver, since now we as developers know what
    to expect; that is, to look for spots where we know state is **mutable**.
  prefs: []
  type: TYPE_NORMAL
- en: The Vuex state management pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Vuex is a plugin of Vue, developed by Vue's core team. The setup is quite easy.
    If you need a quick prototype, you can simply add the Vuex library from the settings
    inside CodePen online editor, as explained in [Chapter 1](5fdb984c-98f5-4703-96ce-7bd3150fbe2f.xhtml),
    *Introducing Vue*.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also install it via npm, with this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'When trying to understand how Vuex works, you''ll usually find references online
    that describe Vuex as a state management pattern that is heavily influenced by
    Flux. This is true in part, but it is interesting to note that Flux itself was
    inspired by the Elm architecture. Be that as it may, in Vuex, the data flows as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Vue components** to actions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Actions** to mutations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mutations** to state'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**State** to Vue components'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The data always flows in one way, ending up where it began, with updates made
    to components, which then *dispatch actions*, which then *commit mutations*, which
    then *mutate state*, which then *renders components*, and the cycle repeats. So,
    looking at the one-way data flow from a slightly different angle, we could rephrase
    it, focusing on the verbs to describe what happens to the data in the store:'
  prefs: []
  type: TYPE_NORMAL
- en: Actions are *dispatched*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mutations are *committed*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: State is *mutated*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Components are *rendered*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Looking at the one-way data flow again, we can now describe the data flow using
    these nouns: *components*, *actions*, *mutations*, and *state*. Describing the
    data flow using verbs, we can view this progression as follows: *dispatch*, *commit*,
    *mutate and* *render*.'
  prefs: []
  type: TYPE_NORMAL
- en: Both of these ways of viewing the flow of data in Vuex are two sides of the
    same coin, the same cycle of state updates, and so thus it would not hurt to commit
    both of these short lists to memory, as it will help speed up the understanding
    of basic Vuex concepts.
  prefs: []
  type: TYPE_NORMAL
- en: To visually reinforce these explanations, a diagram of this one-way data flow
    is available in the official Vuex docs, at this URL: [https://vuex.vuejs.org/vuex.png](https://vuex.vuejs.org/vuex.png).
  prefs: []
  type: TYPE_NORMAL
- en: 'You might ask, why this indirect approach? Why can''t components directly mutate
    state? There are two main reasons for this: first, since asynchronous code is
    simply a matter of fact in the JavaScript world, a choice was made to separate
    asynchronous and synchronous operations in Vuex. Hence, actions were set to be
    asynchronous, so they can, for example, fetch some data from the server, and only
    when this asynchronous data fetching is complete can they then *com**mit* *mutations*;
    since mutations are strictly synchronous, it wouldn''t make sense to call them
    before the call to server has been completed. Second, this way of separating concerns
    enables easier tracking of state changes, which even includes time travel debugging:
    rerunning mutations chronologically to track changes to state and hunt down bugs.'
  prefs: []
  type: TYPE_NORMAL
- en: In the Vuex state management pattern, components can never directly mutate global
    state. Mutations do that.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we'll look at each of these building blocks.
  prefs: []
  type: TYPE_NORMAL
- en: The store
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The **store** needs to be added to the Vue instance root, so that all components
    can share this centralized, global state. Usually, we declare the store as `const`,
    and then later on in the code, we add it inside the object literal that we pass
    as the argument to the Vue constructor, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Next, we'll learn about getters.
  prefs: []
  type: TYPE_NORMAL
- en: Getters in the Vuex store
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our store can also have getters. Getters allow us to return values from the
    state in templates. They are a bit like computed values. They are read-only, meaning
    they cannot change the state. Their responsibility is only to read it and make
    some non-destructive manipulations of it. However, the underlying data is not
    mutated.
  prefs: []
  type: TYPE_NORMAL
- en: So, we use getters in the store to perform some non-destructive work on the
    global state. What do we then do with them? How do we use them? We use them on
    the other side of our app – inside a component—where we use `computed` and return
    the value of getters from the store.
  prefs: []
  type: TYPE_NORMAL
- en: Vuex store mutations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Mutations, as the name implies, mutate the state, and are synchronous. Functions
    that mutate state receive arguments: the existing state and the payload. The payload
    argument is optional. They are responsible for directly updating the state in
    Vuex. You can execute a mutation from an action with this syntax: `state.commit`.'
  prefs: []
  type: TYPE_NORMAL
- en: Actions in Vuex store
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Actions update the state asynchronously and indirectly, by calling one or more
    mutations we defined in the store. So, actions call as many mutations as needed.
    On the other side, inside components, to execute an action we use the store''s
    dispatch values, using this syntax: `store.dispatch`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now extend our boilerplate code to include what we just discussed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see in the Vue constructor, with ES6 syntax, it is possible to simplify
    the `store: store` key-value pair inside the constructor''s object literal argument
    and just use `store`.'
  prefs: []
  type: TYPE_NORMAL
- en: Hot reloading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another popular concept that was brought about by the rise of Webpack is hot
    reloading. When your app is running, upon updating a file—for example, adding
    some changes to scoped styles in one of your components—Webpack will hot-reload
    the updated file without using state in your app. In other words, it will not
    reload the entire page, but rather only the part of your app that was affected
    by the change. The reason why this is useful is because, with hot module replacement
    the state will be kept, which would not be possible if the page was refreshed.
    This comes with the added benefit of faster development time and seamless experience
    of updates in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Building a fruit counter app with Vuex
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The app that we will build is just a simple fruit counter app. The goal is to
    help the user make sure to eat five pieces of fruit daily, and we will set up
    a simple app that will start with five pieces of fruit to eat and, each time we
    click the button, it will decrement the number by `1`. That way, we can keep track
    of our healthy eating goals.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will begin our app by setting the initial state, with only one key-value
    pair in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will set up `getters`. As we learned already, `getters` only return
    state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will add two mutations: the first mutation, `decrementCounter`, will
    operate on the counter by decrementing it by the value stored in the payload argument.
    We will decrement the value of state.count until it reaches `0`. To make sure
    the value of `state.count` cannot be less then `0`, we''ll check it with the ternary
    statement and set its value accordingly.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The second mutation, `resetCounter`, will reset the value of the counter to
    the initial state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we are setting up two actions, `decrement` and `reset`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we''re setting up our app, and specifying the `el`, `store`, `computed`,
    and `methods` options inside its Vue constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, in our HTML, we set up the structure of our simple app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The working example can be found at the following URL: [https://codepen.io/AjdinImsirovic/pen/aRmENx](https://codepen.io/AjdinImsirovic/pen/aRmENx).'
  prefs: []
  type: TYPE_NORMAL
- en: Using the Vue DevTools plugin to track our Vuex state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you type `vuejs devtools` into the search field of the Chrome extensions
    web store, you'll get a few results. The first result is the stable version of
    the official plugin. The second result is the Vue DevTools extension's beta version.
    To see all of the options that are being developed and see where this plugin is
    going, it's good to install the beta version. Interestingly, both versions display
    the same information once open in Chrome DevTools. Currently, the message reads `Ready.
    Detected Vue 2.5.17-beta.0`.
  prefs: []
  type: TYPE_NORMAL
- en: When compared with the regular version, the experimental version comes with
    a few more tabs, namely `routing` and `p``erformance`. However, even the existing
    tabs have some very useful improvements. For example, the Vuex tab comes with
    the ability to directly update the state from inside DevTools. To access that
    functionality, simply open Chrome DevTools by pressing the *F12* key. The best
    way to position the DevTools to use the Vue extension is by setting it to the `Dock
    to bottom` option. This option is accessible by pressing the three vertical dots
    icon (the *Customize and control DevTools* icon), which can be found right next
    to the DevTools close icon in the very top-right corner of the DevTools pane.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have Dock to bottom enabled, the Vue tab open, and inside it, the Vuex
    tab active, you will see two panes. Initially, the left pane lists Base State.
    This is the pane that lists all of the mutations and allows us to run time travel
    debugging. The right pane lists the actual payload, state, and mutations, so it
    gives us a more fine-grained view of what is happening in any given mutation.
    To time travel to any specific mutation, just hover over it and click the *Time
    Travel* icon. You also have the option of running `Commit` or `Revert` on any
    of the mutations listed. As you might guess, while the `Commit` command will perform
    a commit on the currently hovered mutation, the `Revert` command will undo the
    specific mutation's commit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another useful and interesting feature is the ability to update the state right
    from the Vuex tab. For example, let''s say that we click the `Eat fruit!` button
    a few times. Now, we can click on any given `decrementCounter` mutation in the
    mutations pane, and we''ll get the following information in the right pane:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'It is very simple to use this pane. If we need to updated our state, hovering
    over `count: 1` inside the `state` entry will trigger four icons to appear: the *Edit
    value* icon, the minus icon, the plus icon, and the *Copy value* icon, shown as
    three vertical dots. Here, we can also see the proof of `getters` being read-only.
    Hovering over the `getters` entry will not show any editing icons. Contrary to
    that, the `state` and `mutation` entries can both be edited from this pane.'
  prefs: []
  type: TYPE_NORMAL
- en: Improving our fruit counter app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will make some improvements to our fruit counter app. The
    goal is to see how we can go about extending our apps using Vuex.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will update our app by adding additional functionality. Namely, we''ll add
    buttons for different fruits: apples and pears. The number of fruits to eat and
    the number and kind of fruits eaten will appear in our app too.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the updated JS code. We begin with defining the state in the store:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we set up the getters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'When defining mutations, we need `decrementWithApplesCounter` and `decrementWithPearsCounter`,
    and the `resetCounter` functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''ll list our actions, `decrementWithApples`, `decrementWithPears`,
    and `reset`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll wrap it up by adding the Vue constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: As we see in this code, we can update more than one variable value in a JS ternary.
    We are also ''imitating'' a call to the server with the `setTimeout()` function
    call; this is unnecessary, but used as an example of a more complex asynchronous
    operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The updated HTML code will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The updated example app can be found here: [https://codepen.io/AjdinImsirovic/pen/EdNaaO](https://codepen.io/AjdinImsirovic/pen/EdNaaO).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we got acquainted with Vuex, a powerful Vue plugin that helps
    us manage state from a centralized, global store. We learned about what state
    is and why we need to centralize data stores in more complex apps. We discussed
    unidirectional data flow and its implementation in Vuex, through the use of getters,
    store mutations, and store actions. We moved from theory to practice by first
    building a simple app, then learning how to make our development process easier
    with the help of the Vue Devtools extension.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will work with routing using Vue-router and we'll look
    at server-side rendering with Nuxt.
  prefs: []
  type: TYPE_NORMAL
