- en: Compile-Time Tricks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Checking sizes at compile time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enabling function template usage for integral types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disabling function template usage for real types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a type from a number
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a type trait
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selecting an optimal operator for a template parameter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting a type of expression in C++03
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we'll see some basic examples on how the Boost libraries can
    be used in compile-time checking, for tuning algorithms, and in other metaprogramming
    tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Some readers may ask, *"Why should we care about compile-time things?"* That's
    because the released version of the program is compiled once and runs multiple
    times. The more we do at compile time, the less work remains for runtime, resulting
    in much faster and reliable programs. Runtime checks are executed only if a part
    of the code with the check is executed. Compile-time checks will prevent your
    program from compiling, ideally with a meaningful compiler error message.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter is possibly one of the most important. Understanding Boost sources
    and other Boost-like libraries is impossible without it.
  prefs: []
  type: TYPE_NORMAL
- en: Checking sizes at compile time
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s imagine that we are writing some serialization function that stores
    values in a buffer of a specified size:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This code has the following problems:'
  prefs: []
  type: TYPE_NORMAL
- en: The size of the buffer is not checked, so it may overflow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This function can be used with **non-trivially copyable** types, which would
    lead to incorrect behavior
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We may partially fix it by adding some asserts, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: But, this is a bad solution. Runtime checks do not trigger the assert during
    testing in the debug mode if the function was not called. Runtime checks may even
    be optimized out in the release mode, so very bad things may happen.
  prefs: []
  type: TYPE_NORMAL
- en: '`BufSizeV` and `sizeof(value)` values are known at compile time. It means that,
    instead of having a runtime assert, we can force this code to fail compilation
    if the buffer is too small.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe requires some knowledge of C++ templates and the `Boost.Array` library.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s use `Boost.StaticAssert` and `Boost.TypeTraits` libraries to correct
    the solution. Here''s how:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `BOOST_STATIC_ASSERT` macro can be used only if an assert expression can
    be evaluated at compile time and is implicitly convertible to `bool`. It means
    that you may only use `sizeof()`, static constants, constexpr variables, constexpr
    functions with parameters known at compile time, and other constant expressions
    in `BOOST_STATIC_ASSERT`. If assert expression evaluates to `false`, `BOOST_STATIC_ASSERT`
    will stop compilation. In the case of a `serialize` function, if the first static
    assertion fails, it means that the user misused the `serialize` function and provided
    a very small buffer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some more examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: If the `BOOST_STATIC_ASSERT` macro's assert expression has a comma sign in it,
    we must wrap the whole expression in additional brackets.
  prefs: []
  type: TYPE_NORMAL
- en: The last example is very close to what we can see on the second line of the
    `serialize()` function. So now, it is time to discover more about the `Boost.TypeTraits`
    library. This library provides a large number of compile-time metafunctions that
    allow us to get information about types and modify types. The metafunctions usages
    look like `boost::function_name<parameters>::value` or `boost::function_name<parameters>::type`.
    The metafunction `boost::has_trivial_copy<T>::value` returns `true` only if `T`
    is a simple copyable type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at some more examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Some compilers may compile this code even without the `typename` keyword, but
    such behavior violates the C++ standard, so it is highly recommended to write
    `typename`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `BOOST_STATIC_ASSSERT` macro has a more verbose variant called `BOOST_STATIC_ASSSERT_MSG`
    that tries hard to output an error message in the compiler log (or in the IDE
    window) if assertion fails. Take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will give the following result during compilation on the
    g++ compiler in the C++11 mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Neither `BOOST_STATIC_ASSSERT`, nor `BOOST_STATIC_ASSSERT_MSG`, nor any of the
    type traits entity implies a runtime penalty. All these functions are executed
    at compile time and do not add a single assembly instruction to the resulting
    binary file. The C++11 standard has `static_assert(condition, "message")` that
    is equivalent to Boost's `BOOST_STATIC_ASSSERT_MSG`. The `BOOST_STATIC_ASSERT`
    functionality of asserting at compile time without a user provided message is
    available in C++17 as `static_assert(condition)`. You do not have to include header
    files to be able to use your compiler built in `static_assert`.
  prefs: []
  type: TYPE_NORMAL
- en: The `Boost.TypeTraits` library was partially accepted into the C++11 standard.
    You may thus find traits in the `<type_traits>` header in the `std::` namespace.
    C++11 `<type_traits>` has some functions that do not exist in `Boost.TypeTraits`,
    but some other metafunctions exist only in Boost. Metafunctions that have a name
    starting with `has_` are renamed in the standard library to metafunctions with
    names starting with `is_`. Thus, `has_trivial_copy` became `is_trivially_copyable`
    and so forth.
  prefs: []
  type: TYPE_NORMAL
- en: 'C++14 and Boost 1.65 have shortcuts for all the type traits that have a `::type`
    member. Those shortcuts allow you to write `remove_const_t<T1>` instead of `typename
    remove_const<T1>::type`. Note that, in the case of Boost 1.65, the shortcuts require
    a C++11 compatible compiler as they could be implemented only using **type aliases**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'C++17 added `_v` shortcuts for type traits that have `::value`. Since C++17,
    you can just write `std::is_unsigned_v<T1>` instead of `std::is_unsigned<T1>::value`.
    This trick is usually implemented using `variable templates`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: When there is a similar trait in Boost and in the standard library, do opt for
    the Boost version if you are writing a project that must work on a pre-C++11 compilers.
    Otherwise, the standard library version may work slightly better, in rare cases.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next recipes in this chapter will give you more examples and ideas of how
    static asserts and type traits may be used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Read the official documentation of `Boost.StaticAssert` for more examples at:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://boost.org/libs/static_assert.](http://boost.org/libs/static_assert)'
  prefs: []
  type: TYPE_NORMAL
- en: Enabling function template usage for integral types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s a common situation, when we have a class template that implements some
    functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, imagine that we have two additional versions of that class, one for integral,
    and another for real types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the question: How to make the compiler to automatically choose the correct
    class for a specified type?'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe requires some knowledge of C++ templates.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll be using `Boost.Core` and `Boost.TypeTraits` to resolve the problem:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by including headers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s add an additional template parameter with a default value to our generic
    implementation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Modify optimized versions in the following way, so that now they will now be
    treated by the compiler as template partial specializations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'And, that''s it! Now, the compiler will automatically choose the correct class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `boost::enable_if_c` template is a tricky one. It makes use of the **Substitution
    Failure Is Not An Error** (**SFINAE**) principle, which is used during **template
    instantiation**. This is how the principle works; if an invalid argument or return
    type is formed during the instantiation of a function or class template, the instantiation
    is removed from the overload resolution set and does not cause a compilation error.
    Now the tricky part, `boost::enable_if_c<true>` has a member type accessible via
    `::type`, but `boost::enable_if_c<false>` has no `::type`. Let's get back to our
    solution and see how the SFINAE works with different types passed to the `data_processor`
    class as the `T` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: If we pass an `int` as the `T` type, first the compiler will try to instantiate
    template partial specializations from *step 3*, before using our nonspecialized
    generic version. When it tries to instantiate a `float` version, the `boost::is_float<T>::value`
    metafunction returns `false`. The `boost::enable_if_c<false>::type` metafunction
    cannot be correctly instantiated because `boost::enable_if_c<false>` has no `::type`,
    and that is the place where SFINAE acts. Because the class template cannot be
    instantiated, this must be interpreted as not an error, compiler skips this template
    specialization. The next partial specialization is the one that is optimized for
    integral types. The `boost::is_integral<T>::value` metafunction returns `true`,
    and `boost::enable_if_c<true>::type` can be instantiated, which makes it possible
    to instantiate the whole `data_processor` specialization. The compiler found a
    matching partial specialization, so it does not need to try to instantiate the
    nonspecialized method.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's try to pass some nonarithmetic type (for example, `const char *`),
    and let's see what the compiler will do. First, the compiler tries to instantiate
    template partial specializations. The specializations with `is_float<T>::value`
    and `is_integral<T>::value` fail to instantiate, so the compiler tries to instantiate
    our generic version and succeeds.
  prefs: []
  type: TYPE_NORMAL
- en: Without `boost::enable_if_c<>`, all the partially specialized versions may be
    instantiated at the same time for any type, which leads to ambiguity and failed
    compilation.
  prefs: []
  type: TYPE_NORMAL
- en: If you are using templates and compiler reports that cannot choose between two
    template classes of methods, you probably need `boost::enable_if_c<>`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another version of this method is called `boost::enable_if` without `_c` at
    the end. The difference between them is that `enable_if_c` accepts constant as
    a template parameter; the short version accepts an object that has a `value` static
    member. For example, `boost::enable_if_c<boost::is_integral<T>::value >::type`
    is equal to `boost::enable_if<boost::is_integral<T> >::type`.
  prefs: []
  type: TYPE_NORMAL
- en: Before Boost 1.56 the `boost::enable_if` metafunctions were defined in the header
    `<boost/utility/enable_if.hpp>` instead of `<boost/core/enable_if.hpp>`.
  prefs: []
  type: TYPE_NORMAL
- en: C++11 has `std::enable_if` defined in the `<type_traits>` header, which behaves
    exactly like `boost::enable_if_c`. No difference between them exists, except that
    Boost's version works on non C++11 compilers too, providing better portability.
  prefs: []
  type: TYPE_NORMAL
- en: 'C++14 has a shortcut `std::enable_if_t` that must be used without `typename`
    and `::type`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: All the enabling functions are executed only at compile time and do not add
    a performance overhead at runtime. However, adding an additional template parameter
    may produce a bigger classname in `typeid(your_class).name()`, and add an extremely
    tiny performance overhead while comparing two `typeid()` results on some platforms.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next recipes will give you more examples of the `enable_if` usage.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You may also consult the official documentation of `Boost.Core`. It contains
    many examples and a lot of useful classes (which are used widely in this book).
    Follow the link [http://boost.org/libs/core](http://boost.org/libs/core) to read
    about it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You may also read some articles about template partial specializations at [http://msdn.microsoft.com/en-us/library/3967w96f%28v=vs.110%29.aspx](http://msdn.microsoft.com/en-us/library/3967w96f%28v=vs.110%29.aspx).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disabling function template usage for real types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We continue working with Boost metaprogramming libraries. In the previous recipe,
    we saw how to use `enable_if_c` with classes; now it is time to take a look at
    its usage in template functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine that, in your project, you have a template function that works with
    all the available types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'That function exist for a long time. You have written a lot of code that uses
    it. Suddenly, you came up with an optimized version of the `process_data` function
    but only for types that do have an `T::operator+=(const T&)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: You've got a huge code base and it may take months to manually change `process_data`
    to the `process_data_plus_assign` for types that have the right operators. So,
    you do not want to change the already written code. Instead, you want to force
    the compiler to automatically use an optimized function in place of the default
    one if that's possible.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Read the previous recipe to get an idea of what `boost::enable_if_c` does and
    for an understanding of the concept of SFINAE. A basic knowledge of templates
    is still required.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Template magic can be done using the Boost libraries. Let''s see how to do
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will need the `boost::has_plus_assign<T>` metafunction and the `<boost/enable_if.hpp>`
    header:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we disable default implementation for types with the `plus assign` operator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Enable the optimized version for types with the `plus assign` operator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the optimized version is used wherever possible:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `boost::disable_if_c<bool_value>::type` metafunction disables the method,
    if `bool_value` equals `true`. It works just like `boost::enable_if_c<!bool_value>::type`.
  prefs: []
  type: TYPE_NORMAL
- en: A class passed as the second parameter for `boost::enable_if_c` or `boost::disable_if_c`
    is returned via `::type` in the case of successful substitution. In other words,
    `boost::enable_if_c<true, T>::type` is the same as `T`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's go through the `process_data(i, i, i)` case, step by step. We pass an
    `int` as `T` type and the compiler searches for function `process_data(int, int,
    int)`. Because there is no such function, the next step is to instantiate a template
    version of `process_data`. However, there are two template `process_data` functions.
    For example, the compiler starts instantiating the templates from our second (optimized)
    version; in that case, it successfully evaluates the `typename boost::enable_if_c<boost::has_plus_assign<T>::value,
    T>::type` expression, and gets the `T` return type. But, the compiler does not
    stop; it continues instantiation attempts and tries to instantiate our first version
    of the function. During substitution of `typename boost::disable_if_c<boost::has_plus_assign<T>::value`
    a failure happens, which is not treated as an error due to the SFINAE rule. There
    are no more template `process_data` functions, so the compiler stops instantiating.
    As you can see, without `enable_if_c` and `disable_if_c`, the compiler would be
    able to instantiate both templates and there will be an ambiguity.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As in the case of `enable_if_c` and `enable_if`, there is a `disable_if` version
    of the disabling function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: C++11 has neither `disable_if_c` nor `disable_if`, but you are free to use `std::enable_if<!bool_value>::type`
    instead.
  prefs: []
  type: TYPE_NORMAL
- en: Before Boost 1.56 the `boost::disable_if` metafunctions were defined in the
    header `<boost/utility/enable_if.hpp>` instead of `<boost/core/enable_if.hpp>`.
  prefs: []
  type: TYPE_NORMAL
- en: As it was mentioned in the previous recipe, all the enabling and disabling functions
    are executed only at compile time and do not add performance overhead at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Read this chapter from the beginning to get more examples of compile-time tricks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consider reading the `Boost.TypeTraits` official documentation for more examples
    and a full list of metafunctions at [http://boost.org/libs/type_traits.](http://boost.org/libs/type_traits)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Boost.Core` library may provide you with more examples of `boost::enable_if`
    usage; read about it at [http://boost.org/libs/core.](http://boost.org/libs/core)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a type from a number
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have now seen examples of how we can choose between functions using `boost::enable_if_c`.
    Let''s forget about that technique for this chapter and use a different approach.
    Consider the following example, where we have a generic method for processing
    POD datatypes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We also have some processing functions optimized for sizes 1, 4, and 8 bytes.
    How do we rewrite the `process` function so that it can dispatch calls to optimized
    processing functions?
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reading at least the first recipe from this chapter is highly recommended, so
    that you will not be confused by all the things that are happening here. Templates
    and metaprogramming will not scare you (or just get ready to see a lot of them).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are going to see how the size of a template type can be converted to a variable
    of some type, and how that variable can be used for deducing the right function
    overload.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s define our generic and optimized versions of the `process_impl` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we are ready to write a process function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The most interesting part here is that `boost::mpl::int_<sizeof(T)>()`. `sizeof(T)`
    executes at compile time, so its output can be used as a template parameter. The
    class `boost::mpl::int_<>` is just an empty class that holds a compile-time value
    of integral type. In the `Boost.MPL` library, such classes are called **integral
    constants**. It can be implemented as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We need an instance of this class, which is why we have a round parentheses
    at the end of `boost::mpl::int_<sizeof(T)>()`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's take a closer look at how the compiler will decide which `process_impl`
    function to use. First of all, the compiler tries to match functions that have
    a non-template second parameter . If `sizeof(T)` is 4, the compiler tries to search
    the function with signatures like `process_impl(T, boost::mpl::int_<4>)` and finds
    our 4 bytes optimized version from the `detail` namespace. If `sizeof(T)` is 34,
    the compiler can not find the function with a signature like `process_impl(T,
    boost::mpl::int_<34>)`, and uses a template function `process_impl(const T& val,
    Tag /*ignore*/)`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Boost.MPL` library has several data structures for metaprogramming. In
    this recipe, we only scratched the tip of the iceberg. You may find the following
    integral constant classes from MPL useful:'
  prefs: []
  type: TYPE_NORMAL
- en: '`bool_`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int_`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`long_`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`size_t`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`char_`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the `Boost.MPL` functions (except the `for_each` runtime function) are executed
    at compile time and won't add runtime overhead.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Boost.MPL` library is not a part of C++. However, C++ reuses many tricks
    from that library. C++11 in the header file `type_traits` has an `std::integral_constant<type,
    value>` class that could be used in the same way as in the preceding example.
    You could even define your own **type aliases** using it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The recipes from [Chapter 8](part0425.html#CL9V20-712b4ba1126a4c7c89e1d44de61b4bdd),
    *Metaprogramming*, will give you more examples of the `Boost.MPL` library usage.
    If you feel confident, you may also try to read the library documentation at [http://boost.org/libs/mpl](http://boost.org/libs/mpl)
    link.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Read more examples of tags usage at [http://boost.org/libs/type_traits/doc/html/boost_typetraits/examples/fill.html](http://boost.org/libs/type_traits/doc/html/boost_typetraits/examples/fill.html)
    and [http://boost.org/libs/type_traits/doc/html/boost_typetraits/examples/copy.html](http://boost.org/libs/type_traits/doc/html/boost_typetraits/examples/copy.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a type trait
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We need to implement a type trait that returns `true` if the `std::vector` type
    is passed to it as a template parameter and `false` otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some basic knowledge of the `Boost.TypeTrait` or standard library type traits
    is required.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s see how to implement a type trait:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Almost all the work is done by the `boost::true_type` and `boost::false_type`
    classes. The `boost::true_type` class has a boolean `::value` static constant
    in it that equals `true`. The `boost::false_type` class has a boolean `::value`
    static constant in it that equals `false`. These two classes also have some `typedef`s
    to cooperate well with the `Boost.MPL` library.
  prefs: []
  type: TYPE_NORMAL
- en: Our first `is_stdvector` structure is a generic structure that will be used
    always when a template specialized version of such structure is not found. Our
    second `is_stdvector` structure is a template specialization for the `std::vector`
    types (note that it is derived from `true_type`). So, when we pass `std::vector`
    type to the `is_stdvector` structure, a template specialized version is chosen
    by the compiler. If we pass a data type other than `std::vector`, then the generic
    version is used which is derived from `false_type`.
  prefs: []
  type: TYPE_NORMAL
- en: There is no public keyword before `boost::false_type` and, `boost::true_type`
    in our trait, because we use `struct` keyword, and by default, it uses public
    inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Those readers who use the C++11 compatible compilers may use the `true_type`
    and `false_type` types declared in the `<type_traits>` header for creating their
    own type traits. Since C++17, the standard library has a `bool_constant<true_or_false>`
    type alias that you may use for convenience.
  prefs: []
  type: TYPE_NORMAL
- en: As usual, the Boost versions of the classes and functions are more portable
    because they can be used on pre-C++11 compilers.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Almost all the recipes from this chapter use type traits. Refer to the `Boost.TypeTraits`
    documentation for more examples and information at [http://boost.org/libs/type_traits](http://boost.org/libs/type_traits)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See the previous recipe to get more information on integral constants and how
    the `true_type` and `false_type` may be implemented from scratch.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selecting an optimal operator for a template parameter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Imagine that we are working with classes from different vendors that implement
    different numbers of arithmetic operations and have constructors from integers.
    We do want to make a function that increments by any one class that is passed
    to it. Also, we want this function to be effective! Take a look at the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some basic knowledge of the C++ templates, and the `Boost.TypeTrait` or standard
    library type traits is required.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All the selecting can be done at compile time. This can be achieved using the
    `Boost.TypeTraits` library, as shown in the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by making correct functional objects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we will need a bunch of type traits:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We are ready to deduce the correct functor and use it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the magic is done via the `conditional<bool Condition, class T1, class T2>`
    metafunction. When `true` is passed into the metafunction as a first parameter,
    it returns `T1` via the `::type` `typedef`. When `false` is passed into the metafunction
    as a first parameter, it returns `T2` via the `::type` `typedef`. It acts like
    some kind of compile-time `if` statement.
  prefs: []
  type: TYPE_NORMAL
- en: So, `step0_t` holds a `detail::plus_functor` metafunction and `step1_t` holds
    `step0_t` or `detail::plus_assignable_functor`. The `step2_t` type holds `step1_t`
    or `detail::post_inc_functor`. The `step3_t` type holds `step2_t` or `detail::pre_inc_functor`.
    What each `step*_t` `typedef` holds is deduced using type trait.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is a C++11 version of this function, which can be found in the `<type_traits>`
    header in the `std::` namespace. Boost has multiple versions of this function
    in different libraries; for example, `Boost.MPL` has function `boost::mpl::if_c`,
    which acts exactly like `boost::conditional`. It also has a version `boost::mpl::if_`
    (without `c` at the end), which calls `::type` for its first template argument;
    and if it is derived from `boost::true_type`, it returns its second argument during
    the `::type` call. Otherwise, it returns the last template parameter. We can rewrite
    our `inc()` function to use `Boost.MPL`, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'C++17 has an `if constexpr` construction that makes the preceding example much
    simpler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Integral constants in the standard library, `Boost.MPL` and `Boost.TypeTraits`
    have a constexpr conversion operator. For example, it means that an instance of
    `std::true_type` can be converted to `true` value. In the preceding example, `boost::has_pre_increment<T>`
    denotes a type, appending `()`, or C++11 curly brackets `{}` make an instance
    of that type, that is convertible to `true` or `false` values.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The recipe *Enabling template functions usage for integral types.*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The recipe *Disabling template functions usage for real types.*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Boost.TypeTraits` documentation has a full list of available metafunctions.
    Follow the link [http://boost.org/libs/type_traits](http://boost.org/libs/type_traits)
    to read about it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The recipes from [Chapter 8](part0425.html#CL9V20-712b4ba1126a4c7c89e1d44de61b4bdd),
    *Metaprogramming*, will give you more examples of the `Boost.MPL` library usage.
    If you feel confident, you may also try to read its documentation at [http://boost.org/libs/mpl](http://boost.org/libs/mpl)
    link.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting a type of expression in C++03
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipes, we saw some examples of `boost::bind` usage. It may
    be a useful tool in pre-C++11 word, but it is hard to store `boost::bind` result
    as a variable in C++03.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: In C++11, we can use `auto` keyword instead of `???` and that will work. Is
    there a way to do it in C++03?
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A knowledge of the C++11 `auto` and `decltype` keywords may help you to understand
    this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will need a `Boost.Typeof` library for getting a return type of expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It just creates a variable with the name `var`, and the value of the expression
    is passed as a second argument. The type of `var` is detected from the type of
    expression.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An experienced C++ reader will note that there are more keywords in the C++11
    for detecting the types of expression. Maybe `Boost.Typeof` has a macro for them
    too. Let''s take a look at the following C++11 code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Using `Boost.Typeof`, the preceding code can be written in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: C++11 version's `decltype(expr)` deduces and returns the type of `expr`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Using `Boost.Typeof`, the preceding code can be written like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: C++11 has a special syntax for specifying return type at the end of the function
    declaration. Unfortunately, this cannot be emulated in C++03, so we cannot use
    `t1` and `t2` variables in a macro.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can freely use the results of the `BOOST_TYPEOF()` functions in templates
    and in any other compile-time expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Unfortunately, however this magic does not always work without help. For example,
    user-defined classes are not always detected, so the following code may fail on
    some compilers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'In such situations, you may give `Boost.Typeof` a helping hand and register
    a template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: However, the three most popular compilers correctly detected the type even without
    `BOOST_TYPEOF_REGISTER_TEMPLATE` and without C++11.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The official documentation of `Boost.Typeof` has more examples. Follow the link
    [http://boost.org/libs/typeof](http://boost.org/libs/typeof) to read about it.
  prefs: []
  type: TYPE_NORMAL
