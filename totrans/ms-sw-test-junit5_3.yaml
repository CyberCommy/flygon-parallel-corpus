- en: JUnit 5 Standard Tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Talk is cheap. Show me the code.
  prefs: []
  type: TYPE_NORMAL
- en: '*- Linus Torvalds*'
  prefs: []
  type: TYPE_NORMAL
- en: 'JUnit 5 provides a brand-new programming model called Jupiter. We can see this
    programming model as an API for software engineers and testers which allow to
    create JUnit 5 tests. These tests are later executed on the JUnit Platform. As
    we will discover, the Jupiter programming model allows to create many different
    types of tests. This chapter tackles the basics of Jupiter. To that aim, this
    chapter is structured as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Test lifecycle**: In this section, we analyze the structure of the Jupiter
    tests, describing the annotations involved in the management of the test life
    cycle in the JUnit 5 programming model. Then, we discover how to skip tests, and
    also how to annotate tests with a custom display name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Assertions**: In this section, first we present a brief overview of the verification
    assets, called assertions (also known as predicates). Second, we study how the
    assertions have been implemented in Jupiter. Finally, we present several third-party
    libraries about assertions, providing some examples for Hamcrest.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tagging and filtering tests**: In this section, first we will learn how to
    label Jupiter tests, that is, how to create tags in JUnit 5\. Then, we will learn
    how to filter our tests using Maven and Gradle. Finally, we are going to analyze
    how to create meta-annotations using Jupiter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Conditional test execution**: In this section, we will learn how to disable
    tests based on a given condition. After that, we make a review of the so-called
    assumptions in Jupiter, which are a mechanism provided out of the box by Jupiter
    to run tests only if certain conditions are as expected.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Nested tests**: This section presents how Jupiter allows to express the relationship
    among a group of tests, called nested tests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Repeated tests**: This section reviews how Jupiter provides the ability to
    repeat a test a specified number of times.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Migration from JUnit 4 to JUnit 5**: This section provides a set of hints
    about the main differences between JUnit 5 and its immediate antecessor, that
    is, JUnit 4\. Then, this section presents the support for several JUnit 4 rules
    within Jupiter tests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test lifecycle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we saw in [Chapter 1](part0021.html#K0RQ0-ef8404ed083f459d860f84cc8198f8bb), *Retrospective
    on software quality and Java testing*, a unit test case is composed of four stages:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Setup** (optional): First, the test initializes the test fixture (before
    the picture of the SUT).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Exercise**: Second, the test interacts with the SUT, getting some outcome
    from it as a result.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Verify**: Third, the outcome from the system under test is compared to the
    expected value using one or several assertions (also known as predicates). As
    a result, a test verdict is created.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Teardown** (optional): Finally, the test releases the test fixture to put
    the SUT back into the initial state.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In JUnit 4, there were different annotations to control these test phases. JUnit
    5 follows the same approach, that is, Java annotations are used to identify different
    methods within Java classes, implementing the test life cycle. In Jupiter, all
    these annotations are contained in the package `org.junit.jupiter.api`.
  prefs: []
  type: TYPE_NORMAL
- en: The most basic JUnit annotation is `@Test`, which identifies the methods that
    have to be executed as tests. Therefore, a Java method annotated with `org.junit.jupiter.api.Test`
    will be treated as a test. The difference of this annotation with respect to JUnit
    4's `@Test` is two folded. On the one hand, the Jupiter `@Test` annotation does
    not declare any attributes. In JUnit 4,  `@Test` can declare the test timeout
    (as long attribute with the timeout in milliseconds), on the other hand, in JUnit
    5, neither test classes nor test methods need to be public (this was a requirement
    in JUnit 4).
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at the following Java class. Possibly, it is the simplest test case
    we can create with Jupiter. It has simply a method with the `@Test` annotation. The
    test logic (that is the exercise and verify stages as described before) would
    be contained inside the method `myTest`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The Jupiter annotations (also located in the package `org.junit.jupiter.api`)
    aimed to control the setup and tear down stages in JUnit 5 tests are described
    in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **JUnit 5 annotation** | **Description** | **JUnit 4''s equivalence** |'
  prefs: []
  type: TYPE_TB
- en: '| `@BeforeEach` | Method executed before each `@Test` in the current class
    | `@Before` |'
  prefs: []
  type: TYPE_TB
- en: '| `@AfterEach` | Method executed after each `@Test` in the current class |
    `@After` |'
  prefs: []
  type: TYPE_TB
- en: '| `@BeforeAll` | Method executed before all `@Test` in the current class |
    `@BeforeClass` |'
  prefs: []
  type: TYPE_TB
- en: '| `@AfterAll` | Method executed after all `@Test` in the current class | `@AfterClass`
    |'
  prefs: []
  type: TYPE_TB
- en: Methods annotated with these annotations (`@BeforeEach`, `@AfterEach`, `@AfterAll`,
    and `@BeforeAll`) are always inherited.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following picture depicts the order of execution of these annotations in
    a Java class:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00035.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Jupiter annotations to control the test lyfecycle
  prefs: []
  type: TYPE_NORMAL
- en: Let's go back to the generic structure for tests we saw at the beginning of
    this section. Now, we are able to map the Jupiter annotations to control the test
    lifecycle with the different parts of a test case. As illustrated in the following
    picture, we carry out the setup stage by annotating methods with `@BeforeAll`
    and `@BeforeEach`. Then, we carry out the exercise and verify stages in methods
    annotated with `@Test`. Finally, we carry out the tear down process in the methods
    with `@AfterEach` and `@AfterAll`.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00036.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Relationship among the unit test cases stages and the Jupiter annotations
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see a simple example, which uses all these annotations in a single Java
    class. This example defines two tests (that is, two methods annotated with `@Test`),
    and we define additional methods for the rest of the test life cycle with the
    annotations `@BeforeAll`, `@BeforeEach`, `@AfterEach`, and `@AfterAll`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run this test class, first `@BeforeAll` will be executed. Then, the two
    test methods will be executed sequentially, that is, the first one and then the
    other. In each execution, the setup method annotated with `@BeforeEach` will be
    executed before the test, and then the `@AfterEach` method. The following screenshot
    shows an execution of the tests using Maven and the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00037.gif)'
  prefs: []
  type: TYPE_IMG
- en: Execution of a Jupiter test which controls its lifecycle
  prefs: []
  type: TYPE_NORMAL
- en: Test instance lifecycle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to provide execution in isolation, the JUnit 5 framework creates a
    new test instance before executing the actual test (that is, the method annotated
    with `@Test`). This *per-method* test instance life cycle is the behavior in the
    Jupiter test and also in its antecessors (JUnit 3 and 4). As a novelty, this default
    behavior can be changed in JUnit 5, simply by annotating a `test` class with `@TestInstance(Lifecycle.PER_CLASS)`.
    Using this mode, the test instance will be created once per class, instead of
    once per test method.
  prefs: []
  type: TYPE_NORMAL
- en: This *per-class* behavior implies that it is possible to declare the `@BeforeAll`
    and `@AfterAll` methods as non-static. This is beneficial to be used in conjunction
    with some advanced capabilities, such as nested test or default test interfaces
    (explained in the next chapter).
  prefs: []
  type: TYPE_NORMAL
- en: 'All in all, and taking into account the extension callback (as explained in
    the  *The extension model of JUnit 5* section of Chapter 2, *What''s new in JUnit
    5*), the relative execution order of user code and extensions is depicted in the
    following picture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00038.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Relative execution order of user code and extensions
  prefs: []
  type: TYPE_NORMAL
- en: Skipping tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Jupiter annotation `@Disabled` (located in the package `org.junit.jupiter.api`)
    can be used to skip tests. It can be used at class level or method level. The
    following example uses the annotation `@Disabled` at method level and therefore
    it forces to skip the test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in the following screenshot, when we execute this example, the test
    will be counted as skipped:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00039.gif)'
  prefs: []
  type: TYPE_IMG
- en: Disabled test method console output
  prefs: []
  type: TYPE_NORMAL
- en: 'In this other example, the annotation `@Disabled` is placed at the class level
    and therefore all the tests contained in the class will be skipped. Note that
    a custom message, typically with the reason of the disabling, can be specified
    within the annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows how the test case is skipped when it is executed
    (in this example using Maven and the command line):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00040.gif)'
  prefs: []
  type: TYPE_IMG
- en: Disabled test class console output
  prefs: []
  type: TYPE_NORMAL
- en: Display names
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JUnit 4 identified tests basically with the name of the method annotated with
    `@Test`. This imposes a limitation on name tests, since these names are constrained
    by the way of declaring methods in Java.
  prefs: []
  type: TYPE_NORMAL
- en: To overcome this problem, Jupiter provides the ability of declaring a custom
    display name (different to the test name) for tests. This is done with the annotation
    `@DisplayName`. This annotation declares a custom display name for a test class
    or a test method. This name will be displayed by test runners and reporting tools,
    and it can contain spaces, special characters, and even emojis.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following example. We are annotating the test class, and
    also the three test methods declared inside the class with a custom test name
    using `@DisplayName`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'As a result, we see these labels when executing this test in a JUnit 5 compliant
    IDE. The following picture shows the execution of the example on IntelliJ 2016.2+:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00042.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Execution of a test case using *@DisplayName* in IntelliJ
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, the display name can be also seen in Eclipse 4.7 (Oxygen)
    or newer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00043.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Execution of a test case using *@DisplayName* in Eclipse
  prefs: []
  type: TYPE_NORMAL
- en: Assertions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we know, the general structure of a test case is composed of four stages:
    setup, exercise, verify, and tear down. The actual test happens during the second
    and third stage, when the test logic interacts with the system under test, getting
    some kind of outcome from it. This outcome is compared with the expected result
    in the verify stage. In this stage, we find what we call assertions. In this section,
    we take a closer look at them.'
  prefs: []
  type: TYPE_NORMAL
- en: 'An assertion (also known as a predicate) is a `boolean` statement typically
    used to reason about software correctness. From a technical point of view, an
    assertion is composed of three parts (see the image after the list):'
  prefs: []
  type: TYPE_NORMAL
- en: First, we find the expected value, which comes from what we call test oracles.
    A test oracle is a reliable source of expected outputs, for example, the system
    specification.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Second, we find the real outcome, which comes from the exercise stage made by
    the test against the SUT.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, these two values are compared using some logic comparator. This comparison
    can be done in many different ways, for example, we can compare the object identity
    (equals or not), the magnitude (higher or lower value), and so on. As a result,
    we obtain a test verdict, which, in the end, is going to define if the test has
    succeeded or failed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00044.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Schematic view of an assertion
  prefs: []
  type: TYPE_NORMAL
- en: Jupiter assertions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's move on to the JUnit 5 programming model. Jupiter comes with many of the
    assertion methods such as the ones in JUnit 4, and also adds several that can
    be used with Java 8 lambdas. All JUnit Jupiter assertions are static methods in
    the `Assertions` class located in `org.junit.jupiter package`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following picture shows the complete list of these methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00045.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Complete list of Jupiter assertions (class *org.junit.jupiter.Assertions*)
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table reviews the different types of basic assertions in Jupiter:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Assertion** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `fail` | Fails a test with a given message and/or exception |'
  prefs: []
  type: TYPE_TB
- en: '| `assertTrue` | Asserts that a supplied condition is true |'
  prefs: []
  type: TYPE_TB
- en: '| `assertFalse` | Asserts that a supplied condition is false |'
  prefs: []
  type: TYPE_TB
- en: '| `assertNull` | Asserts that a supplied object is `null` |'
  prefs: []
  type: TYPE_TB
- en: '| `assertNotNull` | Asserts that a supplied object is not `null` |'
  prefs: []
  type: TYPE_TB
- en: '| `assertEquals` | Asserts that two supplied objects are equal |'
  prefs: []
  type: TYPE_TB
- en: '| `assertArrayEquals` | Asserts that two supplied arrays are equal |'
  prefs: []
  type: TYPE_TB
- en: '| `assertIterableEquals` | Asserts that two iterable objects are deeply equal
    |'
  prefs: []
  type: TYPE_TB
- en: '| `assertLinesMatch` | Asserts that two lists of Strings are equals |'
  prefs: []
  type: TYPE_TB
- en: '| `assertNotEquals` | Asserts that two supplied objects are not equal |'
  prefs: []
  type: TYPE_TB
- en: '| `assertSame` | Asserts that two objects are the same, compared with `==`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `assertNotSame` | Asserts that two objects are different, compared with `!=`
    |'
  prefs: []
  type: TYPE_TB
- en: For each of the assertions contained in the table, an optional failure message
    (String) can be provided. This message is always the last parameter in the assertion
    method. This is a small difference with respect to JUnit 4, in which this message
    was the first parameter in the method invocation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows a test using the  `assertEquals`, `assertTrue`,
    and `assertFalse `assertion. Note that we are importing the static assertion methods
    at the beginning of the class in order to improve the readability of the test
    logic. In the example, we find the `assertEquals `method, in this case comparing
    two primitive types (it could also be used for objects). Second, the method `assertTrue`
    evaluates if a `boolean` expression is true. Third, the method `assertFalse` evaluates
    if a Boolean expression is false. In this case, notice that the message is created
    as a Lamdba expression. This way, assertion messages are lazily evaluated to avoid
    constructing complex messages unnecessarily:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The following parts of this section review the advance assertions provided
    by Jupiter: `assertAll`, `assertThrows`, `assertTimeout`, and `assertTimeoutPreemptively`.'
  prefs: []
  type: TYPE_NORMAL
- en: Group of assertions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An important Jupiter assertion is `assertAll`. This method allows to group different
    assertions at the same time. In a grouped assertion, all assertions are always
    executed, and any failures will be reported together.
  prefs: []
  type: TYPE_NORMAL
- en: The method `assertAll` accepts a vargargs of lambda expressions (`Executable…`)
    or a stream of those (`Stream<Executable>`). Optionally, the first parameter of
    `assertAll` can be a String message aimed to label the assertion group.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see an example. In the following test, we are grouping a couple of `assertEquals`
    using lambda expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'When executing this test, all assertions of the group will be evaluated. Since
    the second assertion fails (`lastname` does not match), one failure is reported
    in the final verdict, as can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00046.gif)'
  prefs: []
  type: TYPE_IMG
- en: Console output of grouped assertions example
  prefs: []
  type: TYPE_NORMAL
- en: Asserting exceptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another important Jupiter assertion is `assertThrows`. This assertion allows
    to verify if a given exception is raised in a piece of code. To that aim, the
    method `assertThrows` accepts two arguments. First, the exception class expected,
    and second, an executable object (lambda expression), in which the exception is
    supposed to happen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The is expecting  `IllegalArgumentException` to be thrown, and this is actually
    happening inside this lambda expression. The following screenshot shows that the
    test actually succeeds:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00047.gif)'
  prefs: []
  type: TYPE_IMG
- en: Console output of *assertThrows* example
  prefs: []
  type: TYPE_NORMAL
- en: Asserting timeouts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To assess timeouts in JUnit 5 tests, Jupiter provides two assertions: `assertTimeout`
    and `assertTimeoutPreemptively`. On the one hand, `assertTimeout`, allows us to
    verify the timeout of a given operation. In this assertion, the expected time
    is defined using the class `Duration` of the standard Java package `java.time`.'
  prefs: []
  type: TYPE_NORMAL
- en: We are going to see several running examples to clarify the use of this assertion
    method. In the following class, we find two tests using `assertTimeout`. The first
    test is designed to be succeeded, due to the fact that we are expecting that a
    given operation takes less than 2 minutes, and we are doing nothing there. On
    the other side, the second test will fail, since we are expecting that a given
    operation takes a maximum of 10 milliseconds, and we are forcing it to last 100
    milliseconds.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'When we execute this test, the second test is declared as failed because the
    timeout has been exceeded in 90 milliseconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00048.gif)'
  prefs: []
  type: TYPE_IMG
- en: Console output of *assertTimeout* first example
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see a couple more tests using `assertTimeout`. In the first test, `assertTimeout`
    evaluates a piece of code as a lambda expression in a given timeout, obtaining
    its result. In the second test, `assertTimeout` evaluates a method in a given
    timeout, obtaining its result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In both cases, the tests take less time than expected and therefore both of
    them are succeeded:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00049.gif)'
  prefs: []
  type: TYPE_IMG
- en: Console output of *assertTimeout* second example
  prefs: []
  type: TYPE_NORMAL
- en: The other Jupiter assertion for timeouts is called `assertTimeoutPreemptively`.
    The difference with `assertTimeoutPreemptively` with respect to `assertTimeout`
    is that `assertTimeoutPreemptively` does not wait until the end of the operation,
    and the execution is aborted when the expected timeout is exceeded.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, the test will fail since we are simulating an operation which
    lasts 100 milliseconds, and we have defined a timeout of 10 milliseconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, when the timeout of 10 ms is reached, instantly the test is
    declared as a failure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00050.gif)'
  prefs: []
  type: TYPE_IMG
- en: Console output of *assertTimeoutPreemptively* example
  prefs: []
  type: TYPE_NORMAL
- en: Third-party assertion libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we have seen, the built-in assertions provided out of the box for Jupiter
    are sufficient for many testing scenarios. Nevertheless, there are times when
    more additional functionality, such as matchers, can be desired or required. In
    such situations, the JUnit team recommends the use of the following third-party
    assertion libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Hamcrest ([http://hamcrest.org/](http://hamcrest.org/)): an assertion framework
    to write matcher objects allowing rules to be defined declaratively.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'AssertJ ([http://joel-costigliola.github.io/assertj/](http://joel-costigliola.github.io/assertj/)):
    fluent assertions for Java.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Truth ([https://google.github.io/truth/](https://google.github.io/truth/)):
    an assertions Java library designed to make test assertions and failure messages
    more readable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this section, we are going to make a brief review of Hamcrest. This library
    provided the assertion `assertThat`, which allows to create readable highly configurable
    assertions. The method `assertThat` accepts two arguments: first the actual object,
    and second a `Matcher` object. This matcher implements the interface `org.hamcrest.Matcher`,
    and enables a partial or an exact match for an expectation. Hamcrest provides
    different matcher utilities, such as `is`, `either`, `or`, `not`, and `hasItem`.
    The Matcher methods use the builder pattern, allowing to combine one or more matchers
    to build a matcher chain.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to use Hamcrest, first we need to import the dependency in our project.
    In a Maven project, this means that we have to include the following dependency
    in our `pom.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If we are using Gradle, we need to add the equivalent configuration within
    the `build.gradle` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As usual, it is recommended using the latest version of Hamcrest. We can check
    it on the Maven central web ([http://search.maven.org/](http://search.maven.org/)).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example demonstrates how to use Hamcrest inside a Jupiter test.
    Concretely, this test uses the assertion `assertThat` together with the matchers
    `containsString`, `equalTo`, and `notNullValue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in the following screenshot, this test is executed with no failure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00051.gif)'
  prefs: []
  type: TYPE_IMG
- en: Console output of example using the Hamcrest assertion library
  prefs: []
  type: TYPE_NORMAL
- en: Tagging and filtering tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Test classes and methods can be tagged in the JUnit 5 programming model by
    means of the annotation `@Tag` (package `org.junit.jupiter.api`). Those tags can
    later be used to filter test discovery and execution. In the following example,
    we see the use of `@Tag` at class level and also at method level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'As of JUnit 5 M6, the label for tagging tests should meet the following syntax
    rules:'
  prefs: []
  type: TYPE_NORMAL
- en: A tag must not be null or blank.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A trimmed tag (that is, tags in which leading and trailing whitespace have been
    removed) must not contain a white space.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A trimmed tag must not contain ISO control characters nor the following reserved
    characters: `,`, `(`, `)`, `&`, `|`, and `!`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filtering tests with Maven
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we already know, we need to use  `maven-surefire-plugin` in a Maven project
    to execute Jupiter test. Moreover, this plugin allows us to filter the test execution
    in several ways: filtering by JUnit 5 tags and also using the regular inclusion/exclusion
    support of `maven-surefire-plugin`.'
  prefs: []
  type: TYPE_NORMAL
- en: In order to filter by tags, the properties `includeTags` and `excludeTags` of
    the `maven-surefire-plugin` configuration should be used. Let's see an example
    to demonstrate how. Consider the following tests contained in the same Maven project.
    On the one hand, all tests in this class are tagged with the  `functional` word.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, all tests in the second class are tagged as `non-functional`
    and each individual test is also labeled with more tags (`performance`, `security`,
    `usability`, and so on):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'As described before, we use the configuration keywords `includeTags` and `excludeTags`
    in the Maven `pom.xml` file. In this example, we include the test with the tag
    `functional` and exclude `non-functional`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'As a result, when we try to execute all the tests within the project, only
    two will be executed (those with the tag `functional`), and the rest are not recognized
    as tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00052.gif)'
  prefs: []
  type: TYPE_IMG
- en: Maven execution of test filtering by tags
  prefs: []
  type: TYPE_NORMAL
- en: Maven regular support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The regular inclusion/exclusion support of the Maven plugin can still be used
    to select which tests are going to be executed by `maven-surefire-plugin`. To
    that aim, we use the keywords `includes` and `excludes` to configure the test
    name pattern used to filter the execution by the plugin. Notice that for both
    inclusions and exclusions, regular expressions can be used to specify a pattern
    of the test filenames:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: These three patterns, that is, the Java files containing the word *Test* or
    ending with *TestCase*, are included by default by a *maven-surefire plugin*.
  prefs: []
  type: TYPE_NORMAL
- en: Filtering tests with Gradle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s move now to Gradle. As we already know, we can also use Gradle to run
    JUnit 5 tests. Regarding the filtering process, we can select the test to be executed
    based on:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The test engine: Using the keyword engines we can include or exclude the test
    engine to be used (that is `junit-jupiter` or `junit-vintage`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Jupiter tags: Using the keyword `tags`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Java packages: Using the keyword `packages`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The class name patterns: Using the keyword `includeClassNamePattern`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'By default, all engines and tags are included in the test plan. Only the classname
    containing the word `Tests` is applied. Let''s see a working example. We reuse
    the same tests presented in the former Maven project, but this time in a Gradle
    project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that we are including the tags `non-functional` and excluding `functional`, and
    therefore we execute four tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00053.gif)'
  prefs: []
  type: TYPE_IMG
- en: Gradle execution of test filtering by tags
  prefs: []
  type: TYPE_NORMAL
- en: Meta-annotations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The final part of this section is about the definition of meta-annotations.
    The JUnit Jupiter annotations can be used in the definition of other annotations
    (that is, can be used as meta-annotations). That means that we can define our
    own composed annotation that will automatically inherit the semantics of its meta-annotations.
    This feature is very convenient to create our custom test taxonomy by reusing
    the JUnit 5 annotation `@Tag`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see an example. Consider the following classification for test cases,
    in which we classify all tests as functional and non-functional, and then we make
    another level under the non-functional tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00054.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Example taxonomy for tests (functional and non-functional)
  prefs: []
  type: TYPE_NORMAL
- en: 'With that scheme in mind, we are going to create our custom meta-annotations
    for leaves of that tree structure: `@Functional`, `@Security`, `@Usability`, `@Accessiblity`,
    `@Load`, and `@Stress`. Notice that in each annotation we are using one or more
    `@Tag` annotations, depending on the structure previously defined. First, we can
    see the declaration of `@Functional`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we define the annotation `@Security` with tags `non-functional` and `security`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, we define the annotation `@Load`, but this time tagging with `non-functional`,
    `performance`, and `load`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally we create the annotation `@Stress` (with tags `non-functional`, `performance`,
    and `stress`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can use our annotations to tag (and later filter) tests. For instance,
    in the following example we are using the annotation `@Functional` at class level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also out annotations at method level. In the following test, we annotate
    the different tests (methods) with different annotations (`@Load`, `@Stress`,
    `@Security`, and `@Accessibility`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'All in all, we can filter the test by simply changing the included tags. On
    the one hand, we can filter by the tag `functional`. Notice that in this case,
    only two tests are executed. The following snippet shows the output of this kind
    of filtering using Maven:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00055.gif)'
  prefs: []
  type: TYPE_IMG
- en: Filtering test by tags (functional) using Maven and the command line
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, we can also filter with different tags, such as `non-functional`.
    The following picture shows an example of this type of filtering, this time using
    Gradle. As usual, we can play with these examples by forking the GitHub repository
    ([https://github.com/bonigarcia/mastering-junit5](https://github.com/bonigarcia/mastering-junit5)):'
  prefs: []
  type: TYPE_NORMAL
- en: '>![](img/00056.gif)'
  prefs: []
  type: TYPE_NORMAL
- en: Filtering test by tags (non-functional) using Gradle and the command line
  prefs: []
  type: TYPE_NORMAL
- en: Conditional test execution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to establish custom conditions for test execution, we need to use the
    JUnit 5 extension model (introduced in [Chapter 2](part0051.html#1GKCM0-ef8404ed083f459d860f84cc8198f8bb),
    *What's new in JUnit 5*, in the section *The extension model of JUnit 5*). Concretely,
    we need to use the conditional extension point called `ExecutionCondition`. This
    extension can be used to deactivate either all tests in a class or individual
    tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to see a working example in which we create a custom annotation
    to disable tests based on the operative system. First of all, we create a custom
    utility enumeration to select one operative system (`WINDOWS`, `MAC`, `LINUX`,
    and `OTHER`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Then, we create an extension of `ExecutionCondition`. In this example, the evaluation
    is done by checking whether or not the custom annotation `@DisabledOnOs` is present.
    When the annotation `@DisabledOnOs` is present, the value of the operative system
    is compared with the current platform. Depending on the result of that condition,
    the test is disabled or enabled.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Moreover, we need to create our custom annotation `@DisabledOnOs`, which is
    also annotated with `@ExtendWith` pointing to our extension point.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we use our annotation `@DisabledOnOs` in a Jupiter test.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'If we execute this test in a Windows machine, the test is not skipped, as we
    can see in this snapshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00057.gif)'
  prefs: []
  type: TYPE_IMG
- en: Execution of conditional test example
  prefs: []
  type: TYPE_NORMAL
- en: Assumptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this part of this section is about the so-called assumptions. Assumptions
    allow us to only run tests if certain conditions are as expected. All JUnit Jupiter
    assumptions are static methods in the class `Assumptions`, located inside the
    `org.junit.jupiter` package. The following screenshot shows all the methods of
    this class:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00058.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Methods of the class *org.junit.jupiter.Assumptions*
  prefs: []
  type: TYPE_NORMAL
- en: 'On the one hand, the methods `assumeTrue` and `assumeFalse` can be used to
    skip tests whose preconditions are not met. On the other hand, the method `assumingThat`
    is used to condition the execution of a part in a test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that in this example, the two first tests (`assumeTrueTest` and `assumeFalseTest`)
    are skipped since the assumptions are not met. Nevertheless, in the `assummingThatTest` test,
    only this part of the test (a lambda expression in this case) is not executed,
    but the whole test is not skipped:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00059.gif)'
  prefs: []
  type: TYPE_IMG
- en: Execution of assumptions test example
  prefs: []
  type: TYPE_NORMAL
- en: Nested tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nested tests give the test writer more capabilities to express the relationship
    and order in a group of tests. JUnit 5 makes it effortless to nest test classes.
    We simply need to annotate inner classes with `@Nested` and all test methods in
    there will be executed as well, going from the regular tests (defined in the top-level
    class) to the tests defined in each of the inner classes.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we need to take into account is that only non-static nested
    classes (that is inner classes) can serve as `@Nested` tests. Nesting can be arbitrarily
    deep, and the setup and tear down for each test (that is, `@BeforeEach` and `@AfterEach`
    methods) are inherited in the nested tests. Nevertheless, inner classes cannot
    define the `@BeforeAll` and `@AfterAll` methods, due to the fact that Java does
    not allow static members in inner classes. However, this restriction can be avoided
    using the annotation `@TestInstance(Lifecycle.PER_CLASS)` in the test class. As
    described in the section *Test instance lifecycle* in this chapter, this annotation
    force to instance a test instance per class, instead of a test instance per method
    (default behavior). This way, the methods `@BeforeAll` and `@AfterAll` do not
    need to be static and therefore it can be used in nested tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see a simple example composed by a Java class with two levels of inner
    classes, that is, the class contains two nested inner classes annotated with `@Nested`.
    As we can see, there are tests in the three levels of the class. Notice that the
    top class defined a setup method (`@BeforeEach`), and also the first nested class
    (called `InnerClass1` in the example). In the top-level class, we define a single
    test (called `topTest`), and in each nested class we find another test (called
    `innerTest1` and `innerTest2`, respectively):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: If we execute this example, we can trace the execution of the nested tests by
    simply looking to the console traces. Note that the top `@BeforeEach` method (called
    `setup1`) is always executed before each test. Therefore, the trace `Setup 1` is
    always present in the console before the actual test execution. Each test also
    writes a line the console. As we can see, the first test logs `Test 1`. After
    that, the tests defined in the inner classes are executed. The first inner class
    executes the test `innerTest1`, but after that, the setup method of the top-level
    class and the first inner class are executed (logging `Setup 1` and `Setup 2`,
    respectively).
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the test defined in the last inner class (`innerTest2`) is executed,
    but as usual, the cascade of setup methods is executed before the test:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00060.gif)'
  prefs: []
  type: TYPE_IMG
- en: Console output of the execution of the nested test example
  prefs: []
  type: TYPE_NORMAL
- en: 'Nested tests can be used in conjunction with the display name (that is, the
    annotation `@DisplayName`) to help to produce a nicely readable test output. The
    following example demonstrates how. This class contains the structure to test
    the implementation of a stack, that is, a *last-in-first-out* (LIFO) collection.
    The class is designed to first test the stack when it is just instantiated (the
    method `isInstantiatedWithNew`). After that, the first inner class (`WhenNew`)
    is supposed to test the stack as an empty collection (methods `isEmpty`, `throwsExceptionWhenPopped` and `throwsExceptionWhenPeeked`).
    Finally, the second inner class is supposed to test when the stack is not empty
    (methods `isNotEmpty`, `returnElementWhenPopped`, and `returnElementWhenPeeked`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The objective of this type of test is two folded. On the one hand, the class
    structure provides an order for the execution of the tests. On the other hand,
    the use of `@DisplayName` improves the readability of the test execution. We can
    see that when the test is executed in an IDE, concretely in IntelliJ IDEA.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00061.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Execution of nested test using *@DisplayName* on Intellij IDEA
  prefs: []
  type: TYPE_NORMAL
- en: Repeated tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JUnit Jupiter provides for the ability to repeat a test a specified number of
    times simply by annotating a method with `@RepeatedTest`, specifying the total
    number of repetitions desired. Each repeated test behaves exactly as a regular
    `@Test` method. Moreover, each repeated test preserves the same lifecycle callbacks
    (`@BeforeEach`, `@AfterEach`, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following Java class contains a test that is going to be repeated five
    times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Due to the fact that this test only writes a line (`Repeated test`) in the
    standard output, when executing this test in the console, we will see that trace
    five times:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00062.gif)'
  prefs: []
  type: TYPE_IMG
- en: Execution of repeated test in the console
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to specifying the number of repetitions, a custom display name
    can be configured for each repetition via the name attribute of the `@RepeatedTest`
    annotation. The display name can be a pattern composed of a combination of static
    text and dynamic placeholders. The following are currently supported:'
  prefs: []
  type: TYPE_NORMAL
- en: '`{displayName}`: This is the name of the `@RepeatedTest` method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`{currentRepetition}`: This is the current repetition count.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`{totalRepetitions}`: This is the total number of repetitions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following example shows a class with three repeated tests in which the
    display name is configured with the property name of `@RepeatedTest`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'In this test, the display name for these repeated tests will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For the test `customDisplayName`, the display name will follow the long display
    format:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Repeat 1 out of 2`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Repeat 2 out of 2`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For the test `customDisplayNameWithLongPattern`, the display name will follow
    the long display format:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Repeat! 1/2`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Repeat! 2/2`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For the test `customDisplayNameWithShortPattern`, the display name in this
    test will follow the short display format:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Test using long display name :: repetition 1 of 2`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Test using long display name :: repetition 2 of 2`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/00063.gif)'
  prefs: []
  type: TYPE_IMG
- en: Execution of repeated test example in conjunction with *@DisplayName*
  prefs: []
  type: TYPE_NORMAL
- en: Migration from JUnit 4 to JUnit 5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JUnit 5 does not support JUnit 4 features, such as Rules and Runners, natively.
    Nevertheless, JUnit 5 provides a gentle migration path via the JUnit Vintage test
    engine, which allows us to execute legacy test cases (including JUnit 4 but also
    JUnit 3) on the top of the JUnit Platform.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table can be used to summarize the main differences between JUnit
    4 and 5:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Feature** | **JUnit 4** | **JUnit 5** |'
  prefs: []
  type: TYPE_TB
- en: '| Annotations package | `org.junit` | `org.junit.jupiter.api` |'
  prefs: []
  type: TYPE_TB
- en: '| Declaring a test | `@Test` | `@Test` |'
  prefs: []
  type: TYPE_TB
- en: '| Setup for all tests | `@BeforeClass` | `@BeforeAll` |'
  prefs: []
  type: TYPE_TB
- en: '| Setup per test | `@Before` | `@BeforeEach` |'
  prefs: []
  type: TYPE_TB
- en: '| Tear down per test | `@After` | `@AfterEach` |'
  prefs: []
  type: TYPE_TB
- en: '| Tear down for all tests | `@AfterClass` | `@AfterAll` |'
  prefs: []
  type: TYPE_TB
- en: '| Tagging and filtering | `@Category` | `@Tag` |'
  prefs: []
  type: TYPE_TB
- en: '| Disable a test method or class | `@Ignore` | `@Disabled` |'
  prefs: []
  type: TYPE_TB
- en: '| Nested tests | NA | `@Nested` |'
  prefs: []
  type: TYPE_TB
- en: '| Repeated test | Using custom rule | `@Repeated` |'
  prefs: []
  type: TYPE_TB
- en: '| Dynamic tests | NA | `@TestFactory` |'
  prefs: []
  type: TYPE_TB
- en: '| Test templates | NA | `@TestTemaplate` |'
  prefs: []
  type: TYPE_TB
- en: '| Runners | `@RunWith` | This feature is superseded by the extension model
    (`@ExtendWith`) |'
  prefs: []
  type: TYPE_TB
- en: '| Rules | `@Rule` and `@ClassRule` | This feature is superseded by the extension
    model (`@ExtendWith`) |'
  prefs: []
  type: TYPE_TB
- en: Rule support in Jupiter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As described before, Jupiter does not support JUnit 4 rules natively. Nevertheless,
    the JUnit 5 team realized that JUnit 4 rules are widely adopted in many test codebases
    nowadays. In order to provide a seamless migration from JUnit 4 to JUnit 5, the
    JUnit 5 team implemented the `junit-jupiter-migrationsupport` module. If this
    module is going to be used in a project, the module dependency should be imported.
    Examples for Maven are shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The Gradle declaration for this dependency is like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The rule support in JUnit 5 is limited to those rules semantically compatible
    with the Jupiter extension model, including the following rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '`junit.rules.ExternalResource` (including `org.junit.rules.TemporaryFolder`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`junit.rules.Verifier` (including `org.junit.rules.ErrorCollector`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`junit.rules.ExpectedException`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In order to enable these rules in Jupiter tests, the test class should be annotated
    with the class-level annotation `@EnableRuleMigrationSupport` (located in the
    package `org.junit.jupiter.migrationsupport.rules`). Let us see several examples.
    First, the following test case defines and uses a `TemporaryFolder` JUnit 4 rule
    within a Jupiter test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'When executing this test, the path of the temporary folder will be logged on
    the standard output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00064.gif)'
  prefs: []
  type: TYPE_IMG
- en: Execution of Jupiter test using a JUnit 4 *TemporaryFolder* rule
  prefs: []
  type: TYPE_NORMAL
- en: 'The following test demonstrates the use of the `ErrorCollector` rule in a Jupiter
    test. Notice that the collector rule allows the execution of a test to continue
    after one or more problems are found:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'These problems are reported together at the end of the test:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00065.gif)'
  prefs: []
  type: TYPE_IMG
- en: Execution of Jupiter test using a JUnit 4 *ErrorCollector* rule
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the `ExpectedException` rule allows us to configure a test to anticipate
    a given exception to be thrown within the test logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: In this example, even when the second test raises a `NullPointerException`,
    the test will be marked as having succeeded since that exception was expected.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00066.gif)'
  prefs: []
  type: TYPE_IMG
- en: Execution of Jupiter test using a JUnit 4 *ExpectedException* rule
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we introduced the basics of the brand-new programming model
    of the JUnit 5 framework, known as Jupiter. This programming model provides a
    rich API that can be used by practitioners to create test cases. The most basic
    element of Jupiter is the annotation `@Test`, which identifies the methods in
    Java classes treated as tests (that is logic which exercises and verifies a SUT).
    Moreover, there are different annotations that can be used to control the test
    life cycle, namely, `@BeforeAll`, `@BeforeEach`, `@AfterEach` , and `@AfterAll`.
    Other useful Jupiter annotations are `@Disabled` (to skip tests), `@DisplayName`
    (to provide a test name), `@Tag` (to label and filter tests).
  prefs: []
  type: TYPE_NORMAL
- en: Jupiter provides a rich set of assertions, which are static methods in the class
    `Assertions` used to verify if the outcome obtained from the SUT corresponds with
    some expected value. We can impose conditions for the test execution in several
    ways. On the one hand, we can use `Assumptions` to only run tests (or a part of
    those) if certain conditions are as expected.
  prefs: []
  type: TYPE_NORMAL
- en: We have learned how nested tests can be created simple annotating inner Java
    classes with `@Nested`. This can be used to create test executions following an
    order given the nested classes relationship. We have also studied how easy is
    to created repeated test using the JUnit 5 programming model. The annotation `@RepeatedTest`
    is used to that aim, providing the ability to repeat a test a specified number
    of times. Finally, we have seen how Jupiter provides support for several legacy
    JUnit 4 test rules, including `ExternalResource`, `Verifier`, and `ExpectedException`.
  prefs: []
  type: TYPE_NORMAL
- en: In the [chapter 4](part0100.html#2VBO80-ef8404ed083f459d860f84cc8198f8bb), *Simplifying
    Testing With Advanced JUnit Features,* we continue discovering the JUnit programming
    model. Concretely, we review the advance features of JUnit 5, namely, dependency
    injection, dynamic tests, test interfaces, test templates, parameterized tests,
    compatibility of JUnit 5 and Java 9\. Finally, we review some of the planned features
    in the backlog for JUnit 5.1, not implemented yet at the time of this writing.
  prefs: []
  type: TYPE_NORMAL
