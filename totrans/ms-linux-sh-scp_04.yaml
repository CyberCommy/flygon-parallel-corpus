- en: Chapter 4. Creating Code Snippets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you like using the command line, but also like some of the features associated
    with using graphical **Integrated Development Environments** (**IDEs**), then
    this chapter may reveal some new ideas to you. We can create shortcuts for commonly
    used script elements using the `vi` or `vim` text editors from the command line.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating abbreviations in `.vimrc`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading snippets with `vim` text editor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using color in terminal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Abbreviations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already taken one short sojourn into the `~/.vimrc` file and we will
    now revisit this file to look at abbreviations or `abbr` controls. This file acts
    as the run control mechanism for the `vim` text editor, which is likely to be
    installed on your Linux distribution. Older distributions or Unix variants may
    have the original `vi` text editor and will make use of the `~/.exrc` file. If
    you are uncertain of the identity of your version of `vi` and the correct run
    control file to use, simply, enter the `vi` command. If a blank page opens, it
    is indeed `vi`. However, if a new blank document opens with the `vim` splash screens,
    then you are using the improved `vim` or `Vi`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Abbreviations allow for a shortcut string to be used in place of a longer string.
    These abbreviations can be set during a `vim` session from the last line mode
    but are often set in the control file. The shebang can be easily represented by
    an abbreviation, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The basic syntax of an abbreviation is shown in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Using this abbreviation, we just need to type `_sh` while in the edit mode.
    On pressing the *ENTER* key after the shortcut code, the full text for the shebang
    is printed. In reality, not just the *ENTER* key but pressing any key after the
    `abbr` code will expand the shortcut. Simple elements like this can add a lot
    to the experience of using `vim` as our text editor. The following screenshot
    shows the updated `~/.vimrc` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Abbreviations](img/00039.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We are not limited to the single abbreviation code, as we can add more `abbr`
    entries. For example, to support the shebang for Perl scripts at the line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The use of the underscore is not required, but the aim is to keep the shortcut
    code unique and not to have a typed error. We are also not limited to a single
    line; although, this is where abbreviations are most used. Consider the following
    abbreviation for an `if` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Although this does work, the formatting of the `if` statement will not be perfect
    and multiline abbreviations are far from ideal. This is where we may consider
    using code snippets that we prepared in advance.
  prefs: []
  type: TYPE_NORMAL
- en: Using code snippets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All we mean by the term code snippets is a prepared code that we can read into
    our current script. This is especially easy with `vim` being able to read the
    contents of other text files during editing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, if we need to read the contents of a file called `if` located
    in `$HOME/snippets`, we will use the following key sequences in `vim`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The contents of this file is read into the current document below the current
    cursor position. In this way, we can make the code snippets as complex as we need
    and maintain the correct indentations to aide readability and consistency.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we will make it our duty to always create a snippets directory in our home
    directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: It is not required to share the directory, so it is good practice to set the
    mode to `700` or private to the user when it is being created.
  prefs: []
  type: TYPE_NORMAL
- en: 'When creating snippets, it is your choice to use a pseudo-code or real examples.
    My preference is to use real examples that are edited to reflect the requirements
    of the recipient script. The contents of a simple `if` snippet will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This gives us the layout to create an `if` statement with a practical example.
    In this case, we check to see if `$1` is unset and send an error to the user before
    exiting the script. The key is in keeping the snippet short to limit the changes
    that need to be made but easily understood and expandable, as required.
  prefs: []
  type: TYPE_NORMAL
- en: Bringing color to the terminal
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If we are to display text messages to the users and operators executing the
    scripts, we can provide colors to help in message interpretation. Using red as
    a synonym for errors and green indicating success makes it easier to add functionality
    to our scripts. Not all but certainly a vast majority of Linux terminals support
    color. The built-in command `echo` when used with the `-e` option can display
    color to users.
  prefs: []
  type: TYPE_NORMAL
- en: 'To display a text in red we can use the `echo` command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows both the code and the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Bringing color to the terminal](img/00040.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The red text will bring immediate attention to the text and the potential of
    failure of script execution. The use of color in this way adheres to the basics
    of principals application design. If you find the code cumbersome, then simply
    use friendly variables to represent the colors and the reset code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous code, we used red and the final rest code to set the text back
    to the shell default. We could easily create variables for these color codes and
    others:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `\033` value is the *ESCAPE* character and `[31m` is the color code for
    red.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to take care while using variables, to ensure that they are properly
    delimited from the text. Modifying the earlier example, we can see how this is
    easily achieved:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We use the brace brackets to ensure that the `RED` variable is identified and
    separated from the `Error` word.
  prefs: []
  type: TYPE_NORMAL
- en: 'Saving the variable definitions to the `$HOME/snippets/color` file will allow
    them to be used in other scripts. Interestingly, we don''t need to edit this script;
    we can use the command `source` to read these variables definitions into the script
    at runtime. Within the recipient script, we need to add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the shell built-in `source` command will read the color variables into
    the script executing at runtime. The following screenshot shows a modified version
    of the `hello5.sh` script that we now call `hello7.sh`, which makes use of these
    colors:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Bringing color to the terminal](img/00041.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can see the effect this has when we execute the script. In the following
    screenshot, you will see the execution and output both with and without a supplied
    parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Bringing color to the terminal](img/00042.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We can easily identify the success and failure of the script via the color coded
    output; the green **Hello fred** where we supply the parameter and the red `Usage`
    statement where we have not provided the required name.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To any administrator script reuse will always be upmost in the quest for efficiency.
    Using `vim` at the command line can make for very quick and effective editing
    of a script and we can save typing in the use of abbreviations. These are best
    set within a user's personal `.vimrc` file and are defined with the `abbr` control.
    Beyond abbreviations, we can see the sense in using code snippets. These are pre-prepared
    blocks of code that can be read into the current script.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we had a look at the value in using color at the command line where
    a script will provide feedback. In the first look, these color codes are not the
    friendliest, but we can simplify the process by using variables. These variables
    can be set at runtime within the script and by using the `source` command their
    values to read them into the current environment.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at other mechanisms that we can use to write
    test expressions simplifying the use of integers and variables.
  prefs: []
  type: TYPE_NORMAL
