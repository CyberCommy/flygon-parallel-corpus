- en: Chapter 3. Reactive Programming – The Basic Theory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reactive programming, including functional reactive programming as will be discussed
    later, is a programming paradigm that can be used in multiparadigm languages such
    as JavaScript, Python, Scala, and many more. It is primarily distinguished from
    imperative programming, in which a statement does something by what are called
    *side effects*, in literature, about functional and reactive programming. Please
    note, though, that side effects here are not what they are in common English,
    where all medications have some effects, which are the point of taking the medication,
    and some other effects are unwanted but are tolerated for the main benefit. For
    example, Benadryl is taken for the express purpose of reducing symptoms of airborne
    allergies, and the fact that Benadryl, in a way similar to some other allergy
    medicines, can also cause drowsiness is (or at least was; now it is also sold
    as a sleeping aid) a *side effect*. This is unwelcome but tolerated as the lesser
    of two evils by people, who would rather be somewhat tired and not bothered by
    allergies than be alert but bothered by frequent sneezing. Medication side effects
    are rarely the only thing that would ordinarily be considered *side effects* by
    a programmer. For them, *side effects* are the primary intended purpose and effect
    of a statement, often implemented through changes in the stored state for a program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Reactive programming has its roots in the observer pattern, as discussed in
    Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides''s classic book *Design
    Patterns: Elements of Reusable Object-Oriented Software* (the authors of this
    book are commonly called *GoF* or *Gang of Four*). In the observer pattern, there
    is an observable subject. It has a list of listeners, and notifies all of them
    when it has something to publish. This is somewhat simpler than the publisher/subscriber
    (PubSub) pattern, not having potentially intricate filtering of which messages
    reach which subscriber which is a normal feature to include.'
  prefs: []
  type: TYPE_NORMAL
- en: Reactive programming has developed a life of its own, a bit like the MVC pattern-turned-buzzword,
    but it is best taken in connection with the broader context explored in GoF. Reactive
    programming, including the ReactJS framework (which is explored in this title),
    is intended to avoid the shared mutable state and be idempotent. This means that,
    as with RESTful web services, you will get the same result from a function whether
    you call it once or a hundred times. Pete Hunt formerly of Facebook—perhaps the
    face of ReactJS as it now exists—has said that he would rather be predictable
    than right. If there is a bug in his code, Hunt would rather have the interface
    fail the same way every single time than go on elaborate hunts for heisenbugs.
    These are bugs that manifest only in some special and slippery edge cases, and
    are explored later in this book.
  prefs: []
  type: TYPE_NORMAL
- en: ReactJS is called the *V* of *MVC*. That is, it is intended for user interface
    work and has little intentions of offering other standard features. But just as
    the painter Charles Cézanne said about the impressionist painter Claude Monet,
    "Monet is only an eye, but what an eye!" about MVC and ReactJS, we can say, "ReactJS
    is only a view, but what a view!"
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Declarative programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The war on heisenbugs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Flux Architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From pit of despair to the pit of success
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A complete UI teardown and rebuild
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JavaScript as a **Domain-specific Language** (**DSL**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Big-Coffee Notation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ReactJS, the library explored in this book, was developed by Facebook and made
    open source in the not-too-distant past. It is shaped by some of Facebook's concerns
    about making a large-scale site that is safe to debug and work on, and also allowing
    a large number of programmers to work on different components without having to
    store brain-bending levels of complexity in their heads. The quotation "Simplicity
    is the lack of interleaving," which can be found in the videos at [http://facebook.github.io/react](http://facebook.github.io/react),
    is not about how much or how little stuff there is on an absolute scale, but about
    how many moving parts you need to juggle simultaneously to work on a system (See
    the section on *Big-Coffee Notation* for further reflections).
  prefs: []
  type: TYPE_NORMAL
- en: Declarative programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Probably, the biggest theoretical advantage of the ReactJS framework is that
    the programming is declarative rather than imperative. In imperative programming,
    you specify what steps need to be done; declarative programming is the programming
    in which you specify what needs to be accomplished without telling how it needs
    to be done. It may be difficult at first to shift from an imperative paradigm
    to a declarative paradigm, but once the shift has been made, it is well worth
    the effort involved to get there.
  prefs: []
  type: TYPE_NORMAL
- en: Familiar examples of declarative paradigms, as opposed to imperative paradigms,
    include both SQL and HTML. An SQL query would be much more verbose if you had
    to specify how exactly to find records and filter them appropriately, let alone
    say how indices are to be used, and HTML would be much more verbose if, instead
    of having an IMG tag, you had to specify how to render an image. Many libraries,
    for instance, are more declarative than a rolling of your own solution from scratch.
    With a library, you are more likely to specify only what needs to be done and
    not—in addition to this—how to do it. ReactJS is not in any sense the only library
    or framework that is intended to provide a more declarative JavaScript, but this
    is one of its selling points, along with other better specifics that it offers
    to help teams work together and be productive. And again, ReactJS has emerged
    from some of Facebook's efforts in managing bugs and cognitive load while enabling
    developers to contribute a lot to a large-scale project.
  prefs: []
  type: TYPE_NORMAL
- en: The war on Heisenbugs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In modern physics, Heisenberg's uncertainty principle loosely says that there
    is an absolute theoretical limit to how well a particle's position and velocity
    can be known. Regardless of how good a laboratory's measuring equipment gets,
    funny things will always happen when you try to pin things down too far.
  prefs: []
  type: TYPE_NORMAL
- en: Heisenbugs, loosely speaking, are subtle, slippery bugs that can be very hard
    to pin down. They only manifest under very specific conditions and may even fail
    to manifest when one attempts to investigate them (note that this definition is
    slightly different from the jargon file's narrower and more specific definition
    at [http://www.catb.org/jargon/html/H/heisenbug.html](http://www.catb.org/jargon/html/H/heisenbug.html),
    which specifies that attempting to measure a heisenbug may suppress its manifestation).
    This motive—of declaring war on heisenbugs—stems from Facebook's own woes and
    experiences in working at scale and seeing heisenbugs keep popping up. One thing
    that Pete Hunt mentioned, in not a flattering light at all, was a point where
    Facebook's advertisement system was only understood by two engineers well enough
    who were comfortable with modifying it. This is an example of something to avoid.
  prefs: []
  type: TYPE_NORMAL
- en: By contrast, looking at Pete Hunt's remark that he would "rather be predictable
    than right" is a statement that if a defectively designed lamp can catch fire
    and burn, his much, much rather have it catch fire and burn immediately, the same
    way, every single time, than at just the wrong point of the moon phase have something
    burn. In the first case, the lamp will fail testing while the manufacturer is
    testing, the problem will be noticed and addressed, and lamps will not be shipped
    out to the public until the defect has been property addressed. The opposite Heisenbug
    case is one where the lamp will spark and catch fire under just the wrong conditions,
    which means that a defect will not be caught until the laps have shipped and started
    burning customers' homes down. "Predictable" means "fail the same way, every time,
    if it's going to fail at all." "Right means "passes testing successfully, but
    we don't know whether they're safe to use [probably they aren't]." Now, he ultimately
    does, in fact, care about being right, but the choices that Facebook has made
    surrounding React stem from a realization that being predictable is a means to
    being right. It's not acceptable for a manufacturer to ship something that will
    always spark and catch fire when a consumer plugs it in. However, being predictable
    moves the problems to the front and the center, rather than being the occasional
    result of subtle, hard-to-pin-down interactions that will have unacceptable consequences
    in some rare circumstances. The choices in Flux and ReactJS are designed to make
    failures obvious and bring them to the surface, rather than them being manifested
    only in the nooks and crannies of a software labyrinth.
  prefs: []
  type: TYPE_NORMAL
- en: Facebook's war on the shared mutable state is illustrated in the experience
    that they had regarding a chat bug. The chat bug became an overarching concern
    for its users. One crucial moment of enlightenment for Facebook came when they
    announced a completely unrelated feature, and the first comment on this feature
    was a request to fix the chat; it got 898 likes. Also, they commented that this
    was one of the more polite requests. The problem was that the indicator for unread
    messages could have a phantom positive message count when there were no messages
    available. Things came to a point where people seemed not to care about what improvements
    or new features Facebook was adding, but just wanted them to fix the phantom message
    count. And they kept investigating and kept addressing edge cases, but the phantom
    message count kept on recurring.
  prefs: []
  type: TYPE_NORMAL
- en: The solution, besides ReactJS, was found in the flux pattern, or architecture,
    which is discussed in the next section. After a situation where not too many people
    felt comfortable making changes, all of a sudden, many more people felt comfortable
    making changes. These things simplified matters enough that new developers tended
    not to really need the ramp-up time and treatment that had previously been given.
    Furthermore, when there was a bug, the more experienced developers could guess
    with reasonable accuracy what part of the system was the culprit, and the newer
    developers, after working on a bug, tended to feel confident and have a general
    sense of how the system worked.
  prefs: []
  type: TYPE_NORMAL
- en: The Flux Architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the ways in which Facebook, in relation to ReactJS, has declared war
    on heisenbugs is by declaring war on the mutable state. Flux is an architecture
    and a pattern, rather than a specific technology, and it can be used (or not used)
    with ReactJS. It is somewhat like MVC, equivalent to a loose competitor to that
    approach, but it is very different from a simple MVC variant and is designed to
    have a *pit of success* that provides unidirectional data flow like this: from
    the action to the dispatcher, then to the store, and finally to the view (but
    some people have said that these two are so different that a direct comparison
    between Flux and MVC, in terms of trying to identify what part of Flux corresponds
    to what conceptual hook in MVC, is not really that helpful). Actions are like
    events—they are fed into a top funnel. Dispatchers go through the funnels and
    can not only pass actions but also make sure that no additional actions are dispatched
    until the previous one has completely settled out. Stores have similarities and
    difference to models. They are like models in that they keep track of state. They
    are unlike models in that they have only getters, not setters, which stops the
    effect of any part of the program with access to a model being able to change
    anything in its setters. Stores can accept input, but in a very controlled way,
    and in general a store is not at the mercy of anything possessing a reference
    to it. A view is what displays the current output based on what is obtained from
    stores. Stores, compared to models in some respects, have getters but not setters.
    This helps foster a kind of data flow that is not at the mercy of anyone who has
    access to a setter. It is possible for events to be percolated as actions, but
    the dispatcher acts as a traffic cop and ensures that new actions are processed
    only after the stores are completely settled. This de-escalates the complexity
    considerably.'
  prefs: []
  type: TYPE_NORMAL
- en: Flux simplified interactions so that Facebook developers no longer had subtle
    edge cases and bug that kept coming back—the chat bug was finally dead and has
    not come back.
  prefs: []
  type: TYPE_NORMAL
- en: From the pit of despair to the pit of success
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Louis Brandy has warned about the perils of C++, which—at the risk of being
    controversial—has been called the biggest example of the *second system effect*
    ([http://tinyurl.com/reactjs-second-system](http://tinyurl.com/reactjs-second-system))
    since the OS/360 project. In a vague *XKCD*-style graphic, he states "Never trust
    a programmer who says he knows C++" ([http://tinyurl.com/reactjs-cpp-valley](http://tinyurl.com/reactjs-cpp-valley)).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following graph shows the level of confidence of the C++ programmer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![From the pit of despair to the pit of success](img/B04108_03_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'He continues:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"Programmers (especially those coming from C) can very quickly get up to speed
    in C++ and feel quite proficient. These programmers will tell you they know C++.
    They are lying. As a programmer continues in C++, he goes through this valley
    of frustration where he comes fully to terms with the complexity of the language.
    The good news is that it''s really easy to tell between C++ programmers pre- and
    post-valley (in an interview, in this case). Just mention that C++ is an extremely
    large and complex language, and the post-valley people will give you 127 different
    tiny frustrations they have with the language. The pre-valley people will say,
    "Yeah, I guess. I mean, it''s just C with classes."*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Eric Lippert tells us something that isn''t really relevant to only C++ programmers;
    it leads to something larger than C++:'
  prefs: []
  type: TYPE_NORMAL
- en: '*I often think of C++ as my own personal Pit of Despair programming language.
    Unmanaged C++ makes it so easy to fall into traps. Think buffer overruns, memory
    leaks, double frees, mismatch between allocator and deallocator, using freed memory,
    umpteen dozen dozen ways to trash the stack or heap -- and those are just some
    of the memory issues. There are lots more "gotchas" in C++. C++ often throws you
    into the Pit of Despair and you have to climb your way up to the Hill of Quality.
    (Not to be confused with scaling the Cliffs of Insanity. That''s different.)*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '>'
  prefs: []
  type: TYPE_NORMAL
- en: '*Now as I''ve said before, the design of C# is not a subtractive process. It
    is not "C++ with the stupid parts taken out." But that said, it would be rather
    foolish of us not to look at what problems people have had with other languages
    and work to ensure that those exact same problems do not crop up for C# users.
    I would like C# to be a "Pit of Quality" language, a language whose rules encourage
    you to write correct code in the first place. You have to work quite hard to write
    a buffer overrun bug into a C# program, and that''s on purpose.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '>'
  prefs: []
  type: TYPE_NORMAL
- en: '*I have never written a buffer overrun in C#. I have never written a bug where
    I accidentally shadowed a variable in another scope in C#. I have never used stack
    memory after the function returned in C#. I''ve done all those things multiple
    times in C++, and it''s not because I''m an idiot, it''s because C++ makes it
    easy to do all those things and C# makes it very hard. Making it easy to do good
    stuff is obviously goodness; thinking about how to make it hard to do bad is actually
    more important.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Or, as it happened on a Python mailing list, someone with an obvious 133t hax0r
    spelling asked how to write a buffer overflow in Python, and one of the more senior
    list members answered, "We're sorry, but Python doesn't support that feature."
    The point of this meme is that someone asking about how to find a particular kind
    of vulnerability is answered by saying that Python had the basic type of defect
    designed out of the language. As has been pointed out for C#, strings are handled
    in a sane fashion where no naive use ever results in buffer override vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'Eric Lippert is, and remains, a pivotal figure in C#, and his post eloquently
    clarifies how exactly one could intelligently disagree with Bjarne Stroustrup''s
    words:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"The connection between the language in which we think/program and the problems
    and solutions we can imagine is very close. For that reason restricting language
    features with the intent of eliminating programmer errors is at best dangerous."*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'People who disagree with Stroustrup today might not contest both of these sentences,
    but might contest only the second: the connection between the language and the
    solutions may indeed seem to be real, but have quite the opposite implication
    for language features and the pit of success. And something like this may be factored
    into decisions such as those in the book *JavaScript: The Good Parts* by *Douglas
    Crockford*. This or that detail might be challenged, but the core idea of using
    a cherry-picked subset of JavaScript and leaving some other parts alone completely
    stems from seeking and retrofitting the fact that a pit of success is almost a
    no-brainer once the possibility has been pointed out.'
  prefs: []
  type: TYPE_NORMAL
- en: All of this leads up to a point made by Rico Mariani in—sort of—the opposite
    of the pit of despair. The pit of success, in stark contrast to a summit, a peak,
    or a journey across a desert to find victory through many trials and surprises.
    We want our customers to simply "fall into" winning practices using our platforms
    and frameworks. To the extent that we make it easy to fall into trouble we fail.
  prefs: []
  type: TYPE_NORMAL
- en: Complete UI teardown and rebuild
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of Dijkstra''s quotations that is a favorite with ReactJS developers such
    as Pete Hunt is: our intellectual powers are rather geared to master static relations
    and that our powers to visualize processes evolving in time are relatively poorly
    developed. For that reason, we should do (as wise programmers aware of our limitations)
    our utmost to shorten the conceptual gap between the static program and the dynamic
    process, to make the correspondence between the program (spread out in text space)
    and the process (spread out in time) as trivial as possible.'
  prefs: []
  type: TYPE_NORMAL
- en: One way in which ReactJS plays to this strength conceptually, is by blowing
    everything away and re-rendering afresh so that the correspondence between the
    program and the process is simple. You do not keep track of the present state
    of the DOM and 300 jQuery changes that need to be kept in mind to transition accurately
    from one state to another. All you need to do is tell how it should look now.
    Now, in fact, ReactJS does not blow everything away under the hood; it has fairly
    sophisticated facilities that can make a lightning-fast pure JavaScript synthetic
    DOM (the same synthetic DOM that enables HTML5 features in Internet Explorer 8),
    and reconcile and make the fastest changes possible ("fast" in this context includes
    the impressive feat of managing 60-frames-per-second updates on a non-JIT iPhone
    5.) However, conceptually speaking, using ReactJS means simply treating everything
    as if it was being blown away and redrawn from scratch, and trusting ReactJS to
    bring together all the pixie dust it needs to make the minimum sufficient DOM
    changes. This is done to update the page as requested, probably without losing
    the existing input or inertial scrolling.
  prefs: []
  type: TYPE_NORMAL
- en: ReactJS provides optimization hooks to offer more fine-grained control over
    what is rendered. These are well-documented, but they should rarely be needed.
    Remember Knuth's words, "Premature optimization is the root of all evil." I have
    myself not used this feature for optimization, although the Om bindings in ClojureScript
    for ReactJS are significantly faster because they need only check reference equality
    instead of deep equality as objects are immutable in ClojureScript, although I
    have made a secondary usage, to ask ReactJS to disclaim ownership of some part
    of the DOM so that it will play nicely with third-party functionality. See [Chapter
    11](ch11.html "Chapter 11. Demonstrating Functional Reactive Programming in JavaScript
    with a Live Example Part IV – Adding a Scratchpad and Putting It All Together"),
    *Demonstrating Functional Reactive Programming in JavaScript with a Live Example
    Part IV – Adding a Scratchpad and Putting It All Together* for an example of this
    in action. ReactJS is very performant by default, rather than only in how you
    customize its default behavior.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript as a Domain-specific Language
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One widespread practice in templating systems is to provide a DSL for templating.
    In the usual process, such as an underscore on the frontend ([http://underscorejs.org](http://underscorejs.org))
    or Django templating on the backend ([http://djangoproject.com](http://djangoproject.com)),
    there is a carefully chosen but deliberately underpowered templating language
    provided. In Django, for instance, the power is deliberately limited so that templating
    can be handed over to untrusted designers, and there is nothing the designers
    can do that will compromise anything that one would prefer not to be compromised.
  prefs: []
  type: TYPE_NORMAL
- en: This is perhaps an attractive feature, but it speaks of a limited templating
    language. If templating needs something more powerful, they are in a bind until
    any requirements they have are accommodated by nonstandard adjustments on the
    server side. One basic insight, associated with Gödel's incompleteness theorem
    and the halting problem, is that if you tie someone's hands tightly enough so
    that person, in principle, cannot do any damage, you have significantly limited
    what that person is able to do. The best results require at least a little trust.
    If you want people to be able to give their most useful contributions, they probably
    won't be able to do that with their hands bound.
  prefs: []
  type: TYPE_NORMAL
- en: In ReactJS, the DSL for templating is JavaScript, with all its power. Some people
    perhaps find it strange to have designers working on raw JavaScript; The ReactJS
    people seem to have a *give it five minutes* approach (see [http://tinyurl.com/reactjs-five-minutes](http://tinyurl.com/reactjs-five-minutes)),
    and say that designers are smarter than what they are sometimes given credit for
    and are very capable of writing very specific types of JavaScript code. But this
    also means that if you have a special case and your complex situation calls for
    you to do something that was ruled out in some particular—deliberately underpowered—templating
    languages, it is good news. With ReactJS, you have the full power of JavaScript
    for use as you handle templating. With ReactJS, you can also, if you want, use
    a very limited subset of the language used for templating, and Pete Hunt and others
    seem to believe that designers are sharp enough to be able to handle it. But the
    much better news is when you have a difficult need that requires some real power
    to be available. You have as much power as JavaScript offers, and this makes quite
    a difference.
  prefs: []
  type: TYPE_NORMAL
- en: The Big-Coffee Notation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Steve Luscher, a ReactJS guru and enthusiast outside of Facebook who was subsequently
    hired by Facebook, has talked about the Big-Coffee Notation in a video on React.
    The basic insight is that instead of using only the big-O notation for runtime
    complexity (how long the runtime slows down as a function of the rough size of
    a problem, or occasionally other dimensions, such as memory usage), we should
    have a Big-Coffee Notation for what the demands scale for the poor developer,
    who has to keep things in their own poor, caffeinated brain.
  prefs: []
  type: TYPE_NORMAL
- en: 'Gerald Weinberg''s classic book *The Psychology of Computer Programming* works
    out a basic insight at admirable length. The core insight is that *programmers
    programming computers* is not just an activity that involves computers. It''s
    also an activity that involves people, and we would do well to treat it as such.
    Perhaps we should also know the limits of computers, but the human side of this
    is not, in any sense, trivial. Weinberg may have been the first to make this observation,
    or possibly someone else may have made it before him, but in either case, this
    observation has been the bedrock of serious software engineering literature ever
    since it was absorbed. It is a core insight, for instance, in Steve McConnell''s
    *Code Complete: A Practical Handbook of Software Construction*. We will not be
    exploring this idea in full, but it is well worth exploring, especially if you
    haven''t explored it before, and Big-Coffee Notation falls squarely in this court.
    The core idea is that along with tracking the big-O notation or complexity, we
    should also pay attention to how increasingly complex problems scale in terms
    of appropriate demands made by the developer. These demands are in terms of how
    many moving parts need to be kept in one''s head.'
  prefs: []
  type: TYPE_NORMAL
- en: In the big-O notation, depending somewhat on the context, there are various
    *runtime complexities* that provide an upper bound to how much the runtime escalates
    when it is given a progressively larger problem to solve. The *O(1)* runtime has
    a fixed upper limit for any use case. *O(log n)* is associated, for instance,
    with unitary operations on certain data structures. *O(n)* is also called **linear**,
    referring to a runtime in which there is a linear upper limit to how much time
    something will take to run. You are guaranteed to be at least as some constant
    multiplied by the number of items. *O(n log n)* may be the next major step up,
    and it is associated with certain sorting algorithms. *O(n ^ 2)* is called **quadratic**
    (all previously mentioned complexities are called subquadratic, which means faster
    than quadratic) and may be taken as a threshold complexity when things really
    do not scale to large volumes. *(O(n * (n – 1))* is also considered to be quadratic
    and is subsumed under *O(n ^ 2)*. After that, there are some slower polynomial
    times and exponentials, without closing the door to still slower escalations,
    such as factorials. The famous question of NP completeness is a question of whether
    certain NP-complete problems, which are known to be solvable in exponential time,
    can also always be solved in some polynomial time.
  prefs: []
  type: TYPE_NORMAL
- en: Steve Luscher's presentation about the difference between an imperative UI and
    a declarative UI is that if someone is making a widget to display the number of
    unread items in their queue, an imperative UI makes one transition between two
    states, making the poor programmer keep track of ![The Big-Coffee Notation](img/B04108_03_02.jpg),
    meaning quadratic or ![The Big-Coffee Notation](img/B04108_03_04.jpg) complexity
    for the number of items in the poor programmer's brain compared to the number
    of states. If there are three states, there are six transitions. If you add a
    fourth state, there will be 12, or twice as many, transitions. Add a fifth state
    and you are looking at twenty transitions. The explanation from the programmer
    to understand the code is *quadratic*, meaning *steep*. However, if you give the
    UI code declaratively, as in ReactJS programming, you describe the code only once
    per possible rendered state. Three states means only three descriptions. Four
    states means only four descriptions. Five states means only five descriptions.
    It's only ![The Big-Coffee Notation](img/B04108_03_03.jpg), or linear. The escalating
    demands the poor programmer's caffeinated brain to keep a track of what goes on
    in the code, which is much less of an escalation to keep track of. Like a fast
    algorithm, it is much less taxing to run.
  prefs: []
  type: TYPE_NORMAL
- en: 'I haven''t heard of Dijkstra''s *The Humble Programmer* being referenced by
    the ReactJS community, but intellectual humility is a virtue among programmers
    and has been recognized as such in software engineering literature for a long
    time. It is emphasized in classics such as *Code Complete: A Practical Handbook
    of Software Construction*, and programmers are divided, not among those who have
    big and little minds, but those who know that they have little minds and those
    who have little minds but are heedless of it. Excellence in programming partly
    stems from recognition of one''s own cognitive limits. Dijkstra writes:'
  prefs: []
  type: TYPE_NORMAL
- en: '*The competent programmer is fully aware of the strictly limited size of his
    own skull; therefore he approaches the programming task in full humility, and
    among other things he avoids clever tricks like the plague. In the case of a well-known
    conversational programming language I have been told from various sides that as
    soon as a programming community is equipped with a terminal for it, a specific
    phenomenon occurs that even has a well-established name: it is called "the one-liners".
    It takes one of two different forms: one programmer places a one-line program
    on the desk of another and either he proudly tells what it does and adds the question
    "Can you code this in less symbols?" —as if this were of any conceptual relevance!—
    or he just asks "Guess what it does!". From this observation we must conclude
    that this language as a tool is an open invitation for clever tricks; and while
    exactly this may be the explanation for some of its appeal, viz. to those who
    like to show how clever they are, I am sorry, but I must regard this as one of
    the most damning things that can be said about a programming language…*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'This challenge, namely the confrontation with the programming task, has already
    taught us a few lessons, and the one I have chosen to stress in this talk is the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*We shall do a much better programming job, provided that we approach the task
    with a full appreciation of its tremendous difficulty, provided that we stick
    to modest and elegant programming languages, provided that we respect the intrinsic
    limitations of the human mind and approach the task as *very humble programmers*.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We just took a whirlwind tour of some of the theory surrounding reactive programming
    with ReactJS. This includes declarative programming, one of the selling points
    of ReactJS that offers something easier to work with at the end than imperative
    programming. The war on heisenbugs, is an overriding concern surrounding decisions
    made by Facebook, including ReactJS. This takes place through Facebook's declared
    war on the shared mutable state. The Flux Architecture is used by Facebook with
    ReactJS to avoid some nasty classes of bugs. The pit of success and the pit of
    despair, which learns from others' pain, a pain that is concentrated in connection
    to the C++ programming language, and looks at what we should be aiming for.
  prefs: []
  type: TYPE_NORMAL
- en: We covered complete UI teardowns and rebuilds, providing a simple alternative
    to keeping track of the state in how to update an interface. We also saw JavaScript
    as a DSL, looking at an intentional decision in designing ReactJS that is meant
    to give you as much power as you need. Then the Big-Coffee Notation was discussed
    in relation to a healthy recognition of one's own limits instead of them breaking
    their shins, which is preventable.
  prefs: []
  type: TYPE_NORMAL
- en: In our next chapter, we will continue by looking at a concrete case of a user
    interface built with ReactJS.
  prefs: []
  type: TYPE_NORMAL
