- en: Chapter 2. Microservices in Node.js – Seneca and PM2 Alternatives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you will mainly learn about two frameworks, **Seneca** and
    **PM2**, and why they are important for building microservices. We will also get
    to know the alternatives to these frameworks in order to get a general understanding
    of what is going on in the Node.js ecosystem. In this chapter, we are going to
    focus on the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Need for Node.js**: In this section, we are going to justify the choice of
    Node.js as a framework to build our microservices-oriented software. We will walk
    through the software stack required to use this awesome technology.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Seneca – a microservices framework**: In this section, you will learn the
    basics of Seneca and why it is the right choice if we want to keep our software
    manageable. We will explain how to integrate Seneca with Express (the most popular
    web server in Node.js) in order to follow the industry standards.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PM2**: PM2 is the best choice to run Node.js applications. No matter what
    your problem in deploying your ecosystem of apps is, PM2 will always have a solution
    for it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Need for Node.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, I mentioned that I wasn't a big fan of Node.js in the
    past. The reason for this was that I wasn't prepared to cope with the level of
    standardization that JavaScript was undergoing.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript in the browser was painful. Cross-browser compatibility was always
    a problem and the lack of standardization didn't help to ease the pain.
  prefs: []
  type: TYPE_NORMAL
- en: Then Node.js came and it was easy to create highly scalable applications due
    to its non-blocking nature (we will talk about it later in this chapter) and it
    was also very easy to learn as it was based on JavaScript, a well-known language.
  prefs: []
  type: TYPE_NORMAL
- en: Nowadays, Node.js is the preferred choice for a large number of companies across
    the world, as well as the number one choice for aspects that require a non-blocking
    nature in the server, such as web sockets.
  prefs: []
  type: TYPE_NORMAL
- en: In this book, we will primarily (but not only) use Seneca and PM2 as the frameworks
    for building and running microservices, but it does not mean that the alternatives
    are not good.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are few alternatives in the market such as **restify** or **Express**
    for building applications and **forever** or **nodemon** to run them. However,
    I find Seneca and PM2 to be the most appropriate combination for building microservices
    for the following reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: PM2 is extremely powerful regarding application deployments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Seneca is not only a framework to build microservices, but it is also a paradigm
    that reshapes what we know about object-oriented software
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will be using Express in a few examples in the chapters of this book and
    we will also discuss how to integrate Seneca in Express as a middleware.
  prefs: []
  type: TYPE_NORMAL
- en: However, before that, let's discuss some concepts around Node.js that will help
    us to understand those frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Node.js, npm, Seneca, and PM2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Node.js is fairly easy to install. Depending on your system, there is an installer
    available that makes the installation of Node.js and **npm** (**Node Package Manager**)
    a fairly simple task. Simply double-click on it and follow the instructions. At
    the time of writing this book, there are installers available for Windows and
    OSX.
  prefs: []
  type: TYPE_NORMAL
- en: However, the advanced users, especially DevOps engineers, will need to install
    Node.js and npm from the sources or binaries.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Both Node.js and npm programs come bundled together in a single package that
    we can download for various platforms from the Node.js website (either sources
    or binaries):'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://nodejs.org/en/download/](https://nodejs.org/en/download/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'For the Chef users, a popular configuration management software to build servers,
    there are few options available, but the most popular is the following recipe
    (for those unfamiliar with Chef, a recipe is basically a script to install or
    configure software in a server through Chef):'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/redguide/nodejs](https://github.com/redguide/nodejs)'
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing this book, there are binaries available for Linux.
  prefs: []
  type: TYPE_NORMAL
- en: Learning npm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**npm** is a software that comes with Node.js and enables you to pull dependencies
    from the Internet without worrying about their management. It can also be used
    to maintain and update dependencies, as well as create projects from scratch.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you probably know, every node app comes with a `package.json` file. This
    file describes the configuration of the project (dependencies, versions, common
    commands, and so on). Let''s see the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The file itself is self-explanatory. There is an interesting section in the
    file—`scripts`.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we can specify the command that is used to run for different
    actions. In this case, if we run `npm test` from the terminal, npm will execute
    `grunt validate --verbose`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Node applications are usually as easy to run as executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In the root of your project, consider that the bootstrapping file is `index.js`.
    If this is not the case, the best thing you can do is add a subsection in the
    `scripts` section in `package.json`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, now we have two commands executing the same program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The benefits of using `npm start` are quite obvious—uniformity. No matter how
    complex your application is, `npm start` will always run it (if you have configured
    the `scripts` section correctly).
  prefs: []
  type: TYPE_NORMAL
- en: Let's install Seneca and PM2 on a clean project.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, execute `npm init` in a new folder from the terminal after installing
    Node.js. You should get a prompt similar to the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Learning npm](img/B04889_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: npm will ask you for a few parameters to configure your project, and once you
    are done, it writes a `package.json` file with content similar to the preceding
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we need to install the dependencies; npm will do that for us. Just run
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if you inspect `package.json` again, you can see that there is a new section
    called `dependencies` that contains an entry for Seneca:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This means that from now on, our app can require the Seneca module and the
    `require()` function will be able to find it. There are a few variations of the
    `save` flag, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`save`: This saves the dependency in the `dependencies` section. It is available
    through all the development life cycle.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`save-dev`: This saves the dependency in the `devDependencies` section. It
    is only available in development and does not get deployed into production.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`save-optional`: This adds a dependency (such as `save`), but lets npm continue
    if the dependency can''t be found. It is up to the app to handle the lack of this
    dependency.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s continue with PM2\. Although it can be used as a library, PM2 is mainly
    a command tool, like `ls` or `grep` in any Unix system. npm does a great job installing
    command-line tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `–g` flags instruct npm to globally install PM2, so it is available in the
    system, not in the app. This means that when the previous command finishes, `pm2`
    is available as a command in the console. If you run `pm2 help` in a terminal,
    you can see the help of PM2.
  prefs: []
  type: TYPE_NORMAL
- en: Our first program – Hello World
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the most interesting concepts around Node.js is simplicity. You can
    learn Node.js in few days and master it in a few weeks, as long as you are familiar
    with JavaScript. Code in Node.js tends to be shorter and clearer than in other
    languages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code creates a server that listens on the `8000` port for requests.
    If you don''t believe it, open a browser and type `http://127.0.0.1:8000` in the
    navigation bar, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Our first program – Hello World](img/B04889_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s explain the code:'
  prefs: []
  type: TYPE_NORMAL
- en: The first line loads the `http` module. Through the `require()` instruction,
    we ask the node to load the `http` module and assign the export of this module
    to the `http` variable. Exporting language elements is the way that Node.js has
    to expose functions and variables to the outer world from inside a module.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second construction in the script creates the HTTP server. The `http` module
    creates and exposes a method called `createServer()` that receives a function
    (remember JavaScript treats functions as first-level objects so that they can
    be passed as other functions arguments) as a parameter that, in the Node.js world,
    is called **callback**. A callback is an action to be executed as a response to
    an event. In this case, the event is that the script receives an HTTP request.
    Node.js has a heavy usage of callbacks due to its thread model. Your application
    will always be executed on a single thread so that not blocking the application
    thread while waiting for operations to complete and prevents our application from
    looking stalled or hanged. Otherwise, your program won't be responsive. We'll
    come back to this in [Chapter 4](ch04.html "Chapter 4. Writing Your First Microservice
    in Node.js"), *Writing Your First Microservice in Node.js*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next line, `server.listen(8000)` starts the server. From now on, every
    time our server receives a request, the callback on the `http.createServer()`
    function will be executed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is it. Simplicity is the key to Node.js programs. The code allows you
    to go to the point without writing tons of classes, methods, and config objects
    that complicate what, in the first instance, can be done much more simply: write
    a script that serves requests.'
  prefs: []
  type: TYPE_NORMAL
- en: Node.js threading model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Programs written in Node.js are single-threaded. The impact of this is quite
    significant; in the previous example, if we have ten thousand concurrent requests,
    they will be queued and satisfied by the Node.js event loop (it will be further
    explained in [Chapter 4](ch04.html "Chapter 4. Writing Your First Microservice
    in Node.js"), *Writing Your First Microservice in Node.js* and [Chapter 6](ch06.html
    "Chapter 6. Testing and Documenting Node.js Microservices"), *Testing and Documenting
    Node.js Microservices*) one by one.
  prefs: []
  type: TYPE_NORMAL
- en: At first glance, this sounds wrong. I mean, the modern CPUs can handle multiple
    parallel requests due to their multicore nature. So, what is the benefit of executing
    them in one thread?
  prefs: []
  type: TYPE_NORMAL
- en: The answer to this question is that Node.js was designed to handle asynchronous
    processing. This means that in the event of a slow operation such as reading a
    file, instead of blocking the thread, Node.js allows the thread to continue satisfying
    other events, and then the control process of the node will execute the method
    associated with the event, processing the response.
  prefs: []
  type: TYPE_NORMAL
- en: Sticking to the previous example, the `createServer()` method accepts a callback
    that will be executed in the event of an HTTP request, but meanwhile, the thread
    is free to keep executing other actions.
  prefs: []
  type: TYPE_NORMAL
- en: The catch in this model is what Node.js developers call the callback hell. The
    code gets complicated as every single action that is a response to a blocking
    action has to be processed on a callback, like in the previous example; the function
    used as a parameter to the `createServer()` method is a good example.
  prefs: []
  type: TYPE_NORMAL
- en: Modular organization best practices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The source code organization for big projects is always controversial. Different
    developers have different approaches to how to order the source code in order
    to keep the chaos away.
  prefs: []
  type: TYPE_NORMAL
- en: Some languages such as Java or C# organize the code in packages so that we can
    find source code files that are related inside a package. As an example, if we
    are writing a task manager software, inside the `com.taskmanager.dao` package
    we can expect to find classes that implement the **data access object** (**DAO**)
    pattern in order to access the database. In the same way, in the `com.taskmanager.dao.domain.model`
    package, we can find all the classes that represent model objects (usually tables)
    in our application.
  prefs: []
  type: TYPE_NORMAL
- en: This is a convention in Java and C#. If you are a C# developer, and you start
    working on an existing project, it only takes you a few days to get used to how
    the code is structured as the language enforces the organization of the source.
  prefs: []
  type: TYPE_NORMAL
- en: Javascript
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'JavaScript was first designed to be run inside the browser. The code was supposed
    to be embedded in HTML documents so that the **Document Object Model** (**DOM**)
    could be manipulated to create dynamic effects. Take a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, if you load this HTML on a browser, the text inside the `span`
    tag with the `id` as `world` is replaced when the page loads.
  prefs: []
  type: TYPE_NORMAL
- en: In JavaScript, there is no concept of dependency management. JavaScript can
    be segregated from the HTML into its own file, but there is no way (for now) to
    include a JavaScript file into another JavaScript file.
  prefs: []
  type: TYPE_NORMAL
- en: This leads to a big problem. When the project contains dozens of JavaScript
    files, the assets management become more of an art than an engineering effort.
  prefs: []
  type: TYPE_NORMAL
- en: 'The order in which you import the JavaScript files becomes important as the
    browser executes the JavaScript files as it finds them. Let''s reorder the code
    in the previous example to demonstrate it, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, save this HTML in an `index.html` file and try to load it in any browser,
    as shown in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Javascript](img/B04889_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In this case, I have used Chrome and the console shows an **Uncaught TypeError:
    Cannot set property ''innerText'' of null** error in line 7.'
  prefs: []
  type: TYPE_NORMAL
- en: Why is that happening?
  prefs: []
  type: TYPE_NORMAL
- en: As we explained earlier, the browser *executes* the code as it is found, and
    it turns out that when the browser executes the JavaScript, the `world` element
    does not exist yet.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, Node.js has solved the dependency-loading problem using a very
    elegant and standard approach.
  prefs: []
  type: TYPE_NORMAL
- en: SOLID design principles
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When talking about microservices, we always talk about modularity, and modularity
    always boils down to the following (**SOLID**) design principles:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Single** responsibility principle'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Open** for extension, closed for modification'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Liskov** substitution'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Interface** segregation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dependency** inversion (inversion of control and dependency injection)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You want your code to be organized in modules. A module is an aggregation of
    code that does something simple, such as manipulating strings, and it does it
    well. The more functions (or classes, utilities, and so on) your module contains,
    the less cohesive it is, and we are trying to avoid that.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Node.js, every JavaScript file is a module by default. We can also use folders
    as modules, but let''s focus on files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code represents a valid module in Node.js. In this case, the module
    contains three functions, where two of them are exposed to the outside of the
    module.
  prefs: []
  type: TYPE_NORMAL
- en: In Node.js, this is done through the `module.exports` variable. Whatever you
    assign to this variable is going to be visible by the calling code so that we
    can simulate private content on a module, such as the `charToNumber()` function
    in this case.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, if we want to use this module, we just need to `require()` it, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This should output `1122`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go back to the SOLID principles and see how our module looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Single responsibility principle**: Our module only deals with strings'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Open for extension, closed for modification**: We can add more functions,
    but the ones that we have are correct and they can be used to build new functions
    in the module'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Liskov substitution**: We will skip this one, as the structure of the module
    is irrelevant to fulfil this principle'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Interface segregation**: JavaScript is not a language that counts with an
    interface element such as Java or C#, but in this module, we exposed the interface,
    and the `module.exports` variable will act as a contract for the calling code
    and the change in our implementation won''t affect how the module is being called'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dependency inversion**: Here is where we fail, not fully, but enough to reconsider
    our approach'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this case, we require the module, and the only way to interact with it is
    through the global scope. If, inside the module, we want to interact with data
    from outside, the only possible option is to create a global variable (or function)
    prior to requiring the module, and then assume that it is always going to be in
    there.
  prefs: []
  type: TYPE_NORMAL
- en: Global variables are a big problem in Node.js. As you are probably aware, in
    JavaScript, if you omit the `var` keyword when declaring a variable, it is automatically
    global.
  prefs: []
  type: TYPE_NORMAL
- en: This, coupled with the fact that intentional global variables create a data
    coupling between modules (coupling is what we want to avoid at any cost), is the
    reason to find a better approach to how to define the modules for our microservices
    (or in general).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s restructure the code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This looks a bit more complicated, but once you get used to it, the benefits
    are enormous:'
  prefs: []
  type: TYPE_NORMAL
- en: We can pass configuration parameters to the module (such as debugging information)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoids the pollution of global scope as if everything is wrapped inside a function,
    and we enforce the *use strict* configuration (this avoids declarations without
    `var` with a compilation error)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parameterizing a module makes it easy to mock behaviors and data for testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this book, we are going to be writing a good amount of code to model systems
    from the microservices prospective. We will try to keep this pattern as much as
    we can so that we can see the benefits.
  prefs: []
  type: TYPE_NORMAL
- en: One of the library that we are going to be using to build microservices, Seneca,
    follows this pattern, as well as a large number of libraries that can be found
    on Internet.
  prefs: []
  type: TYPE_NORMAL
- en: Seneca – a microservices framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Seneca is a framework for building microservices written by Richard Rodger,
    the founder and CTO of nearForm, a consultancy that helps other companies design
    and implement software using Node.js. Seneca is about simplicity, it connects
    services through a sophisticated pattern-matching interface that abstracts the
    transport from the code so that it is fairly easy to write highly scalable software.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s stop talking and see some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the code is self-explanatory:'
  prefs: []
  type: TYPE_NORMAL
- en: Seneca comes as a module, so the first thing that needs to be done is to `require()`
    it. Seneca package is wrapped in a function, so invoking the function initializes
    the library.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next two instructions are related to a concept explained in [Chapter 1](ch01.html
    "Chapter 1. Microservices Architecture"), *Microservices Architecture*: API composition.
    The `seneca.add()` method instructs Seneca to add a function that will be invoked
    with a set of patterns. For the first one, we specify an action that will take
    place when Seneca receives the `{role: math, cmd: sum}` command. For the second
    one, the pattern is `{role: math, cmd: product}`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last line sends a command to Seneca that will be executed by the service
    that matches the pattern passed as the first parameter. In this case, it will
    match the first service as `role` and `cmd` match. The second call to act will
    match the second service.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Write the code in a file called `index.js` in the project that we created earlier
    in this chapter (remember that we installed Seneca and PM2), and run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be something similar to the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Seneca – a microservices framework](img/B04889_02_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We will talk about this output later in order to explain exactly what it means,
    but if you are used to enterprise applications, you can almost guess what is going
    on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last two lines are the responses from the two services: the first one executes
    `1+2` and the second one executes `3*4`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `null` output that shows up as the first word in the last two lines corresponds
    to a pattern that is widely used in JavaScript: the error first callback.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s explain it with a code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The previous code rewrites the first invocation to Seneca with a more appropriate
    approach. Instead of dumping everything into the console, process the response
    from Seneca, which is a callback where the first parameter is the error, if one
    happened (`null` otherwise), and the second parameter is the data coming back
    from the microservice. This is why, in the first example, `null` was the first
    output into the console.
  prefs: []
  type: TYPE_NORMAL
- en: In the world of Node.js, it is very common to use callbacks. Callbacks are a
    way of indicating to the program that something has happened, without being blocked
    until the result is ready to be processed. Seneca is not an exception to this.
    It relies heavily on callbacks to process the response to service calls, which
    makes more sense when you think about microservices being deployed in different
    machines (in the previous example, everything runs in the same machine), especially
    because the network latency can be something to factor into the design of your
    software.
  prefs: []
  type: TYPE_NORMAL
- en: Inversion of control done right
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Inversion of control is a must in modern software. It comes together with the
    dependency injection.
  prefs: []
  type: TYPE_NORMAL
- en: Inversion of control can be defined as *a technique to delegate the creation
    or call of components and methods so that your module does not need to know how
    to build the dependencies, which usually, are obtained through the dependency
    injection*.
  prefs: []
  type: TYPE_NORMAL
- en: Seneca does not really make use of the dependency injection, but it is the perfect
    example of inversion of control.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the most basic Seneca example. From enterprise software''s point of
    view, we can differentiate two components here: a producer (`Seneca.add()`) and
    a consumer (`Seneca.act()`). As mentioned earlier, Seneca does not have a dependency
    injection system as is, but Seneca is gracefully built around the inversion of
    control principle.'
  prefs: []
  type: TYPE_NORMAL
- en: In the `Seneca.act()` function, we don't explicitly call the component that
    holds the business logic; instead of that, we ask Seneca to resolve the component
    for us through the use of an interface, in this case, a JSON message. This is
    inversion of control.
  prefs: []
  type: TYPE_NORMAL
- en: 'Seneca is quite flexible around it: no keywords (except for integrations) and
    no mandatory fields. It just has a combination of keywords and values that are
    used by a pattern matching engine called **Patrun**.'
  prefs: []
  type: TYPE_NORMAL
- en: Pattern matching in Seneca
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Pattern matching is one of the most flexible software patterns that you can
    use for microservices.
  prefs: []
  type: TYPE_NORMAL
- en: 'As opposed to network addresses or messages, patterns are fairly easy to extend.
    Let''s explain it with the help of the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: It is a service that counts the number of words in a sentence. As we have seen
    before, in the first line, we add the handler for the `wordcount` command, and
    in the second one, we send a request to Seneca to count the number of words in
    a phrase.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you execute it, you should get something similar to the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Pattern matching in Seneca](img/B04889_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: By now, you should be able to understand how it works and even make some modifications
    to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s extend the pattern. Now, we want to skip the short words, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we have added another handler for the `wordcount` command with
    an extra `skipShort` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'This handler now skips all the words with three or fewer characters. If you
    execute the preceding code, the output is similar to the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Pattern matching in Seneca](img/B04889_02_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The first line, `{words: 5}`, corresponds to the first act call. The second
    line, `{words: 4}`, corresponds to the second call.'
  prefs: []
  type: TYPE_NORMAL
- en: Patrun – a pattern-matching library
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Patrun is also written by Richard Rodger. It is used by Seneca in order to execute
    the pattern matching and decide which service should respond to the call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Patrun uses a **closest** **match** approach to resolve the calls. Let''s see
    the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Patrun – a pattern-matching library](img/B04889_02_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding image, we can see three patterns. These are equivalent to `seneca.add()`
    from the example in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, we are registering three different combinations of *x* and *y*
    variables. Now, let''s see how Patrun does the matching:'
  prefs: []
  type: TYPE_NORMAL
- en: '`{x: 1} ->A`: This matches 100% with **A**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`{x: 2} ->`: No match'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`{x:1, y:1} -> B`: 100% match with **B**; it also matches with **A**, but **B**
    is a better match—two out of two vs one out of one'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`{x:1, y:2} -> C`: 100% match with **C**; again, it also matches with **A**,
    but **C** is more concrete'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`{y: 1} ->`: No match'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, Patrun (and Seneca) will always get the longest match. In this
    way, we can easily extend the functionality of the more abstract patterns by concreting
    the matching.
  prefs: []
  type: TYPE_NORMAL
- en: Reusing patterns
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the preceding example, in order to skip the words with fewer than three characters,
    we don't reuse the word count function.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, it is quite hard to reuse the function as is; although the problem
    sounds very similar, the solution barely overlaps.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, let''s go back to the example where we add two numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the code has changed a bit. Now, the pattern that accepts an
    integer relies on the base pattern to calculate the sum of the numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Patrun always tries to match the closest and most concrete pattern that it
    can find with the following two dimensions:'
  prefs: []
  type: TYPE_NORMAL
- en: The longest chain of matches
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The order of the patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It will always try to find the best fit, and if there is an ambiguity, it will
    match the first pattern found.
  prefs: []
  type: TYPE_NORMAL
- en: In this way, we can rely on already-existing patterns to build new services.
  prefs: []
  type: TYPE_NORMAL
- en: Writing plugins
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Plugins are an important part of applications based on Seneca. As we discussed
    in [Chapter 1](ch01.html "Chapter 1. Microservices Architecture"), *Microservices
    Architecture*, the API aggregation is the perfect way of building applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Node.js'' most popular frameworks are built around this concept: small pieces
    of software that are combined to create a bigger system.'
  prefs: []
  type: TYPE_NORMAL
- en: Seneca is also built around this; `Seneca.add()` principle adds a new piece
    to the puzzle so that the final API is a mixture of different small software pieces.
  prefs: []
  type: TYPE_NORMAL
- en: Seneca goes one step further and implements an interesting plugin system so
    that the common functionality can be modularized and abstracted into reusable
    components.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example is the minimal Seneca plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Write the code into a `minimal-plugin.js` file and execute it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this execution should be something similar to the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Writing plugins](img/B04889_02_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In Seneca, a plugin is loaded at the startup, but we don''t see it as the default
    log level is INFO. This means that Seneca won''t show any DEBUG level info. In
    order to see what Seneca is doing, we need to get more information, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This produces a huge output. This is pretty much everything that is happening
    inside Seneca, which can be very useful to debug complicated situations, but in
    this case, what we want to do is show a list of plugins:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'It will produce something similar to the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Writing plugins](img/B04889_02_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s analyze the preceding output:'
  prefs: []
  type: TYPE_NORMAL
- en: '`basic`: This plugin is included with the main Seneca module and provides a
    small set of basic utility action patterns.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`transport`: This is the transport plugin. Up until now, we have only executed
    different services (quite small and concise) on the same machine, but what if
    we want to distribute them? This plugin will help us with that, and we will see
    how to do so in the following sections.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`web`: In [Chapter 1](ch01.html "Chapter 1. Microservices Architecture"), *Microservices
    Architecture*, we mentioned that the microservices should advocate to keep the
    pipes that connect them under a standard that is widely used. Seneca uses TCP
    by default, but creating a RESTful API can be tricky. This plugin helps to do
    it, and we will see how to do this in the following section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mem-store`: Seneca comes with a data abstraction layer so that we can handle
    the data storage in different places: Mongo, SQL databases, and so on. Out of
    the box, Seneca provides an in-memory storage so that it just works.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`minimal_plugin`: This is our plugin. So, now we know that Seneca is able to
    load it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The plugin we wrote does nothing. Now, it is time to write something useful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: First of all, notice that in the last instruction, `act()` follows a different
    format. Instead of passing a dictionary, we pass a string with the same key values
    as the first argument, as we did with a dictionary. There is nothing wrong with
    it, but my preferred approach is to use the JSON objects (dictionaries), as it
    is a way of structuring the data without having syntax problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous example, we can see how the code got structured as a plugin.
    If we execute it, we can see that the output is similar to the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Writing plugins](img/B04889_02_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: One of the things you need to be careful about in Seneca is how to initialize
    your plugins. The function that wraps the plugin (in the preceding example, the
    `math()` function) is executed synchronously by design and it is called the **definition
    function**. If you remember from the previous chapter, Node.js apps are single-threaded.
  prefs: []
  type: TYPE_NORMAL
- en: To initialize a plugin, you add a special `init()` action pattern. This action
    pattern is called in sequence for each plugin. The `init()` function must call
    its respond callback without errors. If the plugin initialization fails, then
    Seneca exits the Node.js process. You want your microservices to fail fast (and
    scream loudly) when there's a problem. All plugins must complete initialization
    before any actions are executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see an example of how to initialize a plugin in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, after executing this file, the output should look very similar to the
    following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Writing plugins](img/B04889_02_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can read from the output, the function that initializes the plugin was
    called.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The general rule in Node.js apps is to never block the thread. If you find yourself
    blocking the thread, you might need to rethink how to avoid it.
  prefs: []
  type: TYPE_NORMAL
- en: Web server integration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In [Chapter 1](ch01.html "Chapter 1. Microservices Architecture"), *Microservices
    Architecture*, we put a special emphasis on using standard technologies to communicate
    with your microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Seneca, by default, uses a TCP transport layer that, although it uses TCP, is
    not easy to interact with, as the criteria to decide the method that gets executed
    is based on a payload sent from the client.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s dive into the most common use case: your service is called by JavaScript
    on a browser. Although it can be done, it would be much easier if Seneca exposed
    a REST API instead of the JSON dialog, which is perfect for communication between
    microservices (unless you have ultra-low latency requirements).'
  prefs: []
  type: TYPE_NORMAL
- en: Seneca is not a web framework. It can be defined as a *general purpose microservices
    framework*, so it would not make too much sense to build it around a concrete
    case like the one exposed before.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of that, Seneca was built in a way that makes the integration with other
    frameworks fairly easy.
  prefs: []
  type: TYPE_NORMAL
- en: '**Express** is the first option when building web applications on Node.js.
    The amount of examples and documentation that can be found on Internet about Express
    makes the task of learning it fairly easy.'
  prefs: []
  type: TYPE_NORMAL
- en: Seneca as Express middleware
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Express was also built under the principle of API composition. Every piece of
    software in Express is called middleware, and they are chained in the code in
    order to process every request.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we are going to use **seneca-web** as a middleware for Express
    so that once we specify the configuration, all the URLs will follow a naming convention.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This code is not as easy to understand as the previous examples, but I''ll
    do my best to explain it:'
  prefs: []
  type: TYPE_NORMAL
- en: The second line adds a pattern to Seneca. We are pretty familiar with it as
    all the examples on this book do that.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third instruction, `seneca.act()`, is where the magic happens. We are mounting
    the patterns with the `role:api` pattern and any cmd pattern (`cmd:*`) to react
    to URLs under `/my-api`. In this example, the first `seneca.add()` will reply
    to the URL `/my-api/bazinga`, as `/my-api/` is specified by the `prefix` variable
    and `bazinga` by the `cmd` part of the `seneca.add()` command.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`app.use(seneca.export(''web''))` instructs Express to use seneca-web as middleware
    to execute actions based on the configuration rules.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`app.listen(3000)` binds the port `3000` to Express.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you remember from an earlier section in this chapter, `seneca.act()` takes
    a function as a second parameter. In this case, we are exposing configuration
    to be used by Express on how to map the incoming requests to Seneca actions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s test it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Seneca as Express middleware](img/B04889_02_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The preceding code is pretty dense, so let''s explain it down to the code from
    the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: Express receives a request that is handled by seneca-web.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The seneca-web plugin was configured to use `/my-api/` as a prefix, which is
    being bound with the keyword `pin` (refer to `seneca.act()` from the preceding
    code) to Seneca actions (`seneca.add()`) that contain the `role:api` pattern,
    plus any cmd pattern (`cmd:*`). In this case, `/my-api/bazinga` corresponds to
    the first (and only) `seneca.add()` command with the `{role: ''api'', cmd: ''bazinga''}`
    pattern.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It takes a while to fully understand the integration between Seneca and Express,
    but once it is clear, the flexibility offered by the API composability pattern
    is limitless.
  prefs: []
  type: TYPE_NORMAL
- en: Express itself is big enough to be out of the scope of this book, but it is
    worth taking a look as it is a very popular framework.
  prefs: []
  type: TYPE_NORMAL
- en: Data storage
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Seneca comes with a data-abstraction layer that allows you to interact with
    the data of your application in a generic way.
  prefs: []
  type: TYPE_NORMAL
- en: By default, Seneca comes with an in-memory plugin (as explained in the previous
    section), therefore, it works out of the box.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to be using it for the majority of this book, as the different
    storage systems are completely out of scope and Seneca abstracts us from them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Seneca provides a simple data abstraction layer (**Object-relational mapping**
    (**ORM**)) based on the following operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '**load**: This loads an entity by identifier'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**save**: This creates or updates (if you provide an identifier) an entity'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**list**: This lists entities matching a simple query'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**remove**: This deletes an entity by an identifier'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s build a plugin that manages employees in the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Remember that the database is, by default, in memory, so we don't need to worry
    about the table structure for now.
  prefs: []
  type: TYPE_NORMAL
- en: The first command adds an employee to the database. The second command recovers
    an employee from the database by `id`.
  prefs: []
  type: TYPE_NORMAL
- en: Note that all the ORM primitives in Seneca end up with the dollar symbol (`$`).
  prefs: []
  type: TYPE_NORMAL
- en: As you can see now, we have been abstracted from the data storage details. If
    the application changes in the future and we decide to use MongoDB as a data storage
    instead of an in-memory storage, the only thing we need to take care of is the
    plugin that deals with MongoDB.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use our employee management plugin, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we add an employee to the in-memory database by invoking
    the pattern exposed in the plugin.
  prefs: []
  type: TYPE_NORMAL
- en: Along the book, we will see different examples about how to use the data abstraction
    layer, but the main focus will be on how to build microservices and not how to
    deal with the different data storages.
  prefs: []
  type: TYPE_NORMAL
- en: PM2 – a task runner for Node.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**PM2** is a production-process manager that helps to scale the Node.js up
    or down, as well as load balance the instances of the server. It also ensures
    that the processes are running constantly, tackling down one of the side effects
    of the thread model of Node.js: an uncaught exception kills the thread, which
    in turn kills your application.'
  prefs: []
  type: TYPE_NORMAL
- en: Single-threaded applications and exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you learned before, Node.js applications are run in a single thread. This
    doesn't mean that Node.js is not concurrent, it only means that your application
    runs on a single thread, but everything else runs parallel.
  prefs: []
  type: TYPE_NORMAL
- en: 'This has an implication: *if an exception bubbles out without being handled,
    your application dies*.'
  prefs: []
  type: TYPE_NORMAL
- en: The solution for this is making an intensive use of promises libraries such
    as **bluebird**; it adds handlers for success and failures so that if there is
    an error, the exception does not bubble out, killing your app.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there are some situations that we can''t control, *we call them unrecoverable
    errors or bugs*. Eventually, your application will die due to a badly handled
    error. In languages such as Java, an exception is not a huge deal: the thread
    dies, but the application continues working.'
  prefs: []
  type: TYPE_NORMAL
- en: In Node.js, it is a big problem. This problem was solved in the first instance
    using task runners such as **forever**.
  prefs: []
  type: TYPE_NORMAL
- en: Both of them are task runners that, when your application exits for some reason,
    rerun it again so it ensures the uptime.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Single-threaded applications and exceptions](img/B04889_02_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `helloWorld.js` application is now handled by forever, which will rerun
    it if the application dies. Let''s kill it, as shown in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Single-threaded applications and exceptions](img/B04889_02_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, forever has spawned a different process with the `4903` PID.
    Now, we issue a kill command (`kill -9 4093`) and that is the output from forever,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Single-threaded applications and exceptions](img/B04889_02_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Although we have killed it, our application was respawned by forever without
    any downtime (at least, noticeable downtime).
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, forever is pretty basic: it reruns the application as many
    times as it gets killed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is another package called **nodemon**, which is one of the most useful
    tools for developing Node.js applications. It reloads the application if it detects
    changes in the files that it monitors (by default, `*.*`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Single-threaded applications and exceptions](img/B04889_02_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now, if we modify the `helloWorld.js` file, we can see how nodemon reloads the
    application. This is very interesting in order to avoid the edit/reload cycle
    and speed up the development.
  prefs: []
  type: TYPE_NORMAL
- en: Using PM2 – the industry-standard task runner
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although, forever looks very interesting, PM2 is a more advanced task runner
    than forever. With PM2, you can completely manage your application life cycle
    without any downtime, as well as scale your application up or down with a simple
    command.
  prefs: []
  type: TYPE_NORMAL
- en: PM2 also acts as a load balancer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a fairly simple application. Let''s run it using PM2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This produces an output similar to the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using PM2 – the industry-standard task runner](img/B04889_02_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: PM2 has registered an app named `helloWorld`. This app is running in the `fork`
    mode (that means, PM2 is not acting as a load balancer, it has just forked the
    app) and the PID of the operating system is `6858`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, as the following screen suggests, we will run `pm2 show 0`, which shows
    the information relevant to the app with `id 0`, as shown in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using PM2 – the industry-standard task runner](img/B04889_02_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: With two commands, we have managed to run a simple application in a very sophisticated
    way.
  prefs: []
  type: TYPE_NORMAL
- en: From now on, PM2 will ensure that your app is always running so that if your
    application dies, PM2 will restart it again.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also monitor the number of apps PM2 is running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'This shows the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using PM2 – the industry-standard task runner](img/B04889_02_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is the PM2 monitor. In this case, it is a complete overkill as our system
    is only composed of one application, which runs in the fork mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also see the logs executing `pm2 logs` as shown in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using PM2 – the industry-standard task runner](img/B04889_02_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, PM2 feels solid. With few commands, we have covered 90% of the
    monitoring necessities of our application. However, this is not everything.
  prefs: []
  type: TYPE_NORMAL
- en: 'PM2 also comes with an easy way to reload your applications without downtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This command ensures that your apps are restarted with zero downtime. PM2 will
    queue the incoming requests for you and reprocess them once your app is responsive
    again. There is a more fine-grained option where you can specify reloading only
    certain apps by specifying the app name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: For those who have been fighting for years with Apache, NGINX, PHP-FPM, and
    so on, this will sound very familiar.
  prefs: []
  type: TYPE_NORMAL
- en: Another interesting feature in PM2 is running your application in the cluster
    mode. In this mode, PM2 spawns a controller process and as many workers (your
    app) as you specify so that you can take the benefit of multicore CPUs with a
    single-thread technology such as Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before doing this, we need to stop our running application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This will result in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using PM2 – the industry-standard task runner](img/B04889_02_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'PM2 remembers the apps that were running, so before rerunning the app in the
    cluster mode, we need to inform PM2 to forget about your app, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '![Using PM2 – the industry-standard task runner](img/B04889_02_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We are ready to run our app in the cluster mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '![Using PM2 – the industry-standard task runner](img/B04889_02_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'PM2 is acting as a round-robin between the main process and the three workers
    so that they can cope with three requests at the same time. We can also scale
    down or up our number of workers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'This will result in two processes being run for the same app instead of three:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using PM2 – the industry-standard task runner](img/B04889_02_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, with very little effort, we have managed to configure our app
    in order to be production ready.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can save the status of PM2 so that if we restart the server, and PM2
    is running as a daemon, the apps will automatically start.
  prefs: []
  type: TYPE_NORMAL
- en: PM2 has a code API so that we can write a Node.js program to manage all the
    steps that we have been manually doing. It also has a way of configuring your
    services with a JSON file. We will discuss this in more depth in [Chapter 6](ch06.html
    "Chapter 6. Testing and Documenting Node.js Microservices"), *Testing and Documenting
    Node.js Microservices*, when we study how to use PM2 and Docker to deploy Node.js
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned the basics of Seneca and PM2 so that we will be
    able to build and run a microservices-oriented system in [Chapter 4](ch04.html
    "Chapter 4. Writing Your First Microservice in Node.js"), *Writing Your First
    Microservice in Node.js*, of this book.
  prefs: []
  type: TYPE_NORMAL
- en: We have also demonstrated that a few of the concepts exposed in the previous
    chapter are actually helpful in solving real-world problems as well as making
    our life very easy.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will talk about how to split a monolithic application,
    a task for which we will need to know a few of the concepts developed during this
    chapter.
  prefs: []
  type: TYPE_NORMAL
