- en: '21'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Challenges of Applying CI Scenarios
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Continuous Integration** (**CI**) is sometimes stated as a prerequisite for
    DevOps. In the previous chapter, we discussed the basics of CI and how DevOps
    depends on it. Its implementation was presented in *Chapter 20*, *Understanding
    DevOps Principles*, too. But differently from the other practical chapters, the
    purpose of this chapter is to discuss how to enable CI in a real scenario, considering
    the challenges that you, as a software architect, will need to deal with.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics covered in this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding CI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Continuous Integration and GitHub
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the risks and challenges when using CI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the WWTravelClub project approach for this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Like in the previous chapter, the sample of the WWTravelClub will be presented
    during the explanation of the chapter, since all the screens captured to exemplify
    CI came from it. Besides this, we will offer a conclusion at the end of the chapter
    so you can understand CI principles easily.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of the chapter, you will be able to decide whether to use CI in your
    project environment. Additionally, you will be able to define the tools needed
    for the successful use of this approach.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter requires Visual Studio 2019 Community edition or better. You may
    also need an Azure DevOps account, as described in *Chapter 3*, *Documenting Requirements
    with Azure DevOps*. You can find the sample code for the chapter at [https://github.com/PacktPublishing/Software-Architecture-with-C-9-and-.NET-5](https://github.com/PacktPublishing/Software-Architecture-with-C-9-and-.NET-5).
  prefs: []
  type: TYPE_NORMAL
- en: Understanding CI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As soon as you start working with a platform such as Azure DevOps, enabling
    CI will definitely be easy when it comes to clicking on the options for doing
    so, as we saw in *Chapter 20*, *Understanding DevOps Principles*. So, technology
    is not the Achilles' heel for implementing this process.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows an example of how easy it is to turn on CI using
    Azure DevOps. By clicking in the build pipeline and editing it, you will be able
    to set a trigger that enables CI after some clicks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16756_21_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 21.1: Enabling Continuous Integration trigger'
  prefs: []
  type: TYPE_NORMAL
- en: The truth is that CI will help you solve some problems. For instance, it will
    force you to test your code, since you will need to commit the changes faster,
    so other developers can make use of the code you are programming.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, you will not do CI just by enabling a CI build in Azure DevOps.
    For sure, you will turn on the possibility of starting a build as soon as you
    get a commit done and the code is done, but this is far from saying you have CI
    available in your solution.
  prefs: []
  type: TYPE_NORMAL
- en: The reason why you as a software architect need to worry a bit more about it
    is related to a real understanding of what DevOps is. As discussed in *Chapter
    20*, *Understanding DevOps Principles*, the need to deliver value to the end user
    will always be a good way to decide on and draw the development life cycle. So,
    even if turning on CI is easy, what is the real business impact of this feature
    being enabled for your end user? Once you have all the answers to this question
    and you know how to reduce the risks of its implementation, then you will be able
    to say that you have a CI process implemented.
  prefs: []
  type: TYPE_NORMAL
- en: It is worth mentioning that CI is a principle that will make DevOps work better
    and faster, as was discussed in *Chapter 20*, *Understanding DevOps Principles*.
    However, DevOps surely can live without it, once you are not sure if your process
    is mature enough to enable code being continuously delivered. More than that,
    if you turn on CI in a team that is not mature enough to deal with its complexity,
    you will probably cause a bad understanding of DevOps, since you will start incurring
    some risks while deploying your solution. The point is, CI is not a prerequisite
    for DevOps. When you have CI enabled, you can make things faster in DevOps. However,
    you can practice DevOps without it.
  prefs: []
  type: TYPE_NORMAL
- en: This is the reason why we are dedicating an extra chapter to CI. As a software
    architect, you need to understand the key points of having CI switched on. But,
    before we check this out, let's learn another tool that can help us out with continuous
    integration – GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous Integration and GitHub
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since GitHub's acquisition by Microsoft, many features have evolved and new
    options have been delivered, enhancing the power of this powerful tool. This integration
    can be checked using the Azure portal, and particularly using GitHub Actions.
  prefs: []
  type: TYPE_NORMAL
- en: 'GitHub Actions is a set of tools that helps with the automation of software
    development. It enables a fast CI/**Continuous Deployment** (**CD**) service on
    any platform, having YAML files to define its workflows. You can consider GitHub
    Actions as an alternative to Azure DevOps Pipelines. However, it is worth mentioning
    that you can automate any GitHub event using GitHub Actions, having thousands
    of actions available at GitHub Marketplace:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16756_21_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 21.2: GitHub Actions'
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating a workflow to build a .NET Core Web App is quite simple via the GitHub Actions
    interface. As you can see in the preceding screenshot, there are some workflows
    already created, to help us out. The YAML we have below was generated by clicking
    the **Set up this workflow** option under **.NET Core**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: With the adaptations made below, it was able to build the application specific
    created for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see below, once the script is updated, it is possible to check the
    result of the workflow. It is also possible to enable Continuous Deployment if
    you want to. It is just a matter of defining the correct script:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16756_21_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 21.3: Simple application compilation using GitHub Actions'
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft provides documentation specifically to present Azure and GitHub integration.
    Check this out at [https://docs.microsoft.com/en-us/azure/developer/github](https://docs.microsoft.com/en-us/azure/developer/github).
  prefs: []
  type: TYPE_NORMAL
- en: As a software architect, you need to understand which tool best fits your development
    team. Azure DevOps has a wonderful environment for enabling continuous integration,
    so does GitHub. The key point here is that no matter the option you decide upon,
    there are risks and challenges that you will face once CI is enabled. Let us check
    them out in the next topic.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the risks and challenges when using CI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, you may be thinking about the risks and challenges as a way for you to
    avoid using CI. But why should we avoid using it if it will help you create a
    better DevOps process? This is not the purpose of the chapter. The idea of this
    section is to help you, as a software architect, to mitigate the risks and find
    a better way to pass through the challenges using good processes and techniques.
  prefs: []
  type: TYPE_NORMAL
- en: 'The list of risks and challenges that will be discussed in this section are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Continuous production deployment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Incomplete features in production
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unstable solutions for testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once you have the techniques and the processes defined to deal with them, there
    is no reason to not use CI. It is worth mentioning that DevOps does not depend
    on CI. However, it does make DevOps work more smoothly. Now, let us have a look
    at them.
  prefs: []
  type: TYPE_NORMAL
- en: Disabling continuous production deployment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Continuous production deployment is a process where, after a commit of a new
    piece of code and some pipeline steps, you will have this code in the **production**
    environment. This is not impossible but is hard and expensive to do. Besides,
    you need to have a mature team to enable it. The problem is that most of the demos
    and samples you will find on the internet presenting CI will show you a fast track
    to deploy the code. The demonstrations of CI/CD look so simple and easy to do!
    This *simplicity* can suggest that you should work as soon as possible on its
    implementation. However, if you think a little more, this scenario can be dangerous
    if you deploy directly into production! In a solution that needs to be available
    24 hours a day, 7 days a week, this is impractical. So, you will need to worry
    about that and think of different solutions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first one is the use of a multi-stage scenario, as described in *Chapter
    20*, *Understanding DevOps Principles*. The multi-stage scenario can bring more
    security to the ecosystem of the deployment you are building. Besides, you will
    get more options to avoid incorrect deployments into production, such as pre-deployment
    approvals:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16756_21_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 21.4: Multi-stage scenario for production environment security'
  prefs: []
  type: TYPE_NORMAL
- en: It is worth mentioning, too, that you can build a deployment pipeline where
    all your code and software structure will be updated by this tool. However, if
    you have something outside of this scenario, such as database scripts and environment
    configurations, an incorrect publication into production may cause damage to end
    users. Besides, the decision of when the production environment will be updated
    needs to be planned and, in many scenarios, all the platform users need to be
    notified of the upcoming change. Use a *change management* procedure in these
    hard-to-decide cases.
  prefs: []
  type: TYPE_NORMAL
- en: So, the challenge of delivering code to production will make you think about
    a schedule to do so. It does not matter if your cycle is monthly, daily, or even
    at each commit. The key point here is that you need to create a process and a
    pipeline that guarantees that only good and approved software is at the production
    stage. It is worth noting, however, that the longer you leave deployments, the
    scarier they are as the deviation between the previously deployed version and
    the new one will be greater, and more changes will be pushed out in one go. The
    more frequently you can manage this, the better.
  prefs: []
  type: TYPE_NORMAL
- en: Incomplete features
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While a developer of your team is creating a new feature or fixing a bug, you
    will probably consider generating a branch that can avoid the use of the branch
    designed for continuous delivery. A branch can be considered a feature available
    in code repositories to enable the creation of an independent line of development
    since it isolates the code. As you can see in the following screenshot, creating
    a branch using Visual Studio is quite simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16756_21_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 21.5: Creating a branch in Visual Studio'
  prefs: []
  type: TYPE_NORMAL
- en: This seems to be a good approach but let us suppose that the developer has considered
    the implementation ready for deploying and has just merged the code into the master
    branch. What if this feature is not ready yet, just because a requirement was
    omitted? What if the bug has caused incorrect behavior? The result could be a
    release with an incomplete feature or an incorrect fix.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the good practices to avoid broken features and even incorrect fixes
    in the master branch is the use of pull requests. Pull requests will let other
    team developers know that the code you developed is ready to be merged. The following
    screenshot shows how you can use Azure DevOps to create a **New Pull Request**
    for a change you have made:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16756_21_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 21.6: Creating a pull request'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the pull request is created and the reviewers are defined, each reviewer
    will be able to analyze the code and decide whether this code is healthy enough
    to be in the master branch. The following screenshot shows a way to check it by
    using the compare tool to analyze the change:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16756_21_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 21.7: Analyzing the pull request'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once all approvals are done, you will be able to safely merge the code to the
    master branch, as you can see in the following screenshot. To merge the code,
    you will need to click on **Complete merge**. If the CI trigger is enabled, as
    shown earlier in the chapter, Azure DevOps will start a build pipeline:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16756_21_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 21.8: Merging the pull request'
  prefs: []
  type: TYPE_NORMAL
- en: There is no way to argue with the fact that without a process like this, the
    master branch will suffer from a lot of bad code being deployed that could cause
    damage together with CD. It is worth mentioning that code review is an excellent
    practice in CI/CD scenarios, and it is considered a wonderful practice for creating
    good quality software as well.
  prefs: []
  type: TYPE_NORMAL
- en: The challenge that you need to focus on here is guaranteeing that only entire
    features will appear to your end users. You may use the feature flag principle
    to solve this, which is a technique that makes sure only features that are ready
    are presented to end users. Again, we are not talking about CI as a tool but as
    a process to be defined and used every single time you need to deliver code for
    production.
  prefs: []
  type: TYPE_NORMAL
- en: It is worth mentioning that for controlling feature availability in an environment,
    feature flags are much safer than using branching/pull requests. Both have their
    place but pull requests are about controlling the quality of code at the CI stage,
    and feature flags are for controlling feature availability at the CD stage.
  prefs: []
  type: TYPE_NORMAL
- en: An unstable solution for testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Considering that you have already mitigated the two other risks presented in
    this topic, you may find it uncommon to have bad code after CI. It is true that
    the worries presented earlier will certainly be lessened since you are working
    with a multi-stage scenario and pull requests before pushing to the first stage.
  prefs: []
  type: TYPE_NORMAL
- en: But is there a way to accelerate the evaluation of release, being sure that
    this new release is ready for your stakeholder's tests? Yes, there is! Technically,
    the way you can do so is described in the use cases of *Chapter 18*, *Testing
    Your Code with Unit Test Cases and TDD*, and *Chapter 22*, *Automation for Functional
    Tests*.
  prefs: []
  type: TYPE_NORMAL
- en: As discussed in both those chapters, it is impracticable to automate every single
    part of the software, considering the efforts needed to do so. Besides, the maintenance
    of automation can be more expensive in scenarios where the user interface or the
    business rules change a lot. Although this is a tough decision, as a software
    architect, you must always incentivize the usage of automated testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'To exemplify it, let us have a look at the following screenshot, which shows
    the unit and functional tests samples of WWTravelClub, created by an Azure DevOps
    project template:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16756_21_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 21.9: Unit and functional tests projects'
  prefs: []
  type: TYPE_NORMAL
- en: There are some architectural patterns, such as SOLID, presented in *Chapter
    11*, *Design Patterns and .NET 5 Implementation*, and quality assurance approaches,
    such as peer review, that will give you better results than software testing.
  prefs: []
  type: TYPE_NORMAL
- en: However, these approaches do not invalidate automation practice. The truth is
    that all of them will be useful for getting a stable solution, especially when
    you are running a CI scenario. In this environment, the best thing you can do
    is to detect errors and wrong behaviors as fast as you can. Both unit and functional
    tests, as shown earlier, will help you with this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unit tests will help you a lot while discovering business logic errors before
    deployment, during the build pipeline. For instance, in the following screenshot,
    you will find a simulated error that canceled the build since the unit test did
    not pass:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16756_21_10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 21.10: Unit tests result'
  prefs: []
  type: TYPE_NORMAL
- en: The way to get this error is quite simple. You need to code something that does
    not respond according to what the unit tests are checking. Once you commit it,
    considering you have the trigger of continuous deployment on, you will have the
    code building in the pipeline. One of the last steps provided by the Azure DevOps
    Project Wizard we have created is the execution of the unit tests. So, after the
    build of the code, the unit tests will run. If the code does not match the tests
    anymore, you will get an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Meanwhile, the following screenshot shows an error during the functional tests
    in the **Development/Tests** stage. At this moment, the **Development/Tests**
    environment has a bug that was rapidly detected by functional tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16756_21_11.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 21.11: Functional tests result'
  prefs: []
  type: TYPE_NORMAL
- en: 'But this is not the only good thing about applying functional tests in the
    process of CI/CD, once you have protected other deployment stages with this approach.
    For instance, let us look at the following screenshot from the **Releases** pipeline
    interface in Azure DevOps. If you look at **Release-9**, you will realize that
    since this error happened after the publication in the **Development/Tests** environment,
    the multi-staged environment will protect the other stages of the deployment:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16756_21_12.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 21.12: Multi-staged environment protection'
  prefs: []
  type: TYPE_NORMAL
- en: The key point for success in the CI process is to think about it as a useful
    tool for accelerating the delivery of software and to not forget that a team always
    needs to deliver value to their end users. With this approach, the techniques
    presented earlier will provide incredible ways to achieve the results that your
    team aims for.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the WWTravelClub project approach
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the chapter, WWTravelClub project screenshots were presented, exemplifying
    the steps for adopting a safer approach while enabling CI. Even considering WWTravelClub
    as a hypothetical scenario, some concerns were considered while building it:'
  prefs: []
  type: TYPE_NORMAL
- en: CI is enabled but a multi-stage scenario is enabled too.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Even with a multi-stage scenario, the pull request is a way to guarantee that
    only good-quality code will be presented in the first stage.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To do a good job in the pull request, peer reviews are undertaken.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The peer reviews check, for instance, the presence of a feature flag while creating
    a new feature.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The peer reviews check both unit and functional tests developed during the creation
    of the new feature.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The preceding steps are not exclusively for WWTravelClub. You, as a software
    architect, will need to define the approach to guarantee a safe CI scenario. You
    may use this as a starting point.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covered the importance of understanding when you can enable CI
    in the software development life cycle, considering the risks and challenges you
    will take as a software architect once you decide to use it for your solution.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, the chapter introduced some solutions and concepts that can make
    this process easier, such as multi-stage environments, pull request reviews, feature
    flags, peer reviews, and automated tests. Understanding these techniques and processes
    will enable you to guide your project toward safer behavior when it comes to CI
    in a DevOps scenario.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will see how automation for software testing works.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is CI?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can you have DevOps without CI?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the risks of enabling CI in a non-mature team?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can a multi-stage environment help CI?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can automated tests help CI?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can pull requests help CI?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do pull requests only work with CI?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These are some websites where you will find more information on the topics
    covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Official Microsoft Documentation about CI/CD:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://azure.microsoft.com/en-us/solutions/architecture/azure-devops-continuous-integration-and-continuous-deployment-for-azure-web-apps/](https://azure.microsoft.com/en-us/solutions/architecture/azure-devops-continuous-integration-and-con)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/azure/devops-project/azure-devops-project-github](https://docs.microsoft.com/en-us/azure/devops-project/azure-devops-project-github)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/aspnet/core/azure/devops/cicd](https://docs.microsoft.com/en-us/aspnet/core/azure/devops/cicd)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/azure/devops/repos/git/pullrequest](https://docs.microsoft.com/en-us/azure/devops/repos/git/pullrequest)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Azure and GitHub integration:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/azure/developer/github](https://docs.microsoft.com/en-us/azure/developer/github)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Great Packt material about DevOps:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.packtpub.com/virtualization-and-cloud/professional-microsoft-azure-devops-engineering](https://www.packtpub.com/virtualization-and-cloud/professional-microsoft-azure-devops-engineering)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.packtpub.com/virtualization-and-cloud/hands-devops-azure-video](https://www.packtpub.com/virtualization-and-cloud/hands-devops-azure-video)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.packtpub.com/networking-and-servers/implementing-devops-microsoft-azure](https://www.packtpub.com/networking-and-servers/implementing-devops-microsoft-azure
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some new information about Azure Pipelines:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://devblogs.microsoft.com/devops/whats-new-with-azure-pipelines/](https://devblogs.microsoft.com/devops/whats-new-with-azure-pipelines/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Explanation about Feature Flags:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://martinfowler.com/bliki/FeatureToggle.html](https://martinfowler.com/bliki/FeatureToggle.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
