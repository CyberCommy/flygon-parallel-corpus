- en: '*Chapter 13*: Implementing Inverse Kinematics'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Inverse Kinematics** (**IK**) is the process of solving how a set of joints
    should be oriented to reach a specified point in world space. For example, you
    could specify a point for a character to touch. By using IK, you can figure out
    how to rotate the character''s shoulder, elbow, and wrist in a way that the character''s
    finger is always touching a specific point.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two algorithms commonly used for IK, that is, CCD and FABRIK. Both
    will be covered in this chapter. By the end of this chapter, you should be able
    to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Understand how CCD IK works
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement a CCD solver
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand how FABRIK works
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement a FABRIK solver
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement ball-and-socket constraints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement hinge constraints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand where and how IK solvers fit into an animation pipeline
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a CCD solver
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you will learn about and implement the CCD IK algorithm. **CCD**
    stands for **Cyclic Coordinate Descent**. This algorithm can be used to pose a
    chain of joints in a way that the last joint on the chain comes as close as possible
    to touching a target. You will be able to use CCD to create limb and other IK
    systems where a chain needs to be solved using a target point.
  prefs: []
  type: TYPE_NORMAL
- en: There are three important concepts for CCD. First, there is the **goal**, the
    point in space you are trying to touch. Next is the **IK chain**, which is a list
    of all of the joints that will need to rotate to reach the goal. Finally, there
    is the **end effector**, which is the last joint in the chain (the one that needs
    to touch the goal).
  prefs: []
  type: TYPE_NORMAL
- en: 'With a goal, chain, and end effector, the CCD algorithm in pseudocode looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The CCD algorithm looks simple but how does it work? Start with the joint right
    before the effector. Rotating the effector would have no effect on the chain.
    Find a vector from the joint before the effector to the target, and then a vector
    from the joint to the effector. Rotate the joint in question so that the two vectors
    line up. Repeat for each joint until the base joint:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_13.1_B16191.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 13.1: Visualizing the CCD algorithm'
  prefs: []
  type: TYPE_NORMAL
- en: Looking at *Figure 13.1*, the end effector does not touch the target. Why not?
    CCD is an iterative algorithm and the preceding steps describe one iteration.
    Multiple iterations per frame are needed to achieve convergence. In the following
    sections, we will learn how to declare the CCD solver, which will lead us to the
    implementation of the `CCDSolver` class.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring the CCD solver
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, you will declare the CCD solver. This will give you a chance
    to familiarize yourself with the API and understand how the class works at a high
    level before diving into the implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file, `CCDSolver.h`, that the `CCDSolver` class will be declared
    in this file. The `CCDSolver` class should contain a vector of transforms that
    make up the IK chain. Assume that the IK chain has a parent-child relationship
    where every index is the child of the index before it, making 0 our root node.
    As such, every transform in the IK chain is declared in local space. Follow these
    steps to declare the CCD IK solver:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Begin by declaring the `CCDSolver` class with three variables: a list of transforms
    to form the IK chain, the number of iterations to perform, and some small delta
    that can be used to control how close the target has to be to the goal before
    the chain is considered solved. Declare the default constructor as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement getter and setter functions for the size of the IK chain, the number
    of steps, and the threshold values. Declare which `[] operator` is to be used
    to get and set local joint transform. Declare the `GetGlobalTransform` function,
    which will return the global transform of a joint:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare the `Solve` function, which will be called to solve the IK chain. A
    transform is provided, but only the position component of the transform is ever
    used. The `Solve` function returns `true` if the chain was solved, otherwise,
    it returns `false`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `mNumSteps` variable is used to make sure the solver doesn't fall into an
    infinite loop. There is no guarantee that the end effector will ever reach the
    goal. Limiting the number of iterations helps to avoid a potential infinite loop.
    In the following section, you will start to implement the CCD solver.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the CCD solver
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new file, `CCDSolver.cpp`, in which to implement the CCD solver. Follow
    these steps to implement the CCD solver:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define the default constructor to assign values to the number of steps and
    the threshold. Use a small threshold such as `0.0001f`. Use `15` for the default
    number of steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `Size` and `Resize` functions, which control the size of the
    IK chain, and `[] operator` contains the value of each joint in the chain:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement getter and setter functions for the number of steps and the threshold
    that the solver contains:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `GetGlobalTransform` function, which probably looks familiar.
    It concatenates the transform of the specified joint with the transform of all
    of its parent joints and returns the global transform of the specified joint:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `Solve` function by making sure the size of the chain is valid
    and storing local variables for the index of the last element and the vector of
    the target position:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Loop from `0` to `mNumSteps` to perform the correct number of iterations. On
    every iteration, get the position of the end effector and check whether it''s
    close enough to the goal. If it is close enough, return early:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In each iteration, loop through the entire IK chain. Start the iteration at
    `size - 2`; since `size - 1` is the last element, rotating the last element has
    no effect on any bones:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'For each joint in the IK chain, get the world transform of the joint. Find
    a vector from the position of the joint to the position of the end effector. Find
    another vector from the position of the current joint to the position of the goal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, find a quaternion that rotates from the position to effector vector to
    the position to goal vector. There is an edge case in which the vector pointing
    to the effector or to the goal could be a zero vector:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Use this vector to rotate the joint into the correct orientation in the world
    space. Rotate the world space orientation of the joint by the inverse of the joint''s
    previous world rotation to move the quaternion back into the joint space:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'As the joint moves, check how close the end effector moved to the goal at each
    iteration. If it''s close enough, return early from the function, with a value
    of `true`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'If the goal wasn''t reached, the IK chain can''t be solved, at least not in
    the number of iterations specified. Simply return `false` to signal that the function
    failed to reach its target:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This CCD solver can be used to solve a single chain that has one origin and
    one end effector. There are more advanced ways of handling IK chains where a single
    chain could have multiple end effectors. However, those are much less common due
    to the additional implementation complexity. In the next section, you will start
    to explore a different IK algorithm, FABRIK.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a FABRIK solver
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**FABRIK** (**Forward And Backward Reaching Inverse Kinematics**) has a more
    natural, humanoid looking convergence. Like CCD, FABRIK works with an IK chain
    that has a base, end effector, and target to reach for. Unlike CCD, FABRIK works
    with positions, not rotations. The FABRIK algorithm is easier to understand since
    it can be implemented using only vectors.'
  prefs: []
  type: TYPE_NORMAL
- en: In many ways, FABRIK can be used as a drop-in replacement for CCD. Both algorithms
    address the same problem, but they take different approaches to address it. FABRIK
    tends to converge faster and look better for humanoid animation, so you will probably
    use it as the solver for character limbs.
  prefs: []
  type: TYPE_NORMAL
- en: Working with positions instead of rotations will not work well when it comes
    to humanoid rigs, which need to be animated by rotating joints. This can be solved
    by adding a pre- and post-process step to the algorithm. The pre-process step
    will convert all transforms in the IK chain into world space position vectors.
    The post-process step will convert those vectors into rotation data.
  prefs: []
  type: TYPE_NORMAL
- en: The FABRIK algorithm has two parts. First, iterate backward from the end effector
    to the base. When iterating backward, move the effector to the target. Next, move
    every bone so they are relative to the effector; this will keep the chain intact.
    Next, move the base back to its original position and move every bone relative
    to the base so the chain stays intact.
  prefs: []
  type: TYPE_NORMAL
- en: 'In pseudocode, the FABRIK algorithm looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: To visualize FABRIK, set the end effector to where the target is. Find a vector
    from the end effector to the last joint. Move the last joint to be along this
    vector, maintaining its distance to the end effector. Repeat for each joint until
    the base is reached. This will move the base joint out of position.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do the forward iteration, put the base back to where it should be. Find
    a vector to the next joint. Place the next joint on this vector, maintaining its
    distance to the base. Repeat this all of the way down the chain:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.2 Visualizing the FABRIK algorithm'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.2_B16191.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.2: Visualizing the FABRIK algorithm'
  prefs: []
  type: TYPE_NORMAL
- en: Both FABRIK and CCD will try to solve an IK chain, but they converge on the
    goal differently. CCD tends to curl, while FABRIK tends to stretch. FABRIK usually
    generates more natural results for humanoid animation. In the following section,
    you will start to declare the `FABRIKSolver` class, followed by the implementation
    of the class.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring the FABRIK solver
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The FABRIK solver will need more memory to run since it has to convert local
    joint transformations into global positions. The algorithm can be broken down
    into several steps that can all be implemented as protected helper functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file, `FABRIKSolver.h`. This file will be used to declare the
    `FABRIKSolver` class. Follow these steps to declare the `FABRIKSolver` class:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Begin by declaring the `FABRIKSolver` class, which needs to keep track of the
    IK chain, the maximum number of steps, and some distance threshold. Declare a
    vector of world space positions and a vector of joint lengths. These vectors are
    needed because the FABRIK algorithm does not take rotations into account:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare helper functions to copy the IK chain into the world position vector,
    to iterate forward, to iterate backward, and to copy the final world positions
    back into the IK chain:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a default constructor, getter and setter functions for the size of
    the chain, the number of iterations to solve the chain, and the epsilon value
    of how far the end joint needs to be from the target:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare getter and setter functions for the local transforms stored in the
    IK chain. Declare a function to retrieve the global transform of a joint. Finally,
    declare the `Solve` function, which solves the IK chain when given a target:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The FABRIK algorithm is a little more complicated to implement than the CCD
    algorithm was, but the steps are easier to break down into functions. In the following
    section, you will start to implement the functions of the `FABRIKSolver` class.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the FABRIK solver
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The FABRIK algorithm works on world space positions. This means, for each iteration,
    the IK chain will need to convert local joint transformations into world positions
    and store the result. After the chain is solved, the world positions vector will
    need to be converted back into relative offsets and stored back in the IK chain.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file, `FABRIKSolver.cpp`; the `FABRIKSolver` class will be implemented
    in this file. Follow these steps to implement the `FABRIKSolver` class:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement the constructor of the `FABRIKSolver` class. It needs to set the
    number of steps and the threshold to default values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the trivial getter and setter functions for the number of steps and
    the threshold values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement a getter and setter function for the size of the chain. The setter
    function needs to set the size of the chain, the world chain, and the lengths''
    vector:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement methods for getting and setting the local transform of an element
    in the IK chain:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the getter function to retrieve the global transform and concatenate
    all of the transforms to the root:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `IKChainToWorld` function, which will copy the IK chain into
    the world transform vector and record the segment lengths. The lengths array stores
    the distance of a joint from its parent. This means that the root joint will always
    contain the length `0`. For non-root joints, the distance at the `i` index is
    the distance between the joints `i` and `i–1`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `WorldToIKChain` function next, which will convert the world
    position IK chain back into local space transforms. Loop through all of the joints.
    For each joint, find the world space transform of the current joint and the next
    one. Cache the world space position and rotation of the current joint:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a vector that points from the current joint to the next one. This is
    the rotation between the current node and the next node:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Construct a vector that points from the world space IK chain of the next joint
    to the current position. This is the rotation between the current node and the
    desired position of the next node:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Align these two vectors by using the `fromTo` quaternion function. Apply the
    final delta rotation to the current joint''s IK chain rotation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, implement the `IterateBackward` function, which sets the last element
    in the chain to be at the goal. This breaks the IK chain. Adjust all other joints
    using the stored distanced so that the chain remains intact. After this function
    executes, the end effector is always at the goal and the initial joint is probably
    no longer at the base:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `IterateForward` function. This function rearranges the IK chain
    so that the first link starts at the origin of the chain. This function needs
    to set the initial joint to be at the base, and it iterates through all other
    joints, adjusting them to keep the IK chain intact. After this function executes,
    the end effector might be at the goal if the chain is solvable and has sufficient
    iterations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Start to implement the `Solve` function by copying the IK chain into the world
    positions vector and fill out the lengths vector. This can be done with the `IKChainToWorld`
    helper function. Cache the base and goal positions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Iterate from `0` to `mNumSteps`. For each iteration, check whether the goal
    and end effector are close enough for the chain to be solved. If they are, copy
    the world positions back into the chain with the `WorldToIKChain` helper function
    and return early. If they are not close enough, do the iteration by calling the
    `IterateBackward` and `IterateForward` methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'After the iteration loop, copy the world positions vector back into the IK
    chain regardless of whether the solver was able to solve the chain. Check one
    last time whether the end effector has reached its goal, and return the appropriate
    Boolean:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The FABRIK algorithm is popular because it tends to converge on the end goal
    fast, the results look good for humanoid characters, and the algorithm is easy
    to implement. In the next section, you will learn how to add constraints to either
    the FABRIK or CCD solver.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing constraints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Both CCD and FABRIK solvers produce good results, but neither produces predictable
    results. In this section, you will learn what constraints are, where the IK solver
    constraints can be applied, and how to apply constraints. This will let you build
    much more realistic IK solvers.
  prefs: []
  type: TYPE_NORMAL
- en: Consider an IK chain that is supposed to represent a leg. You would want to
    make sure that the motion of each joint is predictable, for example, the knee
    should probably not bend forward.
  prefs: []
  type: TYPE_NORMAL
- en: This is where constraints are useful. The knee joint is a hinge; if a hinge
    constraint is applied, the leg IK chain will look more realistic. Using constraints,
    you can set rules for each joint in an IK chain.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps will show you where to apply constraints in both the CCD
    and FABRIK solvers:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Constraints can be applied to both CCD and FABRIK solvers, and they must be
    applied after each iteration. For CCD, this means inserting a bit of code here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Applying constraints to the FABRIK solver is more complex. The constraint is
    applied to each iteration, and the IK chain needs to be converted between the
    world position chain and IK chain on every iteration. Apply constraints every
    iteration after copying the data to the transform chain:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The reason that the `Solve` function is virtual is so you can extend each of
    the `IKChain` classes into specific types of chains such as `LegIKChain` or `ArmIKChain`
    and add the constraint code to the solve method directly. In the following sections,
    you will explore common types of constraints.
  prefs: []
  type: TYPE_NORMAL
- en: Ball-and-socket constraint
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Bal- and-socket joints work like a shoulder joint. The joint can rotate on
    all three axes, but there is an angle constraint preventing it from rotating freely.
    *Figure 13.3* shows what a ball-and-socket constraint looks like visually:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.3 A ball and socket constraint visualized'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.3_B16191.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.3: A ball-and-socket constraint visualized'
  prefs: []
  type: TYPE_NORMAL
- en: To build a ball-and-socket constraint, you need to know the rotation of both
    the current joint and its parent. You can construct forward vectors from these
    quaternions and check the angle of the forward vectors. If the angle is greater
    than a provided limit, the rotation needs to be adjusted.
  prefs: []
  type: TYPE_NORMAL
- en: 'To limit the rotation, find the rotation axis. The cross product between the
    two forward directions is perpendicular to both; this is the rotation axis. Create
    a quaternion that brings the angle limit along this axis into the local space
    of the current joint and set that quaternion to be the rotation of the joint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The ball-and-socket constraint is usually applied to the hip or shoulder joints
    of a character. These also tend to be the root joints for the limb IK chains.
    In the next section, you will explore another type of constraint, that is, the
    hinge constraint.
  prefs: []
  type: TYPE_NORMAL
- en: Hinge constraint
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The hinge constraint is like an elbow or a knee. It only allows for rotation
    on one specific axis. *Figure 13.4* demonstrates what a hinge joint looks like
    visually:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.4 A hinge constraint visualized'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.4_B16191.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.4: A hinge constraint visualized'
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement a hinge constraint, you need to know the world space rotation
    of the current joint and the parent joint. Multiply the axis normal by both rotation
    quaternions and find a quaternion between the two; this is the amount you need
    to rotate to constrain the joint to an axis. Bring this rotation back into the
    joint space and apply the rotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Hinge constraints are often used for elbow or knee joints. In the following
    section, you will explore how to use IK to align a character's feet to the ground.
  prefs: []
  type: TYPE_NORMAL
- en: Using IK to align a character's feet to the ground
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you will learn how IK can be used to modify an animation so
    it looks more correct. Specifically, you will learn how to use IK to stop a character's
    feet from going through the ground when walking over uneven surfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you can solve IK chains using CCD or FABRIK, let's explore how these
    solvers can be used. There are two common uses for IK, that is, to position hands
    or to position feet. In this section, you will explore what it takes to clamp
    a character's foot to the ground as the character is walking.
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve foot clamping, you could check the last global position of the foot
    against the current global position. If the foot motion hits anything on the way,
    pin the foot to the ground. Even the most trivial solutions have edge cases: what
    happens if the up motion is too far away? At what point in the animation cycle
    can we interpolate between pinned and non-pinned positions?'
  prefs: []
  type: TYPE_NORMAL
- en: To make implementation easier, the ground clamping strategy for this chapter
    will remain simple. First, check whether the foot is colliding with anything above
    it, clipping through the terrain, for example. To do this, cast a ray from the
    hip of the character to the ankle.
  prefs: []
  type: TYPE_NORMAL
- en: If the ray hits anything, the hit point will be the goal of the leg IK chain.
    If the ray does not hit anything, the current position of the character's ankle
    will be the goal of the leg IK chain. Next, do the same ray cast, but do not stop
    at the ankle of the character; just keep going.
  prefs: []
  type: TYPE_NORMAL
- en: If this ray hits anything, the hit point is a future IK goal. If the ray does
    not hit anything, set the future IK goal to the current IK goal. Now there are
    two goals, one that's in free motion and one that's pinned to the ground.
  prefs: []
  type: TYPE_NORMAL
- en: If you use the current goal, the feet of the character might snap to the ground
    abruptly. If you use the future goal, the character won't walk—it will just drag
    its feet on the ground. Instead, you have to interpolate between the two goals
    by some value.
  prefs: []
  type: TYPE_NORMAL
- en: The interpolation value should come from the animation itself. When the character's
    foot is down, the current goal should be used; when it's up, the future goal should
    be used. As the character's foot is being placed up or down, the goal position
    should `lerp`.
  prefs: []
  type: TYPE_NORMAL
- en: With the IK goal known, the IK solver can figure out how to bend the character's
    leg. Once the leg joints are in world space, we adjust the head of the foot to
    always be on the terrain following some similar steps as you did to solve the
    legs.
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, you will explore each of the steps described here
    in more detail. However, there is a bit of a catch. Most of the values that are
    needed are specific to the model that is being used for rendering; a different
    character will need values tuned differently.
  prefs: []
  type: TYPE_NORMAL
- en: Finding the foot goals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Cast a ray straight down from a bit below the hip of the character to a bit
    below the ankle. This ray cast should go straight down, following the position
    of the ankle. However, how far under the hit the ray should start and how far
    below the ankle it should go are model-specific:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.5 Ray cast to find the foot goal'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.5_B16191.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.5: Ray cast to find the foot goal'
  prefs: []
  type: TYPE_NORMAL
- en: Record the result of this ray cast regardless of how far away the hit point
    is. This point will be treated as the IK goal, which is always clamped to the
    ground. Check whether the ray has hit anything between its origin and the bottom
    of the ankle. If it did, that will be the ankle goal. If it did not, the ankle
    goal will be the position of the ankle.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is important to keep in mind that the character''s ankle is being positioned,
    not the bottom of its foot. Therefore, the goal point needs to be moved up by
    the distance of the ankle to the floor:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.6 Offset to position the character''s ankle'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.6_B16191.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.6: Offset to position the character''s ankle'
  prefs: []
  type: TYPE_NORMAL
- en: These foot goals will control how the IK system overrides the animation. When
    walking, and if the foot motion is not obstructed, the IK system should not be
    noticeable. In the next section, you will learn how to control the interpolation
    of the foot between the animated and the pinned goal points.
  prefs: []
  type: TYPE_NORMAL
- en: Interpolating the foot goals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To interpolate between the current and future IK goals, you will need some knowledge
    of the animation clip that is currently playing. Specifically, you need to know
    what phase the leg is in; is it grounded, being lifted, suspended, or being placed?
    A common way to encode this information is with a scalar curve.
  prefs: []
  type: TYPE_NORMAL
- en: 'The idea is to create two scalar curves, one for the left and one for the right
    leg. These curves correspond to the stride of the current step. For example, when
    the left foot is off the ground, the value of the left scalar curve needs to be
    0\. If the left foot is on the ground, the value of the left curve needs to be
    1\. The curve looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.7 Walk cycle stride expressed as scalar curves'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.7_B16191.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.7: Walk cycle stride expressed as scalar curves'
  prefs: []
  type: TYPE_NORMAL
- en: Sample these curves based on the current normalized playback time. The resulting
    value will be between 0 and 1\. Use this 0 to 1 value as the blend weight when
    blending the non-IK adjusted animation and the IK adjusted animation together.
    This curve is usually authored by eye using a curve editor. The curve is specific
    to the animation that is currently playing.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, you will explore how to adjust the vertical placement of
    the IK character to avoid hyperextending limbs.
  prefs: []
  type: TYPE_NORMAL
- en: Vertical character placement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next, the character needs to be positioned vertically so that it looks good.
    If the character is placed too far up, it would end up with the legs in a hyperextended
    state. Too low, and the IK system will bend the legs too much:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.8 IK hyperextension compared to sampled animation'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.8_B16191.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.8: IK hyperextension compared to sampled animation'
  prefs: []
  type: TYPE_NORMAL
- en: How the character is positioned is relative to how it was modeled. If the character
    was modeled assuming (0, 0, 0) is the center point on the ground, you can place
    it right on the surface below, and sink it into the surface just a bit.
  prefs: []
  type: TYPE_NORMAL
- en: 'The character needs to be sunk into the surface a little bit to allow the IK
    system to do some work and avoid hyperextension. This raises the question: what
    is the surface that the character''s feet need to be aligned with? The alignment
    position can come from a collision/physics system, or in a simpler example, just
    a ray cast going straight down from the character.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Collision surfaces and visual surfaces are not the same. Consider a staircase:
    the collision geometry is usually a ramp. The display geometry is what looks like
    an actual staircase. In a situation like this, the character''s position should
    be relative to the collision geometry, but the IK goals should be positioned in
    relation to the visual geometry.'
  prefs: []
  type: TYPE_NORMAL
- en: What if there is only one geometry used for both collisions and visuals? In
    this scenario, place the character to either of the clamped IK goals, whichever
    one is lower. This will ensure that the ground is always reachable without hyperextension.
  prefs: []
  type: TYPE_NORMAL
- en: IK pass
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It's time to solve the leg IK chain. Before doing this, copy joints from the
    animated pose into the IK solver. For each leg, copy the global transform of the
    hip joint into the root of the IK solver. Copy the local transform of the knee
    into joint 1, and the local transform of the ankle into joint 2\. Then, run the
    IK solver. The solver will place the character's feet at the goal points, which
    are clamped to the ground.
  prefs: []
  type: TYPE_NORMAL
- en: Foot alignment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The clamped foot animation is smooth at this point, and the feet will no longer
    clip inside the ground. But only the leg of the character looks correct, not the
    feet. Take a look at the foot of a character on a non-flat surface—there is still
    a decent amount of clipping happening:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.9 The leg is clamped to the ground, but the foot is oriented wrong'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.9_B16191.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.9: The leg is clamped to the ground, but the foot is oriented wrong'
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this, create a toe ray. The toe ray will be positioned at the ankle
    joint of the character, and some distance along the forward axis of the character.
    This will ensure that the toe target is always looking forward, even if, in the
    animation, the toe is pointing down. Adjust the vertical position of the toe ray
    to shoot from above the knee to a little below the toe:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.10 To cast the offset forward, even if the toe points down'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.10_B16191.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.10: To cast the offset forward, even if the toe points down'
  prefs: []
  type: TYPE_NORMAL
- en: Position the toe similar to how the leg was positioned. Find a goal that is
    the position of the current toe, clamped to the ground. Interpolate between the
    ground clamped goal and the active animation goal by the current normalized time
    of the animation.
  prefs: []
  type: TYPE_NORMAL
- en: This toe goal will be used to rotate the foot. Find a vector from the ankle
    to the current toe position. Find a vector from the ankle to the goal toe position.
    Create a quaternion that rotates between these two vectors. Rotate the ankle by
    this quaternion.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you learned how to find foot goals, interpolate between them,
    and use those goals and the IK system to align a character's feet to the ground.
    Ground alignment is just one of the use cases for IK solvers. Similar systems
    can be used with arms to grab things or the whole body to create a ragdoll system.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you implemented CCD and FABRIK IK solvers. Both solvers can
    solve an IK chain, but they converge differently. Which algorithm works better
    is very much context-dependent.
  prefs: []
  type: TYPE_NORMAL
- en: You also learned how constraints can be used to limit the range of motion for
    a specific joint. With the right constraints in place, an IK system modifies the
    current animation so that it interacts with the environment. You explored how
    to achieve this in the feet grounding section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In the downloadable content for this book, there are 4 samples for this chapter.
    `Sample00` contains the code up to this point. `Sample01` demonstrates how a CCD
    solver can be used, and `Sample02` demonstrates how a FABRIK solver can be used.
    `Sample03` demonstrates foot clamping and ground alignment for a character walking
    along a path.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn how dual quaternions can be used for skinning.
    Dual quaternion skinning better maintains the volume of a mesh than linear blended
    skinning when the mesh is bent or rotated.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Other than FABRIK and CCD, IK chains are sometimes solved analytically or with
    Jacobian matrices:'
  prefs: []
  type: TYPE_NORMAL
- en: For more [info on analytical IK solvers, check out htt](http://theorangeduck.com/page/simple-two-joint)p://theorangeduck.com/page/simple-two-joint.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A complete Jacobian solver implementation is covered in *Game Programming Gems
    4*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
