- en: '*Chapter 4*: Learning Single-Page Application Concepts and How React Enables
    Them'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we'll learn about **Single-Page Applications** (**SPAs**).
    This style of programming web applications is relatively new in the history of
    web development but has caught on strongly in recent years. Its use is now common
    practice for building large complex web applications that need to feel like native
    desktop or mobile apps.
  prefs: []
  type: TYPE_NORMAL
- en: We will review the former methods of building web apps and why SPA-style apps
    were created. We'll then learn how React can help us build this style of application
    in a performant and efficient way.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding how websites were built in the past
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding SPA benefits and attributes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding how React helps build SPA applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The requirements for this chapter are similar to the ones for [*Chapter 3*](B15508_03_Final_JC_ePub.xhtml#_idTextAnchor052),
    *Building Better Apps with ES6+ Features*. You should have a basic understanding
    of JavaScript as well as HTML and CSS. We will once again be using Node.js and
    **Visual Studio Code** (**VSCode**).
  prefs: []
  type: TYPE_NORMAL
- en: The GitHub repository is again at [https://github.com/PacktPublishing/Full-Stack-React-TypeScript-and-Node](https://github.com/PacktPublishing/Full-Stack-React-TypeScript-and-Node).
    Use the code in the `Chap4` folder.
  prefs: []
  type: TYPE_NORMAL
- en: To set up this chapter's code folder, go to your `HandsOnTypescript` folder
    and create a new folder called `Chap4`.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding how websites were built in the past
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will investigate the reasons for the creation of SPA-style
    programming by reviewing the original methods for designing and writing web pages.
    Having this knowledge will help us understand the reason for the shift to SPAs.
  prefs: []
  type: TYPE_NORMAL
- en: Originally, when the web was getting started, there was no JavaScript language.
    Initially, it was all just static HTML pages created to share documents among
    scientists. Once this document format and the internet became more popular, people
    realized that these documents needed improved styling methods to enhance communication.
    So, CSS was created and it became a standard for styling and the layout of HTML
    documents. Then, finally, the Netscape browser company decided the web needed
    a scripting language to make page content more dynamic, and they created JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Despite these features, the original web was still very static in nature. When
    you entered a URL into your browser, you got back a single document—that is, an
    actual file on the server—and this would be the case for every URL you entered.
    CSS and JavaScript did help to make the web look better and be more dynamic, but
    it did not change the page-focused model of the web.
  prefs: []
  type: TYPE_NORMAL
- en: As websites became more and more sophisticated, many web developers wanted to
    have better control over their web documents. They wanted to dynamically control
    the layout and content of web pages. This resulted in **Common Gateway Interface**
    (**CGI**) being created. CGI was an early attempt at doing **Server-Side Rendering**
    (**SSR**). This basically means that requests from browsers were received by web
    servers, but instead of returning static HTML pages, the server would run a processor
    that would dynamically generate a page on the fly based on parameters and logic
    and then send that back.
  prefs: []
  type: TYPE_NORMAL
- en: Whether the website used a static HTML page that did not change or rendered
    its pages on a server using server-side logic, in the past, the emphasis was on
    sending to browsers complete HTML pages as files. This was how websites worked
    in general.
  prefs: []
  type: TYPE_NORMAL
- en: This single-file or page-based model is not at all like how native apps work,
    either on desktops or mobile devices. The native app model is different in that
    the entire app is downloaded and installed onto the user's device. When the user
    opens the app, it is ready to use in its entirety at that moment. Any controls
    that need to be drawn on the screen are done so from the code that is already
    there, and no additional calls to a backend server are necessary (other than calls
    to send or get data). This makes apps feel noticeably more responsive and faster
    than classic web applications, which constantly required a page refresh to show
    new content in the old model.
  prefs: []
  type: TYPE_NORMAL
- en: The impetus of SPA applications was to make web apps feel much more like native
    device applications, in order to give them the same sense of speed and responsiveness.
    Therefore, the SPA style uses various techniques and libraries to make web applications
    function and feel more like native applications.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we reviewed how websites were built in the early days of the
    web. Back then, the focus was on generating and serving individual HTML document
    files. We saw how there are limitations with this style of programming, especially
    when compared with native applications, and that SPA-style applications are an
    attempt to address those limitations and make web apps seem like native apps.
    In the next section, you will see what SPA apps are and how they may improve upon
    the page-focused model of the original web.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding SPA benefits and attributes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will learn about what the benefits and attributes of SPA
    applications are. By learning about these attributes, they will help us understand
    some of the architectural decisions that were made during React's creation, as
    well as some of the related libraries and components used in creating React apps.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned earlier, the impetus for using SPA-style application building is
    to make our web app look and feel more like a native application. By using SPA
    application methods, we will make our program respond and look like it was installed
    on the device. Classic-style web apps can seem sluggish since any changes to the
    page require a call back to the server to get a new screen. However, SPA-style
    apps redraw portions of the screen immediately without waiting for a new file
    to come back from the server. Therefore, as far as the user can tell, a SPA application
    is a native device application.
  prefs: []
  type: TYPE_NORMAL
- en: Building SPA applications is quite complex, with many components and libraries
    that need to be used. However, whether we're using Angular, Vue, React, or some
    other framework, there are certain features and requirements that will always
    be common across SPA applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s understand some of the requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: As the name suggests, the entire app lives on one HTML page only. Unlike standard
    HTML apps, which use separate pages to show different screens, the first page
    is the only page that ever loads on a SPA application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instead of static HTML files, JavaScript renders the screen dynamically. Therefore,
    the HTML page that is first downloaded is actually almost entirely empty of content.
    But what it will have is a root element inside of the body tag that becomes the
    container for the entire application, which again is rendered live as the user
    interacts with the application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All scripts and files needed to run the application are generally downloaded
    in the beginning, when retrieving the main HTML file. However, this method is
    changing and more applications are downloading only a base-level script file and
    then downloading other scripts on-demand as needed. We'll review how to use these
    techniques later, as they can enhance the user experience by reducing screen wait
    times.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: URL routing is handled differently for SPAs. In SPA applications, there is some
    mechanism used, depending on the framework you choose, in order to create **virtual
    routing**. Virtual routing simply means that although it appears to the user that
    different calls to different server-side URLs are being made, in reality, all
    the "routing" is only happening on the client browser in order to make logical
    transitions to different screens. In other words, no calls to servers are made
    and URL routing becomes a means to logically separate an app into different screens.
    For example, when a user types a URL into their browser, they must then press
    *Enter* for the submission to be posted back to the server that is the destination
    of the URL. However, in the case of routing happening in a SPA app, there is no
    actual server path indicated by the URL. It does not exist. Therefore, the postback
    is never triggered. Instead, the application uses the URL as a sort of container
    for sections of the application and also to trigger certain behaviors when certain
    URLs are given. Having said this, URL routing is still a useful feature to have,
    as routing is an expected capability by most users and it allows them to bookmark
    screens.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, we have learned about the attributes that make up a SPA. We
    covered the different methods to deal with having only a single file for our entire
    application and the methodologies used for building these kinds of applications.
    In the next section, we will drill into details about how React enables SPAs and
    the decisions that were made by the React team for creating this style of application.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding how React helps build SPAs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll learn about React at a high level. This understanding
    will help us build better React-based applications as we'll understand how React
    operates internally.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned previously, a website is primarily just an HTML file, which is
    a text-based document. This file contains code that the browser uses to create
    a logical tree called the **Document Object Model** (**DOM**). This tree represents
    all of the HTML elements within the file according to their order and relative
    to other elements in the structure. All websites have a DOM structure on their
    pages, whether they use the SPA style or not. However, React takes advantage of
    the DOM in unique ways in order to help build apps.
  prefs: []
  type: TYPE_NORMAL
- en: 'React has two main constructs:'
  prefs: []
  type: TYPE_NORMAL
- en: React maintains its own virtual DOM at runtime. This virtual DOM is distinct
    from the browser's DOM. It is React's own unique copy of the DOM that it creates
    and maintains based on the instructions from our code. This virtual DOM is created
    and edited as needed based on a reconciliation process that the React service
    does internally. The reconciliation process is a comparison process where React
    looks at the browser DOM and contrasts that with its own virtual DOM. This reconciliation
    process is generally known as the **render phase**. When differences are found—for
    example, the virtual DOM contains an element not contained in the browser DOM—React
    will send instructions to the browser DOM to create that element so that the browser
    DOM and the virtual DOM match. This process of adding, editing, or removing elements
    is known as the **commit phase**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The other main attribute of React development is that it is state-driven. In
    React, an application is made up of many components, and in each component, there
    may be some local state (that is, data). If this data changes for any reason,
    React will trigger its reconciliation process and make changes in the DOM if needed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To make these concepts more concrete, we should take a look at an example of
    a simple React application. But before we do that, let's review what a React application
    is "made of."
  prefs: []
  type: TYPE_NORMAL
- en: Attributes of a React application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At its core, a modern React application will need a few base features to function.
    We'll need `npm` to help us manage the application's dependencies. As you've seen
    from our previous exercises, `npm` is a repository that allows us to download
    open source dependencies from a central store and use them in our application.
    We'll also need a tool for doing what's called bundling. A bundling system is
    a service that aggregates all of our script files and assets, such as CSS files,
    and minifies them into a single set of files. The minification process removes
    whitespace and other unneeded text from our scripts so that the files that ultimately
    get downloaded onto user browsers are as small as possible. This smaller payload
    size improves app startup time and improves user experience. The bundling system
    we'll use is called webpack, and we've selected it because it's the industry standard
    for bundling React applications. In addition, we can use `npm`'s built-in script
    system and create scripts to automate some of our work. For example, we can create
    scripts that will start up our test server, run our tests, and build the final
    production version of our app.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we use the `create-react-app` `npm` package, we can get all of the previously
    mentioned dependencies, as well as common dependencies for doing React development
    and some built-in scripts to manage our app. Let''s use this package and create
    our first app:'
  prefs: []
  type: TYPE_NORMAL
- en: 'On your terminal or command line, go to the `HandsOnTypescript/Chap4` folder
    and run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Once this command completes, open VSCode and open the newly created folder,
    `try-react`, which we created at the start of this chapter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the terminal in VSCode and run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '![Figure 4.1 – try-react'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.1_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.1 – try-react
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at what `create-react-app` gives us, starting from the top:'
  prefs: []
  type: TYPE_NORMAL
- en: The `build` folder is the destination of all of our bundled and minified final
    production files. They have been shrunken down to be as small as possible and
    debug information has also been removed in order to enhance performance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we have the `node_modules` folder, which contains all of our dependencies
    that we download from the `npm` repository.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, we have the `public` folder, which is a folder for static assets, such
    as the `index.html` file, which will be used to build out our final app.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we have what is perhaps the most important folder, called `src`. As the
    shortened name implies, this is the folder that contains all of our source scripts.
    Any files with a `.tsx` extension indicate a React component. `.ts` files are
    just plain TypeScript files. Finally, `.css` files have our styling attributes
    (and there can be more than one). `d.ts` files are files that contain TypeScript
    typing information that the compiler uses to determine static type checks it needs
    to do.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next is the `.gitignore` file. This file is for use with the GitHub code repository
    we are using to save this book's source code. As the name implies, with this file,
    we are telling our `git` system to not upload certain files and folders, but to
    ignore them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `package.json` and `package-lock.json` files are for configuring and setting
    our dependencies. Additionally, they can store configurations for our build, test,
    and run scripts, as well as configurations for the Jest testing framework.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we have our `tsconfig.json` file, which we discussed in [*Chapter 2*](B15508_02_Final_JC_ePub.xhtml#_idTextAnchor025),
    *Exploring TypeScript*. It will configure the TypeScript compiler. Please notice
    that by default, strict mode is turned on, and therefore we cannot use implicit
    `any` or `undefined`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that we''ve done this quick inventory of our project, let''s take a look
    at the contents of some of our files. First, we''ll start with the `package.json`
    file. There are many sections to the `package.json` file, but let''s look at some
    of the most important ones:'
  prefs: []
  type: TYPE_NORMAL
- en: The `dependencies` section contains the libraries that our app will be using
    for certain pieces of functionality. These dependencies include React, as well
    as TypeScript and Jest libraries for doing testing. The `@types` dependencies
    contain the TypeScript definition files. TypeScript definition files store static
    typing information for frameworks that are written in JavaScript. In other words,
    this file tells the TypeScript compiler the shape of the types being used by a
    framework so that type declarations and checking can be done.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is another dependencies section, called `devDependencies`—although it's
    not used here—which normally stores development time dependencies (as opposed
    to the `dependencies` section, which normally only stores the runtime dependencies).
    For whatever reason, the React team decided to merge the two into `dependencies`.
    Having said that, you should be aware of it as you'll see this section in many
    projects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The scripts section is for storing scripts that manage the application. For
    example, the `start` script is used by calling `npm run start`, or `npm start`
    for short. This script is used to start our application using a development server.
    We can also add our own scripts, as we'll do later, for doing things such as deploying
    production files to a server.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Be aware that the projects created by `create-react-app` have been highly modified
    by the React team. They have been optimized by the team and have hidden scripts
    and configurations that are not readily visible—for example, base webpack configurations
    and scripts. If you're curious, you can run `npm run eject` to see what all these
    configurations and scripts are. However, please note that this is not reversible.
    So, you will not be able to undo it. We will not be using an ejected project,
    as there's little benefit in doing so.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s look at some of the scripts. Open the `index.tsx` file from the
    `src` folder and you''ll see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Service workers
  prefs: []
  type: TYPE_NORMAL
- en: Service workers are a way of doing simple threading in JavaScript. We will not
    be using this feature, but it comes as part of the `create-react-app` project,
    so I have left it for completeness.
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, any file containing a React component that returns JSX will have a `.tsx`
    file extension. We are starting with this file because this is React''s entry
    point for the application. It''s where React starts its runtime build process.
    Now, if we start from the top, we can see that ES6 syntax for importing dependencies
    is being used. React and related modules are being imported, including the core
    `App` module, which we''ll explore shortly. After the imports, we can see that
    `ReactDOM.render` is called, which ultimately "writes out" the HTML of all our
    components combined. It takes two arguments. One is the lowest - level React component
    from which rendering will start and the other is the HTML element used to contain
    the rendered content. As you can see, the `App` component is wrapped with a component
    called `React.StrictMode`. This component is simply an aid to development. When
    compiling in production mode, it has no effect and does not impact performance.
    However, in development mode, it provides extra information about potential issues
    in our code. This may change over time, but here is a list of the current help
    it provides:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Identifying components with unsafe life cycles: It will show you if you are
    using unsafe life cycle calls, such as `componentWillMount`, `componentWillReceiveProps`,
    and `componentWillUpdate`. When coding with Hooks, these issues don''t apply,
    but it is good to be aware of them for legacy class-based components.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Warning about legacy string ref APIs: The older way of creating a reference
    to an HTML element, as opposed to a React component, was to use a string—for example,
    `<div ref="myDiv">{content}</div>`. Because this method uses a string, it has
    issues and now the preferred method is to use `React.createRef` instead. We''ll
    discuss why you might use a ref in later chapters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Warning about deprecated `findDOMNode` usage: `findDOMNode` is now deprecated
    because it broke abstraction principles. Specifically, it allowed parent components,
    in a component tree, to code for specific child components. This tie-in to code
    implementation means that it becomes difficult to change code later because the
    parent now depends on something existing in its component tree. We discussed object-oriented
    programming principles, including abstraction, in [*Chapter 2*](B15508_02_Final_JC_ePub.xhtml#_idTextAnchor025),
    *Exploring TypeScript*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Detecting unexpected side effects: Side-effects are unintended consequences
    of our code. For example, if my class component initializes its state in the constructor
    from some other function or property, it would not be acceptable if that state
    sometimes received different values for every initialization. In order to help
    catch these kinds of issues, `React.StrictMode` will run certain life cycle calls,
    such as, for example, the constructor or `getDerivedStateFromProps`, twice to
    try and show whether this type of thing is happening. Note that this only happens
    during development.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Detecting the legacy context API: The context API is a React feature that provides
    a global state across all components of an application. There is a newer version
    of the API and the older one is now deprecated. This checks that you are not using
    the older one.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most of the checks being done revolve around the older class-based component
    style. However, since the vast majority of existing code that you will probably
    have to maintain is still written in the older style with classes, it's still
    important to know.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s take a look at the `App.tsx` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Please note that the JSX syntax, as shown here, is not actually HTML. It is
    custom JavaScript. Therefore, any time there is a potential conflict with JavaScript
    keywords, React uses another name. For example, `class` is a reserved keyword
    in JavaScript. So, React uses `className` instead to represent CSS classes.
  prefs: []
  type: TYPE_NORMAL
- en: Although the `index.tsx` file is the main starting point for React, the actual
    components that we will build for our app start in the `App.tsx` file. So, this
    is a very important file for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s discuss some items in this code:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we are importing React from the React `npm` dependency. If you look inside
    of the `npm_modules` folder, you will find a subfolder called `react`, and that
    folder is what this `import` statement is referring to. Any code imports we did
    not create ourselves will be in the `node_modules` folder.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next is the `logo` import. Image assets are imported into a JavaScript variable—in
    this case, the `logo` variable. Also, as you can see, since this is not an `npm`
    module, it requires a dot reference. `npm` modules do not require a relative path
    because the system is aware of which folder to start looking in, `npm_modules`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we import `App.css`. This file is the styles file and therefore does not
    have an associated JavaScript variable to it. Since it is not an `npm` package,
    it also requires a relative path.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `App` component is a functional component, as shown by its syntax. The `App`
    component is the root parent component for the entire application. This component
    has no state of its own and just renders out content. So, the `return` statement
    is the rendered content and it is using **JSX**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll go into much more detail about what JSX is in later chapters; however,
    for now, JSX is HTML-like syntax written in JavaScript. It was created by the
    React team to make it easier and clearer to create HTML content with React components.
    The main thing to note is that although it looks almost identical to HTML, it
    is not really HTML and therefore there are some differences in the way it works.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The style reference to CSS classes, which is normally set as `class`, is set
    as `className`, as shown in the code. This is because `class` is a JavaScript
    keyword and so cannot be used here.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Squiggly brackets indicate code is being passed, not strings. For example, the
    `img` tag's `src` attribute takes a JavaScript variable, `logo`, as its value,
    and also that value is inside of squiggly brackets. To pass strings, use quotes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s start our app in development mode to see what this basic screen looks
    like. Run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you run the previous command, you should see the following screen in your
    browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2 – App start'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.2_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.2 – App start
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the text and logo from our `App.tsx` file is showing up, since
    this is the main starting component of our application. Once we start coding,
    we will leave this server running, and when we save any script files, the page
    will automatically update, allowing us to see our changes in real time.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get a better feel for building components in React, as well as how React
    routing works, let''s create our first simple component:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file in the `src` folder called `Home.tsx` and add the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now, as you can see, we are creating a component called `Home` that returns
    a `div` tag with the words `Hello World!`. You should also notice that we are
    using the `FC`, functional component, declaration to type our component. Functional
    components are the only way of creating components when using React Hooks, as
    opposed to the older class style. This is because the React team believes composition
    works better as a means of doing code reuse than inheritance. But do notice that
    the importance of having code reuse, whatever the method, is still there.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, in order to get our component to show on the screen, we need to add it
    to our `App.tsx` file. But let''s also add routing to our app and explore that
    as well. First, update the `index.tsx` file like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `index.tsx` file now has a component called `BrowserRouter`. This component
    is part of React Router and is the base component that allows routing to happen
    across the application. Since it wraps our `App` component, and the rest of the
    application lives inside of this `App` component, it means routing services are
    being provided for the entire application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we will be using React Router, let''s also create a component for a second
    route, called `AnotherScreen`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, update the `App.tsx` file like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: If you left `npm start` running, you should see **Hello World!** Home, as follows:![Figure
    4.3 – Home
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_4.3_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.3 – Home
  prefs: []
  type: TYPE_NORMAL
- en: 'If you look at the URL, you can see that it is on the root of the site. Let''s
    try switching the URL to `http://localhost:3000/another`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.4 – Another screen'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.4_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.4 – Another screen
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, it loaded the `AnotherScreen` component, as per our instructions
    to load that component for this specific URL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, if you open your Chrome browser debugger, you will see that no
    network calls to that specific path were actually made. Again, this confirms that
    React Router is not doing any postbacks for these paths and they only exist on
    the browser locally:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5 – Chrome debugger'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_4.5_B15508.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 4.5 – Chrome debugger
  prefs: []
  type: TYPE_NORMAL
- en: This was just a quick example of building a React app and components just to
    get us started.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned how React works internally and how to set up a React
    project. This knowledge will be valuable in the coming chapters as we begin to
    build out our application.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about how websites were built in the early days
    of the web. We also learned about some of the limitations of the older style of
    web development and how SPA applications attempt to overcome them. We saw how
    a SPA application's main driver is to make web apps behave more like native applications.
    Finally, we got an introduction to React development and building components.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll build upon this knowledge and go into React component
    building in more depth. We'll look at class-based components and compare and contrast
    them to the newer Hook-style components. The things we've learned so far about
    web development and React-based web development will help us to better understand
    this next chapter.
  prefs: []
  type: TYPE_NORMAL
