- en: Vue.js Directives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When writing Vue applications, we have access to a variety of powerful directives
    that allow us to shape the way our content appears on the screen. This allows
    us to craft highly interactive user experiences with additions to our HTML templates.
    This chapter will be looking at each one of these directives in detail, as well
    as any shortcuts and patterns that allow us to improve our workflow.
  prefs: []
  type: TYPE_NORMAL
- en: 'By the end of this chapter you will have:'
  prefs: []
  type: TYPE_NORMAL
- en: Used attribute binding to conditionally change element behavior
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Investigated two-way binding with `v-model`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conditionally displayed information with `v-if`, `v-else`, and `v-if-else`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Iterated over items in a collection with `v-for`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Listened to events (such as keyboard/input) with `v-on`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Used event modifiers to change the binding of a directive
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Used filters to change the view data of a binding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Looked at how we can use shorthand syntax to save time and be more declarative
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the most common requirements for any business application is text input.
    Vue assists us with this need with the `v-model` directive. It allows us to create
    reactive two-way data bindings on form input events, making working with forms
    easily. It''s a welcome abstraction over what would otherwise be a tedious way
    to get form values and input events. To explore this, we can create a new Vue
    project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We can head over to our root `App.vue` file and remove everything from the
    template and instead add a new `div` that encompasses a `label` and `form` input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives us the ability to add text to our input element, that is, prompting
    the user to input their name. I''d like to capture this value and display it below
    the name element for demonstration sake. In order to do this, we''d need to add
    the `v-model` directive to the input element; this will allow us to capture the
    user input events and place the value into a variable. We''ll call this variable
    `name` and subsequently add it to our `data` object within our Vue instance. As
    the value is now captured as a variable, we can display this in our template with
    interpolation binding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The result can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/57e1b1bd-0dc7-4d39-91f1-945d91e28b95.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We''re not limited to working with text inputs when using `v-model`, we can
    also capture radio buttons or checkboxes when selected. The following example
    shows this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This will then display in our browser like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/e61b09d2-ec24-4925-a376-4471e6a09a50.png)'
  prefs: []
  type: TYPE_IMG
- en: The great thing about `v-model` is that it's highly adaptable to a variety of
    form controls, giving us declarative power over our HTML templates.
  prefs: []
  type: TYPE_NORMAL
- en: Iteration with v-for
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If we have content that we''d like to repeat over a certain number, we can
    use `v-for`. This is often used to populate a template with a dataset. For example,
    let''s say we have a list of groceries and we wanted to display this list on the
    screen; we could do this with `v-for`. We can create a new project to see this
    in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'To start with, let''s create an array with a list of groceries that we can
    display on screen. Each item has an `id`, `name`, and `quantity`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then iterate over each item inside of our groceries list and modify
    the DOM to display them on screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice how we have a `v-bind:key="item.id"` on the `li` element. This makes
    Vue work better with iterations that change over time and a key should be added
    where possible:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/1ef683ca-2198-4e34-9033-b7a37aa89275.png)'
  prefs: []
  type: TYPE_IMG
- en: Bindings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we''re going to look at how we can dynamically toggle CSS
    classes within our Vue applications. We''ll start off by investigating the `v-bind`
    directive and we''ll see how this can be applied to both `class` and `style` attributes.
    This is great for conditionally applying styles based on a particular business
    logic. Let''s create a new Vue project for this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Inside of our project, we can make checkboxes that represent the different states
    of our application. We'll start off with one named `red`. As you may be able to
    infer, by checking this we can turn a particular piece of text `red` in color
    and subsequently turn it black by unchecking it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `data` object named `red` with the value of `false` inside `App.vue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This represent the value of our checkbox, which we''ll be able to set with
    the `v-model` directive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, we can create a new CSS class for our color:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in the browser if we open the dev tools, we can see that the
    color of the text is currently set to `blue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/e906133c-b558-45a1-ab86-4cd6523d2b20.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, to add the addition/removal of the class based on the context of the
    `red` variable, we''ll need to add the `v-bind:class` directive to our `h1` like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now in our browser, we can see that we have the ability to check the box to
    set the text to `red` like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/dc02a9df-a9dd-4162-b481-5ff39fa36596.png)'
  prefs: []
  type: TYPE_IMG
- en: Adding secondary properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If we also wanted to add another property to our class binding, we''d need
    to add another property (such as `strikeThrough`) to our `data` object like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then add another `checkbox`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'With an appropriate `style`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we then need to adjust our binding to add the extra class like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the results of checking both boxes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/0aa00a8a-02df-4684-9173-d45a35cd66be.png)'
  prefs: []
  type: TYPE_IMG
- en: Style bindings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We may want to add various styles to our heading, so instead, we could use
    `v-bind:style`. We can see this in action by creating a new object named `headingStyles`
    inside of our `data` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Anytime we're adding CSS classes that would otherwise be kebab-case (for example,
    `text-align`) they now become camel-case (`textAlign`) inside of our JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add the style to our heading inside of the template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Every time the compiler sees a `v-bind` or `:` the content inside of `"` is
    treated as JavaScript with an implicit `this`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could also split this to add `layoutStyles` as a separate object, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'So all that we have to do at this point is add the `styles` in an array within
    the `template` like so within the `<h1>` tag, using `v-bind`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '![](assets/54a1ea26-3a11-4a1c-a346-95fd2d5e0363.png)'
  prefs: []
  type: TYPE_IMG
- en: You can now see the results of our styling on screen. Note that any items further
    in the array will take styling preference over items declared first.
  prefs: []
  type: TYPE_NORMAL
- en: DOM events and v-on
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can handle DOM events within Vue by using `v-on`. By listening to DOM events,
    we're able to react to user input with everything from key-down events (such as
    clicking the *Enter* button) to button click events and more.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s make a playground project to try this in our own project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s imagine an `input` box such that, when we either hit the Add button
    or hit the *Enter* key, the input gets added to an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: You will have to copy the object before pushing it in.
  prefs: []
  type: TYPE_NORMAL
- en: 'What exactly is happening here? We''re capturing the value of the user input
    inside of the person string using the `v-model` directive; after that we''re listening
    for both `keyup.enter` and `v-on:click` events, both of which call the `addPerson`
    function, and subsequently adding the `person` to an array. After that, using
    the `v-for` directive, we''re able to output this list of people to the page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ace0b21b-bc4c-45b3-98bf-43bf51fed64a.png)'
  prefs: []
  type: TYPE_IMG
- en: Key modifiers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''re not limited to simply using the `enter` modifier, we also have access
    to a variety of shorthand modifiers, for example the use of the @ symbol and shortening
    `v-on:event.name` `v-on:` by replacing it with the `@` symbol. Other shortening
    methods include:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@` is the same as ``v-on:``'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@keyup.13` is the same as `@keyup.enter`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@key*` can be queued, such as `@keyup.ctrl.alt.delete`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Other modifiers can be seen in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Name** | **Description** | **Code Example** |'
  prefs: []
  type: TYPE_TB
- en: '| `.enter` | Whenever the *Enter* key is tapped. | `<input v-on:keyup.enter="myFunction"
    />` |'
  prefs: []
  type: TYPE_TB
- en: '| `.tab` | Whenever the *Tab* key is tapped. | `<input v-on:keyup.tab="myFunction"
    />` |'
  prefs: []
  type: TYPE_TB
- en: '| `.delete` | Whenever the *Delete* or *Backspace* key is tapped. | `<input
    v-on:keyup.delete="myFunction" />` |'
  prefs: []
  type: TYPE_TB
- en: '| `.esc` | Whenever the *Esc* key is tapped. | `<input v-on:keyup.esc="myFunction"
    />` |'
  prefs: []
  type: TYPE_TB
- en: '| `.up` | Whenever the up arrow key is tapped. | `<input v-on:keyup.up="myFunction"
    />` |'
  prefs: []
  type: TYPE_TB
- en: '| `.down` | Whenever the down arrow key is tapped. | `<input v-on:keyup.down="myFunction"
    />` |'
  prefs: []
  type: TYPE_TB
- en: '| `.left` | Whenever the left arrow key is tapped. | `<input v-on:keyup.left="myFunction"
    />` |'
  prefs: []
  type: TYPE_TB
- en: '| `.right` | Whenever the right arrow key is tapped. | `<input v-on:keyup.right="myFunction"
    />` |'
  prefs: []
  type: TYPE_TB
- en: Event modifiers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Often when we're working with events inside of JavaScript, we'll modify the
    functionality of the event itself. This means that we need to add `event.preventDefault()`
    or `event.stopPropagation()` within our handler. Vue helps us abstract these calls
    by handling this inside of the template using event modifiers.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is best shown with a `form` example. Let''s take our previous people example
    and modify this to contain a `form` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'If you try and run this example, you''ll notice that when we click the Add
    button, the page refreshes. This is because it''s the default behavior of the
    `form` submitted event. As we''re not POSTing data to a server at this point,
    we instead need to add the `.prevent` modifier to our `submit` event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Now when we select our button, the `addPerson` function is called without refreshing
    the page.
  prefs: []
  type: TYPE_NORMAL
- en: Conditionally showing DOM elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When creating business applications, there'll be many times when you only want
    to display a particular element if a certain condition is **true** or **false**.
    This could include a user's age, whether the user is logged in, whether it is
    an administrator or any other piece of business logic you can think of.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this, we have a variety of conditional directives such as `v-show`, `v-if`,
    `v-else`, and `v-else-if`, all of which act in similar yet different ways. Let''s
    take a look at this in more detail by creating a new playground project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: v-show
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If we want to hide elements from view yet still have them in the DOM (effectively
    `display:none`), we can use `v-show`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, if we had a data variable that allowed us to determine whether
    someone was an administrator, we''d be able to use `v-show` to only show protected
    content to appropriate users:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/41ae3f14-c246-456f-a71c-14bf49db5c8f.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Notice how, in the preceding figure when `admin` is set to `false`, the `display:
    none` style is added to the element. At first glance it may seem like this is
    exactly what we want, our item has disappeared! In certain circumstances, this
    is the case, but in other scenarios, the use of `v-if` may be better.'
  prefs: []
  type: TYPE_NORMAL
- en: '`v-show` doesn''t remove the element from the DOM, meaning that everything
    is initially loaded and simply hidden if it isn''t being used. Our page will have
    to render this content and this could cause performance issues when used in the
    wrong way; therefore prior to using `v-show` ask this question:'
  prefs: []
  type: TYPE_NORMAL
- en: Do I need to show this component again? If so, will be showing it often?
  prefs: []
  type: TYPE_NORMAL
- en: If the answer to this question is **yes**, then `v-show` may be better in this
    circumstance. Otherwise, if the answer to this is **no,** then `v-if` may be better
    in this use case.
  prefs: []
  type: TYPE_NORMAL
- en: v-if
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If we''d like to conditionally remove the element from the DOM, we can use
    `v-if`. Let''s replace our previous `v-show` directive with `v-if`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that now when we look at the DOM, the element is entirely removed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/666919bd-0ba3-4999-82dd-830f4bd3e78c.jpg)'
  prefs: []
  type: TYPE_IMG
- en: v-else
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A common pattern when showing or hiding elements is to instead show a different
    piece of content. Whilst we could use `v-if` or `v-show` multiple times, we also
    have access to the `v-else` directive, which can be used directly after showing
    or hiding the element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at this in more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: By adding the `v-else` directive to the second `<article>`, we're telling Vue
    that we want to show this DOM element whenever the first condition is hidden.
    Because of the way this works, we don't have to pass a value to `v-else` as Vue
    is specifically looking for a structural directive in the preceding element.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s important to realize that this wouldn''t work if we had an element in
    between the `v-if` and `v-else` directive(s), such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: v-else-if
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whilst `v-else` works well in standard **IF NOT A** then **B** scenarios, you
    may want to test for multiple values and show a different template. Similar to
    `v-else`, we can use `v-else-if` to change the behavior of our application. For
    this example, we'll have fun by using a generator as introduced with ES2015.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the generator, we''ll need to install the `babel-polyfill` package;
    this also allows us to use things such as `async` and `await` better promise handling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'After installing it, we can modify our Webpack configuration (`webpack.config.js`)
    to include it inside of our entry files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'If we hadn''t installed the appropriate polyfill, we''d not be able to use
    the generator functionality within our project. Let''s make a new method named
    `returnRole()` that gives us one of three users "roles" when called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'If you''ve never seen a generator function before, you may be wondering what
    the asterisk (`*`) is that we''ve prefixed to our function name, as well as the
    `yield` keyword. This essentially allows us to step through the function by capturing
    an instance of it. For example, let''s make a data value that returns our iterator,
    which we can call `next()` on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We can, therefore, make a template that takes advantage of `v-if-else` by displaying
    different messages depending on the user role:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: There are different messages shown on the screen depending on the user role.
    If the user has no role, we use `v-else` to show a message stating `You have no
    role!`. This example shows how we can take advantage of structural directives
    to truly change the DOM depending on our application state.
  prefs: []
  type: TYPE_NORMAL
- en: Filters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we''re going to investigate filters; you may have come across
    filters before in frameworks such as Angular (Pipes). Perhaps we want to create
    a filter that allows us to format a date in a readable format (DD/MM/YYYY). Let''s
    create a playground project to investigate this further:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'If we had some test people and used the `v-for` directive to display them on
    screen, we''d get the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/90cd6697-f297-41f9-81e3-81584b5e8a08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To obtain the result shown in the preceding screenshot, where we display our
    test people with the appropriate data through the `v-for` directive, we would
    have to add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: We could do the work of converting the date ourselves, but where possible it's
    always worth looking to see if there is a trusted third-party component that can
    do the same thing. We'll be using moment ([https://momentjs.com](https://momentjs.com))
    to do this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s install `moment` for our project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then add it to our `App.vue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Locally registered filters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We then have a choice: add the filter locally to this Vue instance, or add
    it globally to the entire project. We''ll first look at how to add it locally:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll create a function that takes in a value and returns the date
    as a formatted date using `moment`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then add a filters object to our Vue instance and reference this by
    a `key`, such as `date`. When we call the `date` filter inside of our template,
    the value will be passed to this filter and instead, we''ll display the converted
    date on screen. This can be done by using the `|` key, as seen in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, to add this to the local Vue instance, we can add a `filters` object
    that references our function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of this shows the date as intended:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/fad4697a-7219-4dec-96b0-372a6c51fe20.png)'
  prefs: []
  type: TYPE_IMG
- en: Globally registered filters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If we wanted to use this filter elsewhere, we could abstract this function
    into its own file and reference our filter once again, or, we could register the
    `date` filter globally inside of our application. Let''s abstract our `convertDateToString`
    function into its own file at `src/filters/date/date.filter.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Afterwards we can define the filter inside of our `main.js` with the following
    interface: `Vue.filter(''filterName'', filterFunction())`. As we''ve abstracted
    the function into its own file we can import it and define it like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: If you check our application again, you'll see that we get the same result as
    before. It is therefore important to consider where and how many times the filter
    will be used inside of the project. If you're using it on a specific component/instance
    (once) then you should place it locally; otherwise, place it globally.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at many Vue directives and their usage. This now
    gives us the power to declaratively change the way our templates appear on screen,
    including ways to capture user input, hook into events, filter view data, and
    much more. This chapter should be used as a reference whenever you're looking
    to implement directives in a Vue.js application.
  prefs: []
  type: TYPE_NORMAL
- en: Component-based architecture is an important concept that allows us to build
    scalable projects that range from personal to enterprise. In the next chapter,
    we'll be looking at how we can create these reusable components to encapsulate
    pieces of functionality within our projects.
  prefs: []
  type: TYPE_NORMAL
