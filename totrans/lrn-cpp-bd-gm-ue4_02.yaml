- en: Variables and Memory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To write your C++ game program, you will need your computer to remember a lot
    of things, such as where in the world the player is, how many hit points they
    have, how much ammunition they have left, where the items are in the world, what
    power-ups they provide, and the letters that make up the player's screen name.
  prefs: []
  type: TYPE_NORMAL
- en: 'The computer that you have actually has a sort of electronic sketchpad inside
    it called **memory***,* or RAM. Physically, computer memory is made out of silicon
    and it looks similar to what is shown in the following photograph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/50811780-25ce-481b-a8d4-3f90d20df7fc.png)'
  prefs: []
  type: TYPE_IMG
- en: Does this RAM look like a parking garage? Because that's the metaphor we're
    going to use.
  prefs: []
  type: TYPE_NORMAL
- en: RAM is short for random access memory. It is called random access because you
    can access any part of it at any time. If you still have some CDs lying around,
    they are an example of non-random access. CDs are meant to be read and played
    back in order. I still remember jumping tracks on Michael Jackson's *Dangerous*
    album way back when switching tracks on a CD took a lot of time! Hopping around
    and accessing different cells of RAM, however, doesn't take much time at all.
    RAM is a type of fast memory access known as flash memory.
  prefs: []
  type: TYPE_NORMAL
- en: RAM is called volatile flash memory because when the computer is shut down,
    the RAM's contents are cleared, and the old contents of the RAM are lost unless
    they were saved to the hard disk first.
  prefs: []
  type: TYPE_NORMAL
- en: 'For permanent storage, you have to save your data to a hard disk. There are
    two main types of hard disks:'
  prefs: []
  type: TYPE_NORMAL
- en: Platter-based **hard disk drives** (**HDDs**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Solid-state drives** (**SSDs**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SSDs are more modern than platter-based HDDs, since they use RAM's fast access
    (flash) memory principle. Unlike RAM, however, the data on an SSD persists after
    the computer is shut down. If you can get an SSD, I'd highly recommend that you
    use it! Platter-based drives are outdated.
  prefs: []
  type: TYPE_NORMAL
- en: While a program is running, it is much faster to access data stored in the RAM
    than it is to access it from either HDDs or SSDs, so we need a way to reserve
    a space on the RAM and read and write from it. Fortunately, C++ makes this easy.
  prefs: []
  type: TYPE_NORMAL
- en: Variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A saved location in computer memory that we can read or write to is called a
    **variable**.
  prefs: []
  type: TYPE_NORMAL
- en: A variable is a component whose value can vary. In a computer program, you can
    think of a variable as a container in which you can store some data. In C++, these
    data containers (variables) have types, and names you can use to refer to them.
    You have to use the right type of data container to save your data in your program.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to save an integer, such as 1, 0, or 20, you will use an `int` type
    container. You can use float-type containers to carry around floating-point (decimal)
    values, such as 38.87, and you can use string variables to carry around strings
    of letters (think of it as a *string of pearls*, where each letter is a pearl).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can think of your reserved spot in RAM like reserving a parking space in
    a parking garage: once we declare our variable and get a spot for it, no one else
    (not even other programs running on the same machine) will be given that piece
    of RAM by the operating system. The RAM beside your variable might be unused or
    it might be used by other programs.'
  prefs: []
  type: TYPE_NORMAL
- en: The operating system exists to keep programs from stepping on each other's toes
    and accessing the same bits of computer hardware at the same time. In general,
    civil computer programs should not read or write to each other's memory. However,
    some types of cheat programs (for example, maphacks) secretly access your program's
    memory. Programs such as PunkBuster were introduced to prevent cheating in online
    games.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring variables – touching the silicon
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reserving a spot in computer memory using C++ is easy. We want to name our chunk
    of memory that we will store our data in with a good, descriptive name.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, say we know that player **hit points** (**hp**) will be an integer
    (whole) number, such as 1, 2, 3, or 100\. To get a piece of silicon to store the
    player''s `hp` in memory, we will declare the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This line of code reserves a small chunk of RAM to store an integer (`int`
    is short for integer) called `hp`. The following is an example of our chunk of
    RAM used to store the player''s `hp`. This reserves a parking space for us in
    the memory (among all the other parking spaces), and we can refer to this space
    in memory by its label (`hp`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/43575241-0eb0-41bd-b8e3-0e5d9ce0182b.png)'
  prefs: []
  type: TYPE_IMG
- en: Among all the other spaces in memory, we get one spot to store our hp data.
  prefs: []
  type: TYPE_NORMAL
- en: When you name a variable, there are a few rules. Variable names can't start
    with a number, and there are certain "reserved words" the compiler won't let you
    use (usually because they are used by C++ itself). You will learn these as you
    learn more C++, or you can look for lists of reserved words online.
  prefs: []
  type: TYPE_NORMAL
- en: Notice how the variable space is type-marked in this diagram as `int` if it
    is a space for a double or a different type of variable. C++ remembers the spaces
    that you reserve for your program in memory not only by name, but by the type
    of variable it is as well.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we haven't put anything in hp's box yet! We'll do that later—right
    now, the value of the `hp` variable is not set, so it will have the value that
    was left in that parking space by the previous occupant (the value left behind
    by another program, perhaps). Telling C++ the type of the variable is important!
    Later, we will declare a variable to store decimal values, such as 3.75.
  prefs: []
  type: TYPE_NORMAL
- en: Reading and writing to your reserved spot in memory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Writing a value into memory is easy! Once you have an `hp` variable, you just
    write to it using the `=` sign:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Voila! The player has 500 hp.
  prefs: []
  type: TYPE_NORMAL
- en: 'Reading the variable is equally simple. To print out the value of the variable,
    simply put the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This will print the value stored inside the `hp` variable. The `cout` object
    is smart enough to figure out what type of variable it is and print the contents. 
    If you change the value of `hp` and then use `cout` again, the most up-to-date
    value will be printed, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Numbers and math
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The heading says it all; in this section, we'll dive into the importance of
    numbers and math in C++.
  prefs: []
  type: TYPE_NORMAL
- en: Numbers are everything
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Something that you need to get used to when you start computer programming is
    that a surprising number of things can be stored in computer memory as just numbers.
    A player's hp? As we just saw in the previous section, hp can just be an integer
    number. If the player gets hurt, we reduce this number. If the player gains health,
    we increase the number.
  prefs: []
  type: TYPE_NORMAL
- en: 'Colors can be stored as numbers too! If you''ve used standard image editing
    programs, there may be sliders that indicate color as how much red, green, and
    blue are being used, such as Pixelmator''s color sliders, if you''ve used that.
    Photoshop doesn''t have sliders but does show you the numbers and allow you to
    edit them directly to change the color. A color is then represented by three numbers.
    The purple color shown in the following screenshot is (R: `127`, G: `34`, B: `203`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/31daffe0-b152-444a-a39a-c7b14167ab65.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, Photoshop allows you to use other numbers to represent colors,
    such as HSB (hue, saturation, brightness), an alternate way of representing color,
    or CMYK (cyan, magenta, yellow, black) which is used for printing, since professional
    printing presses use those color inks in printing. For viewing on a computer monitor,
    you will generally stick to RGB color representation since that is what monitors
    use.
  prefs: []
  type: TYPE_NORMAL
- en: 'What about world geometry? These are also just numbers; all we have to do is
    store a list of 3D space points (*x*, *y*, and *z* coordinates) and then store
    another list of points that explain how those points can be connected to form
    triangles. In the following screenshot, we can see how 3D space points are used
    to represent world geometry:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ed292664-eb2e-4e40-94eb-3b3187163583.png)'
  prefs: []
  type: TYPE_IMG
- en: The combination of numbers for colors and numbers for 3D space points will let
    you draw large and colored landscapes in your game world.
  prefs: []
  type: TYPE_NORMAL
- en: The trick with the preceding examples is how we interpret the stored numbers
    so that we can make them mean what we want them to mean.
  prefs: []
  type: TYPE_NORMAL
- en: More on variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can think of variables as pet carriers. A cat carrier can be used to carry
    a cat but not a dog. Similarly, you should use a float-type variable to carry
    decimal-valued numbers. If you store a decimal value inside an `int` variable,
    it will not fit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: What's really happening here is that C++ does an automatic type conversion on
    `38.87`, *transmogrifying* it to an integer to fit in the `int` carrying case.
    It drops the decimal to convert `38.87` into the integer value `38`.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, for example, we can modify the code to include the use of three types of
    variables, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In the first three lines, we declare three boxes to store our data parts in,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'These three lines reserve three spots in memory (like parking spaces). The
    next three lines fill the variables with the values we desire, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In computer memory, this will look like the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/91199601-5d19-43f5-98e6-a7dea05d3d5d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can change the contents of a variable at any time. You can write a variable
    using the `=` assignment operator, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also read the contents of a variable at any time. That''s what the
    next three lines of code do, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Take a look at the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: There are two uses of the word `hp` in this line. One is between double quotes,
    while the other is not. Words between double quotes are always output exactly
    as you typed them. When double quotes are not used (for example, `<< hp <<`),
    a variable lookup is performed. If the variable does not exist, then you will
    get a compiler error (undeclared identifier).
  prefs: []
  type: TYPE_NORMAL
- en: There is a space in memory that is allocated for the name, a space for how many
    `goldPieces` the player has, and a space for the hp of the player.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what you should see when you run the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/aa24ff21-3d49-4d67-9c0c-ddd78d56a222.png)'
  prefs: []
  type: TYPE_IMG
- en: In general, you should always try to store the right type of data inside the
    right type of variable. If you happen to store the wrong type of data, your code
    may misbehave. For example, accidentally storing a float into an `int` variable
    will make you lose the decimal points, and storing the value of a char in an `int`
    will give you the ASCII value, but will no longer treat it as a letter. Sometimes,
    it even doesn't have any type of automatic type conversion so it won't know how
    to handle the value at all.
  prefs: []
  type: TYPE_NORMAL
- en: Math in C++
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Math in C++ is easy to do; `+` (plus), `-` (minus), `*` (times), and `/` (divide
    by) are all common C++ operations, and the proper **brackets**, **exponents***,*
    **division**, **multiplication**, **addition**, and **subtraction** (**BEDMAS**) order
    will be followed. For example, we can do as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, if you want to be absolutely sure of the order, it is always a good
    idea to use parentheses. Another operator that you might not be familiar with
    yet is % (modulus). Modulus (for example, 10 % 3) finds the remainder when `x`
    (10) is divided by `y` (3). See the following table for examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Operator (name) | Example | Answer |'
  prefs: []
  type: TYPE_TB
- en: '| + (plus) | 7 + 3 | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| - (minus) | 8 - 5 | 3 |'
  prefs: []
  type: TYPE_TB
- en: '| * (times) | 5*6 | 30 |'
  prefs: []
  type: TYPE_TB
- en: '| / (division) | 12/6 | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| % (modulus) | 10 % 3 | 1 (because 10/3 is 3 and the remainder = 1). |'
  prefs: []
  type: TYPE_TB
- en: However, we often don't want to do math in this manner. Instead, we usually
    want to change the value of a variable by a certain computed amount. This is a
    concept that is harder to understand. Say the player encounters an imp and is
    dealt 15 damage.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following line of code will be used to reduce the player''s `hp` by `15`
    (believe it or not):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: You might ask why. Because on the right-hand side, we are computing a new value
    for hp (`hp-15`). After the new value for hp is found (15 less than what it was
    before), the new value is written into the `hp` variable.
  prefs: []
  type: TYPE_NORMAL
- en: Think of `hp` as a painting at a specific spot on a wall. `-15` tells you to
    draw a mustache on the painting but leave it in the same place. The new, mustachioed
    painting is now `hp`.
  prefs: []
  type: TYPE_NORMAL
- en: Pitfall
  prefs: []
  type: TYPE_NORMAL
- en: An uninitialized variable has the bit pattern that was held in memory for it
    before. Declaring a variable does not clear the memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, say we used the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The second line of code reduces the hp by 15 from its previous value. What was
    its previous value if we never set `hp = 100` or so? It could be 0, but not always.
  prefs: []
  type: TYPE_NORMAL
- en: One of the most common errors is to proceed with using a variable without initializing
    it first.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a shorthand syntax for doing this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Besides `-=`, you can use `+=` to add an amount to a variable, `*=` to multiply
    a variable by an amount, and `/=` to divide a variable by an amount.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you''re using an `int` and want to increment (or decrement) it by 1, you
    can shorten the syntax. You don''t need to write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'You can instead do any of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Putting it before the variable increments or decrements it before the value
    is used (if you're using it in a larger statement). Putting it after updates the
    variable after it is used.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Write down the value of `x` after performing the following operations, then
    check with your compiler:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Exercises | Solutions |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `int x = 4; x += 4;` | `8` |'
  prefs: []
  type: TYPE_TB
- en: '| `int x = 9; x-=2;` | `7` |'
  prefs: []
  type: TYPE_TB
- en: '| `int x = 900; x/=2;` | `450` |'
  prefs: []
  type: TYPE_TB
- en: '| `int x = 50; x*=2;` | `100` |'
  prefs: []
  type: TYPE_TB
- en: '| `int x = 1; x += 1;` | `2` |'
  prefs: []
  type: TYPE_TB
- en: '| `int x = 2; x -= 200;` | `-198` |'
  prefs: []
  type: TYPE_TB
- en: '| `int x = 5; x*=5;` | `25` |'
  prefs: []
  type: TYPE_TB
- en: Generalized variable syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous section, you learned that every piece of data that you save
    in C++ has a type. All variables are created in the same way; in C++, variable
    declarations are of the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `variableType` object tells you what type of data we are going to store
    in our variable. The `variableName` object is the symbol we'll use to read or
    write to that piece of memory.
  prefs: []
  type: TYPE_NORMAL
- en: Primitive types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We previously talked about how all the data inside a computer will at some point
    be a number. Your computer code is responsible for interpreting that number correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is said that C++ only defines a few basic data types, as shown in the following
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `Char` | A single letter, such as *a*, *b*, or *+*. It is stored as a number
    value from -127 to 127 using ASCII, a standard that assigns specific number values
    to each character. |'
  prefs: []
  type: TYPE_TB
- en: '| `Short` | An integer from `-32,767` to `+32,768`. |'
  prefs: []
  type: TYPE_TB
- en: '| `Int` | An integer from `-2,147,483,647` to `+2,147,483,648`. |'
  prefs: []
  type: TYPE_TB
- en: '| `Long` | An integer from `-2,147,483,647` to `+2,147,483,648`. |'
  prefs: []
  type: TYPE_TB
- en: '| `Float` | Any decimal value from approx. `-1x10^(38)` to `1x10^(38)`. |'
  prefs: []
  type: TYPE_TB
- en: '| `Double` | Any decimal value from approx. `-1x10^(308)` to `1x10^(308)`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Bool` | True or false. |'
  prefs: []
  type: TYPE_TB
- en: There are unsigned versions of each of the variable types mentioned in the preceding
    table (except of course Bool, which wouldn't really make sense). An unsigned variable
    can contain natural numbers, including 0 (x >= 0). An unsigned `short`, for example,
    might have a value between `0` and `65535`. You can also get even bigger integers
    if necessary using `long long` or `long long int`.
  prefs: []
  type: TYPE_NORMAL
- en: The size of variables can sometimes be different for different compilers, or
    depending on whether you are compiling for a 32-bit or 64-bit operating system.
    Keep that in mind if you find yourself working on something different in the future.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we are focusing on Visual Studio or Xcode and (most likely) 64-bit.
  prefs: []
  type: TYPE_NORMAL
- en: If you're interested in the difference between float and double, please feel
    free to look it up on the internet. I will keep my explanations only for the most
    important C++ concepts used for games. If you are curious about something that's
    not covered by this text, feel free to look it up.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced variable topics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Newer versions of C++ have added a few new features related to variables, and
    there are others that haven't been mentioned yet. Here are a few things you should
    keep in mind.
  prefs: []
  type: TYPE_NORMAL
- en: Automatically detecting type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Starting with C++ 11, there is a new variable *type* you can use for cases
    where you may not be sure what type you are expecting to get. This new type is
    called `auto`. What it means is that it will detect the type of whatever value
    you first assign to it and then use that. Say you type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: If you do this, `x` will automatically be a float and `y` will be a Boolean.
    In general, you want to use the actual variable type if you know it (and most
    of the time you will), and as a beginner it is better to avoid using it. You should
    be able to recognize it when you see it, however, and know about it if you do
    run into a case where you need it eventually.
  prefs: []
  type: TYPE_NORMAL
- en: Enums
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Enums have existed for a long time, but starting with C++ 11 you have more
    control over them. The idea behind an enum is sometimes you want to track different
    types of things in a game, and you just want an easy way to give each a value
    that tells you what it is, and that you can later check. An enum looks like the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates each of these weapon types and assigns each a unique value by
    adding 1 to each, so knife would be equal to 1, axe to 2, and so on. Note that
    you do not need to set the first one to 0 (it does that automatically) but if
    you want to start with a different number you can do that (and it''s not just
    the first one that can be set to a specific value). You can also assign any `enum`
    member to a different one and it will have the same value (in this example, `defaultWeapon`
    has the same value as `mace`: 3). Any time you assign a specific value anywhere
    in the enum list, any types you add after that on the list will start going up
    by 1 from that value.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Enums have always contained an int value, but starting with C++ 11 you have
    the ability to specify a variable type. For example, you might want to do something
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: While you could do this with 0 and 1, you might find this more convenient in
    some cases.
  prefs: []
  type: TYPE_NORMAL
- en: const variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes you will have a value you do not want to change ever during the game.
    You don't want things such as the number of lives, your maximum hp, the amount
    of xp you need to reach a specific level, or your movement speed to change (unless
    your character does reach that level, in which case you might switch to a different
    constant value).
  prefs: []
  type: TYPE_NORMAL
- en: 'In some cases, an `enum` will work for this, but for single values it''s easier
    to create a new variable and declare it to be `const`. Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Putting `const` in front of the variable type tells the program to never allow
    that value to be changed, and if you try it will give you an error. Putting `k`
    in front of the variable name is a common naming convention for `const` variables.
    Many companies will insist that you follow that standard.
  prefs: []
  type: TYPE_NORMAL
- en: Building more complex types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It turns out that these simple data types alone can be used to construct arbitrarily
    complex programs. *How?* you ask. Isn't it hard to build a 3D game using just
    floats and integers?
  prefs: []
  type: TYPE_NORMAL
- en: It is not really difficult to build a game from `float` and `int`, but more
    complex data types help. It would be tedious and messy to program if we used loose
    floats for the player's position.
  prefs: []
  type: TYPE_NORMAL
- en: Object types – struct
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'C++ gives you structures to group variables together, which will make your
    life a lot easier. Take the example of the following block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The way this looks in memory is pretty intuitive; a **Vector** is just a chunk
    of memory with three floats, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f0a7f2fa-edae-43ba-8254-665d7b7eec5a.png)'
  prefs: []
  type: TYPE_IMG
- en: Don't confuse the `struct Vector` in the preceding screenshot with the `std::vector`
    of the **Standard Template Library** (**STL**)—we'll get into that later. The
    preceding `Vector` object is meant to represent a three-space vector, while the
    STL's `std::vector` type represents a collection of values.
  prefs: []
  type: TYPE_NORMAL
- en: Here are a couple of review notes about the preceding code listing.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, even before we use our `Vector` object type, we have to define it. C++
    does not come with built-in types for math vectors (it only supports scalar numbers,
    and they thought that was enough!). So, C++ lets you build your own object constructions
    to make your life easier. We first had the following definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This tells the computer what a `Vector` is (it's three floats, all of which
    are declared to be sitting next to each other in the memory). The way a `Vector`
    will look in the memory is shown in the preceding diagram.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we use our `Vector` object definition to create a Vector instance called
    `v`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Once you have an instance of a `Vector`, you can access the variables inside
    it using what we call **dot syntax**. You access the variable `x` on Vector `v`
    using `v.x`. The `struct` Vector definition doesn't actually create a Vector object,
    it just defines the object type. You can't do `Vector.x = 1`. Which object instance
    are you talking about? the C++ compiler will ask. You need to create a Vector
    instance first, such as Vector `v`. That creates an instance of a Vector and names
    it `v`. Then, you can do assignments on the `v` instance, such as `v.x = 0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then use this instance to write values into `v`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We used commas in the preceding code to initialize a bunch of variables on the
    same line. This is okay in C++. Although you can do each variable on its own line,
    the approach shown here is okay too.
  prefs: []
  type: TYPE_NORMAL
- en: 'This makes `v` look as in the preceding image. Then, we print them out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'In both the lines of code here, we access the individual data members inside
    the object by simply using a dot (`.`); `v.x` refers to the `x` member inside
    the object `v`. Each Vector object will have exactly three floats inside it: one
    called `x`, one called `y`, and one called `z`.'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise – player
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Define a C++ data struct for a `Player` object. Then, create an instance of
    your `Player` struct and fill each of the data members with values.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s declare our `Player` object. We want to group together everything to
    do with the player into the `Player` object. We do this so that the code is neat
    and tidy. The code you read in Unreal Engine will use objects such as these everywhere,
    so pay attention:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The line `me.position.x = me.position.y = me.position.z=0;` means `me.position.z`
    is set to `0`, and then that value is passed on to set `me.position.y` to 0, and
    then it is passed along and sets `me.position.x` to `0`.
  prefs: []
  type: TYPE_NORMAL
- en: The `struct Player` definition is what tells the computer how a `Player` object
    is laid out in memory.
  prefs: []
  type: TYPE_NORMAL
- en: I hope you noticed the mandatory semicolon at the end of the struct declaration.
    Struct object declarations need to have a semicolon at the end, but functions
    do not (we'll go over functions later). This is just a C++ rule that one must
    remember.
  prefs: []
  type: TYPE_NORMAL
- en: Inside a `Player` object, we declared a string for the player's name, a float
    for their hp, and a `Vector` object for their complete `x`, `y`, and `z` position.
  prefs: []
  type: TYPE_NORMAL
- en: When I say object, I mean a C++ struct (later, we will introduce the term *class*).
  prefs: []
  type: TYPE_NORMAL
- en: Wait! We put a Vector object inside a Player object! Yes, you can do that. Just
    make sure the Vector is defined in the same file.
  prefs: []
  type: TYPE_NORMAL
- en: After the definition of what a `Player` object has inside it, we actually create
    a `Player` object instance called `me` and assign it some values.
  prefs: []
  type: TYPE_NORMAL
- en: Pointers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A particularly tricky concept to grasp is the concept of pointers. Pointers
    aren't that hard to understand but can take a while to get a firm handle on. Pointers
    basically contain an address in memory where an object is stored, so they "point
    to" the object in memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Say we have, as before, declared a variable of the type `Player` in memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We now declare a pointer to the `Player`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The `*` changes the meaning of the variable type. The `*` is what makes `ptrMe`
    a pointer to a `Player` object instead of a regular `Player` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now want to link `ptrMe` to `me`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This linkage step is very important. If you don't link the pointer to an object
    before you use the pointer, you will get a memory access violation—an error that
    you are trying to access memory that you didn't set, so it could contain random
    data or even part of another program!
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ptrMe` pointer now points to the same object as `me`. Changing the values
    of the variables in the object `ptrMe` points to will change them in `me`, as
    shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/39c61393-1da4-452f-a007-f0252648101b.png)'
  prefs: []
  type: TYPE_IMG
- en: What can pointers do?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we set up the linkage between the pointer variable and what it is pointing
    to, we can manipulate the variable that it is pointed to through the pointer.
  prefs: []
  type: TYPE_NORMAL
- en: One use of pointers is to refer to the same object from several different locations
    in the code. You may want to store a pointer to it locally if you'll be constantly
    trying to access it, to make it easier to access. The `Player` object is a good
    candidate for being pointed to, since many places in your code could be accessing
    it constantly.
  prefs: []
  type: TYPE_NORMAL
- en: You can create as many pointers as you wish to the same object, but you'll want
    to keep track of them all (unless you use smart pointers, which we will get to
    later). Objects that are pointed to do not necessarily know that they are being
    pointed at, but changes can be made to the object through the pointers.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, say the player got attacked. A reduction in their hp will be
    the result, and this reduction will be done using the pointer, as shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: When using a pointer, you need to use `->` instead of `.` to access the variables
    in the object pointed to.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how the `Player` object looks now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/aa4316de-1a4a-43bc-a029-729cf5c3125e.png)'
  prefs: []
  type: TYPE_IMG
- en: So, we changed `me.name` by changing `ptrMe->name`. Because `ptrMe` points to
    `me`, changes through `ptrMe` affect `me` directly.
  prefs: []
  type: TYPE_NORMAL
- en: Address of operator (&)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Notice the use of the `&` symbol in the preceding code example. The `&` operator
    gets the memory address where a variable is stored. A variable's memory address
    is a location in the computer memory space that is reserved to store the variable's
    value. C++ is able to get the memory address of any object in your program's memory.
    The address of a variable is unique and also kind of random.
  prefs: []
  type: TYPE_NORMAL
- en: 'Say we print the address of an integer variable, `x`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'On the first run of the program, my computer prints the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'This number (the value of `&x`) is just the memory cell where the `x` variable is
    stored. What this means is that in this particular launch of the program, the `x`
    variable is located at memory cell number `0023F744`, as shown in the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6bdb0610-ff05-47f6-a361-5b6026e67f61.png)'
  prefs: []
  type: TYPE_IMG
- en: You may wonder why the preceding number contains an `F`. Addresses are in hexadecimal
    (base 16) so since you run out of numerical digits after 9, but you can't really
    fit two digits in 1, you set the values that would be 10-15 to A-F instead. So
    A = 10, B = 11, and in this case F = 15.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, create and assign a pointer variable to the address of `x`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'What we''re doing here is storing the memory address of `x` inside the `px`
    variable. So, we are metaphorically pointing to the `x` variable using another
    different variable called `px`. This might look similar to what is shown in the
    following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6e560752-06c4-46e1-b673-7e7486f96405.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, the `px` variable has the address of the `x` variable inside it. In other
    words, the `px` variable is a reference to another variable. De-referencing `px`
    means to access the variable that `px` is referencing. De-referencing is done
    using the `*` symbol:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Using nullptr
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `nullptr` variable is a pointer variable with the value `0`. In general,
    most programmers like to initialize pointers to `nullptr` (`0`) on the creation
    of new pointer variables. Computer programs, in general, can't access the memory
    address `0` (it is reserved), so if you try to reference a null pointer, your
    program will crash.
  prefs: []
  type: TYPE_NORMAL
- en: '*Pointer Fun with Binky* is a fun video about pointers. Take a look at [http://www.youtube.com/watch?v=i49_SNt4yfk](http://www.youtube.com/watch?v=i49_SNt4yfk).'
  prefs: []
  type: TYPE_NORMAL
- en: Smart pointers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pointers can be hard to manage. Once we start creating and deleting new objects
    later in this book, we may not know where all the pointers are that point to a
    specific object. It can be too easy to delete an object that another pointer is
    still using (leading to a crash), or to stop pointing to an object from the only
    pointer to it and leave it floating in memory with nothing referencing it (this
    is called a memory leak, and will slow down your computer).
  prefs: []
  type: TYPE_NORMAL
- en: Smart pointers keep track of how many references exist to a specific object,
    and will automatically increment or decrement this number as things change in
    the code. This makes it much easier to control what is happening, and in real-world
    programming it is preferable to using regular pointers when possible.
  prefs: []
  type: TYPE_NORMAL
- en: People used to have to write their own smart pointers, but not since C++ 11\.
    There is now a `shared_ptr` template available (we'll talk about templates and
    the STL later). This will automatically keep track of pointers to an object, and
    will automatically delete that object if nothing else is referencing it, preventing
    memory leaks. This is why it is better to use smart pointers than pointers, since
    regular pointers could wind up pointing to objects that have been deleted elsewhere
    in the code.
  prefs: []
  type: TYPE_NORMAL
- en: Input and output
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In programming, you constantly have to pass information to the user, or get
    information from the user. For simple cases, such as the ones we will be starting
    with (and many times for finding errors later), you need to input and output standard
    text and numbers. C++ makes this easy.
  prefs: []
  type: TYPE_NORMAL
- en: The cin and cout objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve already seen how `cout` works in previous examples. The `cin` object
    is the way C++ traditionally takes input from the user into the program. The `cin` object
    is easy to use, because it looks at the type of variable it will put the value
    into and uses that to determine the type being put inside it. For example, say
    we want to ask the user his age and store it in an `int` variable. We can do that
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: When you run this, it will print `What is your age?` and wait for your response.
    Type in a response and hit *Enter* to input it. You might want to try typing in
    other things besides `int` variables just to see what happens!
  prefs: []
  type: TYPE_NORMAL
- en: The printf() function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although we have used `cout` to print out variables so far, you should also
    know about another common function that is used to print to the console. This
    function is called the `printf` function, and it originally comes from C. The
    `printf` function is included in the `<iostream>` library, so you don't have to
    `#include` anything extra to use it. Some people in the gaming industry prefer
    `printf` to `cout`, so let's introduce it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s proceed to how `printf()` works, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Downloading the example code
  prefs: []
  type: TYPE_NORMAL
- en: You can download the example code files from your account at [http://www.packtpub.com](http://www.packtpub.com)
    for all the Packt books you have purchased. If you purchased this book elsewhere,
    you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files emailed directly to you.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start with a format string. The format string is like a picture frame, and
    the variables will get plugged in at the locations of the `%` in the format string.
    Then, the entire thing gets dumped out to the console. In the preceding example,
    the integer variable will be plugged into the location of the first `%` (`%d`),
    and the character will be plugged into the location of the second `%` (`%c`),
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0f75934f-d8a3-4f1f-92c3-8e724477863f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You have to use the right format code to get the output to format correctly;
    take a look at the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Data type | Format code |'
  prefs: []
  type: TYPE_TB
- en: '| `Int` | `%d` |'
  prefs: []
  type: TYPE_TB
- en: '| `Char` | `%c` |'
  prefs: []
  type: TYPE_TB
- en: '| `String` | `%s` |'
  prefs: []
  type: TYPE_TB
- en: 'To print a C++ string, you must use the `string.c_str()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The `s.c_str()` function accesses the C pointer to the string, which `printf`
    needs.
  prefs: []
  type: TYPE_NORMAL
- en: If you use the wrong format code, the output won't appear correctly or the program
    might crash.
  prefs: []
  type: TYPE_NORMAL
- en: You may also find cases where you need to use this type of formatting to set
    up strings, so it is good to know. But if you'd prefer to avoid having to remember
    these different format codes, just use `cout`. It will figure the type out for
    you. Just make sure you use whatever standard the company you eventually work
    for prefers. It's generally a good idea to do that with most things in programming.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ask the user their name and age and take them in using `cin`. Then, issue a
    greeting for them at the console using `printf()` (not `cout`).
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is how the program will look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: A string is actually an object type. Inside, it is just a bunch of chars!
  prefs: []
  type: TYPE_NORMAL
- en: Namespaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve seen namespaces so far in the case of `std`, and we''ve mostly avoided
    that issue by putting the following at the top of the files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: But, you should know what that means for the future.
  prefs: []
  type: TYPE_NORMAL
- en: Namespaces are ways to group together code that is related, and it allows you
    to use the same variable names in different namespaces without any naming conflicts
    (unless of course you put `using namespace` for both at the top, which is why
    many people prefer to not use that).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can create your own namespace in a C++ file like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you''ve created your namespace, you can then access that code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Or, you can put in a using statement at the top (just make sure the name isn't
    used for something else). But, in general you don't want to use this for more
    complex programs, since a namespace allows you to reuse the same variable name
    in different namespaces, so if you use it with a namespace with a variable in
    it that has the same name as one in the current namespace and try to access it,
    the compiler won't know which one you are referring to, which would cause a conflict.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we spoke about variables and memory. We talked about mathematical
    operations on variables and how simple they were in C++.
  prefs: []
  type: TYPE_NORMAL
- en: We also discussed how arbitrarily complex data types can be built using a combination
    of these simpler data types, such as floats, integers, and characters. Constructions
    such as this are called objects. In the next chapter, we will start talking about
    what we can do with these objects!
  prefs: []
  type: TYPE_NORMAL
