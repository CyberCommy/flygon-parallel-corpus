- en: Primitive and Built-In Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have explored the meaning of clean code from several different perspectives.
    We've explored how the code we write allows our users to wield remarkable complexity
    by leveraging abstractions. We've gone on to discuss the tenets of clean code,
    such as reliability and usability, and the various traps and challenges to watch
    out for when pursuing these goals.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we'll be exploring the JavaScript language itself, in great
    detail, including both the more common language constructs and the more obscure
    and confusing aspects. We'll be applying our accrued wealth of knowledge about
    clean code to all these parts of the language and will build an understanding
    of JavaScript that's tailored purely to the creation of clean code.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll begin by looking at the most atomic part of JavaScript: the primitive
    values that serve as the building blocks for any program. Then, we''ll move on
    to non-primitive values, known as **objects**. In our exploration of these types,
    we will, through examples, be exposing the semantics that make each type unique
    and the pitfalls to avoid in their usage. The crucial knowledge that we''ll gain
    in this chapter will be applied in later chapters as we build up a truly complete
    knowledge of what it means to write clean code in JavaScript.'
  prefs: []
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you should feel comfortable in the following topic
    areas:'
  prefs: []
  type: TYPE_NORMAL
- en: Primitive types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arrays and iterables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regular expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Primitive types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A primitive type in JavaScript is any value that is not an object and thus
    does not have any methods or properties. There are seven primitive types in JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: Number
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: String
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Boolean
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Undefined
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Null'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: BigInt
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Symbol
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, we'll explore the common characteristics among these primitives
    and delve into each individual type to explore how it works and what potential
    hazards exist in its usage. We'll gain an appreciation for how the JavaScript
    language itself is just a set of distinct abstractions that, when wielded masterfully,
    can make easy work of any problem domain.
  prefs: []
  type: TYPE_NORMAL
- en: Immutability of primitives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All primitive values are immutable, meaning that you cannot mutate their values.
    This is a core part of their primitiveness. You cannot, for example, change the
    number value of `3.14` to `42`, or change the value of a string to its uppercased
    variation.
  prefs: []
  type: TYPE_NORMAL
- en: '**But I can change the value of a string to its uppercased variation!** You
    may be confused right now if you recall being able to do this. But there is a
    crucial distinction to be made here between the reassignment of variables to new
    primitive values, which is fully possible (and likely what you''re remembering),
    and the mutation of primitive values, which is not possible.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When we reassign a variable, giving it a new value, we are not changing the
    value itself; we are only changing which value the variable refers to, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note how `copy` has remained lowercase. The primitive value `simon` has not
    been mutated; instead, a new primitive value has been derived from it, via the
    `toUpperCase` method, and then assigned to the variable that previously held the
    lowercase variant.
  prefs: []
  type: TYPE_NORMAL
- en: Primitive wrappers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You'll remember that we mentioned that primitive values don't have methods as
    they are not objects. So, how exactly are we able to call `toUpperCase` on the
    preceding string? Is that not a method? Yes, it is. And to allow us to access
    this method, JavaScript wraps primitive values in their respective wrapper objects
    at the time of property access. This occurs for all primitive values, apart from `null`
    and `undefined`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Primitive values, in these moments of being wrapped, remain immutable but,
    via their wrapped instance, provide access to properties and methods. A string
    value would be wrapped in a `String` instance, while a number value would be wrapped
    in a `Number` instance. The same would occur for all other non-null and non-undefined
    primitives. You are free to instantiate these wrapper objects yourself: you will
    observe that they no longer behave like primitives, though; they are objects,
    and, as such, you can add and mutate properties on them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: If you require an object to add custom properties to, it is best to use a plain
    object. Using wrapper objects for anything other than wrapping their primitive
    values is an anti-pattern as it would not be expected by other programmers. Nonetheless,
    it is useful to observe and remember the differences between primitives and their
    respective wrapper objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Invoking a wrapper constructor (for example, `Number`, `String`, and so on)
    as a regular function has a unique behavior. Instead of returning a new wrapper
    instance, it will cast the value to a particular type and return a regular primitive.
    This is quite useful when you''re casting one type to another:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Invoking wrapper constructors as functions, as we have done here, is a useful
    casting technique, though it's not the only one. We'll cover typecasting and coercion
    in a lot more detail in [Chapter 7](43f1d47f-08cd-4c87-a731-7c359ef3bedd.xhtml), *Dynamic
    Typing*.
  prefs: []
  type: TYPE_NORMAL
- en: The falsy primitives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In JavaScript, all the values in Boolean contexts will evaluate to either `true`
    or `false`. To describe this behavior, we usually refer to values as either truthy
    or falsy. To determine the truthiness of a value, we can simply pass it to the
    `Boolean` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'There are only eight falsy values in JavaScript, and all of them are primitive
    types:'
  prefs: []
  type: TYPE_NORMAL
- en: '`null`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`undefined`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`+0`  or  `-0` (zero, a number)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`false` (a Boolean)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`""` (an empty string)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0n` (zero, a `BigInt`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NaN` (not a number)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All values that are not falsy are, therefore, truthy. Throughout this and the
    next chapter, we will be exploring the implications of these truthy and falsy
    values. For now, it''s only important to know that the preceding falsy values
    will, when used in conditional or logical contexts, behave as if they were false.
    A falsy value, when used in an `if` statement, for example, would act the same
    as if it were false:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The existence of these falsy values means that we must be wary of how we check
    for certain conditions. It''s easy to fall into the trap of testing for the existence
    of a certain value state by using only its truthiness to determine existence.
    For example, let''s say that we need to be able to check for the age of a person:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a contrived example, but we can imagine a system in which the identities
    of individuals need to be processed somehow, perhaps through a medical application.
    Checking for the existence of the `age` property is not going to do what''s intended
    if the age happens to be 0\. Perhaps the system needs to cater to the eventuality
    of a newborn baby being entered into the system, but suddenly it breaks because
    the `age` is `0`. In such scenarios, it''s best to be preemptively explicit, even
    if you don''t expect odd falsy values. In this context, we likely want to check
    for either `null` or `undefined`, so we should explicitly do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This code is far more resilient to the possible variabilities of the `age` property.
    We could also, perhaps, be more in line with our requirements and check only for
    the specific characteristics that we are interested in, such as that the age property
    is a number within specific bounds. The point is that it's better to be explicit
    in Boolean contexts such as `if` statements so that you don't run into an unexpected
    falsy value.
  prefs: []
  type: TYPE_NORMAL
- en: Number
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The number primitive type is used to express numerical data. It stores this
    data in the double-precision 64-bit floating-point format (IEEE 754). 64 bits
    here refers to there being 64 binary digits available to store information. The
    entire 64-bit format that''s used in the IEEE 754 standards can be broken down
    into three chunks:'
  prefs: []
  type: TYPE_NORMAL
- en: '**1 bit for the sign of the number being represented**: Whether the number
    is positive or negative'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**11 bits for the exponent of the number**: This tells us where the radix or
    decimal dot resides'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**52 bits for what''s termed the fraction or significand**: This tells us the
    integer value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A side effect of this floating-point formation means that there are technically
    two zeros: positive zero (`+0`) and negative zero (`-0`). Thankfully, in JavaScript,
    you don''t have to be explicit when checking for these values. Both will return
    true when compared with the strict equality operator ( `+0 === -0`) and both are
    considered falsy.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Technically, there are 53 bits available (not 52) for the expression of an
    integer value as the leading bit of the significand field resides within the exponent
    field. This is an important clarification as it has a direct effect on how much
    precision we can get from JavaScript numbers. Having 53 bits available to express
    an integer value means that any numbers greater than *2^(53)-1* are considered
    unsafe. These safety limits are available as constants on the `Number` object:'
  prefs: []
  type: TYPE_NORMAL
- en: Integers larger than `2^(53)` or `9007199254740991` (`Number.MAX_SAFE_INTEGER`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integers smaller than `-2^(53)` or `-9007199254740991` (`Number.MIN_SAFE_INTEGER`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The loss of precision beyond these bounds can be observed if we try to perform
    addition on the upper limit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see that the evaluated additions are incorrect. Beyond `MAX_SAFE_INTEGER`,
    all mathematical operations will be similarly imprecise.
  prefs: []
  type: TYPE_NORMAL
- en: It is still possible to express values larger than `MAX_SAFE_INTEGER` within
    JavaScript. Many values up to `2^(1024)` (`Number.MAX_VALUE`) can be expressed,
    but many cannot. Therefore, it is considered very unwise to attempt to express
    numbers beyond `Number.MAX_SAFE_INTEGER`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To sum this up, any values between `Number.MIN_SAFE_INTEGER` and `Number.MAX_SAFE_INTEGER`
    are safe to use and will provide integer precision, while values beyond these
    bounds should be considered unsafe. If we feel ourselves needing an integer outside
    of these bounds, then we can use JavaScript''s `BigInt` primitive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll explore the `BigInt` primitive further in a later part of this section.
    For now, just remember to always consider the largeness of your numbers and whether
    they can be fully accommodated by JavaScript''s `Number` type. It''s also important
    to consider the precision of decimal values (such as in fractions) as well. When
    expressing decimals in JavaScript, you''ll likely encounter issues like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This is due to inherent mechanism by which fractions are expressed in the floating-point
    standard. You can imagine that if we were interested in querying whether a decimal
    is equal to, greater than, or less than another value, it would be as simple as
    using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'But `yay()` will never run. To get around this problem, there are two options.
    The first involves something called the epsilon. The epsilon is the margin of
    error inherent to floating-point math, and JavaScript makes this available to
    use as `Number.EPSILON`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a very tiny number, but it must be taken into account if we are to
    have a hope of doing basic mathematical operations on decimals. If we wish to
    compare two numbers, we can simply subtract them from each other and check that
    the margin is less than the `EPSILON`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The other approach we can take is to convert any decimals we''re dealing with
    into integers expressed by either `Number` or `BigInt` types. So, if we have a
    need to represent values from `0` to `1` with a precision of eight decimal places,
    for example, then we can simply multiply these values by `100,000,000` (or `10⁸`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now, we are free to conduct integer math on these values and divide them back
    down into their fractions when done. It's crucial to note that any decimal value
    longer than 15 digits cannot be expressed in JavaScript's `Number` type, so you'll
    need to explore other options. JavaScript currently doesn't have a native `BigDecimal`
    type, but there are many third-party libraries available that fulfill a similar
    purpose (you can easily find these online).
  prefs: []
  type: TYPE_NORMAL
- en: If you ever find yourself needing to operate on large or very precise numbers
    in JavaScript, or if your code concerns sensitive matters such as finance, medicine,
    or science, it's absolutely crucial to take the time to fully understand what
    levels of precision you require and whether JavaScript can natively support those
    needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s one more topic to discuss under the `Number` type, and that is `NaN`. `NaN`
    is a primitive that technically belongs to the `Number` type. It represents a
    failure to parse something as a number; for example, `Number(''wow'')` evaluates
    to `NaN`. Since `typeof NaN` is a `number`, we should check for a valid number
    in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The value `NaN` can create a headache when its existence is not foreseen. It'll
    usually crop up in areas where you're attempting to cast strings to numbers or
    where this happens implicitly (coercion).
  prefs: []
  type: TYPE_NORMAL
- en: We'll be covering the topic of coercion, casting, and detection more in the
    next chapter. This will include a section where we get into the complexity of
    `NaN` and compare `isNaN()`, the global function, to the slightly different `Number.isNaN()`.
    For now, it's only important to appreciate that `NaN` is its own distinct value
    and is itself, oddly, considered a number within JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is another value encapsulated by the `Number` type that is not a normal
    number: `Infinity`. You will receive `Infinity` when you attempt to do mathematical
    operations such as dividing by `0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '`Infinity`, like `NaN`, is a globally available primitive value that you can
    reference and check for:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'There is also `-Infinity`, which is technically a distinct value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '`Infinity`, like `NaN`, is of the `Number` type, so when passed to the `typeof`
    operator, it will evaluate to `"number"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Outside of `Infinity`, `-Infinity`, and `NaN`, all values that are of the `Number`
    type can be considered regular everyday numbers. Overall, and for most use cases,
    the `Number` type is very simple to use and operate on. It is, however, vital
    to know about its limitations, many of which we've covered here so that you can
    make an informed decision about when it may not be appropriate to use.
  prefs: []
  type: TYPE_NORMAL
- en: String
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `String` type in JavaScript allows us to express sequences of characters.
    It is usually used to encapsulate words, sentences, lists, HTML, and many other
    forms of text-like content.
  prefs: []
  type: TYPE_NORMAL
- en: 'Strings are expressed by delimiting sequences of characters with either single
    quotes, double quotes, or backticks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Only backtick-delimited strings, known as **template literals** (or template
    strings), can occupy multiple lines. Single quote- or double quote-delimited strings
    can technically be spread along multiple lines as well, but this is only achieved
    by escaping their invisible newline characters (with a `\` character), which effectively
    removes the newlines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Nowadays, template literals are preferred as they retain newlines and allow
    us to interpolate arbitrary expressions, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Strings come with a number of curious challenges once your usage exceeds the
    most simple use cases. Under the surface, the humble string is masking a miraculous
    scale of complexity in the form of Unicode.
  prefs: []
  type: TYPE_NORMAL
- en: Unicode is an industry standard for the encoding, representation, and handling
    of text that's used in writing systems around the world. The Unicode standard
    contains over 130,000 characters, including all of your favorite emojis.
  prefs: []
  type: TYPE_NORMAL
- en: 'To step beneath the veneer of the String abstraction slightly, we can say that
    Strings in JavaScript are really just an ordered sequence of 16-bit unsigned integers.
    Each of these integers is interpreted as a UTF-16 code unit. UTF-16 is a type
    of encoding for the Unicode character set. Using it, we are able to express hundreds
    of thousands of valid Unicode code points. This means that we can express emojis,
    many languages, and a myriad of Unicode oddities via our strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/1cfee330-5c7a-4adf-9e65-53644f2acf6e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'A Unicode code point is a character (such as the letter *B*, a question mark,
    or a smiling emoji). We can express a code point by using one or more UTF-16 code
    units. Most code points that we use from day to day only need a single code unit.
    These are known as **scalars**. There are, however, quite a few Unicode code points
    that require a pair of code units (known as a **surrogate pair**). The panda emoji
    is an example of such a surrogate pair:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/932e06b3-c837-45a4-9998-fa9e94b15f83.png)'
  prefs: []
  type: TYPE_IMG
- en: Since UTF-16 only has 16 bits to work with, it has to use pairs of 16-bit integers
    to express some characters. Naturally, if we're using UTF-32 encoding (with 32
    bits to play with), then we'd be able to express the panda emoji in a single 32-bit
    integer.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we've used `charCodeAt()` to determine the individual UTF-16 code units
    of the Panda emoji and we've found that these are the *55,357^(th)* and *56,380^(th)*
    decimal code units within Unicode. Since there are so many code units, it is simpler
    and more convenient to use hexadecimal digits to express them, so we can say that
    the panda emoji is expressed by code units  `U+D83D` and `U+DC3C` (Unicode hexadecimal
    values are conventionally prefixed with `U+`).
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to surrogate pairs, there is another type of combination that''s
    useful to know about. The *Combining Code Point* enables certain traditional *non-combining* code
    points to be augmented into new characters. Examples of this include traditional
    Latin characters that can be augmented with accents or other augmentations, such
    as the combining tilde:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/74a8f34d-49af-4c20-91ec-ff6a9c3a72b3.png)'
  prefs: []
  type: TYPE_IMG
- en: We've chosen to express this particular combining character via a Unicode escape
    sequence (`\u0303`). The format of `\uXXXX` allows us to express Unicode code
    units between `U+0000` and `U+FFFF` within JavaScript strings.
  prefs: []
  type: TYPE_NORMAL
- en: The range of Unicode between `U+0000` and `U+FFFF` is known as the **Basic Multilingual
    Plane** (**BMP**) and includes the most commonly used everyday characters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our panda emoji, as we''ve already seen, is quite an obscure symbol. It does
    not exist on the BMP and is thus expressed by a surrogate pair of two UTF-16 code
    units. We can express these individually in JavaScript strings via two Unicode
    escape sequences:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/027dce04-a27f-41cb-8b99-e4c742858944.png)'
  prefs: []
  type: TYPE_IMG
- en: 'More obscure and ancient symbols are found in the *supplementary* (or *astral*)
    planes between `U+010000` and `U+10FFFF`. The escaping format of `\uXXXX` does
    not have enough slots for us to express these. Symbols within the astral planes
    require at least five hexadecimal digits to express, so we must use the more recently
    introduced escape sequence format of `\u{X}`. This provides up to six hexadecimal
    slots (`\u{XXXXXX}`) and can thus express over 1 million different code points.
    Using this type of escape sequence, we can express our Panda emoji directly via
    its 32-bit representation (`U+1F43C`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/8ac0deef-10e0-4718-a4f9-686f78db91fa.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The newer `\u{X}` escape sequence is really convenient and goes some way in
    making Unicode less burdensome to use than JavaScript. But there is still a little
    more complexity to explore. Surrogate pairs and combining characters are examples
    where UTF-16 code units are combined to produce individual symbols. On top of
    this, there are longer sequences called **grapheme clusters**. These are used
    to express combinations of code points that can be combined to create an aggregate
    symbol:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/1eb89558-39ae-414f-a0fd-fa6322c9fe8b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Wow! Unicode is a pretty incredible feat of engineering, but it can make things
    complicated for us. The ability to combine Unicode in all of these ways (combining
    characters, surrogate pairs, and grapheme clusters) creates a challenge for us.
    JavaScript strings, as you may know, have a `length` property. This property returns
    the number of code units in a given string (that is, the number of 16-bit integers
    in the entire sequence). For most strings, this is straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'However, as we know, we are able to combine code units to create code points
    and we are also able to combine code points to create grapheme clusters. This
    means the `length` property, which is only concerned with the 16-bit code units,
    can give us unexpected results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/db5089b2-18e2-45bf-9195-d6d02babb3a3.png)'
  prefs: []
  type: TYPE_IMG
- en: The smiling-face emoji is composed of two code units, so JavaScript correctly
    tells us this string has a length of `2`. But this may not be what we expect or
    desire. It's even more challenging when we're dealing with grapheme clusters that
    may use a dozen different code units to express a single symbol.
  prefs: []
  type: TYPE_NORMAL
- en: Watch out when attempting to truncate or establish the width of a piece of text
    within a UI using only its `length` property. Due to the fact that many Unicode
    symbols may be expressed by multiple code units, using `length` alone is not reliable.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this section, we've explored the tricky domain of Unicode. Va our
    new understanding of it, we're now far more empowered to cleanly work with strings
    in JavaScript. Excluding the complexity of Unicode, the behavior of strings in
    JavaScript is rather intuitive and shouldn't cause many headaches as long as we
    use them in a way that clearly communicates our intent.
  prefs: []
  type: TYPE_NORMAL
- en: Boolean
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Boolean` primitive type in JavaScript is used to represent either `true`
    or `false`. These polar opposites are its only values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Semantically, Booleans are used to represent real-life or problem domain values
    that can be considered on or off (`0` or `1`), for example, whether a feature
    is enabled, or whether the user is over a certain age. These are Boolean characteristics
    and so are appropriate to express via Boolean values. We can use such values to
    dictate control flow within a program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Boolean` primitive, just like `String` and `Number`, can be manually wrapped
    in a wrapper instance like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that, once you do this, `Boolean` will behave just like any other object
    in conditional statements. So, the following conditional statement will succeed,
    even though the wrapped primitive value is `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The `Boolean` instance here is not equivalent to its primitive value; it merely contains its
    primitive value. `isFalseObj` will behave just like any other Object in a `Boolean`
    context, resolving to `true`. Manually wrapping a `Boolean` like this is not especially
    useful and should be avoided as an anti-pattern in most programs as it doesn't
    behave according to Boolean semantics and may produce unexpected results.
  prefs: []
  type: TYPE_NORMAL
- en: '`Boolean` primitives are returned by JavaScript''s logical operators such as
    greater than or equal to (`>=`) or strict equality (`===`). We''ll cover these
    in more detail in [Chapter 8](d8c326c9-db6f-4562-b92d-975dd0159182.xhtml),*Operators*.'
  prefs: []
  type: TYPE_NORMAL
- en: BigInt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `BigInt` primitive type in JavaScript is used to represent an integer of
    arbitrary precision. This means that it can be used to represent integers that
    are not able to be precisely represented by JavaScript''s `Number` type (anything
    larger than ~*2^(53)*). Literal BigInts are declared by suffixing any sequence
    of digits with the `n` character, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '`BigInt` is capable of representing integers of arbitrary precision, meaning
    that you can store integers of unlimited length. This is especially useful in
    financial applications or any case where high-accuracy integers need to be expressed
    and operated on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A `BigInt` can only operate on itself, and is therefore not compatible with
    many of JavaScript''s native `Math` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'All native mathematics operators work with `BigInt` as long as both operands
    are of the same type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if one operand is a `BigInt` and the other is a `Number`, then you''ll
    receive a `TypeError`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The semantics of a `BigInt` is similar to `Number`: any value that is intuitively
    numerical and can be expressed as an integer can be stored in either `BigInt`
    or `Number`, depending on the extent of precision that it requires.'
  prefs: []
  type: TYPE_NORMAL
- en: Symbol
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A `Symbol` primitive is used to represent an entirely unique value. Symbols
    are created via invoking the `Symbol` function, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'You can optionally pass an initial argument to this function to annotate your
    symbol for your own debugging purposes, but this is not necessary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Symbols are used to act as property keys where uniqueness is required or where
    you want to store metadata on objects. When you add a property to an object with
    a `Symbol` key, it will not be iterated over by normal object iteration approaches
    (such as `for...in`). `Symbol` keys of an object can only be retrieved via `Object.getOwnPropertySymbols`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Since `Symbol` keys exist in an explicit but hidden manner, they are useful
    for storing programmatic information semantically that''s unrelated to the core
    data of the object but useful in fulfilling some programmatic need. For example,
    you may have a logging library and wish to annotate specific objects with custom-rendering
    functions that log in a specific way. Such a need could be easily fulfilled with
    symbols:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: There are not many everyday situations that would necessitate the creation and
    usage of new symbols, but there are many instances of prescribing native behavior
    by such symbols. For example, you can define a custom iterator for your object
    by using the `Symbol.iterator` property. We will cover this in greater detail
    in the *Arrays and iterables* section, later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'null'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `null` primitive type is used to express the intentional absence of a value.
    It is a type with only one value: the only null value is `null`.'
  prefs: []
  type: TYPE_NORMAL
- en: The semantics of `null` are crucially different from `undefined`. The `undefined` value
    is used to indicate something that is not declared or defined, while `null` is
    an explicitly declared absent value. We usually use the `null` value to indicate
    that a value is either explicitly not yet set or, for whatever reason, unavailable.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s consider an API where we specify various properties related
    to a restaurant review:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The `null` value, in this context, means that we do not know the value of `hasParking` yet.
    When we have the necessary information, we can specify `hasParking` as either `true`
    or `false` (`Boolean`), but to express our ignorance of its true value, we're
    setting it to `null`. We could also completely leave the value out, meaning that
    it would effectively be `undefined`. The key difference is that using `null` is
    always proactively done, while `undefined` is the result of wh something isn't
    done.
  prefs: []
  type: TYPE_NORMAL
- en: 'A `null` value, as we mentioned previously, is always falsy, meaning that it
    will always evaluate to `false` in a `Boolean` context. So, if we attempt to use
    `null` in a conditional statement, then it would not succeed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'It is important to check for the exact values we want so that we can avoid
    bugs and communicate effectively to the people reading our code. In this case, 
    we may wish to explicitly check for `undefined` and `null` as we want to execute
    distinct code for that case versus the case of `false`. We could accomplish this
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also use the abstract equality operator (*`==`*) to compare to `null`,
    which will helpfully evaluate to `true` if the operand is either `null` or `undefined`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This is, in fact, doing the same as the more explicit comparison, but is far
    more succinct. Unfortunately, it's not very clear that its intention is to check
    for both `null` and `undefined`. We should usually prefer being explicit as this
    allows us to communicate our intent to other programmers in a more efficient way.
  prefs: []
  type: TYPE_NORMAL
- en: A final trap to avoid with null is the `typeof` operator. Due to some legacies
    of the JavaScript language, `typeof null` will, rather confusingly, return `"object"`
    and is therefore entirely unreliable.
  prefs: []
  type: TYPE_NORMAL
- en: More information about `typeof` and detection of the `null` type can be found
    in [Chapter 7](43f1d47f-08cd-4c87-a731-7c359ef3bedd.xhtml), *Dynamic Typing*,
    in the *Detection* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, there you have it. Null is a simple enough value and, insofar as clean
    code is concerned, you won''t go wrong if you remember two key points: that it
    should only be used to express the intentional absence of a value and that it
    should, ideally, be checked explicitly (prefer `value === null`).'
  prefs: []
  type: TYPE_NORMAL
- en: undefined
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `undefined` primitive type expresses that something hasn''t been defined
    yet or remains undefined. Like `null`, it is a type with only one value (`undefined`). Unlike
    `null`, an `undefined` value should not be explicitly set, but may be returned
    by the language when something does not have a value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Undefined is best thought of as the absence of something. If you ever find yourself
    wishing to explicitly set something to `undefined`, you should probably reach
    for `null` instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s important to distinguish between the concepts of undefined and not even
    declared. In JavaScript, if you try to evaluate an identifier that does not exist
    within your scope, you will get a `ReferenceError`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'However, as you''ve already seen, if you try to evaluate a property of an object
    and the property does not exist, you will get no such error. Instead, it will
    evaluate to `undefined`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if you try to access a property under the non-existent `foo` property,
    you''ll receive a `TypeError` complaining that it cannot read a property that
    has an `undefined` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'This behavior is an extension of the fact that seeking to access any property
    on an `undefined` or `null` value will always throw such a `TypeError`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Curiously, the `undefined` value, unlike `null`, is not a literal, but is a
    globally available value provided by the language. Overwriting this global value
    is not possible in ECMAScript 2015 onward, but it is still possible to define
    your own value for the undefined identifier in local (non-global) scopes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'This is an anti-pattern as it can create very awkward and unexpected results.
    The accidental setting of `undefined` in a scope higher than your scope can mean
    that, if you were to rely on the value directly, you may end up referring to a
    value other than `undefined`. This lack of trust in the `undefined` value has
    historically meant that people have found other ways to forcefully make `undefined`
    available in their scope. For example, declaring a variable but not assigning
    it will always result in its value being `undefined`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use JavaScript''s `void` operator on any value that will always
    return the `real` undefined value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Explicitly setting undefined within your scope means that you can safely refer
    to your `undefined` value without worrying that it has been compromised. Fortunately,
    however, you can avoid the pain of having to worry about this risk by using the `typeof`
    operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: This will not throw a `ReferenceError` even if `myValue` does not exist. The
    `typeof` operator, as we've discovered with `null`, is a bit of a fair-weather
    friend as we can't always rely on it, but it is nonetheless very useful when explicitly
    checking for `undefined`.
  prefs: []
  type: TYPE_NORMAL
- en: Another way to avoid the risk of undefined is to enforce its correct usage within
    your code base by using a linting tool. We'll cover linting tools in [Chapter
    15](be9ab437-faeb-4a14-8a5f-663ddba470fd.xhtml), *Tools for Cleaner Code.*
  prefs: []
  type: TYPE_NORMAL
- en: 'In summary, `undefined` can be used cleanly if you remember the following two
    points:'
  prefs: []
  type: TYPE_NORMAL
- en: Avoid directly assigning `undefined` to a variable; you should use `null` instead
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Always check for `undefined` explicitly, preferring the `typeof` operator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This concludes our exploration of primitive types in JavaScript. Now, we'll
    move on to non-primitives, that is, objects.
  prefs: []
  type: TYPE_NORMAL
- en: Objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Everything that is not a primitive value in JavaScript can be considered an
    object. Even functions are, in fact, specialized objects; their only difference
    is that they can be invoked. Usually, however, when we use the term `Object`,
    we are referring to a plain object that is normally declared as an object literal
    delimited by curly braces, with a set of key-value pairs within:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also instantiate an object via the `Object` constructor and then add
    properties directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Even though they are equivalent, it's preferable to use an object literal in
    most situations as it is simpler to declare and to read, especially if there are
    many properties. It also has the added benefit of allowing you to create and pass
    an object as an expression without having to prepare it beforehand.
  prefs: []
  type: TYPE_NORMAL
- en: Property names
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The keys that are used to add properties to objects (the property names) are
    internally stored as strings. However, when using the object literal syntax, you
    can declare the keys as regular identifiers (that is, anything you could use as
    a variable name), number literals, or string literals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s preferable to use identifiers where possible as this helpfully restricts
    you to using key names that can easily be accessed as properties. If you use a
    string literal that is not also a valid identifier, then you''ll have to use square-bracket
    notation to access it, which can be burdensome:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use computed property names (delimited by square brackets) to
    add dynamically named items to an object literal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'As we mentioned previously, all non-primitives in JavaScript are technically
    objects. What else makes something an object, though? Objects allow us to assign
    arbitrary values to them as properties, which is something primitives are not
    capable of. Beyond this characteristic, the definition of an object in JavaScript
    is left invitingly generic. We can wield objects in many different ways to suit
    the code we''re writing. Many languages will provide language constructs for dictionaries
    or hashmaps. In JavaScript, we can use objects to fulfill most of these needs.
    When we need to use store a key-value pair where the key is something other than
    a string, it''s common to provide a string representation of that value via the
    object''s `toString` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'This will be called internally when the object is put in a context where it
    is coerced to a string, such as when accessing or assigning via square-bracket
    notation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: This has historically been used to allow the implementation of data structures
    where the key is effectively non-primitive (even though objects technically store
    property names as strings). Nowadays, however, using `Map` or `WeakMap` is preferred.
  prefs: []
  type: TYPE_NORMAL
- en: Property descriptors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When adding properties to objects in the conventional fashion, either via property
    access or via an object literal, the properties will be given the following implicit
    traits:'
  prefs: []
  type: TYPE_NORMAL
- en: '`configurable`: This means the property can be deleted from the object (and
    if its property descriptor can be changed)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`enumerable`: This means the property will be visible to enumerations such
    as `for...in` and `Object.keys()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`writable`: This means the property''s value can be changed via an assignment
    operator (such as `obj.prop = ...`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JavaScript gives you the power to turn off these traits individually, but be
    wary that changes to these traits can obscure the behavior of your code. For example,
    if a property is described as not being writeable but a write is attempted via
    assignment (for example, `obj.prop = 123`), then the programmer will receive no
    warning that the write has not occurred. This can create unexpected and hard-to-find
    bugs. As ever, it's vital to keep in mind the expectations of the programmers
    who will be consuming your interfaces. So you keep the property descriptors with
    care and consideration.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can define your own traits for a given property via the natively provided `Object.defineProperty()`.
    When setting up a new property descriptor, the default of each trait will be `false`,
    so if you wish to give the property a trait of either `configurable`, `enumerable`,
    or `writable`, then you will need to specify these as `true` explicitly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use `Object.defineProperties()` to describe many properties at
    once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'If you attempt to change the traits of a property that has `configurable` set
    to `false`, then you will receive a `TypeError`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'It is also possible to set custom setters and getters*. *A getter defines what
    value will be returned when a property is accessed, while a setter will define
    what occurs when an assignment is attempted on that property (that is, via the
    assignment operator). Using these can be useful in situations where you wish to
    have an internal implementation that holds the value in a unique way or somehow
    filters or processes the value upon assignment, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'As the `name` property here has been described via `defineProperties`, it will
    have all of the default traits disabled, which means it is not enumerable, writeable,
    or configurable. If we try to enumerate it, we''ll discover that our internally
    used `normalizedName` is found:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: This is something to keep in mind when working with property descriptors. Make
    sure you're aware of what traits every property has and watch out for leakage
    of your internal implementation!
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s worth noting that it is also possible (and often preferable) to define
    getters and setters for properties directly within an object literal or class
    definition. For example, we could create a subclass of `Array` with the addition
    of a `last` property, which acts as a getter for the last element in the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: There are many such creative uses of getters and setters. But, as with the traits
    of `configurable`, `enumerable`, and `writable`, it's important to be cautious
    of how your custom behaviors will affect the expectations of your fellow programmers.
    If the abstraction or data structures you create are not familiar or predictable
    in their behavior, then you're paving the way for misunderstandings and bugs.
    The best approach is to align with the natural semantics of the language itself.
    So, whenever you are about to create a custom setter or describe a property as
    unwritable, ask yourself whether it would be reasonable for a programmer to expect
    it to work that way. Follow a helpful rule dubbed as the **Principle of Least
    Astonishment** (**POLA**)!
  prefs: []
  type: TYPE_NORMAL
- en: The POLA (or least surprise) applies to software design and UX design. It broadly
    means that a given function or component of a system should act as most users
    would expect it to and should seek not to surprise or astonish too much.
  prefs: []
  type: TYPE_NORMAL
- en: Map and WeakMap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The  `Map` and `WeakMap` abstractions are capable of storing key-value pairs
    where, unlike regular objects, the key can be anything, including non-primitive
    values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '`WeakMap` is similar to `Map`, but it only holds a weak reference to the object
    that''s used as a key, meaning that, if the object becomes unavailable due to
    being garbage-collected elsewhere in your program, then `WeakMap` will cease to
    keep a hold of it.'
  prefs: []
  type: TYPE_NORMAL
- en: Most of the time, a plain object is all you will need. You should only reach
    for `Map` or `WeakMap` if you need your keys to be non-primitive or if you want
    to weakly hold your values.
  prefs: []
  type: TYPE_NORMAL
- en: The prototype
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'JavaScript is a prototypical language where inheritance is achieved via prototypes.
    This can be a daunting concept, but it is, in fact, beautifully simple. JavaScript''s
    prototypal behavior can be described like this: every time a property is accessed
    on an object, if it is not available on the object itself, JavaScript will attempt
    to access it on an internally available property called  `[[Prototype]]`. It will
    then repeat this process until it either finds the property or gets to the top
    of the prototype *chain* and returns `undefined`.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding what this `[[Prototype]]` property is capable of will give you
    great power over the language and will immediately make JavaScript less daunting. 
    It can be difficult to grasp but is worth it in the end.
  prefs: []
  type: TYPE_NORMAL
- en: 'A `[[Prototype]]` object, which could feasibly be attached to any other object,
    is just a regular object itself. We could create one called `engineerPrototype` and
    have it contain data and methods related to the role of an engineer, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we could attach this prototype to another object, thus making its properties
    available there as well. To do this, we use `Object.create()`, which creates a
    new object with a hardcoded `[[Prototype]]`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: The internal `[[Prototype]]` property cannot be directly set, so we must use
    mechanisms such as `Object.create` and `Object.setPrototypeOf`. Note that you
    may have seen code that uses the non-standard `__proto__` property to set `[[Prototype]]`,
    but this is a legacy feature and should not be relied on.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this newly created `pandaTheEngineer` object, we are able to access any
    properties available on its `[[Prototype]]`, such as `engineerPrototype`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'We can illustrate that the objects are now linked by adding a new property
    to `engineerPrototype` and observe how it is made available on `pandaTheEngineer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'As we mentioned previously, the `[[Prototype]]` of an object will only be used
    to resolve a property if it is not already available on the object itself. The
    following code shows how we can set our own `sayHello` method on our `pandaTheEngineer` object,
    and that by doing so we no longer have access to the `sayHello` method defined
    on `[[Prototype]]`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'However, deleting this newly added `sayHello` method would mean we once again
    have access to the `[[Prototype]]` `sayHello` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'To understand what''s happening and which properties are coming from which
    object, we are always able to inspect the `[[Prototype]]` of an object using `Object.getPrototypeOf`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can inspect its properties via `Object.getOwnPropertyNames`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we can see that the `[[Prototype]]` object (that is, `engineerPrototype`)
    is providing the `type`, `sayHello,` and `sayGoodbye` properties. If we inspect
    the `pandaTheEngineer` object itself, we can see that it only has a `name` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'As we observed with our earlier addition of the `sayGoodbye` method, we can
    modify that prototype at any time and have our changes accessible to any objects
    that use that prototype. Here''s another example of doing this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Here, you can see how our inherited `sayHello` method is producing a string
    that includes our mutated type property (that is, `"Awesome Engineer"`).
  prefs: []
  type: TYPE_NORMAL
- en: Hopefully, you are beginning to see how we could construct a hierarchy of inheritance
    using prototypes. The very simple mechanism of `[[Prototype]]` allows us to express
    complex hierarchical relations between problem domains expressed as objects. This
    is how OOP is achieved in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: We could feasibly create another prototype that itself uses `engineerPrototype`,
    possibly `fullStackEngineerPrototype`, and it would work as expected, with each
    prototype defining another layer of property resolution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Below the surface, JavaScript''s newer *Class Definition Syntax*, which you
    may have grown accustomed to, relies on this underlying mechanism of prototypes
    as well. This can be observed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: You'll notice that there are some subtle differences here. The most crucial
    one is that, when declaring classes, there is currently no way to define non-method
    properties on the prototype object. When we declare the `type` property, we are
    populating the instance itself so that when we inspect the properties of the instance,
    we get `"type"` and `"name"`. However, the methods (such as `sayHello`) will exist
    on the `[[Prototype]]`. Another difference is that, of course, when using classes,
    we are able to declare a `constructor`, which itself is a method/property on the
    `[[Prototype]]`.
  prefs: []
  type: TYPE_NORMAL
- en: Fundamentally, the *Class Definition Syntax* (introduced in *ECMAScript 2015*),
    does not make anything possible that was not already possible in the language.
    It's just utilizing the existing prototypical mechanism. However, the newer syntax
    does make some things simpler, such as referring to a superclass with the `super`
    keyword.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before class definitions existed, we typically wrote class-like abstractions
    by assigning our intended `[[Prototype]]` object to the `prototype` property of
    a function, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'When a function is instantiated via the `new` operator, JavaScript will implicitly
    create a new object with its `[[Prototype]]` set to the function''s `prototype`
    property, if it has one. Let''s try instantiating the `Engineer` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Inspecting this yields the same characteristics that we saw in our original
    `Object.create` approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Broadly, all of these approaches are the same but have some subtle differences
    around where certain properties reside (that is, whether its properties are on
    the instance itself or on its `[[Prototype]]`). The newer *Class Definition Syntax*
    is useful and succinct and so is preferable nowadays, but it is nonetheless useful
    to have an underlying knowledge about how prototypes work as it drives the entirety
    of the language, including all of its native types. We can inspect these native
    types in the same manner as in the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Mutating native prototypes is an anti-pattern and should be avoided at all
    costs as it can create unexpected conflicts with other code in your code base.
    Since a runtime will only have a single set of native types available, when you
    modify them, you are modifying the capabilities of every single instance of that
    type that currently exists. Therefore, it is best to abide by a simple rule: **only
    modify your own prototypes**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you ever catch yourself trying to modify a native prototype, it may be better
    if you created your own subclass of that type and added your functionality there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Here, we're creating our own `Array` subclass called `HeartArray` so that we
    can add our own specialized `join` method.
  prefs: []
  type: TYPE_NORMAL
- en: When and how to use objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An object of any type, much like our primitive values, should only be used inline
    with the semantic concept it represents. The preceding case of subclassing `Array`
    to `HeartArray` makes sense as the data we wish to express via it is indeed array-like,
    that is, it is a sequential set of words.
  prefs: []
  type: TYPE_NORMAL
- en: When we go about molding objects into abstractions that suit our needs, we should
    always consider the expectations that other programmers will have about objects
    and the ramifications of those expectations. We'll go into the subtleties of designing
    good abstractions in [Chapter 11](9ef81929-c89f-4988-aa66-436c59f7f43f.xhtml),
    *Design Patterns,* where we will be utilizing objects to craft abstractions in
    a multitude of ways.
  prefs: []
  type: TYPE_NORMAL
- en: This section has introduced you to the concept of objects in JavaScript—how
    they are everywhere—and how they operate beneath the surface via prototypes. This
    fundamental knowledge will make working with JavaScript much easier and will help
    you write cleaner code.
  prefs: []
  type: TYPE_NORMAL
- en: Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functions in JavaScript are like any other type; they can be passed around just
    like objects and primitive types. When we talk about most other values, however,
    we see that there is usually only one way to literally declare them. Object literals
    are declared using braces. Array literals are delimited square brackets. Functions,
    however, come in a variety of literal forms.
  prefs: []
  type: TYPE_NORMAL
- en: 'When outside of an object literal or class definition, you can declare a function
    in three different ways: as a function declaration, as a function expression,
    or as a fat-arrow function expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'When declaring functions inside object literals, however, there is a more succinct
    syntax, called a **method definition**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to separate these method definitions with a comma (just as we''d have
    to do with any other properties defined in an object literal). Class definitions
    also allow us to use method definitions, although they don''t require separating
    commas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Methods are just functions that are *bound* to an object when invoked. This
    includes functions defined within class definitions and functions that are in
    any way assigned to a property of an object. When discussing code with other programmers,
    it's useful to know what people mean when they say *method* versus *function*.
    Fundamentally, however, the language of JavaScript does not distinguish between
    these—they are all technically just functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'All the various ways of defining functions have subtle differences that are
    worth knowing about because the typical JavaScript code base will use most, if
    not all, of these styles. The types of differences you''ll encounter in how functions
    are declared include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Whether the definition style is *hoisted* to the top of its scope; for example,
    with function declarations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whether the definition style creates a function that has its own bindings (for
    example, `this`); for example, with function expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whether the definition style creates a function with its own `name` property;
    for example, with function declarations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whether the definition style is contextual to specific areas of code; for example,
    with method definitions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, we can go into more detail about the syntax of the various definition styles.
  prefs: []
  type: TYPE_NORMAL
- en: Syntactic context
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are three syntactic contexts in which a function can exist:'
  prefs: []
  type: TYPE_NORMAL
- en: As a statement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As an expression
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a method definition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Statements** can be thought of as the scaffolding. For example, `const X
    = 123` is a *Statement* that contains a `const` declaration and assignment. **Expressions** can
    be thought of as the values that you place into the scaffolding; for example, `123` in
    the latter *statement* is an *expression*. In [Chapter 9](1b37008e-8843-431a-9545-56d4246e3447.xhtml),
    *Parts of Syntax and Scope**,* we''ll talk about this topic in more detail.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The difference between functions as statements and functions as expressions
    is exemplified by the function expression and the function declaration. The function
    declaration is quite unique in that it is the only way to declare a function that
    is technically a statement. To be considered a function declaration, the syntax
    of `function name() {}` must reside on its own without being used in the context
    of an expression. This can be incredibly confusing because you cannot always tell
    whether a function is a function declaration or function expression based purely
    on its own syntax; instead, you must look at the context in which it exists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: As we mentioned previously, a function expression is allowed to have a name,
    just like a function declaration, but that name may not match the name of the
    variable that the function is assigned to.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s easiest to think of expressions as anything that can legally exist to
    the right-hand side of the assignment operator. All of the following *right-hand
    sides* are legal expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Function expressions are as flexible as all the other values in JavaScript in
    terms of where they can be placed syntactically. Function declarations, as we
    will discover, are limited. Method definitionsare also limited to exist within
    the confines of either an object literal or a class definition.
  prefs: []
  type: TYPE_NORMAL
- en: Function bindings and this
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A function''s bindings refer to a set of additional and implicit values that
    JavaScript makes available for referencing within the body of the function. These
    bindings include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`this`: The `this` keyword refers to the execution context of a function''s
    invocation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`super`: The `super` keyword in a method or constructor refers to its super-class'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`new.target`: This binding informs you as to whether the function was invoked
    as a constructor (via the `new` operator)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`arguments`: This binding provides access to the arguments that are passed
    to a function when it is invoked'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These bindings are available to all functions except those defined with the
    arrow syntax (`fn = () => {}`). Functions defined in this way will effectively absorb
    the bindings from the parent scope (if one is available). Each of these bindings
    has unique behaviors and constraints. We will explore these in the following subsections.
  prefs: []
  type: TYPE_NORMAL
- en: Execution context
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `this` keyword is usually determined at the calltime of the function and
    will normally resolve to the object that the function is being invoked on. It
    is sometimes referred to as the execution context of a function or its `thisArg`. This
    can be unintuitive since it means that the `this` value can technically change
    between calls. For example, we could assign a method from one object to another,
    call it on the second, and observe that its `this` is always the object it''s
    been called on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: When called without an object of invocation, as is the case when we directly
    call `sayMyName`, its presumed execution context is the global environment in
    which the code resides. On the browser, this global environment is equal to the
    window object (which provides access to the browser-and-document object models),
    while in Node.js, this refers to an environment that's unique to each specific
    module/file, which includes, among other things, that module's exports.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the case of calling a function globally, there are two cases
    where the `this` keyword will be something other than the apparent object of invocation:'
  prefs: []
  type: TYPE_NORMAL
- en: If the function being called was defined as an arrow-function, then it will
    absorb the `this` value from the scope in which it is situated
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the function being called is a constructor, its `this` value that will be
    a new object that has its `[[Prototype]]` preset to the prototype property of
    the function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are also ways to force the value of `this` when calling or declaring
    a function. You can use `bind(X)` to create a new function that will have its
    `this` value set to `X`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use a function''s `call` and `apply` methods to force the `this`
    value for any given invocation, but note that this will not work if the function
    is being called as a constructor (that is, with a new keyword) or if it has been
    defined with the arrow-function syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: In your everyday function calls, it's best to avoid awkward techniques of invocation
    like this. Such techniques can make it difficult for the readers of your code
    to discern what's happening. There are many valid applications of invoking via
    `call`, `apply`, or `bind`, but these are usually limited to lower-level libraries
    or utility code. Higher-level logic should avoid them. If you find yourself having
    to rely on these methods in higher-level abstractions, then you're likely making
    something more complicated than it needs to be.
  prefs: []
  type: TYPE_NORMAL
- en: super
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The super keyword comes in three distinct flavors:'
  prefs: []
  type: TYPE_NORMAL
- en: '`super()` as a direct function invocation will call the superclass''s constructor
    (that is, its object''s  `[[Prototype]]` constructor) and is only valid to call
    within a constructor. It also must be called before trying to access `this` as
    it is `super()` itself that''ll initiate the execution context.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`super.property` will access a property on the superclass (that is, the `[[Prototype]]`),
    and is only valid to reference within a constructor or method defined using the
    method definition syntax.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`super.method()` will invoke a method on the superclass (that is, the `[[Prototype]]`),
    and is only valid to call within a constructor or method defined using the method
    definition syntax.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `super` keyword was introduced to the language at the same time as the
    class definition and method definition syntax, so it is tied up in those constructs.
    You are free to use `super` in class constructors, methods, and also in method
    definitions within object literals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'The `super` keyword, as its name suggests, is semantically suited to referencing
    a superclass, so 99% of its valid use cases will be within class definitions,
    where you''re seeking to reference the class being extended, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: Using `super` in this manner is entirely intuitive, especially to programmers
    who are used to other OOP languages. For individuals adept with JavaScript's prototype
    mechanism, however, the implementation of `super` can seem confusing. Unlike the `this`
    value, `super` is bound at definition time, instead of call time. We've seen how
    we can manipulate the value of this by calling a method in a specific manner (for
    example, using `fn.call()`). You cannot similarly manipulate `super`. Hopefully,
    this will not affect you in any way, but it is useful to remember nonetheless.
  prefs: []
  type: TYPE_NORMAL
- en: new.target
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `new.target` binding will be equal to the current function being called
    if the function has been called via a `new` operator. We typically use the `new`
    operator to instantiate classes, and in this case, we will correctly expect `new.target`
    to be that class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'This is useful when we may wish to carry out a certain behavior if a constructor
    is called directly versus when called via `new`. A common defensive strategy is
    to make your constructor behave in the same way, regardless of whether it''s called
    with or without `new`. This can be achieved by checking for `new.target`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you may wish to throw an error to check that a constructor has
    been invoked incorrectly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: Both of these examples would be considered intuitive use cases of `new.target`.
    There is, of course, the possibility to use it to deliver entirely different functionality
    depending on the calling pattern, but in the interest of catering to the reasonable
    expectations of programmers, it's best to avoid such behavior. Remember the POLA.
  prefs: []
  type: TYPE_NORMAL
- en: arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `arguments` binding is made available as an array-like object and will contain
    the arguments that a given function was called with.
  prefs: []
  type: TYPE_NORMAL
- en: When we say that `arguments` is array-like, we are referring to the fact that
    it has a `length` property and properties indexed from zero (just like a regular
    `Array`), but it still just a regular `Object` and therefore does not have any
    of array's built-in methods available, such as `forEach`, `reduce`, and `map`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we can observe that the arguments are provided within the scope of a
    given function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'The `arguments` binding was popularly used to gain access to an arbitrary (that
    is, non-fixed) amount of arguments, though its usefulness quickly disappeared
    after the language introduced the *rest parameter* syntax (`...arg`). This newer
    syntax can be used when defining a function to instruct JavaScript to place remaining
    arguments into a singular array. This meant that you could achieve all of the
    utility of the older `arguments` binding, plus you''d have a value that was not
    merely array-like but actually a genuine array. Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: Even though the `arguments` object has fallen out of favor, it is still within
    the language spec and works in older environments, so you may still see it in
    the wild. Most of the time, its usage can be avoided.
  prefs: []
  type: TYPE_NORMAL
- en: Function names
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Confusingly, functions have names, and these names are not the same as the
    variables or properties that we assign to functions. The name of a function is
    within its syntax, prior to its parentheses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'You can access a function''s name via its `name` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'When you define a function via the function declaration syntax, it''ll assign
    that function to a local variable of the same name, meaning that we can reference
    the function as we would expect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'Method definitionswill also assign the method to a property name that is equal
    to the function name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'You may be thinking this all seems incredibly intuitive. And it is. It makes
    perfect sense that the names we give our functions and methods are themselves
    used to dictate what variable or property those things will be assigned to. Oddly,
    though, it is also possible to have named function expressions, and these names
    do not cause such an assignment. The following is an example of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'The `const` name here, `myFunction`, dictates what we will use in subsequent
    lines to reference the function. However, the function technically has a name
    of `"hullaballoo"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'If we try to reference the function via its formal name, we will get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'This can seem odd. Why is it possible to give a function a name if that name
    itself is not used to refer to the function? This is a mixture of legacy and convenience.
    One hidden feature of the named function expression is that the name is actually
    available to you to reference the function, but only inside the scope of the function
    itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'This can be useful in situations where you want to supply an *anonymous* callback
    to some other function but still be able to reference your own callback for any
    repeated or recursive calls, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: So, even though the named function expression is an odd thing, it does have
    its merits. In usage, however, it's best to take into consideration the clarity
    of your code for people who might not know of these idiosyncratic behaviors. This
    does not mean avoiding it altogether, but just being ever more mindful of the
    readability of your code when using it.
  prefs: []
  type: TYPE_NORMAL
- en: Function declarations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Function declarations are a type of *hoisted declaration*. A hoisted declaration
    is one that will, at runtime, be effectively hoisted up the top of its execution
    context, meaning that it will be immediately accessible to preceding lines of
    code (seemingly *before* it''s declared):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'This, of course, is not possible with a function expression that''s been assigned
    to a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: The hoisted behavior of function declarations can create unexpected results,
    so it is typically considered an anti-pattern to rely on the hoist. In general,
    it's fine to use function declarations, as long as they're used in a way that
    respects the assumptions that programmers will intuitively make. Hoisting, as
    a practice, is not very intuitive to most people, and so it's usually best to
    avoid it.
  prefs: []
  type: TYPE_NORMAL
- en: For more information on scopes and how hoisting occurs in the case of function
    declarations, please take a look at [Chapter 9](1b37008e-8843-431a-9545-56d4246e3447.xhtml), *Parts
    of Syntax and Scope*, and go to the *Scopes and Declarations* section.
  prefs: []
  type: TYPE_NORMAL
- en: Function expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Function expressions are the easiest and most predictable to use as they are
    syntactically similar to all the other values within JavaScript. You can use them
    to *literally* define functions anywhere you would define any other value as they
    are a type of expression. Observe here, for example, how we''re defining an array
    of functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'A common application of the function expression is in passing callbacks to
    other functions so that they can be called at some later point. Many native `Array`
    methods, such as `forEach`, accept functions in this manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are passing a function expression to the `forEach` method. We haven't
    named this function by assigning it to a variable, so it is considered an anonymous
    function. Anonymous functions are useful as they mean that we don't need to preassign
    a function to a variable in order to make use of it; we can simply write our function
    into our code at the exact location of usage.
  prefs: []
  type: TYPE_NORMAL
- en: 'The function expression is most similar in its expressive manner to the arrow
    function.The key difference, as we will discover, is that the arrow function does
    not have access to its own bindings (for example, to `this` or `arguments`). A
    function expression, however, does have access to these values, and so in some
    contexts will be more useful to you. It''s very common to need a binding to `this`
    in order to operate successfully with the DOM API, for example, where many native
    DOM methods will invoke callbacks and event handlers with the relevant element
    as execution context. Additionally, you''ll want to use function expressions when
    defining methods on objects or prototypes that will need to access the current
    instance. As illustrated here, using an arrow function would not be appropriate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, using the arrow function syntax prevents us from accessing the
    instance via `this`, while the function expression syntax allows us to do this.
    Therefore, the function expression, although somewhat superseded by the more succinct
    arrow function, is still a very useful tool.
  prefs: []
  type: TYPE_NORMAL
- en: Arrow functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The arrow function is, in many ways, just a slightly more succinct version
    of the function expression, although it does have some practical differences.
    It comes in two flavors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the *concise* variant includes an implicit return, while the
    *regular* variant, much like other function definition styles, requires you to
    define a regular function body delimited by curly braces in which you must explicitly
    return a value with a `return` statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, arrow functions allow you to avoid using parentheses when declaring
    a function with only one argument. In these cases, you can just place the identifier
    of the argument by itself prior to the arrow, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'The succinctness of the arrow function can be very useful in situations where
    you need to pass functions around quite a lot. This is common, for example, when
    operating on arrays via native methods such as `map`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'Despite its superhero status as the succinct variant of otherwise verbose function
    definitions, the arrow function comes with its own challenges. The fact that the
    language must accommodate both *concise* and *regular* variants of syntax means
    that there is some ambiguity when attempting to return an object literal from
    the concise arrow function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'This syntax will confuse the JavaScript parser as the opening curly brace implies
    that a regular function body resides within. Due to this, the parser gives us
    an error about an unexpected token as it is not expecting the body of an object
    literal. If we want to return an object literal from the concise form of the arrow
    function, then we must awkwardly wrap it in parentheses to disambiguate the syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'Functionally, the arrow function differs from the function expression in two
    ways:'
  prefs: []
  type: TYPE_NORMAL
- en: It does not provide access to bindings such as `this` or `arguments`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It does not have a `prototype` property, so it cannot be used as a constructor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These differences mean that, on the whole, arrow functions are typically unsuitable
    to use as methods or constructors. They are best used in contexts where you wish
    to pass a callback or handler to another function, and especially in cases where
    you wish to retain your `this` binding. For example, if we were to bind event
    handlers within the context of a `UIComponent` abstraction, we may wish to retain
    the `this` value in order to carry out certain instance-specific functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'The arrow function feels most at home in scenarios like this. Its succinctness,
    however, means that there can be a risk of confusion when reading overly dense
    lines of code, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'For this reason, it is best to employ the arrow function with the same consideration
    and practicality with which you would employ any other construct: ensure that
    you always put the usability and readability of your code first, above the very
    enticing niftiness of *cool* or succinct syntax.'
  prefs: []
  type: TYPE_NORMAL
- en: Immediately Invoked Function Expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Function expressions and arrow functions are the only function definition styles
    that are, technically, expressions. As we have seen, this quality makes them useful
    when we need to pass them as values to other functions without having to go through
    the process of assignment.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we mentioned previously, a function without an assignment, and thus without
    a reference to its value, is typically called an *anonymous function *and will
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'The idea of an *anonymous function* is extended further by the concept of an
    **Immediately Invoked Function Expression** (**IIFE**). An IIFE is just a regular
    *anonymous function* that is invoked immediately, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: Note the invocation parentheses (that is, `...()`) after the closing curly brace.
    This will call the function and thus makes the preceding syntactic construct an
    IIEE.
  prefs: []
  type: TYPE_NORMAL
- en: An IIFE is not a distinct concept within the language itself. It is just a useful
    term that the community has come up with to describe the common pattern of *immediately*
    invoking a function. It's a useful pattern because it allows us to create an ad
    hoc scope, meaning that any variables defined within it are constrained to that
    scope and will not leak outside, just as we'd expect from any function. This immediate
    scope is useful to quickly do self-contained work without affecting the parent
    scope.
  prefs: []
  type: TYPE_NORMAL
- en: IIFEs were popularized in the browser era when it was preferable to avoid polluting
    the global namespace. Nowadays, with pre-compilation being so popular, the IIFE
    is less useful.
  prefs: []
  type: TYPE_NORMAL
- en: 'The exact syntax of an IIFE can vary. For example, if we use an arrow function,
    then the calling parenthesis must be placed after the wrapped function expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: The mechanism remains essentially the same, regardless of whether we use a function
    expression or an arrow function.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the concept of an IIFE is confusing, it''s simpler to understand what''s
    going on if we replace the actual function with an identifier, `fn`, and imagine
    that we have previously assigned a function to this identifier. Here, we can call
    `fn` like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we could choose to wrap the `fn` reference in parentheses. This would
    make no difference to the invocation, although it may look bizarre:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s useful to remember that parentheses are just syntactic vessels that are
    sometimes needed to avoid syntactic ambiguity. So, all of these are technically
    equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'If we replace the `fn` reference here with an inline anonymous function, nothing
    groundbreaking occurs. Instead of referencing an existing function, we are just
    expressing an inline function, on the spot, and then invoking it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: We call the pattern of an inline function expression an IIFE, but it really
    isn't anything special. Consider that the invocation parentheses, that is, `...()`,
    don't really care what they're attached to, as long as it's a function. The expression
    prior to the invocation could be literally *anything* as long as it evaluates
    to a function.
  prefs: []
  type: TYPE_NORMAL
- en: 'IIFEs are useful because they provide scope isolation without the burden of
    having to define a function with a name and then later reference and invoke it,
    as we''re doing here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: Within the browser, prior to complex builds involving compilation and bundling,
    IIFEs were useful because they provided scope isolation while not leaking any
    names into the global scope. Nowadays, however, the IIFE is rarely necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Interestingly, the `initializeApp` function in the preceding code is, arguably,
    more readable and understandable with an explicit name. This is why, even if necessary,
    IIFEs are sometimes considered needlessly confusing and fancy. A named function
    usefully provides a clue as to its purpose and the intent of the author. Without
    a name, the reader of our code is left with the cognitive burden of having to
    read through the function itself to discover its broad purpose. For this reason,
    it is usually preferable to avoid IIFEs and similar anonymous constructs unless
    you have a very specific need.
  prefs: []
  type: TYPE_NORMAL
- en: Method definitions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Method definitions were added to the language at the same time as class definitions
    to allow you to easily declare methods bound to a specific object. They are not
    limited to class definitions, though. You can use them freely in object literals
    as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'In classes, you can also declare methods in this manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use traditional styles of function definition to declare your
    methods, such as a function expression assigned to an identifier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'There is, however, a crucial difference between method definitions and other
    styles of function definition. A method definition will always be bound to the
    object in which it was first defined. This is known internally as its `[[HomeObject]]`.
    This home object will determine what `super` binding is available to the method
    when it is called. Only method definitions are allowed to make reference to `super`,
    and the `super` they reference will always be the `[[Prototype]]` of their `[[HomeObject]]`.
    This means that if you try to *borrow* methods from other objects, you may be
    surprised to discover that `super` is not what you intended:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we can observe that both `JessieTheCat` and `JessieTheDog` have `greet`
    methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also observe that their greet methods are implemented in identical ways.
    They both return the interpolated string ``${super.greet()} I am Jessie!``. Due
    to this, it might seem logical to be able to let `JessieTheCat` borrow the method
    from `JessieTheDog`. After all,  they''re exactly the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'We might intuitively expect `super` in the greet method to refer to the superclass
    of the current instance, which in the case of `JessieTheCat` will be `Cat`. But
    curiously, when we call this borrowed method, we experience something different:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: It barks! The borrowed method has annoyingly retained its binding to its original
    `[[HomeObject]]`.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, method definitions are simpler and more succinct variants of their
    more verbose cousins, the function declaration and function expression. However,
    they come with an implicit mechanic that sets them apart and can create confusion.
    99% of the time, method definitions won't bite you; they'll behave as expected.
    The other 1% of the time, it's useful at the very least to know why your code
    is misbehaving so that you can explore other options. As always, knowledge about
    the idiosyncrasies of JavaScript can only help us in our pursuit of a cleaner
    and more reliable code base.
  prefs: []
  type: TYPE_NORMAL
- en: Async functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Asynchronous** (**async**) functions are specified with an `async` keyword
    preceding the function keyword. All function definition styles can be prefixed
    with it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'An async function allows you to easily conduct asynchronous operations by providing
    you with two key features:'
  prefs: []
  type: TYPE_NORMAL
- en: You can use `await` within your async function to await the completion of Promises
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your function will always return a Promise, which can, itself, be awaited
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Promise is a natively supplied abstraction for dealing with asynchronous
    operations. It can seem complicated, but it's best to think of a Promise as an
    object that will either resolve or reject at a time later than *now *(that is,
    asynchronously).
  prefs: []
  type: TYPE_NORMAL
- en: 'Traditionally, in JavaScript, we''d have to pass around callbacks to ensure
    that we''re able to respond to such asynchronous activity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: 'However, with an async function and `await`, we can achieve this more succinctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: The `await` clause here will halt current execution until `getUserDetails` completes
    and resolves to a value. Note that we can only use await within functions that
    are themselves async.
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous execution is a complex topic, so there is a whole chapter dedicated
    to it, that is, [Chapter 10](b41df1c6-fc76-4d51-b95c-ae39ab040ab1.xhtml), *Control
    Flow*. For now, it's useful to know that async functions are a distinct type of
    a function that will always return a Promise.
  prefs: []
  type: TYPE_NORMAL
- en: Other than allowing `await` clauses and returning Promises, async functions
    carry the same features and characteristics as the respective function definition
    style that's used. An async arrow function, just like a regular arrow function,
    does not have its own bindings to this or arguments. An async function declaration
    is hoisted just like its non-async cousin. Essentially, async should be thought
    of as a layer atop all of the learnings you've already picked up concerning the
    different function definition styles.
  prefs: []
  type: TYPE_NORMAL
- en: Generator functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The very last type of function definition style we will cover is the very powerful
    *generator function.* Broadly, generators are used to supply and control the iteration
    behavior for a sequence of one or more, or even infinite, items.
  prefs: []
  type: TYPE_NORMAL
- en: '*Generator functions* in JavaScript are specified with an asterisk following
    the function keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: When called, they will return a generator object, which uniquely conforms to
    both the iterable protocol and the iterator protocol*,* meaning that they can
    be iterated over themselves or can serve as an object's iteration logic.
  prefs: []
  type: TYPE_NORMAL
- en: Feel free to skip ahead to the section on the iterable protocol*. *The generator
    function makes far more sense when you think of it as a convenient way to create
    an iterator or iterable.
  prefs: []
  type: TYPE_NORMAL
- en: 'A generator function will halt and return a value at the point of a `yield`
    statement, and this can occur multiple times. After a `yield`, the function is
    effectively stalled while it waits for a consumer to need its next value. This
    is best illustrated with an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the generator object that's returned from the function has a
    `next` method, which, when called, will return an object with a `value` (indicating
    the current value of the iteration) and a `done` property (indicating whether
    the iteration/generation is complete). This is the *iterator protocol* and is
    the contract you can expect all generators to fulfill.
  prefs: []
  type: TYPE_NORMAL
- en: 'A generator fulfills not only the iterator protocol but also the iterable protocol,
    which means it can be iterated over by language constructs that accept iterables
    (such as `for...of` or the `...spread` operator):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: '*Async generator functions* can also be specified. They usefully combine the
    async and generator formats into a hybrid that allows for custom asynchronous
    generation logic, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: You'll notice how we're using the `for await` iteration construct to iterate
    through our asynchronous generator. This will ensure that each iteration will
    await its result before continuing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Generator functions are very powerful, but it''s important to be aware of the
    underlying mechanics at play. They are not regular functions and are not guaranteed
    to run to completion. Their implementation should take into account the context
    in which they will be run. If your generator is intended to be used as an iterator,
    then it should respect the implied expectations of iteration: that it is a read-only
    operation of an underlying piece of data or generation logic. While it is possible
    to mutate underlying data within a generator, this should be avoided.'
  prefs: []
  type: TYPE_NORMAL
- en: Arrays and iterables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An array in JavaScript is a type of object that is specialized in that it contains
    a set of ordered elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can express an array using its literal syntax, which is a comma-separated
    list of expressions delimited by square brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: 'These comma-separated expressions can be as complex or simple as we desire:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: An array is capable of containing all manner of values. There are very few constraints
    on how we can use arrays. Technically, an array's limited to a `length` of around
    4 billion, due to its `length` being stored as a 32-bit integer. For most purposes,
    of course, this should be absolutely fine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Arrays have a numeric property for every indexed element within them and a
    `length` property to describe how many elements there are. They also have a set
    of useful methods for reading from and operating on the data within them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: 'Historically, arrays were iterated over using conventional `for(...)` and `while(...)`
    loops that increment a counter toward the `length` so that, upon each iteration,
    the current element could be accessed via `array[counter]`, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: 'Nowadays, however, it''s preferable to use other methods of iteration, such
    as `forEach` or `for...of`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: '`for...of` has the benefit of being breakable, meaning you can use `break`
    and `continue` statements within them and easily escape from the iteration.  It
    will also work on any object that is iterable, whereas `forEach` is only an `Array`
    method. The `forEach` style, however, is useful in that it provides you with the
    current index of the iteration via the second argument to your callback.'
  prefs: []
  type: TYPE_NORMAL
- en: Which style of iteration you use should be determined by the value you are iterating
    over and what you wish to do on each iteration. Nowadays, it is quite rare to
    need to use traditional styles of array iteration such as `for(...)` and `while(...)`.
  prefs: []
  type: TYPE_NORMAL
- en: Array-like objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Most native Array methods are generic, meaning that they can be used on any
    object that *looks like* an array. All we need to achieve  the appearance of an
    array is use a `length` property and individual properties for each index (indexed
    from zero):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: Here, we've constructed an array-like object and then provided it with a `join`
    method of its own by borrowing the `join` method of an array (that is, from `Array.prototype`).
    The native array `join` method is so generically implemented that it doesn't mind
    operating on an object as long as that object fulfills the contract of an array
    by providing a `length` property and corresponding indexes (`0`, `1`, `2`, and
    so on). Most native array methods are similarly generic.
  prefs: []
  type: TYPE_NORMAL
- en: 'One example of an array-like object within the language itself is the `arguments`
    binding that we explored earlier in this chapter. Another example is `NodeList`,
    which is a type of object that is returned from various DOM selection methods.
    If necessary, we can derive proper arrays from these objects by borrowing and
    calling the array `slice` method, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: 'However, in the case of `arguments` or the `NodeList` object, we can also rely
    on them being iterable, meaning that we can use the spread syntax to derive a
    true array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: If you find yourself needing to create an array-like object, consider having
    it implement the iterable protocol (which we're about to explore) so that the
    spread syntax can be used in this way.
  prefs: []
  type: TYPE_NORMAL
- en: Set and WeakSet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Set` and `WeakSet` are native abstractions that allow us to store sequences
    of unique objects. This is in contrast to arrays, which give you no assurances
    as to the uniqueness of your values. Here''s an illustration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, values given to a `Set` will always be ignored if they already
    exist in the `Set`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sets can be initialized by passing an iterable value to the constructor; for
    example, a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: 'If you need to convert a `Set` into an array, you can most simply do this with
    the spread syntax (as sets are, themselves, iterable):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: WeakSets are similar to the previously covered WeakMaps. They are for *weakly* holding
    values in a way that allows that value to be garbage-collected in another part
    of the program. The semantics and best practices around using sets are similar
    to those concerning arrays. It's advisable to only use sets if you need to store
    unique sequences of values; otherwise, just use a simple array.
  prefs: []
  type: TYPE_NORMAL
- en: Iterable protocol
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The iterable protocol allows values containing sequences to share a common set
    of characteristics, allowing them to all be iterated over or treated in a similar
    way.
  prefs: []
  type: TYPE_NORMAL
- en: We can say that an object that implements the iterable protocol is iterable.
    Iterable objects within JavaScript include `Array`, `Map`, `Set`, and `String`.
  prefs: []
  type: TYPE_NORMAL
- en: Any object can define its own iterable protocol by simply supplying an iterator
    function under the property name's `Symbol.iterator` (which maps to the internal
    `@@iterator` property).
  prefs: []
  type: TYPE_NORMAL
- en: 'This iterator function must fulfill the iterator protocol by returning an object
    with a `next` function. This `next` function, when called, must return an object
    with `done` and `value` keys indicating what the current value of the iteration
    is and whether the iteration is completed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: 'So, to be utterly clear about this, there are two distinct protocols:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The iterable protocol**: Any object that implements an `@@iterator` via `[Symbol.iterator]`
    fulfills this protocol. Native examples include `Array`, `String`, `Set`, and
    `Map`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The iterator protocol**: Any function that returns an object of the form
    `{... next: Function}` and whose `next` method, when called, returns an object
    in the following form: `{value: Boolean, done: ...}`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For an object to fulfill the iterable protocol, it must implement `[Symbol.iterator]`,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: 'Providing custom methods of iteration via the iterable protocol can be useful
    when you want to control the order of iteration or if you want to somehow process,
    filter, or generate values during iteration. Here, for example, we are specifying
    an iterator function as a generator function, which, as you may recall, returns
    a generator that fulfills both the *iterator* and iterable protocols. This generator
    function will yield two variants for every word stored – one uppercase and one
    lowercase:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: 'Specifying iterator functions as generator functions like this is far simpler
    than having to manually implement the iterator protocol. Generators naturally
    fulfill this contract, so they can be used far more seamlessly. Generators also
    tend to be more readable and succinct and have the dual benefit of implementing
    both the iterator and iterable protocols, meaning that they can be used to decorate
    an object with iteration capabilities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: 'They can, themselves, also provide that iteration capability:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: It's important to keep in mind that any work that's done within a custom iterable
    should be in line with the expectations of consumers. Iteration is usually considered
    a read-only operation, so you should steer clear of mutations of the underlying
    value-set during iteration. Implementing your own iterables can be incredibly
    powerful, but can also lead to unexpected behavior by the consumers of your code
    who aren't aware of your custom iteration logic.
  prefs: []
  type: TYPE_NORMAL
- en: It's vital to balance the convenience of custom iteration for those people who
    are *in the know* with those people who might only be experiencing your interface
    or abstraction for the first time.
  prefs: []
  type: TYPE_NORMAL
- en: RegExp
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JavaScript natively supports regular expressions via the object type `RegExp`,
    allowing them to be expressed via the literal syntax `/foo/` or directly via the
    constructor (`RegExp('foo')`).  Regular expressions are used to define patterns
    of characters that can be matched or executed against strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example in which we extract only the long words (`>=10` characters)
    from a corpus of text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: The grammar and syntax of regular expressions can be complex. It is technically
    an entire language unto itself, requiring many days of study. We won't be able
    to explore all of its complexity here. We will, however,  be covering the ways
    in which we typically operate on regular expressions within JavaScript and explore
    some of the challenges in doing so. It is suggested that you conduct further study
    into regular expressions yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Regular expression 101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Regular expressions allow us to describe a pattern of characters. They are
    used for matching and extracting values from strings. For example, if we had a
    string that contained digits `(1,2,3)` at various positions, a regular expression
    would allow us to easily retrieve them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: 'A regular expression is written as a pattern delimited by forward slashes,
    with optional flags following the final forward slash:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: 'The pattern you write can contain both literal and special characters that
    together inform the regular expression engine of what to look for. The regular
    expression we''re using in our example contains literal characters (that is, `1`,
    `2`, `3`) and the pipe (that is, `|`) special character:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: The pipe special character tells the regular expression engine that the characters
    on the left or the right of the pipe may match. The `g`, following the final forward
    slash, is a *global* flag that directs the engine to search globally within the
    string and not to give up after the first match is found. For us, this means that
    our regular expression will match either `"1"`, `"2"`, or `"3"`, wherever they
    appear within a subject string.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are specific special characters we can use within regular expressions
    that act as shortcuts. The notation `[0-9]` is an example of this. It is a* character
    class* that will match all the digits from `0` to `9` so that we don''t have to
    list all of these digits individually. There is also a *shorthand character class*,
    `\d`, that allows us to express this even more succinctly. Thus, we can shorten
    our regular expression to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: 'For a more realistic application, we may imagine a scenario in which we wish
    to match sequences of digits, such as phone numbers. Perhaps we wish to match
    only those phone numbers beginning with `0800` and containing a further `4` to
    `6` digits. We could do this with the following regular expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are using the `{n, n}` syntax, which allows us to express a quantity
    for the preceding special character, `\d`. We can confirm that our pattern works 
    by passing it to a test string''s `match` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: This brief introduction only touches on the very surface of what regular expressions
    can do. The syntax of regular expressions allows us to express significant complexity,
    allowing us to validate that specific text exists within a string or to extract
    specific text for use within our programs.
  prefs: []
  type: TYPE_NORMAL
- en: RegExp flags
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The literal syntax of regular expressions allows for specific *flags*, such
    as `i` (*ignore-case*), to be specified after the final delimiting forward slash.
    These flags will affect the way the regular expression is executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: 'When using the `RegExp` constructor, you can pass your flags as the second
    argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: 'There are six available flags in JavaScript''s flavor of regular expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '`i`: The *ignore-case* flag will ignore the case of the string when matching
    letters (that is, `/a/i` would match both `''a''` andor `''A''` in a string).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`g`: The *global-match* flag will make the regular expression find *all* matches
    instead of stopping after the first match.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`m`: The *multiline* flag will make beginning and end anchors (that is, `^`
    and `$`) mark the beginnings and ends of individual lines instead of entire strings.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`s`: The *dotAll* flag will cause the dot character in your regular expression
    (which usually only matches non-newline characters) to match newline characters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`u`: The *Unicode* flag will treat the sequence of characters in your regular
    expression as individual Unicode code points instead of code units. This broadly
    means you can painlessly match and test for rare or exotic symbols such as emojis
    (see the section within this chapter on the `String` type to get a more thorough
    understanding of Unicode).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`y`: The *sticky* flag will cause all `RegExp` operations to attempt a match
    at the exact index detailed by the `lastIndex` property and then mutate `lastIndex`
    upon matches.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As we''ve seen, regular expressions can also be constructed via the `RegExp`
    constructor. This can usefully be invoked as both a constructor or a regular function:
    either way, you''ll receive a `RegExp` object equivalent to what was derived from
    the literal syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: This is quite a unique behavior. In fact, the `RegExp` constructor is the only
    natively provided constructor that can be invoked as both a constructor and a
    regular function and, in both cases, returns a new instance. You'll recall that
    the primitive constructors (such as `String` and `Number`) can be invoked as regular
    functions but will behave differently when invoked as constructors.
  prefs: []
  type: TYPE_NORMAL
- en: Methods accepting RegExp
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are seven methods provided by JavaScript that are capable of utilizing
    regular expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`RegExp.prototype.test(String)`: Runs the regular expression against the passed
    string and return true if it finds at least one match. It will return false if
    no matches are found.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RegExp.prototype.exec(String)`: If the regular expression has a global (`g`),
    flag then `exec()` will return the next match from the current `lastIndex` (and
    will update the regular expression''s `lastIndex` after doing so); otherwise,
    it will return the first match of the regular expression (similar to `String.prototype.match`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`String.prototype.match(RegExp)`: This `String` method will return a match
    (or if the global flag is set, all matches) of the passed regular expression made
    against the string.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`String.prototype.replace(RegExp, Function)`: This `String` method will execute
    the passed function on every single match and will, for each match, replace the
    matched text with whatever the function returns.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`String.prototype.matchAll(RegExp)`: This `String` method will return an iterator
    of all results and their individual groups. This is useful when you have a global
    regular expression with individual matching groups.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`String.prototype.search(RegExp)`: This `String` method will return the index
    of the first match or -1 if there are no matches found.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`String.prototype.split(RegExp)`: This `String` method will return an array
    containing parts of the string split by the provided separator (which can be a
    regular expression).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are many methods to choose from, but for most situations, you'll likely
    find that the `RegExp` method, `test()`, and the String methods, `match()` and
    `replace()`, are the most useful.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a rundown of some examples of these methods. This should give you an
    idea of the situations in which each method may be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: Most of these methods, as you can see, behave intuitively. However, there is
    some complexity surrounding *stickiness* and the `lastIndex` property, which we
    will now go over.
  prefs: []
  type: TYPE_NORMAL
- en: RegExp methods and lastIndex
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By default, if your `RegExp` is global (that is, uses the `g` flag), the `RegExp`
    methods (that is, `test()` and `exec()`) will mutate the `lastIndex` property
    of the `RegExp` object upon each execution. These methods will attempt to match
    the subject string from the index specified by the current `lastIndex` property,
    which is 0 by default, and will then update the `lastIndex` upon every subsequent
    call.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can lead to unexpected behavior if you expect `exec()` or `test()` to
    always return the same result for a given global regular expression and string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: 'It will also lead to confusion if you attempt to execute a global regular expression
    on more than one string without resetting the `lastIndex` yourself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, following the match with the `"monkeys"` substring, the `lastIndex`
    is updated to the next index (`7`),  which means, when executed on a different
    string, the regular expression will continue where it left off and attempt to
    match everything beyond that index, which in the case of the second string, `"birds
    flying"`, is the substring `"lying"`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a rule, to avoid these confusions, it''s important to always have ownership
    over your regular expressions. Don''t accept regular expressions from elsewhere
    in a program if you''re using `RegExp` methods. Also, don''t attempt to use `exec()` or
    `test()` on different strings without resetting the `lastIndex` before each execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: Here, you can see that, if we don't reset the `lastIndex`, our regular expression
    fails to match on subsequent strings that are passed to the `exec()` method. If,
    however, we reset the `lastIndex` prior to each subsequent `exec()` call, we'll
    observe a match.
  prefs: []
  type: TYPE_NORMAL
- en: Stickiness
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Stickiness means that a regular expression will try to match at the exact `lastIndex` and
    that, if a match is not available at that exact index, it will fail (that is,
    return `null` or `false`, depending on the method used). The sticky flag (`y`)
    will force `RegExp` to read and mutate `lastIndex` with each match. Traditionally
    sticky methods such as `exec()` and `test()`, as we mentioned previously, will
    always do this, but the `y` flag will *force* stickiness even when using non-sticky
    methods, such as `match()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: Stickiness can be useful if you're looking for a match at a specific index in
    a string or series of strings. However, its behavior can be unexpected if you're
    not in full control of `lastIndex`.  As we mentioned previously, a good general
    rule is to always have ownership over your own `RegExp` objects so that any mutations
    to `lastIndex` are only made by your code.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have begun to delve into JavaScript by looking at the built-in
    types that the language provides. The point of our exploration has been to look
    at these language constructs through the lens of clean code. By doing so, we've
    highlighted the importance of caution when dealing with some of the more obscure
    areas of the language. We've discovered many of the nasty edge cases and challenges
    involved in using JavaScript types, such as the lack of precision in the floating-point
    `Number` type and the complexity of Unicode in the `String` type. Exploring these
    more difficult parts of the language allows us not only to avoid specific traps
    but instills a fluency within us that will hugely boost our ability to wield JavaScript
    in the service of clean code.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will continue to enhance this fluency. We will learn
    more about JavaScript's type system and begin to operate on and manipulate these
    types to suit our needs.
  prefs: []
  type: TYPE_NORMAL
