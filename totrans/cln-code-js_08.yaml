- en: Primitive and Built-In Types
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原始和内置类型
- en: So far, we have explored the meaning of clean code from several different perspectives.
    We've explored how the code we write allows our users to wield remarkable complexity
    by leveraging abstractions. We've gone on to discuss the tenets of clean code,
    such as reliability and usability, and the various traps and challenges to watch
    out for when pursuing these goals.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经从几个不同的角度探讨了清晰代码的含义。我们探讨了我们编写的代码如何让用户通过利用抽象来处理复杂性。我们继续讨论了清晰代码的原则，如可靠性和可用性，以及在追求这些目标时需要注意的各种陷阱和挑战。
- en: In this chapter, we'll be exploring the JavaScript language itself, in great
    detail, including both the more common language constructs and the more obscure
    and confusing aspects. We'll be applying our accrued wealth of knowledge about
    clean code to all these parts of the language and will build an understanding
    of JavaScript that's tailored purely to the creation of clean code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将详细探讨 JavaScript 语言本身，包括更常见的语言构造和更晦涩和令人困惑的方面。我们将把我们对清晰代码的积累知识应用到语言的所有部分，并建立一个纯粹针对清晰代码创建的
    JavaScript 理解。
- en: 'We''ll begin by looking at the most atomic part of JavaScript: the primitive
    values that serve as the building blocks for any program. Then, we''ll move on
    to non-primitive values, known as **objects**. In our exploration of these types,
    we will, through examples, be exposing the semantics that make each type unique
    and the pitfalls to avoid in their usage. The crucial knowledge that we''ll gain
    in this chapter will be applied in later chapters as we build up a truly complete
    knowledge of what it means to write clean code in JavaScript.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从 JavaScript 最基本的部分开始：作为任何程序的构建块的原始值。然后，我们将转向非原始值，即**对象**。在我们探索这些类型时，我们将通过示例揭示使每种类型独特的语义和在使用中需要避免的陷阱。我们在本章中获得的关键知识将应用在后面的章节中，以便我们真正完全地了解在
    JavaScript 中编写清晰代码的含义。
- en: 'By the end of this chapter, you should feel comfortable in the following topic
    areas:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，你应该对以下主题感到自如：
- en: Primitive types
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原始类型
- en: Objects
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象
- en: Functions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数
- en: Arrays and iterables
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组和可迭代对象
- en: Regular expressions
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正则表达式
- en: Primitive types
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原始类型
- en: 'A primitive type in JavaScript is any value that is not an object and thus
    does not have any methods or properties. There are seven primitive types in JavaScript:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中，原始类型是指任何不是对象的值，因此没有任何方法或属性。JavaScript 中有七种原始类型：
- en: Number
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字
- en: String
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串
- en: Boolean
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布尔
- en: Undefined
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未定义
- en: 'Null'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空
- en: BigInt
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大整数
- en: Symbol
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 符号
- en: In this section, we'll explore the common characteristics among these primitives
    and delve into each individual type to explore how it works and what potential
    hazards exist in its usage. We'll gain an appreciation for how the JavaScript
    language itself is just a set of distinct abstractions that, when wielded masterfully,
    can make easy work of any problem domain.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探索这些原始值之间的共同特征，并深入研究每种类型，探讨它的工作原理以及在使用中存在的潜在危险。我们将欣赏到 JavaScript 语言本身只是一组不同抽象的集合，当巧妙地使用时，可以轻松解决任何问题领域。
- en: Immutability of primitives
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原始值的不可变性
- en: All primitive values are immutable, meaning that you cannot mutate their values.
    This is a core part of their primitiveness. You cannot, for example, change the
    number value of `3.14` to `42`, or change the value of a string to its uppercased
    variation.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 所有原始值都是不可变的，这意味着你不能改变它们的值。这是它们原始性的核心部分。例如，你不能将数字值 `3.14` 改变为 `42`，或者将字符串的值更改为它的大写变体。
- en: '**But I can change the value of a string to its uppercased variation!** You
    may be confused right now if you recall being able to do this. But there is a
    crucial distinction to be made here between the reassignment of variables to new
    primitive values, which is fully possible (and likely what you''re remembering),
    and the mutation of primitive values, which is not possible.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**但我可以将字符串的值更改为它的大写变体！** 如果你记得能够这样做，你现在可能会感到困惑。但这里需要做出一个重要的区分，即变量重新赋值为新的原始值是完全可能的（也可能是你记得的），而原始值的变异是不可能的。'
- en: 'When we reassign a variable, giving it a new value, we are not changing the
    value itself; we are only changing which value the variable refers to, as shown
    here:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们重新分配一个变量，给它一个新的值时，我们并没有改变值本身；我们只是改变了变量所引用的值，如下所示：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note how `copy` has remained lowercase. The primitive value `simon` has not
    been mutated; instead, a new primitive value has been derived from it, via the
    `toUpperCase` method, and then assigned to the variable that previously held the
    lowercase variant.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意 `copy` 保持小写。原始值 `simon` 没有被改变；相反，通过 `toUpperCase` 方法派生出一个新的原始值，然后赋给之前持有小写变体的变量。
- en: Primitive wrappers
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原始包装器
- en: You'll remember that we mentioned that primitive values don't have methods as
    they are not objects. So, how exactly are we able to call `toUpperCase` on the
    preceding string? Is that not a method? Yes, it is. And to allow us to access
    this method, JavaScript wraps primitive values in their respective wrapper objects
    at the time of property access. This occurs for all primitive values, apart from `null`
    and `undefined`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你会记得我们提到原始值没有方法，因为它们不是对象。那么，我们是如何能够在前面的字符串上调用 `toUpperCase` 的呢？那不是一个方法吗？是的，是方法。为了让我们能够访问这个方法，JavaScript
    在属性访问时会将原始值包装在它们各自的包装对象中。这适用于所有原始值，除了 `null` 和 `undefined`。
- en: 'Primitive values, in these moments of being wrapped, remain immutable but,
    via their wrapped instance, provide access to properties and methods. A string
    value would be wrapped in a `String` instance, while a number value would be wrapped
    in a `Number` instance. The same would occur for all other non-null and non-undefined
    primitives. You are free to instantiate these wrapper objects yourself: you will
    observe that they no longer behave like primitives, though; they are objects,
    and, as such, you can add and mutate properties on them:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些被包装的时刻，原始值保持不变，但是通过它们的包装实例，可以访问属性和方法。字符串值将被包装在`String`实例中，而数字值将被包装在`Number`实例中。对于所有其他非空和非未定义的原始值也是如此。您可以自由地实例化这些包装对象：您会发现它们不再像原始值那样行为了；它们是对象，因此您可以在它们上面添加和改变属性：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If you require an object to add custom properties to, it is best to use a plain
    object. Using wrapper objects for anything other than wrapping their primitive
    values is an anti-pattern as it would not be expected by other programmers. Nonetheless,
    it is useful to observe and remember the differences between primitives and their
    respective wrapper objects.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要一个对象来添加自定义属性，最好使用一个普通对象。除了用于包装其原始值以外的任何其他内容，都是一种反模式，因为其他程序员不会预期这样做。尽管如此，观察和记住原始类型及其相应包装对象之间的差异是很有用的。
- en: 'Invoking a wrapper constructor (for example, `Number`, `String`, and so on)
    as a regular function has a unique behavior. Instead of returning a new wrapper
    instance, it will cast the value to a particular type and return a regular primitive.
    This is quite useful when you''re casting one type to another:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 调用包装构造函数（例如`Number`，`String`等）作为常规函数具有独特的行为。它不会返回一个新的包装实例，而是会将值转换为特定类型并返回一个常规的原始值。当您需要将一种类型转换为另一种类型时，这是非常有用的：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Invoking wrapper constructors as functions, as we have done here, is a useful
    casting technique, though it's not the only one. We'll cover typecasting and coercion
    in a lot more detail in [Chapter 7](43f1d47f-08cd-4c87-a731-7c359ef3bedd.xhtml), *Dynamic
    Typing*.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 将包装构造函数作为函数调用，就像我们在这里所做的那样，是一种有用的转换技术，尽管这不是唯一的一种。我们将在[第7章](43f1d47f-08cd-4c87-a731-7c359ef3bedd.xhtml)中更详细地介绍类型转换和强制转换，*动态类型*。
- en: The falsy primitives
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 虚假原始值
- en: 'In JavaScript, all the values in Boolean contexts will evaluate to either `true`
    or `false`. To describe this behavior, we usually refer to values as either truthy
    or falsy. To determine the truthiness of a value, we can simply pass it to the
    `Boolean` function:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，布尔上下文中的所有值都将计算为`true`或`false`。为了描述这种行为，我们通常将值称为真实或虚假。要确定值的真实性，我们可以简单地将其传递给`Boolean`函数：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'There are only eight falsy values in JavaScript, and all of them are primitive
    types:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript中只有八个虚假值，它们都是原始类型：
- en: '`null`'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`null`'
- en: '`undefined`'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未定义
- en: '`+0`  or  `-0` (zero, a number)'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`+0`或`-0`（零，一个数字）'
- en: '`false` (a Boolean)'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`false`（布尔值）'
- en: '`""` (an empty string)'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`""`（空字符串）'
- en: '`0n` (zero, a `BigInt`)'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0n`（零，一个`BigInt`）'
- en: '`NaN` (not a number)'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NaN`（不是一个数字）'
- en: 'All values that are not falsy are, therefore, truthy. Throughout this and the
    next chapter, we will be exploring the implications of these truthy and falsy
    values. For now, it''s only important to know that the preceding falsy values
    will, when used in conditional or logical contexts, behave as if they were false.
    A falsy value, when used in an `if` statement, for example, would act the same
    as if it were false:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，所有不是虚假的值都是真实的。在本章和下一章中，我们将探讨这些真实和虚假值的含义。现在，只需要知道前面的虚假值在条件或逻辑上下文中使用时会表现得像假一样。例如，当虚假值在`if`语句中使用时，它会像假一样行事：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The existence of these falsy values means that we must be wary of how we check
    for certain conditions. It''s easy to fall into the trap of testing for the existence
    of a certain value state by using only its truthiness to determine existence.
    For example, let''s say that we need to be able to check for the age of a person:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这些虚假值的存在意味着我们必须谨慎地检查某些条件。很容易陷入陷阱，只使用其真实性来确定存在的某个值状态。例如，假设我们需要能够检查一个人的年龄：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This is a contrived example, but we can imagine a system in which the identities
    of individuals need to be processed somehow, perhaps through a medical application.
    Checking for the existence of the `age` property is not going to do what''s intended
    if the age happens to be 0\. Perhaps the system needs to cater to the eventuality
    of a newborn baby being entered into the system, but suddenly it breaks because
    the `age` is `0`. In such scenarios, it''s best to be preemptively explicit, even
    if you don''t expect odd falsy values. In this context, we likely want to check
    for either `null` or `undefined`, so we should explicitly do that:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个牵强的例子，但我们可以想象一个需要以某种方式处理个体身份的系统，也许是通过医疗应用。如果年龄恰好为0，检查`age`属性的存在将不会达到预期的效果。也许系统需要适应新生儿被输入系统的可能性，但突然间因为`age`是`0`而崩溃。在这种情况下，最好是预先明确，即使您不希望出现奇怪的虚假值。在这种情况下，我们可能希望检查`null`或`undefined`，因此我们应该明确这样做：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This code is far more resilient to the possible variabilities of the `age` property.
    We could also, perhaps, be more in line with our requirements and check only for
    the specific characteristics that we are interested in, such as that the age property
    is a number within specific bounds. The point is that it's better to be explicit
    in Boolean contexts such as `if` statements so that you don't run into an unexpected
    falsy value.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码对`age`属性的可能变化更具弹性。我们也可以更符合我们的要求，仅检查我们感兴趣的特定特征，比如`age`属性是在特定范围内的数字。关键是在布尔上下文中，比如`if`语句中最好是明确的，这样您就不会遇到意外的虚假值。
- en: Number
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数字
- en: 'The number primitive type is used to express numerical data. It stores this
    data in the double-precision 64-bit floating-point format (IEEE 754). 64 bits
    here refers to there being 64 binary digits available to store information. The
    entire 64-bit format that''s used in the IEEE 754 standards can be broken down
    into three chunks:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 数字原始类型用于表示数字数据。它以双精度64位浮点格式（IEEE 754）存储这些数据。这里的64位指的是有64个二进制数字可用于存储信息。在IEEE
    754标准中使用的整个64位格式可以分解为三个部分：
- en: '**1 bit for the sign of the number being represented**: Whether the number
    is positive or negative'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数字的符号需要1位**：表示数字是正数还是负数'
- en: '**11 bits for the exponent of the number**: This tells us where the radix or
    decimal dot resides'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数字的指数需要11位**：这告诉我们小数点的位置'
- en: '**52 bits for what''s termed the fraction or significand**: This tells us the
    integer value'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用于分数或有效数字的52位**：这告诉我们整数值'
- en: 'A side effect of this floating-point formation means that there are technically
    two zeros: positive zero (`+0`) and negative zero (`-0`). Thankfully, in JavaScript,
    you don''t have to be explicit when checking for these values. Both will return
    true when compared with the strict equality operator ( `+0 === -0`) and both are
    considered falsy.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点形式的一个副作用是，从技术上讲有两个零：正零（`+0`）和负零（`-0`）。幸运的是，在JavaScript中，您在检查这些值时不必明确指定。当使用严格相等运算符（`+0
    === -0`）进行比较时，两者都将返回true，并且都被视为假值。
- en: 'Technically, there are 53 bits available (not 52) for the expression of an
    integer value as the leading bit of the significand field resides within the exponent
    field. This is an important clarification as it has a direct effect on how much
    precision we can get from JavaScript numbers. Having 53 bits available to express
    an integer value means that any numbers greater than *2^(53)-1* are considered
    unsafe. These safety limits are available as constants on the `Number` object:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，有53位可用（而不是52）来表示整数值，因为有效数字字段的最高位位于指数字段内。这是一个重要的澄清，因为它直接影响了我们可以从JavaScript数字中获得多少精度。有53位可用于表示整数值意味着任何大于*2^(53)-1*的数字都被认为是不安全的。这些安全限制作为`Number`对象的常量可用：
- en: Integers larger than `2^(53)` or `9007199254740991` (`Number.MAX_SAFE_INTEGER`)
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大于`2^(53)`或`9007199254740991`（`Number.MAX_SAFE_INTEGER`）的整数
- en: Integers smaller than `-2^(53)` or `-9007199254740991` (`Number.MIN_SAFE_INTEGER`)
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小于`-2^(53)`或`-9007199254740991`（`Number.MIN_SAFE_INTEGER`）的整数
- en: 'The loss of precision beyond these bounds can be observed if we try to perform
    addition on the upper limit:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试对上限进行加法，就会观察到超出这些范围的精度损失：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, we can see that the evaluated additions are incorrect. Beyond `MAX_SAFE_INTEGER`,
    all mathematical operations will be similarly imprecise.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到评估的加法是不正确的。超出`MAX_SAFE_INTEGER`，所有数学运算都将同样不精确。
- en: It is still possible to express values larger than `MAX_SAFE_INTEGER` within
    JavaScript. Many values up to `2^(1024)` (`Number.MAX_VALUE`) can be expressed,
    but many cannot. Therefore, it is considered very unwise to attempt to express
    numbers beyond `Number.MAX_SAFE_INTEGER`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中仍然可以表示大于`MAX_SAFE_INTEGER`的值。可以表示多达`2^(1024)`（`Number.MAX_VALUE`）的许多值，但也有许多值无法表示。因此，尝试表示超出`Number.MAX_SAFE_INTEGER`的数字被认为是非常不明智的。
- en: 'To sum this up, any values between `Number.MIN_SAFE_INTEGER` and `Number.MAX_SAFE_INTEGER`
    are safe to use and will provide integer precision, while values beyond these
    bounds should be considered unsafe. If we feel ourselves needing an integer outside
    of these bounds, then we can use JavaScript''s `BigInt` primitive:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，任何介于`Number.MIN_SAFE_INTEGER`和`Number.MAX_SAFE_INTEGER`之间的值都是安全的，并且将提供整数精度，而超出这些范围的值应被视为不安全。如果我们需要超出这些范围的整数，那么我们可以使用JavaScript的`BigInt`原始类型：
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We''ll explore the `BigInt` primitive further in a later part of this section.
    For now, just remember to always consider the largeness of your numbers and whether
    they can be fully accommodated by JavaScript''s `Number` type. It''s also important
    to consider the precision of decimal values (such as in fractions) as well. When
    expressing decimals in JavaScript, you''ll likely encounter issues like this:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本节的后面进一步探讨`BigInt`原始类型。现在，只需记住始终考虑您的数字的大小以及它们是否可以完全由JavaScript的`Number`类型容纳。同样重要的是考虑小数值的精度（例如在分数中）。在JavaScript中表示小数时，您可能会遇到此类问题：
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This is due to inherent mechanism by which fractions are expressed in the floating-point
    standard. You can imagine that if we were interested in querying whether a decimal
    is equal to, greater than, or less than another value, it would be as simple as
    using the following code:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这是由浮点标准中表达分数的固有机制所致。您可以想象，如果我们有兴趣查询一个小数是否等于、大于或小于另一个值，那么使用以下代码将会非常简单：
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'But `yay()` will never run. To get around this problem, there are two options.
    The first involves something called the epsilon. The epsilon is the margin of
    error inherent to floating-point math, and JavaScript makes this available to
    use as `Number.EPSILON`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 但`yay()`永远不会运行。为了解决这个问题，有两个选择。第一个涉及到一个叫做epsilon的东西。Epsilon是浮点数学固有的误差范围，JavaScript使其可用作`Number.EPSILON`：
- en: '[PRE11]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This is a very tiny number, but it must be taken into account if we are to
    have a hope of doing basic mathematical operations on decimals. If we wish to
    compare two numbers, we can simply subtract them from each other and check that
    the margin is less than the `EPSILON`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常小的数字，但如果我们希望对小数进行基本的数学运算，就必须考虑到它。如果我们希望比较两个数字，我们可以简单地将它们相互减去，并检查边际是否小于`EPSILON`：
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The other approach we can take is to convert any decimals we''re dealing with
    into integers expressed by either `Number` or `BigInt` types. So, if we have a
    need to represent values from `0` to `1` with a precision of eight decimal places,
    for example, then we can simply multiply these values by `100,000,000` (or `10⁸`):'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以采取的另一种方法是将我们处理的任何小数转换为由`Number`或`BigInt`类型表示的整数。因此，如果我们需要以八位小数的精度表示从`0`到`1`的值，那么我们可以简单地将这些值乘以`100,000,000`（或`10⁸`）：
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now, we are free to conduct integer math on these values and divide them back
    down into their fractions when done. It's crucial to note that any decimal value
    longer than 15 digits cannot be expressed in JavaScript's `Number` type, so you'll
    need to explore other options. JavaScript currently doesn't have a native `BigDecimal`
    type, but there are many third-party libraries available that fulfill a similar
    purpose (you can easily find these online).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以自由地对这些值进行整数运算，并在完成后将它们分解为分数。需要注意的是，任何小数值超过15位数字都无法在JavaScript的`Number`类型中表示，因此您需要探索其他选项。JavaScript目前没有本地的`BigDecimal`类型，但有许多第三方库可用来实现类似的目的（您可以轻松在网上找到这些）。
- en: If you ever find yourself needing to operate on large or very precise numbers
    in JavaScript, or if your code concerns sensitive matters such as finance, medicine,
    or science, it's absolutely crucial to take the time to fully understand what
    levels of precision you require and whether JavaScript can natively support those
    needs.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您发现自己需要在JavaScript中操作大型或非常精确的数字，或者如果您的代码涉及财务、医学或科学等敏感事项，那么完全理解您需要的精度级别以及JavaScript是否可以原生支持这些需求是非常重要的。
- en: 'There''s one more topic to discuss under the `Number` type, and that is `NaN`. `NaN`
    is a primitive that technically belongs to the `Number` type. It represents a
    failure to parse something as a number; for example, `Number(''wow'')` evaluates
    to `NaN`. Since `typeof NaN` is a `number`, we should check for a valid number
    in the following way:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个`Number`类型下要讨论的话题，那就是`NaN`。`NaN`是一个技术上属于`Number`类型的原始值。它表示无法将某些东西解析为数字；例如，`Number('wow')`评估为`NaN`。由于`typeof
    NaN`是`number`，我们应该以以下方式检查有效数字：
- en: '[PRE14]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The value `NaN` can create a headache when its existence is not foreseen. It'll
    usually crop up in areas where you're attempting to cast strings to numbers or
    where this happens implicitly (coercion).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当没有预见到`NaN`的存在时，它可能会带来麻烦。它通常会出现在您试图将字符串转换为数字或在这种情况下隐式发生（强制转换）的地方。
- en: We'll be covering the topic of coercion, casting, and detection more in the
    next chapter. This will include a section where we get into the complexity of
    `NaN` and compare `isNaN()`, the global function, to the slightly different `Number.isNaN()`.
    For now, it's only important to appreciate that `NaN` is its own distinct value
    and is itself, oddly, considered a number within JavaScript.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一章中更多地涵盖强制、转换和检测的主题。这将包括一个部分，我们将深入探讨`NaN`的复杂性，并比较全局函数`isNaN()`与稍有不同的`Number.isNaN()`。目前，重要的是要欣赏`NaN`是其自己独特的值，并且在JavaScript中奇怪地被认为是一个数字。
- en: 'There is another value encapsulated by the `Number` type that is not a normal
    number: `Infinity`. You will receive `Infinity` when you attempt to do mathematical
    operations such as dividing by `0`:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`Number`类型中封装的另一个值不是普通数字：`Infinity`。当您尝试进行数学运算，如除以`0`时，您将收到`Infinity`：'
- en: '[PRE15]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`Infinity`, like `NaN`, is a globally available primitive value that you can
    reference and check for:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`Infinity`，就像`NaN`一样，是一个全局可用的原始值，您可以引用和检查：'
- en: '[PRE16]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'There is also `-Infinity`, which is technically a distinct value:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 还有`-Infinity`，这在技术上是一个不同的值：
- en: '[PRE17]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`Infinity`, like `NaN`, is of the `Number` type, so when passed to the `typeof`
    operator, it will evaluate to `"number"`:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`Infinity`，就像`NaN`一样，属于`Number`类型，因此当传递给`typeof`运算符时，它将被评估为`"number"`：'
- en: '[PRE18]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Outside of `Infinity`, `-Infinity`, and `NaN`, all values that are of the `Number`
    type can be considered regular everyday numbers. Overall, and for most use cases,
    the `Number` type is very simple to use and operate on. It is, however, vital
    to know about its limitations, many of which we've covered here so that you can
    make an informed decision about when it may not be appropriate to use.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`Infinity`、`-Infinity`和`NaN`之外，所有属于`Number`类型的值都可以被视为普通的日常数字。总的来说，对于大多数用例，`Number`类型非常简单易用。然而，了解它的限制是非常重要的，我们在这里涵盖了许多限制，以便您可以明智地决定何时不适合使用它。
- en: String
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串
- en: The `String` type in JavaScript allows us to express sequences of characters.
    It is usually used to encapsulate words, sentences, lists, HTML, and many other
    forms of text-like content.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript中的`String`类型允许我们表示字符序列。它通常用于封装单词、句子、列表、HTML和许多其他形式的文本内容。
- en: 'Strings are expressed by delimiting sequences of characters with either single
    quotes, double quotes, or backticks:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串通过用单引号、双引号或反引号界定字符序列来表示：
- en: '[PRE19]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Only backtick-delimited strings, known as **template literals** (or template
    strings), can occupy multiple lines. Single quote- or double quote-delimited strings
    can technically be spread along multiple lines as well, but this is only achieved
    by escaping their invisible newline characters (with a `\` character), which effectively
    removes the newlines:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 只有用反引号界定的字符串，称为**模板文字**（或模板字符串），才能占据多行。单引号或双引号界定的字符串也可以在多行上分布，但这只能通过转义它们的不可见换行字符（使用`\`字符）来实现，这实际上删除了换行：
- en: '[PRE20]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Nowadays, template literals are preferred as they retain newlines and allow
    us to interpolate arbitrary expressions, like so:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，模板文字被认为是首选，因为它们保留了换行，并允许我们插入任意表达式，就像这样：
- en: '[PRE21]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Strings come with a number of curious challenges once your usage exceeds the
    most simple use cases. Under the surface, the humble string is masking a miraculous
    scale of complexity in the form of Unicode.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您的使用超出了最简单的用例，字符串就会带来许多有趣的挑战。在表面下，这个普通的字符串掩盖了Unicode形式的复杂性奇迹。
- en: Unicode is an industry standard for the encoding, representation, and handling
    of text that's used in writing systems around the world. The Unicode standard
    contains over 130,000 characters, including all of your favorite emojis.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Unicode是一个行业标准，用于编码、表示和处理世界各地书写系统中使用的文本。Unicode标准包含超过130,000个字符，包括所有您喜爱的表情符号。
- en: 'To step beneath the veneer of the String abstraction slightly, we can say that
    Strings in JavaScript are really just an ordered sequence of 16-bit unsigned integers.
    Each of these integers is interpreted as a UTF-16 code unit. UTF-16 is a type
    of encoding for the Unicode character set. Using it, we are able to express hundreds
    of thousands of valid Unicode code points. This means that we can express emojis,
    many languages, and a myriad of Unicode oddities via our strings:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/1cfee330-5c7a-4adf-9e65-53644f2acf6e.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
- en: 'A Unicode code point is a character (such as the letter *B*, a question mark,
    or a smiling emoji). We can express a code point by using one or more UTF-16 code
    units. Most code points that we use from day to day only need a single code unit.
    These are known as **scalars**. There are, however, quite a few Unicode code points
    that require a pair of code units (known as a **surrogate pair**). The panda emoji
    is an example of such a surrogate pair:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/932e06b3-c837-45a4-9998-fa9e94b15f83.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
- en: Since UTF-16 only has 16 bits to work with, it has to use pairs of 16-bit integers
    to express some characters. Naturally, if we're using UTF-32 encoding (with 32
    bits to play with), then we'd be able to express the panda emoji in a single 32-bit
    integer.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: Here, we've used `charCodeAt()` to determine the individual UTF-16 code units
    of the Panda emoji and we've found that these are the *55,357^(th)* and *56,380^(th)*
    decimal code units within Unicode. Since there are so many code units, it is simpler
    and more convenient to use hexadecimal digits to express them, so we can say that
    the panda emoji is expressed by code units  `U+D83D` and `U+DC3C` (Unicode hexadecimal
    values are conventionally prefixed with `U+`).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to surrogate pairs, there is another type of combination that''s
    useful to know about. The *Combining Code Point* enables certain traditional *non-combining* code
    points to be augmented into new characters. Examples of this include traditional
    Latin characters that can be augmented with accents or other augmentations, such
    as the combining tilde:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/74a8f34d-49af-4c20-91ec-ff6a9c3a72b3.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
- en: We've chosen to express this particular combining character via a Unicode escape
    sequence (`\u0303`). The format of `\uXXXX` allows us to express Unicode code
    units between `U+0000` and `U+FFFF` within JavaScript strings.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: The range of Unicode between `U+0000` and `U+FFFF` is known as the **Basic Multilingual
    Plane** (**BMP**) and includes the most commonly used everyday characters.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: 'Our panda emoji, as we''ve already seen, is quite an obscure symbol. It does
    not exist on the BMP and is thus expressed by a surrogate pair of two UTF-16 code
    units. We can express these individually in JavaScript strings via two Unicode
    escape sequences:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/027dce04-a27f-41cb-8b99-e4c742858944.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
- en: 'More obscure and ancient symbols are found in the *supplementary* (or *astral*)
    planes between `U+010000` and `U+10FFFF`. The escaping format of `\uXXXX` does
    not have enough slots for us to express these. Symbols within the astral planes
    require at least five hexadecimal digits to express, so we must use the more recently
    introduced escape sequence format of `\u{X}`. This provides up to six hexadecimal
    slots (`\u{XXXXXX}`) and can thus express over 1 million different code points.
    Using this type of escape sequence, we can express our Panda emoji directly via
    its 32-bit representation (`U+1F43C`):'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/8ac0deef-10e0-4718-a4f9-686f78db91fa.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
- en: 'The newer `\u{X}` escape sequence is really convenient and goes some way in
    making Unicode less burdensome to use than JavaScript. But there is still a little
    more complexity to explore. Surrogate pairs and combining characters are examples
    where UTF-16 code units are combined to produce individual symbols. On top of
    this, there are longer sequences called **grapheme clusters**. These are used
    to express combinations of code points that can be combined to create an aggregate
    symbol:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 新的`\u{X}`转义序列非常方便，使得Unicode比JavaScript更易于使用。但是还有更多复杂性需要探索。代理对和组合字符是UTF-16代码单元组合成单个符号的例子。此外，还有更长的序列称为**图形簇**。这些用于表示可以组合成一个聚合符号的代码点组合：
- en: '![](assets/1eb89558-39ae-414f-a0fd-fa6322c9fe8b.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/1eb89558-39ae-414f-a0fd-fa6322c9fe8b.png)'
- en: 'Wow! Unicode is a pretty incredible feat of engineering, but it can make things
    complicated for us. The ability to combine Unicode in all of these ways (combining
    characters, surrogate pairs, and grapheme clusters) creates a challenge for us.
    JavaScript strings, as you may know, have a `length` property. This property returns
    the number of code units in a given string (that is, the number of 16-bit integers
    in the entire sequence). For most strings, this is straightforward:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！Unicode是一项非常了不起的工程成就，但它可能会让我们的事情变得复杂。能够以所有这些方式组合Unicode（组合字符、代理对和图形簇）对我们来说是一个挑战。JavaScript字符串，你可能知道，有一个`length`属性。这个属性返回给定字符串中代码单元的数量（即整个序列中的16位整数）。对于大多数字符串来说，这是直接的：
- en: '[PRE22]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'However, as we know, we are able to combine code units to create code points
    and we are also able to combine code points to create grapheme clusters. This
    means the `length` property, which is only concerned with the 16-bit code units,
    can give us unexpected results:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，正如我们所知，我们能够组合代码单元来创建代码点，也能够组合代码点来创建图形簇。这意味着`length`属性，它只关注16位代码单元，可能会给我们带来意想不到的结果：
- en: '![](assets/db5089b2-18e2-45bf-9195-d6d02babb3a3.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/db5089b2-18e2-45bf-9195-d6d02babb3a3.png)'
- en: The smiling-face emoji is composed of two code units, so JavaScript correctly
    tells us this string has a length of `2`. But this may not be what we expect or
    desire. It's even more challenging when we're dealing with grapheme clusters that
    may use a dozen different code units to express a single symbol.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 笑脸表情符号由两个代码单元组成，因此JavaScript正确告诉我们这个字符串的长度为`2`。但这可能不是我们期望或希望的结果。当我们处理可能使用十几个不同代码单元来表示单个符号的图形簇时，情况会更加复杂。
- en: Watch out when attempting to truncate or establish the width of a piece of text
    within a UI using only its `length` property. Due to the fact that many Unicode
    symbols may be expressed by multiple code units, using `length` alone is not reliable.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在UI中尝试仅使用其`length`属性截断或确定文本的宽度时要小心。由于许多Unicode符号可能由多个代码单元表示，仅使用`length`是不可靠的。
- en: Throughout this section, we've explored the tricky domain of Unicode. Va our
    new understanding of it, we're now far more empowered to cleanly work with strings
    in JavaScript. Excluding the complexity of Unicode, the behavior of strings in
    JavaScript is rather intuitive and shouldn't cause many headaches as long as we
    use them in a way that clearly communicates our intent.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了Unicode的棘手领域。通过对它的新理解，我们现在更有能力在JavaScript中清晰地处理字符串。除了Unicode的复杂性，JavaScript中的字符串行为相当直观，只要我们以能清晰传达意图的方式使用它们，就不应该引起太多头痛。
- en: Boolean
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Boolean
- en: 'The `Boolean` primitive type in JavaScript is used to represent either `true`
    or `false`. These polar opposites are its only values:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript中的`Boolean`原始类型用于表示`true`或`false`。这两个极端是它唯一的值：
- en: '[PRE23]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Semantically, Booleans are used to represent real-life or problem domain values
    that can be considered on or off (`0` or `1`), for example, whether a feature
    is enabled, or whether the user is over a certain age. These are Boolean characteristics
    and so are appropriate to express via Boolean values. We can use such values to
    dictate control flow within a program:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 从语义上讲，布尔值用于表示现实生活或问题域的值，可以被认为是开启或关闭（`0`或`1`），例如，一个功能是否启用，或者用户是否超过一定年龄。这些都是布尔特征，因此适合通过布尔值来表达。我们可以使用这些值来控制程序中的控制流程：
- en: '[PRE24]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `Boolean` primitive, just like `String` and `Number`, can be manually wrapped
    in a wrapper instance like so:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boolean`原始类型，就像`String`和`Number`一样，可以手动包装在包装实例中，如下所示：'
- en: '[PRE25]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Note that, once you do this, `Boolean` will behave just like any other object
    in conditional statements. So, the following conditional statement will succeed,
    even though the wrapped primitive value is `false`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，一旦你这样做，`Boolean`将会像条件语句中的任何其他对象一样行为。因此，即使包装的原始值是`false`，以下条件语句也会成功：
- en: '[PRE26]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `Boolean` instance here is not equivalent to its primitive value; it merely contains its
    primitive value. `isFalseObj` will behave just like any other Object in a `Boolean`
    context, resolving to `true`. Manually wrapping a `Boolean` like this is not especially
    useful and should be avoided as an anti-pattern in most programs as it doesn't
    behave according to Boolean semantics and may produce unexpected results.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的`Boolean`实例与其原始值不等效；它只是包含其原始值。在`Boolean`上下文中，`isFalseObj`将像`Boolean`上下文中的任何其他对象一样，解析为`true`。手动包装`Boolean`不是特别有用的，应该在大多数程序中避免使用，因为它不符合布尔语义，可能会产生意外结果。
- en: '`Boolean` primitives are returned by JavaScript''s logical operators such as
    greater than or equal to (`>=`) or strict equality (`===`). We''ll cover these
    in more detail in [Chapter 8](d8c326c9-db6f-4562-b92d-975dd0159182.xhtml),*Operators*.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript的逻辑运算符（如大于或等于（`>=`）或严格相等（`===`））返回`Boolean`原始值。我们将在[第8章](d8c326c9-db6f-4562-b92d-975dd0159182.xhtml)中更详细地介绍这些内容，*运算符*。
- en: BigInt
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: BigInt
- en: 'The `BigInt` primitive type in JavaScript is used to represent an integer of
    arbitrary precision. This means that it can be used to represent integers that
    are not able to be precisely represented by JavaScript''s `Number` type (anything
    larger than ~*2^(53)*). Literal BigInts are declared by suffixing any sequence
    of digits with the `n` character, like so:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '`BigInt` is capable of representing integers of arbitrary precision, meaning
    that you can store integers of unlimited length. This is especially useful in
    financial applications or any case where high-accuracy integers need to be expressed
    and operated on.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: 'A `BigInt` can only operate on itself, and is therefore not compatible with
    many of JavaScript''s native `Math` methods:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'All native mathematics operators work with `BigInt` as long as both operands
    are of the same type:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'However, if one operand is a `BigInt` and the other is a `Number`, then you''ll
    receive a `TypeError`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The semantics of a `BigInt` is similar to `Number`: any value that is intuitively
    numerical and can be expressed as an integer can be stored in either `BigInt`
    or `Number`, depending on the extent of precision that it requires.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: Symbol
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A `Symbol` primitive is used to represent an entirely unique value. Symbols
    are created via invoking the `Symbol` function, like so:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'You can optionally pass an initial argument to this function to annotate your
    symbol for your own debugging purposes, but this is not necessary:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Symbols are used to act as property keys where uniqueness is required or where
    you want to store metadata on objects. When you add a property to an object with
    a `Symbol` key, it will not be iterated over by normal object iteration approaches
    (such as `for...in`). `Symbol` keys of an object can only be retrieved via `Object.getOwnPropertySymbols`:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Since `Symbol` keys exist in an explicit but hidden manner, they are useful
    for storing programmatic information semantically that''s unrelated to the core
    data of the object but useful in fulfilling some programmatic need. For example,
    you may have a logging library and wish to annotate specific objects with custom-rendering
    functions that log in a specific way. Such a need could be easily fulfilled with
    symbols:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: There are not many everyday situations that would necessitate the creation and
    usage of new symbols, but there are many instances of prescribing native behavior
    by such symbols. For example, you can define a custom iterator for your object
    by using the `Symbol.iterator` property. We will cover this in greater detail
    in the *Arrays and iterables* section, later in this chapter.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: 'null'
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `null` primitive type is used to express the intentional absence of a value.
    It is a type with only one value: the only null value is `null`.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: The semantics of `null` are crucially different from `undefined`. The `undefined` value
    is used to indicate something that is not declared or defined, while `null` is
    an explicitly declared absent value. We usually use the `null` value to indicate
    that a value is either explicitly not yet set or, for whatever reason, unavailable.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s consider an API where we specify various properties related
    to a restaurant review:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The `null` value, in this context, means that we do not know the value of `hasParking` yet.
    When we have the necessary information, we can specify `hasParking` as either `true`
    or `false` (`Boolean`), but to express our ignorance of its true value, we're
    setting it to `null`. We could also completely leave the value out, meaning that
    it would effectively be `undefined`. The key difference is that using `null` is
    always proactively done, while `undefined` is the result of wh something isn't
    done.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: 'A `null` value, as we mentioned previously, is always falsy, meaning that it
    will always evaluate to `false` in a `Boolean` context. So, if we attempt to use
    `null` in a conditional statement, then it would not succeed:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'It is important to check for the exact values we want so that we can avoid
    bugs and communicate effectively to the people reading our code. In this case, 
    we may wish to explicitly check for `undefined` and `null` as we want to execute
    distinct code for that case versus the case of `false`. We could accomplish this
    like so:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要检查我们想要的确切值，这样我们可以避免错误并有效地向阅读我们代码的人传达信息。在这种情况下，我们可能希望明确检查`undefined`和`null`，因为我们想要针对这种情况执行不同的代码，而不是针对`false`的情况。我们可以这样做：
- en: '[PRE37]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We can also use the abstract equality operator (*`==`*) to compare to `null`,
    which will helpfully evaluate to `true` if the operand is either `null` or `undefined`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用抽象相等运算符（`==`）来与`null`进行比较，如果操作数是`null`或`undefined`，它将有用地评估为`true`：
- en: '[PRE38]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This is, in fact, doing the same as the more explicit comparison, but is far
    more succinct. Unfortunately, it's not very clear that its intention is to check
    for both `null` and `undefined`. We should usually prefer being explicit as this
    allows us to communicate our intent to other programmers in a more efficient way.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，这与更明确的比较是一样的，但更加简洁。不幸的是，它并不清楚它的意图是检查`null`和`undefined`。通常我们应该更加明确，因为这样可以更有效地向其他程序员传达我们的意图。
- en: A final trap to avoid with null is the `typeof` operator. Due to some legacies
    of the JavaScript language, `typeof null` will, rather confusingly, return `"object"`
    and is therefore entirely unreliable.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 要避免的最后一个陷阱是`null`的`typeof`运算符。由于JavaScript语言的一些遗留问题，`typeof null`会返回`"object"`，因此完全不可靠。
- en: More information about `typeof` and detection of the `null` type can be found
    in [Chapter 7](43f1d47f-08cd-4c87-a731-7c359ef3bedd.xhtml), *Dynamic Typing*,
    in the *Detection* section.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`typeof`和检测`null`类型的更多信息可以在[第7章](43f1d47f-08cd-4c87-a731-7c359ef3bedd.xhtml)的*动态类型*中的*检测*部分找到。
- en: 'So, there you have it. Null is a simple enough value and, insofar as clean
    code is concerned, you won''t go wrong if you remember two key points: that it
    should only be used to express the intentional absence of a value and that it
    should, ideally, be checked explicitly (prefer `value === null`).'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，你已经知道了。`null`是一个足够简单的值，在干净的代码方面，只要记住两个关键点就不会出错：它只应该用来表示有意识地缺少一个值，并且最好明确地检查它（最好使用`value
    === null`）。
- en: undefined
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: undefined
- en: 'The `undefined` primitive type expresses that something hasn''t been defined
    yet or remains undefined. Like `null`, it is a type with only one value (`undefined`). Unlike
    `null`, an `undefined` value should not be explicitly set, but may be returned
    by the language when something does not have a value:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`undefined`原始类型表示某物尚未被定义或仍然未定义。与`null`一样，它是一个只有一个值（`undefined`）的类型。与`null`不同，`undefined`值不应该被明确设置，但当某物没有值时语言可能会返回它：'
- en: '[PRE39]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Undefined is best thought of as the absence of something. If you ever find yourself
    wishing to explicitly set something to `undefined`, you should probably reach
    for `null` instead.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 未定义最好被认为是某物的缺失。如果你发现自己希望明确地将某物设置为`undefined`，你应该考虑使用`null`代替。
- en: 'It''s important to distinguish between the concepts of undefined and not even
    declared. In JavaScript, if you try to evaluate an identifier that does not exist
    within your scope, you will get a `ReferenceError`:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要区分未定义和甚至未声明的概念。在JavaScript中，如果你尝试评估一个在你的范围内不存在的标识符，你会得到一个`ReferenceError`：
- en: '[PRE40]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'However, as you''ve already seen, if you try to evaluate a property of an object
    and the property does not exist, you will get no such error. Instead, it will
    evaluate to `undefined`:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，正如你已经看到的，如果你尝试评估一个对象的属性，而该属性不存在，你将不会得到任何错误。相反，它将评估为`undefined`：
- en: '[PRE41]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'However, if you try to access a property under the non-existent `foo` property,
    you''ll receive a `TypeError` complaining that it cannot read a property that
    has an `undefined` value:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你尝试访问不存在的`foo`属性下的属性，你将收到一个`TypeError`，抱怨它无法读取一个具有`undefined`值的属性：
- en: '[PRE42]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This behavior is an extension of the fact that seeking to access any property
    on an `undefined` or `null` value will always throw such a `TypeError`:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为是寻求访问`undefined`或`null`值的任何属性时总是会抛出`TypeError`的扩展：
- en: '[PRE43]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Curiously, the `undefined` value, unlike `null`, is not a literal, but is a
    globally available value provided by the language. Overwriting this global value
    is not possible in ECMAScript 2015 onward, but it is still possible to define
    your own value for the undefined identifier in local (non-global) scopes:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，与`null`不同，`undefined`值不是一个字面量，而是语言提供的一个全局可用的值。在ECMAScript 2015及以后的版本中不可能覆盖这个全局值，但在本地（非全局）范围内定义自己的`undefined`标识符的值仍然是可能的：
- en: '[PRE44]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'This is an anti-pattern as it can create very awkward and unexpected results.
    The accidental setting of `undefined` in a scope higher than your scope can mean
    that, if you were to rely on the value directly, you may end up referring to a
    value other than `undefined`. This lack of trust in the `undefined` value has
    historically meant that people have found other ways to forcefully make `undefined`
    available in their scope. For example, declaring a variable but not assigning
    it will always result in its value being `undefined`:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种反模式，因为它可能会产生非常尴尬和意想不到的结果。在比你的范围更高的范围意外设置`undefined`可能意味着，如果你依赖于该值，你最终可能会引用一个不是`undefined`的值。对`undefined`值的不信任在历史上意味着人们已经找到其他方法来强制在他们的范围内使`undefined`可用。例如，声明一个变量但不给它赋值将始终导致它的值为`undefined`：
- en: '[PRE45]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'You can also use JavaScript''s `void` operator on any value that will always
    return the `real` undefined value:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以对任何值使用JavaScript的`void`运算符，它将始终返回`real`的`undefined`值：
- en: '[PRE46]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Explicitly setting undefined within your scope means that you can safely refer
    to your `undefined` value without worrying that it has been compromised. Fortunately,
    however, you can avoid the pain of having to worry about this risk by using the `typeof`
    operator:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的范围内明确设置未定义意味着你可以安全地引用你的`undefined`值，而不必担心它已被破坏。然而，幸运的是，你可以通过使用`typeof`运算符来避免担心这种风险的痛苦：
- en: '[PRE47]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This will not throw a `ReferenceError` even if `myValue` does not exist. The
    `typeof` operator, as we've discovered with `null`, is a bit of a fair-weather
    friend as we can't always rely on it, but it is nonetheless very useful when explicitly
    checking for `undefined`.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: Another way to avoid the risk of undefined is to enforce its correct usage within
    your code base by using a linting tool. We'll cover linting tools in [Chapter
    15](be9ab437-faeb-4a14-8a5f-663ddba470fd.xhtml), *Tools for Cleaner Code.*
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: 'In summary, `undefined` can be used cleanly if you remember the following two
    points:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Avoid directly assigning `undefined` to a variable; you should use `null` instead
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Always check for `undefined` explicitly, preferring the `typeof` operator
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This concludes our exploration of primitive types in JavaScript. Now, we'll
    move on to non-primitives, that is, objects.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: Objects
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Everything that is not a primitive value in JavaScript can be considered an
    object. Even functions are, in fact, specialized objects; their only difference
    is that they can be invoked. Usually, however, when we use the term `Object`,
    we are referring to a plain object that is normally declared as an object literal
    delimited by curly braces, with a set of key-value pairs within:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'You can also instantiate an object via the `Object` constructor and then add
    properties directly:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Even though they are equivalent, it's preferable to use an object literal in
    most situations as it is simpler to declare and to read, especially if there are
    many properties. It also has the added benefit of allowing you to create and pass
    an object as an expression without having to prepare it beforehand.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: Property names
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The keys that are used to add properties to objects (the property names) are
    internally stored as strings. However, when using the object literal syntax, you
    can declare the keys as regular identifiers (that is, anything you could use as
    a variable name), number literals, or string literals:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'It''s preferable to use identifiers where possible as this helpfully restricts
    you to using key names that can easily be accessed as properties. If you use a
    string literal that is not also a valid identifier, then you''ll have to use square-bracket
    notation to access it, which can be burdensome:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'You can also use computed property names (delimited by square brackets) to
    add dynamically named items to an object literal:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'As we mentioned previously, all non-primitives in JavaScript are technically
    objects. What else makes something an object, though? Objects allow us to assign
    arbitrary values to them as properties, which is something primitives are not
    capable of. Beyond this characteristic, the definition of an object in JavaScript
    is left invitingly generic. We can wield objects in many different ways to suit
    the code we''re writing. Many languages will provide language constructs for dictionaries
    or hashmaps. In JavaScript, we can use objects to fulfill most of these needs.
    When we need to use store a key-value pair where the key is something other than
    a string, it''s common to provide a string representation of that value via the
    object''s `toString` method:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'This will be called internally when the object is put in a context where it
    is coerced to a string, such as when accessing or assigning via square-bracket
    notation:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This has historically been used to allow the implementation of data structures
    where the key is effectively non-primitive (even though objects technically store
    property names as strings). Nowadays, however, using `Map` or `WeakMap` is preferred.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: Property descriptors
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When adding properties to objects in the conventional fashion, either via property
    access or via an object literal, the properties will be given the following implicit
    traits:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '`configurable`: This means the property can be deleted from the object (and
    if its property descriptor can be changed)'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`enumerable`: This means the property will be visible to enumerations such
    as `for...in` and `Object.keys()`'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`writable`: This means the property''s value can be changed via an assignment
    operator (such as `obj.prop = ...`)'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JavaScript gives you the power to turn off these traits individually, but be
    wary that changes to these traits can obscure the behavior of your code. For example,
    if a property is described as not being writeable but a write is attempted via
    assignment (for example, `obj.prop = 123`), then the programmer will receive no
    warning that the write has not occurred. This can create unexpected and hard-to-find
    bugs. As ever, it's vital to keep in mind the expectations of the programmers
    who will be consuming your interfaces. So you keep the property descriptors with
    care and consideration.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: 'You can define your own traits for a given property via the natively provided `Object.defineProperty()`.
    When setting up a new property descriptor, the default of each trait will be `false`,
    so if you wish to give the property a trait of either `configurable`, `enumerable`,
    or `writable`, then you will need to specify these as `true` explicitly:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'You can also use `Object.defineProperties()` to describe many properties at
    once:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'If you attempt to change the traits of a property that has `configurable` set
    to `false`, then you will receive a `TypeError`:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'It is also possible to set custom setters and getters*. *A getter defines what
    value will be returned when a property is accessed, while a setter will define
    what occurs when an assignment is attempted on that property (that is, via the
    assignment operator). Using these can be useful in situations where you wish to
    have an internal implementation that holds the value in a unique way or somehow
    filters or processes the value upon assignment, for example:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'As the `name` property here has been described via `defineProperties`, it will
    have all of the default traits disabled, which means it is not enumerable, writeable,
    or configurable. If we try to enumerate it, we''ll discover that our internally
    used `normalizedName` is found:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This is something to keep in mind when working with property descriptors. Make
    sure you're aware of what traits every property has and watch out for leakage
    of your internal implementation!
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s worth noting that it is also possible (and often preferable) to define
    getters and setters for properties directly within an object literal or class
    definition. For example, we could create a subclass of `Array` with the addition
    of a `last` property, which acts as a getter for the last element in the array:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: There are many such creative uses of getters and setters. But, as with the traits
    of `configurable`, `enumerable`, and `writable`, it's important to be cautious
    of how your custom behaviors will affect the expectations of your fellow programmers.
    If the abstraction or data structures you create are not familiar or predictable
    in their behavior, then you're paving the way for misunderstandings and bugs.
    The best approach is to align with the natural semantics of the language itself.
    So, whenever you are about to create a custom setter or describe a property as
    unwritable, ask yourself whether it would be reasonable for a programmer to expect
    it to work that way. Follow a helpful rule dubbed as the **Principle of Least
    Astonishment** (**POLA**)!
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: The POLA (or least surprise) applies to software design and UX design. It broadly
    means that a given function or component of a system should act as most users
    would expect it to and should seek not to surprise or astonish too much.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: Map and WeakMap
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The  `Map` and `WeakMap` abstractions are capable of storing key-value pairs
    where, unlike regular objects, the key can be anything, including non-primitive
    values:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '`WeakMap` is similar to `Map`, but it only holds a weak reference to the object
    that''s used as a key, meaning that, if the object becomes unavailable due to
    being garbage-collected elsewhere in your program, then `WeakMap` will cease to
    keep a hold of it.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: Most of the time, a plain object is all you will need. You should only reach
    for `Map` or `WeakMap` if you need your keys to be non-primitive or if you want
    to weakly hold your values.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: The prototype
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'JavaScript is a prototypical language where inheritance is achieved via prototypes.
    This can be a daunting concept, but it is, in fact, beautifully simple. JavaScript''s
    prototypal behavior can be described like this: every time a property is accessed
    on an object, if it is not available on the object itself, JavaScript will attempt
    to access it on an internally available property called  `[[Prototype]]`. It will
    then repeat this process until it either finds the property or gets to the top
    of the prototype *chain* and returns `undefined`.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: Understanding what this `[[Prototype]]` property is capable of will give you
    great power over the language and will immediately make JavaScript less daunting. 
    It can be difficult to grasp but is worth it in the end.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: 'A `[[Prototype]]` object, which could feasibly be attached to any other object,
    is just a regular object itself. We could create one called `engineerPrototype` and
    have it contain data and methods related to the role of an engineer, for example:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Then, we could attach this prototype to another object, thus making its properties
    available there as well. To do this, we use `Object.create()`, which creates a
    new object with a hardcoded `[[Prototype]]`:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The internal `[[Prototype]]` property cannot be directly set, so we must use
    mechanisms such as `Object.create` and `Object.setPrototypeOf`. Note that you
    may have seen code that uses the non-standard `__proto__` property to set `[[Prototype]]`,
    but this is a legacy feature and should not be relied on.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: 'With this newly created `pandaTheEngineer` object, we are able to access any
    properties available on its `[[Prototype]]`, such as `engineerPrototype`:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'We can illustrate that the objects are now linked by adding a new property
    to `engineerPrototype` and observe how it is made available on `pandaTheEngineer`:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'As we mentioned previously, the `[[Prototype]]` of an object will only be used
    to resolve a property if it is not already available on the object itself. The
    following code shows how we can set our own `sayHello` method on our `pandaTheEngineer` object,
    and that by doing so we no longer have access to the `sayHello` method defined
    on `[[Prototype]]`:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'However, deleting this newly added `sayHello` method would mean we once again
    have access to the `[[Prototype]]` `sayHello` method:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'To understand what''s happening and which properties are coming from which
    object, we are always able to inspect the `[[Prototype]]` of an object using `Object.getPrototypeOf`:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Now, we can inspect its properties via `Object.getOwnPropertyNames`:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Here, we can see that the `[[Prototype]]` object (that is, `engineerPrototype`)
    is providing the `type`, `sayHello,` and `sayGoodbye` properties. If we inspect
    the `pandaTheEngineer` object itself, we can see that it only has a `name` property:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'As we observed with our earlier addition of the `sayGoodbye` method, we can
    modify that prototype at any time and have our changes accessible to any objects
    that use that prototype. Here''s another example of doing this:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Here, you can see how our inherited `sayHello` method is producing a string
    that includes our mutated type property (that is, `"Awesome Engineer"`).
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: Hopefully, you are beginning to see how we could construct a hierarchy of inheritance
    using prototypes. The very simple mechanism of `[[Prototype]]` allows us to express
    complex hierarchical relations between problem domains expressed as objects. This
    is how OOP is achieved in JavaScript.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: We could feasibly create another prototype that itself uses `engineerPrototype`,
    possibly `fullStackEngineerPrototype`, and it would work as expected, with each
    prototype defining another layer of property resolution.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: 'Below the surface, JavaScript''s newer *Class Definition Syntax*, which you
    may have grown accustomed to, relies on this underlying mechanism of prototypes
    as well. This can be observed here:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: You'll notice that there are some subtle differences here. The most crucial
    one is that, when declaring classes, there is currently no way to define non-method
    properties on the prototype object. When we declare the `type` property, we are
    populating the instance itself so that when we inspect the properties of the instance,
    we get `"type"` and `"name"`. However, the methods (such as `sayHello`) will exist
    on the `[[Prototype]]`. Another difference is that, of course, when using classes,
    we are able to declare a `constructor`, which itself is a method/property on the
    `[[Prototype]]`.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: Fundamentally, the *Class Definition Syntax* (introduced in *ECMAScript 2015*),
    does not make anything possible that was not already possible in the language.
    It's just utilizing the existing prototypical mechanism. However, the newer syntax
    does make some things simpler, such as referring to a superclass with the `super`
    keyword.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: 'Before class definitions existed, we typically wrote class-like abstractions
    by assigning our intended `[[Prototype]]` object to the `prototype` property of
    a function, as shown here:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'When a function is instantiated via the `new` operator, JavaScript will implicitly
    create a new object with its `[[Prototype]]` set to the function''s `prototype`
    property, if it has one. Let''s try instantiating the `Engineer` function:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Inspecting this yields the same characteristics that we saw in our original
    `Object.create` approach:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Broadly, all of these approaches are the same but have some subtle differences
    around where certain properties reside (that is, whether its properties are on
    the instance itself or on its `[[Prototype]]`). The newer *Class Definition Syntax*
    is useful and succinct and so is preferable nowadays, but it is nonetheless useful
    to have an underlying knowledge about how prototypes work as it drives the entirety
    of the language, including all of its native types. We can inspect these native
    types in the same manner as in the preceding code:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Mutating native prototypes is an anti-pattern and should be avoided at all
    costs as it can create unexpected conflicts with other code in your code base.
    Since a runtime will only have a single set of native types available, when you
    modify them, you are modifying the capabilities of every single instance of that
    type that currently exists. Therefore, it is best to abide by a simple rule: **only
    modify your own prototypes**.'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: 'If you ever catch yourself trying to modify a native prototype, it may be better
    if you created your own subclass of that type and added your functionality there:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Here, we're creating our own `Array` subclass called `HeartArray` so that we
    can add our own specialized `join` method.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: When and how to use objects
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An object of any type, much like our primitive values, should only be used inline
    with the semantic concept it represents. The preceding case of subclassing `Array`
    to `HeartArray` makes sense as the data we wish to express via it is indeed array-like,
    that is, it is a sequential set of words.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: When we go about molding objects into abstractions that suit our needs, we should
    always consider the expectations that other programmers will have about objects
    and the ramifications of those expectations. We'll go into the subtleties of designing
    good abstractions in [Chapter 11](9ef81929-c89f-4988-aa66-436c59f7f43f.xhtml),
    *Design Patterns,* where we will be utilizing objects to craft abstractions in
    a multitude of ways.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: This section has introduced you to the concept of objects in JavaScript—how
    they are everywhere—and how they operate beneath the surface via prototypes. This
    fundamental knowledge will make working with JavaScript much easier and will help
    you write cleaner code.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: Functions
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functions in JavaScript are like any other type; they can be passed around just
    like objects and primitive types. When we talk about most other values, however,
    we see that there is usually only one way to literally declare them. Object literals
    are declared using braces. Array literals are delimited square brackets. Functions,
    however, come in a variety of literal forms.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: 'When outside of an object literal or class definition, you can declare a function
    in three different ways: as a function declaration, as a function expression,
    or as a fat-arrow function expression:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'When declaring functions inside object literals, however, there is a more succinct
    syntax, called a **method definition**:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'We need to separate these method definitions with a comma (just as we''d have
    to do with any other properties defined in an object literal). Class definitions
    also allow us to use method definitions, although they don''t require separating
    commas:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Methods are just functions that are *bound* to an object when invoked. This
    includes functions defined within class definitions and functions that are in
    any way assigned to a property of an object. When discussing code with other programmers,
    it's useful to know what people mean when they say *method* versus *function*.
    Fundamentally, however, the language of JavaScript does not distinguish between
    these—they are all technically just functions.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: 'All the various ways of defining functions have subtle differences that are
    worth knowing about because the typical JavaScript code base will use most, if
    not all, of these styles. The types of differences you''ll encounter in how functions
    are declared include the following:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: Whether the definition style is *hoisted* to the top of its scope; for example,
    with function declarations
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whether the definition style creates a function that has its own bindings (for
    example, `this`); for example, with function expressions
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whether the definition style creates a function with its own `name` property;
    for example, with function declarations
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whether the definition style is contextual to specific areas of code; for example,
    with method definitions
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, we can go into more detail about the syntax of the various definition styles.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: Syntactic context
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are three syntactic contexts in which a function can exist:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: As a statement
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As an expression
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a method definition
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Statements** can be thought of as the scaffolding. For example, `const X
    = 123` is a *Statement* that contains a `const` declaration and assignment. **Expressions** can
    be thought of as the values that you place into the scaffolding; for example, `123` in
    the latter *statement* is an *expression*. In [Chapter 9](1b37008e-8843-431a-9545-56d4246e3447.xhtml),
    *Parts of Syntax and Scope**,* we''ll talk about this topic in more detail.'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: 'The difference between functions as statements and functions as expressions
    is exemplified by the function expression and the function declaration. The function
    declaration is quite unique in that it is the only way to declare a function that
    is technically a statement. To be considered a function declaration, the syntax
    of `function name() {}` must reside on its own without being used in the context
    of an expression. This can be incredibly confusing because you cannot always tell
    whether a function is a function declaration or function expression based purely
    on its own syntax; instead, you must look at the context in which it exists:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: As we mentioned previously, a function expression is allowed to have a name,
    just like a function declaration, but that name may not match the name of the
    variable that the function is assigned to.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s easiest to think of expressions as anything that can legally exist to
    the right-hand side of the assignment operator. All of the following *right-hand
    sides* are legal expressions:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Function expressions are as flexible as all the other values in JavaScript in
    terms of where they can be placed syntactically. Function declarations, as we
    will discover, are limited. Method definitionsare also limited to exist within
    the confines of either an object literal or a class definition.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: Function bindings and this
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A function''s bindings refer to a set of additional and implicit values that
    JavaScript makes available for referencing within the body of the function. These
    bindings include the following:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: '`this`: The `this` keyword refers to the execution context of a function''s
    invocation'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`super`: The `super` keyword in a method or constructor refers to its super-class'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`new.target`: This binding informs you as to whether the function was invoked
    as a constructor (via the `new` operator)'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`arguments`: This binding provides access to the arguments that are passed
    to a function when it is invoked'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These bindings are available to all functions except those defined with the
    arrow syntax (`fn = () => {}`). Functions defined in this way will effectively absorb
    the bindings from the parent scope (if one is available). Each of these bindings
    has unique behaviors and constraints. We will explore these in the following subsections.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: Execution context
  id: totrans-324
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `this` keyword is usually determined at the calltime of the function and
    will normally resolve to the object that the function is being invoked on. It
    is sometimes referred to as the execution context of a function or its `thisArg`. This
    can be unintuitive since it means that the `this` value can technically change
    between calls. For example, we could assign a method from one object to another,
    call it on the second, and observe that its `this` is always the object it''s
    been called on:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: When called without an object of invocation, as is the case when we directly
    call `sayMyName`, its presumed execution context is the global environment in
    which the code resides. On the browser, this global environment is equal to the
    window object (which provides access to the browser-and-document object models),
    while in Node.js, this refers to an environment that's unique to each specific
    module/file, which includes, among other things, that module's exports.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the case of calling a function globally, there are two cases
    where the `this` keyword will be something other than the apparent object of invocation:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: If the function being called was defined as an arrow-function, then it will
    absorb the `this` value from the scope in which it is situated
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the function being called is a constructor, its `this` value that will be
    a new object that has its `[[Prototype]]` preset to the prototype property of
    the function
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are also ways to force the value of `this` when calling or declaring
    a function. You can use `bind(X)` to create a new function that will have its
    `this` value set to `X`:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'You can also use a function''s `call` and `apply` methods to force the `this`
    value for any given invocation, but note that this will not work if the function
    is being called as a constructor (that is, with a new keyword) or if it has been
    defined with the arrow-function syntax:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: In your everyday function calls, it's best to avoid awkward techniques of invocation
    like this. Such techniques can make it difficult for the readers of your code
    to discern what's happening. There are many valid applications of invoking via
    `call`, `apply`, or `bind`, but these are usually limited to lower-level libraries
    or utility code. Higher-level logic should avoid them. If you find yourself having
    to rely on these methods in higher-level abstractions, then you're likely making
    something more complicated than it needs to be.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: super
  id: totrans-336
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The super keyword comes in three distinct flavors:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: '`super()` as a direct function invocation will call the superclass''s constructor
    (that is, its object''s  `[[Prototype]]` constructor) and is only valid to call
    within a constructor. It also must be called before trying to access `this` as
    it is `super()` itself that''ll initiate the execution context.'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`super.property` will access a property on the superclass (that is, the `[[Prototype]]`),
    and is only valid to reference within a constructor or method defined using the
    method definition syntax.'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`super.method()` will invoke a method on the superclass (that is, the `[[Prototype]]`),
    and is only valid to call within a constructor or method defined using the method
    definition syntax.'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `super` keyword was introduced to the language at the same time as the
    class definition and method definition syntax, so it is tied up in those constructs.
    You are free to use `super` in class constructors, methods, and also in method
    definitions within object literals:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'The `super` keyword, as its name suggests, is semantically suited to referencing
    a superclass, so 99% of its valid use cases will be within class definitions,
    where you''re seeking to reference the class being extended, like so:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Using `super` in this manner is entirely intuitive, especially to programmers
    who are used to other OOP languages. For individuals adept with JavaScript's prototype
    mechanism, however, the implementation of `super` can seem confusing. Unlike the `this`
    value, `super` is bound at definition time, instead of call time. We've seen how
    we can manipulate the value of this by calling a method in a specific manner (for
    example, using `fn.call()`). You cannot similarly manipulate `super`. Hopefully,
    this will not affect you in any way, but it is useful to remember nonetheless.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: new.target
  id: totrans-346
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `new.target` binding will be equal to the current function being called
    if the function has been called via a `new` operator. We typically use the `new`
    operator to instantiate classes, and in this case, we will correctly expect `new.target`
    to be that class:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'This is useful when we may wish to carry out a certain behavior if a constructor
    is called directly versus when called via `new`. A common defensive strategy is
    to make your constructor behave in the same way, regardless of whether it''s called
    with or without `new`. This can be achieved by checking for `new.target`:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Alternatively, you may wish to throw an error to check that a constructor has
    been invoked incorrectly:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Both of these examples would be considered intuitive use cases of `new.target`.
    There is, of course, the possibility to use it to deliver entirely different functionality
    depending on the calling pattern, but in the interest of catering to the reasonable
    expectations of programmers, it's best to avoid such behavior. Remember the POLA.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: arguments
  id: totrans-354
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `arguments` binding is made available as an array-like object and will contain
    the arguments that a given function was called with.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: When we say that `arguments` is array-like, we are referring to the fact that
    it has a `length` property and properties indexed from zero (just like a regular
    `Array`), but it still just a regular `Object` and therefore does not have any
    of array's built-in methods available, such as `forEach`, `reduce`, and `map`.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we can observe that the arguments are provided within the scope of a
    given function:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'The `arguments` binding was popularly used to gain access to an arbitrary (that
    is, non-fixed) amount of arguments, though its usefulness quickly disappeared
    after the language introduced the *rest parameter* syntax (`...arg`). This newer
    syntax can be used when defining a function to instruct JavaScript to place remaining
    arguments into a singular array. This meant that you could achieve all of the
    utility of the older `arguments` binding, plus you''d have a value that was not
    merely array-like but actually a genuine array. Here''s an example:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Even though the `arguments` object has fallen out of favor, it is still within
    the language spec and works in older environments, so you may still see it in
    the wild. Most of the time, its usage can be avoided.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: Function names
  id: totrans-362
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Confusingly, functions have names, and these names are not the same as the
    variables or properties that we assign to functions. The name of a function is
    within its syntax, prior to its parentheses:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'You can access a function''s name via its `name` property:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'When you define a function via the function declaration syntax, it''ll assign
    that function to a local variable of the same name, meaning that we can reference
    the function as we would expect:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Method definitionswill also assign the method to a property name that is equal
    to the function name:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'You may be thinking this all seems incredibly intuitive. And it is. It makes
    perfect sense that the names we give our functions and methods are themselves
    used to dictate what variable or property those things will be assigned to. Oddly,
    though, it is also possible to have named function expressions, and these names
    do not cause such an assignment. The following is an example of this:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'The `const` name here, `myFunction`, dictates what we will use in subsequent
    lines to reference the function. However, the function technically has a name
    of `"hullaballoo"`:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'If we try to reference the function via its formal name, we will get an error:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'This can seem odd. Why is it possible to give a function a name if that name
    itself is not used to refer to the function? This is a mixture of legacy and convenience.
    One hidden feature of the named function expression is that the name is actually
    available to you to reference the function, but only inside the scope of the function
    itself:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'This can be useful in situations where you want to supply an *anonymous* callback
    to some other function but still be able to reference your own callback for any
    repeated or recursive calls, like so:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: So, even though the named function expression is an odd thing, it does have
    its merits. In usage, however, it's best to take into consideration the clarity
    of your code for people who might not know of these idiosyncratic behaviors. This
    does not mean avoiding it altogether, but just being ever more mindful of the
    readability of your code when using it.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: Function declarations
  id: totrans-382
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Function declarations are a type of *hoisted declaration*. A hoisted declaration
    is one that will, at runtime, be effectively hoisted up the top of its execution
    context, meaning that it will be immediately accessible to preceding lines of
    code (seemingly *before* it''s declared):'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'This, of course, is not possible with a function expression that''s been assigned
    to a variable:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: The hoisted behavior of function declarations can create unexpected results,
    so it is typically considered an anti-pattern to rely on the hoist. In general,
    it's fine to use function declarations, as long as they're used in a way that
    respects the assumptions that programmers will intuitively make. Hoisting, as
    a practice, is not very intuitive to most people, and so it's usually best to
    avoid it.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: For more information on scopes and how hoisting occurs in the case of function
    declarations, please take a look at [Chapter 9](1b37008e-8843-431a-9545-56d4246e3447.xhtml), *Parts
    of Syntax and Scope*, and go to the *Scopes and Declarations* section.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: Function expressions
  id: totrans-389
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Function expressions are the easiest and most predictable to use as they are
    syntactically similar to all the other values within JavaScript. You can use them
    to *literally* define functions anywhere you would define any other value as they
    are a type of expression. Observe here, for example, how we''re defining an array
    of functions:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'A common application of the function expression is in passing callbacks to
    other functions so that they can be called at some later point. Many native `Array`
    methods, such as `forEach`, accept functions in this manner:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: Here, we are passing a function expression to the `forEach` method. We haven't
    named this function by assigning it to a variable, so it is considered an anonymous
    function. Anonymous functions are useful as they mean that we don't need to preassign
    a function to a variable in order to make use of it; we can simply write our function
    into our code at the exact location of usage.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: 'The function expression is most similar in its expressive manner to the arrow
    function.The key difference, as we will discover, is that the arrow function does
    not have access to its own bindings (for example, to `this` or `arguments`). A
    function expression, however, does have access to these values, and so in some
    contexts will be more useful to you. It''s very common to need a binding to `this`
    in order to operate successfully with the DOM API, for example, where many native
    DOM methods will invoke callbacks and event handlers with the relevant element
    as execution context. Additionally, you''ll want to use function expressions when
    defining methods on objects or prototypes that will need to access the current
    instance. As illustrated here, using an arrow function would not be appropriate:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: As you can see, using the arrow function syntax prevents us from accessing the
    instance via `this`, while the function expression syntax allows us to do this.
    Therefore, the function expression, although somewhat superseded by the more succinct
    arrow function, is still a very useful tool.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: Arrow functions
  id: totrans-398
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The arrow function is, in many ways, just a slightly more succinct version
    of the function expression, although it does have some practical differences.
    It comes in two flavors:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: As you can see, the *concise* variant includes an implicit return, while the
    *regular* variant, much like other function definition styles, requires you to
    define a regular function body delimited by curly braces in which you must explicitly
    return a value with a `return` statement.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, arrow functions allow you to avoid using parentheses when declaring
    a function with only one argument. In these cases, you can just place the identifier
    of the argument by itself prior to the arrow, like so:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'The succinctness of the arrow function can be very useful in situations where
    you need to pass functions around quite a lot. This is common, for example, when
    operating on arrays via native methods such as `map`:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Despite its superhero status as the succinct variant of otherwise verbose function
    definitions, the arrow function comes with its own challenges. The fact that the
    language must accommodate both *concise* and *regular* variants of syntax means
    that there is some ambiguity when attempting to return an object literal from
    the concise arrow function:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'This syntax will confuse the JavaScript parser as the opening curly brace implies
    that a regular function body resides within. Due to this, the parser gives us
    an error about an unexpected token as it is not expecting the body of an object
    literal. If we want to return an object literal from the concise form of the arrow
    function, then we must awkwardly wrap it in parentheses to disambiguate the syntax:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Functionally, the arrow function differs from the function expression in two
    ways:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: It does not provide access to bindings such as `this` or `arguments`
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It does not have a `prototype` property, so it cannot be used as a constructor
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These differences mean that, on the whole, arrow functions are typically unsuitable
    to use as methods or constructors. They are best used in contexts where you wish
    to pass a callback or handler to another function, and especially in cases where
    you wish to retain your `this` binding. For example, if we were to bind event
    handlers within the context of a `UIComponent` abstraction, we may wish to retain
    the `this` value in order to carry out certain instance-specific functionality:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'The arrow function feels most at home in scenarios like this. Its succinctness,
    however, means that there can be a risk of confusion when reading overly dense
    lines of code, such as the following:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'For this reason, it is best to employ the arrow function with the same consideration
    and practicality with which you would employ any other construct: ensure that
    you always put the usability and readability of your code first, above the very
    enticing niftiness of *cool* or succinct syntax.'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: Immediately Invoked Function Expressions
  id: totrans-418
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Function expressions and arrow functions are the only function definition styles
    that are, technically, expressions. As we have seen, this quality makes them useful
    when we need to pass them as values to other functions without having to go through
    the process of assignment.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: 'As we mentioned previously, a function without an assignment, and thus without
    a reference to its value, is typically called an *anonymous function *and will
    look like this:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'The idea of an *anonymous function* is extended further by the concept of an
    **Immediately Invoked Function Expression** (**IIFE**). An IIFE is just a regular
    *anonymous function* that is invoked immediately, like so:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: Note the invocation parentheses (that is, `...()`) after the closing curly brace.
    This will call the function and thus makes the preceding syntactic construct an
    IIEE.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: An IIFE is not a distinct concept within the language itself. It is just a useful
    term that the community has come up with to describe the common pattern of *immediately*
    invoking a function. It's a useful pattern because it allows us to create an ad
    hoc scope, meaning that any variables defined within it are constrained to that
    scope and will not leak outside, just as we'd expect from any function. This immediate
    scope is useful to quickly do self-contained work without affecting the parent
    scope.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: IIFEs were popularized in the browser era when it was preferable to avoid polluting
    the global namespace. Nowadays, with pre-compilation being so popular, the IIFE
    is less useful.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: 'The exact syntax of an IIFE can vary. For example, if we use an arrow function,
    then the calling parenthesis must be placed after the wrapped function expression:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: The mechanism remains essentially the same, regardless of whether we use a function
    expression or an arrow function.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: 'If the concept of an IIFE is confusing, it''s simpler to understand what''s
    going on if we replace the actual function with an identifier, `fn`, and imagine
    that we have previously assigned a function to this identifier. Here, we can call
    `fn` like so:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'Now, we could choose to wrap the `fn` reference in parentheses. This would
    make no difference to the invocation, although it may look bizarre:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'It''s useful to remember that parentheses are just syntactic vessels that are
    sometimes needed to avoid syntactic ambiguity. So, all of these are technically
    equivalent:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'If we replace the `fn` reference here with an inline anonymous function, nothing
    groundbreaking occurs. Instead of referencing an existing function, we are just
    expressing an inline function, on the spot, and then invoking it:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: We call the pattern of an inline function expression an IIFE, but it really
    isn't anything special. Consider that the invocation parentheses, that is, `...()`,
    don't really care what they're attached to, as long as it's a function. The expression
    prior to the invocation could be literally *anything* as long as it evaluates
    to a function.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: 'IIFEs are useful because they provide scope isolation without the burden of
    having to define a function with a name and then later reference and invoke it,
    as we''re doing here:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: Within the browser, prior to complex builds involving compilation and bundling,
    IIFEs were useful because they provided scope isolation while not leaking any
    names into the global scope. Nowadays, however, the IIFE is rarely necessary.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: Interestingly, the `initializeApp` function in the preceding code is, arguably,
    more readable and understandable with an explicit name. This is why, even if necessary,
    IIFEs are sometimes considered needlessly confusing and fancy. A named function
    usefully provides a clue as to its purpose and the intent of the author. Without
    a name, the reader of our code is left with the cognitive burden of having to
    read through the function itself to discover its broad purpose. For this reason,
    it is usually preferable to avoid IIFEs and similar anonymous constructs unless
    you have a very specific need.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: Method definitions
  id: totrans-443
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Method definitions were added to the language at the same time as class definitions
    to allow you to easily declare methods bound to a specific object. They are not
    limited to class definitions, though. You can use them freely in object literals
    as well:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'In classes, you can also declare methods in this manner:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'You can also use traditional styles of function definition to declare your
    methods, such as a function expression assigned to an identifier:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'There is, however, a crucial difference between method definitions and other
    styles of function definition. A method definition will always be bound to the
    object in which it was first defined. This is known internally as its `[[HomeObject]]`.
    This home object will determine what `super` binding is available to the method
    when it is called. Only method definitions are allowed to make reference to `super`,
    and the `super` they reference will always be the `[[Prototype]]` of their `[[HomeObject]]`.
    This means that if you try to *borrow* methods from other objects, you may be
    surprised to discover that `super` is not what you intended:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'Here, we can observe that both `JessieTheCat` and `JessieTheDog` have `greet`
    methods:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'We can also observe that their greet methods are implemented in identical ways.
    They both return the interpolated string ``${super.greet()} I am Jessie!``. Due
    to this, it might seem logical to be able to let `JessieTheCat` borrow the method
    from `JessieTheDog`. After all,  they''re exactly the same:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'We might intuitively expect `super` in the greet method to refer to the superclass
    of the current instance, which in the case of `JessieTheCat` will be `Cat`. But
    curiously, when we call this borrowed method, we experience something different:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: It barks! The borrowed method has annoyingly retained its binding to its original
    `[[HomeObject]]`.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: In summary, method definitions are simpler and more succinct variants of their
    more verbose cousins, the function declaration and function expression. However,
    they come with an implicit mechanic that sets them apart and can create confusion.
    99% of the time, method definitions won't bite you; they'll behave as expected.
    The other 1% of the time, it's useful at the very least to know why your code
    is misbehaving so that you can explore other options. As always, knowledge about
    the idiosyncrasies of JavaScript can only help us in our pursuit of a cleaner
    and more reliable code base.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: Async functions
  id: totrans-460
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Asynchronous** (**async**) functions are specified with an `async` keyword
    preceding the function keyword. All function definition styles can be prefixed
    with it:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'An async function allows you to easily conduct asynchronous operations by providing
    you with two key features:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
- en: You can use `await` within your async function to await the completion of Promises
  id: totrans-464
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your function will always return a Promise, which can, itself, be awaited
  id: totrans-465
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Promise is a natively supplied abstraction for dealing with asynchronous
    operations. It can seem complicated, but it's best to think of a Promise as an
    object that will either resolve or reject at a time later than *now *(that is,
    asynchronously).
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: 'Traditionally, in JavaScript, we''d have to pass around callbacks to ensure
    that we''re able to respond to such asynchronous activity:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'However, with an async function and `await`, we can achieve this more succinctly:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: The `await` clause here will halt current execution until `getUserDetails` completes
    and resolves to a value. Note that we can only use await within functions that
    are themselves async.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous execution is a complex topic, so there is a whole chapter dedicated
    to it, that is, [Chapter 10](b41df1c6-fc76-4d51-b95c-ae39ab040ab1.xhtml), *Control
    Flow*. For now, it's useful to know that async functions are a distinct type of
    a function that will always return a Promise.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: Other than allowing `await` clauses and returning Promises, async functions
    carry the same features and characteristics as the respective function definition
    style that's used. An async arrow function, just like a regular arrow function,
    does not have its own bindings to this or arguments. An async function declaration
    is hoisted just like its non-async cousin. Essentially, async should be thought
    of as a layer atop all of the learnings you've already picked up concerning the
    different function definition styles.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
- en: Generator functions
  id: totrans-474
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The very last type of function definition style we will cover is the very powerful
    *generator function.* Broadly, generators are used to supply and control the iteration
    behavior for a sequence of one or more, or even infinite, items.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
- en: '*Generator functions* in JavaScript are specified with an asterisk following
    the function keyword:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: When called, they will return a generator object, which uniquely conforms to
    both the iterable protocol and the iterator protocol*,* meaning that they can
    be iterated over themselves or can serve as an object's iteration logic.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: Feel free to skip ahead to the section on the iterable protocol*. *The generator
    function makes far more sense when you think of it as a convenient way to create
    an iterator or iterable.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: 'A generator function will halt and return a value at the point of a `yield`
    statement, and this can occur multiple times. After a `yield`, the function is
    effectively stalled while it waits for a consumer to need its next value. This
    is best illustrated with an example:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: As you can see, the generator object that's returned from the function has a
    `next` method, which, when called, will return an object with a `value` (indicating
    the current value of the iteration) and a `done` property (indicating whether
    the iteration/generation is complete). This is the *iterator protocol* and is
    the contract you can expect all generators to fulfill.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
- en: 'A generator fulfills not only the iterator protocol but also the iterable protocol,
    which means it can be iterated over by language constructs that accept iterables
    (such as `for...of` or the `...spread` operator):'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '*Async generator functions* can also be specified. They usefully combine the
    async and generator formats into a hybrid that allows for custom asynchronous
    generation logic, like so:'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: You'll notice how we're using the `for await` iteration construct to iterate
    through our asynchronous generator. This will ensure that each iteration will
    await its result before continuing.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
- en: 'Generator functions are very powerful, but it''s important to be aware of the
    underlying mechanics at play. They are not regular functions and are not guaranteed
    to run to completion. Their implementation should take into account the context
    in which they will be run. If your generator is intended to be used as an iterator,
    then it should respect the implied expectations of iteration: that it is a read-only
    operation of an underlying piece of data or generation logic. While it is possible
    to mutate underlying data within a generator, this should be avoided.'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
- en: Arrays and iterables
  id: totrans-489
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An array in JavaScript is a type of object that is specialized in that it contains
    a set of ordered elements.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
- en: 'You can express an array using its literal syntax, which is a comma-separated
    list of expressions delimited by square brackets:'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'These comma-separated expressions can be as complex or simple as we desire:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: An array is capable of containing all manner of values. There are very few constraints
    on how we can use arrays. Technically, an array's limited to a `length` of around
    4 billion, due to its `length` being stored as a 32-bit integer. For most purposes,
    of course, this should be absolutely fine.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
- en: 'Arrays have a numeric property for every indexed element within them and a
    `length` property to describe how many elements there are. They also have a set
    of useful methods for reading from and operating on the data within them:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'Historically, arrays were iterated over using conventional `for(...)` and `while(...)`
    loops that increment a counter toward the `length` so that, upon each iteration,
    the current element could be accessed via `array[counter]`, like so:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'Nowadays, however, it''s preferable to use other methods of iteration, such
    as `forEach` or `for...of`:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '`for...of` has the benefit of being breakable, meaning you can use `break`
    and `continue` statements within them and easily escape from the iteration.  It
    will also work on any object that is iterable, whereas `forEach` is only an `Array`
    method. The `forEach` style, however, is useful in that it provides you with the
    current index of the iteration via the second argument to your callback.'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
- en: Which style of iteration you use should be determined by the value you are iterating
    over and what you wish to do on each iteration. Nowadays, it is quite rare to
    need to use traditional styles of array iteration such as `for(...)` and `while(...)`.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
- en: Array-like objects
  id: totrans-504
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Most native Array methods are generic, meaning that they can be used on any
    object that *looks like* an array. All we need to achieve  the appearance of an
    array is use a `length` property and individual properties for each index (indexed
    from zero):'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: Here, we've constructed an array-like object and then provided it with a `join`
    method of its own by borrowing the `join` method of an array (that is, from `Array.prototype`).
    The native array `join` method is so generically implemented that it doesn't mind
    operating on an object as long as that object fulfills the contract of an array
    by providing a `length` property and corresponding indexes (`0`, `1`, `2`, and
    so on). Most native array methods are similarly generic.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
- en: 'One example of an array-like object within the language itself is the `arguments`
    binding that we explored earlier in this chapter. Another example is `NodeList`,
    which is a type of object that is returned from various DOM selection methods.
    If necessary, we can derive proper arrays from these objects by borrowing and
    calling the array `slice` method, like so:'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'However, in the case of `arguments` or the `NodeList` object, we can also rely
    on them being iterable, meaning that we can use the spread syntax to derive a
    true array:'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: If you find yourself needing to create an array-like object, consider having
    it implement the iterable protocol (which we're about to explore) so that the
    spread syntax can be used in this way.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
- en: Set and WeakSet
  id: totrans-513
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Set` and `WeakSet` are native abstractions that allow us to store sequences
    of unique objects. This is in contrast to arrays, which give you no assurances
    as to the uniqueness of your values. Here''s an illustration:'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: As you can see, values given to a `Set` will always be ignored if they already
    exist in the `Set`.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
- en: 'Sets can be initialized by passing an iterable value to the constructor; for
    example, a string:'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'If you need to convert a `Set` into an array, you can most simply do this with
    the spread syntax (as sets are, themselves, iterable):'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: WeakSets are similar to the previously covered WeakMaps. They are for *weakly* holding
    values in a way that allows that value to be garbage-collected in another part
    of the program. The semantics and best practices around using sets are similar
    to those concerning arrays. It's advisable to only use sets if you need to store
    unique sequences of values; otherwise, just use a simple array.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
- en: Iterable protocol
  id: totrans-522
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The iterable protocol allows values containing sequences to share a common set
    of characteristics, allowing them to all be iterated over or treated in a similar
    way.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
- en: We can say that an object that implements the iterable protocol is iterable.
    Iterable objects within JavaScript include `Array`, `Map`, `Set`, and `String`.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
- en: Any object can define its own iterable protocol by simply supplying an iterator
    function under the property name's `Symbol.iterator` (which maps to the internal
    `@@iterator` property).
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
- en: 'This iterator function must fulfill the iterator protocol by returning an object
    with a `next` function. This `next` function, when called, must return an object
    with `done` and `value` keys indicating what the current value of the iteration
    is and whether the iteration is completed:'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  id: totrans-527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'So, to be utterly clear about this, there are two distinct protocols:'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
- en: '**The iterable protocol**: Any object that implements an `@@iterator` via `[Symbol.iterator]`
    fulfills this protocol. Native examples include `Array`, `String`, `Set`, and
    `Map`.'
  id: totrans-529
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The iterator protocol**: Any function that returns an object of the form
    `{... next: Function}` and whose `next` method, when called, returns an object
    in the following form: `{value: Boolean, done: ...}`.'
  id: totrans-530
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For an object to fulfill the iterable protocol, it must implement `[Symbol.iterator]`,
    like so:'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'Providing custom methods of iteration via the iterable protocol can be useful
    when you want to control the order of iteration or if you want to somehow process,
    filter, or generate values during iteration. Here, for example, we are specifying
    an iterator function as a generator function, which, as you may recall, returns
    a generator that fulfills both the *iterator* and iterable protocols. This generator
    function will yield two variants for every word stored – one uppercase and one
    lowercase:'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'Specifying iterator functions as generator functions like this is far simpler
    than having to manually implement the iterator protocol. Generators naturally
    fulfill this contract, so they can be used far more seamlessly. Generators also
    tend to be more readable and succinct and have the dual benefit of implementing
    both the iterator and iterable protocols, meaning that they can be used to decorate
    an object with iteration capabilities:'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: 'They can, themselves, also provide that iteration capability:'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: It's important to keep in mind that any work that's done within a custom iterable
    should be in line with the expectations of consumers. Iteration is usually considered
    a read-only operation, so you should steer clear of mutations of the underlying
    value-set during iteration. Implementing your own iterables can be incredibly
    powerful, but can also lead to unexpected behavior by the consumers of your code
    who aren't aware of your custom iteration logic.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
- en: It's vital to balance the convenience of custom iteration for those people who
    are *in the know* with those people who might only be experiencing your interface
    or abstraction for the first time.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
- en: RegExp
  id: totrans-541
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JavaScript natively supports regular expressions via the object type `RegExp`,
    allowing them to be expressed via the literal syntax `/foo/` or directly via the
    constructor (`RegExp('foo')`).  Regular expressions are used to define patterns
    of characters that can be matched or executed against strings.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example in which we extract only the long words (`>=10` characters)
    from a corpus of text:'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: The grammar and syntax of regular expressions can be complex. It is technically
    an entire language unto itself, requiring many days of study. We won't be able
    to explore all of its complexity here. We will, however,  be covering the ways
    in which we typically operate on regular expressions within JavaScript and explore
    some of the challenges in doing so. It is suggested that you conduct further study
    into regular expressions yourself.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
- en: Regular expression 101
  id: totrans-546
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Regular expressions allow us to describe a pattern of characters. They are
    used for matching and extracting values from strings. For example, if we had a
    string that contained digits `(1,2,3)` at various positions, a regular expression
    would allow us to easily retrieve them:'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  id: totrans-548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'A regular expression is written as a pattern delimited by forward slashes,
    with optional flags following the final forward slash:'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  id: totrans-550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: 'The pattern you write can contain both literal and special characters that
    together inform the regular expression engine of what to look for. The regular
    expression we''re using in our example contains literal characters (that is, `1`,
    `2`, `3`) and the pipe (that is, `|`) special character:'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: The pipe special character tells the regular expression engine that the characters
    on the left or the right of the pipe may match. The `g`, following the final forward
    slash, is a *global* flag that directs the engine to search globally within the
    string and not to give up after the first match is found. For us, this means that
    our regular expression will match either `"1"`, `"2"`, or `"3"`, wherever they
    appear within a subject string.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
- en: 'There are specific special characters we can use within regular expressions
    that act as shortcuts. The notation `[0-9]` is an example of this. It is a* character
    class* that will match all the digits from `0` to `9` so that we don''t have to
    list all of these digits individually. There is also a *shorthand character class*,
    `\d`, that allows us to express this even more succinctly. Thus, we can shorten
    our regular expression to the following:'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  id: totrans-555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 'For a more realistic application, we may imagine a scenario in which we wish
    to match sequences of digits, such as phone numbers. Perhaps we wish to match
    only those phone numbers beginning with `0800` and containing a further `4` to
    `6` digits. We could do this with the following regular expression:'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  id: totrans-557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: 'Here, we are using the `{n, n}` syntax, which allows us to express a quantity
    for the preceding special character, `\d`. We can confirm that our pattern works 
    by passing it to a test string''s `match` method:'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  id: totrans-559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: This brief introduction only touches on the very surface of what regular expressions
    can do. The syntax of regular expressions allows us to express significant complexity,
    allowing us to validate that specific text exists within a string or to extract
    specific text for use within our programs.
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
- en: RegExp flags
  id: totrans-561
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The literal syntax of regular expressions allows for specific *flags*, such
    as `i` (*ignore-case*), to be specified after the final delimiting forward slash.
    These flags will affect the way the regular expression is executed:'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  id: totrans-563
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: 'When using the `RegExp` constructor, you can pass your flags as the second
    argument:'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  id: totrans-565
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: 'There are six available flags in JavaScript''s flavor of regular expression:'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
- en: '`i`: The *ignore-case* flag will ignore the case of the string when matching
    letters (that is, `/a/i` would match both `''a''` andor `''A''` in a string).'
  id: totrans-567
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`g`: The *global-match* flag will make the regular expression find *all* matches
    instead of stopping after the first match.'
  id: totrans-568
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`m`: The *multiline* flag will make beginning and end anchors (that is, `^`
    and `$`) mark the beginnings and ends of individual lines instead of entire strings.'
  id: totrans-569
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`s`: The *dotAll* flag will cause the dot character in your regular expression
    (which usually only matches non-newline characters) to match newline characters.'
  id: totrans-570
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`u`: The *Unicode* flag will treat the sequence of characters in your regular
    expression as individual Unicode code points instead of code units. This broadly
    means you can painlessly match and test for rare or exotic symbols such as emojis
    (see the section within this chapter on the `String` type to get a more thorough
    understanding of Unicode).'
  id: totrans-571
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`y`: The *sticky* flag will cause all `RegExp` operations to attempt a match
    at the exact index detailed by the `lastIndex` property and then mutate `lastIndex`
    upon matches.'
  id: totrans-572
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As we''ve seen, regular expressions can also be constructed via the `RegExp`
    constructor. This can usefully be invoked as both a constructor or a regular function:
    either way, you''ll receive a `RegExp` object equivalent to what was derived from
    the literal syntax:'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  id: totrans-574
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: This is quite a unique behavior. In fact, the `RegExp` constructor is the only
    natively provided constructor that can be invoked as both a constructor and a
    regular function and, in both cases, returns a new instance. You'll recall that
    the primitive constructors (such as `String` and `Number`) can be invoked as regular
    functions but will behave differently when invoked as constructors.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
- en: Methods accepting RegExp
  id: totrans-576
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are seven methods provided by JavaScript that are capable of utilizing
    regular expressions:'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
- en: '`RegExp.prototype.test(String)`: Runs the regular expression against the passed
    string and return true if it finds at least one match. It will return false if
    no matches are found.'
  id: totrans-578
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RegExp.prototype.exec(String)`: If the regular expression has a global (`g`),
    flag then `exec()` will return the next match from the current `lastIndex` (and
    will update the regular expression''s `lastIndex` after doing so); otherwise,
    it will return the first match of the regular expression (similar to `String.prototype.match`).'
  id: totrans-579
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`String.prototype.match(RegExp)`: This `String` method will return a match
    (or if the global flag is set, all matches) of the passed regular expression made
    against the string.'
  id: totrans-580
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`String.prototype.replace(RegExp, Function)`: This `String` method will execute
    the passed function on every single match and will, for each match, replace the
    matched text with whatever the function returns.'
  id: totrans-581
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`String.prototype.matchAll(RegExp)`: This `String` method will return an iterator
    of all results and their individual groups. This is useful when you have a global
    regular expression with individual matching groups.'
  id: totrans-582
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`String.prototype.search(RegExp)`: This `String` method will return the index
    of the first match or -1 if there are no matches found.'
  id: totrans-583
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`String.prototype.split(RegExp)`: This `String` method will return an array
    containing parts of the string split by the provided separator (which can be a
    regular expression).'
  id: totrans-584
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are many methods to choose from, but for most situations, you'll likely
    find that the `RegExp` method, `test()`, and the String methods, `match()` and
    `replace()`, are the most useful.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a rundown of some examples of these methods. This should give you an
    idea of the situations in which each method may be used:'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  id: totrans-587
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: Most of these methods, as you can see, behave intuitively. However, there is
    some complexity surrounding *stickiness* and the `lastIndex` property, which we
    will now go over.
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
- en: RegExp methods and lastIndex
  id: totrans-589
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By default, if your `RegExp` is global (that is, uses the `g` flag), the `RegExp`
    methods (that is, `test()` and `exec()`) will mutate the `lastIndex` property
    of the `RegExp` object upon each execution. These methods will attempt to match
    the subject string from the index specified by the current `lastIndex` property,
    which is 0 by default, and will then update the `lastIndex` upon every subsequent
    call.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
- en: 'This can lead to unexpected behavior if you expect `exec()` or `test()` to
    always return the same result for a given global regular expression and string:'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  id: totrans-592
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: 'It will also lead to confusion if you attempt to execute a global regular expression
    on more than one string without resetting the `lastIndex` yourself:'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  id: totrans-594
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: As you can see, following the match with the `"monkeys"` substring, the `lastIndex`
    is updated to the next index (`7`),  which means, when executed on a different
    string, the regular expression will continue where it left off and attempt to
    match everything beyond that index, which in the case of the second string, `"birds
    flying"`, is the substring `"lying"`.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
- en: 'As a rule, to avoid these confusions, it''s important to always have ownership
    over your regular expressions. Don''t accept regular expressions from elsewhere
    in a program if you''re using `RegExp` methods. Also, don''t attempt to use `exec()` or
    `test()` on different strings without resetting the `lastIndex` before each execution:'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  id: totrans-597
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: Here, you can see that, if we don't reset the `lastIndex`, our regular expression
    fails to match on subsequent strings that are passed to the `exec()` method. If,
    however, we reset the `lastIndex` prior to each subsequent `exec()` call, we'll
    observe a match.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
- en: Stickiness
  id: totrans-599
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Stickiness means that a regular expression will try to match at the exact `lastIndex` and
    that, if a match is not available at that exact index, it will fail (that is,
    return `null` or `false`, depending on the method used). The sticky flag (`y`)
    will force `RegExp` to read and mutate `lastIndex` with each match. Traditionally
    sticky methods such as `exec()` and `test()`, as we mentioned previously, will
    always do this, but the `y` flag will *force* stickiness even when using non-sticky
    methods, such as `match()`:'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  id: totrans-601
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: Stickiness can be useful if you're looking for a match at a specific index in
    a string or series of strings. However, its behavior can be unexpected if you're
    not in full control of `lastIndex`.  As we mentioned previously, a good general
    rule is to always have ownership over your own `RegExp` objects so that any mutations
    to `lastIndex` are only made by your code.
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-603
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have begun to delve into JavaScript by looking at the built-in
    types that the language provides. The point of our exploration has been to look
    at these language constructs through the lens of clean code. By doing so, we've
    highlighted the importance of caution when dealing with some of the more obscure
    areas of the language. We've discovered many of the nasty edge cases and challenges
    involved in using JavaScript types, such as the lack of precision in the floating-point
    `Number` type and the complexity of Unicode in the `String` type. Exploring these
    more difficult parts of the language allows us not only to avoid specific traps
    but instills a fluency within us that will hugely boost our ability to wield JavaScript
    in the service of clean code.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will continue to enhance this fluency. We will learn
    more about JavaScript's type system and begin to operate on and manipulate these
    types to suit our needs.
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
