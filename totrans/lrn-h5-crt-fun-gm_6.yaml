- en: Chapter 6. Adding Features to Your Game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is slightly different than the previous several chapters, in that
    there is no game associated with this chapter. The reason that we're not building
    a game with the concepts from this chapter is that the concepts covered are either
    way too complex for a single chapter (there are entire books dedicated to the
    topic of WebGL, for example) or they're not a particularly good match for use
    in a game. Also, some of the features mentioned at the end of the chapter are
    so new that browser support is still minimal (if any) and the stability of the
    APIs may not be too reliable. For this reason, we'll simply explain each API,
    provide meaningful examples, and hope this skin-deep introduction is enough to
    get you excited about the prospects involved with each API.
  prefs: []
  type: TYPE_NORMAL
- en: The first part of the chapter will cover *four* HTML5 APIs that are very exciting
    and powerful additions to the browser platform. First and foremost, we'll cover
    **WebGL** , which brings the power of **OpenGL ES** to the browser, allowing for
    hardware accelerated 3D graphics rendering without any need for a single plugin.
    Next, we will discuss how we can use web sockets for a thread-like experience,
    the video API for native video playback and manipulation right from JavaScript,
    and geolocation, which allows JavaScript to determine the physical location (geographical
    location) of a user.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we'll wrap up the chapter by looking at the absolute latest features
    in the HTML5 evolution. These features take CSS to the next level, taking it away
    from being a mere rectangular-based rendering engine. The first new feature that
    we'll study is CSS shaders, which allows us to specify how each pixel is to be
    rendered. This is done using GLSL shaders, which, as we'll see during the WebGL
    discussion, are independent programs that we write and are run on the GPU, controlling
    at the lowest level possible how something is to be rendered. With custom shaders,
    we can do so much more than simple, pre-baked CSS transformations.
  prefs: []
  type: TYPE_NORMAL
- en: Other new CSS features, covered in the second half of the chapter, are CSS columns
    and CSS regions and exclusions. CSS columns make it beautifully easy to dynamically
    adjust how many columns of text a container displays. For example, if we want
    a block of text to be displayed in 3 equal width or height columns, we would normally
    set up three different containers, then float each container to the left. With
    columns, we can simply store all of the text inside a single container, then use
    CSS to generate the columns. Finally, CSS regions and exclusions make it possible
    to render text inside or around complex patterns, instead of the traditional rectangular
    shape. Surely you have seen magazines doing this, where a block of text wraps
    around some shape like the outline of a car or some other object. In the past,
    doing this effect with plain text (as opposed to using images) has very rarely
    been attempted in HTML because of the extreme complexity required to pull this
    off. Now it only takes a few lines of CSS code.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced HTML5 APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although the following APIs and features vary greatly in complexity and learning
    curve steepness, our goal is to provide at least a thorough introduction to each
    of these topics. In order to gain a deeper understanding of, and working experience
    with each topic, it is recommended that you supplement the introduction provided
    here with other sources.
  prefs: []
  type: TYPE_NORMAL
- en: Since parts of the HTML5 specs and features have not yet reached full maturity,
    some APIs may not be fully supported in all browsers, even the latest modern browsers.
    Since this chapter will cover the absolute latest features of HTML5 (as at the
    time of writing), there is a chance some browsers might not be suitable for the
    examples covered in the chapter. For this reason, it is recommended that you work
    on the latest version of whatever the most advanced web browser is. Not only that,
    but you must also make certain that you check whatever experimental feature and/or
    security flags your browser has available. The following code snippets were written
    specifically for, and aimed at Google Chrome, since all of the features described
    are supported by it. We will make a note of any specific configuration settings
    required for a feature to work properly but these may or may not be needed as
    new updates are deployed for new web browsers.
  prefs: []
  type: TYPE_NORMAL
- en: WebGL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Perhaps no other HTML5 feature is as exciting for game developers as WebGL.
    This new JavaScript API allows us to render high performance, hardware accelerated
    2D and 3D graphics. The API is a flavor of OpenGL ES 2.0 and makes use of the
    HTML5 canvas element in order to bridge the gap between the browser and the graphics
    processing unit in the user's computer.
  prefs: []
  type: TYPE_NORMAL
- en: While 3D programming is a topic worthy of its own book, the following overview
    is sufficient to get us started on the most important concepts, and will allow
    us to get started with 3D game development for the browser platform. For those
    looking for a good learning resource for OpenGL ES 2, take a look at *OpenGL ES
    2.0 Programming Guide by Munshi, Ginsburg, and Shreiner*.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since WebGL is heavily based on OpenGL ES 2.0, you may be tempted to look for
    reference and supplemental material about it from OpenGL books and other sources.
    Keep in mind that OpenGL Version 1.5 and earlier is significantly different than
    OpenGL 2.0 (as well as OpenGL ES 2.0, from which came WebGL) and may not be a
    complete source of learning, although it may be a decent starting point.
  prefs: []
  type: TYPE_NORMAL
- en: The major difference between the two versions is the rendering pipeline. In
    earlier versions, the API used a fixed pipeline, where the heavy lifting was done
    for us behind the scenes. The newer versions expose a fully programmable pipeline,
    where we need to provide our own **shader** programs in order to render our models
    to the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Hello, World!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before going any further into the theoretical side of WebGL and 3D programming,
    let's take a quick look at the simplest possible WebGL application, where we'll
    simply render a yellow triangle against a green background. You will notice that
    this takes quite a few lines of code. Keep in mind that the problem that WebGL
    solves is not a trivial one. The purpose of WebGL is to render the most complex
    of three dimensional, interactive scenes, and not simple, static two dimensional
    shapes, as illustrated by the following example.
  prefs: []
  type: TYPE_NORMAL
- en: In order to avoid a large code snippet, we'll break down the example into a
    few separate chunks. Each chunk will be presented in the order in which they are
    executed.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we need to do is set up the page where our example will run.
    The two components here are the two shader programs (more information on what
    a shader program is will follow) and the initialization of the `WebGLRenderingContext`
    object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `script` tags of type `glsl-shader/x-vertex` and `glsl-shader/x-fragment`
    make use of how HTML renders unknown tags. When a browser parses a `script` tag
    with a `type` attribute that it does not understand (namely a made up type, such
    as `glsl-shader/x-vertex`), it simply ignores all of the contents of the tag.
    Since we want to define the contents of our shader programs within our HTML file,
    but we don't want that text to show up in the HTML file, this slight hack comes
    in very handy. This way we can define those scripts, have access to them, and
    not worry about the browser not knowing how to handle that particular language.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned earlier, in WebGL we need to provide the GPU with a so-called shader
    program, which is an actual compiled program written in a language called **GLSL**
    (OpenGL Shading Language), which gives the GPU the instructions required to render
    our models just the way we want. The variables `shaderFrag` and `shaderVert` hold
    a reference to the source code of each of these shader programs, which is itself
    contained inside our custom `script` tags.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a regular HTML5 canvas element, inject it into the DOM, and
    create a `gl` object. Note the similarities between WebGL and the 2D canvas. Of
    course, beyond this point the two APIs are one from Mars and one from Venus, but
    until then, the initialization of them is identical. Instead of requesting a 2D
    Rendering Context object from the canvas object, we simply request a WebGL Rendering
    Context. Since most browsers (Google Chrome included) are still in experimental
    stages with WebGL, we must supply the `webgl` string with the experimental prefix
    when requesting the context. The Boolean `OR` operator separating the two `getContext`
    calls indicates that we're requesting the context from the experimental prefix,
    or without the prefix. Whichever call the browser supports, is the call that succeeds.
  prefs: []
  type: TYPE_NORMAL
- en: From this point on, every API call to WebGL is done from this `gl` object. If
    the call to the canvas that returns the `WebGLRenderingContext` object fails,
    we can make absolutely no calls to WebGL and we might as well halt execution.
    Otherwise, we can continue on with our program, passing around this object so
    that we may interact with WebGL.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The next step in this process is to create a vertex and fragment shader, which
    are then combined into a single shader program. The entire job of the vertex shader
    is to specify the position of a vertex in the final rendered model and the fragment
    shader's job is to specify the color of each pixel between two or more vertices.
    Since these two shaders are needed for any rendering to take place, WebGL combines
    them into a single shader program.
  prefs: []
  type: TYPE_NORMAL
- en: After the shader program is successfully compiled, it will be sent to the GPU
    where the processing of fragments and vertices take place. The way we can send
    input into our shaders is through pointer locations that we specify in the shader
    program before sending it to the GPU. This step is done by calling the `get*Location`
    method on the `gl` object (the `WebGLRenderingContext` object). Once we have a
    reference to those locations, we can later assign a value to them.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that our shader scripts declare variables of type `vec4` and `mat4`.
    In strongly typed languages such as C or C++, a variable can have a type of `int`
    (for integers), `float` (for floating point numbers), `bool` (for Boolean values),
    or `char` (for characters). In GLSL, there are a few new data types that are native
    to the language, which are specially useful in graphics programming. These types
    are vectors and matrices. We can create a vector with two components by using
    the data type `vec2`, or `vec4` for a vector with four components. Similarly,
    we can create a 3 x 3 matrix by calling `mat3`, which essentially creates an array-like
    structure with three `vec3` elements.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: After we have a shader program in place, which will tell the graphics card how
    to draw whatever points we give it to draw for us, it follows that we now need
    a few points to draw. Thus, this next step creates a buffer of points that we
    will draw in a little bit. If you remember [Chapter 4](ch04.html "Chapter 4. Using
    HTML5 to Catch a Snake"), *Using HTML5 to Catch a Snake*, where we introduced
    the new typed arrays, then this will look familiar to you. The way WebGL stores
    vertex data is by using those typed arrays, but more specifically, 32 bit floating
    point arrays.
  prefs: []
  type: TYPE_NORMAL
- en: In this particular case where we're only drawing a triangle, calculating, and
    keeping track of what all the points are is a trivial task. However, 3D models
    are not normally drawn by hand. After we draw a complex model using some 3D modeling
    software of one kind or another, we will be exporting anywhere from a few hundred
    to several thousand individual vertices that represent the model. In such cases,
    we will need to calculate how many vertices our model has and it would be a good
    idea to store that data somewhere. Since JavaScript allows us to add properties
    to objects dynamically, we take advantage of that and store these two calculations
    on the buffer object itself.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, let's actually draw our triangle to the screen. Of course, if we haven't
    written enough boilerplate code already, let's talk about one major component
    of 3D programming, and write just a little bit of extra code to allow us to finally
    render our model.
  prefs: []
  type: TYPE_NORMAL
- en: Without getting too deep into the topic of 3D coordinate space and transformation
    matrices, one key aspect of rendering 3D shapes into a 2D screen (for instance,
    your computer monitor), we need to perform some linear algebra to convert the
    points that represent our models from 3D space into a simple 2D space (think x
    and y coordinates). This is done by creating a couple of matrix structures and
    performing some matrix multiplication. Then, we just need to multiply each point
    in our 3D model (our triangle buffer, in this example) by a matrix called the
    **MVP matrix** (which is a matrix composed of three individual matrices, namely
    the model, view, and projection matrices). This matrix is constructed by the multiplication
    of the individual matrices, each representing a step in the transformation process
    from 3D to 2D.
  prefs: []
  type: TYPE_NORMAL
- en: If you have taken any linear algebra classes before, you will know that multiplying
    matrices is not as simple as multiplying two numbers. You will also notice that
    representing a matrix in JavaScript is also not as trivial as defining a variable
    to type integer. In order to simplify and solve this problem, we can use one of
    the many matrix utility libraries available in JavaScript. The particular library
    we'll use in this example is a very powerful one called **GL-Matrix** , which
    is an open source library created by Brandon Jones and Colin MacKenzie IV.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: A couple of things about the preceding code are noteworthy. First, you will
    notice that this is a single frame that's only drawn once. Had we decided to animate
    our scene (which we most definitely would in a real game), we would need to run
    the `drawScene` function inside a request animation frame loop. This loop would
    involve all of the steps shown, including all of the matrix math that generates
    our MVP matrix for each and every model that we would render on the scene. Yes,
    that is a lot of computations to perform multiple times per second, especially
    on more complex scenes.
  prefs: []
  type: TYPE_NORMAL
- en: Second, observe the usage of our model-view-projection matrices. We first create
    them as 4 x 4 matrices, then instantiate each of them. The projection matrix's
    job is to do just that—project the 3D points onto a 2D space (the canvas rendering
    context), stretching the points as needed in order to maintain the specified aspect
    ratio of the canvas. In WebGL, the coordinate system of the rendering context
    goes from zero to one on both axis (the vertical and horizontal axis). The projection
    matrix makes it possible to map points beyond that limited range.
  prefs: []
  type: TYPE_NORMAL
- en: The model and view matrices allow us to model points relative to the object's
    center (its own coordinate system) onto the world's coordinate system. For example,
    say we're modeling a robot. Suppose the robot's head is centered at point (0,
    0, 0). From that point, the robot's arms would be, say, at points (-5, 1, 0) and
    (5, 1, 0) respectively, both relative to the robot's head. But where exactly is
    the robot placed with respect to the world? And what if we had another robot in
    this scene, how are they positioned relative to each other? Through the model
    and view matrices, we can put them both on the same global coordinate system.
    In our example, we moved the triangle to the point (0, 0, -0.5, -3.0), which is
    a point somewhere close to the origin of the world coordinate system.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we bind our matrices to the graphics card, where we later render our
    scene by calling the draw functions defined in the `WebGLRenderingContext` object.
    If you look closely at the end of the `drawScene` function, we send some values
    to the `shader` object. Looking at the two shader programs we wrote earlier (using
    GLSL), we specified three variables that are used as input into the programs.
    The observant student will ask where those variables came from (the variables
    are defined in the vertex shader and are named `aVertPos`, `uMVMat`, and `uPMat`,
    which are special data types defined in the GLSL language). They come from our
    JavaScript code and are passed to the shader program in the GPU through calls
    to `gl.vertexAttribPointer` and `gl.uniformMatrix4fv`.
  prefs: []
  type: TYPE_NORMAL
- en: About 150 lines of code later, we have a yellow triangle rendered against a
    green background that looks like the following screenshot. Again, I remind you
    that WebGL is by no means a trivial programming interface and is not the tool
    of choice for simple drawing that could be done with easier tools, such as the
    2DRenderingContext of the canvas element, SVG, and possibly just a simple piece
    of photo editing software.
  prefs: []
  type: TYPE_NORMAL
- en: Although WebGL takes a lot of boilerplate code to render a very simple shape,
    as shown in the following screenshot, rendering and animating complex scenes is
    not much more complicated than that. The same basic steps required to setup a
    rendering context, create a shader program, and load buffers, are used in creating
    extremely complicated scenes.
  prefs: []
  type: TYPE_NORMAL
- en: '![Hello, World!](img/6029OT_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In conclusion, even though WebGL can be a beast of its own for developers just
    coming in to HTML5 or even game development, the fundamentals are fairly straight
    forward. For those seeking to deepen their understanding of WebGL (or 3D graphics
    programming in general), it is recommended that you study up on the subject of
    three dimensional programming and linear algebra, as well as the principles that
    are unique to, and a part of, WebGL. As a bonus, go ahead and get acquainted with
    the GLSL shading language as well, since this is what lies at the heart of WebGL.
  prefs: []
  type: TYPE_NORMAL
- en: Web sockets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you''ve ever thought about creating a high performance multiplayer game
    in HTML5 then the new web sockets API is just the thing you''ve been looking for.
    If you haven''t done much with socket programming before, this is what you''ve
    been missing: instead of establishing a connection to a server each and every
    time a resource needs to be requested, a socket simply creates a connection once,
    then the client and server can communicate back and forth over that same connection.
    To put it another way, imagine making a phone call to someone, saying "Hello",
    then hanging up the phone after the other person says "Hello" back to you. Then,
    you call that person again, wait for them to pick up the phone and once you''re
    both ready, you ask the person on the other side of the line how he or she is
    doing. After receiving an answer, you again hang up the phone. This continues
    for the duration of the conversation, where you only ask a question at a time
    (or make a single statement at a time), and most of the time is spent with both
    of you waiting for the call to come in and connecting the phones.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, with socket programming, the above scenario would be like making one phone
    call, then having the entire conversation without ever hanging up the phone. The
    only time you would hang up the phone would be when the conversation is finally
    over, and you and the other person have said good bye, and agreed to put down
    the phone. In this situation, there is virtually no delay between question and
    answer—only whatever intrinsic delay is involved in the sound traveling from one
    phone to another.
  prefs: []
  type: TYPE_NORMAL
- en: In HTML5, the sockets API is divided into two parts, namely a server part and
    a client part. The server side of the socket is something we will not discuss
    too much in this book, given the nature of what's involved. The client-side interface
    is where we will spend most of the discussion, although you will be happy to know
    that the JavaScript interface for web sockets and web workers is nearly identical.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the preceding code snippet, there aren't too many differences
    between the web socket interface and the web worker interface. Most notably, perhaps,
    is the actual interface through which we can post a message to the server. Whereas
    a web worker uses the `postMessage` function, a web socket uses the `send` function.
    The traditional event handling functions work the exact same way as with workers.
    There are four events associated with a socket, namely `onOpen` , `onClose` ,
    `onError` , and `onMessage`. The first two events, `onOpen` and `onClose`, are
    called when the server successfully validates the request and upgrades the connection
    with the browser and when the server somehow closes a connection with the particular
    socket, respectively. The `onError` event is fired when an error occurs on the
    server application. Finally, when the server pushes a message to the client, the
    JavaScript handle to the socket is alerted through the `onMessage` callback function.
    The event object that is passed to the function, similar to a web worker `onMessage`
    event object, has a `data` attribute with the actual data sent to it, as well
    as a `timestamp` attribute indicating when the message was sent.
  prefs: []
  type: TYPE_NORMAL
- en: The connection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Understanding the way a web application connects to a backend server through
    a web socket is fundamental to learning how the socket API works. The first point
    to remember is that the protocol that connects the browser to the server is different
    from the usual HTTP connection. The way a browser keeps the connection open with
    the server is by using the new `WebSocket` protocol, which is done by following
    a few steps. The `WebSocket` protocol is based on the traditional TCP and uses
    HTTP to upgrade the connection between a browser and a backend server, as illustrated
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The connection](img/6029OT_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When we create an instance of the `WebSocket` class in JavaScript, the browser
    attempts to establish the persistent socket connection with the server. The first
    thing that happens is that the browser sends an HTTP request to the URI specified
    in the `WebSocket` constructor. This request contains an upgrade header, specifying
    that it wishes to upgrade the connection to using the `WebSocket` protocol. The
    server and the browser then perform a typical handshake, which, for the purposes
    of this book will not be explained in any great detail. If you're interested in
    implementing your own backend server application to handle this low-level handshake,
    you can refer to the official web socket documentation online.
  prefs: []
  type: TYPE_NORMAL
- en: To be brief, the client sends this HTTP request to the server, including a header
    containing a key, which is a simple text string. The server then hashes and encodes
    that string and sends back an HTTP response, which the browser then validates,
    and accepts the protocol upgrade if everything is right. If this handshake is
    successful, the browser proceeds to instantiate the `WebSocket` object, which
    we can then use to communicate with the server over the same connection.
  prefs: []
  type: TYPE_NORMAL
- en: The server-side code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A typical use case for web sockets is a multiplayer game where two or more players
    either play against each other or otherwise share the same game, in real time,
    but from different locations. One way such a game could be implemented (say, a
    fighting game such as Street Fighter or Mortal Kombat) is by having two players
    connecting to the server from separate computers, then the server would receive
    input from both players and send them the output computed from their actions.
    Each player's client application would then simply render the data received from
    the server. For example, player A presses a key on the keyboard that makes the
    character controlled by player A jump. That data is sent to the server, which
    is keeping track of where the character is and whether it can jump, and so on.
    After the server computes what is to be done based on the input it received from
    player A (in this example, the server determines that player A's character is
    now performing a jump), it sends the updated state of player A's character to
    both player A and player B. Their application then simply renders player A's character
    up in the air. Of course, each player's local instance of the game also renders
    the state it calculates from a local player's actions in order to provide instant
    feedback. However, the server-side instance of the game has the ability to invalidate
    any game state resulting from input from either player, if it is determined to
    be invalid. This way, both players can experience a very smooth, responsive multiplayer
    gaming experience, while the integrity of the game remains in check.
  prefs: []
  type: TYPE_NORMAL
- en: Now, depending on the specific language in which the server-side code is implemented,
    this could either be a trivial task or a real nightmare. Overall, the main thing
    that this server-side code needs to keep track of is all of the sockets connected
    to it. Obviously, the complexity of the application will be relative to the goals
    of the game. However, as far as the web sockets API is concerned, the main point
    is to pass data back to the client using the `send` interface function and check
    on input from the `onMessage` function.
  prefs: []
  type: TYPE_NORMAL
- en: The client-side code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we saw in the previous code snippet, working with the JavaScript `WebSocket`
    object is very straightforward. Two things to keep in mind, however, are that
    every call to `WebSocket.send` is asynchronous and whatever data is padded to
    `WebSocket.send` must be (or will be converted to) a `DOMString`. That means that
    if we send an object, a function, or anything else to the server, it will be available
    to the server as a UTF-16 encoded string. If we send a JSON string to the server
    then all we need to do is parse the data and access the specifics. However, if
    we simply send an actual object, such as a literal JSON object, the server will
    receive something such as the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Thus, when sending objects through a web socket, JavaScript will not attempt
    to encode the object, but will instead simply call the object's `toString` function
    and send the output of that along to the socket.
  prefs: []
  type: TYPE_NORMAL
- en: Video
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Being able to play videos directly inside a browser without having to worry
    about plugins is quite a joyous experience. Not only that, but since the video
    element is actually a native part of the DOM, that means we can also deal with
    it the same way as we do with all other DOM elements. In other words, we can apply
    CSS styles to a video element and the browser is more than happy to make things
    work for us. For example, suppose we want to create the effect of the video being
    played on a shiny surface, where the video reflects vertically and the reflection
    fades out, blending into the background, as in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Video](img/6029OT_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Since the browser is in charge of rendering the video, as well as applying CSS
    styles and effects to all elements being managed by it, we don't have to worry
    about the logic involved in rendering a video with special effects added to it.
    Keep in mind, however, that the more CSS we throw on top of the video, the more
    work the browser will have to do to make the video look the way we want, which
    may quickly affect performance. However, if all we're adding to the video is a
    simple detail here and there, then most modern web browsers will have no problem
    rendering everything at full speed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Similar to the new HTML5 audio element, there are more or less two ways we can
    use the tag. One way is to simply create the HTML node, specify the same properties
    as the `audio` tag, specify one or more `source` nodes, and call it a day. Alternatively,
    we can use the JavaScript API available to us and programmatically manipulate
    the playback of the video file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We can also ignore the default controls and manage the playing, pausing, volume
    adjusting, and so on, on our own by taking advantage of the attributes available
    to the JavaScript object that references the video element. The following is a
    list of attributes and functions we can call on a video object.
  prefs: []
  type: TYPE_NORMAL
- en: Attributes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`autoplay`(Boolean)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`currentTime`(float—in seconds)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`paused` (Boolean)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`controls` (Boolean)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`muted` (Boolean)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`width` (integer)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`height` (integer)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`videoWidth` (integer—read only)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`videoHeight` (integer—read only)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`poster` (string—an image uri)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`duration` (int—read only)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`loop` (Boolean)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`currentSrc` (string)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`preload` (Boolean)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`seeking` (Boolean)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`playbackRange` (integer)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ended` (Boolean)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`volume` (integer—between 0 and 100 exclusive)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '| `loadstart` | The user agent begins looking for media data, as part of the
    resource selection algorithm. |'
  prefs: []
  type: TYPE_TB
- en: '| `progress` | The user agent is fetching media data. |'
  prefs: []
  type: TYPE_TB
- en: '| `suspend` | The user agent is intentionally not currently fetching media
    data. |'
  prefs: []
  type: TYPE_TB
- en: '| `abort` | The user agent stops fetching the media data before it is completely
    downloaded, but not due to an error. |'
  prefs: []
  type: TYPE_TB
- en: '| `error` | An error occurs while fetching the media data. |'
  prefs: []
  type: TYPE_TB
- en: '| `emptied` | A media element whose networkState was previously not in the
    `NETWORK_EMPTY` state has just switched to that state (either because of a fatal
    error during load that''s about to be reported, or because the `load()` method
    was invoked while the resource selection algorithm was already running). |'
  prefs: []
  type: TYPE_TB
- en: '| `stalled` | The user agent is trying to fetch media data, but data is unexpectedly
    not forthcoming. |'
  prefs: []
  type: TYPE_TB
- en: '| `loadedmetadata` | The user agent has just determined the duration and dimensions
    of the media resource and the text tracks are ready. |'
  prefs: []
  type: TYPE_TB
- en: '| `loadeddata` | The user agent can render the media data at the current playback
    position for the first time. |'
  prefs: []
  type: TYPE_TB
- en: '| `canplay` | The user agent can resume playback of the media data, but estimates
    that if playback were to be started now, the media resource could not be rendered
    at the current playback rate up to its end without having to stop for further
    buffering of content. |'
  prefs: []
  type: TYPE_TB
- en: '| `canplaythrough` | The user agent estimates that if playback were to be started
    now, the media resource could be rendered at the current playback rate all the
    way to its end without having to stop for further buffering. |'
  prefs: []
  type: TYPE_TB
- en: '| `playing` | Playback is ready to start after having been paused or delayed
    due to lack of media data. |'
  prefs: []
  type: TYPE_TB
- en: '| `waiting` | Playback has stopped because the next frame is not available,
    but the user agent expects that frame to become available in due course. |'
  prefs: []
  type: TYPE_TB
- en: '| `seeking` | The seeking IDL attribute changed to true. |'
  prefs: []
  type: TYPE_TB
- en: '| `seeked` | The seeking IDL attribute changed to false. |'
  prefs: []
  type: TYPE_TB
- en: '| `ended` | Playback has stopped because the end of the media resource was
    reached. |'
  prefs: []
  type: TYPE_TB
- en: '| `durationchange` | The duration attribute has just been updated. |'
  prefs: []
  type: TYPE_TB
- en: '| `timeupdate` | The current playback position changed as part of normal playback
    or in an especially interesting way, for example, discontinuously. |'
  prefs: []
  type: TYPE_TB
- en: '| `play` | The element is no longer paused. Fired after the `play()` method
    has returned, or when the `autoplay` attribute has caused playback to begin. |'
  prefs: []
  type: TYPE_TB
- en: '| `pause` | The element has been paused. Fired after the `pause()` method has
    returned. |'
  prefs: []
  type: TYPE_TB
- en: '| `ratechange` | Either the default `Playback Rate` or the `playback Rate`
    attribute has just been updated. |'
  prefs: []
  type: TYPE_TB
- en: '| `volumechange` | Either the `volume` attribute or the `muted` attribute has
    changed. Fired after the relevant attribute''s setter has returned. |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more information on events, visit W3C Candidate Recommendation Media Events
    at [http://www.w3.org/TR/html5/embedded-content-0.html#mediaevents](http://www.w3.org/TR/html5/embedded-content-0.html#mediaevents)
  prefs: []
  type: TYPE_NORMAL
- en: One final reason that you should be excited about the new HTML5 video element
    is that each frame of the video can be rendered right into a canvas 2D rendering
    context, just as if a single frame was a standalone image. This way, we are able
    to do video processing right on the browser. Unfortunately, there is no `video.toDataURL`
    equivalent where we could export the video created by our JavaScript application.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The idea is to play the video offscreen, meaning that the actual video player
    is never attached to the DOM. The video still plays, but the browser never needs
    to blitz each frame to the screen (it only plays in memory). As each frame is
    played, we draw that frame to a canvas context (just like we do with images),
    take the pixels from the canvas context, manipulate the pixel data, then finally
    draw it back on to the canvas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since a video is nothing more than a sequence of frames played one after the
    other, giving the illusion of animation, we can extract each frame from an HTML5
    video and use it with the canvas API just like any other image. Since there isn''t
    a way to draw to the video element, we simply keep on drawing each frame from
    the video player into a plain canvas object, achieving the same result—but with
    carefully crafted pixels. The following screenshot illustrates the result of this
    technique:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Events](img/6029OT_07_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: One way to achieve this result is to create two canvas elements. If we only
    draw to the same canvas (draw the frame from the video, then manipulate that frame,
    then draw the next frame, and so on), the customized frame would only be visible
    for a fraction of a second. It would only be visible until we quickly drew the
    next incoming frame. In turn, this next frame would only be visible for as long
    as we looped through that frame's pixel data and redrew that frame again. You
    get the idea, the result would be messy, and not at all what we want.
  prefs: []
  type: TYPE_NORMAL
- en: So instead we use two canvas contexts. One context will be in charge of only
    displaying the pixels we work on (also known as, the manipulated pixels) and the
    other context will never be visible to the user and will serve the purpose of
    holding each frame as it comes straight from the video. This way, we're only drawing
    to our main, visible canvas once per iteration and all that's ever displayed in
    this canvas context is the manipulated pixels. The original pixels (also known
    as, the pixels from the original video that's playing in memory) will continue
    to be streamed to the offscreen canvas context as fast as they can.
  prefs: []
  type: TYPE_NORMAL
- en: Geolocation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although 3D graphics are awesome, as is a socket-based, multiplayer game, neither
    technology is necessarily new. Geolocation, on the other hand, is somewhat of
    a more recent phenomenon. With it, we are able to use JavaScript to determine
    the physical location (geographical location) of a user. Having such a tool at
    our disposal opens up new possibilities of awesome, highly innovative game concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Now, whenever a new feature comes out that promises to be able to track down
    exactly where a user is physically located, most people (except for developers,
    of course) get at least a little scared about it. After all, how creepy would
    it be to play a very dark, survival horror game, knowing that other people playing
    the game can see exactly where you live. Luckily for us, the entire geolocation
    API is opt-in-based, meaning that the user is prompted about the application attempting
    to capture the user's location and the browser only allows the application to
    continue to capture the GPS location of the user if and when the user accepts
    the request from the application.
  prefs: []
  type: TYPE_NORMAL
- en: As shown in the following screenshot, when attempting to use the geolocation
    API, the browser will somehow alert the user about it and ask for permission to
    continue. If the user decides not to share his or her location with the application,
    the browser will not share the location with the application.
  prefs: []
  type: TYPE_NORMAL
- en: '![Geolocation](img/6029OT_07_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Although each browser implements this request step slightly differently, especially
    with regards to how this notification and request is graphically conveyed to the
    user, there is no way for the application to use the geolocation API to forcefully
    or secretly collect this piece of information.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The first part of the API involves asking the user for permission to get his
    or her location. This is done by calling the `getCurrentPosition` function on
    the `geolocation` attribute of the global navigator object. The function takes
    two arguments, namely a callback function to be called if the user allows the
    browser to share the user's location and a callback function to be called if the
    user denies the application's request.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the user accepts the request from the application to share the geolocation,
    the callback is invoked with a `Geoposition` object passed in to it. This object
    has *nine* properties that we can use:'
  prefs: []
  type: TYPE_NORMAL
- en: '`timestamp`: When the callback function was invoked'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`coords`: An instance of class `Coordinates`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`accuracy`: How accurate the GPS coordinate is (in meters)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`altitude`: In meters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`altitudeAccuracy`: How accurate the altitude is (in meters)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`heading`: In degrees clockwise from north'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`latitude`: As a double'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`longitude`: As a double'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`speed`: In meters per second'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are only three attributes in the position object that are required to
    be present. These are the `latitude` and `longitude` values, along with the `accuracy`
    attribute. All other values are optional and will be available if the hardware
    in use supports them. Keep in mind, also, that this feature is equally available
    on mobile devices, so it is possible and likely that the user's position changes
    somewhat during the course of the application's usage. Thankfully, once the user
    has agreed to have his or her position shared with the application, any subsequent
    calls to get the current position will be successful right away. Of course, the
    user can just as well clear the permissions for a given domain right from the
    browser, so any subsequent calls to get the position may fail (if the user has
    disabled the feature altogether) or result in a new request for permission (in
    case the user simply cleared the permissions cache on the browser).
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from the following screenshot, Google Chrome displays a different
    icon on the address bar when a page is using geolocation to let the user know
    about it. By clicking this special icon, the user can reset the permissions, or
    block or allow the application on a more long term basis.
  prefs: []
  type: TYPE_NORMAL
- en: '![Geolocation](img/6029OT_07_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A Google Maps example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Possibly the most common use case for geolocation these days involves rendering
    a position to a map. Thankfully, Google offers a terrific, free API that we can
    tap into for the purposes of doing just that. With this mapping service, we can
    capture a user's geolocation, then render a marker on the map right where the
    user is located (or somewhere within the accuracy distance of where the user is).
    While the Google Maps API is rather robust, we will simply cover a fairly trivial
    example of how we can go about obtaining the user's location then render that
    coordinate point on a map.
  prefs: []
  type: TYPE_NORMAL
- en: 'The general idea where the maps API is based is simple: create a map object
    to be rendered inside some HTML container object, specify where this map is to
    be centered (so that we can know the general area within the map that is immediately
    visible to the user), and add markers to it. Marker objects take at least two
    attributes, namely a reference to a map object and a GPS coordinate point. In
    our example, we''ll center the map on the user''s GPS coordinate and also place
    a marker on that same location.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: While the preceding example might not be the most exciting piece of software
    you've seen, it does a great job illustrating two powerful points. First, the
    geolocation API is powerful, yet, it is also possibly the easiest of all other
    HTML5 APIs in terms of all the functionality it offers and everything you need
    to know in order to use it. Second, the preceding snippet shows how open the web
    platform is and how much we can potentially accomplish simply by taking advantage
    of other people's work.
  prefs: []
  type: TYPE_NORMAL
- en: Running the preceding code will result in a very nice looking map covering the
    entirety of the screen, with the central point of the map being the user's current
    location, as shown in the following screenshot. Keep in mind that Google Maps
    is just one example of the many free APIs that we can use in conjunction with
    such powerful HTML5 features as geolocation.
  prefs: []
  type: TYPE_NORMAL
- en: '![A Google Maps example](img/6029OT_07_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Upcoming CSS features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of my favorite things about the Open Web is that it is also a living web.
    As new ideas arise and as new needs manifest themselves, it becomes a matter of
    time until new features are introduced into a spec. A perfect example of this
    is CSS, where recently there have been a few new features added to the spec. Best
    of all, most browser vendors are quite proactive at bringing these new features
    to their browsers.
  prefs: []
  type: TYPE_NORMAL
- en: In this next section we will look at three new features of CSS, namely CSS shaders,
    CSS columns, and CSS regions and exclusions. To give you an idea of how active
    the development of these features is, we will discuss the first feature **CSS
    shaders**, which was recently renamed as CSS custom filters. Talk about a fast
    moving development life cycle.
  prefs: []
  type: TYPE_NORMAL
- en: Programming in the bleeding edge
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although most of the content in this book is somewhat new and state of the art,
    the majority of the HTML5 features and APIs discussed so far are fairly stable.
    By that, I mean that just about any major browser should be able to handle these
    features without any problems. However, the following CSS features are literally
    fresh out of the oven. To be more specific, all three of these features are still
    being baked, with the recipe being worked on until it reaches a more stable level
    of refinement.
  prefs: []
  type: TYPE_NORMAL
- en: 'With that said, this section may require that you use the absolute most recent
    browsers, using the latest possible version, and you may even be required to delve
    into the settings section of your browser of choice so that any advanced flags
    are set in order for these new and experimental features to work. All of the code
    examples for the rest of this chapter were written for and tested in Google Chrome
    Canary (nightly builds). As of this writing, after a fresh install of Google Chrome
    Canary, the following flags had to be manually enabled:'
  prefs: []
  type: TYPE_NORMAL
- en: Enable `experimental WebKit features`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enable `CSS shaders`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You likely won''t need to enable the `WebGL` flag, as this particular flag
    has been enabled by default for a while, but in case the flag is disabled, you
    can make it available in the same manner. To view all the available flags that
    can be set on Google Chrome, simply type the following command in the browser''s
    address bar (where you normally enter a website''s URL): `chrome://flags`.'
  prefs: []
  type: TYPE_NORMAL
- en: Once in the flags page, you will see a list of flags, along with a description
    of what each flag does. Look for the two flags related to `experimental WebKit
    features` and `CSS shaders`, and be sure that they are enabled. As you can tell
    from the following screenshot, beware that carelessly setting and unsetting flags
    may affect the way that Google Chrome behaves and performs. Be sure to change
    the least amount of flags to avoid doing anything to cause the browser to work
    less than optimally and make sure you keep track of any flags you change, so that
    you can revert your changes, should anything bad happen as a result.
  prefs: []
  type: TYPE_NORMAL
- en: '![Programming in the bleeding edge](img/6029OT_07_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: One final note about developing with these absolute bleeding edge APIs is that,
    given the nature of an experimental API, there may be browser specific syntax
    and features as well as significant performance differences between different
    browsers. Since not all browsers start adopting new APIs at the same time, a great
    percentage of users are not able to view your latest and greatest code until APIs
    become stable enough—which sometimes takes longer than we'd like them to.
  prefs: []
  type: TYPE_NORMAL
- en: CSS shaders
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Currently, this is the absolute latest feature added to CSS. The original idea
    behind CSS shaders was to allow a designer to use GLSL shaders to render arbitrary
    HTML elements. Instead of simply specifying an element's background color, border
    style, box shadow, and so on, we can now take care of how each pixel of an element
    is rendered.
  prefs: []
  type: TYPE_NORMAL
- en: More recently, this feature was merged into the existing CSS filters spec, which
    specifing a handful of pre-baked filters that we can apply to an element. For
    example, we can apply a blur filter to an image element, letting the browser process
    the image dynamically, as it gets served from the server to the web application.
    However, instead of relying only on whatever filters a browser decides to make,
    we can now cook our own filters and have the CSS rendering engine use those. Thus,
    the current name of this new CSS API is (for now, anyway) **custom CSS filters**.
  prefs: []
  type: TYPE_NORMAL
- en: Using CSS filters is pretty easy. After all, they are nothing more than a regular
    CSS property. As of this writing, there are *nine* different filters that we can
    apply, not only to images, but also to anything that can receive CSS styling.
    If a filter is added to an element with one or more children nodes in it, as is
    the nature of CSS, the filter effect will cascade down to any and all child elements,
    unless one or more of them specify their own filters, or deliberately specify
    that no filtering should be applied to it and its children.
  prefs: []
  type: TYPE_NORMAL
- en: 'The current list of CSS filters that can be used are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`blur`: Applies a Gaussian blur'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`brightness`: Increases the brightness of the element by applying more or less
    white color'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`contrast`: Adjusts the contrast of the element'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`drop-shadow`: Applies a drop shadow effect to the element'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`grayscale`: Converts the colors of the element into grayscale'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hue-rotate`: Applies a hue rotation in degrees based on a color circle'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`invert`: Inverts the colors of the element'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`opacity`: Applies transparency to the element'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`saturate`: Increases the saturation of the element'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sepia`: Converts the colors of the element into sepia'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keep in mind that, although these filters are in fact mere CSS attributes, in
    reality they are each a separate function that the browser performs on the elements
    matched by the CSS query. Thus, each filter function takes one or more arguments,
    which, behind the scenes, are variables being passed to pre-defined shader programs.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the following screenshot, the image on the left is a regular piece of HTML,
    with a heading and an image. On the right, we applied a CSS filter that inverted
    the colors. That entire effect was achieved with a single line of code.
  prefs: []
  type: TYPE_NORMAL
- en: '![CSS shaders](img/6029OT_07_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note that we can apply multiple filters to the same element by just simply listing
    additional filters as the value of the CSS property. Also, keep in mind that even
    though it only takes a single line of code to add one of these exciting filters
    to our applications, each filter used means work that the browser will need to
    do on top of all that it's already doing. Thus, the more we use these filters,
    the more we can expect performance to drop accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Using custom filters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In order to input our own filtering functions for the browser to use when rendering
    our application, we need to create the shader program that does what we want.
    Thankfully, these shader programs are written in the same shading language that
    we use in WebGL. If you thought learning JavaScript, CSS, and HTML was a lot of
    work already, I'm sorry to say, but go ahead and add GLSL to the list of languages
    you must master (or find someone who's already mastered it) in order to take full
    advantage of the HTML5 revolution.
  prefs: []
  type: TYPE_NORMAL
- en: To specify custom shaders to be used for our CSS filters, we simply call the
    custom function as the value of the filter attribute, pass in our vertex and fragment
    shaders, followed by any possible variables to be used by the vertex shader. External
    variables used by the fragment shader are passed in from the vertex shader, so
    we can't pass anything into it directly from CSS.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: There are three parts to the preceding filter definition. First, we call `custom`
    to indicate that we'll be using our own shaders. The first argument we pass to
    this function is the vertex shader. The extension of this file is not important,
    as the contents of the file will be compiled and sent to the GPU. A lot of the
    time, you will see other developers using file extensions for their shaders such
    as `.glsl` or `.vs` and `.fs` (for vertex shader and fragment shader, respectively).
    Note that the fragment shader is sent through the `mix()` function, as opposed
    to just being sent directly through the `url()` function, as is the case with
    the vertex shader. Lastly, we specify the number of rows and columns that will
    make up the element's content mesh. The vertices that make up this mesh are created
    by the browser automatically. Finally, the last set of arguments passed with our
    custom filter are uniform values (accompanied by their names) for the vertex shader
    to use.
  prefs: []
  type: TYPE_NORMAL
- en: Since GLSL itself is beyond the scope of this book, we will stay away from a
    thorough example of these custom shaders. Instead, we will look at a symbolic
    example, which will use dummy shaders. Without the proper background knowledge
    and experience with graphics programming, shader programming, and other 3D graphics
    topics, it would be rather challenging to explain our way through a custom shader
    program.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following shader programs take three inputs from CSS, namely a value between
    0.0 and 1.0 representing the amount of red, green, and blue to be applied to each
    pixel in the image. As a quick and brief crash course in OpenGL Shading Language
    (GLSL), I''ll just say this: a uniform is like a global variable that we can pass
    in to the vertex shader. The vertex shader is called once per vertex and determines
    where each vertex is positioned. In order to send values to the fragment shader,
    the vertex shader can use a varying variable. If we define a variable of whatever
    type in the vertex shader that has the `varying` keyword before it, that means
    that whatever value is assigned to it will be available to the fragment shader,
    provided that the fragment shader also defines a varying variable of the same
    name and type. Thus, if we want a value to be passed to the fragment shader directly
    from CSS, we can simply send the value to the vertex shader, then use `varying`
    to pass the value through to the fragment shader. The fragment shader is called
    once per pixel and determines what color to apply to that pixel.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The only two things the preceding vertex shader does are pass our values from
    CSS to the fragment shader and set the vertex position of each vertex on our content
    mesh.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: With that shader program in place, all we need to do is call it from within
    our HTML file. The three parameters we need to pay attention to are the red, green,
    and blue uniforms. Whatever values we send in for those three color channels,
    it will reflect on the rendering of whatever elements we apply this filter to.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: With this setup in place, our `div` element will render one particular way by
    default. In this case, we only turn on the red channel on every pixel within the
    DOM node. When we hover over the element, however, we apply the same shader, but
    with a completely different color. This time we make every pixel look extra yellow.
    With the help of CSS transitions, we can smoothly gradate those two states, giving
    a simple, yet quite cozy effect. Of course, the more you know about GLSL, the
    more fancy and powerful you can make these custom shaders. And as an added bonus,
    we don't have to worry about all of the setup work involved in using shaders in
    WebGL. The default abstraction provided by the browser is quite useful, making
    custom shaders very reusable, since people using our shaders only need to keep
    track of a couple of CSS attributes. Best of all, since shader programs are, at
    least at this CSS level, pure text files, we can learn how other people's shaders
    work by inspecting their source code. By using our custom shader, we can easily
    control which color channels are turned on or off at an individual pixel level,
    as shown in the following screenshot. This pixel by pixel manipulation is not
    only limited to images, but is rather performed on each pixel of whatever DOM
    element we apply the filter to—text, images, containers, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: '![Using custom filters](img/6029OT_07_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Beware, however, that since this technology is so hot off the oven, there are
    very few tools, if any, to help us develop, debug, and maintain GLSL shaders.
    You will quickly notice that when an error is found within your shaders, you will
    simply see an unfiltered HTML document. If your shader programs fail to compile,
    for example, the browser will not bother letting you know what happened, or where,
    or maybe even why. Thus, writing custom CSS filters can be the most challenging
    aspect of web development at the moment, since browsers are not yet very useful
    in offering a hand in the process.
  prefs: []
  type: TYPE_NORMAL
- en: CSS columns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you have been using the internet for at least a few weeks, or if you have
    seen at least a couple of dozen different websites, you will certainly have noticed
    the rectangular nature of HTML documents. Although it is possible to use a combination
    of HTML, JavaScript, and CSS to create very robust designs, web designers have
    been waiting for many moons for a simple solution to create multicolumn designs.
  prefs: []
  type: TYPE_NORMAL
- en: With the new CSS columns feature, we can create a regular block of text, then
    tell the CSS engine to display that block in two or more columns. Everything else
    is handled by the browser very efficiently. For example, say we want a block of
    text to be displayed into four equal width columns, with 20 pixels between each
    column. This can be achieved with two intuitive lines of code (vendor prefix may
    be required, but is deliberately ignored in this example).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: With the preceding setup, the browser knows that we wish to render our text
    into four columns, with 20 pixels separating each column on the sides. Observe
    that no mention is ever made about how wide to make each column. In this case,
    the browser calculates the space available inside the `div` container, subtracts
    the total width needed for the column gap (the space between two columns, not
    including the space between a column and the container), then divides the remaining
    width into the total number of columns. This way, as we resize the browser window,
    the columns will automatically resize and everything else will retain its dimensions.
  prefs: []
  type: TYPE_NORMAL
- en: After we specify a column gap width, the browser can determine how wide to make
    each column (if we specify a fixed number of columns) or a number of columns to
    display (if we specify a width for each column) based on the available space for
    the columns, as shown in the following screenshot. It doesn't normally make sense
    to specify both a column width and a number of columns.
  prefs: []
  type: TYPE_NORMAL
- en: '![CSS columns](img/6029OT_07_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Alternatively, we can simply tell the browser how wide we want each column,
    and optionally how much gap to have between two columns. What the browser would
    do in this situation is the opposite. It would calculate the remaining space available
    for rendering the columns, then render as many columns as it can in that space,
    given the width constraint we have specified.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The column rule
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Similar to the concept of a border around a box, as in border: 1px solid #333,
    CSS columns come with the concept of a rule. Simply put, a column rule is a single
    border that is drawn vertically between two columns. A rule can be styled much
    like a border and is rendered right between the two columns, making use of the
    space provided by a column-gap. If the space available for a column rule is greater
    than the space provided by a column gap, the gap is rendered properly and the
    rule is ignored.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, similar to a border property, we can specify each attribute related
    to a column rule, or short hand the definition in the same order as a border (width,
    style, and color, respectively). Valid values for a border style include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`none`: No border'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dotted`: The border is a series of dots'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dashed`: The border is a series of short line segments'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`solid`: The border is a single line segment'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`double`: The border is two solid lines. The sum of the two lines and the space
    between them equals the value of ''border-width'''
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`groove`: The border looks as though it were carved into the canvas'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ridge`: The opposite of ''groove'': the border looks as though it were coming
    out of the canvas'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more information on the table border styles, you can visit [http://www.w3.org/TR/CSS2/tables.html#table-border-styles](http://www.w3.org/TR/CSS2/tables.html#table-border-styles)
  prefs: []
  type: TYPE_NORMAL
- en: Column breaks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes, we may want a bit of control over where exactly the content breaks
    into a new column. For example, if we have several blocks of text, each preceded
    by heading of some sort. It may not look too good if the last line in a column
    is a lonely heading meant to introduce the next section. The column break property
    gives us this ability where we can specify column breaks before or after an element.
  prefs: []
  type: TYPE_NORMAL
- en: 'By specifying where a column should or should not break into the next column,
    we can have more control over how each column is rendered and populated, as demonstrated
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Column breaks](img/6029OT_07_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The same properties used to control page breaks in CSS are also used to control
    the breaking of columns. There are three properties we can use to control column
    break, namely `break-before`, `break-after`, and `break-inside`. The first two
    are fairly self-explanatory—we can use break before or after to indicate the behavior
    before or after a particular element, such as always break the column, never break,
    or insert the column break where it should normally be inserted. Break inside,
    on the other hand, specifies what should be the behavior inside a multiline block
    of text, instead of simply at its beginning or end.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Note how the column break property is applied to the `h2` tag, which now becomes
    the element that controls the breaking of each column. Of course, if we had specified
    a greater number of columns in this block of text than there were headings tags,
    then obviously the text inside the paragraph tags would end up breaking into new
    columns. This behavior can also be controlled, although in this particular case
    we simply set the `column-break-inside` property to `auto`, making it clear that
    we would like the content of each paragraph tag to spill over into other columns
    if needed.
  prefs: []
  type: TYPE_NORMAL
- en: CSS regions and exclusions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Two new text-related features of CSS are regions and exclusions. Regions behave
    somewhat similar to columns, in that we specify how a particular block of text
    is to render and flow. The main difference between regions and columns is that
    columns are restricted to equal width implied rectangles, whereas regions specify
    a separate content source and define where that content is to flow. For example,
    we can tell CSS to render text from a given source into three separate `div` elements,
    along with an arbitrary SVG polygon. Each of these elements need not be related
    in any particular way—one can be absolutely positioned, one can be transformed,
    and so on. The text would then flow from one element into the next, following
    the order in which each element is defined within the HTML file. Exclusions, on
    the other hand, do the exact opposite. Instead of defining areas where text flows
    into, they describe areas or shapes where text is to go around.
  prefs: []
  type: TYPE_NORMAL
- en: The whole reason for these two separate, yet closely related APIs, is to push
    the envelope of where we can take the visual design of web applications. Until
    now, the only way to achieve this sort of effect was through external software,
    and hopefully a very specific plugin that allowed such software or technology
    to be executed inside a browser. Now that the browser has grown a bit more mature,
    we can pull off these magazine-like effects right from the stylesheet.
  prefs: []
  type: TYPE_NORMAL
- en: Regions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The way regions work is somewhat similar to columns, yet it is fundamentally
    different. In general, all that regions do is specify a content source, then assign
    a CSS expression as the destination of that content. The content is moved from
    the element specified as the source and flowed into all elements assigned as destinations.
    If one or more elements don't receive any content because there wasn't enough
    content, these elements will behave just like a regular *empty* element. Other
    than the CSS property that identifies an element as a destination, there is nothing
    else about that element that is different from any other regular HTML elements.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Here, we assign the contents of the element with an `id` property of `src` as
    the content provider, so to speak. This is done by assigning the new CSS property
    `flow-into`, which is assigned a string that we can use to identify this particular
    region content source. That means that the contents of that element will not be
    rendered where they are within the DOM, but will instead be distributed among
    all elements with a CSS property of `flow-from`, with a value matching the keyword
    used by the element with the `flow-into` property.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Once a region source is defined, and a region chain is created, the browser
    takes care of distributing the contents throughout all the regions. Each region
    can be uniquely styled and can be a unique element altogether. For example, a
    region source can be defined and two targets can be created. One target can be
    a standard `div` element and the other can be an SVG shape. CSS regions can also
    be combined with exclusions, which we'll discuss in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: As illustrated in the following screenshot, four elements are styled and floated
    about, while a region source is put in charge of filling up those regions. In
    case of region resizing, because of the browser window itself being resized, the
    user agent takes care of refreshing the content, flowing into the newly resized
    regions.
  prefs: []
  type: TYPE_NORMAL
- en: '![Regions](img/6029OT_07_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Exclusions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The way exclusions work is very similar to how we normally make text flow around
    images or any other inline elements. The main difference is that we can take it
    a step further and specify a few details in CSS that tells the text exactly how
    to flow.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This trivial snippet simply tells the rest of the content inside that `div`
    element to flow around the image from its right side. Even if we had an SVG object
    in the place of that image, and this object was a polygon shaped like a triangle
    pointing to the right, the text would wrap around the object treating it like
    a rectangle.
  prefs: []
  type: TYPE_NORMAL
- en: However, with the magic of CSS exclusions, we can add properties to the image
    tag or the SVG object that would alter the way its outer shape is interpreted.
    By default, since any HTML element has an x and y position, along with a `width`
    and `height` attribute, every element is treated like a rectangle. Using the shape
    property changes that.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: One thing that might be a bit tricky about CSS exclusions is that it simply
    defines a shape or path for the text to flow around and not necessarily a shape
    or path to be rendered. In other words, the two highlighted lines of code in the
    previous code example are completely independent. The only reason that the two
    polygon definitions resemble each other closely is for visual effects. If we had
    used an image, a `div`, or any other HTML element inside that block of text, the
    CSS `shape-outside` property would still cause the text to flow around that element
    the same way, no matter what physical shape that element has. Simply adding a
    CSS `shape` attribute to an element will not alter its own visual properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the previous code example produces an output similar to the following
    screenshot. Again, remember that the relationship between the path that the text
    follows and the shape of the element displayed, where no text is allowed to enter,
    is purely coincidental and intentional. If instead of an SVG polygon we had an
    image element, the text would still follow that arrow shape, but the rectangular
    image would float on top of any text that followed a path intersecting the image''s
    boundaries. Strictly speaking, exclusions only deal with how text flows within
    a given block of text. Whether anything is rendered along the path that the text
    follows is up to the designer, and is a separate issue from exclusions, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Exclusions](img/6029OT_07_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If the ultimate goal is to simply define a path for text to follow, such as
    in the previous example, we don't need to use SVG, or any specific HTML element.
    Simply having an element present and assigning basic floating attributes to that
    element is enough for exclusions to work with. Remember, the only significant
    part of exclusions is the shape attribute.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Alternatively, we can use the companion property to `shape-outside`, namely
    `shape-inside`. Intuitively, this property defines the opposite as its counterpart.
    Whereas a `shape-outside` property tells the browser where text needs to flow
    around (outside), a `shape-inside` property tells the browser the area where the
    text must stay within. All property values are the same for both attributes. The
    only difference between the two attributes is that in `shape-outside`, text is
    placed well outside of the placeholder element. With `shape-inside`, any text
    to be guided within the shape defined is placed as a descendant node of the shape
    element.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'In comparison with `shape-outside`, the `shape-inside` property contains its
    own contents within itself, as opposed to `shape-outside`, which is nothing but
    a block around which its sibling elements must flow, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Exclusions](img/6029OT_07_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, in anticipation of the question that these two properties beg to be
    asked, yes, we could very well combine an exclusion that defines a `shape-outside`
    property, and one that defines a `shape-inside` property. Observe that a `shape-inside`
    exclusion is nothing more than a block level element, just like any other. Viewing
    the source code of an HTML file without any CSS instructions will make a `shape-inside`
    exclusion impossible to be told apart from an ordinary block of text. Thus, we
    could very well use a `shape-inside` excluded element as a `shape-outside` exclusion.
    The same element can have both CSS attributes, since their effect is mutually
    exclusive. Any text inside the element would be bound to the `shape-inside` exclusion
    declaration, whereas any content around the element would be associated with the
    effects of the `shape-outside` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Defining shapes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Conveniently, possible values for shape properties are the same as basic SVG
    shapes. The four available shapes are rectangle, ellipse, circle, and polygon.
    Point values can be represented as length values or percentage values. The syntax
    for each of these shapes is very consistent and is of the form `<shape>([value]{?})`.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`rectangle(x, y, width, height)`: Defines a sharp rectangle with the top left
    corner of the shape being positioned at point x, y'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rectangle(x, y, width, height, round-x, round-y)`: Defines a rectangle with
    the option of rounding its corners'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ellipse(x, y, radius-x, radius-y)`: Defines an ellipse centered at point x,
    y'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`circle(x, y, radius)`: Defines a circle of a given radius, center at point
    x, y'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`polygon(p1-x p1-y, p2-x p2-y, (…))`: Defines a polygon given three or more
    pairs of x, y positions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter presented some of the more complex and cutting edge HTML5 APIs.
    The major highlight was the new 3D rendering and graphics programming API—WebGL.
    We also took a look at HTML5's new video playback capabilities as well as the
    ability to manipulate each frame of a video played natively on the browser. Finally,
    we got our feet wet with the latest and greatest CSS improvements and additions.
    This involved such APIs as CSS shaders, columns, and regions and exclusions.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we conclude our journey into the fascinating world of HTML5
    game development by delving into mobile web development with HTML5\. We will learn
    what makes mobile game development different from the traditional desktop application
    development. We will also learn two HTML5 APIs to help us along the way. The game
    that we will build to illustrate these concepts is a 2D space shooter that is
    completely mobile-friendly.
  prefs: []
  type: TYPE_NORMAL
