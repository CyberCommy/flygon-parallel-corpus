- en: '*Chapter 8*: Building a Chat App with Vue 3, Laravel, and Socket.IO'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, we have created frontend projects or full stack projects
    that only communicate via HTTP. There is no real-time communication between the
    frontend and the backend. Real-time communication is sometimes necessary if we
    need to communicate data from the server side to the client side and vice versa
    instantly. Without some real-time communication mechanism, there is no way to
    communicate from the server side to the client side without the client initiating
    the request. This is something that we can add easily with the Laravel framework
    and Socket.io.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will take a look at the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating the API endpoints with Laravel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up JWT authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the frontend to let users chat
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Laravel is a backend web framework that is written with PHP. It is a comprehensive
    backend framework that includes processing HTTP requests, database manipulation,
    and real-time communication.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will look at how to get all these parts working together
    so that we can create a chat app with Vue 3, Laravel, Laravel Echo Server, and
    Redis working together.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To fully understand this chapter, the following is required:'
  prefs: []
  type: TYPE_NORMAL
- en: A basic understanding of PHP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ability to create basic apps with Vue components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ability to send and receive HTTP requests with the Axios HTTP client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code for this chapter's project is available at [https://github.com/PacktPublishing/-Vue.js-3-By-Example/tree/master/Chapter08](https://github.com/PacktPublishing/-Vue.js-3-By-Example/tree/master/Chapter08).
  prefs: []
  type: TYPE_NORMAL
- en: Creating the API endpoints with Laravel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first step to create our chat app is to create a backend app with Laravel.
    Creating the API with Laravel is the main thing that we have to learn for this
    chapter. This is something that we have not done before. It also means that we
    have to write code in PHP since Laravel is a PHP-based web framework. Therefore,
    you should learn some basic PHP syntaxes before reading this code. Like JavaScript
    and other object-oriented languages, they share similar concepts such as using
    objects, arrays, dictionaries, loops, classes, and other basic object-oriented
    programming concepts. Therefore, it should not be too different from JavaScript
    in terms of difficulty of learning.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the required libraries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To create our API with Laravel, we don't have to create all the files ourselves,
    we just have to run a few commands and that will create all the files and configuration
    settings for us automatically. Before we create our API, we have to have PHP running.
    In Windows, the easiest way to add PHP to our Windows installation is to use XAMPP.
    We can download and install it by going to [https://www.apachefriends.org/download.html](https://www.apachefriends.org/download.html).
    It is also available for macOS and Linux.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we install it, then we can create our Laravel API with **Composer**. Composer
    is a package manager for PHP that we will use to install more libraries later
    on. The easiest way to create a project is to create our project folder and then
    run the command to create the Laravel project after we go to the folder:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we create a project folder called `vue-example-ch8-chat-app` that will
    hold both the frontend and backend in their own separate folders.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, within this folder, we create the backend folder to house our Laravel
    project code files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we go to the command line, then we go into `vue-example-ch8-chat-app` and
    then run `composer global require laravel/installer`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This will install the Laravel installer, which will let us create our Laravel
    project. The locations at which the global libraries are located are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**macOS**: `$HOME/.composer/vendor/bin`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Windows**: `%USERPROFILE%\AppData\Roaming\Composer\vendor\bin`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GNU / Linux Distributions**: `$HOME/.config/composer/vendor/bin` or `$HOME/.composer/vendor/bin`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can also run `composer global about` to find out where the library files
    are located.
  prefs: []
  type: TYPE_NORMAL
- en: Once that is done, we create the scaffold with all the files and also include
    all the configuration files and install all the required libraries for us with
    one command.
  prefs: []
  type: TYPE_NORMAL
- en: We go into the `vue-example-ch8-chat-app` folder through the command line, and
    then we run `laravel new backend` to create the Laravel app in the backend folder.
    The Laravel installer will run and create the scaffolding for our Laravel. Also,
    Composer will install all the PHP libraries that we need to run Laravel. Once
    that is all done, we should have a full Laravel installation with all the files
    and configuration that we need to run our app.
  prefs: []
  type: TYPE_NORMAL
- en: Creating databases and migration files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, with the creation of the Laravel app and all the associated libraries being
    installed, we can work on the Laravel app to create our API. First, we create
    our database by creating some migration files. We need them to create the `chats`
    and `messages` tables. The `chats` table has the chat room data. And the `messages`
    table has the chat messages that are associated with a chat room. It will also
    have a reference to the user who sent the message.
  prefs: []
  type: TYPE_NORMAL
- en: We don't have to create a `users` table since that is created automatically
    when we create the Laravel app. Almost every app needs to hold user data so this
    is included automatically. With the Laravel scaffold, we can create users with
    a username, email, and password, and log in with the username and password for
    the user that we just created. Laravel also has the ability to send emails for
    user verification without having to add any code to do that.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create the migrations, we run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding commands will create the migration files for us with the date
    and time prepended to the filename of the migration files. All the migration files
    are in the `database/migrations` folder. So we can go into this folder and open
    the files. In the one with the `create_chats_table` as the filename, we add the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code will create the `chats` table. The `up()` method has the
    code that we want to run when we run our migration. The `down()` method has the
    method we run when we want to reverse the migration.
  prefs: []
  type: TYPE_NORMAL
- en: In the `up()` method, we call `Schema::create` to create the table. The `::`
    symbols indicate that the method is a static method. The first argument is the
    table name, and the second argument is a callback function that we add code to
    create the table with. The `$table` object has the `id()` method to create an
    `id` column. The `string()` method creates a `string` column with the column name
    in the argument. The `timestamp()` method lets us create a `timestamp` column
    with the given column name. The `useCurrent()` method lets us set the default
    value of the timestamp to the current date and time.
  prefs: []
  type: TYPE_NORMAL
- en: In the `down()` method, we have the `Schema::dropIfExists()` method to drop
    the table with the given name in the argument to drop the table if it exists.
  prefs: []
  type: TYPE_NORMAL
- en: A migration file must have a class that inherits from the `Migration` class
    for it to be used as a migration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Likewise, in the migration file with the `create_message_table` name in the
    file name, we write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The preceding file has the code to create the `messages` table. This table has
    more columns. We have the same `id` and `timestamp` columns as in the `chats`
    table, but we also have the `user_id` unsigned `integer` column to reference the
    ID of the user who posted the message and the `chat_id` unsigned `integer` column
    to reference an entry in the `chats` table to associate the message with the chat
    session that it is created in.
  prefs: []
  type: TYPE_NORMAL
- en: The `foreign()` method lets us specify what the `user_id` and `chat_id` columns
    are referencing in the users and `chats` tables respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring our database
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we can run our migration, we have to configure our database that we will
    use to store the data for our backend. To do that, we create the `.env` file in
    the project's `root` folder by copying the `.env.example` file and then renaming
    it `.env`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `.env` file has many settings that we will need to run our Laravel app.
    To configure which database we will use, we run the following command to let us
    connect to a SQLite database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The full configuration file is at [https://github.com/PacktPublishing/-Vue.js-3-By-Example/blob/master/Chapter08/backend/.env.example](https://github.com/PacktPublishing/-Vue.js-3-By-Example/blob/master/Chapter08/backend/.env.example).
    We just copy its contents into the `.env` file in the same folder to use the configuration.
  prefs: []
  type: TYPE_NORMAL
- en: We use SQLite for simplicity in this chapter so that we can focus on creating
    the chat app with Vue 3\. However, we should use a production-quality database
    that has better security and management capabilities if we are building a production
    app. The `DB_CONNECTION` environment variable has the database type we want to
    use, which is SQLite. In the `DB_DATABASE` setting, we specify the absolute path
    of our database file. Laravel will not create this file automatically for us,
    so we have to create it ourselves. To create the SQLite file, we can use the DB
    Browser for SQLite program. It supports Windows, macOS, and Linux so we can run
    this on all the popular platforms. You can download the program from [https://sqlitebrowser.org/dl/](https://sqlitebrowser.org/dl/).
    Once this is installed, just click on **New Database** at the top left and click
    on the **File** menu and click **Save** to save the database file.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring a connection to Redis
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In addition to using SQLite as the main database for our app, we also need
    to configure the connection to Redis so that we can use Laravel''s queuing feature
    to broadcast our data to the Redis server, which will then be picked up by the
    Laravel Echo Server so that the event will be sent to the Vue 3 frontend. The
    environment variables for the Redis configuration are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'And we add the Redis configuration with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The first group of environment variables configures where the queue directs
    the data to. The `BROADCAST_DRIVER` setting is set to `redis` so that we direct
    our event to Redis. `QUEUE_CONNECTION` also has to be set to `redis` for the same
    reason. `QUEUE_DRIVER` is set to `sync` so that the events will be sent to the
    queue immediately after they are broadcast.
  prefs: []
  type: TYPE_NORMAL
- en: Running the migration files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have created our migrations and configured which database to use,
    we run `php artisan migrate` to run the migrations. Running the migrations will
    add the tables to our SQLite database. After adding the tables, we can add the
    seed data so we will not have to recreate the data ourselves when we want to reset
    our database or when we have an empty database. To create the seed data, we add
    some code to the `database/seeders/DatabaseSeeder.php` file. In the file, we write
    the following code to add the files for our database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We have the `addUsers()` method to add a few users into the `users` table. We
    create a loop that calls `DB::table('users')->insert` to insert some entries into
    the `users` table. The `->` symbol is the same as the period in JavaScript. It
    lets us access object properties or methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `insert()` method, we pass in an associative array or dictionary with
    the keys and values that we want to insert:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The `addChats()` method lets us add the chat room entries. We only have to
    insert the name. In the `addMessages()` method, we insert the entries for the
    `messages` table. We get the user entry''s `id` value that we want to set as the
    value from an existing entry in the `users` table. Likewise, we do the same for
    `chat_id` by getting an entry from the `chats` table and use the `id` value for
    that entry and set that as the value of `chat_id`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Once we have written the seeder, we may want to regenerate Composer's autoloader
    to update the autoloader with the dependencies that we have. We can do that by
    running `composer dump-autoload`. This is handy in case references to any dependencies
    are outdated and we want to refresh the references so that they won't be outdated.
    Then we run `php artisan db:seed` to run the seeder to populate all the data into
    the tables.
  prefs: []
  type: TYPE_NORMAL
- en: To reset the data to a pristine state, we can run the migration and the seeder
    at the same time by running `php artisan migrate:refresh –seed`. We can also just
    empty the database and rerun all the migrations by running `php artisan migrate:refresh`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating our application logic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have got the database structure and the seed data down, we can
    move on to creating our app logic. We create some controllers so that we can receive
    requests in from the frontend. Laravel controllers should be in the `app/Http/Controllers`
    folder. We create one for receiving requests or manipulating the `chats` table
    and another for receiving requests to manipulate the `messages` table. Laravel
    comes with a command for creating controllers. First, we create the `ChatController.php`
    file by running the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Then we should get the `app/Http/Controllers/ChatController.php` file added
    to our project. The full code is at [https://github.com/PacktPublishing/-Vue.js-3-By-Example/blob/master/Chapter08/backend/app/Http/Controllers/ChatController.php](https://github.com/PacktPublishing/-Vue.js-3-By-Example/blob/master/Chapter08/backend/app/Http/Controllers/ChatController.php).
  prefs: []
  type: TYPE_NORMAL
- en: A Laravel controller has a class that inherits from the `Controller` class.
    Inside the class, we have the methods that will be mapped to URLs later so that
    we can run these methods and do what we want. Each method takes a request object
    with the request data, including the headers, URL parameters, and body.
  prefs: []
  type: TYPE_NORMAL
- en: The `get()` method finds a single `Chat` entry. `Chat` is the model class for
    the `chats` table. In Laravel, the convention is that the class name corresponds
    to the table name by transforming the table name by removing the *s* at the end
    and then converting the first letter to uppercase. Therefore, the `Chat` model
    class is used to manipulate the entries in the `chats` table. Laravel does the
    mapping automatically so we don't have to do anything ourselves. We just have
    to remember this convention, so we won't get confused by it. The `find()` method
    is a `static` method that we use to get a single entry by its ID.
  prefs: []
  type: TYPE_NORMAL
- en: In all controller functions, we can just return a string, an associative array,
    a response object, or the results returned from a `query()` method to return that
    as the response. Therefore, the return value of the `Chat::find` method will be
    returned as the response when we make a request and the `get` method is called.
  prefs: []
  type: TYPE_NORMAL
- en: The `getAll()` method is used to get all the entries from the `chats` table.
    The `all()` method is a static method that returns all entries.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `create()` method is used to create an entry from the request data. We
    call the `Validate::make` static method to create a validator for the request
    data. The first argument is `$request->all()`, which is a method that returns
    all the items in a request object. The second argument is an associative array
    with the key of the request body to validate. The value of it is a string with
    the validation rules. The required rule makes sure the name is filled. The string
    rule checks that value set as the value of the name key is a string. The `max:255`
    rule is the maximum number of characters we can have in the `name` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We check whether validation fails with the `$validator->fails()` method. `$validator`
    is the object that is returned by the `Validator::make` method. In the `if` block,
    we call `response()->json()` to return the error to the user with the 400 status
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Otherwise, we call `Chat::create` to create the `chats` table entry. We get
    the value of the `name` field from the request body with the `$request->get` method
    with the key that we want to get. Then we set that as the value of the `'name'`
    key in the associative array that we pass into the `create` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'We do something similar with the `update()` method, except that we call `Chat::find`
    to find the item by its `id` value. Then we assign the value of the `name` field
    from the request body to the `name` property of the returned chat object. Then
    we call `$chat->save()` to save the latest value. Then we return the response
    by calling `response()->json($chat)` to return the latest chat entry converted
    to JSON:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The `delete()` method is called when we make a *DELETE* request to the API
    to delete a chat room entry. We call `Chat::find` again to find the entry from
    the `chats` table with the given ID. Then we call `$chat->delete()` to delete
    the returned entry. Then we return an empty response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We have similar logic for `MessageController.php` to let us save chat messages.
    We have the `UserController.php` file with code to let us save user data when
    we register for a user account.
  prefs: []
  type: TYPE_NORMAL
- en: 'Important:'
  prefs: []
  type: TYPE_NORMAL
- en: These files can be found at [https://github.com/PacktPublishing/-Vue.js-3-By-Example/blob/master/Chapter08/backend/app/Http/Controllers/MessageController.php](https://github.com/PacktPublishing/-Vue.js-3-By-Example/blob/master/Chapter08/backend/app/Http/Controllers/MessageController.php)
    and [https://github.com/PacktPublishing/-Vue.js-3-By-Example/blob/master/Chapter08/backend/app/Http/Controllers/UserController.php](https://github.com/PacktPublishing/-Vue.js-3-By-Example/blob/master/Chapter08/backend/app/Http/Controllers/UserController.php)
    respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Exposing controller methods for endpoints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next, we have to map our controller methods to the URLs that we will make our
    requests to call. We do that by adding some code to the `routes/api.php` file.
    To do that, we replace what is in the file with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We expose the controller methods as POST and GET endpoints to the client by
    calling the `Route::post` and `Route::get` methods respectively.
  prefs: []
  type: TYPE_NORMAL
- en: The `jwt.verify` middleware is what we use to check the JSON web token before
    we run the `controller` method for the route. This way, the `controller()` method
    will only be run when the token is valid.
  prefs: []
  type: TYPE_NORMAL
- en: Then we have to create `AuthController` to let us do the JSON web token authentication.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Then in the `app/Http/Controllers/AuthController.php` file, we add methods for
    endpoints to let us get the current user's data, log in, and log out. The code
    for this file is at [https://github.com/PacktPublishing/-Vue.js-3-By-Example/blob/master/Chapter08/backend/app/Http/Controllers/AuthController.php](https://github.com/PacktPublishing/-Vue.js-3-By-Example/blob/master/Chapter08/backend/app/Http/Controllers/AuthController.php).
  prefs: []
  type: TYPE_NORMAL
- en: If you don't have the `app/Http/Middleware/JwtMiddleware.php` file, the full
    code for this file is at [https://github.com/PacktPublishing/-Vue.js-3-By-Example/blob/master/Chapter08/backend/app/Http/Middleware/JwtMiddleware.php](https://github.com/PacktPublishing/-Vue.js-3-By-Example/blob/master/Chapter08/backend/app/Http/Middleware/JwtMiddleware.php).
  prefs: []
  type: TYPE_NORMAL
- en: It lets us enable authentication with a JSON web token between the Vue client
    and this app.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up JWT authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we have to set up the JSON web token authentication with our Laravel app
    so that we can host our frontend separately from our backend. To do that, we use
    the `tymon/jwt-auth` library. To install it, we run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we run the following command to publish the package configuration files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command will add all the required configuration for us. We should
    now have `config/jwt.php` added to our app. Then we generate the secret key to
    sign the JSON web token by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `secret` key will be added to the `.env` file with the key `JWT_SECRET`.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring our authentication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next, we have to configure our authentication so that we can verify our JSON
    web token before we can successfully make a request to routes that requires authentication.
    In `config/auth.php`, we have the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In the `guards` section, we have an `api` key that has a value being an associative
    array with the driver key set to `'jwt'` and the provider set to `'users'` to
    let us authenticate users with the JSON web token issued by the `jwt-auth` library.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we add the code to enable CORS so that our Vue.js 3 app can communicate
    with it.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling cross-domain communication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To enable us to do cross-domain communication between the frontend and backend,
    we install the `fruitcake/laravel-cors` package. To do this, we run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in `app/Http/Kernel.php`, we should have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We register the `HandleCors` middleware that comes with the `laravel-cors`
    package, and register the `jwt.verify` middleware in the `$routeMiddleware` associative
    array by writing the following code in the `$routesMiddleware` associative array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This way, we can use the `jwt.verify` middleware to verify the token.
  prefs: []
  type: TYPE_NORMAL
- en: The full code is at [https://github.com/PacktPublishing/-Vue.js-3-By-Example/blob/master/Chapter08/backend/app/Http/Kernel.php](https://github.com/PacktPublishing/-Vue.js-3-By-Example/blob/master/Chapter08/backend/app/Http/Kernel.php).
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, we install the `predis` package so that we can talk to our Redis database
    more easily. To install the `predis` package, we run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in `config/database.php`, we write the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We configure our Redis database connection within the associative array we set
    for `'redis'` so that we can connect to Redis.
  prefs: []
  type: TYPE_NORMAL
- en: The full file is at [https://github.com/PacktPublishing/-Vue.js-3-By-Example/blob/master/Chapter08/backend/config/database.php](https://github.com/PacktPublishing/-Vue.js-3-By-Example/blob/master/Chapter08/backend/config/database.php).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have created the API for storing users' data and their chat messages,
    we'll move on to add real-time communication capabilities to the Laravel app so
    that users can save and get chat messages in real time.
  prefs: []
  type: TYPE_NORMAL
- en: Adding real-time communication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we are done with adding the routes, authentication, and database configuration
    and manipulation code, we are ready to add the code for letting us communicate
    between the frontend and backend in real time. First, we need to create an `event`
    class in our Laravel backend so that we can call the `event` function to broadcast
    the event as we did in `MessageController`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do that, we run the `php artisan make:event MessageSent` command to create
    the `MessageSent` event class. The class should now be in the `backend/app/Events/MessageSent.php`
    file. Once the file is created, we replace what is inside the file with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The `__constructor()` method is the constructor; we get the `$user` and `$message`
    objects and then assign them to the class variables with the same name. The `broadcastOn()`
    method returns the `Channel` object, which creates a channel that we can listen
    to in the frontend. The `broadCastAs()` method returns the event name that we
    listen to in the chat channel. We will use this in the frontend to listen to the
    broadcast events. An `event` class should implement the `ShouldBroadcast` interface
    so that events can be broadcast from it.
  prefs: []
  type: TYPE_NORMAL
- en: The full code of `MessageSent.php` is at [https://github.com/PacktPublishing/-Vue.js-3-By-Example/blob/master/Chapter08/backend/app/Events/MessageSent.php](https://github.com/PacktPublishing/-Vue.js-3-By-Example/blob/master/Chapter08/backend/app/Events/MessageSent.php).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `backend/routes/channels.php` file, we should have the following code
    so that all users can listen to the chat channel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The first argument is the name of the channel we are subscribing to. The callback
    is a function that returns `true` if the user can listen to the event and `false`
    otherwise. An optional parameter is the `user` object so that we can check whether
    the user can listen to a given event.
  prefs: []
  type: TYPE_NORMAL
- en: The full code of this file is at [https://github.com/PacktPublishing/-Vue.js-3-By-Example/blob/master/Chapter08/backend/routes/channels.php](https://github.com/PacktPublishing/-Vue.js-3-By-Example/blob/master/Chapter08/backend/routes/channels.php).
  prefs: []
  type: TYPE_NORMAL
- en: 'The communication flow is as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1 – Diagram of the chat app''s architecture'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_8.1_B14405.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.1 – Diagram of the chat app's architecture
  prefs: []
  type: TYPE_NORMAL
- en: The Vue 3 frontend makes an HTTP request to the Laravel app with the message
    we want to send. The Laravel app saves the message to the `messages` table with
    the ID of the chat session and the user. It also broadcasts an event via the queue
    to the Redis server. Then the Laravel Echo Server watches Redis to see whether
    there is anything saved to the Redis database. If there is anything new saved,
    then the Laravel Echo Server pushes that to the Vue 3 frontend. The Vue 3 frontend
    picks that up by listening to the Laravel Echo Server for the events with the
    Laravel Echo client and the Socket.IO client.
  prefs: []
  type: TYPE_NORMAL
- en: Communication with Socket.IO
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To make our backend app communicate with the frontend via Socket.IO, we need
    the Laravel Echo Server. To do this, we first need to install the Laravel Echo
    Server `npm` package globally. We install it by running `npm install –g laravel-echo-server`.
    Then we will run this package to create the configuration file for setting up
    the communication.
  prefs: []
  type: TYPE_NORMAL
- en: To do this, we create a new folder and then run `laravel-echo-server init` to
    run the command-line wizard to create the Laravel Echo Server configuration file
    in the folder. At this point, we can just answer all the questions that are asked
    with the default settings. This is because we are going to edit the configuration
    file that it creates once this wizard is done.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the wizard is done, we should see the `laraval-echo-server.json` file
    in the folder. Now we open it and replace whatever is in there with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we have the JSON code for the configuration so that the
    Laravel Echo Server can listen to the items that are saved in Redis and then send
    whatever is in the Redis database to the frontend via the Socket.IO client. The
    `devMode` property is set to `true` so that we can see all the events that are
    sent. The host has the host IP address of the Laravel Echo Server. The `port`
    property is set to `6001` so this server will listen to port 6001\. Another important
    part of this file is the `apiOriginAllow` property. It is set to an object with
    `allowCors` set to `true` so that we can do cross-domain communication with our
    frontend.
  prefs: []
  type: TYPE_NORMAL
- en: The `allowOrigin` property lets us set the domains that are allowed to listen
    to the emitted events. The `allowMethods` property has the HTTP methods that are
    allowed to be received from the frontend. The `allowHeaders` property has the
    list of HTTP request headers that are allowed to be sent from the frontend to
    the Laravel Echo Server.
  prefs: []
  type: TYPE_NORMAL
- en: '`authHost` has the base URL of the Laravel app so that it can listen to the
    events broadcast by the Laravel app. `authEndpoint` has the authentication endpoint
    that is used to check whether the user is authenticated for listening to events
    that require authentication.'
  prefs: []
  type: TYPE_NORMAL
- en: Another important part of this configuration file is the database configuration
    properties. The database property is set to `"redis"` so that it will listen to
    the Redis server for saved items. The `databaseConfig` property has the settings
    to let us connect to the Redis server. The `"redis"` property is set to an object
    with the `"port"` property set to the `port` that the Redis server listens to.
    The default port for Redis is `6379`. The `host` property is the location of the
    Redis server. The `publishPresence` property is set to `true` so that Redis publishes
    items that are saved in its database.
  prefs: []
  type: TYPE_NORMAL
- en: The full configuration is at [https://github.com/PacktPublishing/-Vue.js-3-By-Example/blob/master/Chapter08/laravel-echo-server/laravel-echo-server.json](https://github.com/PacktPublishing/-Vue.js-3-By-Example/blob/master/Chapter08/laravel-echo-server/laravel-echo-server.json).
  prefs: []
  type: TYPE_NORMAL
- en: 'The latest version of Redis is only available for Linux or macOS. To install
    Redis on Ubuntu Linux, run the following command to install the Redis server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are running Windows 10, you can use the Window Subsystem for Linux to
    install a copy of Ubuntu Linux so you can run the latest version of Redis. To
    install Ubuntu on Windows 10, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Type in `Turn Windows Features on and Off` in the **Start** menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then we scroll to the bottom and click on **Window Subsystem for Linux** to
    install it. It will ask you to restart, and you should do that before continuing.
  prefs: []
  type: TYPE_NORMAL
- en: Once your computer has restarted, go to the **Windows Store** and search for
    **Ubuntu**, then you can click it and click **Get**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After it is installed, then you can type in `Ubuntu` in the **Start** menu and
    start it. Now just follow the instructions to finish the installation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then you can run the preceding two commands to install Redis.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once Redis is installed, we run the following command to run the Redis server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Now the backend part of our project is done. Now we run `php artisan serve`
    and `php artisan queue:listen` to run the Laravel app and the queue worker. We
    also have to run the Laravel Echo Server by running `laravel-echo-server start`
    to start the Laravel Echo Server.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run into any issues, then you may have to clear the cache to make sure
    that the latest code is actually running. To do that, you can run the following
    commands to clear all the caches:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: If the cache is cleared and the code is still not working, then you can go back
    to check the code.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have added real-time communication to our Laravel app, we are ready
    to move on to creating the frontend to let users register an account, log in,
    and start chatting in a chat room.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the frontend to let users chat
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have the backend code all finished and running, we can work on the
    frontend. The frontend is not very different from what we had in the earlier chapters.
    We use the Vue CLI to create our project in the `frontend` folder of the `vue-example-ch8-chat-app`
    folder and then we can start writing our code.
  prefs: []
  type: TYPE_NORMAL
- en: In the `vue-example-ch8-chat-app/frontend` folder, we run `vue create`, then
    we choose **select version**, then we select the **Vue 3** option with **Vue Router**
    option enabled. Once the Vue CLI wizard finishes running, we can start building
    our frontend.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the Vue dependencies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In addition to the Vue dependencies, we also need to install the Axios HTTP
    client, the Socket.IO client, and the Laravel Echo client package to make HTTP
    requests and listen to events emitted from the server side via the Laravel Echo
    Server respectively. To install those, we run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'First, in the `src` folder, we create the `constants.js` file and add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We add the `APIURL` constant that we will use when we make requests to our
    API endpoints. In `src/main.js`, we replace the code we have with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: We have two things that are new in this file. We have the Axios request and
    response interceptors so that we can apply the same settings to all requests without
    repeating the same code when we make each request. The `axios.interceptors.request.use()`
    method takes a callback that lets us return a new `config` object according to
    our needs.
  prefs: []
  type: TYPE_NORMAL
- en: If the request URL doesn't include `login` or `register`, then we need to add
    the token to the `Authorization` header. This is what we did in the callback we
    passed into the `use()` method. We add the token to the request configuration
    for the endpoints that need them. The second callback is an error handler, and
    we just return a rejected promise so we can handle them when we make the request.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, we have the `axios.interceptor.response.use()` method to check for
    each response with the callback in the first argument. We check whether the response
    body has the `status` property set to the `"Token is expired"` string so we can
    redirect to the login page when we get this message and return the response. Otherwise,
    we just return the response as is. The error handler in the second argument is
    the same with the request interceptor.
  prefs: []
  type: TYPE_NORMAL
- en: Creating our components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next, we create our components. We start with the form to let us set or edit
    the chat room name. To do that, we go into the `src/components` folder and create
    the `ChatroomForm.vue` file. Then, in the file, we write the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This component takes the `edit` prop, which has the type boolean and the `id`
    prop that has the type string. It has one reactive property, which is the `form`
    property. It is used to bind the input value to the reactive property. We have
    the `submit()` method that checks the name to see whether it is filled. If it
    is, then we go ahead and submit it. If the `edit` prop is true, then we make a
    PUT request to update an existing entry in the `chats` table with the given ID.
    Otherwise, we create a new entry in the same table with the given name value.
    Once that is done, we redirect to the home page, which has the list of chat rooms.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `created` hook, we check whether the `edit` reactive property is true.
    If it is, then we get the entry in the `chats` table with the given ID and set
    it as the value of the `form` reactive property so that we can see the value of
    the `form.name` property in the input box:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, in the `src/components` folder, we create `NavBar.vue` to create a component
    to render a navigation bar. Inside the file, we write the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: We have a `router-link` component that goes to the **Chatrooms** page. This
    is done by setting the `to` prop to the `/` route. We also have a link to call
    the `logout()` method when we click it. The `logout()` method makes a POST request
    to the `/api/auth/logOut` endpoint to invalidate the JSON web token. Then we call
    the `localStorage.clear()` method to clear local storage. Then we call `this.$router.push`
    to redirect to the login page.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the styles section, we have some styles for the `ul` and `li` elements so
    the `li` display horizontally with some margins between them. We also have the
    `list-style-type` property set to `none` so that we remove the bullets from the
    list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `src/views` folder, we have the components for the pages that we map
    to a URL with Vue Router so that we can access these components from the browser.
    First, we create the `AddChatroomForm.vue` component file in the `src/views` folder
    and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: We just register the `NavBar` and the `ChatroomForm` component in the `components`
    property and then add them to the template.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we create the `ChatRoom.vue` component to display our chat messages and
    add the code to listen to the `laravel_database_chat` channel''s `MessageSent`
    event that we emit from the Laravel app via the Redis database and the Laravel
    Echo Server in this file. In this file, we write the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we add the methods to the same file to get and send the chat messages
    by writing the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The `getChatMessages` method gets the chat messages for the chat room from the
    API and the `sendChatMessage` method sends a message to the chatroom by submitting
    the chat message via an HTTP request to the API. Then, the API endpoint would
    send a message to the queue through the Laravel Echo Server back to the Socket.IO
    chat client used in this app. We call `addChatListener` to listen to the `laravel_database_chat`
    event from the server, which calls `getChatMessages` to get the latest messages.
  prefs: []
  type: TYPE_NORMAL
- en: 'The component template just uses the `v-for` directive to render each entry
    of the `chatMessages` reactive property and render them. The `form` element in
    the following code is used to let us enter a message and then submit it to Laravel
    by making an HTTP request. The endpoint saves the message to the `messages` table
    and also emits an event that we listen to, which is sent via the Redis database
    and the Laravel Echo Server. The frontend only knows about the Laravel Echo Server
    from the real-time communication point of view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: In the `component` object, we have the `beforeMount` hook to call the `getChatMessage`
    method to get chat messages. The `addChatListener()` method creates an event listener
    with the Socket.IO client to let us listen to events emitted from the Laravel
    Echo Server. In the `getChatMessage()` method, we call the `this.$nextTick()`
    method with a callback so that we always scroll to the bottom of the `div` tag
    that holds the messages once we get the messages. We have run that code in the
    `$nextTick` callback because we need to make sure the scrolling code runs after
    all the messages are rendered.
  prefs: []
  type: TYPE_NORMAL
- en: The `this.$nextTick()` method lets us wait for the component to be re-rendered
    after reactive properties are updated before running the code in the callback.
  prefs: []
  type: TYPE_NORMAL
- en: In the `addChatListener()` method, we subscribe to the `laravel_database_chat`
    channel, which is the same as the chat channel we defined in the Laravel app.
    We can make sure that we subscribe to the right channel by watching the output
    of the Laravel Echo Server. The `.MessageSent` event is the same one that we defined
    in the backend app. The dot before the event name is required so that it listens
    to the right event in the right namespace. In the callback that we pass in to
    listen, we call `this.getChatMessages()` to get the latest messages.
  prefs: []
  type: TYPE_NORMAL
- en: 'The container for the chat messages is set to the height 300px so that it won''t
    be too tall when we have too many messages. It also lets us scroll to the bottom
    when we have enough messages to overflow the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, in the `src/views` folder, we create the `Chatrooms.vue` component file
    by writing the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: We render a table with the list of chat rooms that we can go to, edit the name
    of, or delete. The method just gets the chat room data and goes to the routes
    for editing the chatroom with the given ID, adding the chat room, redirecting
    to the chat room page with the given ID, and deleting the chat room respectively.
    When we delete a chat room, we get the latest entries again with the `getChatRooms()`
    method so that we can get the latest data.
  prefs: []
  type: TYPE_NORMAL
- en: 'We get the chat room list in the `beforeMount` hook so we see the table entries
    when the page loads. Next, in the same folder, we create the `EditChatroomForm.vue`
    file and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: It has the same content as the `AddChatroomForm.vue` file but with the `edit`
    prop on `ChatroomForm` set to `true` and the `id` prop set to the `id` URL parameter
    from the URL that we get from Vue Router.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the login page
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next, we create the login page by creating `src/views/Login.vue` and adding
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The template just has a login form that takes the email and password to let
    us log in. When we submit the form, the `login()` method is called. It first checks
    whether all the fields are filled in properly, then it makes an HTTP request to
    the `/api/auth/login` route with the credentials to see whether we can log in.
  prefs: []
  type: TYPE_NORMAL
- en: The form also has a `Register.vue` file to go to the **Register** page so that
    we can register for an account and join the chat rooms.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last page that we have to create is a page for housing the registration
    form. To create it, we write the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The form has the **Name**, **Email**, **Password**, and **Confirm Password**
    fields that are all required to register an account. When we submit the form,
    we call the `register()` method. We do the checks for the fields to see whether
    they're filled out properly. The `test()` method is called on the `email` regular
    expression to check for a valid email address. If it is valid, the `test()` method
    returns `true`. Otherwise, it returns `false`. We also check whether the password
    is the same as the `confirmPassword` variable. If everything is valid, then we
    make a POST request to register for a user account.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `src/App.vue`, we replace what is there with the following code to add the
    `router-view` component so that we can see the route components from the `src/views`
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in the `src/router/index.js` file, we replace what is there with the
    following code to register all the routes and also create the `Socket.io` event
    to listen with the Laravel Echo library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The Laravel Echo client is used with the Socket.IO client so that we can listen
    to events broadcast from the Laravel Echo Server. The `broadcaster` property is
    set to `'socket.io'` so that we can listen to the events from the Laravel Echo
    Server. The `host` property is set to the URL of the Laravel Echo Server.
  prefs: []
  type: TYPE_NORMAL
- en: Also, we have the `beforeEnter` navigation guard that we have seen in previous
    chapters for when we need to restrict a route to be available only after authentication
    is successful. We just check whether the token exists. If it exists, we call `next`
    to proceed to the next route. Otherwise, we redirect to the login page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can run the frontend by running `npm run serve` as we do in all the
    other projects. Now we should see something like the following screenshots. The
    following screenshot has the **Chatroom** user interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2 – Screenshot of the Chatroom'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_8.2_B14405.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.2 – Screenshot of the Chatroom
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot is the Laravel Echo Server working. We should see
    the name of the event that is broadcast and the channel that it is sent through:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.3 – The output from Redis when chat events are sent to the frontend'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_8.3_B14405.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.3 – The output from Redis when chat events are sent to the frontend
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot is the log of the event of the queue:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.4 – Output of Laravel events'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_8.4_B14405.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.4 – Output of Laravel events
  prefs: []
  type: TYPE_NORMAL
- en: We started the queue earlier by running `php artisan queue:listen` in the `backend`
    folder, which is the folder with the Laravel project.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the chat app's frontend working, we have created a simple chat
    system with Laravel and Vue.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at how to build a chat app with Laravel and Vue.
    We built our backend with Laravel and we added controllers to receive requests.
    And we used the queue system built into Laravel to send data to the frontend.
    We also added JSON web token authentication into our Laravel app.
  prefs: []
  type: TYPE_NORMAL
- en: On the frontend, we used the Socket.IO client to listen to events sent from
    the Laravel Echo Server, which gets its data from Laravel via Redis.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have gone through Vue 3 projects with various levels of difficulty,
    we can adapt what we learned here to real-life situations. Real-life Vue apps
    will almost always make HTTP requests to a server. The Axios library makes this
    easy. Some apps also communicate in real time with the server like the chat app
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The only difference is that in real-life apps, there would be checks to see
    whether the user is authenticated and authorized to send the data to the server.
  prefs: []
  type: TYPE_NORMAL
