- en: Chapter 2. Under the Hood – Tutorial Explained
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we built a simple single-page application from scratch.
    We used Vue.js to implement the application's functionality, Bootstrap to make
    it beautiful, and Firebase to manage the backend part of the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will get to know all these technologies in depth and see
    how and why they can work nicely together. We will mostly discuss Vue.js since
    this will be our number one framework to build our application. Then, we will
    touch on Bootstrap and Firebase to get a basic understanding of how powerful these
    technologies are. Having said that, in this chapter we will:'
  prefs: []
  type: TYPE_NORMAL
- en: Discuss the Vue.js framework, reactivity, and data binding. Not only will we
    cover Vue.js' basics, but we will also dig into topics such as directives, components,
    routing, and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discuss the Bootstrap framework. We will see what is possible to achieve with
    it, discuss how it can be useful to lay out an application, and discuss how its
    components can enrich your application with useful self-contained functionality.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discuss the Firebase platform. We will see what it is, what functionalities
    it provides, and how to use its API to bring those functionalities to the application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check how all the mentioned technologies can be combined together in order to
    achieve simplicity in the development of complex things.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vue.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The official Vue.js website suggests that Vue is a progressive JavaScript framework:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Vue.js](../images/00020.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Screenshot from the official Vue.js website
  prefs: []
  type: TYPE_NORMAL
- en: What does that mean? In a very simplified way, I can describe Vue.js as a JavaScript
    framework that brings reactivity to web applications.
  prefs: []
  type: TYPE_NORMAL
- en: It's undeniable that each and every application has some data and some interface.
    Somehow, the interface is responsible for displaying data. Data might or might
    not change during runtime. The interface usually has to react somehow to those
    changes. The interface might or might not have some interactive elements that
    might or might not be used by the application's users. Data usually has to react
    to those interactions, and consequently, other interface elements have to react
    to the changes that have been done to the data. All of this sounds complex. Part
    of this complex architecture can be implemented on the backend side, closer to
    where data resides; the other part of it might be implemented on the frontend
    side, closer to the interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Vue.js allows us to simply bind data to the interface and relax. All the reactions
    that must happen between data and the interface will happen on their own. Let''s
    look at a very simple example where we will bind a message to the page title.
    Start by defining a simple HTML structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s initialize a **Vue.js** instance on this page and bind its data
    to the `<h1>` element. For this simple example, we will use a standalone `Vue.js`
    file. Download it from the Vue.js official page at [https://vuejs.org/js/vue.js](https://vuejs.org/js/vue.js).
    Import it within the `<script>` tag. Let''s now initialize a **Vue** instance.
    The minimum that a Vue.js instance needs is the **element** to be attached to
    and the `data` object. We want to attach our Vue instance to the main `<div>`
    tag with the `app` ID. Let''s also create a data object containing an entry for
    the name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create our Vue.js instance with this data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now bind `data` to our HTML element. We will do this using double curly
    brackets (`{{}}`). Once the element has been attached to the `Vue` instance, everything
    that is inside of it becomes special—even the curly brackets. Everything that
    you put inside the double curly brackets will be interpreted and evaluated. So,
    if you put, for example, `2 + 2` inside the curly brackets, `4` will be rendered
    on the page. Just try it. Any expression, any statement will be compiled and calculated.
    Don''t be too excited though; don''t start writing chunks of JavaScript code inside
    those brackets. Let''s leave the computation to the script logic that is written
    where script resides. Use the brackets to access the data that you pass to your
    `Vue` instance. So, in our case, if you insert `{{name}}` anywhere inside your
    HTML markup, you will see the name that we passed to the `Vue` instance within
    the data object. Let''s, for example, replace the word `reader` inside the `<h1>`
    element by `{{name}}`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: If you refresh the page, you will see that the name we passed to the Vue instance
    is rendered. Try to change the `data.name` attribute in the developer tools console.
    You will see the changes immediately propagated. What we see here is a **one-way
    data binding**—the changes that happen to data are reactively propagated to the
    element to which the data is bound. Vue.js also supports **two-way data binding**;
    so, the changes that happen to the element on the page are also propagated to
    the data to which the element is bound.
  prefs: []
  type: TYPE_NORMAL
- en: 'To achieve this, just bind the given piece of data to the element using the
    `v-model` attribute. Let''s, for example, add a text input to the page and bind
    it to the data attribute `name`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, once you start typing in the text input, the change is immediately propagated
    to any other element bound to this piece of data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Vue.js](../images/00021.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The data changes are reactively propagated through all the bound elements
  prefs: []
  type: TYPE_NORMAL
- en: 'The complete code for the HTML markup and JavaScript code looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, there is nothing difficult at all. All you need is to pass `data`
    to the `Vue` instance and bind it to the elements of your page. The Vue framework
    does everything else. In the upcoming chapters, we will find out what else is
    possible using Vue.js and how to Bootstrap a Vue.js project.
  prefs: []
  type: TYPE_NORMAL
- en: Vue project – getting started
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So, now that we know what Vue.js is for and what its main focus is, we would
    like to get our hands dirty and start a Vue.js project and explore all the Vue.js
    features with it. There are plenty of ways of including Vue into the project.
    Let's explore all of them.
  prefs: []
  type: TYPE_NORMAL
- en: Including directly in script
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can use Vue.js by just downloading it and including it within the `<script>`
    tag. Actually, we've done it in the previous section. So, if you have a project
    already running and want to use some Vue.js features, you can simply include the
    `vue.js` file and use it.
  prefs: []
  type: TYPE_NORMAL
- en: CDN
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you don''t want to bother downloading and managing Vue versions yourself,
    you can simply use the CDN version. Just include [https://unpkg.com/vue](https://unpkg.com/vue)
    script in your project and you are good to go! It will always be in sync with
    the latest Vue version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: NPM
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you are all into the Node.js development, you can simply add an `npm` dependency
    to your `package.json` file. Just run `npm install` on your project''s root:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Vue-cli
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Vue provides a nice and clean command-line interface that is perfect for bootstrapping
    new projects. First of all, you must install **vue-cli**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Now, you can start a fresh new project using the Vue command-line interface.
    Check out the *vue-cli* repository for the detailed documentation at [https://github.com/vuejs/vue-cli](https://github.com/vuejs/vue-cli).
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, it is possible to setup a project using different templates—starting
    from a simple single HTML page project and going to a complex webpack project
    setup. The command that should be used for scaffolding a Vue project is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The following templates are available:'
  prefs: []
  type: TYPE_NORMAL
- en: '**webpack**: This is a full-featured webpack setup with `vue-loader`. It supports
    hot reload, linting, testing, all kind of pre-processors, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**webpack-simple**: This is a simple webpack setup that is useful for quick
    prototyping.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**browserify**: This is a full-featured browserify setup with vueify that also
    supports hot reload, linting, and unit testing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**browserify-simple**: This is a simple browserify setup with vueify that can
    be used for quick prototyping.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**simple**: This generates a simple HTML page that includes Vue.js. It is perfect
    for quick feature exploration.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is also possible to create custom templates. Check out the documentation
    at [https://github.com/vuejs/vue-cli#custom-templates](https://github.com/vuejs/vue-cli#custom-templates)
    and try it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this book, we will use the `webpack` template. We will include some loaders,
    and we will use linters, unit, and end-to-end testing techniques. To bootstrap
    a project using the `webpack` template, simply run the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Now that we know how to scaffold a project with *vue-cli*, let's check what
    Vue offers besides what we already explored in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: Vue directives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Vue directives are no more than just **attributes** attached to your HTML elements.
    These directives provide some extra functionality to your template.
  prefs: []
  type: TYPE_NORMAL
- en: All these directives start with the prefix `v-`. Why? Because it's *Vue*! You
    have already used some of them in the previous section. Now, we will see what
    directives exist and what you can do with them.
  prefs: []
  type: TYPE_NORMAL
- en: Conditional rendering
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Open our Hello page and remove user''s input. Something not really beautiful
    is happening:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Conditional rendering](../images/00022.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '"Hello,!"'
  prefs: []
  type: TYPE_NORMAL
- en: It would be interesting to render the **Hello,** name message conditionally,
    depending on the user input. If there is a name, render it; if there's no name,
    don't render.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, only render the **Hello,** name message if there''s a name. Directives
    `v-show` and `v-if` are used exactly for the conditional render. Open the `index.html`
    file of this example and let''s change it. Wrap the `Hello, <strong>{{name}}</strong>!`part
    into `span` and add a `v-show` attribute with the `name` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if you refresh the page and remove the input completely, the message will
    only say **Let''s learn Vue.js**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Conditional rendering](../images/00023.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The v-show attribute allows conditional rendering
  prefs: []
  type: TYPE_NORMAL
- en: 'Try to replace the `v-show` directive with the `v-if` directive. The end result
    will be quite the same. Why do both exist then? Check out the developer tools''
    elements tab and try to add or remove the text in the input. You will see that
    in the case of `v-show`, the conditional span will just gain a `display:none`
    property if the condition does not verify. In the case of `v-if`, the element
    disappears completely:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Conditional rendering](../images/00024.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Using the v-show attribute manipulates the display CSS property, whereas using
    the v-if attribute adds/removes an element completely
  prefs: []
  type: TYPE_NORMAL
- en: When do we use either attribute? If you have a lot of elements that should be
    visible depending on some data (this data is really dynamic, so it will happen
    a lot during the runtime), I would advise using the `v-show` attribute, because
    adding or removing elements in DOM is a rather expensive operation that might
    affect the application's performance and even the DOM itself. On the other hand,
    if the elements should be conditionally rendered only once, let's say, at the
    application startup, use the `v-if` attribute. If some elements should not appear,
    they will just not be rendered. Thus, the number of elements on the page will
    be reduced. Consequently, the computational cost of the application will be also
    reduced, as, now, it has fewer elements to go through and compute.
  prefs: []
  type: TYPE_NORMAL
- en: Text versus HTML
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I am sure you know pretty well from the previous chapter how to bind some data
    using the mustache syntax `{{}}`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since this is a technical book about programming, we have to have a cat here
    ![Text versus HTML](../images/00025.jpeg)! A cat is pretty easy to render. Its
    Unicode is `U+1F638`; thus, we just have to add the `&#x1f638;` code to our HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'And, surely, we will have a cat:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Text versus HTML](../images/00026.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Emoji cat saying hello to us
  prefs: []
  type: TYPE_NORMAL
- en: It's nice, but if we want to replace the cat with a dog, we will have to use
    Google to look for another Unicode representing a dog and replace it. If at some
    point we want to replace it with a unicorn, we will have to run the same procedure.
    Moreover, just by looking at our code, we will not be able to say what we are
    actually rendering unless we know all emoji codes by `&hearts;`. It might be a
    good idea to map the names of the emojis to their codes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add a map of some of them. Open your HTML file and add the following
    lines of code to the `<script>` area:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can bind the values of this map to your HTML elements. Let''s try
    to do it using the mustache annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Refresh the page. The result is not exactly the same as we expected, is it?
  prefs: []
  type: TYPE_NORMAL
- en: '![Text versus HTML](../images/00027.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The code is rendered instead of the actual cat emoji
  prefs: []
  type: TYPE_NORMAL
- en: 'This is happening because mustache interpolation actually interpolates text.
    Using mustache interpolation is the same as using the `v-text` directive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'What we actually want to render here is not the text; we want the value of
    the Unicode for the emoji being rendered as HTML! This is also possible with Vue.js.
    Just replace a `v-text` directive with the `v-html` directive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Now, we will get our cat back, and we know exactly what we are rendering when
    we are looking at the code.
  prefs: []
  type: TYPE_NORMAL
- en: So, remember to use the `v-text` directive or mustache annotation for text interpolation
    and the `v-html` directive for interpolating pure HTML.
  prefs: []
  type: TYPE_NORMAL
- en: Loops
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the previous section, we put a cat on our page. In this section, I would
    like to have a whole zoo! Imagine that our zoo has a cat ![Loops](../images/00028.jpeg),
    a dog ![Loops](../images/00029.jpeg) , a monkey ![Loops](../images/00030.jpeg)
    , and, of course, a unicorn ![Loops](../images/00031.jpeg).We would like to display
    our zoo in an ordered list. Of course, you can write a simple markup that will
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'However, this makes your code unreadable, and if you want to add more animals
    to your zoo or remove one of them, you would have to know all these codes by heart.
    In the previous section, we added a map for emoji animals Unicode. Let''s use
    it in our markup. You already learned that we must use a `v-html` directive so
    that the codes are interpolated as HTML. Hence, our markup will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'It looks better, but still there''s something we could improve. Imagine if
    you want to render all the animals from the emoji world! There are plenty of them.
    For each animal, you will have to repeat the code of the list item. Every time
    you would like to reorder the list, remove some elements, or add new ones, you
    will have to deal with this markup. Wouldn''t it be nice if we just had an array
    of animals that we want to render and then somehow iterate over it and render
    what''s inside of it? Of course, it would! It is possible using the `v-for` directive.
    Create an array of animals using the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Export it in the `vue data` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can use this array in the `v-for` directive and replace multiple `<li>`
    elements by only one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The result will be quite nice:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Loops](../images/00032.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Emoji zoo rendered using the v-for directive
  prefs: []
  type: TYPE_NORMAL
- en: Binding data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We dealt a lot with rendering different data using Vue.js in the previous section;
    so now, you are already familiar with different ways of binding it. You know how
    to interpolate data as *text* and as *HTML*, and you know how to iterate over
    arrays of data.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve also seen that two-way data binding is achieved using the `v-model`
    directive. We used it to bind a name to the input element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The `v-model` directive can only be used with the `input`, `select`, and `textarea`
    elements. It also accepts some modifiers to be used with. Modifiers are special
    keywords that affect the input in some way. There are three modifiers that can
    be used with this directive:'
  prefs: []
  type: TYPE_NORMAL
- en: '`.lazy`: This will only update the data on a change event (try it with our
    input and you''ll see that changes in the input will only affect other parts where
    the name is used when the *Enter* button is pressed and not on each key press)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.number`: This will cast your input to number'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.trim`: This will trim the user''s input'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It is also possible to chain the modifiers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: So now, we know nearly everything about binding data to the elements. What if
    we want to bind some data to the elements' properties? Imagine, for example, the
    dynamic value for the image's source property or class property depending on some
    data value. How could we do that?
  prefs: []
  type: TYPE_NORMAL
- en: For this, Vue provides a `v-bind` directive. With this directive, you can bind
    whatever you want!
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, let''s show a sad picture when the name is not defined and a
    glad picture when the name is defined. For this, I''ve created two pictures, `glad.png`
    and `sad.png`, and put them into the `images` folder of my application. I will
    also export their paths into the data object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, I can create an image and bind its source using `v-bind:src`, and I''ll
    provide a JavaScript expression as the value. This expression will check the value
    of the name. If it''s defined, the `glad` image will be applied, and if not, the
    `sad` image will be applied instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The shortcut for the `v-bind` directive is `:`, so we can just write the following
    line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is how our page looks when the value of `name` is defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Binding data](../images/00033.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Happy face image appears when the name is defined
  prefs: []
  type: TYPE_NORMAL
- en: 'If you remove the name from the input field, the image will automatically change!
    Open the page and try to remove the text from the input field and add it again.
    Continue removing and adding, and you will see how fast the image is changed to
    the corresponding one. This is how the page looks when the name is undefined:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Binding data](../images/00034.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Once the input is cleaned, the image source is immediately changed
  prefs: []
  type: TYPE_NORMAL
- en: 'Basically, you can do exactly the same with any property binding, for example,
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: You can also bind properties to pass to the children components. We will see
    how to do it in the section about components.
  prefs: []
  type: TYPE_NORMAL
- en: Handling events
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Besides the direct form of data binding to the elements, we want to handle some
    events because this is what our users do on the page—trigger some events so that
    they happen. They click, they hover, they submit forms—and all these events must
    be handled somehow by us. Vue provides a very nice way of attaching listeners
    to events on any DOM element and provides methods that can handle those events.
    The good thing about these methods is that they have direct access to Vue data
    using the `this` keyword. In this way, we can use methods to manipulate data,
    and since this data is reactive, all the changes will be immediately propagated
    to the elements to which this data is bound.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to create a method, you just have to add a `methods` object to the
    export section of your Vue application. In order to attach this method to any
    event listener, use the `v-on` directive with the corresponding event after the
    colon. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The shortcut for this directive is `@`, so we could rewrite all these directives
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'It should sound familiar to you. Do you remember the tutorial that we followed
    in the [Chapter 1](part0016_split_000.html#F8901-449ee41b57ea4c048225480b41c8dbe3
    "Chapter 1. Please Introduce Yourself – Tutorial"), *Please Introduce Yourself
    – Tutorial*? Do you remember that we were listening on the `submit` method of
    the message, adding `form` and calling `addMessage`? Check it out. Our form with
    its `submit` directive looked like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, inside the `methods` section, we actually had the `addMessage` method
    defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Does it start to make more sense now?
  prefs: []
  type: TYPE_NORMAL
- en: 'Just to understand it better, let''s add some methods to our zoo page! Wouldn''t
    it be nice if you could compose your own zoo? Let''s add a multiple select element
    that will contain all possible options, and your zoo will be populated from something
    that you actually choose! So, let''s do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Add more animals to our `animalCodes` map
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add another array called `animalsForZoo`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use this new array in our ordered list that displays the zoo
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a multiple `select` box composed of the keys of the `animalCodes` map
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attach a `@change` listener to this select box that will call the `populateAnimalsForZoo`
    method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a `populateAnimalsForZoo` method that will populate the `animalsForZoo`
    array with the selected options from our multiple select element
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Doesn''t it sound easy? Of course, it does! Let''s get started. So, at first,
    add more animals to our `animalCodes` map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s also rethink our `animals` array and generate it out of our map. In
    this way, every time we need to add some new animal, we just add its key-value
    name-unicode to the mapping object instead of maintaining both object and array.
    So, our `animals` array will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need another empty array. Let''s call it `animalsForZoo`, and let''s
    populate our zoo from this new array. Since it is empty, our zoo will also be
    empty. However, we are about to create a method that will populate this array.
    So, creating an array is easy, and don''t forget to export it in a data object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Don''t forget to replace the usage of the `animals` array in our zoo display
    with the new `animalsForZoo` array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: I know that now you are worried that your zoo on the page is empty, but give
    us a couple of minutes and we will take care of that!
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, let''s create a multiple `select` element that will be populated
    based on the `animals` array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, finally, we will attach an event listener to our select box. Let''s attach
    a listener to the change event. Let''s tell it to call the `populateAnimalsForZoo`
    method. Our directive will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The whole `select` element will obtain a new attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Great! But there''s no such method as `populateAnimalsForZoo`. But there''s
    us! Let''s create it. This method will just iterate through the checked options
    of the animals selected as input and push them into the `animalsForZoo` array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Check out how the whole HTML and JavaScript code look after all these changes
    in the `chapter2/example1-vue-intro/index.html` file. This is how our testing
    page looks after the changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Handling events](../images/00035.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The zoo is being populated based on the user's choice
  prefs: []
  type: TYPE_NORMAL
- en: The page is messy, right? However, look how many things you have already learned
    just by using this page. And, admit it, it's a fun learning process! And we are
    not done with it yet.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you have learned how to add methods and event listeners, I will teach
    you how we could have done the exact same thing without this method and `v-bind:change`.
    Remove all the code we just added and just add `v-model` to our `select` element
    with the `animalsForZoo` value :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Now, everything we have just done inside the method is handled automatically
    by Vue! Isn't it great?
  prefs: []
  type: TYPE_NORMAL
- en: Vue components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We came to this chapter having a midsize HTML page in our hands that contains
    a lot of different parts. We could have thought of more things, for example, adding
    interactivity to each animal of our zoo, adding the possibility of feeding animals,
    or having some interesting facts about each animal showing up every time you hover
    over the animal's icon. At some point, let's face it, the HTML file along with
    its JavaScript will become unmaintainable.
  prefs: []
  type: TYPE_NORMAL
- en: Can you also see that our visualization layer (HTML) works along with our logical
    layer (JavaScript)? So, they kind of form blocks, items, bricks… For example,
    we have a piece of code that is responsible for the **Hello** name section. We
    have another block that contains our zoo. Each animal in the zoo is another item.
  prefs: []
  type: TYPE_NORMAL
- en: Call these things whatever you want, but they are undeniably separated pieces
    of structure and logic that, when brought together, form the whole puzzle. If
    you build a wall from a unique piece of material and decide to change some parts
    of the wall, it will not be the easiest task.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, imagine, you build this wall and incorporate some yellow stars, blue polygons,
    red squares, and so on into it. Then, you decide that your yellow stars should
    be black. You have to change all your stars. Then, you decide that your green
    ellipsis should be a smiling face instead. What now? Change all ellipses, but
    first you have to find all the places in the wall that contain those ellipses.
    This is your wall, try to find all ellipses in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Vue components](../images/00036.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The wall built as a whole piece with incorporated parts of different colors
    and forms
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, imagine that each piece actually resides on its individual brick. You
    can change them, add them, and remove them as much as you want. If you want to
    change the appearance of some of the wall elements, you just change this one brick
    and all the wall pieces containing this brick will change, because *all in all,
    it''s just another brick in the wall*. So, instead of having the wall full of
    incorporated strange pieces, you have four bricks, and you change them whenever
    you need to change the piece of wall that relies on that brick:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Vue components](../images/00037.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: If you need to change the appearance of an element in the wall, you just change
    the corresponding brick
  prefs: []
  type: TYPE_NORMAL
- en: 'The wall is composed of bricks. These bricks are our components. What if we
    could also have components built with HTML, CSS, and JavaScript and our application
    could be built of those components? Did I just say "what if"? There''s no "what
    if." We already have it. Vue.js supports component-based application structure.
    It''s really easy to create components with Vue.js. The only three things you
    have to do are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a component, and give it a template, data, methods, and whatever you
    need to give to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Register it in the Vue app under the `components` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use it within the application's template.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For example, let''s create a component that will simply render a header element
    saying **Hello**. Let''s call it `HelloComponent`. It will only contain the template
    string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can register this component inside our Vue application initialization
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, this component can actually be used inside the HTML section of the Vue
    application''s element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'So, the whole section will look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Someone might ask, "What''s so powerful in these components?" The amount of
    written code is actually the same as if I would have just written a piece of HTML
    that does the same. What''s the point? Yes, sure, but in this example, our component
    had just one template inside. A template composed of one line only. We could have
    a huge template in there, and we could have some methods in this component and
    also its own data! Let''s, for example, add an input for the name to this component
    and the name to its data object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'If you need to reuse this component, you can do it as many times as you want:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you will end up with three independent components on your page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Vue components](../images/00038.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Using components helps avoid repeated code
  prefs: []
  type: TYPE_NORMAL
- en: These components are very nice, but there's still a big amount of code written
    within the same JavaScript code block. We declare components all in one place,
    and if there are too many of them, the application will become unmanageable again.
    Besides that, this HTML code within the template string is also not the most maintainable
    thing ever.
  prefs: []
  type: TYPE_NORMAL
- en: Well, if you are thinking so, I have some good news for you. Each component
    can be stored in its own file with its own HTML, JavaScript, and CSS code. These
    are special files with the `.vue` extension. Inside each file, there's a `<script>`
    section for the JavaScript code, a `<style>` section for the CSS code, and a`<template>`
    section for the HTML code. Isn't it convenient? Such components are called single-file
    components. Have a look at the first chapter's code—there's a main component called
    `App.vue` and there's also the `MessageCard.vue` component created by us. Isn't
    it nice?
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to use single-file components in your application, you must scaffold
    this application using some modular bundler, for example, `webpack`. We already
    talked about `vue-cli` and how easy it is to bootstrap a Vue application using
    the `webpack` template. Let''s port the messy page with zoo to the `webpack` bundled
    application. Run the initialization and installation scripts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, open the `App.vue` file and let''s fill it up with our messy zoo application.
    The `<script>` section looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Note the highlighted areas. I've copied the images into the `static` folder.
    Another important thing is that the data inside the component should be used as
    a function that returns an object and not as an object itself. Since the data
    object will still be one single instance across multiple components, the whole
    data object with its properties must be assembled in a dedicated function.
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the script is completely the same.
  prefs: []
  type: TYPE_NORMAL
- en: The template area of the component is pretty much the same as the HTML structure
    from the previous example. Check out the code in the `chapter2/example3-components-started`
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s extract some of the functionality into the individual component. What
    do you think if we extract the zoo to its individual component? Create a `Zoo.vue`
    file in the `components` folder. Copy the template for the animals list to this
    component''s `<template>` area:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we should tell this component that it will receive `animals`, `name`,
    and `animalCodes` properties from the parent component that will call the following
    component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, open the main `App.vue` component, import the `Zoo` component, and export
    it in the `components` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can use this component inside the template! So, replace the whole `div`
    tagthat contains our zoo with just the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Check out the page! Everything works as it did earlier!
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Extract an animal to the individual component and call it inside the zoo within
    the `v-for` directive. Each animal has to have a small functionality that will
    display a small description when clicking its face (on `click`). I am pretty sure
    you will easily solve this exercise. If you need help, check out this chapter's
    code inside the `example4-components/zoo` directory.
  prefs: []
  type: TYPE_NORMAL
- en: Vue router
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Single Page Applications** (**SPA**) are great. They came to make our life
    easier. And it definitely is. With a bit of JavaScript code, you can achieve all
    the functionality that had to be done on the server side before, and the whole
    page should have been replaced just to display the result of that functionality.
    It is a golden era for web developers now. However, there is a problem that SPAs
    are trying to solve—*navigation*. History API and the `pushState` method ([https://developer.mozilla.org/en-US/docs/Web/API/History_API](https://developer.mozilla.org/en-US/docs/Web/API/History_API))
    are already solving it, but it has been a long process until it became an established
    technology.'
  prefs: []
  type: TYPE_NORMAL
- en: Our users are used to controlling their *where I am and where I want to be*
    using browsers' navigation buttons. If the whole functionality is located on the
    same page, how will these buttons help with the navigation? How do you use Google
    analytics to check which page (that, in fact, is the same) is being accessed more
    by your users? The whole concept is totally different. Of course, these kinds
    of applications are a lot faster because the number of requests is significantly
    reduced, and of course, our users are grateful for that, but they are not changing
    their web surfing habits just because we changed the way we implement things.
    They still want to go *back*. They expect that if they refresh the page, the page
    will open on exactly the same place where they were right before hitting the refresh
    button. They expect that they will understand where they are just by looking at
    the page's URL and checking what's behind the slash. For example, if it's `http://mySite/store`
    then it's a store; if it's `http://mySite/settings`, then most likely I'm somewhere
    where I can check my current settings and change them.
  prefs: []
  type: TYPE_NORMAL
- en: There are a lot of ways to achieve navigation without having to transform single-page
    applications into multiple-page applications. You can include an extra layer of
    logic on your application and change `window.location.href` every time a different
    URL is required—this will cause the page to refresh, which is not nice. You can
    also use HTML5 `history` API. It would not be the simplest thing to maintain,
    but it might work.
  prefs: []
  type: TYPE_NORMAL
- en: We all know that good developers are lazy, right? Being lazy means not solving
    problems that are already solved by someone else. This problem of navigation is
    being solved by many frameworks and libraries. Not only can you use some third-party
    libraries that help you deal with the routing in your application, but you can
    also use the mechanisms provided by the framework of your choice. Vue.js is one
    of the frameworks that offers a way of dealing with routing. You just map the
    URL path to your components and everything just works! Check out the official
    documentation of `vue-router` library at [https://router.vuejs.org/en/](https://router.vuejs.org/en/).
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to be able to use `vue-router`, you must install it for your project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Optionally, `vue-router` usage can be selected on the Vue project initialization
    with `vue init`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you can use Vue router in your application. Just tell Vue to use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create a simple routing example. We will have three components, one
    of which we consider as the `Home` component, meaning that it should be shown
    when someone navigates to the root route `/`. Let''s call the second one `Hello`
    component and the third one `Bye` component. Open the `example5-router-started`
    code files from [Chapter 2](part0024_split_000.html#MSDG2-449ee41b57ea4c048225480b41c8dbe3
    "Chapter 2. Under the Hood – Tutorial Explained"), *Under the Hood – Tutorial
    Explained*. You will find all the described components in the `components` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Vue router](../images/00039.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The structure of the example application where we are going to try Vue router
  prefs: []
  type: TYPE_NORMAL
- en: Now, we must create a `router` instance. The constructor receives the `options`
    object as a parameter. This object can contain different configurable values.
    The most important one is the array of `routes`. Each entry of this array should
    consist of an object that indicates the `path` of the route and its corresponding
    `component`.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will import all the needed components, and then, our `router` instance
    will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to understand better what the `mode:` `history` option is, check
    out the documentation page at [https://router.vuejs.org/en/essentials/history-mode.html](https://router.vuejs.org/en/essentials/history-mode.html)
    that explains it in a really nice manner. Now, we have to pass the router option
    to our Vue application. This option will point to our new `router` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the whole application knows that we use this router. One more important
    step: we need to include the router component into the main component''s template.
    For this, it is enough to just include the `<router-view>` tag in the `App.vue`
    component''s template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Check out in more detail the `router-view` component at [https://router.vuejs.org/en/api/router-view.html](https://router.vuejs.org/en/api/router-view.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Voilà! Run the application if you haven''t done so already:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the page at `http://localhost:8080` and check that it is displaying our
    home page component. Then, type `http://localhost:8080/hello` and `http://localhost:8080/bye`
    in the browser''s address bar. Check that the content of the page actually changes
    according to the URL path:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Vue router](../images/00040.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Basic routing with vue-router
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, you are already thinking about how to create a simple menu, pointing
    an anchor `<a>` element to your defined paths in the router. Don''t think too
    much. Just use a `<router-link>` component with the `to` attribute pointing to
    the path of your choice. For example, to display a simple navigational menu for
    our router example application, we could write something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, if you don''t want to write your paths all over again, you can
    reference your routes by name and use the `v-bind:to` directive or simply use
    `:to`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Check how the code looks in the `example6-router` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Open the page and check whether all the links actually work! Click on them several
    times and check whether you will actually go back if you click on the browser's
    go back button. Isn't it fantastic?
  prefs: []
  type: TYPE_NORMAL
- en: Vuex state management architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Do you remember our example with the `Zoo` and `animal` components? There was
    some data that had to be propagated from the main component to the child component
    of the child component. If this grandchild component had the possibility of somehow
    changing data, this change would have to be propagated from the child component
    to its parent component and so on until data reaches the main component. Don't
    think that you would do it simply with a `v-model` binding attribute. Vue has
    some restrictions regarding binding data to the children components via `props`.
    It is strictly one way. So, if the parent component changes the data, the child
    component's bindings will be affected, but it will never happen the other way
    around. Check out Vue's official documentation in regarding this at [https://vuejs.org/v2/guide/components.html#One-Way-Data-Flow](https://vuejs.org/v2/guide/components.html#One-Way-Data-Flow).
  prefs: []
  type: TYPE_NORMAL
- en: 'If you don''t believe me, let''s try it. Imagine that in our zoo page example,
    we would extract the introduction part to the separate component. I am talking
    about this part of our messy zoo page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Vuex state management architecture](../images/00041.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: What if we'd like to extract this part to the separate component?
  prefs: []
  type: TYPE_NORMAL
- en: 'It seems easy. We have to declare a component, let''s say `Introduction`, tell
    it that it will receive the `name` property, and just copy-paste HTML from `App.vue`
    to this new component. Inside `App.vue`, we will import this new component and
    export it inside the `components` object of the Vue instance. Of course, we will
    replace the HTML that we already copied to the new component with the `<introduction>`
    tag and bind the `name` property to it. Isn''t it easy? Our `Introduction.vue`
    file will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `App.vue` file will import, export, and call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Check out this code in the code bundle of the [Chapter 2](part0024_split_000.html#MSDG2-449ee41b57ea4c048225480b41c8dbe3
    "Chapter 2. Under the Hood – Tutorial Explained"), *Under the Hood – Tutorial
    Explained* in the `example7-events-started/zoo` folder. Run `npm install` and
    `npm run` inside this folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Check out the page. It looks like it did before. Try to change the name inside
    the input. First of all, it doesn''t change in other places where it should change,
    and second, our dev tools console is full of warnings and errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Vuex state management architecture](../images/00042.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The name is not updated where it should have been updated, and the console is
    full of errors
  prefs: []
  type: TYPE_NORMAL
- en: 'It seems the documentation is right: we can''t change the value of data passed
    as property to the child component. What can we do then? We can emit events and
    attach event listeners to the component, and change the data on the event. How
    do we do this? It''s simple. First of all, let''s call the property being passed
    by something that is not `name`, for example, `initialName`. Then, open the `Introduction`
    component and create a `data` function that will bind this component''s `name`
    object to `initialValueprops`. In this way, we are at least telling Vue that it
    is not our intention to try to change parent''s data from the child. So, `script`
    of the `Introduction.vue` component will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'We also have to change the way we bind name to the component inside `App.vue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if you check the page, you will at least see that Vue doesn''t complain
    anymore about something illegal that we try to do. However, still, if we try to
    change the name, the changes are not propagated to the parent, which is quite
    understandable; these changes only affect the data of the component itself. Now,
    we have to attach the `event` to the `input` element. This event will call a method
    that will finally emit the event to the parent component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the only thing we have to do is to bind the `nameChanged` event listener
    to the `<introduction>` component and call the method that will change the name
    of the `App.vue` data object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Check the page. Now, everything works as before! Check the code for this solution
    inside the `example7-events/zoo` code folder for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Well, it was not very difficult, but do we want to emit all these events every
    time we need to update the state? And what if we have components inside the components?
    And what if we have other components inside those components? Will it be the events
    handling hell? And if we have to change something, will we have to go to all those
    components? Argh! Wouldn't it be great to have the application's data in some
    kind of centralized storage that would provide a simple API for its management
    and then we could just call this storage's methods in order to retrieve and update
    the data? Well, this is exactly what Vuex is for! Vuex is a centralized state
    management inspired by Redux. Check out its official documentation at [http://vuex.vuejs.org/en/](http://vuex.vuejs.org/en/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, in a nutshell, the three most important parts of a Vuex store are state,
    getters, and mutations:'
  prefs: []
  type: TYPE_NORMAL
- en: '**State**: This is an initial state of the application, basically the data
    of the application'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Getters**: These are exactly what you think, functions that return data from
    the store'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mutations**: These are functions that can mutate data on the store'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A store can also have actions. These things are like wrappers for mutations
    with a bit more capacity. If you want to check what are they about, refer to the
    official documentation at [http://vuex.vuejs.org/en/mutations.html](http://vuex.vuejs.org/en/mutations.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add the Vuex store to our `Zoo` application to check how it works. First
    of all, we need to install `vuex`. Open the code for [Chapter 2](part0024_split_000.html#MSDG2-449ee41b57ea4c048225480b41c8dbe3
    "Chapter 2. Under the Hood – Tutorial Explained"), *Under the Hood – Tutorial
    Explained* from the `example8-store-started/zoo` folder and run `npm install`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create our store. Start by creating a folder named `store` with the
    `index.js` file inside. We will put all our store data inside this file. Before
    doing this, tell Vue that we will use Vuex:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can create a new Vuex instance. It should receive `state`, `getters`,
    and `mutations`. Let''s define them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Nice! Now, let''s add all the data that resides in our application to the state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if you inject the store on the Vue application initialization, all the
    components and their children will have access to the `this.$store` instance.
    Let''s inject it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we replace all the data with computed properties from the store in
    `App.vue` (except `animalsForZoo`, which is bound as a property for our zoo),
    the application will look quite the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: If you open the page, nothing has changed. However, our changing name interaction
    doesn't work again!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add `mutation` to change the name. Mutations are just methods that receive
    a state as first argument and anything you call them with as other parameters.
    So, let''s call our mutation `updateName` and pass `newName` to it as a second
    argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can use this mutation to access the `this.$store.mutation` property
    inside the component responsible for updating the name—`Introduction.vue`. We
    have to just change the `onInput` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'By the way, we can also remove the properties and pass the name directly from
    the store, just like we did in the `App.vue` component. Then, you can remove the
    `name` binding to the `introduction` component inside the `App.vue` component''s
    template. Now, you can replace the properties that are bound to the Zoo component
    by computed properties coming from the store. See how elegant the code becomes!
    For example, look at this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Doesn''t it look better than the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Check out the final code for this chapter in the `example8-store/zoo` code folder
    for [Chapter 2](part0024_split_000.html#MSDG2-449ee41b57ea4c048225480b41c8dbe3
    "Chapter 2. Under the Hood – Tutorial Explained"), *Under the Hood – Tutorial
    Explained*. Note that we have used a very simplified version. We have not even
    used any getters. For a more sophisticated use, we would create `getters` and
    `actions`, and they would have been located in their own `actions.js` and `getters.js`
    files. We would also use `mapGetters` and `mapActions` helpers. However, for basic
    understanding, what we have done is enough. Refer to the official documentation
    to find out more about Vuex store and how to use it.
  prefs: []
  type: TYPE_NORMAL
- en: Bootstrap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we know almost everything about Vue.js, let's talk about Bootstrap.
    Check out the official Bootstrap page at [https://v4-alpha.getbootstrap.com/](https://v4-alpha.getbootstrap.com/).
  prefs: []
  type: TYPE_NORMAL
- en: '![Bootstrap](../images/00043.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Bootstrap—framework for responsive projects
  prefs: []
  type: TYPE_NORMAL
- en: In a nutshell, Bootstrap gives you a broad set of classes that allow building
    nearly everything with any layout in an easy and effortless way.
  prefs: []
  type: TYPE_NORMAL
- en: 'Bootstrap provides with you four most important things:'
  prefs: []
  type: TYPE_NORMAL
- en: Easy layouts building at [https://v4-alpha.getbootstrap.com/layout/overview/](https://v4-alpha.getbootstrap.com/layout/overview/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Broad range of classes to style nearly any web element at [https://v4-alpha.getbootstrap.com/content/](https://v4-alpha.getbootstrap.com/content/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Self-contained components such as alerts, budges, modals, and so on at [https://v4-alpha.getbootstrap.com/components/](https://v4-alpha.getbootstrap.com/components/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some utilities for styling images, figures, for positioning, styling, and adding
    borders at [https://v4-alpha.getbootstrap.com/utilities/](https://v4-alpha.getbootstrap.com/utilities/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'How to install Bootstrap? It can be installed from the CDN:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: This is, actually, exactly what we have in the `PleaseIntroduceYourself` application
    from [Chapter 1](part0016_split_000.html#F8901-449ee41b57ea4c048225480b41c8dbe3
    "Chapter 1. Please Introduce Yourself – Tutorial"), *Please Introduce Yourself
    – Tutorial*, and in the messy zoo application from this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Bootstrap components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Bootstrap has a lot of components that can be used just out of the box.
  prefs: []
  type: TYPE_NORMAL
- en: I will not talk about all of them in this chapter, because we will have several
    opportunities to discover them during the course of the book. Let's look at some
    of them just to have an idea.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the alert components. As you might know, alerts are nice elements
    that appear on the page when you have successfully filled in some form. Alerts
    are also those angry red elements that tell you that you''ve done something wrong.
    What would you need to create an alert element on the page that would disappear
    after some time or give the possibility to the user to close it by clicking on
    the **x** button? You would probably create a `div`, add some class to it, and
    add a bit of JavaScript that would remove the element from the DOM tree after
    a grace period. Using Bootstrap, you just add `alert` class to your `div` and
    add another class such as `alert-warning` or `alert-info` to specify which kind
    of alert it is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'This code will produce nice alert boxes that look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Bootstrap components](../images/00044.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Bootstrap alerts—success, info, warning, and danger
  prefs: []
  type: TYPE_NORMAL
- en: 'Even a simple element like a button can be styled in hundreds of different
    ways using Bootstrap. Again, you can have buttons indicating success, danger zone,
    being informative, or just gray. There''s a possibility of grouping buttons and
    making them look like a link. The code is pretty easy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'This code will produce buttons as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Bootstrap components](../images/00045.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Bootstrap buttons
  prefs: []
  type: TYPE_NORMAL
- en: icial documentation page at [https://v4-alpha.getbootstrap.com/components/buttons/](https://v4-alpha.getbootstrap.com/components/buttons/).
  prefs: []
  type: TYPE_NORMAL
- en: 'One of my favorite things about Bootstrap is that you might have a trivial
    element, but then you add some of the Bootstrap''s classes to it and it suddenly
    becomes clean and nice. For example, create a simple page with some `<h1>` and
    `<p>` elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: It will look normal, simple. Now, add the `container` class to the parent `div`.
    Isn't it much nicer? Also, add the `jumbotron` class to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The page looked like this earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Bootstrap components](../images/00046.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The content inside the div before adding Bootstrap classes
  prefs: []
  type: TYPE_NORMAL
- en: 'All of a sudden, the same page looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Bootstrap components](../images/00047.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The content inside the div after adding Bootstra
  prefs: []
  type: TYPE_NORMAL
- en: Actually, if you check our `PleaseIntroduceYourself` example from [Chapter 1](part0016_split_000.html#F8901-449ee41b57ea4c048225480b41c8dbe3
    "Chapter 1. Please Introduce Yourself – Tutorial"), *Please Introduce Yourself
    – Tutorial* (`chapter1/please-introuce-yourself/src/App.vue`), you will see that
    this exact class was used for the parent element.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a lot of different components: popovers, tooltips, modals, and so
    on. We will use all of them during the course of the book.'
  prefs: []
  type: TYPE_NORMAL
- en: Bootstrap utilities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Do you want to have responsive floats (elements that flow to the left or to
    the right)? Just add the `float-left` and `float-right` classes to your elements,
    and you don''t have to be worried about it anymore:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Just insert this code into your HTML page (or simply check out the `index.html`
    file in the `example11-responsive-floats` folder), open it, and resize your window.
  prefs: []
  type: TYPE_NORMAL
- en: You can easily control the sizing and spacing with simple classes. Check out
    [https://v4-alpha.getbootstrap.com/utilities/sizing/](https://v4-alpha.getbootstrap.com/utilities/sizing/)
    and [https://v4-alpha.getbootstrap.com/utilities/spacing/.](https://v4-alpha.getbootstrap.com/utilities/spacing/.)
  prefs: []
  type: TYPE_NORMAL
- en: You can even enable flex-box behavior just by adding the `d-flex` class to your
    container. The *d* comes from *display*. With more classes attached to your flex
    element, you can control alignment and direction of your flex-box. Check it out
    at [https://v4-alpha.getbootstrap.com/utilities/flexbox/](https://v4-alpha.getbootstrap.com/utilities/flexbox/).
  prefs: []
  type: TYPE_NORMAL
- en: There are a lot more utilities to explore, and we will get into most of them
    during our journey.
  prefs: []
  type: TYPE_NORMAL
- en: Bootstrap layout
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using Bootstrap, it is easy to control the layout of your system:'
  prefs: []
  type: TYPE_NORMAL
- en: '|   | *Bootstrap includes several components and options for laying out your
    project, including wrapping containers, a powerful flexbox grid system, a flexible
    media object, and responsive utility classes.*- ([https://v4-alpha.getbootstrap.com/layout/overview/](https://v4-alpha.getbootstrap.com/layout/overview/))
    |   |'
  prefs: []
  type: TYPE_TB
- en: '|   | --*From Bootstrap* |'
  prefs: []
  type: TYPE_TB
- en: 'Bootstrap''s grid system is pretty powerful and easy to understand. It is just
    a row composed of columns. Everything is controlled by classes that have pretty
    self-descriptive names such as `row` and `col`. If you just give your columns
    `col` class, every column inside the `row` element will have the same size. If
    you want to have columns of different sizes, play with the fact that the row can
    be composed of 12 columns. So, if you want to make some columns, let''s say half
    of your row, give it a class **col-6**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'This code will produce results similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Bootstrap layout](../images/00048.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Grid layout system combining row and col classes
  prefs: []
  type: TYPE_NORMAL
- en: The interesting part is that if you resize your window, your layout will not
    break. It will resize accordingly. You don't have to implement any CSS black magic
    in order to achieve that! That is why Bootstrap is a big ![Bootstrap layout](../images/00049.jpeg).
  prefs: []
  type: TYPE_NORMAL
- en: Combining Vue.js and Bootstrap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we were talking about Vue, we devoted a big section to its components.
    When we talked about Bootstrap, we also talked about components. Doesn't it ring
    the same bell? Maybe we could create Vue components out of Bootstrap components?
    Maybe we can! Actually, we have already done it! Open the code of the first chapter's
    `PleaseIntroduceYourself` application. Check what we have inside the `components`
    folder. There's something that we called `MessageCard.vue`. Actually, this is
    an implemented Vue component for Card Bootstrap's component ([https://v4-alpha.getbootstrap.com/components/card/](https://v4-alpha.getbootstrap.com/components/card/))!
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `example13-vue-bootstrap-components-started/components` folder. Let''s
    use this project as a playground to create the Vue component based on the Bootstrap
    alert component. Run `npm install` and `run`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Let's create a Vue component called `Alert`. This component will contain the
    necessary code to simulate Bootstrap's alert component behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file named `Alert.vue` inside the `components` folder and add `template`
    tags. Our alert will definitely have the `alert` class. However, its additional
    class (`alert-danger`, `alert-info`, etc.) should be something configurable. Also,
    its title and text should be something passed by bound properties from the parent
    component. Thus, the template for the alert component will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s implement the `additionalClass` property as a computed property that
    will be calculated based on the `type` property passed by the parent component.
    So, the script for the `Alert` component will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can call it from our main `App.vue` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'You will end up with a nice alert on your page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Combining Vue.js and Bootstrap](../images/00050.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We just created our Alert Vue Bootstrap component
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Enable a default value for the title of the alert component. So, if the `title`
    is not passed, it will say **Success** by default. Also, bind the `type` property
    to the component on its creation inside the `App.vue` parent component. Export
    this property as a computed property depending on some arbitrary value. For example,
    based on some random number, if it's divisible by `3`, the type should be **danger**;
    if it's divisible by `5`, the type should be **info**; and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Check it out yourself. Go to the `example13-vue-bootstrap-components/components`
    folder and have a look, in particular, at the `App.vue` and `components/Alert.vue`
    components.
  prefs: []
  type: TYPE_NORMAL
- en: Combining Vue.js and Bootstrap continued
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So, we know how to create Vue components based on Bootstrap components. Doesn''t
    it feel like now it would be great to create all the Bootstrap components as Vue
    components and just use them in our Vue applications without having to think about
    Bootstrap classes whatsoever? Imagine Vue components such as `<button-success></button-success>`
    or `<button :type="success"></button>`. We could even create a whole library of
    Vue components based on Bootstrap! The question is, should we do it if it already
    exists? Yes, someone has already done all the work for us. These are the people
    who have done the work:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Combining Vue.js and Bootstrap continued](../images/00051.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Core team of bootstrap-vue
  prefs: []
  type: TYPE_NORMAL
- en: These nice people have developed something called Bootstrap-Vue and that's something
    that does exactly what you think—it contains a full set of Bootstrap components
    implemented as Vue.js components. Check it out at [https://bootstrap-vue.github.io/](https://bootstrap-vue.github.io/).
  prefs: []
  type: TYPE_NORMAL
- en: Let's check, for example, how the alert component is implemented at [https://bootstrap-vue.github.io/docs/components/alert](https://bootstrap-vue.github.io/docs/components/alert).
    It's a little bit more detailed than our alert. The data is passed within the
    component's tags and not as properties, like in our case, which also makes it
    more flexible. We will use it a lot while developing our application throughout
    the book.
  prefs: []
  type: TYPE_NORMAL
- en: What is Firebase?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To understand what is Firebase let''s open its website [https://firebase.google.com/](https://firebase.google.com/).
    This is what we see:'
  prefs: []
  type: TYPE_NORMAL
- en: '![What is Firebase?](../images/00052.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Google Firebase landing page
  prefs: []
  type: TYPE_NORMAL
- en: Firebase for Google is yet another cloud service, like AWS for Amazon or Azure
    for Microsoft, a bit simpler though, because Google already has Google Cloud Platform,
    which is huge.
  prefs: []
  type: TYPE_NORMAL
- en: If you feel like you want to choose between Firebase and AWS, do not forget
    that you will most likely Google it. In any case, someone has already done this
    for you so here you have this question on Quora at [https://www.quora.com/Which-is-better-cloud-server-Amazon-AWS-or-Firebase](https://www.quora.com/Which-is-better-cloud-server-Amazon-AWS-or-Firebase).
  prefs: []
  type: TYPE_NORMAL
- en: I would say that it's more similar to Heroku—it allows you to easily deploy
    your applications and integrate them with analytics tools. If you have read the
    Learning Vue.js 2 book ([https://www.packtpub.com/web-development/learning-vuejs-2](https://www.packtpub.com/web-development/learning-vuejs-2)),
    then you already know how much I love Heroku. I even have Heroku socks!
  prefs: []
  type: TYPE_NORMAL
- en: '![What is Firebase?](../images/00053.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: My beautiful Heroku socks
  prefs: []
  type: TYPE_NORMAL
- en: 'However, I find Google Firebase console also quite nice and simple to use.
    It also provides a backend as a service. This backend is shared for your web and
    mobile applications, which comes as a huge help when developing cross-platform
    and cross-device applications. Firebase provides the following services:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Authentication**: This uses Firebase API for authenticating users using different
    providers (Facebook, Google, e-mail, and so on).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Database**: This uses Firebase database API to store and retrieve your data.
    No need to choose between different database providers, and no need to establish
    connection. Just use the API out of the box.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hosting**: This hosts and deploys your application using simple shell commands.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Storage**: This hosts static files using a simple API.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Again, if you think about how to integrate your Vue application with Firebase
    APIs, stop thinking about it because someone has already done the job for you.
    After creating your project using the Firebase console, you can simply use a `vuefire`
    wrapper for Firebase to connect to your database and fetch your data. Check it
    out at [https://github.com/vuejs/vuefire](https://github.com/vuejs/vuefire). Actually,
    this is exactly what we did in our `PleaseIntroduceYourself` application from
    the first chapter. Check out the code that is located inside the `App.vue` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: Everything that is exported in the Firebase object becomes accessible via the
    `this` keyword, the same way as we access the `data` or `computed` properties.
    We will use `vuefire` in the application that we will develop throughout the book
    to better understand how it works.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we familiarized ourselves with Vue.js, Bootstrap and Firebase.
    We have also analyzed tools that integrate Vue.js with Bootstrap and Vue.js with
    Firebase.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, now, we are familiar with Vue.js applications that are built using single-file
    components, Bootstrap's grid system, components, and CSS helpers to make our lives
    easier and to make Google Firebase console with its possibilities.
  prefs: []
  type: TYPE_NORMAL
- en: Also, we know how to initialize Vue.js project, and use Vue directives, components,
    store and routing.
  prefs: []
  type: TYPE_NORMAL
- en: You also learned how to leverage Bootstrap's grid system to achieve the responsibility
    of our application's layout.
  prefs: []
  type: TYPE_NORMAL
- en: And last but not least, you learned how to use the Firebase API within the Vue
    application using `vuefire` bindings.
  prefs: []
  type: TYPE_NORMAL
- en: With the end of this chapter, the first introduction part of our journey also
    comes to an end.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will actually dive deep inside the implementation. As
    a scuba diving tank, we will take everything that you have learned so far!
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we will start developing the application that we will build during the
    whole book until it''s ready for deployment. We will:'
  prefs: []
  type: TYPE_NORMAL
- en: Define what the application will do and its requirements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define whom we are building the application for
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build basic mockups for the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scaffold the application using Vue command-line interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Are you as excited as much as I am? Then, let's go to the next chapter!
  prefs: []
  type: TYPE_NORMAL
