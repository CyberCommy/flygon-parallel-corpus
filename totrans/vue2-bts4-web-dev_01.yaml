- en: Chapter 2. Under the Hood – Tutorial Explained
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。底层-教程解释
- en: In the previous chapter, we built a simple single-page application from scratch.
    We used Vue.js to implement the application's functionality, Bootstrap to make
    it beautiful, and Firebase to manage the backend part of the application.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们从头开始构建了一个简单的单页面应用程序。我们使用Vue.js来实现应用程序的功能，使用Bootstrap使其美观，并使用Firebase来管理应用程序的后端部分。
- en: 'In this chapter, we will get to know all these technologies in depth and see
    how and why they can work nicely together. We will mostly discuss Vue.js since
    this will be our number one framework to build our application. Then, we will
    touch on Bootstrap and Firebase to get a basic understanding of how powerful these
    technologies are. Having said that, in this chapter we will:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入了解所有这些技术，看看它们如何以及为什么能够很好地协同工作。我们将主要讨论Vue.js，因为这将是我们构建应用程序的首选框架。然后，我们将涉及Bootstrap和Firebase，以基本了解这些技术有多强大。话虽如此，在本章中我们将：
- en: Discuss the Vue.js framework, reactivity, and data binding. Not only will we
    cover Vue.js' basics, but we will also dig into topics such as directives, components,
    routing, and so on.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 讨论Vue.js框架、反应性和数据绑定。我们不仅将涵盖Vue.js的基础知识，还将深入探讨诸如指令、组件、路由等主题。
- en: Discuss the Bootstrap framework. We will see what is possible to achieve with
    it, discuss how it can be useful to lay out an application, and discuss how its
    components can enrich your application with useful self-contained functionality.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 讨论Bootstrap框架。我们将看到它可以实现什么，讨论它如何有助于布局应用程序，并讨论它的组件如何为您的应用程序提供有用的自包含功能。
- en: Discuss the Firebase platform. We will see what it is, what functionalities
    it provides, and how to use its API to bring those functionalities to the application.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 讨论Firebase平台。我们将看到它是什么，它提供了哪些功能，并且如何使用其API将这些功能带到应用程序中。
- en: Check how all the mentioned technologies can be combined together in order to
    achieve simplicity in the development of complex things.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查所有提到的技术如何结合在一起，以实现在开发复杂事物时的简单性。
- en: Vue.js
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Vue.js
- en: 'The official Vue.js website suggests that Vue is a progressive JavaScript framework:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 官方Vue.js网站建议Vue是一个渐进式JavaScript框架：
- en: '![Vue.js](../images/00020.jpeg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![Vue.js](../images/00020.jpeg)'
- en: Screenshot from the official Vue.js website
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 来自官方Vue.js网站的截图
- en: What does that mean? In a very simplified way, I can describe Vue.js as a JavaScript
    framework that brings reactivity to web applications.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着什么？以非常简化的方式，我可以将Vue.js描述为一个为Web应用程序带来反应性的JavaScript框架。
- en: It's undeniable that each and every application has some data and some interface.
    Somehow, the interface is responsible for displaying data. Data might or might
    not change during runtime. The interface usually has to react somehow to those
    changes. The interface might or might not have some interactive elements that
    might or might not be used by the application's users. Data usually has to react
    to those interactions, and consequently, other interface elements have to react
    to the changes that have been done to the data. All of this sounds complex. Part
    of this complex architecture can be implemented on the backend side, closer to
    where data resides; the other part of it might be implemented on the frontend
    side, closer to the interface.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 不可否认的是，每个应用程序都有一些数据和一些界面。在某种程度上，界面负责显示数据。数据可能在运行时发生变化，也可能不会。界面通常必须以某种方式对这些变化做出反应。界面可能有一些交互元素，这些元素可能会或可能不会被应用程序的用户使用。数据通常必须对这些交互做出反应，因此，其他界面元素必须对已对数据所做的更改做出反应。所有这些听起来都很复杂。这种复杂架构的一部分可以在后端实现，靠近数据所在的地方；另一部分可能在前端实现，靠近界面。
- en: 'Vue.js allows us to simply bind data to the interface and relax. All the reactions
    that must happen between data and the interface will happen on their own. Let''s
    look at a very simple example where we will bind a message to the page title.
    Start by defining a simple HTML structure:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, let''s initialize a **Vue.js** instance on this page and bind its data
    to the `<h1>` element. For this simple example, we will use a standalone `Vue.js`
    file. Download it from the Vue.js official page at [https://vuejs.org/js/vue.js](https://vuejs.org/js/vue.js).
    Import it within the `<script>` tag. Let''s now initialize a **Vue** instance.
    The minimum that a Vue.js instance needs is the **element** to be attached to
    and the `data` object. We want to attach our Vue instance to the main `<div>`
    tag with the `app` ID. Let''s also create a data object containing an entry for
    the name:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let''s create our Vue.js instance with this data:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let''s now bind `data` to our HTML element. We will do this using double curly
    brackets (`{{}}`). Once the element has been attached to the `Vue` instance, everything
    that is inside of it becomes special—even the curly brackets. Everything that
    you put inside the double curly brackets will be interpreted and evaluated. So,
    if you put, for example, `2 + 2` inside the curly brackets, `4` will be rendered
    on the page. Just try it. Any expression, any statement will be compiled and calculated.
    Don''t be too excited though; don''t start writing chunks of JavaScript code inside
    those brackets. Let''s leave the computation to the script logic that is written
    where script resides. Use the brackets to access the data that you pass to your
    `Vue` instance. So, in our case, if you insert `{{name}}` anywhere inside your
    HTML markup, you will see the name that we passed to the `Vue` instance within
    the data object. Let''s, for example, replace the word `reader` inside the `<h1>`
    element by `{{name}}`:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If you refresh the page, you will see that the name we passed to the Vue instance
    is rendered. Try to change the `data.name` attribute in the developer tools console.
    You will see the changes immediately propagated. What we see here is a **one-way
    data binding**—the changes that happen to data are reactively propagated to the
    element to which the data is bound. Vue.js also supports **two-way data binding**;
    so, the changes that happen to the element on the page are also propagated to
    the data to which the element is bound.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: 'To achieve this, just bind the given piece of data to the element using the
    `v-model` attribute. Let''s, for example, add a text input to the page and bind
    it to the data attribute `name`:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, once you start typing in the text input, the change is immediately propagated
    to any other element bound to this piece of data:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '![Vue.js](../images/00021.jpeg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
- en: The data changes are reactively propagated through all the bound elements
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: 'The complete code for the HTML markup and JavaScript code looks like this:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you can see, there is nothing difficult at all. All you need is to pass `data`
    to the `Vue` instance and bind it to the elements of your page. The Vue framework
    does everything else. In the upcoming chapters, we will find out what else is
    possible using Vue.js and how to Bootstrap a Vue.js project.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Vue project – getting started
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So, now that we know what Vue.js is for and what its main focus is, we would
    like to get our hands dirty and start a Vue.js project and explore all the Vue.js
    features with it. There are plenty of ways of including Vue into the project.
    Let's explore all of them.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Including directly in script
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can use Vue.js by just downloading it and including it within the `<script>`
    tag. Actually, we've done it in the previous section. So, if you have a project
    already running and want to use some Vue.js features, you can simply include the
    `vue.js` file and use it.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: CDN
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you don''t want to bother downloading and managing Vue versions yourself,
    you can simply use the CDN version. Just include [https://unpkg.com/vue](https://unpkg.com/vue)
    script in your project and you are good to go! It will always be in sync with
    the latest Vue version:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: NPM
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you are all into the Node.js development, you can simply add an `npm` dependency
    to your `package.json` file. Just run `npm install` on your project''s root:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Vue-cli
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Vue provides a nice and clean command-line interface that is perfect for bootstrapping
    new projects. First of all, you must install **vue-cli**:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now, you can start a fresh new project using the Vue command-line interface.
    Check out the *vue-cli* repository for the detailed documentation at [https://github.com/vuejs/vue-cli](https://github.com/vuejs/vue-cli).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, it is possible to setup a project using different templates—starting
    from a simple single HTML page project and going to a complex webpack project
    setup. The command that should be used for scaffolding a Vue project is as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The following templates are available:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '**webpack**: This is a full-featured webpack setup with `vue-loader`. It supports
    hot reload, linting, testing, all kind of pre-processors, and so on.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**webpack-simple**: This is a simple webpack setup that is useful for quick
    prototyping.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**browserify**: This is a full-featured browserify setup with vueify that also
    supports hot reload, linting, and unit testing.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**browserify-simple**: This is a simple browserify setup with vueify that can
    be used for quick prototyping.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**simple**: This generates a simple HTML page that includes Vue.js. It is perfect
    for quick feature exploration.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is also possible to create custom templates. Check out the documentation
    at [https://github.com/vuejs/vue-cli#custom-templates](https://github.com/vuejs/vue-cli#custom-templates)
    and try it.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: 'In this book, we will use the `webpack` template. We will include some loaders,
    and we will use linters, unit, and end-to-end testing techniques. To bootstrap
    a project using the `webpack` template, simply run the following line of code:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now that we know how to scaffold a project with *vue-cli*, let's check what
    Vue offers besides what we already explored in the previous section.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: Vue directives
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Vue directives are no more than just **attributes** attached to your HTML elements.
    These directives provide some extra functionality to your template.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: All these directives start with the prefix `v-`. Why? Because it's *Vue*! You
    have already used some of them in the previous section. Now, we will see what
    directives exist and what you can do with them.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: Conditional rendering
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Open our Hello page and remove user''s input. Something not really beautiful
    is happening:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '![Conditional rendering](../images/00022.jpeg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
- en: '"Hello,!"'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: It would be interesting to render the **Hello,** name message conditionally,
    depending on the user input. If there is a name, render it; if there's no name,
    don't render.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, only render the **Hello,** name message if there''s a name. Directives
    `v-show` and `v-if` are used exactly for the conditional render. Open the `index.html`
    file of this example and let''s change it. Wrap the `Hello, <strong>{{name}}</strong>!`part
    into `span` and add a `v-show` attribute with the `name` value:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, if you refresh the page and remove the input completely, the message will
    only say **Let''s learn Vue.js**:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '![Conditional rendering](../images/00023.jpeg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
- en: The v-show attribute allows conditional rendering
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: 'Try to replace the `v-show` directive with the `v-if` directive. The end result
    will be quite the same. Why do both exist then? Check out the developer tools''
    elements tab and try to add or remove the text in the input. You will see that
    in the case of `v-show`, the conditional span will just gain a `display:none`
    property if the condition does not verify. In the case of `v-if`, the element
    disappears completely:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '![Conditional rendering](../images/00024.jpeg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
- en: Using the v-show attribute manipulates the display CSS property, whereas using
    the v-if attribute adds/removes an element completely
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: When do we use either attribute? If you have a lot of elements that should be
    visible depending on some data (this data is really dynamic, so it will happen
    a lot during the runtime), I would advise using the `v-show` attribute, because
    adding or removing elements in DOM is a rather expensive operation that might
    affect the application's performance and even the DOM itself. On the other hand,
    if the elements should be conditionally rendered only once, let's say, at the
    application startup, use the `v-if` attribute. If some elements should not appear,
    they will just not be rendered. Thus, the number of elements on the page will
    be reduced. Consequently, the computational cost of the application will be also
    reduced, as, now, it has fewer elements to go through and compute.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: Text versus HTML
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I am sure you know pretty well from the previous chapter how to bind some data
    using the mustache syntax `{{}}`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: 'Since this is a technical book about programming, we have to have a cat here
    ![Text versus HTML](../images/00025.jpeg)! A cat is pretty easy to render. Its
    Unicode is `U+1F638`; thus, we just have to add the `&#x1f638;` code to our HTML:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'And, surely, we will have a cat:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '![Text versus HTML](../images/00026.jpeg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
- en: Emoji cat saying hello to us
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: It's nice, but if we want to replace the cat with a dog, we will have to use
    Google to look for another Unicode representing a dog and replace it. If at some
    point we want to replace it with a unicorn, we will have to run the same procedure.
    Moreover, just by looking at our code, we will not be able to say what we are
    actually rendering unless we know all emoji codes by `&hearts;`. It might be a
    good idea to map the names of the emojis to their codes.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add a map of some of them. Open your HTML file and add the following
    lines of code to the `<script>` area:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, you can bind the values of this map to your HTML elements. Let''s try
    to do it using the mustache annotation:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Refresh the page. The result is not exactly the same as we expected, is it?
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '![Text versus HTML](../images/00027.jpeg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
- en: The code is rendered instead of the actual cat emoji
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: 'This is happening because mustache interpolation actually interpolates text.
    Using mustache interpolation is the same as using the `v-text` directive:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'What we actually want to render here is not the text; we want the value of
    the Unicode for the emoji being rendered as HTML! This is also possible with Vue.js.
    Just replace a `v-text` directive with the `v-html` directive:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now, we will get our cat back, and we know exactly what we are rendering when
    we are looking at the code.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: So, remember to use the `v-text` directive or mustache annotation for text interpolation
    and the `v-html` directive for interpolating pure HTML.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: Loops
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the previous section, we put a cat on our page. In this section, I would
    like to have a whole zoo! Imagine that our zoo has a cat ![Loops](../images/00028.jpeg),
    a dog ![Loops](../images/00029.jpeg) , a monkey ![Loops](../images/00030.jpeg)
    , and, of course, a unicorn ![Loops](../images/00031.jpeg).We would like to display
    our zoo in an ordered list. Of course, you can write a simple markup that will
    look like this:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'However, this makes your code unreadable, and if you want to add more animals
    to your zoo or remove one of them, you would have to know all these codes by heart.
    In the previous section, we added a map for emoji animals Unicode. Let''s use
    it in our markup. You already learned that we must use a `v-html` directive so
    that the codes are interpolated as HTML. Hence, our markup will look like this:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'It looks better, but still there''s something we could improve. Imagine if
    you want to render all the animals from the emoji world! There are plenty of them.
    For each animal, you will have to repeat the code of the list item. Every time
    you would like to reorder the list, remove some elements, or add new ones, you
    will have to deal with this markup. Wouldn''t it be nice if we just had an array
    of animals that we want to render and then somehow iterate over it and render
    what''s inside of it? Of course, it would! It is possible using the `v-for` directive.
    Create an array of animals using the following lines of code:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Export it in the `vue data` object:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, you can use this array in the `v-for` directive and replace multiple `<li>`
    elements by only one:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The result will be quite nice:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '![Loops](../images/00032.jpeg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
- en: Emoji zoo rendered using the v-for directive
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Binding data
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We dealt a lot with rendering different data using Vue.js in the previous section;
    so now, you are already familiar with different ways of binding it. You know how
    to interpolate data as *text* and as *HTML*, and you know how to iterate over
    arrays of data.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve also seen that two-way data binding is achieved using the `v-model`
    directive. We used it to bind a name to the input element:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `v-model` directive can only be used with the `input`, `select`, and `textarea`
    elements. It also accepts some modifiers to be used with. Modifiers are special
    keywords that affect the input in some way. There are three modifiers that can
    be used with this directive:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '`.lazy`: This will only update the data on a change event (try it with our
    input and you''ll see that changes in the input will only affect other parts where
    the name is used when the *Enter* button is pressed and not on each key press)'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.number`: This will cast your input to number'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.trim`: This will trim the user''s input'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It is also possible to chain the modifiers:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: So now, we know nearly everything about binding data to the elements. What if
    we want to bind some data to the elements' properties? Imagine, for example, the
    dynamic value for the image's source property or class property depending on some
    data value. How could we do that?
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: For this, Vue provides a `v-bind` directive. With this directive, you can bind
    whatever you want!
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, let''s show a sad picture when the name is not defined and a
    glad picture when the name is defined. For this, I''ve created two pictures, `glad.png`
    and `sad.png`, and put them into the `images` folder of my application. I will
    also export their paths into the data object:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, I can create an image and bind its source using `v-bind:src`, and I''ll
    provide a JavaScript expression as the value. This expression will check the value
    of the name. If it''s defined, the `glad` image will be applied, and if not, the
    `sad` image will be applied instead:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The shortcut for the `v-bind` directive is `:`, so we can just write the following
    line of code:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Here is how our page looks when the value of `name` is defined:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '![Binding data](../images/00033.jpeg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
- en: Happy face image appears when the name is defined
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: 'If you remove the name from the input field, the image will automatically change!
    Open the page and try to remove the text from the input field and add it again.
    Continue removing and adding, and you will see how fast the image is changed to
    the corresponding one. This is how the page looks when the name is undefined:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '![Binding data](../images/00034.jpeg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
- en: Once the input is cleaned, the image source is immediately changed
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: 'Basically, you can do exactly the same with any property binding, for example,
    class:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: You can also bind properties to pass to the children components. We will see
    how to do it in the section about components.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: Handling events
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Besides the direct form of data binding to the elements, we want to handle some
    events because this is what our users do on the page—trigger some events so that
    they happen. They click, they hover, they submit forms—and all these events must
    be handled somehow by us. Vue provides a very nice way of attaching listeners
    to events on any DOM element and provides methods that can handle those events.
    The good thing about these methods is that they have direct access to Vue data
    using the `this` keyword. In this way, we can use methods to manipulate data,
    and since this data is reactive, all the changes will be immediately propagated
    to the elements to which this data is bound.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to create a method, you just have to add a `methods` object to the
    export section of your Vue application. In order to attach this method to any
    event listener, use the `v-on` directive with the corresponding event after the
    colon. Here is an example:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The shortcut for this directive is `@`, so we could rewrite all these directives
    as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'It should sound familiar to you. Do you remember the tutorial that we followed
    in the [Chapter 1](part0016_split_000.html#F8901-449ee41b57ea4c048225480b41c8dbe3
    "Chapter 1. Please Introduce Yourself – Tutorial"), *Please Introduce Yourself
    – Tutorial*? Do you remember that we were listening on the `submit` method of
    the message, adding `form` and calling `addMessage`? Check it out. Our form with
    its `submit` directive looked like this:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Then, inside the `methods` section, we actually had the `addMessage` method
    defined:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Does it start to make more sense now?
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: 'Just to understand it better, let''s add some methods to our zoo page! Wouldn''t
    it be nice if you could compose your own zoo? Let''s add a multiple select element
    that will contain all possible options, and your zoo will be populated from something
    that you actually choose! So, let''s do the following:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: Add more animals to our `animalCodes` map
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add another array called `animalsForZoo`
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use this new array in our ordered list that displays the zoo
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a multiple `select` box composed of the keys of the `animalCodes` map
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attach a `@change` listener to this select box that will call the `populateAnimalsForZoo`
    method
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a `populateAnimalsForZoo` method that will populate the `animalsForZoo`
    array with the selected options from our multiple select element
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Doesn''t it sound easy? Of course, it does! Let''s get started. So, at first,
    add more animals to our `animalCodes` map:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Let''s also rethink our `animals` array and generate it out of our map. In
    this way, every time we need to add some new animal, we just add its key-value
    name-unicode to the mapping object instead of maintaining both object and array.
    So, our `animals` array will look like this:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now, we need another empty array. Let''s call it `animalsForZoo`, and let''s
    populate our zoo from this new array. Since it is empty, our zoo will also be
    empty. However, we are about to create a method that will populate this array.
    So, creating an array is easy, and don''t forget to export it in a data object:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Don''t forget to replace the usage of the `animals` array in our zoo display
    with the new `animalsForZoo` array:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: I know that now you are worried that your zoo on the page is empty, but give
    us a couple of minutes and we will take care of that!
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, let''s create a multiple `select` element that will be populated
    based on the `animals` array:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now, finally, we will attach an event listener to our select box. Let''s attach
    a listener to the change event. Let''s tell it to call the `populateAnimalsForZoo`
    method. Our directive will look like this:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The whole `select` element will obtain a new attribute:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Great! But there''s no such method as `populateAnimalsForZoo`. But there''s
    us! Let''s create it. This method will just iterate through the checked options
    of the animals selected as input and push them into the `animalsForZoo` array:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Check out how the whole HTML and JavaScript code look after all these changes
    in the `chapter2/example1-vue-intro/index.html` file. This is how our testing
    page looks after the changes:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '![Handling events](../images/00035.jpeg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
- en: The zoo is being populated based on the user's choice
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: The page is messy, right? However, look how many things you have already learned
    just by using this page. And, admit it, it's a fun learning process! And we are
    not done with it yet.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you have learned how to add methods and event listeners, I will teach
    you how we could have done the exact same thing without this method and `v-bind:change`.
    Remove all the code we just added and just add `v-model` to our `select` element
    with the `animalsForZoo` value :'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Now, everything we have just done inside the method is handled automatically
    by Vue! Isn't it great?
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: Vue components
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We came to this chapter having a midsize HTML page in our hands that contains
    a lot of different parts. We could have thought of more things, for example, adding
    interactivity to each animal of our zoo, adding the possibility of feeding animals,
    or having some interesting facts about each animal showing up every time you hover
    over the animal's icon. At some point, let's face it, the HTML file along with
    its JavaScript will become unmaintainable.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: Can you also see that our visualization layer (HTML) works along with our logical
    layer (JavaScript)? So, they kind of form blocks, items, bricks… For example,
    we have a piece of code that is responsible for the **Hello** name section. We
    have another block that contains our zoo. Each animal in the zoo is another item.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: Call these things whatever you want, but they are undeniably separated pieces
    of structure and logic that, when brought together, form the whole puzzle. If
    you build a wall from a unique piece of material and decide to change some parts
    of the wall, it will not be the easiest task.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: 'So, imagine, you build this wall and incorporate some yellow stars, blue polygons,
    red squares, and so on into it. Then, you decide that your yellow stars should
    be black. You have to change all your stars. Then, you decide that your green
    ellipsis should be a smiling face instead. What now? Change all ellipses, but
    first you have to find all the places in the wall that contain those ellipses.
    This is your wall, try to find all ellipses in it:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '![Vue components](../images/00036.jpeg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
- en: The wall built as a whole piece with incorporated parts of different colors
    and forms
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, imagine that each piece actually resides on its individual brick. You
    can change them, add them, and remove them as much as you want. If you want to
    change the appearance of some of the wall elements, you just change this one brick
    and all the wall pieces containing this brick will change, because *all in all,
    it''s just another brick in the wall*. So, instead of having the wall full of
    incorporated strange pieces, you have four bricks, and you change them whenever
    you need to change the piece of wall that relies on that brick:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '![Vue components](../images/00037.jpeg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
- en: If you need to change the appearance of an element in the wall, you just change
    the corresponding brick
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: 'The wall is composed of bricks. These bricks are our components. What if we
    could also have components built with HTML, CSS, and JavaScript and our application
    could be built of those components? Did I just say "what if"? There''s no "what
    if." We already have it. Vue.js supports component-based application structure.
    It''s really easy to create components with Vue.js. The only three things you
    have to do are as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: Create a component, and give it a template, data, methods, and whatever you
    need to give to it.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Register it in the Vue app under the `components` object.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use it within the application's template.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For example, let''s create a component that will simply render a header element
    saying **Hello**. Let''s call it `HelloComponent`. It will only contain the template
    string:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now, we can register this component inside our Vue application initialization
    code:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now, this component can actually be used inside the HTML section of the Vue
    application''s element:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'So, the whole section will look something like this:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Someone might ask, "What''s so powerful in these components?" The amount of
    written code is actually the same as if I would have just written a piece of HTML
    that does the same. What''s the point? Yes, sure, but in this example, our component
    had just one template inside. A template composed of one line only. We could have
    a huge template in there, and we could have some methods in this component and
    also its own data! Let''s, for example, add an input for the name to this component
    and the name to its data object:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'If you need to reuse this component, you can do it as many times as you want:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Then, you will end up with three independent components on your page:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '![Vue components](../images/00038.jpeg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
- en: Using components helps avoid repeated code
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: These components are very nice, but there's still a big amount of code written
    within the same JavaScript code block. We declare components all in one place,
    and if there are too many of them, the application will become unmanageable again.
    Besides that, this HTML code within the template string is also not the most maintainable
    thing ever.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: Well, if you are thinking so, I have some good news for you. Each component
    can be stored in its own file with its own HTML, JavaScript, and CSS code. These
    are special files with the `.vue` extension. Inside each file, there's a `<script>`
    section for the JavaScript code, a `<style>` section for the CSS code, and a`<template>`
    section for the HTML code. Isn't it convenient? Such components are called single-file
    components. Have a look at the first chapter's code—there's a main component called
    `App.vue` and there's also the `MessageCard.vue` component created by us. Isn't
    it nice?
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to use single-file components in your application, you must scaffold
    this application using some modular bundler, for example, `webpack`. We already
    talked about `vue-cli` and how easy it is to bootstrap a Vue application using
    the `webpack` template. Let''s port the messy page with zoo to the `webpack` bundled
    application. Run the initialization and installation scripts:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now, open the `App.vue` file and let''s fill it up with our messy zoo application.
    The `<script>` section looks like this:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Note the highlighted areas. I've copied the images into the `static` folder.
    Another important thing is that the data inside the component should be used as
    a function that returns an object and not as an object itself. Since the data
    object will still be one single instance across multiple components, the whole
    data object with its properties must be assembled in a dedicated function.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the script is completely the same.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: The template area of the component is pretty much the same as the HTML structure
    from the previous example. Check out the code in the `chapter2/example3-components-started`
    folder.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s extract some of the functionality into the individual component. What
    do you think if we extract the zoo to its individual component? Create a `Zoo.vue`
    file in the `components` folder. Copy the template for the animals list to this
    component''s `<template>` area:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Now, we should tell this component that it will receive `animals`, `name`,
    and `animalCodes` properties from the parent component that will call the following
    component:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Now, open the main `App.vue` component, import the `Zoo` component, and export
    it in the `components` object:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Now, we can use this component inside the template! So, replace the whole `div`
    tagthat contains our zoo with just the following code:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Check out the page! Everything works as it did earlier!
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Extract an animal to the individual component and call it inside the zoo within
    the `v-for` directive. Each animal has to have a small functionality that will
    display a small description when clicking its face (on `click`). I am pretty sure
    you will easily solve this exercise. If you need help, check out this chapter's
    code inside the `example4-components/zoo` directory.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: Vue router
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Single Page Applications** (**SPA**) are great. They came to make our life
    easier. And it definitely is. With a bit of JavaScript code, you can achieve all
    the functionality that had to be done on the server side before, and the whole
    page should have been replaced just to display the result of that functionality.
    It is a golden era for web developers now. However, there is a problem that SPAs
    are trying to solve—*navigation*. History API and the `pushState` method ([https://developer.mozilla.org/en-US/docs/Web/API/History_API](https://developer.mozilla.org/en-US/docs/Web/API/History_API))
    are already solving it, but it has been a long process until it became an established
    technology.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: Our users are used to controlling their *where I am and where I want to be*
    using browsers' navigation buttons. If the whole functionality is located on the
    same page, how will these buttons help with the navigation? How do you use Google
    analytics to check which page (that, in fact, is the same) is being accessed more
    by your users? The whole concept is totally different. Of course, these kinds
    of applications are a lot faster because the number of requests is significantly
    reduced, and of course, our users are grateful for that, but they are not changing
    their web surfing habits just because we changed the way we implement things.
    They still want to go *back*. They expect that if they refresh the page, the page
    will open on exactly the same place where they were right before hitting the refresh
    button. They expect that they will understand where they are just by looking at
    the page's URL and checking what's behind the slash. For example, if it's `http://mySite/store`
    then it's a store; if it's `http://mySite/settings`, then most likely I'm somewhere
    where I can check my current settings and change them.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: There are a lot of ways to achieve navigation without having to transform single-page
    applications into multiple-page applications. You can include an extra layer of
    logic on your application and change `window.location.href` every time a different
    URL is required—this will cause the page to refresh, which is not nice. You can
    also use HTML5 `history` API. It would not be the simplest thing to maintain,
    but it might work.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: We all know that good developers are lazy, right? Being lazy means not solving
    problems that are already solved by someone else. This problem of navigation is
    being solved by many frameworks and libraries. Not only can you use some third-party
    libraries that help you deal with the routing in your application, but you can
    also use the mechanisms provided by the framework of your choice. Vue.js is one
    of the frameworks that offers a way of dealing with routing. You just map the
    URL path to your components and everything just works! Check out the official
    documentation of `vue-router` library at [https://router.vuejs.org/en/](https://router.vuejs.org/en/).
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to be able to use `vue-router`, you must install it for your project:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Optionally, `vue-router` usage can be selected on the Vue project initialization
    with `vue init`.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you can use Vue router in your application. Just tell Vue to use it:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Let''s create a simple routing example. We will have three components, one
    of which we consider as the `Home` component, meaning that it should be shown
    when someone navigates to the root route `/`. Let''s call the second one `Hello`
    component and the third one `Bye` component. Open the `example5-router-started`
    code files from [Chapter 2](part0024_split_000.html#MSDG2-449ee41b57ea4c048225480b41c8dbe3
    "Chapter 2. Under the Hood – Tutorial Explained"), *Under the Hood – Tutorial
    Explained*. You will find all the described components in the `components` directory:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '![Vue router](../images/00039.jpeg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
- en: The structure of the example application where we are going to try Vue router
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: Now, we must create a `router` instance. The constructor receives the `options`
    object as a parameter. This object can contain different configurable values.
    The most important one is the array of `routes`. Each entry of this array should
    consist of an object that indicates the `path` of the route and its corresponding
    `component`.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will import all the needed components, and then, our `router` instance
    will look like this:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'If you want to understand better what the `mode:` `history` option is, check
    out the documentation page at [https://router.vuejs.org/en/essentials/history-mode.html](https://router.vuejs.org/en/essentials/history-mode.html)
    that explains it in a really nice manner. Now, we have to pass the router option
    to our Vue application. This option will point to our new `router` instance:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Now, the whole application knows that we use this router. One more important
    step: we need to include the router component into the main component''s template.
    For this, it is enough to just include the `<router-view>` tag in the `App.vue`
    component''s template:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Check out in more detail the `router-view` component at [https://router.vuejs.org/en/api/router-view.html](https://router.vuejs.org/en/api/router-view.html).
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: 'Voilà! Run the application if you haven''t done so already:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Open the page at `http://localhost:8080` and check that it is displaying our
    home page component. Then, type `http://localhost:8080/hello` and `http://localhost:8080/bye`
    in the browser''s address bar. Check that the content of the page actually changes
    according to the URL path:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '![Vue router](../images/00040.jpeg)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
- en: Basic routing with vue-router
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, you are already thinking about how to create a simple menu, pointing
    an anchor `<a>` element to your defined paths in the router. Don''t think too
    much. Just use a `<router-link>` component with the `to` attribute pointing to
    the path of your choice. For example, to display a simple navigational menu for
    our router example application, we could write something like this:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Alternatively, if you don''t want to write your paths all over again, you can
    reference your routes by name and use the `v-bind:to` directive or simply use
    `:to`:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Check how the code looks in the `example6-router` folder.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: Open the page and check whether all the links actually work! Click on them several
    times and check whether you will actually go back if you click on the browser's
    go back button. Isn't it fantastic?
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: Vuex state management architecture
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Do you remember our example with the `Zoo` and `animal` components? There was
    some data that had to be propagated from the main component to the child component
    of the child component. If this grandchild component had the possibility of somehow
    changing data, this change would have to be propagated from the child component
    to its parent component and so on until data reaches the main component. Don't
    think that you would do it simply with a `v-model` binding attribute. Vue has
    some restrictions regarding binding data to the children components via `props`.
    It is strictly one way. So, if the parent component changes the data, the child
    component's bindings will be affected, but it will never happen the other way
    around. Check out Vue's official documentation in regarding this at [https://vuejs.org/v2/guide/components.html#One-Way-Data-Flow](https://vuejs.org/v2/guide/components.html#One-Way-Data-Flow).
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: 'If you don''t believe me, let''s try it. Imagine that in our zoo page example,
    we would extract the introduction part to the separate component. I am talking
    about this part of our messy zoo page:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '![Vuex state management architecture](../images/00041.jpeg)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
- en: What if we'd like to extract this part to the separate component?
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: 'It seems easy. We have to declare a component, let''s say `Introduction`, tell
    it that it will receive the `name` property, and just copy-paste HTML from `App.vue`
    to this new component. Inside `App.vue`, we will import this new component and
    export it inside the `components` object of the Vue instance. Of course, we will
    replace the HTML that we already copied to the new component with the `<introduction>`
    tag and bind the `name` property to it. Isn''t it easy? Our `Introduction.vue`
    file will look like this:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Our `App.vue` file will import, export, and call:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Check out this code in the code bundle of the [Chapter 2](part0024_split_000.html#MSDG2-449ee41b57ea4c048225480b41c8dbe3
    "Chapter 2. Under the Hood – Tutorial Explained"), *Under the Hood – Tutorial
    Explained* in the `example7-events-started/zoo` folder. Run `npm install` and
    `npm run` inside this folder:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Check out the page. It looks like it did before. Try to change the name inside
    the input. First of all, it doesn''t change in other places where it should change,
    and second, our dev tools console is full of warnings and errors:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '![Vuex state management architecture](../images/00042.jpeg)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
- en: The name is not updated where it should have been updated, and the console is
    full of errors
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: 'It seems the documentation is right: we can''t change the value of data passed
    as property to the child component. What can we do then? We can emit events and
    attach event listeners to the component, and change the data on the event. How
    do we do this? It''s simple. First of all, let''s call the property being passed
    by something that is not `name`, for example, `initialName`. Then, open the `Introduction`
    component and create a `data` function that will bind this component''s `name`
    object to `initialValueprops`. In this way, we are at least telling Vue that it
    is not our intention to try to change parent''s data from the child. So, `script`
    of the `Introduction.vue` component will look like this:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'We also have to change the way we bind name to the component inside `App.vue`:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Now, if you check the page, you will at least see that Vue doesn''t complain
    anymore about something illegal that we try to do. However, still, if we try to
    change the name, the changes are not propagated to the parent, which is quite
    understandable; these changes only affect the data of the component itself. Now,
    we have to attach the `event` to the `input` element. This event will call a method
    that will finally emit the event to the parent component:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Now, the only thing we have to do is to bind the `nameChanged` event listener
    to the `<introduction>` component and call the method that will change the name
    of the `App.vue` data object:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Check the page. Now, everything works as before! Check the code for this solution
    inside the `example7-events/zoo` code folder for this chapter.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: Well, it was not very difficult, but do we want to emit all these events every
    time we need to update the state? And what if we have components inside the components?
    And what if we have other components inside those components? Will it be the events
    handling hell? And if we have to change something, will we have to go to all those
    components? Argh! Wouldn't it be great to have the application's data in some
    kind of centralized storage that would provide a simple API for its management
    and then we could just call this storage's methods in order to retrieve and update
    the data? Well, this is exactly what Vuex is for! Vuex is a centralized state
    management inspired by Redux. Check out its official documentation at [http://vuex.vuejs.org/en/](http://vuex.vuejs.org/en/).
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, in a nutshell, the three most important parts of a Vuex store are state,
    getters, and mutations:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: '**State**: This is an initial state of the application, basically the data
    of the application'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Getters**: These are exactly what you think, functions that return data from
    the store'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mutations**: These are functions that can mutate data on the store'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A store can also have actions. These things are like wrappers for mutations
    with a bit more capacity. If you want to check what are they about, refer to the
    official documentation at [http://vuex.vuejs.org/en/mutations.html](http://vuex.vuejs.org/en/mutations.html).
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add the Vuex store to our `Zoo` application to check how it works. First
    of all, we need to install `vuex`. Open the code for [Chapter 2](part0024_split_000.html#MSDG2-449ee41b57ea4c048225480b41c8dbe3
    "Chapter 2. Under the Hood – Tutorial Explained"), *Under the Hood – Tutorial
    Explained* from the `example8-store-started/zoo` folder and run `npm install`:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Let''s create our store. Start by creating a folder named `store` with the
    `index.js` file inside. We will put all our store data inside this file. Before
    doing this, tell Vue that we will use Vuex:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Now, we can create a new Vuex instance. It should receive `state`, `getters`,
    and `mutations`. Let''s define them:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Nice! Now, let''s add all the data that resides in our application to the state:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Now, if you inject the store on the Vue application initialization, all the
    components and their children will have access to the `this.$store` instance.
    Let''s inject it:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Now, if we replace all the data with computed properties from the store in
    `App.vue` (except `animalsForZoo`, which is bound as a property for our zoo),
    the application will look quite the same:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: If you open the page, nothing has changed. However, our changing name interaction
    doesn't work again!
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add `mutation` to change the name. Mutations are just methods that receive
    a state as first argument and anything you call them with as other parameters.
    So, let''s call our mutation `updateName` and pass `newName` to it as a second
    argument:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Now, we can use this mutation to access the `this.$store.mutation` property
    inside the component responsible for updating the name—`Introduction.vue`. We
    have to just change the `onInput` method:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'By the way, we can also remove the properties and pass the name directly from
    the store, just like we did in the `App.vue` component. Then, you can remove the
    `name` binding to the `introduction` component inside the `App.vue` component''s
    template. Now, you can replace the properties that are bound to the Zoo component
    by computed properties coming from the store. See how elegant the code becomes!
    For example, look at this line of code:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Doesn''t it look better than the following line of code:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Check out the final code for this chapter in the `example8-store/zoo` code folder
    for [Chapter 2](part0024_split_000.html#MSDG2-449ee41b57ea4c048225480b41c8dbe3
    "Chapter 2. Under the Hood – Tutorial Explained"), *Under the Hood – Tutorial
    Explained*. Note that we have used a very simplified version. We have not even
    used any getters. For a more sophisticated use, we would create `getters` and
    `actions`, and they would have been located in their own `actions.js` and `getters.js`
    files. We would also use `mapGetters` and `mapActions` helpers. However, for basic
    understanding, what we have done is enough. Refer to the official documentation
    to find out more about Vuex store and how to use it.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: Bootstrap
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we know almost everything about Vue.js, let's talk about Bootstrap.
    Check out the official Bootstrap page at [https://v4-alpha.getbootstrap.com/](https://v4-alpha.getbootstrap.com/).
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: '![Bootstrap](../images/00043.jpeg)'
  id: totrans-311
  prefs: []
  type: TYPE_IMG
- en: Bootstrap—framework for responsive projects
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: In a nutshell, Bootstrap gives you a broad set of classes that allow building
    nearly everything with any layout in an easy and effortless way.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: 'Bootstrap provides with you four most important things:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: Easy layouts building at [https://v4-alpha.getbootstrap.com/layout/overview/](https://v4-alpha.getbootstrap.com/layout/overview/)
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Broad range of classes to style nearly any web element at [https://v4-alpha.getbootstrap.com/content/](https://v4-alpha.getbootstrap.com/content/)
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Self-contained components such as alerts, budges, modals, and so on at [https://v4-alpha.getbootstrap.com/components/](https://v4-alpha.getbootstrap.com/components/)
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some utilities for styling images, figures, for positioning, styling, and adding
    borders at [https://v4-alpha.getbootstrap.com/utilities/](https://v4-alpha.getbootstrap.com/utilities/)
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'How to install Bootstrap? It can be installed from the CDN:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: This is, actually, exactly what we have in the `PleaseIntroduceYourself` application
    from [Chapter 1](part0016_split_000.html#F8901-449ee41b57ea4c048225480b41c8dbe3
    "Chapter 1. Please Introduce Yourself – Tutorial"), *Please Introduce Yourself
    – Tutorial*, and in the messy zoo application from this chapter.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: Bootstrap components
  id: totrans-322
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Bootstrap has a lot of components that can be used just out of the box.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: I will not talk about all of them in this chapter, because we will have several
    opportunities to discover them during the course of the book. Let's look at some
    of them just to have an idea.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the alert components. As you might know, alerts are nice elements
    that appear on the page when you have successfully filled in some form. Alerts
    are also those angry red elements that tell you that you''ve done something wrong.
    What would you need to create an alert element on the page that would disappear
    after some time or give the possibility to the user to close it by clicking on
    the **x** button? You would probably create a `div`, add some class to it, and
    add a bit of JavaScript that would remove the element from the DOM tree after
    a grace period. Using Bootstrap, you just add `alert` class to your `div` and
    add another class such as `alert-warning` or `alert-info` to specify which kind
    of alert it is:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'This code will produce nice alert boxes that look like this:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: '![Bootstrap components](../images/00044.jpeg)'
  id: totrans-328
  prefs: []
  type: TYPE_IMG
- en: Bootstrap alerts—success, info, warning, and danger
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: 'Even a simple element like a button can be styled in hundreds of different
    ways using Bootstrap. Again, you can have buttons indicating success, danger zone,
    being informative, or just gray. There''s a possibility of grouping buttons and
    making them look like a link. The code is pretty easy:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'This code will produce buttons as shown here:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: '![Bootstrap components](../images/00045.jpeg)'
  id: totrans-333
  prefs: []
  type: TYPE_IMG
- en: Bootstrap buttons
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: icial documentation page at [https://v4-alpha.getbootstrap.com/components/buttons/](https://v4-alpha.getbootstrap.com/components/buttons/).
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: 'One of my favorite things about Bootstrap is that you might have a trivial
    element, but then you add some of the Bootstrap''s classes to it and it suddenly
    becomes clean and nice. For example, create a simple page with some `<h1>` and
    `<p>` elements:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: It will look normal, simple. Now, add the `container` class to the parent `div`.
    Isn't it much nicer? Also, add the `jumbotron` class to it.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: 'The page looked like this earlier:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: '![Bootstrap components](../images/00046.jpeg)'
  id: totrans-340
  prefs: []
  type: TYPE_IMG
- en: The content inside the div before adding Bootstrap classes
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: 'All of a sudden, the same page looks like this:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: '![Bootstrap components](../images/00047.jpeg)'
  id: totrans-343
  prefs: []
  type: TYPE_IMG
- en: The content inside the div after adding Bootstra
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: Actually, if you check our `PleaseIntroduceYourself` example from [Chapter 1](part0016_split_000.html#F8901-449ee41b57ea4c048225480b41c8dbe3
    "Chapter 1. Please Introduce Yourself – Tutorial"), *Please Introduce Yourself
    – Tutorial* (`chapter1/please-introuce-yourself/src/App.vue`), you will see that
    this exact class was used for the parent element.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a lot of different components: popovers, tooltips, modals, and so
    on. We will use all of them during the course of the book.'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: Bootstrap utilities
  id: totrans-347
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Do you want to have responsive floats (elements that flow to the left or to
    the right)? Just add the `float-left` and `float-right` classes to your elements,
    and you don''t have to be worried about it anymore:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Just insert this code into your HTML page (or simply check out the `index.html`
    file in the `example11-responsive-floats` folder), open it, and resize your window.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: You can easily control the sizing and spacing with simple classes. Check out
    [https://v4-alpha.getbootstrap.com/utilities/sizing/](https://v4-alpha.getbootstrap.com/utilities/sizing/)
    and [https://v4-alpha.getbootstrap.com/utilities/spacing/.](https://v4-alpha.getbootstrap.com/utilities/spacing/.)
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: You can even enable flex-box behavior just by adding the `d-flex` class to your
    container. The *d* comes from *display*. With more classes attached to your flex
    element, you can control alignment and direction of your flex-box. Check it out
    at [https://v4-alpha.getbootstrap.com/utilities/flexbox/](https://v4-alpha.getbootstrap.com/utilities/flexbox/).
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: There are a lot more utilities to explore, and we will get into most of them
    during our journey.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: Bootstrap layout
  id: totrans-354
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using Bootstrap, it is easy to control the layout of your system:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: '|   | *Bootstrap includes several components and options for laying out your
    project, including wrapping containers, a powerful flexbox grid system, a flexible
    media object, and responsive utility classes.*- ([https://v4-alpha.getbootstrap.com/layout/overview/](https://v4-alpha.getbootstrap.com/layout/overview/))
    |   |'
  id: totrans-356
  prefs: []
  type: TYPE_TB
- en: '|   | --*From Bootstrap* |'
  id: totrans-357
  prefs: []
  type: TYPE_TB
- en: 'Bootstrap''s grid system is pretty powerful and easy to understand. It is just
    a row composed of columns. Everything is controlled by classes that have pretty
    self-descriptive names such as `row` and `col`. If you just give your columns
    `col` class, every column inside the `row` element will have the same size. If
    you want to have columns of different sizes, play with the fact that the row can
    be composed of 12 columns. So, if you want to make some columns, let''s say half
    of your row, give it a class **col-6**:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'This code will produce results similar to this:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: '![Bootstrap layout](../images/00048.jpeg)'
  id: totrans-361
  prefs: []
  type: TYPE_IMG
- en: Grid layout system combining row and col classes
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: The interesting part is that if you resize your window, your layout will not
    break. It will resize accordingly. You don't have to implement any CSS black magic
    in order to achieve that! That is why Bootstrap is a big ![Bootstrap layout](../images/00049.jpeg).
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: Combining Vue.js and Bootstrap
  id: totrans-364
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we were talking about Vue, we devoted a big section to its components.
    When we talked about Bootstrap, we also talked about components. Doesn't it ring
    the same bell? Maybe we could create Vue components out of Bootstrap components?
    Maybe we can! Actually, we have already done it! Open the code of the first chapter's
    `PleaseIntroduceYourself` application. Check what we have inside the `components`
    folder. There's something that we called `MessageCard.vue`. Actually, this is
    an implemented Vue component for Card Bootstrap's component ([https://v4-alpha.getbootstrap.com/components/card/](https://v4-alpha.getbootstrap.com/components/card/))!
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `example13-vue-bootstrap-components-started/components` folder. Let''s
    use this project as a playground to create the Vue component based on the Bootstrap
    alert component. Run `npm install` and `run`:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Let's create a Vue component called `Alert`. This component will contain the
    necessary code to simulate Bootstrap's alert component behavior.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file named `Alert.vue` inside the `components` folder and add `template`
    tags. Our alert will definitely have the `alert` class. However, its additional
    class (`alert-danger`, `alert-info`, etc.) should be something configurable. Also,
    its title and text should be something passed by bound properties from the parent
    component. Thus, the template for the alert component will look like this:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Let''s implement the `additionalClass` property as a computed property that
    will be calculated based on the `type` property passed by the parent component.
    So, the script for the `Alert` component will look like this:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Then, we can call it from our main `App.vue` component:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'You will end up with a nice alert on your page:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: '![Combining Vue.js and Bootstrap](../images/00050.jpeg)'
  id: totrans-376
  prefs: []
  type: TYPE_IMG
- en: We just created our Alert Vue Bootstrap component
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  id: totrans-378
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Enable a default value for the title of the alert component. So, if the `title`
    is not passed, it will say **Success** by default. Also, bind the `type` property
    to the component on its creation inside the `App.vue` parent component. Export
    this property as a computed property depending on some arbitrary value. For example,
    based on some random number, if it's divisible by `3`, the type should be **danger**;
    if it's divisible by `5`, the type should be **info**; and so on.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: Check it out yourself. Go to the `example13-vue-bootstrap-components/components`
    folder and have a look, in particular, at the `App.vue` and `components/Alert.vue`
    components.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: Combining Vue.js and Bootstrap continued
  id: totrans-381
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So, we know how to create Vue components based on Bootstrap components. Doesn''t
    it feel like now it would be great to create all the Bootstrap components as Vue
    components and just use them in our Vue applications without having to think about
    Bootstrap classes whatsoever? Imagine Vue components such as `<button-success></button-success>`
    or `<button :type="success"></button>`. We could even create a whole library of
    Vue components based on Bootstrap! The question is, should we do it if it already
    exists? Yes, someone has already done all the work for us. These are the people
    who have done the work:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: '![Combining Vue.js and Bootstrap continued](../images/00051.jpeg)'
  id: totrans-383
  prefs: []
  type: TYPE_IMG
- en: Core team of bootstrap-vue
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: These nice people have developed something called Bootstrap-Vue and that's something
    that does exactly what you think—it contains a full set of Bootstrap components
    implemented as Vue.js components. Check it out at [https://bootstrap-vue.github.io/](https://bootstrap-vue.github.io/).
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: Let's check, for example, how the alert component is implemented at [https://bootstrap-vue.github.io/docs/components/alert](https://bootstrap-vue.github.io/docs/components/alert).
    It's a little bit more detailed than our alert. The data is passed within the
    component's tags and not as properties, like in our case, which also makes it
    more flexible. We will use it a lot while developing our application throughout
    the book.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: What is Firebase?
  id: totrans-387
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To understand what is Firebase let''s open its website [https://firebase.google.com/](https://firebase.google.com/).
    This is what we see:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: '![What is Firebase?](../images/00052.jpeg)'
  id: totrans-389
  prefs: []
  type: TYPE_IMG
- en: Google Firebase landing page
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: Firebase for Google is yet another cloud service, like AWS for Amazon or Azure
    for Microsoft, a bit simpler though, because Google already has Google Cloud Platform,
    which is huge.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: If you feel like you want to choose between Firebase and AWS, do not forget
    that you will most likely Google it. In any case, someone has already done this
    for you so here you have this question on Quora at [https://www.quora.com/Which-is-better-cloud-server-Amazon-AWS-or-Firebase](https://www.quora.com/Which-is-better-cloud-server-Amazon-AWS-or-Firebase).
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: I would say that it's more similar to Heroku—it allows you to easily deploy
    your applications and integrate them with analytics tools. If you have read the
    Learning Vue.js 2 book ([https://www.packtpub.com/web-development/learning-vuejs-2](https://www.packtpub.com/web-development/learning-vuejs-2)),
    then you already know how much I love Heroku. I even have Heroku socks!
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: '![What is Firebase?](../images/00053.jpeg)'
  id: totrans-394
  prefs: []
  type: TYPE_IMG
- en: My beautiful Heroku socks
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: 'However, I find Google Firebase console also quite nice and simple to use.
    It also provides a backend as a service. This backend is shared for your web and
    mobile applications, which comes as a huge help when developing cross-platform
    and cross-device applications. Firebase provides the following services:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: '**Authentication**: This uses Firebase API for authenticating users using different
    providers (Facebook, Google, e-mail, and so on).'
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Database**: This uses Firebase database API to store and retrieve your data.
    No need to choose between different database providers, and no need to establish
    connection. Just use the API out of the box.'
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hosting**: This hosts and deploys your application using simple shell commands.'
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Storage**: This hosts static files using a simple API.'
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Again, if you think about how to integrate your Vue application with Firebase
    APIs, stop thinking about it because someone has already done the job for you.
    After creating your project using the Firebase console, you can simply use a `vuefire`
    wrapper for Firebase to connect to your database and fetch your data. Check it
    out at [https://github.com/vuejs/vuefire](https://github.com/vuejs/vuefire). Actually,
    this is exactly what we did in our `PleaseIntroduceYourself` application from
    the first chapter. Check out the code that is located inside the `App.vue` component:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Everything that is exported in the Firebase object becomes accessible via the
    `this` keyword, the same way as we access the `data` or `computed` properties.
    We will use `vuefire` in the application that we will develop throughout the book
    to better understand how it works.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-404
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we familiarized ourselves with Vue.js, Bootstrap and Firebase.
    We have also analyzed tools that integrate Vue.js with Bootstrap and Vue.js with
    Firebase.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: Thus, now, we are familiar with Vue.js applications that are built using single-file
    components, Bootstrap's grid system, components, and CSS helpers to make our lives
    easier and to make Google Firebase console with its possibilities.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: Also, we know how to initialize Vue.js project, and use Vue directives, components,
    store and routing.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: You also learned how to leverage Bootstrap's grid system to achieve the responsibility
    of our application's layout.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: And last but not least, you learned how to use the Firebase API within the Vue
    application using `vuefire` bindings.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: With the end of this chapter, the first introduction part of our journey also
    comes to an end.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will actually dive deep inside the implementation. As
    a scuba diving tank, we will take everything that you have learned so far!
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we will start developing the application that we will build during the
    whole book until it''s ready for deployment. We will:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: Define what the application will do and its requirements
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define whom we are building the application for
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build basic mockups for the application
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scaffold the application using Vue command-line interface
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Are you as excited as much as I am? Then, let's go to the next chapter!
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
