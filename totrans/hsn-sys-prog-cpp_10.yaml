- en: Programming POSIX Sockets Using C++
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you will learn how to program POSIX sockets using C++17, including
    more common C++ paradigms, such as **Resource Aquisition Is Initialization** (**RAII**).
    To begin with, this chapter will discuss what a socket is, and the difference
    between UDP and TCP. The POSIX APIs will be explained in detail prior to walking
    you through five different examples. The first example will step you through programming
    with POSIX sockets by creating a UDP echo server example. The second example will
    create this same example using TCP instead of UDP and explain the differences.
    The third example will expand upon our existing debug logger that has been created
    in previous chapters, while the fourth and fifth examples will explain how to
    safely process a packet.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: POSIX sockets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leveraging C++ and RAII with sockets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TCP vs UDP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to compile and execute the examples in this chapter, the reader must
    have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A Linux-based system capable of compiling and executing C++17 (for example,
    Ubuntu 17.10+)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GCC 7+
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CMake 3.6+
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An internet connection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To download all of the code in this chapter, including the examples, and code
    snippets, please see the following link: [https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/tree/master/Chapter10](https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/tree/master/Chapter10).
  prefs: []
  type: TYPE_NORMAL
- en: Beginning with POSIX sockets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unfortunately, C++ does not contain a native networking library (something that
    will hopefully be addressed with C++20). For this reason, POSIX sockets are needed
    to perform networking with C++.  The POSIX sockets API defines an API for sending
    and receiving network packets using the standard, Unix file-descriptor paradigm.
    When programming with sockets, both a server and a client must be created. Servers
    are responsible for binding a specific port to the socket protocol that is being
    developed by the user of the sockets library. Clients are any other application
    that is connected to a previously-bound port. Both servers and clients have their
    own IP addresses.
  prefs: []
  type: TYPE_NORMAL
- en: When programming sockets, besides picking address types, such as IPv4 versus
    IPv6, typically the programmer must also choose between UDP versus TCP. UDP is
    a connectionless protocol that provides no assurances that a packet is reliably
    sent, with the advantage being speed and simplicity. UDP is commonly used for
    data that does not have to be received 100% of the time, such as your position
    in a video game. TCP, on the other hand, is a connection-based protocol that ensures
    all packets are received in the order they are sent and is the typical protocol
    used for its reliability.
  prefs: []
  type: TYPE_NORMAL
- en: Beginning with APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following sections will explain, in detail, the different socket APIs.
  prefs: []
  type: TYPE_NORMAL
- en: The socket() API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All POSIX socket programming starts with the creation of a socket file descriptor
    using the `socket()` API, which takes the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The domain defines the address type used when creating the socket. In most cases,
    this would be `AF_INET` for IPv4 or `AF_INET6` for IPv6\. In the case of our examples
    in this chapter, we will use `AF_INET.` The type field usually takes on `SOCK_STREAM`
    for a TCP connection or `SOCK_DGRAM` for a UDP connection, both of which will
    be demonstrated in this chapter. Finally, the protocol field in this API will
    be set to `0` in all of our examples, telling the API to use the default protocol
    for whichever socket type is specified.
  prefs: []
  type: TYPE_NORMAL
- en: 'Upon completion of this API, a socket file descriptor is returned, which will
    be needed by the remaining POSIX APIs. If this API fails, `-1` is returned, and
    `errno` is set to an appropriate error code. It should be noted that `errno` is
    not thread-safe and its use should be handled with care. A great way to handle
    these types of errors is to immediately convert the `errno` into a C++ exception,
    which can be done using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, an IPv4 TCP socket is created. The resulting file
    descriptor is saved into a memory variable, `m_fd`. Using C++17 syntax, the file
    descriptor is checked for validity, and if an error is reported (that is, `-1`),
    an exception is thrown. To provide a human-readable version of the error, `errno` is
    converted into a string using `strerror()`. Not only does this provide a string
    version of `errno`, it also ensures that the process of recording the error doesn't
    change `errno` in the process, which can happen if a more complicated approach
    is used.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, when the socket is no longer needed, it should be closed like any other
    file descriptor using the POSIX `close()` function. It should be noted that most
    POSIX operating systems will automatically close sockets that are still open when
    the application closes.
  prefs: []
  type: TYPE_NORMAL
- en: 'To prevent possible descriptor leaks, the socket file descriptor may be encapsulated
    in a class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we open an IPv4 TCP socket using the logic in the
    prior example, ensuring any errors are detected and properly reported. The difference
    is that we store the file descriptor as a member variable, and when `mytcpsocket{}`
    loses scope, we automatically ensure the file descriptor is properly released
    back to the operating system. Any time the file descriptor is needed, the `descriptor()`
    accessor may be used.
  prefs: []
  type: TYPE_NORMAL
- en: The bind() and connect() APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once a socket file descriptor is created, the socket must be bound, or connected,
    depending on whether the socket is creating the connection (the server), or is
    connecting to an existing bound socket (client). When communicating via TCP or
    UDP, binding a socket dedicates a port for the socket. Ports `0`-`1024` are reserved
    for specific services and are often managed by the operating system (requiring
    special privileges to bind). The remaining ports are user-defined and often may
    be bound without privileges. Determining which port to use is dependent on the
    implementation. Some ports are predetermined for a specific application, or the
    application can ask the operating system for an open port to use, which has the
    added complication of communicating this newly-allocated port to potential client
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `bind()` API takes the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `socket` integer parameter is the socket file descriptor that was previously
    provided by the `socket()` API. The `address` parameter tells the operating system
    which port to bind to, and which IP address to accept incoming connections from,
    usually `INADDR_ANY` which tells the operating system that an incoming connection
    may be accepted from any IP address. Finally, the `address_len` parameter tells
    the API what the total size of the address structure is.
  prefs: []
  type: TYPE_NORMAL
- en: 'The total size (in bytes) is needed for the address structure because different
    structures are supported depending on the socket type you''re using. For example,
    an IPv6 socket has a larger IP address compared to an IPv4 socket. In this chapter,
    we will discuss IPv4, which uses the `sockaddr_in{}` structure, which defines
    the following fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sin_family`: This is identical to the socket domain, which, in the case of
    IPv4, is `AF_INET`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sin_port`: This defines the port to bind to, which must be converted into
    network byte order using `htons()`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sin_address`: This defines the IP address to accept incoming connections from,
    which must also be converted into network byte order using `htonl()`. Often, this
    is set to `htonl(INADDR_ANY)`, indicating connections are accepted from any IP
    address.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since the address structure is variable in length, the `bind()` API takes a
    pointer to an opaque structure type and uses the length field to ensure the proper
    information was provided. It should be noted that this type of API is not encouraged
    by the C++ Core Guidelines as there is no type-safe way of implementing this API.
    In fact, in order to use this API, `reinterpret_cast()` is needed to convert a `sockaddr_in{}`
    to the opaque `sockaddr{}` structure. Although the use of `reinterpret_cast()`
    is not supported by the C++ Core Guidelines, there is no alternative and therefore
    if sockets are needed, this rule must be broken.
  prefs: []
  type: TYPE_NORMAL
- en: 'While servers use `bind()` to dedicate a port for the socket, clients use `connect()`
    to connect to an already-bound port. The `connect()` API has the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'It should be noted that the parameters for `connect()` are identical to `bind()`.
    Like `bind()`, you must provide the file descriptor returned by the call to `socket()`,
    and like `bind()`, you must provide, in the case of IPv4, a pointer to a `sockaddr_in{}`
    structure as well as the size of the `sockaddr_in{}` structure. When filling out
    the `sockaddr_in{}` structure, you would use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sin_family`: This is identical to the socket domain, which, in the case of
    IPv4, is `AF_INET`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sin_port`: This defines the port to connect to, which must be converted into
    network byte order using `htons()`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sin_address`: This defines the IP address to connect to, which must also be
    converted into network byte order using `htonl()`. For loopback connections, this
    would be set to `htonl(INADDR_LOOPBACK)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, both `bind()` and `connect()` return `0` on success or `-1` on failure,
    setting `errno` in the event of an error.
  prefs: []
  type: TYPE_NORMAL
- en: The listen() and accept() APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For TCP servers, two additional APIs exist that provide the server with a means
    to listen for and accept incoming TCP connections—`listen()` and `accept()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `listen()` API has the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The socket parameter is the file descriptor returned by the `socket()` API,
    and the backlog parameter limits the total number of outstanding connections that
    may be made. In the examples in this chapter, we will use a backlog of `0`, which
    tells the API to use an implementation-specific value for the backlog.
  prefs: []
  type: TYPE_NORMAL
- en: If `listen()` succeeds, `0` is returned, otherwise `-1` is returned and `errno`
    is set to the appropriate error code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once your application is set up to listen for incoming connections, the `accept()`
    API may be used to accept a connection once it is ready. The `accept()` API has
    the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Like the other APIs, the `socket` parameter is the file descriptor returned
    by the `socket()` API and the address, and the `address_len` parameter returns
    information about the connection. `nullptr` may also be provided for both the
    address and `address_len` if the connection information is not needed. Upon successful
    completion of the `accept()` API, a socket file descriptor for the client connection
    is returned, which may be used to send and receive data to and from the client.
  prefs: []
  type: TYPE_NORMAL
- en: If accept fails to execute, instead of a valid socket file descriptor being
    returned, `-1` is returned, and `errno` is set appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: It should be noted that both `listen()` and `accept()` are only needed for TCP
    connections. With a TCP connection, the server creates two or more socket descriptors;
    the first one is used to bind to a port and listen for connections, while the
    second one is the socket file descriptor for the client, which is used to send
    and receive data. UDP, on the other hand, is a connectionless protocol and thus
    the same socket that is used to bind to a port is also used to send and receive
    data with the client.
  prefs: []
  type: TYPE_NORMAL
- en: The send(), recv(), sendto(), and recvfrom() APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To send information to a server or client after opening a socket, POSIX provides
    the `send()` and `sendto()` APIs. The `send()` API has the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The first parameter is the socket file descriptor for the server or client you
    wish to send data to. It should be noted that the socket must be connected to
    a specific client or server to work (such as communicating back to a server, or
    to a client opened using TCP). The `buffer` parameter points to the buffer you
    wish to send, `length` defines the length of the buffer you wish to send, and
    `flags` provides various different settings for how you wish to send the buffer,
    which in most cases is just set to `0`. It should also be noted that when `flags` is
    set to `0`, there is typically no difference between the `write()` function and
    the `send()` function, and both may be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'If a server is attempting to communicate with a client using UDP, the server
    won''t know who or how to send information to the client as the server binds to
    a specific port, not to a specific client. Likewise, if a client using UDP doesn''t
    connect to a specific server, it will not know who or how to send information
    to the server. For this reason, POSIX provides `sendto()`, which adds the `sockaddr{}`
    structure to define who and how you wish to send the buffer. `sendto()` has the
    following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The only difference between `send()` and `sendto()` is that `sendto()` also
    provides the destination `address` and `len` parameters, which provide the user
    with a way to define who the buffer is sent to.
  prefs: []
  type: TYPE_NORMAL
- en: 'To receive data from a client or server, POSIX provides the `recv()` API, which
    has the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `recv()` API takes the same parameters as the `send()` API, with the difference
    being that the buffer will be written to (which is why it's not labeled `const`)
    when data is received, and the length field describes the total size of the buffer
    and not the total number of bytes received.
  prefs: []
  type: TYPE_NORMAL
- en: 'Likewise, POSIX provides a `recvfrom()` API, which is similar to the `sendto()`
    API and has the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Both the `send()` and `sendto()` functions return the total number of bytes
    that were sent, while the `recv()` and `recvfrom()` functions return the total
    number of bytes received. All of these functions return `-1` and set `errno` to
    an appropriate value in the event of an error.
  prefs: []
  type: TYPE_NORMAL
- en: Studying an example on the UDP echo server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this example, we will walk you through a simple echo server example using
    UDP. An echo server (as is the same with our previous chapters) echoes any input
    to its output. In the case of this UDP example, the server echoes data sent to
    it from a client back to the client. To keep the example simple, character buffers
    will be echoed. How to properly process structured packets will be covered in
    the following examples.
  prefs: []
  type: TYPE_NORMAL
- en: Server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To start, we must define the maximum buffer size we plan to send from the client
    to the server and back, and we must also define the port we wish to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'It should be noted that any port number will do so long as it is above `1024`,
    to prevent the need for privileges. In this example, the following includes are
    needed for the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The server will be defined using a class to take advantage of RAII, providing
    a clean method for closing the socket opened by the server when it is no longer
    needed. We also define three private member variables. The first variable will
    store the socket file descriptor that the server will use throughout the example.
    The second variable stores the address information of the server, which will be
    provided to the `bind()` function, while the third parameter stores the address
    information of the client, which will be used by the `recvfrom()` and `sendto()`
    functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The constructor of the server will open the socket and bind the provided port
    to the socket, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The socket is opened using `AF_INET`, which tells the socket API that IPv4 is
    desired. Additionally, `SOCK_DGRAM` is provided, which tells the socket API that
    UDP is desired instead of TCP. The result of the call to `::socket()` is saved
    into the `m_fd` variable, which stores the servers socket file descriptor. Leveraging
    C++17, if the resulting file descriptor is `-1`, an error occurred, and we throw
    the error, which will be recovered later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we fill in a `sockaddr_in{}` structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sin_family` is set to `AF_INET` to match the socket, telling the socket API
    we wish to use IPv4.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sin_port` is set to the port number, and `htons` is used to convert host byte
    order into network byte order for a short.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sin_addr` is set to `INADDR_ANY`, which tells the socket API that the server
    will accept data from any client. Since UDP is a connectionless protocol, this
    means we may receive data from any client if desired.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, a call to a member function, called `bind()`, is made and the result
    is checked for an error. If an error occurs, an exception is thrown.
  prefs: []
  type: TYPE_NORMAL
- en: 'The bind function is nothing more than a wrapper around the `::bind()` socket
    API, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, we call `bind` with the socket file descriptor
    that is opened in the constructor of our server class, and we provide the `bind`
    API with the port and address that was also initialized in the constructor prior
    to calling this function, which tells the socket to bind to port `22000` and any
    IP address.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the socket has been bound, the server is ready to receive data from a
    client. Since we bound the socket to any IP address, any client can send us information.
    We could use the `recv()` POSIX API for this, but the problem with this approach
    is that once we receive data, we will not know who sent us the information. This
    is fine if we don''t need to send that client any information in return, or we
    embed the client information in the data received, but in the case of a simple
    echo server, we need to know who to echo the data to. To solve this problem, we
    use `recvfrom()` instead of `recv()`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The first parameter is the socket file descriptor that was created during construction,
    while the second and third parameters are the buffer and its maximum size. Note
    that our `recv()` member function takes `std::array` instead of a pointer and
    a size, as a pointer and a size parameter would not be C++-Core-compliant because
    doing so provides an opportunity for error in reporting the actual size of the
    array. The last two parameters are a pointer to a `sockaddr_in{}` structure and
    its size.
  prefs: []
  type: TYPE_NORMAL
- en: It should be noted that in our example we provide `recvfrom()` with a `sockaddr_in{}`
    structure, as we know that the client that will be connecting will use an IPv4
    address. If this is not the case, the `recvfrom()` function will fail, as we will
    have provided it with a structure that is too small to provide, say, an IPv6 address
    if it is used. To overcome this issue, you may use `sockaddr_storage{}` instead
    of `sockaddr_in{}`. The `sockaddr_storage{}` structure is large enough to store
    an incoming address type. To determine which address type you received, the `sin_family`
    field may be used, which is required in all of the structures.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we return the result of the call to `recvfrom()`, which could either
    be the number of bytes received, or `-1` in the event of an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'To send a buffer to a client that connects to the UDP server, we use the `sendto()`
    API, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'As with the other APIs, the first parameter is the socket file descriptor that
    was opened in the constructor. The buffer is then provided. The difference between
    `recvrom()` and `sendto()` in this case is that the number of bytes to send is
    provided instead of the total size of the buffer. This doesn''t break C++ Core
    Guidance as the total size of the buffer is still attached to the buffer itself,
    and instead the number of bytes to send is a second value used to determine how
    far into an array we plan to address. We do, however, need to ensure the length
    field is not out of range. This could be done using a call to `Expects()`, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In the case of this example, we explicitly check for an out-of-range error and
    throw a more verbose error if this should occur. Either approach would work.
  prefs: []
  type: TYPE_NORMAL
- en: As with the `recvfrom()` call, we provide the `sendto()` API with a pointer
    to a `sockaddr_in{}` structure, which tells the socket which client to send data
    to. In this case, since the API does not modify the address structure (and thus
    the structure cannot change in size), a pointer to the length field is not needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to put all of these together to create the echo server itself,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The echo server is designed to receive a buffer of data from a client, send
    it back to the same client, and repeat. To start, we create an infinite loop that
    is capable of echoing data from any client until we are told the client has disconnected.
    The next step is to define a buffer that will be used to both send and receive
    data to the client. We then call the `recv()` member function and provide it with
    the buffer we wish the receive function to fill in with data from the client and
    check whether the number of bytes returned from the client is greater than `0`.
    If the number of bytes returned from the client is greater than `0`, we use the
    `send` member function to send (or echo) the buffer back to the client. If the
    number of bytes is `0`, we assume the client has disconnected as a result, and
    we stop the infinite loop, which in turn completes the echo process.
  prefs: []
  type: TYPE_NORMAL
- en: The client-information structure (that is, `m_client`) is provided to both the
    `recvfrom()` and `sendto()` POSIX APIs. This is done intentionally. The only assumption
    we are making is that all clients connecting will use IPv4\. The `recvfrom()`
    function will fill in the `m_client` structure for us when data is received from
    a client, telling us who the client was that sent us the information. We then
    provide this same structure back to the `sendto()` function to tell the API who
    to echo the data to.
  prefs: []
  type: TYPE_NORMAL
- en: 'As stated before, when the server class is destroyed we close the socket, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we complete the server by instantiating the server in a `protected_main()`
    function, and then begin echoing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: As shown, the `main` function is protected from possible exceptions, and in
    the `protected_main()` function, we instantiate the server and call its `echo()`
    member function, which starts the infinite loop for echoing client data.
  prefs: []
  type: TYPE_NORMAL
- en: The client logic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this example, the following includes are needed for the client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Like the server, the client is created using a class to take advantage of RAII:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In addition to the class definition, two private member variables are defined.
    The first, like the server, is the socket file descriptor that will be used by
    the client. The second defines the address information for the server the client
    desires to communicate with.
  prefs: []
  type: TYPE_NORMAL
- en: 'The constructor of the client is similar to the server''s, with some minor
    differences:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Like the server, the client creates a socket file descriptor for IPv4 by using
    `AF_INET` and the protocol type is set to UDP by using `SOCK_DGRAM`. If the `socket()`
    API returns an error, an exception is thrown. The `sockaddr_in{}` structure that
    is set up is different from the server. The server's `sockaddr_in{}` structure
    defines how the server will bind the socket, while the client `sockaddr_in{}`
    structure defines what server the client will connect to. In the case of this
    example, we set the address to `INADDR_LOOPBACK` as the server will be running
    on the same computer. Finally, the `connect()` member function is called, which
    connects to the server, and if an error occurs, an exception is thrown.
  prefs: []
  type: TYPE_NORMAL
- en: 'To connect to the server, the following `connect()` member function is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: It should be noted that connecting to a server with UDP is optional as UDP is
    a connectionless protocol. The `connect` function, in this case, tells the operating
    system which server you plan to communicate with such that `send()` and `recv()`
    may be used, instead of `sendto()` and `recvfrom()` on the client side. Like the
    `bind()` member function for the server, the `connect()` function leverages the
    `sockaddr_in{}` structure filled in by the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'To send data to the server to be echoed, the following `send()` member variable
    is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we plan to send the server a string, we pass the `send()` member function
    a string reference. The `send()` POSIX API is then given the socket file descriptor
    created in the constructor, the buffer to send to the server to be echoed, and
    the total length of the buffer being sent. Since we don''t use the `flags` field,
    the `send()` member function could also be written using the `write()` function,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'To receive data from the server after it has been echoed, we use the following
    `recv()` member function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: There are many ways to implement the `recv()` member function. Since we know
    the total size of the string being sent to the server, and we know the server
    will echo the same-sized string back to us, we could always create a second string
    the same size as the first (or simply reuse the original string if you trust echo
    actually is occurring). In the case of this example, we create a receive buffer
    with a specific maximum size to demonstrate a more likely scenario. As a result,
    in this example, we can send any size string we wish, but the server has its own,
    internal maximum buffer size that it can accept. The server will then echo the
    data back to the client. The client itself has its own maximum-sized receive buffer,
    which ultimately limits the total number of bytes that may be echoed. Since the
    client is echoing strings, we must reserve one byte for a trailing `'\0'` to null
    terminate any string that is received by the client that fills the entire receive
    buffer.
  prefs: []
  type: TYPE_NORMAL
- en: 'To send and receive data to and from the server, we create an `echo` function,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The `echo` function, like the server, first creates an infinite loop so that
    it can send multiple strings to the server to be echoed. Inside the infinite loop,
    two buffers are created. The first is the string that will take in user input.
    The second defines the receive buffer to be used. Once the buffers are defined,
    we use `std::cin` to get from the user the string to be sent to the server (which
    will ultimately be echoed).
  prefs: []
  type: TYPE_NORMAL
- en: If the string is the word `exit`, we send 0 bytes to the server and exit the
    infinite loop. Since UDP is a connectionless protocol, the server has no way of
    knowing whether the client has disconnected because no such construct exists.
    Therefore, without sending a signal to the server to stop (in this case we send
    0 bytes), the server would stay in an infinite loop as it has no way of knowing
    when to stop. In this example, this poses an interesting problem because if the
    client crashes or is killed (for example, with *Ctrl* + *C*), the server will
    never be given the 0 byte signal, and thus remain in an infinite loop. There are
    many ways to solve this issue (that is, by sending a keep-alive signal), but once
    you go down the path of trying to solve this problem, you quickly end up with
    a protocol that is so similar to TCP, you might as well use TCP.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the user-inputted buffer is sent to the server using the `send()` member
    function, the server echoes the string, and then the client then receives the
    string using the `recv()` member function. Once the string is received, the data
    is output to `stdout` using `std::cout`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like the server, when the client class is destroyed, the socket file descriptor
    is closed, closing the socket:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the client is created using the same `protected_main()` function as
    the server and our previous examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the client is instantiated in the `protected_main()`
    function, and the `echo` function is called, which accepts user input, sends the
    input to the server, and outputs any echoed data to `stdout`.
  prefs: []
  type: TYPE_NORMAL
- en: Compiling and testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To compile this code, we leverage the same `CMakeLists.txt` file that we have
    been using for the other examples: [https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/blob/master/Chapter10/CMakeLists.txt](https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/blob/master/Chapter10/CMakeLists.txt).
  prefs: []
  type: TYPE_NORMAL
- en: 'With this code in place, we can compile this code using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'To execute the server, run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'To execute the client, open a new terminal and run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the preceding snippet, when the client is executed, and input is
    entered, the input is echoed back to the terminal. Once complete and the word
    `exit` is entered, the client exits. Also the server will exit when the client
    is complete. To demonstrate the connection issue with UDP, instead of entering
    `exit`, hit *Ctrl *+ *C* on the client—the client will exit but the server will
    continue to execute, waiting for more input from the client as it will not know
    the client has completed. To solve this issue, out next example will create the
    same echo server but using TCP instead.
  prefs: []
  type: TYPE_NORMAL
- en: Studying an example on the TCP echo server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this example, we will walk the reader through creating an echo server, but
    using TCP instead of UDP. Just like with the previous example, an echo server
    echoes any input to its output. Unlike the UDP example, TCP is a connection-based
    protocol, and thus some of the specifics of how to establish a connection and
    send/receive data are different in this example.
  prefs: []
  type: TYPE_NORMAL
- en: Server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To start, we must define the maximum buffer size we plan to send from the client
    to the server and back, and we must also define the port we wish to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'For the server, we will need the following includes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'As with the previous examples, we will create the server using a class to take
    advantage of RAII:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: As with UDP, three member variables will be used. The first member variable,
    `m_fd`, stores the socket file descriptor for the socket associated with the server.
    Unlike UDP, this descriptor will not be used to send/receive data with a client.
    Instead, `m_client` represents a second socket file descriptor that will be used
    to send/receive data with the client. Like with UDP, the `sockaddr_in{}` structure,
    `m_addr`, will be filled in with the server address type, which will be bound.
  prefs: []
  type: TYPE_NORMAL
- en: 'The constructor for the server is similar to the UDP example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Like the UDP example, a socket file descriptor for the server is created, but
    instead of `SOCK_DGRAM` being used, `SOCK_STREAM` is used instead. The `sockaddr_in{}`
    structure is identical to the UDP example with IPv4 being used (that is, `AF_INET`),
    the port, and any IP address being used to signal that connections from any IP
    address will be accepted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like the UDP example, the `sockaddr_in{}` structure is then bound using the
    following member function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The preceding `bind()` function is identical to the `bind()` function used in
    the UDP example.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike UDP, a second, client-specific socket descriptor is created, and the
    IP address, port, and address type are all set for that socket type, meaning communicating
    with the client does not require `sendto()` or `recvfrom()` since we have a specific
    socket file descriptor that already has this additional information bound to it.
    For this reason, `send()` and `recv()` may be used instead of `sendto()` and `recvfrom()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To receive data from the client, the following member function will be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The only difference between the UDP example and this example is the use of `recv()`
    instead of `recvfrom()`, which omits the additional `sockaddr_in{}` structure.
    If you recall from the previous UDP example, `m_fd` was used with `recvfrom()`
    instead of `m_client` with `recv()`. The difference is that `m_client` in the
    UDP example is a `sockaddr_in{}` structure that defines who to receive data from.
    With TCP, `m_client` is instead a socket descriptor, and who to receive data from
    is bound to the descriptor, which is why the additional `sockaddr_in{}` structure
    is not needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same is also true for the `send()` member function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Unlike in the UDP example, the preceding `send()` function may use the `send()`
    POSIX API instead of `sendto()`, as the address information about who and how
    to send data to the client is bound to the descriptor and, as such, the additional
    `sockaddr_in{}` information may be omitted. The rest of the `send()` function
    is identical to the UDP example.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `echo` function is quite a bit different from its UDP counterpart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Since TCP requires connections, the first step in the `echo` function for the
    server is to tell the POSIX API that you wish to begin listening for incoming
    connections. In our example, we tell the API to use the default connection backlog,
    which is implementation-specific, by setting the backlog to `0`. The next step
    is to wait for an incoming connection from a client using the `accept()` POSIX
    API. By default, this function is a blocking function. The `accept()` function
    returns a socket file descriptor with the address information bound to the descriptor
    and as a result, we pass `nullptr` to the address fields in the `accept()` POSIX
    API as this information is not needed in our example (but might be needed if you,
    for example, need to filter certain incoming clients).
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to wait for data to be received by the client and then echo
    that data back to the client using the `send()` member function. This logic is
    identical to the UDP example. It should be noted that if we receive `0` bytes
    from the client, we stop processing data from the client, similar to what was
    done with UDP. The difference is that, as will be shown, on the client side, we
    do not need to explicitly send 0 bytes to the server for this condition to occur.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last step in the `echo` function is to close the client socket file descriptor
    once the client has finished:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'As with the other examples, we close the server''s socket file descriptor when
    the server class is destroyed. Finally, the server is instantiated in a `protected_main()`
    function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Like the UDP example, the server is instantiated, and the `echo()` function
    is executed.
  prefs: []
  type: TYPE_NORMAL
- en: The client logic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The client logic is similar to the UDP client logic with a few minor exceptions.
    The following includes are needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like with the UDP example, a client class is created to leverage RAII,
    and the `m_fd` and `m_addr` private member variables are defined to store the
    socket file descriptor for the client, and the address information for the server
    the client wishes to connect to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Unlike the UDP example, but like the TCP server logic, the constructor creates
    a socket for IPv4 and TCP using both `AF_INET` and `SOCK_STREAM`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The rest of the constructor is identical to the UDP example, as are the `connect()`,
    `send()`, and `recv()` functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in the preceding snippet, the client functions almost exactly the
    same as a UDP client. The difference between a UDP client and a TCP client, other
    than the use of `SOCK_STREAM`, lies in the implementation of the `echo` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Unlike the UDP example, the TCP client does not need to check for the `exit` string.
    This is because if the client disconnects (for example, *Ctrl *+ *C* is used to
    kill the client), `0` bytes are received on the server side, telling the server
    logic the client has been disconnected. This is possible because TCP is a connection-based
    protocol, and thus, the operating system is maintaining an open connection, including
    keep-alive signals between the server and the client so that the user of the API
    doesn''t have to do this explicitly. For this reason, in most cases, this is the
    desired socket type, as it prevents a lot of common problems with connection status:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in the preceding code, like all of the other examples, when the client
    is destroyed, the socket file descriptor is closed, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Finally, the client is instantiated in a `protected_main()` function, and the
    `echo` function is called.
  prefs: []
  type: TYPE_NORMAL
- en: Compiling and testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To compile this code, we leverage the same `CMakeLists.txt` file that we have
    been using for the other examples: [https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/blob/master/Chapter10/CMakeLists.txt](https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/blob/master/Chapter10/CMakeLists.txt).
  prefs: []
  type: TYPE_NORMAL
- en: 'With this code in place, we can compile this code using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'To execute the server, run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'To execute the client, open a new terminal and run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the preceding snippet, when the client is executed, and input is
    entered, the input is echoed back to the terminal. Once complete, and *Ctrl *+
    *C* is entered, the client exits. As you can see, the server will exit when the
    client is complete. The preceding example demonstrates the ease of use of TCP,
    and its advantages over UDP. The next example will demonstrate how to use TCP
    for something more useful.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring an example on TCP Logger
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To demonstrate something more useful, the following example implements the same
    logger that we have been developing throughout this book, but as a remote logging
    facility.
  prefs: []
  type: TYPE_NORMAL
- en: Server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The same macros and includes are needed for this example as with the previous
    examples in this chapter. To start the server, we must define the log file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Since the logger will be executing on the same computer to keep the example
    simple, we will name the file the server is logging to as `server_log.txt`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The server is identical to the TCP server in the previous example, with the
    exception that only a `recv()` member function is needed (that is, there is no
    need for a `send()` function as the server will only be receiving log data):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The difference between the previous TCP example and this example is the use
    of the `log()` function instead of the `echo` function. Both functions are similar
    in that they listen for an incoming connection and then loop infinitely until
    data is received by the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: The difference with the `log` function is that when data is received by the
    client, instead of echoing the data back to the server, the data is output to
    `stdout` and written to the `server_log.txt` log file.
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown here, the rest of the server logic is the same as the previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The socket file descriptor is closed when the server object is destroyed, the
    server is instantiated in a `protected_main()` function, and the `log()` function
    is then executed.
  prefs: []
  type: TYPE_NORMAL
- en: The client logic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The client logic for this example is a combination of the debug examples in
    previous chapters (which we have been building upon) and the previous TCP example.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by defining the debug level and enable macros, as with previous examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'The client class is identical to the client class in the previous TCP example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: The only difference between the client in this example and the client in the
    previous example is that in this example, there is no need for a `recv()` function
    (as no data is being received from the server), and there is no need for the `echo()`
    function (or anything similar) as the client will be used directly to send data
    to the server as needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with the previous debug example, a log file for the client is needed, and
    in this example, we will also globally instantiate the client, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: As shown, the client log file will be named `client_log.txt`, to prevent a collision
    with the server log file as both will be running on the same computer to simplify
    the example.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `log` function is identical to the `log` function defined in [Chapter 8](da2d2789-8a5d-4da0-b374-668d06e322ec.xhtml), *Learning
    to Program File Input/Output,* with the exception that in addition to logging
    to `stderr` and the client-side log file, the debug string will also be logged
    to the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: As shown in preceding code, the `log` function encapsulates any output to `std::clog`,
    and redirects the resulting string to `stderr`, the log file, and for the purpose
    of this example, to the client object that sends the string to the server to be
    logged on the server side.
  prefs: []
  type: TYPE_NORMAL
- en: 'The remaining portion of the example is identical to the previous examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: The `protected_main()` function outputs `Hello World\n` to `stderr`, which is
    redirected to include `stderr`, the log file, and finally sent to the server.
    Another call to `std::clog` is made to show that only calls to `std:clog` that
    are encapsulated in the `log()` function are redirected.
  prefs: []
  type: TYPE_NORMAL
- en: Compiling and testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To compile this code, we leverage the same `CMakeLists.txt` file that we have
    been using for the other examples: [https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/blob/master/Chapter10/CMakeLists.txt](https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/blob/master/Chapter10/CMakeLists.txt).
  prefs: []
  type: TYPE_NORMAL
- en: 'With this code in place, we can compile this code using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'To execute the server, run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'To execute the client, open a new terminal and run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in the preceding snippet, when the client is executed, the client
    and server side both output `DEBUG: Hello World` to `stderr.` In addition, the
    client outputs `Hello World` to `stderr` as the second call to `std::clog` is
    not redirected. Finally, both log files contain the redirected `DEBUG: Hello World`.'
  prefs: []
  type: TYPE_NORMAL
- en: In all of the examples so far, the one thing that has been ignored is what happens
    if more than one client attempts to connect to the server. In the examples in
    this chapter, only one client is supported. To support additional clients, threading
    is needed, which will be covered in [Chapter 12](3bc6e6a9-5b8d-46b1-aeae-8d6b07c3ad18.xhtml),
    *Learning to Program POSIC and C++ Threads *where we will expand upon this example
    to create a logging server capable of logging the debug output of more than one
    application. The final two examples in this chapter will demonstrate how to process
    non-string data packets using TCP.
  prefs: []
  type: TYPE_NORMAL
- en: Trying out an example for processing packets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this example, we will discuss how to process the following packet from the
    client to the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: The packet consists of some fixed-width integer data and a string (fields in
    a network must always be fixed width, as you might not have control of the type
    of computer your application is running on and non-fixed width types, such as
    `int` and `long`, might change depending on the computer).
  prefs: []
  type: TYPE_NORMAL
- en: This type of packet is common among many programs, but as will be demonstrated,
    this type of packet has challenges with respect to safely parsing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The server is identical to the previous TCP examples, minus the `recv_packet()`
    function (and the `recv()` function processes packets instead of `std::arrays`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: In the `recv_packet()` function, we wait to receive data from the client. Once
    the packet is received from the client, we parse the packet received. The integer
    data associated with the packet is read and output to `stdout` without issue.
    The string data, however, is more problematic. Since we don't know the total size
    of the string data being received, we must account for the entire buffer to safely
    process the string, and in a sense, maintain type-safety. Of course, in our example,
    to reduce the total size of the packet, we could have placed the integer data
    first in the packet, and then created a variable length packet, but this is both
    unsafe and hard to control or accomplish in more complicated scenarios. Most attempts
    to solve this problem (of having to send and receive more data than is actually
    needed) result in an operation that is variable in length, and thus, unsafe.
  prefs: []
  type: TYPE_NORMAL
- en: 'The rest of the server is identical to the previous examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: As shown in preceding code, the server is instantiated in a `protected_main()`
    function and the `recv_packet()` function is called.
  prefs: []
  type: TYPE_NORMAL
- en: The client logic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The bulk of the client is also identical to the previous examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: The `send_packet()` function is the only  part that's different from the previous
    examples (minus the fact that the `send()` function sends packets instead of a
    `std::array()`). In the `send_packet()` function, we create a packet without our
    `"Hello World"` string. It should be noted that to create this packet, we still
    require some processing, including a memory copy. Once the packet is created,
    we send it to the server for processing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The rest of the client is identical to the previous examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: The client is instantiated in a `proceted_main()` function, and the `send_packet()`
    function is executed.
  prefs: []
  type: TYPE_NORMAL
- en: Compiling and testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To compile this code, we leverage the same `CMakeLists.txt` file that we have
    been using for the other examples: [https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/blob/master/Chapter10/CMakeLists.txt](https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/blob/master/Chapter10/CMakeLists.txt).
  prefs: []
  type: TYPE_NORMAL
- en: 'With this code in place, we can compile this code using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'To execute the server, run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'To execute the client, open a new terminal and run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'On the server side, the following is output to `stdout`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the preceding snippet, the packet data is sent by the client and
    received by the server. The total size of the packet received by the server is
    280 bytes, even though the total size of the string is far smaller. In the next
    example, we will demonstrate how marshaling packets can safely reduce the total
    size of a packet at the expense of some additional processing (although likely
    negligible depending on your use case).
  prefs: []
  type: TYPE_NORMAL
- en: Processing an example of processing JSON
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this final example, we will demonstrate how packets can be marshaled using
    JSON to safely reduce the size of a network packet, at the expense of some additional
    processing. To support this example, the following C++ JSON library will be used: [https://github.com/nlohmann/json](https://github.com/nlohmann/json).
  prefs: []
  type: TYPE_NORMAL
- en: 'To incorporate this JSON library into our example, the following will have
    to be added to our `CMakeLists.txt`, which downloads this header-only library
    and installs it into our build folder to be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The server includes and macros are the same, with the exception that JSON must
    be added, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'The server in this example is identical to the previous examples, with the
    exception of the `recv_packet()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: In the `recv_packet()` function, we need to allocate a buffer with some maximum
    size; this buffer is not required to be received in full, but rather is a placeholder
    for our JSON buffer, which could be any size up to our maximum. Parsing the JSON
    data is simple. The integer data and the string data are safely parsed into their
    integer and `std::string` types, respectively, all adhering to the C++ Core Guidelines
    in the process. The code is simple to read and follow, and the packet can be changed
    in the future without having to change any additional logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'The rest of the server is identical:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: The server is instantiated in a `protected_main()` function and the `recv_packet()`
    function is called.
  prefs: []
  type: TYPE_NORMAL
- en: The client logic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Like the server, the client must also include the JSON header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'As with the server, the client is the same as the previous examples, minus
    the `send_packet()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: The `send_packet()` function is equally simple. A JSON packet is constructed
    and sent to the server. The difference is that the packet is marshaled into a
    JSON string before being sent (using the `dump()` function). This converts all
    of the data into a single string with special syntax to define the start and end
    of each field in a well-established, well-tested fashion to prevent unsafe parsing.
    In addition, as will be shown shortly, the total number of bytes being sent is
    dramatically reduced.
  prefs: []
  type: TYPE_NORMAL
- en: 'The rest of the client is identical:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: The client is instantiated in a `protected_main()` function, and the `send_packet()`
    function is called.
  prefs: []
  type: TYPE_NORMAL
- en: Compiling and testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To compile this code, we leverage the same `CMakeLists.txt` file that we have
    been using for the other examples: [https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/blob/master/Chapter10/CMakeLists.txt](https://github.com/PacktPublishing/Hands-On-System-Programming-with-CPP/blob/master/Chapter10/CMakeLists.txt).
  prefs: []
  type: TYPE_NORMAL
- en: 'With this code in place, we can compile this code using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'To execute the server, run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'To execute the client, open a new terminal and run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'On the server side, the following is output to `stdout`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the preceding snippet, the packet data is sent by the client and
    received by the server. The total size of the packet received by the server is
    43 bytes, which is 6.5 times more efficient compared to the previous example.
    In addition to providing a smaller packet, the logic for creating and parsing
    the packet is similar, and easier to read and modify in the future. Furthermore,
    with things such as JSON Schema, packets may even be validated prior to processing,
    a topic outside the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to program POSIX sockets using C++17\. Specifically,
    we learned the common APIs associated with POSIX sockets, and how to use them.
    We concluded this chapter with five different examples. The first example created
    a UDP echo server, while the second example created a similar echo server using
    TCP instead of UDP, outlining the differences between the different approaches.
    The third example expanded upon our debug example by adding a server component
    to our debugger. The fourth and fifth examples demonstrated how to process a simple
    network packet, and the benefits of using marshaling to simplify the process.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss the C and C++ time interfaces that can
    be used to get the wall clock, measure elapsed time and perform benchmarking.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the main difference between UDP and TCP?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What protocol type does UDP use?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What protocol type does TCP use?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What address type does `AF_INET` represent?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between `bind()` and `connect()`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between `sendto()` and `send()`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does a UDP server detect when a UDP client is dropped or crashed?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the benefits of using packet marshaling?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[https://www.packtpub.com/application-development/c17-example](https://www.packtpub.com/application-development/c17-example)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.packtpub.com/application-development/getting-started-c17-programming-video](https://www.packtpub.com/application-development/getting-started-c17-programming-video)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
