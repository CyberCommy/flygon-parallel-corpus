- en: Strings and Things
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The recipes in this chapter are:'
  prefs: []
  type: TYPE_NORMAL
- en: Finding the substring in a string
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Breaking the string into words
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Joining the string slice with a separator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Concatenating a string with writer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Aligning text with tabwriter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Replacing part of the string
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding the substring in text by the regex pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decoding a string from the non-Unicode charset
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling case
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parsing comma-separated data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing whitespace in a string
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Indenting a text document
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Operations on strings and string-based data are common tasks in a developer's
    life. This chapter covers how to handle these using the Go standard library. It
    is no surprise that with the standard library it is possible to do a great deal.
  prefs: []
  type: TYPE_NORMAL
- en: Check whether Go is properly installed. The *Getting ready* section from the *Retrieving
    the Golang version* recipe of [Chapter 1](acf67248-0aa9-4150-a43b-d13eb9de89f2.xhtml), *Interacting
    with the Environment,* will help you.
  prefs: []
  type: TYPE_NORMAL
- en: Finding the substring in a string
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Finding the substring in a string is one of the most common tasks for developers.
    Most of the mainstream languages implement this in a standard library. Go is not
    an exception. This recipe describes the way Go implements this.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the console and create the folder `chapter02/recipe01`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the `contains.go` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Run the code by executing `go run contains.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'See the output in the Terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/cfdd6ec3-b88c-4c16-b0ea-b27625bd827c.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Go library `strings` contain functions to handle the string operations.
    This time the function `Contains` could be used. The `Contains` function simply
    checks whether the string has a given substring. In fact, the function `Index`
    is used in `Contains` function.
  prefs: []
  type: TYPE_NORMAL
- en: To check whether the string begins with the substring, the `HasPrefix` function
    is there. To check whether the string ends with the substring, the function `HasSuffix`
    will work.
  prefs: []
  type: TYPE_NORMAL
- en: 'In fact, the `Contains` function is implemented by use of the `Index` function
    from the same package. As you can guess, the actual implementation works like
    this: if the index of the given substring is greater than `-1`, the `Contains`
    function returns `true`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `HasPrefix` and `HasSuffix` functions work in a different way: the internal
    implementation just checks the length of both the string and substring, and if
    they are equal or the string is longer, the required part of the string is compared.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe describes how to match the exact substring. The *Finding the substring
    in text by the regex pattern* recipe will help to find out how to use regex pattern
    matching.
  prefs: []
  type: TYPE_NORMAL
- en: Breaking the string into words
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Breaking the string into words could be tricky. First, decide what the word
    is, as well as what the separator is, and if there is any whitespace or any other
    characters.  After these decisions have been made, you can choose the appropriate
    function from the `strings` package. This recipe will describe common cases.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the console and create the folder `chapter02/recipe02`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the `whitespace.go` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Run the code by executing `go run whitespace.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'See the output in the Terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/aaf4051e-fe24-425c-9f49-cd929cfaed85.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Create another file called `anyother.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Run the code by executing `go run anyother.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'See the output in the Terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c0abf1c1-01cc-4d1a-accd-44894c13b81f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Create another file called `specfunction.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Run the code by executing `go run specfunction.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'See the output in the Terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/de72c9b7-3058-4e46-b357-2d46d78961a0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Create another file called `regex.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Run the code by executing `go run regex.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'See the output in the Terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/795483fa-ac1f-40af-8bdb-fe4867938c39.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The simplest form of how to split the string into words considers any whitespace
    as a separator. In detail, the whitespace is defined by the `IsSpace` function
    in the `unicode` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `Fields` function of the `strings` package could be used to split the sentence
    by the whitespace chars as mentioned earlier. The steps **1 – 5** cover this first
    simple case.
  prefs: []
  type: TYPE_NORMAL
- en: If any other separator is needed, the `Split` function comes into play. Splitting
    by another separator is covered in steps **6 – 8**. Just note that the whitespace
    in the string is omitted.
  prefs: []
  type: TYPE_NORMAL
- en: If you need a more complex function to decide whether to split the string at
    a given point, `FieldsFunc` could work for you. One of the function's argument
    is the function that consumes the rune of the given string and returns `true`
    if the string should split at that point.  This option is covered by steps **9
    – 11**.
  prefs: []
  type: TYPE_NORMAL
- en: The regular expression is the last option mentioned in the example. The `Regexp`
    structure of the `regexp` package contains the `Split` method, which works as
    you would expect. It splits the string in the place of the matching group. This
    approach is used in steps **12 – 14.**
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `strings` package also provides the various `SplitXXX` functions that could
    help you to achieve more specific tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Joining the string slice with a separator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The recipe, *Breaking the string into words*, led us through the task of splitting
    the single string into substrings, according to defined rules. This recipe, on
    the other hand, describes how to concatenate the multiple strings into a single
    string with a given string as the separator.
  prefs: []
  type: TYPE_NORMAL
- en: A real use case could be the problem of dynamically building a SQL select statement
    condition.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the console and create the folder `chapter02/recipe03`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the `join.go` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Run the code by executing `go run join.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'See the output in the Terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/9a1a1eeb-08a1-483f-a036-383b264ef022.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Create the `join_manually.go` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Run the code by executing `go run join.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'See the output in the Terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/0235e503-6a97-460a-a1cd-f8b35e807aca.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the purpose of joining the string slice into a single string, the `Join`
    function of the `strings` package is there. Simply, you need to provide the slice
    with strings that are needed to be joined. This way you can comfortably join the
    string slices. The use of the `Join` function is shown in steps **1 – 5.**
  prefs: []
  type: TYPE_NORMAL
- en: Naturally, the joining could be implemented manually by iterating over the slice.
    This way you can customize the separator by some more complex logic. The steps
    **6 – 8** just represent how the manual concatenation could be used with more
    complex decision logic, based on the string that is currently processed.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Join` function is provided by the `bytes` package, which naturally serves
    to join the slice of bytes.
  prefs: []
  type: TYPE_NORMAL
- en: Concatenating a string with writer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Besides the built-in `+` operator, there are more ways to concatenate the string. 
    This recipe will describe the more performant way of concatenating strings with
    the `bytes` package and the built-in `copy` function.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the console and create the folder `chapter02/recipe04`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the `concat_buffer.go` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Run the code by executing `go run concat_buffer.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'See the output in the Terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/2f4a68c8-c2d3-4636-8bd8-fff4422c4ee9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Create the `concat_copy.go` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Run the code by executing `go run concat_copy.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'See the output in the Terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c256f79f-54e0-4dc9-b44c-67a3e711a549.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The steps **1 - 5** cover the use of the `bytes` package `Buffer` as a performance-friendly
    solution to string concatenation. The `Buffer` structure implements the `WriteString`
    method, which could be used to effectively concatenate the strings into an underlying
    byte slice.
  prefs: []
  type: TYPE_NORMAL
- en: There is no need to use this improvement in all situations, just think about
    this in cases where the program is going to concatenate a big number of strings
    (for example, in-memory CSV exports and others).
  prefs: []
  type: TYPE_NORMAL
- en: The built-in `copy` function presented in steps **6 - 8** could be used to accomplish
    the `string` concatenation. This method requires some assumption about the final
    string length, or it could be done on the fly. However, if the capacity of the
    buffer, where the result is written, is smaller than the sum of the already written
    part and the string to be appended, the buffer must be expanded (usually by the
    allocation of a new slice with bigger capacity).
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Just for comparison, there is a benchmark code, which compares the performance
    of the built-in `+` operator, `bytes.Buffer`, and built-in `copy`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `bench` folder and file `bench_test.go` in it with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'See the results of the benchmark run:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c17081b7-fea0-4732-8fe6-817dcef5c142.png)'
  prefs: []
  type: TYPE_IMG
- en: Aligning text with tabwriter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In certain cases, the output (usually data output) is done via tabbed text,
    which is formatted in well-arranged cells. This format could be achieved with
    the `text/tabwriter` package. The package provides the `Writer` filter, which
    transforms the text with the tab characters into properly formatted output text.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the console and create the folder `chapter02/recipe05`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the `tabwriter.go` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Run the code by executing `go run tabwriter.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'See the output in the Terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b82420b6-4610-4dc0-a2c5-c60ce2564e0c.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `NewWriter` function call creates the `Writer` filter with configured parameters.
    All data written by this `Writer` is formatted according to the parameters. `os.Stdout`
    is used here for demonstration purposes.
  prefs: []
  type: TYPE_NORMAL
- en: The `text/tabwriter` package also provides a few more configuration options,
    such as the `flag` parameter.  The most useful is `tabwriter.AlignRight`, which
    configures the writer to align the content to the right in each column.
  prefs: []
  type: TYPE_NORMAL
- en: Replacing part of the string
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another very common task related to string processing is the replacement of
    the substring in a string. Go standard library provide the `Replace` function
    and `Replacer` type for the replacement of multiple strings at once.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the console and create the folder `chapter02/recipe06`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the `replace.go` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Run the code by executing `go run replace.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'See the output in the Terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/76243f61-3968-4c87-81ef-303c328e2f7e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Create the `replacer.go` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Run the code by executing `go run replacer.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'See the output in the Terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/da6e947d-9685-4b0d-871c-d61272db6f04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Create the `regexp.go` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Run the code by executing `go run regexp.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'See the output in the Terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/9aa3b189-d60a-44e3-8e5e-b8dac48d94e0.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Replace` function of a `strings` package is widely used for simple replacement.
    The last integer argument defines how many replacements will be done (in case
    of `-1`, all strings are replaced. See the second use of `Replace`, where only
    the first two occurrences are replaced.) The use of the `Replace` function is
    presented in steps **1 - 5**.
  prefs: []
  type: TYPE_NORMAL
- en: Besides the `Replace` function, the `Replacer` structure also has the `WriteString`
    method. This method will write to the given writer with all replacements defined
    in `Replacer`.  The main purpose of this type is its reusability. It can replace
    multiple strings at once and it is safe for concurrent use; see steps **6 - 8**.
  prefs: []
  type: TYPE_NORMAL
- en: The more sophisticated method of replacing the substring, or even the matched
    pattern, is naturally the use of the regular expression. The `Regex` type pointer
    method `ReplaceAllString` could be leveraged for this purpose. Steps **9 - 11**
    illustrate the use of the `regexp` package.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If more complex logic for the replacement is needed, the `regexp` package is
    probably the one that should be used.
  prefs: []
  type: TYPE_NORMAL
- en: Finding the substring in text by the regex pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are always tasks such as validating the input, searching the document
    for any information, or even cleaning up a given string from unwanted escape characters.
    For these cases, regular expressions are usually used.
  prefs: []
  type: TYPE_NORMAL
- en: The Go standard library contains the `regexp` package, which covers the operations
    with regular expressions.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the console and create the folder `chapter02/recipe07`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the `regexp.go` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Run the code by executing the `go run regexp.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'See the output in the Terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/70ccf05e-39f5-4e35-8df8-48c45e48dd9a.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `FindString` or `FindAllString` functions are the simplest ways to find
    the matching pattern in the given string. The only difference is that the `FindString`
    method of `Regexp` will return only the first occurrence. On the other hand, the
    `FindAllString`, as the name suggests, returns a slice of strings with all occurrences.
  prefs: []
  type: TYPE_NORMAL
- en: The `Regexp` type offers a rich set of `FindXXX` methods. This recipe describes
    only the `String` variations that are usually most useful. Note that the preceding
    code uses the `MustCompile` function of the `regexp` package, which panics if
    the compilation of the regular expression fails.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Besides this complex regular expression pattern matching, it is possible to
    match the substring only. This approach is described in the *Finding the substring
    in a string* recipe of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Decoding a string from the non-Unicode charset
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A lesser-known fact is that all content in `.go` files is encoded in UTF-8\.
    Believe it or not the Unicode is not, the only charset in the world. For example,
    the Windows-1250 encoding is widely spread across Windows users.
  prefs: []
  type: TYPE_NORMAL
- en: When working with non-Unicode strings, you need to transcode the content to
    Unicode. This recipe demonstrates how to decode and encode the non-Unicode strings.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the console and create the folder `chapter02/recipe08`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the file `win1250.txt` with content `Gdańsk`. The file must be encoded
    in the windows-1250 charset. If you are not sure how to do that, just jump to
    step 6 and after you complete step 7, which will create the windows-1250 encoded
    file, you can rename the `out.txt` file and go back to step 4.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the `decode.go` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Run the code by executing `go run decode.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'See the output in the Terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/9943be1b-4808-496e-9ebe-90d0947094d0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Create a file with the name `encode.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Run the code by executing `go run encode.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: See the output in the file `out.txt` in Windows-1250 encoding and UTF-8 encoding.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The package `golang.org/x/text/encoding/charmap` contains the `Charset` type
    for simple encoding and decoding. The type implements the `NewDecoder` method
    that creates the `Decoder` structure.
  prefs: []
  type: TYPE_NORMAL
- en: Steps **1 – 5** show the use of the decoding `Reader`.
  prefs: []
  type: TYPE_NORMAL
- en: The encoding works analogically. The encoding `Writer` is created and then each
    string written by this `Writer` is encoded into Windows-1250 encoding.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the Windows-1250 was chosen as an example. The package, `golang.org/x/text/encoding/charmap`
    contains a lot of other charset options.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling case
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are a lot of practical tasks where the modification of case is the most
    common approach. Let''s pick a few of these:'
  prefs: []
  type: TYPE_NORMAL
- en: Case-insensitive comparison
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Beginning the sentence with an automatic first capital
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Camel-case to snake-case conversion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For these purposes, the `strings` package offers functions `ToLower`, `ToUpper`,
    `ToTitle`, and `Title`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the console and create the folder `chapter02/recipe09`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the `case.go` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Run the code by executing `go run case.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'See the output in the Terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d144e5ad-7430-44e3-82f1-e18202476c4d.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Note that the title-case mapping in Unicode differs from the uppercase mapping.
    The difference is that the number of characters requires special handling. These
    are mainly ligatures and digraphs such as *fl*, *dz*, and *lj*, plus a number
    of polytonic Greek characters. For example, *U+01C7 (LJ)* maps to *U+01C8 (Lj)*
    rather than to *U+01C9 (lj)*.
  prefs: []
  type: TYPE_NORMAL
- en: For proper case-insensitive comparison, the `EqualFold` function from the `strings`
    package should be used. This function uses case folding to normalize the strings
    and compare them.
  prefs: []
  type: TYPE_NORMAL
- en: Parsing comma-separated data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are multiple table data formats. **CSV** (**comma-separated values**)
    is one of the most basic formats largely used for data transport and export. There
    is no standard that defines CSV, but the format itself is described in RFC 4180.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe introduces how to parse CSV-formatted data comfortably.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the console and create the folder `chapter02/recipe10`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a file named `data.csv` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the `data.go` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Run the code by executing `go run data.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'See the output in the Terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/788beecb-4faf-49b4-b6ca-21710a3aec1d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Create a file named `data_uncommon.csv` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file named `data_uncommon.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Run the code by executing `go run data_uncommon.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'See the output in the Terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f872ac32-9dae-4681-b8a5-7c6fd0f885cb.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Instead of simply scanning the input line by line and using `strings.Split`
    and other methods to parse the CSV format, Go offers a better way. The `NewReader` function
    in the `encoding/csv` package returns the `Reader` structure, which provides the
    API to read the CSV file. The `Reader` struct keeps variables to configure the
    `read` parameters, according to your needs.
  prefs: []
  type: TYPE_NORMAL
- en: The `FieldsPerRecord`parameter of `Reader` is a significant setting. This way
    the cell count per row could be validated. By default, when set to `0`, it is
    set to the number of records in a first line. If a positive value is set, the
    number of records must match. If a negative value is set, there is no cell count
    validation.
  prefs: []
  type: TYPE_NORMAL
- en: Another interesting configuration is the `Comment` parameter, which allows you
    to define the comment characters in the parsed data. In the example, a whole line
    is ignored this way.
  prefs: []
  type: TYPE_NORMAL
- en: Go 1.10 now disallows the use of nonsensical comma and comment settings. This
    means null, carriage return, newline, invalid runes, and the Unicode replacement
    character. Also, setting comma and comment equal to each other is forbidden.
  prefs: []
  type: TYPE_NORMAL
- en: Managing whitespace in a string
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The string input could contain too much whitespace, too little whitespace, or
    unsuitable whitespace chars. This recipe includes tips on how to manage these
    and format the string to your needs.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the console and create the folder `chapter02/recipe11`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a file named `whitespace.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Run the code by executing `go run whitespace.go`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'See the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/35175b6c-1e9b-4ddd-97a9-6c86aa8c379d.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Trimming the string before it is handled by the code is pretty common practice,
    and as the preceding code demonstrates, it is easily done by the standard Go library.
    The `strings` library also provides more variations of the `TrimXXX` function,
    which also allows the trimming of other chars from the string.
  prefs: []
  type: TYPE_NORMAL
- en: 'To trim the leading and ending whitespace, the `TrimSpace` function of the `strings`
    package can be used. This typifies the following part of a code, which was also
    included in the example earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The `regex` package is suitable for replacing multiple spaces and tabs, and
    the string can be prepared for further processing this way. Note that, with this
    method, the break lines are replaced with a single space.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part of the code represents the use of the regular expression to replace
    all multiple whitespaces with a single space:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Padding is not an explicit function for the `strings` package, but it can be
    achieved by the `Sprintf` function of the `fmt` package. The `pad` function in
    code uses the formatting pattern `% <+/-padding>s` and some simple math to find
    out the padding. Finally, the minus sign before the padding number works as the
    right pad, and the positive number as the left pad.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For more tips on how to work with regex, you can check the recipe, *Finding
    the substring in text by the regex pattern,* in this chapter*.*
  prefs: []
  type: TYPE_NORMAL
- en: Indenting a text document
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous recipe depicts how to do string padding and whitespace trimming.
    This one will guide you through the indentation and unindentation of a text document.
    Similar principles from the previous recipes will be used.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the console and create the folder `chapter02/recipe12`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the file `main.go` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Run the code by executing `go run main.go` in the Terminal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'See the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/30068e99-b616-4c59-9169-7be545936a62.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The indentation is as simple as padding. In this case, the same formatting option
    is used. The more readable form of the `indent` implementation could use the `Repeat`
    function of the `strings` package. The `IndentByRune` function in the preceding
    code applies this approach.
  prefs: []
  type: TYPE_NORMAL
- en: Unindenting, in this case, means removing the given count of leading spaces.
    The implementation of `Unindent` in the preceding code removes the minimum number
    of leading spaces or given indentation.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Managing whitespace in a string* recipe also works with spaces in a more
    generous way.
  prefs: []
  type: TYPE_NORMAL
