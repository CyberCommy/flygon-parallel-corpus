- en: Strings and Things
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串和其他内容
- en: 'The recipes in this chapter are:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的配方有：
- en: Finding the substring in a string
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在字符串中查找子字符串
- en: Breaking the string into words
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将字符串分解为单词
- en: Joining the string slice with a separator
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用分隔符连接字符串切片
- en: Concatenating a string with writer
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用writer连接字符串
- en: Aligning text with tabwriter
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用tabwriter对齐文本
- en: Replacing part of the string
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 替换字符串的一部分
- en: Finding the substring in text by the regex pattern
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过正则表达式模式在文本中查找子字符串
- en: Decoding a string from the non-Unicode charset
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从非Unicode字符集解码字符串
- en: Controlling case
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制大小写
- en: Parsing comma-separated data
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解析逗号分隔的数据
- en: Managing whitespace in a string
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理字符串中的空格
- en: Indenting a text document
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缩进文本文档
- en: Introduction
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Operations on strings and string-based data are common tasks in a developer's
    life. This chapter covers how to handle these using the Go standard library. It
    is no surprise that with the standard library it is possible to do a great deal.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发人员的生活中，对字符串和基于字符串的数据进行操作是常见任务。本章介绍如何使用Go标准库处理这些任务。毫无疑问，使用标准库可以做很多事情。
- en: Check whether Go is properly installed. The *Getting ready* section from the *Retrieving
    the Golang version* recipe of [Chapter 1](acf67248-0aa9-4150-a43b-d13eb9de89f2.xhtml), *Interacting
    with the Environment,* will help you.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 检查Go是否已正确安装。[第1章](acf67248-0aa9-4150-a43b-d13eb9de89f2.xhtml)的*准备就绪*部分，*与环境交互*的*检索Golang版本*配方将对您有所帮助。
- en: Finding the substring in a string
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在字符串中查找子字符串
- en: Finding the substring in a string is one of the most common tasks for developers.
    Most of the mainstream languages implement this in a standard library. Go is not
    an exception. This recipe describes the way Go implements this.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发人员中，查找字符串中的子字符串是最常见的任务之一。大多数主流语言都在标准库中实现了这一点。Go也不例外。本配方描述了Go实现这一功能的方式。
- en: How to do it...
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Open the console and create the folder `chapter02/recipe01`.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开控制台并创建文件夹`chapter02/recipe01`。
- en: Navigate to the directory.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到目录。
- en: 'Create the `contains.go` file with the following content:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`contains.go`文件，内容如下：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Run the code by executing `go run contains.go`.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行`go run contains.go`来运行代码。
- en: 'See the output in the Terminal:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中查看输出：
- en: '![](img/cfdd6ec3-b88c-4c16-b0ea-b27625bd827c.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cfdd6ec3-b88c-4c16-b0ea-b27625bd827c.png)'
- en: How it works...
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The Go library `strings` contain functions to handle the string operations.
    This time the function `Contains` could be used. The `Contains` function simply
    checks whether the string has a given substring. In fact, the function `Index`
    is used in `Contains` function.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Go库`strings`包含处理字符串操作的函数。这次可以使用`Contains`函数。`Contains`函数只是检查字符串是否包含给定的子字符串。实际上，`Contains`函数中使用了`Index`函数。
- en: To check whether the string begins with the substring, the `HasPrefix` function
    is there. To check whether the string ends with the substring, the function `HasSuffix`
    will work.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查字符串是否以子字符串开头，可以使用`HasPrefix`函数。要检查字符串是否以子字符串结尾，可以使用`HasSuffix`函数。
- en: 'In fact, the `Contains` function is implemented by use of the `Index` function
    from the same package. As you can guess, the actual implementation works like
    this: if the index of the given substring is greater than `-1`, the `Contains`
    function returns `true`.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，`Contains`函数是通过使用同一包中的`Index`函数实现的。可以猜到，实际实现方式是这样的：如果给定子字符串的索引大于`-1`，则`Contains`函数返回`true`。
- en: 'The `HasPrefix` and `HasSuffix` functions work in a different way: the internal
    implementation just checks the length of both the string and substring, and if
    they are equal or the string is longer, the required part of the string is compared.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`HasPrefix`和`HasSuffix`函数的工作方式不同：内部实现只是检查字符串和子字符串的长度，如果它们相等或字符串更长，则比较字符串的所需部分。'
- en: See also
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: This recipe describes how to match the exact substring. The *Finding the substring
    in text by the regex pattern* recipe will help to find out how to use regex pattern
    matching.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 本配方描述了如何匹配精确的子字符串。*通过正则表达式模式在文本中查找子字符串*配方将帮助您了解如何使用正则表达式模式匹配。
- en: Breaking the string into words
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将字符串分解为单词
- en: Breaking the string into words could be tricky. First, decide what the word
    is, as well as what the separator is, and if there is any whitespace or any other
    characters.  After these decisions have been made, you can choose the appropriate
    function from the `strings` package. This recipe will describe common cases.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 将字符串分解为单词可能有些棘手。首先，决定单词是什么，分隔符是什么，是否有任何空格或其他字符。做出这些决定后，可以从`strings`包中选择适当的函数。本配方将描述常见情况。
- en: How to do it...
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Open the console and create the folder `chapter02/recipe02`.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开控制台并创建文件夹`chapter02/recipe02`。
- en: Navigate to the directory.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到目录。
- en: 'Create the `whitespace.go` file with the following content:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`whitespace.go`文件，内容如下：
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Run the code by executing `go run whitespace.go`.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行`go run whitespace.go`来运行代码。
- en: 'See the output in the Terminal:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中查看输出：
- en: '![](img/aaf4051e-fe24-425c-9f49-cd929cfaed85.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](img/aaf4051e-fe24-425c-9f49-cd929cfaed85.png)'
- en: 'Create another file called `anyother.go` with the following content:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另一个名为`anyother.go`的文件，内容如下：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Run the code by executing `go run anyother.go`.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行`go run anyother.go`来运行代码。
- en: 'See the output in the Terminal:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中查看输出：
- en: '![](img/c0abf1c1-01cc-4d1a-accd-44894c13b81f.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c0abf1c1-01cc-4d1a-accd-44894c13b81f.png)'
- en: 'Create another file called `specfunction.go` with the following content:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另一个名为`specfunction.go`的文件，内容如下：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Run the code by executing `go run specfunction.go`.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行`go run specfunction.go`来运行代码。
- en: 'See the output in the Terminal:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中查看输出：
- en: '![](img/de72c9b7-3058-4e46-b357-2d46d78961a0.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](img/de72c9b7-3058-4e46-b357-2d46d78961a0.png)'
- en: 'Create another file called `regex.go` with the following content:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另一个名为`regex.go`的文件，内容如下：
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Run the code by executing `go run regex.go`.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行`go run regex.go`来运行代码。
- en: 'See the output in the Terminal:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中查看输出：
- en: '![](img/795483fa-ac1f-40af-8bdb-fe4867938c39.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/795483fa-ac1f-40af-8bdb-fe4867938c39.png)'
- en: How it works...
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The simplest form of how to split the string into words considers any whitespace
    as a separator. In detail, the whitespace is defined by the `IsSpace` function
    in the `unicode` package:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `Fields` function of the `strings` package could be used to split the sentence
    by the whitespace chars as mentioned earlier. The steps **1 – 5** cover this first
    simple case.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: If any other separator is needed, the `Split` function comes into play. Splitting
    by another separator is covered in steps **6 – 8**. Just note that the whitespace
    in the string is omitted.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: If you need a more complex function to decide whether to split the string at
    a given point, `FieldsFunc` could work for you. One of the function's argument
    is the function that consumes the rune of the given string and returns `true`
    if the string should split at that point.  This option is covered by steps **9
    – 11**.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: The regular expression is the last option mentioned in the example. The `Regexp`
    structure of the `regexp` package contains the `Split` method, which works as
    you would expect. It splits the string in the place of the matching group. This
    approach is used in steps **12 – 14.**
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `strings` package also provides the various `SplitXXX` functions that could
    help you to achieve more specific tasks.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Joining the string slice with a separator
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The recipe, *Breaking the string into words*, led us through the task of splitting
    the single string into substrings, according to defined rules. This recipe, on
    the other hand, describes how to concatenate the multiple strings into a single
    string with a given string as the separator.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: A real use case could be the problem of dynamically building a SQL select statement
    condition.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the console and create the folder `chapter02/recipe03`.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the `join.go` file with the following content:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Run the code by executing `go run join.go`.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'See the output in the Terminal:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/9a1a1eeb-08a1-483f-a036-383b264ef022.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
- en: 'Create the `join_manually.go` file with the following content:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Run the code by executing `go run join.go`.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'See the output in the Terminal:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/0235e503-6a97-460a-a1cd-f8b35e807aca.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
- en: How it works...
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the purpose of joining the string slice into a single string, the `Join`
    function of the `strings` package is there. Simply, you need to provide the slice
    with strings that are needed to be joined. This way you can comfortably join the
    string slices. The use of the `Join` function is shown in steps **1 – 5.**
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: Naturally, the joining could be implemented manually by iterating over the slice.
    This way you can customize the separator by some more complex logic. The steps
    **6 – 8** just represent how the manual concatenation could be used with more
    complex decision logic, based on the string that is currently processed.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Join` function is provided by the `bytes` package, which naturally serves
    to join the slice of bytes.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: Concatenating a string with writer
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Besides the built-in `+` operator, there are more ways to concatenate the string. 
    This recipe will describe the more performant way of concatenating strings with
    the `bytes` package and the built-in `copy` function.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the console and create the folder `chapter02/recipe04`.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the `concat_buffer.go` file with the following content:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Run the code by executing `go run concat_buffer.go`.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'See the output in the Terminal:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/2f4a68c8-c2d3-4636-8bd8-fff4422c4ee9.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
- en: 'Create the `concat_copy.go` file with the following content:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Run the code by executing `go run concat_copy.go`.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'See the output in the Terminal:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c256f79f-54e0-4dc9-b44c-67a3e711a549.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
- en: How it works...
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The steps **1 - 5** cover the use of the `bytes` package `Buffer` as a performance-friendly
    solution to string concatenation. The `Buffer` structure implements the `WriteString`
    method, which could be used to effectively concatenate the strings into an underlying
    byte slice.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: There is no need to use this improvement in all situations, just think about
    this in cases where the program is going to concatenate a big number of strings
    (for example, in-memory CSV exports and others).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: The built-in `copy` function presented in steps **6 - 8** could be used to accomplish
    the `string` concatenation. This method requires some assumption about the final
    string length, or it could be done on the fly. However, if the capacity of the
    buffer, where the result is written, is smaller than the sum of the already written
    part and the string to be appended, the buffer must be expanded (usually by the
    allocation of a new slice with bigger capacity).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Just for comparison, there is a benchmark code, which compares the performance
    of the built-in `+` operator, `bytes.Buffer`, and built-in `copy`:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `bench` folder and file `bench_test.go` in it with the following content:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'See the results of the benchmark run:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c17081b7-fea0-4732-8fe6-817dcef5c142.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
- en: Aligning text with tabwriter
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In certain cases, the output (usually data output) is done via tabbed text,
    which is formatted in well-arranged cells. This format could be achieved with
    the `text/tabwriter` package. The package provides the `Writer` filter, which
    transforms the text with the tab characters into properly formatted output text.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the console and create the folder `chapter02/recipe05`.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the `tabwriter.go` file with the following content:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Run the code by executing `go run tabwriter.go`.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'See the output in the Terminal:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b82420b6-4610-4dc0-a2c5-c60ce2564e0c.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
- en: How it works...
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `NewWriter` function call creates the `Writer` filter with configured parameters.
    All data written by this `Writer` is formatted according to the parameters. `os.Stdout`
    is used here for demonstration purposes.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: The `text/tabwriter` package also provides a few more configuration options,
    such as the `flag` parameter.  The most useful is `tabwriter.AlignRight`, which
    configures the writer to align the content to the right in each column.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Replacing part of the string
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another very common task related to string processing is the replacement of
    the substring in a string. Go standard library provide the `Replace` function
    and `Replacer` type for the replacement of multiple strings at once.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the console and create the folder `chapter02/recipe06`.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the `replace.go` file with the following content:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Run the code by executing `go run replace.go`.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'See the output in the Terminal:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/76243f61-3968-4c87-81ef-303c328e2f7e.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
- en: 'Create the `replacer.go` file with the following content:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Run the code by executing `go run replacer.go`.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'See the output in the Terminal:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/da6e947d-9685-4b0d-871c-d61272db6f04.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
- en: 'Create the `regexp.go` file with the following content:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Run the code by executing `go run regexp.go`.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'See the output in the Terminal:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/9aa3b189-d60a-44e3-8e5e-b8dac48d94e0.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
- en: How it works...
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Replace` function of a `strings` package is widely used for simple replacement.
    The last integer argument defines how many replacements will be done (in case
    of `-1`, all strings are replaced. See the second use of `Replace`, where only
    the first two occurrences are replaced.) The use of the `Replace` function is
    presented in steps **1 - 5**.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: Besides the `Replace` function, the `Replacer` structure also has the `WriteString`
    method. This method will write to the given writer with all replacements defined
    in `Replacer`.  The main purpose of this type is its reusability. It can replace
    multiple strings at once and it is safe for concurrent use; see steps **6 - 8**.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: The more sophisticated method of replacing the substring, or even the matched
    pattern, is naturally the use of the regular expression. The `Regex` type pointer
    method `ReplaceAllString` could be leveraged for this purpose. Steps **9 - 11**
    illustrate the use of the `regexp` package.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If more complex logic for the replacement is needed, the `regexp` package is
    probably the one that should be used.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: Finding the substring in text by the regex pattern
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are always tasks such as validating the input, searching the document
    for any information, or even cleaning up a given string from unwanted escape characters.
    For these cases, regular expressions are usually used.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: The Go standard library contains the `regexp` package, which covers the operations
    with regular expressions.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the console and create the folder `chapter02/recipe07`.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the `regexp.go` file with the following content:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Run the code by executing the `go run regexp.go`.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'See the output in the Terminal:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/70ccf05e-39f5-4e35-8df8-48c45e48dd9a.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
- en: How it works...
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `FindString` or `FindAllString` functions are the simplest ways to find
    the matching pattern in the given string. The only difference is that the `FindString`
    method of `Regexp` will return only the first occurrence. On the other hand, the
    `FindAllString`, as the name suggests, returns a slice of strings with all occurrences.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: The `Regexp` type offers a rich set of `FindXXX` methods. This recipe describes
    only the `String` variations that are usually most useful. Note that the preceding
    code uses the `MustCompile` function of the `regexp` package, which panics if
    the compilation of the regular expression fails.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Besides this complex regular expression pattern matching, it is possible to
    match the substring only. This approach is described in the *Finding the substring
    in a string* recipe of this chapter.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: Decoding a string from the non-Unicode charset
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A lesser-known fact is that all content in `.go` files is encoded in UTF-8\.
    Believe it or not the Unicode is not, the only charset in the world. For example,
    the Windows-1250 encoding is widely spread across Windows users.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: When working with non-Unicode strings, you need to transcode the content to
    Unicode. This recipe demonstrates how to decode and encode the non-Unicode strings.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the console and create the folder `chapter02/recipe08`.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the file `win1250.txt` with content `Gdańsk`. The file must be encoded
    in the windows-1250 charset. If you are not sure how to do that, just jump to
    step 6 and after you complete step 7, which will create the windows-1250 encoded
    file, you can rename the `out.txt` file and go back to step 4.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the `decode.go` file with the following content:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Run the code by executing `go run decode.go`.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'See the output in the Terminal:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/9943be1b-4808-496e-9ebe-90d0947094d0.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
- en: 'Create a file with the name `encode.go` with the following content:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Run the code by executing `go run encode.go`.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: See the output in the file `out.txt` in Windows-1250 encoding and UTF-8 encoding.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The package `golang.org/x/text/encoding/charmap` contains the `Charset` type
    for simple encoding and decoding. The type implements the `NewDecoder` method
    that creates the `Decoder` structure.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: Steps **1 – 5** show the use of the decoding `Reader`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: The encoding works analogically. The encoding `Writer` is created and then each
    string written by this `Writer` is encoded into Windows-1250 encoding.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: Note that the Windows-1250 was chosen as an example. The package, `golang.org/x/text/encoding/charmap`
    contains a lot of other charset options.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: Controlling case
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are a lot of practical tasks where the modification of case is the most
    common approach. Let''s pick a few of these:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: Case-insensitive comparison
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Beginning the sentence with an automatic first capital
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Camel-case to snake-case conversion
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For these purposes, the `strings` package offers functions `ToLower`, `ToUpper`,
    `ToTitle`, and `Title`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the console and create the folder `chapter02/recipe09`.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the `case.go` file with the following content:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Run the code by executing `go run case.go`.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'See the output in the Terminal:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d144e5ad-7430-44e3-82f1-e18202476c4d.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
- en: How it works...
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Note that the title-case mapping in Unicode differs from the uppercase mapping.
    The difference is that the number of characters requires special handling. These
    are mainly ligatures and digraphs such as *fl*, *dz*, and *lj*, plus a number
    of polytonic Greek characters. For example, *U+01C7 (LJ)* maps to *U+01C8 (Lj)*
    rather than to *U+01C9 (lj)*.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: For proper case-insensitive comparison, the `EqualFold` function from the `strings`
    package should be used. This function uses case folding to normalize the strings
    and compare them.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: Parsing comma-separated data
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are multiple table data formats. **CSV** (**comma-separated values**)
    is one of the most basic formats largely used for data transport and export. There
    is no standard that defines CSV, but the format itself is described in RFC 4180.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: This recipe introduces how to parse CSV-formatted data comfortably.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the console and create the folder `chapter02/recipe10`.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a file named `data.csv` with the following content:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Create the `data.go` file with the following content:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Run the code by executing `go run data.go`.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'See the output in the Terminal:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/788beecb-4faf-49b4-b6ca-21710a3aec1d.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
- en: 'Create a file named `data_uncommon.csv` with the following content:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Create a file named `data_uncommon.go` with the following content:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Run the code by executing `go run data_uncommon.go`.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'See the output in the Terminal:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f872ac32-9dae-4681-b8a5-7c6fd0f885cb.png)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
- en: How it works...
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Instead of simply scanning the input line by line and using `strings.Split`
    and other methods to parse the CSV format, Go offers a better way. The `NewReader` function
    in the `encoding/csv` package returns the `Reader` structure, which provides the
    API to read the CSV file. The `Reader` struct keeps variables to configure the
    `read` parameters, according to your needs.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: The `FieldsPerRecord`parameter of `Reader` is a significant setting. This way
    the cell count per row could be validated. By default, when set to `0`, it is
    set to the number of records in a first line. If a positive value is set, the
    number of records must match. If a negative value is set, there is no cell count
    validation.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: Another interesting configuration is the `Comment` parameter, which allows you
    to define the comment characters in the parsed data. In the example, a whole line
    is ignored this way.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: Go 1.10 now disallows the use of nonsensical comma and comment settings. This
    means null, carriage return, newline, invalid runes, and the Unicode replacement
    character. Also, setting comma and comment equal to each other is forbidden.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: Managing whitespace in a string
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The string input could contain too much whitespace, too little whitespace, or
    unsuitable whitespace chars. This recipe includes tips on how to manage these
    and format the string to your needs.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the console and create the folder `chapter02/recipe11`.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a file named `whitespace.go` with the following content:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Run the code by executing `go run whitespace.go`.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'See the output:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/35175b6c-1e9b-4ddd-97a9-6c86aa8c379d.png)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
- en: How it works...
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Trimming the string before it is handled by the code is pretty common practice,
    and as the preceding code demonstrates, it is easily done by the standard Go library.
    The `strings` library also provides more variations of the `TrimXXX` function,
    which also allows the trimming of other chars from the string.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: 'To trim the leading and ending whitespace, the `TrimSpace` function of the `strings`
    package can be used. This typifies the following part of a code, which was also
    included in the example earlier:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `regex` package is suitable for replacing multiple spaces and tabs, and
    the string can be prepared for further processing this way. Note that, with this
    method, the break lines are replaced with a single space.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: 'This part of the code represents the use of the regular expression to replace
    all multiple whitespaces with a single space:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的这一部分表示使用正则表达式将所有多个空格替换为单个空格：
- en: '[PRE25]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Padding is not an explicit function for the `strings` package, but it can be
    achieved by the `Sprintf` function of the `fmt` package. The `pad` function in
    code uses the formatting pattern `% <+/-padding>s` and some simple math to find
    out the padding. Finally, the minus sign before the padding number works as the
    right pad, and the positive number as the left pad.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 填充不是`strings`包的显式函数，但可以通过`fmt`包的`Sprintf`函数实现。代码中的`pad`函数使用格式化模式`% <+/-padding>s`和一些简单的数学运算来找出填充。最后，填充数字前的减号作为右填充，正数作为左填充。
- en: See also
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: For more tips on how to work with regex, you can check the recipe, *Finding
    the substring in text by the regex pattern,* in this chapter*.*
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 有关如何使用正则表达式的更多提示，您可以在本章中查看*通过正则表达式模式在文本中查找子字符串*的示例。
- en: Indenting a text document
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对文本文档进行缩进
- en: The previous recipe depicts how to do string padding and whitespace trimming.
    This one will guide you through the indentation and unindentation of a text document.
    Similar principles from the previous recipes will be used.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例描述了如何进行字符串填充和修剪空白。这个示例将指导您如何对文本文档进行缩进和取消缩进。将使用前面示例中的类似原则。
- en: How to do it...
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Open the console and create the folder `chapter02/recipe12`.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开控制台并创建文件夹`chapter02/recipe12`。
- en: 'Create the file `main.go` with the following content:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建名为`main.go`的文件，并包含以下内容：
- en: '[PRE26]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Run the code by executing `go run main.go` in the Terminal.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中执行`go run main.go`来运行代码。
- en: 'See the output:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看输出：
- en: '![](img/30068e99-b616-4c59-9169-7be545936a62.png)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![](img/30068e99-b616-4c59-9169-7be545936a62.png)'
- en: How it works...
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The indentation is as simple as padding. In this case, the same formatting option
    is used. The more readable form of the `indent` implementation could use the `Repeat`
    function of the `strings` package. The `IndentByRune` function in the preceding
    code applies this approach.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 缩进就像填充一样简单。在这种情况下，使用相同的格式选项。`indent`实现的更可读形式可以使用`strings`包的`Repeat`函数。上述代码中的`IndentByRune`函数应用了这种方法。
- en: Unindenting, in this case, means removing the given count of leading spaces.
    The implementation of `Unindent` in the preceding code removes the minimum number
    of leading spaces or given indentation.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，取消缩进意味着删除给定数量的前导空格。在上述代码中，`Unindent`的实现会删除最少数量的前导空格或给定的缩进。
- en: See also
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Managing whitespace in a string* recipe also works with spaces in a more
    generous way.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '*管理字符串中的空白*示例也以更宽松的方式处理空格。'
