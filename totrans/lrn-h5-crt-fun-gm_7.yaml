- en: Chapter 7. HTML5 and Mobile Game Development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this last chapter we will take a look at the ever so important concept of
    not only developing for multiple browsers and platforms, but also of developing
    an application with multiple devices in mind. It used to be that web development
    was all about supporting multiple browsers. Then it became all about taking advantage
    of the latest technologies available and creating applications that resembled
    a native desktop application. Today, we must not only remember those same concepts
    that allow us to make our applications available to as many people as possible,
    but we must also remember that the standard desktop computer is not the only machine
    accessing our web applications.
  prefs: []
  type: TYPE_NORMAL
- en: While creating an HTML5-based game or application, we must be able to envision
    our users connecting through the desktop computer, net-books, HTML5-ready video
    game systems, smart phones, tables, television sets, and soon their smart watches,
    smart glasses, and possibly their smart toasters, fish tanks, and so on. Needless
    to say, there are quite a few differences between these devices, other than their
    size, shape, and suggested retail price.
  prefs: []
  type: TYPE_NORMAL
- en: As we develop the last game in this book, lets take a look at some of the most
    important concepts related to mobile game development with HTML5\. We'll first
    look at fundamental differences between a desktop machine and a mobile device
    (specifically, a smart phone and a tablet). The two HTML5-related APIs discussed
    in the chapter are media queries (which allows us to adjust CSS properties based
    on the current state of the device viewing the application) and JavaScript touch
    events, with their corresponding event handlers. Finally, we'll conclude the chapter
    with a discussion on how to go about developing and optimizing a game for a desktop
    browser as well as a mobile device, with a single code base.
  prefs: []
  type: TYPE_NORMAL
- en: Desktop versus mobile
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At first sight, the careless web developer might be led to believe that, because
    many of today's smart phones are in fact quite a lot smarter than most fifth graders,
    that their fancy web applications and games will run just fine on a mobile device.
    Do not be deceived! Although it is true that your smart phone is indeed smarter
    than you were when in fifth grade (in fact, most not-so-smart phones today have
    more computer power than the hardware that NASA used to take Neil A. Armstrong,
    Michael Collins, and Edwin E. Aldrin to the moon in 1969), it is in many instances
    no match to the average desktop computer from which most people surf the internet
    and play games online.
  prefs: []
  type: TYPE_NORMAL
- en: There are several significant differences between a desktop browser and a mobile
    browser. For this reason, we need to develop our applications with these differences
    in mind. After all, no matter how large the group of people only using the internet
    strictly from a mobile device or from a desktop browser, we have no reason to
    limit our reach to only one of those groups.
  prefs: []
  type: TYPE_NORMAL
- en: One key aspect of mobile-friendly development that we must keep in mind, which
    doesn't always apply to games, is that one's mobile strategy is often inherently
    different from a desktop strategy for reasons beyond hardware limitations and
    differences. For example, use case on a mobile device is substantially different
    than the use case on a desktop version of a journal application. Since it is much
    harder and slower to type on a small device, users are less likely to spend hours
    typing a journal entry on a phone application as opposed to its desktop counterpart,
    where a full-sized keyboard is available. Thus, the entire mobile experience must
    be considered with a different persona in mind.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, because the human-computer interaction is different in a mobile device,
    the presentation of the application must be considered with these features in
    mind. For example, while navigating a website, most people would generously move
    the mouse cursor about the screen in an attempt to discover what can be clicked
    and what can be interacted with. Every time an action element is hovered, the
    mouse pointer changes (normally from an arrow icon to a pointing index finger)
    hinting to the user that an action can be initiated by clicking on such item.
    On a mobile device, however, no such thing exists. Thus, the design must take
    this into account, so that users aren't confused, intimidated, or worse yet, hesitant
    to use your game or application.
  prefs: []
  type: TYPE_NORMAL
- en: The rest of this section will present a few major implementation considerations
    for your mobile strategy as well as a couple of current best practices. Both sections
    apply equally well to mobile games and mobile applications (non-gaming applications,
    that is). Albeit not extensive, this list of considerations and best practices
    should be sufficient to get you thinking in the right direction, and pointed towards
    a successful mobile campaign.
  prefs: []
  type: TYPE_NORMAL
- en: Major implementation considerations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Perhaps the most distinguishing feature that sets a mobile device apart from
    a desktop computer is the fact that the mobile device is always accessible. Once
    the user has left his or her house, the desktop machine is parked until possibly
    many hours later. The mobile device, on the other hand, can be as far away from
    the user as his or her pocket. So at any moment, the user can pull out the mobile
    device and start playing your game or using your application.
  prefs: []
  type: TYPE_NORMAL
- en: Very importantly, a continuation of this always accessible use case is that
    a user will play your game for a very small amount of time—while waiting for the
    elevator, while standing in line at the store, or while trying to drown out an
    awkward moment during a first date. Thus, your game must accommodate these brief,
    very brief, playing sessions and it must do so in a way that the player can still
    make progress in the game while playing it in sessions of 30 to 120 seconds at
    a time.
  prefs: []
  type: TYPE_NORMAL
- en: Some important considerations for your mobile game that are more related to
    the physical nature of mobile devices include its limited screen size, the possibility
    to change screen orientation effortlessly, limited computing power (relative to
    a desktop computer, of course), limited battery power, and browser differences
    (no, those haven't gone away yet on mobile devices, either).
  prefs: []
  type: TYPE_NORMAL
- en: Screen size and orientation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The most obvious difference between a desktop computer and a mobile device is
    its size. Even though most modern devices can simulate large screen resolutions,
    the physical screen size is still rather limited. Not only that, but also at any
    moment the user can rotate the device sideways, expecting a responsive feedback
    of some sort from the application.
  prefs: []
  type: TYPE_NORMAL
- en: In web design in general, the standard solution to the problem of smaller and
    varying screen sizes is a technique called responsive design. The main tool used
    today to implement responsive design is the new CSS media query API (which we
    discuss later in the chapter). Simply put, this API allows us to load different
    stylesheets or sets of CSS rules based on, among other things, screen size, proportions,
    and orientation.
  prefs: []
  type: TYPE_NORMAL
- en: For example, we can define a CSS stylesheet for the case when the screen is
    wider than it is taller (which, by definition, would make it a landscape viewport)
    and have a second style sheet designed for the case when the screen is taller
    than it is wider (making it a portrait view). Media queries would allow us to
    automatically and dynamically load one of these two stylesheets based on the current
    screen state. That is, if the user was to manually resize the browser window,
    the style sheet would trigger in real time.
  prefs: []
  type: TYPE_NORMAL
- en: As for screen orientation changes, DOM-based web applications have it easier,
    because the browser itself if able to rotate everything, so it faces the right
    direction. On a canvas-based application (either 2D canvas or WebGL), a screen
    rotation also rotates the browser's coordinate system, but not the canvas'. Thus,
    if you want a particular game to play horizontally on a landscape view, and vertically
    on a portrait view, you'll need to manage the rotation of the canvas' coordinate
    system by hand.
  prefs: []
  type: TYPE_NORMAL
- en: Most importantly, however, is the fact that when designing a mobile-friendly,
    or a mobile version of a game, the screen size will be significantly smaller.
    That means that fewer elements can be crammed into a particular view. Less information
    needs to be presented, since less information can be conveyed at once.
  prefs: []
  type: TYPE_NORMAL
- en: The two common solutions to this problem are to develop one application with
    two separate presentation layers (or two separate views or templates), only serving
    the view that's appropriate to the device requesting it (serving the mobile template
    when a template accesses the application and the full template when a desktop
    browser requests the application) and developing a single application with a single
    template, but making this template responsive, as described previously. The less
    popular alternative is to develop two separate applications altogether, where
    each application focuses on a given paradigm (mobile and desktop).
  prefs: []
  type: TYPE_NORMAL
- en: 'Normally, the mobile template is a shrunk down version of the full template
    where not all elements are necessarily displayed, as represented by the following
    illustration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Screen size and orientation](img/6029OT_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Computing power
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As mentioned before, today's mobile devices have gotten quite powerful. Even
    more amazing is the fact that the tendency is for them to continue to improve,
    jamming more computing power into less physical space. However, the best smart
    phone today is no match against even an average power gaming PC. For most web
    applications, this difference can often be neglected but certainly not for more
    complex games.
  prefs: []
  type: TYPE_NORMAL
- en: One specific disadvantage that mobile devices have against desktop computers
    in this area is that the gap between the computing power of a lower-end mobile
    device and an average mobile device is quite large, as compared to a low-end desktop
    computer and a mere average one. Thus, when considering the capabilities of your
    game's users, remember that a large amount of those players will have very limited
    devices.
  prefs: []
  type: TYPE_NORMAL
- en: Battery life
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Believe it or not, the most used feature of a smart phone is, well, to make
    and receive phone calls. With such an important function being the mobile device's
    primary use, it would be quite tragic to keep the device from performing such
    a task because a game uses up all of the device's battery power. For this reason,
    one very important characteristic of a mobile application (including games and
    mobile web applications) is how well it conserves power.
  prefs: []
  type: TYPE_NORMAL
- en: The more data the application needs to process, the more electricity it will
    require to do so. If the game spends much of its time performing complex calculations,
    it is likely to quickly drain the device's battery sooner than one would like
    it to. It is imperative that your mobile games use the least possible amount of
    power so that the player can enjoy the game as much as possible, while still saving
    enough battery power so that the device can serve its most fundamental purpose—to
    make phone calls.
  prefs: []
  type: TYPE_NORMAL
- en: Browser differences
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you thought all your browser compatibility issues would go away once you
    started focusing your web development efforts on mobile devices, think again.
    Not only are there differences between the various mobile browsers themselves
    (just as there are differences on their desktop counterparts), but also not every
    HTML5 API and feature available on a given desktop browser is available on the
    same browser's mobile version.
  prefs: []
  type: TYPE_NORMAL
- en: Some features are in fact available on a mobile browser, but the performance
    is still a very long way from being acceptable. One simple example that we will
    see in the game developed in this chapter is CSS animations. Depending on how
    creative you get with the animation, the mobile browser might have a very hard
    time handling the animation, while on a desktop browser the computations and rendering
    power needed to display the animation smoothly and consistently are quite trivial.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, when defining the concrete way in which your mobile application
    is to be implemented, keep in mind that some APIs and features will simply have
    to be thrown out, lest the application performs at unacceptable levels.
  prefs: []
  type: TYPE_NORMAL
- en: Best practices
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that you're ready to take the theory just discussed, where the rubber meets
    the road, let's discuss a few best practices on how to do just that. While a complete
    book could be dedicated to this topic, the following selection covers what I believe
    to be the top five most important best practices for mobile web development. Again,
    these concepts apply to generic web applications as well as games.
  prefs: []
  type: TYPE_NORMAL
- en: Degrade gracefully and enhance progressively
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Up to a couple of years ago, any discussion about adding new and cutting edge
    functionality to a web application was built around the topic of graceful degradation.
    More recently, that ideology has shifted more towards the other end of the spectrum,
    where the suggested way of building multiplatform and multidevice applications
    is with progressive enhancement.
  prefs: []
  type: TYPE_NORMAL
- en: In this context, graceful degradation refers to building the full-blown application
    first (the latest and greatest desktop browser), then scaling it down so that
    it works on a less capable browser as well as on mobile devices. Similarly, progressive
    enhancement refers to building the mobile version of the application first, then
    making it work on the desktop browser. Whichever approach is taken, the end result
    is the same—one application that functions equally well on both platforms.
  prefs: []
  type: TYPE_NORMAL
- en: While much can be said about both of these approaches, in practice none is particularly
    better than the other. The only difference is simply where you start. Hopefully,
    the application is well planned for, so that each version is already envisioned
    before construction begins, so that starting at either end will take the application
    to the same place. Normally, however, the ideal approach to take depends largely
    on the type of project in question.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of most games, as was indeed the case with the 2D space shooter
    game built for this chapter, it is much easier to develop the desktop version
    first then remove whatever functionality is not supported by, or appropriate for,
    mobile devices.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the main rendering loop of our game is based on the new `requestAnimationFrame`
    function. Now, not all browsers expose this function yet, while others expose
    it through a different interface. Gracefully degrading this functionality would
    mean to use the function where available and use a fallback where it isn't available.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: On the other hand, a progressive enhancement approach would start out with the
    lowest common denominator first, not promising any special bells and whistles
    to anyone, but adding those in as permitted by the client technology.
  prefs: []
  type: TYPE_NORMAL
- en: For example, suppose we want to make extensive use of CSS animations. Specifically,
    we wish to use a very large image for the background, then animate its position
    and size continually using keyframe animation. On a mobile device, this could
    consume a lot of processing power, causing severe performance problems. Thus,
    we decide not to use these animations in such cases.
  prefs: []
  type: TYPE_NORMAL
- en: Enhancing the application progressively in this case would mean that we start
    out with a static image for the background. The CSS file defining the animation
    and applying it to the application is not loaded by default.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Once that minimum functionality is in place, we can test the environment in
    order to determine if we should load the CSS file, injecting the more robust functionality.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Now, it wouldn't be particularly difficult to build the game with the animated
    background first, then remove it when a particular device was detected. There
    wouldn't necessarily be any added value taking this approach either.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, whatever approach makes more sense to your specific application
    and design goals and objectives, the key principle is to keep user experience
    in mind. Never present the user of your game or application with an unusable product
    or feature. Either downgrade the feature to something useful or upgrade it when
    you are sure that the user's environment can make proper use of the feature.
  prefs: []
  type: TYPE_NORMAL
- en: Finger-friendly design
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another very important design consideration that is so easy to overlook is the
    size of the various elements. Although making text large enough is important,
    this is somewhat easier to get right. Plus, text size is fairly easy to adjust
    dynamically, so users can tweak things until they're comfortable with the exact
    size of the text in your application. However, coming from the point-and-click
    world, where action targets are big enough if the mouse pointer can fit on top
    of it, we may not realize that different people have vastly different finger sizes.
    Nothing can possibly be more frustrating to a big-fingered user, than to miss
    a click target because the target is too small. When the first touch-sensitive
    mobile applications came out several years ago, users probably considered carrying
    a finger sharpener along with their device, so that those tiny touch targets could
    be reached.
  prefs: []
  type: TYPE_NORMAL
- en: In the following illustration, the screenshot on the left is an example of items
    that are too small for a user to touch, as well as items that are too close together.
    The better solution, as shown on the screenshot on the right, makes the interface
    more forgiving and harder for the user to mess up.
  prefs: []
  type: TYPE_NORMAL
- en: '![Finger-friendly design](img/6029OT_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you look at the developer guides published by the various mobile platform
    makers, you will find specific pixel dimensions that are suggested as the minimum
    size for widgets that can be touched as well as minimum distances between two
    or more touchable elements. While there is no perfect size of any particular widget,
    we must always design with this issue in mind.
  prefs: []
  type: TYPE_NORMAL
- en: Save battery life
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: No matter how amazing your mobile game might be, the minute that users realize
    that the game is rudely demanding on their device's battery, the game will immediately
    be frowned upon. If the user is running low on power, but they know that your
    game is very friendly with power consumption, your application will definitely
    get extra love.
  prefs: []
  type: TYPE_NORMAL
- en: Now, the main source of energy inefficiencies in mobile apps is extensive, unnecessary
    hardware use. For example, if an application pulls the GPS multiple times per
    second, it will probably run down the battery fairly quickly. However, in an HTML5
    application, direct hardware access is not as readily available.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of a web application, the main way to save energy is to do as much
    caching as possible. The main point of caching here would be to avoid extra network
    activity. Not only would the extra processing require more energy, but it would
    also force the user to spend what is often limited bandwidth. As an added bonus,
    caching would also make your application behave much faster.
  prefs: []
  type: TYPE_NORMAL
- en: Plan for offline
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A very large amount of mobile gamers today have a limited amount of internet
    access from their mobile device. Any extra use of that precious data plan might
    be a costly deal for the user. As a result, many users actively disable internet
    access on their device. As a result of that, you should never make the assumption
    that your games will have continuous access to the internet.
  prefs: []
  type: TYPE_NORMAL
- en: Again, the best solution to this use case is to use caching to your benefit.
    First, by making fewer server round trips, even if each batch is larger, you will
    be saving expensive bandwidth that the user is trying to save. Second, the application
    can seem much faster and more responsive if HTTP requests are saved up for a moment
    when the application is not doing anything meaningful (such as displaying a game-related
    message or waiting for the user to input information).
  prefs: []
  type: TYPE_NORMAL
- en: Offering a desktop version
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are many reasons why a user might want to checkout a mobile application's
    non-mobile version. Perhaps it is because of missing functionality, maybe the
    user has a good enough mobile device that can actually handle the full version
    just fine or maybe the user wants to access the full version from a mobile device
    just out of curiosity. Whatever the reason, adding a link to the full-sized version
    of your application is perhaps the easiest thing you can do, so why not do it
    for the minority of users who might actually use it!
  prefs: []
  type: TYPE_NORMAL
- en: Understanding media queries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Media queries have been around since HTML4 and CSS2\. Originally, the CSS media
    attribute was used to specify a different stylesheet to be loaded based on the
    media type loading the page, such as screen, TV, projection, or handheld. In HTML5,
    media queries also allow for expressions that check for other properties of the
    user agent viewing the document such as viewport width, height, resolution, and
    so on.
  prefs: []
  type: TYPE_NORMAL
- en: A **media query** is made up of two parts, namely a media type declaration and
    one or more expressions that evaluate to either true or false. Any CSS rules contained
    nested within the media query declaration are applied whenever any of the media
    query expressions evaluate to true. Alternatively, every CSS rule inside a stylesheet
    referenced by a link tag whose media attribute contains a **truthy** media query
    expression is applied to the specified media type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: According to the specification, a browser is expected to, but not required to,
    continue to evaluate the expressions in media queries and update the CSS rules
    as changes take place in the browser environment. In other words, if two media
    queries are specified in a page—one for a window with a width below a certain
    size and one with a width above that value—the browser is not required to load
    the corresponding style sheet if the user manually resizes the browser width without
    refreshing the page. However, since this isn't a very common use case, it should
    not be of much concern to web designers. Besides, most modern browsers do in fact
    re-evaluate media query expressions in real time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are nine media types that can be specified and targeted from a media
    query. Alternatively, the keyword `all` can be used to indicate all media types.
    The allowed media types in CSS media types are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`braille`: Used for braille tactile feedback devices'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`handheld`: Used for handheld devices'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`print`: Used for printers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`projection`: Used for projectors'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`screen`: Used for computer screens'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tty`: Used for media using a fixed-pitch character grid'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tv`: Used for televisions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`embossed`: Used for paged braille printers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`speech`: Used for speech synthesizers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The two operators that can be used to connect two or more expressions are the
    logical `AND` and `OR` operators, indicated by the `and` keyword and a `comma`
    character respectively. Additionally, the logical `NOT` operator can be used to
    negate an expression. This operator is indicated by the `not` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The 13 values that can be checked inside media query expressions are width,
    height, device-width, device-height, orientation, aspect-ratio, device-aspect-ratio,
    color, color-index, monochrome, resolution, scan, and grid. So long as the expression
    makes sense, any combination of these values can be used in an expression. This
    is when some basic Boolean logic comes in handy as well as a bit of common sense.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the units that can be used along with each expression are the same
    as CSS units. We can use fixed units (such as pixels, centimeters, or inches)
    or relative units (such as percentages or ems). As a refresher, the following
    list describes the possible units used in CSS, and thus, in media query expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`%`: percentage'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`in`: inch'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cm`: centimeter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mm`: millimeter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`em`: em (1 em = height of current font size)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ex`: ex (1 ex = height of a font)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pt`: point (1 point = 1/72 inch)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pc`: pica (1 pica = 12 points)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`px`: CSS pixels'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The rest of this section will contain a more detailed explanation of each of
    the valid values used in media queries, along with examples for each.
  prefs: []
  type: TYPE_NORMAL
- en: width
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When queried against a continuous media type, the value refers to the total
    viewport (visible window area) width of the device, including any rendered scroll
    bars. When queried against a paged media type, the total width measured against
    is the width of the output page.
  prefs: []
  type: TYPE_NORMAL
- en: Optionally, the prefixes `min` and `max` can be used with the `width` keyword,
    allowing us to specify ranges, rather than discrete values.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The preceding snipped specifies two media queries that apply to all media types.
    When the output width is less than 250 (exclusive), the background color is set
    to blue. Otherwise, the background color becomes red. As is the case with most
    modern browsers, we can resize the browser window manually and the new CSS rules
    will apply automatically. Otherwise, the properties are tested and set at the
    time the browser renders the page the first time.
  prefs: []
  type: TYPE_NORMAL
- en: In the following illustration, the window on the left is not quite wide enough
    to trigger the first media query on the previous snippet, which causes the second
    snippet to evaluate to true. By simply resizing the browser window (which can
    be done by maximizing the browser or possibly by simply turning the mobile device
    into landscape mode), the second media query will be invalidated and the first
    one will become enabled.
  prefs: []
  type: TYPE_NORMAL
- en: '![width](img/6029OT_08_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Note that the units used in the previous media query evaluation are CSS pixels.
    When setting special rules for media types where pixels don''t apply very easily,
    we can use other units such as `in` (inches) or `cm` (centimeters), as seen in
    the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The output of the previous code snippet can be seen in the following screenshot.
    Note that the minimum and maximum width in question is not necessarily the width
    of the page in which the printing takes place, but rather the width of the box
    formed by the paper width minus any margins set by the printer. In this case,
    a sheet of paper of 8.5 inches in width, minus a single inch from the left and
    right margins, makes an effective width of 6.5 inches in portrait mode. The landscape
    version of that same page, which is 11 inches wide, produces a box width of 9
    inches, which is wide enough to trigger the first media query.
  prefs: []
  type: TYPE_NORMAL
- en: The top print preview on the following screenshot represents a page being printed
    in portrait mode. That is, its width (in this case) is no more than 6.5 inches.
    The preview on the bottom is wider than 7.0 inches which causes a different media
    query to enable, thus changing the stylesheet settings for the page to be printed.
  prefs: []
  type: TYPE_NORMAL
- en: '![width](img/6029OT_08_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: height
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Similar to the `width` property, the `height` property refers to the viewport
    height of a continuous media type, including rendered scroll bars. For paged media
    types, this refers to the effective page box available to the output media. Needless
    to say, the value of a height property cannot be a negative unit. Again, just
    like the `width` property described previously, we can also add the modifier prefixes
    `min` and `max` to this property in order to specify ranges of values, rather
    than unit-perfect single values.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: device-width
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Similar to the `width` property, the device-width refers to the entire physical
    window or page, regardless of the current browser window's width or available
    output width of a paged media.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code example, if the screen width (not browser width) is exactly
    1600px, the last media query will be active, regardless of any browser resizing.
    The same goes for a page—if the entire width of the page calculates to exactly
    1600px wide, the corresponding media query will match. Anything more or less than
    that and one of the other two media queries will be used instead. Again, the keywords
    `min` and `max` are valid modifiers that we can use in conjunction with this property.
  prefs: []
  type: TYPE_NORMAL
- en: 'The answer to the question about when to choose device-width or width and vice-versa
    is simple: whenever the design of your application calls for it. In most cases,
    the end result is the same. The only time when width is more appropriate than
    device-width is when the user might use their browser windowing in a customized
    size (not maximized) and the design is intended to reflow and auto adjust to the
    current width of the browser. On the other hand, if a design is meant to remain
    the same on a certain monitor width (or range of widths) regardless of the current
    browser state, then device width might be a more elegant and efficient way to
    go about it.'
  prefs: []
  type: TYPE_NORMAL
- en: device-height
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Finally, the last possibility with querying the rectangular sides of a display,
    device-height works exactly the same as device-width (other than the size measured).
    Although the same result can be achieved with the other viewport queries described
    so far, out of the four queries described so far, device-height might be the ideal
    candidate (along with device-width) to identify mobile orientation (portrait or
    landscape).
  prefs: []
  type: TYPE_NORMAL
- en: orientation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since media queries don't allow for comparison between two attributes (for example,
    if width is greater than or equal to height), orientation allows us to determine
    which way a media type is rotated. Had there been comparison operators included
    in the CSS media query engine, we could easily determine if a page was in landscape
    mode. To do that, we simply need to determine if the width is greater than the
    height. If the two sides are of the same length (a square viewport), the specification
    determines the media to be in portrait mode. However, since such an approach is
    not possible directly with media queries, we can instead use the much more intuitive
    orientation attribute.
  prefs: []
  type: TYPE_NORMAL
- en: The two possible values for the attribute are, with little surprise, `portrait`
    and `landscape`. The prefixes `min` and `max` are not allowed with this query,
    since it doesn't make sense to classify something as being at least landscape
    or no more than portrait.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the previous example, we check if the media is either landscape or portrait.
    Whatever the orientation evaluates, the media query becomes activated. Note that
    the third query attempts to set a third orientation based on erroneous conclusions.
    One might imagine that the way to determine if something is landscape or portrait
    is to take the ratio between the two—if the width is greater than the height then
    the media is in landscape mode, otherwise it is in portrait mode. You can imagine
    how someone might conclude that if both sides (width and height) are the same,
    that the orientation is neither landscape nor portrait. However, it is important
    to remember that a square figure is not landscape, but is indeed portrait. The
    key is to remember that there are only two possible values for this property,
    precisely because there are only two possible states that a media can be in at
    a time.
  prefs: []
  type: TYPE_NORMAL
- en: aspect-ratio
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The aspect ratio property allows us to check for the proportion of the media's
    width relative to its height (in this order). This property takes into account
    the actual ratio between the `width` and `height` media query values, meaning
    that dynamic changes to the viewport width and height affect this property directly.
    The `min` and `max` keywords can be used in the evaluation of this property.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The previous code snippet demonstrates various ways to calculate aspect ratio.
    Keep in mind that the value of this attribute must always read as a single fraction,
    with no floating point numbers involved. Simply said, the value must be in the
    form of an integer, followed by a slash, followed by a second integer. The first
    integer refers to the width value and the second to the height. Together, they
    form a ratio.
  prefs: []
  type: TYPE_NORMAL
- en: The first media query in the previous example tests for a viewport that is exactly
    two width units for every one width unit. Put it another way, that expression
    checks for a viewport that is twice as high as it is tall or half as wide as it
    is wide. In contrast, the last media query attempts to generate the same result,
    but in reverse. The attempt there was to query a media type that was at most twice
    as wide as it is tall. This expression would raise a silent expression (the expression
    would be ignored), because the format is not appropriate. Instead of checking
    for 1/0.5, the proper way would be to make it 2/1, making the width length twice
    as large as the height.
  prefs: []
  type: TYPE_NORMAL
- en: When specifying a desired value for a media query aspect-ratio expression, the
    number on the left refers to the width relative to the height, which is represented
    by the value on the right. Both numbers must be positive integers and the larger
    of the two values can be on either side. Alternatively, both values can be the
    same, which would test for a square aspect ratio (1/1).
  prefs: []
  type: TYPE_NORMAL
- en: '![aspect-ratio](img/6029OT_08_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: device-aspect-ratio
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Checking for device-aspect-ratio works the exact same way as the aspect-ratio,
    as explained previously, with the only difference being that the `width` and `height`
    references are based on the device-width and device-height, as explained in their
    respective sections.
  prefs: []
  type: TYPE_NORMAL
- en: Again, as with device-width and device-height, this is a great way to check
    for the underlying fingerprinting of the device accessing the application, which
    is independent of the current state of the browser window at the time the media
    query is tested. As far as responding to user actions, testing for aspect-ratio
    might be a better solution than device-aspect-ratio as the user might change the
    dimensions of the browser window independently of the device-screen-ratio. However,
    in order to determine the device's true aspect ratio, the alternative would be
    to use device-aspect-ratio.
  prefs: []
  type: TYPE_NORMAL
- en: Also, keep in mind that it is quite possible to define redundant media queries
    when querying the aspect ratio. In a case such as this, as is the case with CSS,
    the last matching expression overrules previous duplicated expressions and values.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The previous code example shows six media query expressions, all of which evaluate
    to the same aspect ratio. Whether the original expressed ratio is a duplicate
    of a previous value or a different value that reduces to the same ratio, the end
    result is the same. When equal ratios are found and no other expression breaks
    the tie by further qualifying the whole expression, then the last occurrence of
    the duplicate expression becomes the only active query for values not unique to
    the previous expressions. For example, if two or more expressions evaluate to
    the same aspect ratio, whatever CSS attributes that both expressions had in common
    are given priority to the last occurrence of the query. Unique values between
    each expression get cascaded to the final evaluation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code snippet, three separate media queries evaluate to the same
    aspect ratio. The last query also uses a `min` modifier, meaning that it matches
    any aspect ratio that is not 1/1 (as well as any aspect ratio that is exactly
    1/1), but the device width is still larger than the height (in other words, any
    media types of aspect ratio 1/1 and any media types of orientation landscape).
  prefs: []
  type: TYPE_NORMAL
- en: In this case, when a media type is `landscape` (remember a square or 1/1 aspect
    ratio is never considered landscape), only the third query matches the current
    state. Thus, only the color attribute is assigned to the `h1` tag specified in
    that media query. However, when the aspect ratio is in fact 1/1, then all three
    of media queries evaluate to true, thus all three queries are applied to the elements
    they specify.
  prefs: []
  type: TYPE_NORMAL
- en: The first query only sets a color of the tag to green. The second query resets
    that tag color and additionally applies a few more attributes to the tag. Finally,
    the third query again resets the tag color, but doesn't touch any other property.
    The final result for these composite queries for a media type with a 1/1 aspect
    ratio can be seen in the following code snippet.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: color
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This media query attribute checks for the number of bits per color component
    used by the output device. For example, if the output device uses an 8-bit color
    system, where it uses 2 bits to represent the red, green, blue, and alpha components,
    then the color attribute in the media query expression is 2\. The `min` and `max`
    modifiers can also be used to test for this as well.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: If the output device is not a color device then the value of the color attribute
    will be zero.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In some instances, where the output device uses different bit counts per color
    component, the color attribute refers to the smallest value of bits per component.
    For example, if the output device uses an 8-bit color system and it uses 3 bits
    for the red component, 3 for the green component, and 2 for the blue component
    then the value used as the color attribute for the media query will be 2.
  prefs: []
  type: TYPE_NORMAL
- en: color-index
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `color-index` attribute returns the number of colors used by the output
    device. For example, a device with 256 colors would match the following media
    query exactly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As with the color attribute, values specified for the color-index attribute
    cannot be negative. Also, if the output device does not use a color lookup table,
    the value for color-index is zero.
  prefs: []
  type: TYPE_NORMAL
- en: monochrome
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If an output device is monochrome, this media query attribute refers to the
    number of bits per pixel used by device. This is similar to color, but only applies
    to monochrome devices and, for obvious reasons, only for a single pixel, as opposed
    to the lowest color component.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: If the device is not monochrome, this attribute will match a value of zero.
    Also, we can use the `min` and `max` modifier keyword to target ranges. Alternatively,
    a single Boolean expression can be used to determine whether the device is monochrome
    or not.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: resolution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Contrary to what one might be led to believe, the resolution attribute does
    not query the screen resolution as in the resolution we can set to our monitor
    through the operating system. Instead, the resolution attribute queries the pixel
    density (or dot density in the case of a printer) measured in dpi (dots per inch
    or pixels per inch) as well as dpcm (dots or pixels per centimeter).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `min` and `max` modifiers are valid in this query expression. If the output
    device does not use square pixels, using `min-resolution` queries against the
    least dense dimension of the output device. When a `max-resolution` query is issued,
    the most dense dimension of the output device is used to evaluate the expression.
  prefs: []
  type: TYPE_NORMAL
- en: scan
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When rendering on a television, the scan attribute queries the scanning of the
    device. The only possible values are `progressive` and `interlace`. Using the
    `min` and `max` modifiers does not make sense in the context of a television's
    scan process and thus makes an invalid expressions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: grid
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A grid output device is one that is not a bitmap-based device. Querying the
    `grid` attribute returns true when the output device is not bitmap-based. The
    only possible values to query against are 1 and 0\. The `min` and `max` modifiers
    are not valid in this query.
  prefs: []
  type: TYPE_NORMAL
- en: Examples of grid-based devices include any device that uses a character grid,
    such as those older calculators or even older model cell phones with fixed fonts.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Understanding touch events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although similar in nature to an ordinary mouse click, a touch event allows
    us to interact with the computer primarily through a point and respond manner.
    However, touches are far more flexible than clicks and thus open up the stage
    for a whole new type of game.
  prefs: []
  type: TYPE_NORMAL
- en: Fundamentally, a touch is different than a click in that more than one touch
    is possible on the same surface, at the same time. Also, a touch is generally
    different than a click in that it allows for a larger target area as well as varying
    pressure. I say generally because not all devices detect the touch area with high
    precision (or with any precision at all) or touch pressure. Similarly, some mouse
    or other equivalent input devices actually do offer pressure sensitivity, although
    most browsers don't have use of such a feature, neither do they expose that data
    through a click event object.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For compatibility purposes, most mobile browsers respond to touch events when
    JavaScript code expects a touch. In other words, a click handler can be triggered
    by the user touching the screen. In this case, a regular click event object is
    passed to the registered `callback` function and not a touch event object. Furthermore,
    the experience might differ between a drag event (the `dragMove` event) and a
    touch move event. Finally, multiple touches may or may not trigger simultaneous
    click event listeners.
  prefs: []
  type: TYPE_NORMAL
- en: There are three events related to touch, namely touch start, touch move, and
    touch end. Touch start and touch end can be related to the mouse down and mouse
    up events respectively, while a touch move event is similar to a drag move event.
  prefs: []
  type: TYPE_NORMAL
- en: touchstart
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This event is triggered when the touch area detects a new touch, whether or
    not one or more touch events have already started and have not yet ended.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The object passed into the registered `callback` function is an instance of
    the `TouchEvent` class, which contains the following attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: touches
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An instance of the `TouchList` class which looks like an ordinary array and
    contains a list of all touches that have been touched down on the touch device
    and have not yet been removed, even if other active touches have moved about the
    screen or input device. Each element in this list is an instance of type `Touch`.
  prefs: []
  type: TYPE_NORMAL
- en: changedTouches
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An instance of the `TouchList` class containing a list of touch objects representing
    all new touch points that have been introduced since the last touch event. For
    example, if two touch objects have already been detected (in other words, two
    fingers have been pressed against the touch device) and a third touch is detected,
    only this third touch is present in this touch list. Again, every touch-related
    element contained by this touch list is of type `Touch`.
  prefs: []
  type: TYPE_NORMAL
- en: targetTouches
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An instance of the `TouchList` class containing a list of touch objects representing
    all touch points that have been captured by a given DOM node. For example, if
    multiple touches have been detected throughout the screen but a particular element
    registered for a touch start event and captured this event (either from the capture
    or bubble stage), only touch events captured by this node will be present in this
    touch list. Again, every touch-related element contained by this touch list is
    of type `Touch`.
  prefs: []
  type: TYPE_NORMAL
- en: touchend
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Similar to a mouse up event, a `touchend` event is fired when any of the registered
    touch events leave the input touch device.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Just like a `touchstart` event, the object passed into the registered `callback`
    function is an instance of the `TouchEvent` class, which contains the same three
    `TouchList` attributes. The context of the `touches` and `targetTouches` attributes
    are the exact same as their version found in `touchstart`. However, the `changedTouches`
    touch list has a slightly different meaning in this event.
  prefs: []
  type: TYPE_NORMAL
- en: Although the `TouchList` object inside a `touchend` event is the exact same
    as the one in `touchstart`, the list of touch objects contained here represents
    touches that have left the touch input device.
  prefs: []
  type: TYPE_NORMAL
- en: touchmove
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `touchmove` event, analogous to a `drag` event, is fired whenever at least
    one of the registered touch objects changes position without triggering a `touchend`
    event. As we'll soon see each touch object is uniquely tracked so that it is possible
    to determine if any of the registered touch objects have moved and which ones
    have actually displaced.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Again, just like a `touchend` event, the object passed into the registered `callback`
    function is an instance of the `TouchEvent` class, which contains the same three
    `TouchList` attributes. The context of the `touches` and `targetTouches` attributes
    are the exact same as their version found in `touchstart`. The touch objects in
    the `changedTouches` list in the `touchmove` event represent previously registered
    touches that have moved about the input device.
  prefs: []
  type: TYPE_NORMAL
- en: One important thing about the `touchmove` event is that it can be associated
    with a `drag` event. If you notice, the default behavior for a `drag` event is
    to scroll the page in the direction of the scroll. In some applications involving
    dragging across the screen with a finger, this behavior may not be desired. For
    this reason, the `event.preventDefault()` method is called, which produces the
    effect of alerting the browser that no scrolling is desired. If, however, the
    intention is to scroll the screen with a `touchmove` event, provided that the
    element being touched supports such behavior, this can be accomplished by omitting
    the call to the prevent default function.
  prefs: []
  type: TYPE_NORMAL
- en: The touch object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, you may have noticed that each `TouchList` object holds instances of a
    very specific object which is an instance of the `Touch` class. This is important
    because the input device needs to keep track of individual touches. Otherwise,
    the list of `changedTouches` would not be accurate thus limiting what we can accomplish
    with the API.
  prefs: []
  type: TYPE_NORMAL
- en: The way that each touch can be uniquely identified is by having the input device
    assign a unique ID to each event it captures. This ID remains the same for the
    same touch object until that object is released (in other words, when that particular
    touch leaves the input device).
  prefs: []
  type: TYPE_NORMAL
- en: Lets take a look at all the other properties of the `Touch` class and see what
    other important information is contained therein.
  prefs: []
  type: TYPE_NORMAL
- en: identifier
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A unique integer identifier for a particular touch event contained in the current
    touches `TouchList`. This number remains the same until a touch event leaves the
    input device, which allows us to track each touch individually even if many other
    touch objects are starting, moving, and ending while the one particular touch
    object can be singled out and kept appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: Note that sometimes the value of this attribute may match the array index value
    of the touch object within a `TouchList` object. Sometimes the identifier property
    might even match the order in which each touch was detected by the input device.
    As an attentive programmer, you must never assume that these two values will always
    be the same.
  prefs: []
  type: TYPE_NORMAL
- en: For example, suppose that the first time a touch is detected by the device it
    has an identifier ID of zero (and since this is the first touch in the **TouchList**,
    it will obviously be indexed into the list with an index value of zero). Now a
    second touch is detected, making it the second object in the **TouchList** array,
    which would give it an index key of one. Suppose this touch also receives an identifier
    of one so that all three values match (touch order, array order, and identifier
    value). Now, after moving these two touches around the input device, suppose the
    first touch object is released and a new touch event is detected. Now there are
    again two touch objects in the **TouchList**, but their values are completely
    different than the first two touch elements. While the second touch event still
    has the same identifier (in this example, the identifier was one), it's now (possibly)
    the first element in the **TouchList**.
  prefs: []
  type: TYPE_NORMAL
- en: Although at times the order in which a touch is detected, the touch's position
    in the **TouchList** array, and the touch's unique identifier number may all match
    (assuming that the input device even assigns specific identifier values), you
    should never use any of these assumptions to track individual touches. A touch
    should always be tracked by its unique identifier attribute when more than one
    touch is being tracked. If only a single touch is tracked, that touch will always
    be the first element in the `TouchList` object.
  prefs: []
  type: TYPE_NORMAL
- en: '![identifier](img/6029OT_08_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In summary, the order in which touches are detected and assigned to the `TouchList`
    object is unpredictable and should never be assumed. The proper way to track individual
    touch objects is through the identifier property assigned to each object. Once
    a touch event is released, the value of its former identifier property can be
    reassigned to a consequent touch, so be sure to keep that in mind as well.
  prefs: []
  type: TYPE_NORMAL
- en: screenX
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `screenX` coordinate refers to the point in the browser viewport that was
    touched relative to the origin of the system display. The origin of the browser's
    viewport is not taken into account in this calculation at all. Point (0, 0) is
    the upper left corner of the monitor, and however many pixels to the right of
    it is touched, that's where this attribute will refer.
  prefs: []
  type: TYPE_NORMAL
- en: screenY
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `screenY` coordinate refers to the point down from the system's screen (monitor),
    independent of where the browser is relative to that. If the screen is, say, 800
    pixels in height and the browser is set up with a height of, say, 100 pixels located
    exactly 100 pixels below the top of the screen, then at touch a the half-way point
    between the browser's viewport's top and bottom left corners would result in the
    touch's `screenY` coordinate being 150.
  prefs: []
  type: TYPE_NORMAL
- en: Think about it, the browser's viewport has 100 pixels in height so that it's
    midpoint is exactly 50 pixels below its origin. If the browser is exactly 100
    pixels below the screen's origin, that midpoint is 150 pixels below the screen's
    vertical origin.
  prefs: []
  type: TYPE_NORMAL
- en: The `screenX` and `screenY` attributes almost look like they don't take the
    browser's coordinate system into account whatsoever. With that, since the origin
    the browser bases its calculations off of its screen's origin, then it follows
    that a point returned by `screenX` and `screenY` will never be less than zero,
    since there is no way we can touch a point outside the screen's surface area and
    still have the screen detect that point.
  prefs: []
  type: TYPE_NORMAL
- en: clientX
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Similar to `screenX`, `clientX` coordinate refers to the offset from a touch
    location from the browser's viewport's origin, independent of any scrolling within
    the page. In other words, since the origin of the browser's viewport is its upper
    left corner, a touch 100 pixels to the right of that point corresponds to a `clientX`
    value of 100\. Now, if the user scrolls that page, say, 500 pixels to the right,
    then a touch to the right of the browser's left border by 100 pixels would still
    result in a `clientX` value of 100, even though the touch occurred at point 600
    within the page.
  prefs: []
  type: TYPE_NORMAL
- en: clientY
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `clientY` coordinate refers to the point down from the browser's viewport
    origin, independent of where within the page the touch occurred. If the page scrolls
    an arbitrary amount of pixels to the right and to the bottom and a touch is detected
    at the very first pixel to the right of the upper left corner of the browser's
    viewport and exactly one pixel down, the `clientY` value would be calculated as
    1.
  prefs: []
  type: TYPE_NORMAL
- en: The `clientX` and `clientY` attributes don't take the web page's coordinate
    system into account whatsoever. With that, because this point is calculated relative
    to the browser's frame, it follows that a point returned by `clientX` and `clientY`
    will never be less than zero since there is no way we can touch a point outside
    the browser's viewport surface area and still have the browser detect that point.
  prefs: []
  type: TYPE_NORMAL
- en: pageX
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Finally, the coordinate represented by `pageX` refers to the point within the
    actual page where the touch was detected. In other words, if a browser is only,
    say, 500 pixels wide but the application is 3000 pixels wide (meaning that we
    can scroll the application's content to the right by 2500 pixels), a touch detected
    exactly 2000 pixels from the browser's viewport's origin would result in a `pageX`
    value of 2000.
  prefs: []
  type: TYPE_NORMAL
- en: In the world of gaming, a better name for `pageX` would probably be `worldCoordinateX`
    since the touch takes into account where within the world the touch event took
    place. Of course, this only works when the web page physically scrolls, not when
    a representation of a scroll has taken place. For example, say we render a world
    onto a 2D canvas and the world is actually much larger than the width and height
    of the canvas element. If we scroll the virtual map by an arbitrary amount of
    pixels but the canvas element itself never actually moved, then the `pageX` value
    will be meaningless with respect to the game's map's offset.
  prefs: []
  type: TYPE_NORMAL
- en: pageY
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: And to conclude, the `pageY` coordinate refers to the point where the touch
    was detected below the browser's viewport's origin, plus any scrolled offsets.
    As with the other touch point locations, it is impossible to obtain a negative
    value for the `pageX` and `pageY` attributes since there is no way to touch a
    point in the page that has not been scrolled to yet, especially a point behind
    the origin of the page where we cannot ever scroll to.
  prefs: []
  type: TYPE_NORMAL
- en: The following illustration shows the difference between screen, client, and
    page location. The screen location refers to the location within the screen (not
    browser window), with the origin being the upper left corner of the display. Client
    location is similar to screen location, but places the origin at the top left
    corner of the browser viewport. Even if the browser is resized and moved half
    way across the screen, the first pixel to the right of the browser viewport will
    be point (0, 0). Page location is similar to client location but takes into account
    any scrolling within the browser viewport. If the page is scrolled down 100 pixels
    vertically and none horizontally, the first pixel to the right of the left margin
    of the browser viewport will be (100, 1).
  prefs: []
  type: TYPE_NORMAL
- en: '![pageY](img/6029OT_08_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: radiusX
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When a touch is detected by the input device, an ellipse is drawn around the
    touch area by the input device. The radius of that ellipse can be accessed through
    the `radiusX` and `radiusY` attributes, hinting at how much area is covered by
    the touch. Keep in mind that the accuracy of the ellipse that describes the area
    touched is determined by the device used, so mileage may vary greatly here.
  prefs: []
  type: TYPE_NORMAL
- en: radiusY
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In order to get the radius across the horizontal axis of the ellipse formed
    by the touch detected by the input device, we can use the `radiusY` attribute.
    With that information, we can add an extra depth to the types of applications
    we can create using touch as input.
  prefs: []
  type: TYPE_NORMAL
- en: As an example application, the following code snippet detects as many touches
    as the input device can handle simultaneously, keeping track of the radius of
    each touch, then displaying each touch at its approximate size.
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to set up the document viewport to be the same width and height
    as the device as well as set initial zoom levels. We also want to disable pinching
    gestures, because in this particular sample application, we want that gesture
    to act as any other touch movement and not have any special meaning.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The meta viewport tag allows us to define specific width and height values for
    the viewport, or use the optional device-width and device-height attributes. If
    only a width or height value is specified, the other is inferred by the user agent.
    The tag also allows us to specify a default zoom level as well as disable zooming
    through gestures or other means.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to make sure the root DOM node in the application stretches the
    entire width and height of the display so that we can capture all touch events
    within it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We set the `body` tag to be as wide as the viewport and remove any margin and
    padding from it so that touches near the edge of the screen would not be missed
    by the element's event handling. We also style the `div` elements to look round,
    have a red background color, and be absolutely positioned so that we can place
    one anywhere a touch is detected. We could have used a canvas element instead
    of rendering multiple `div` tags to represent each touch but that is an insignificant
    detail for this demo.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we get down to the JavaScript logic of the application. To summarize
    the structure of this demonstration, we simply use a global array where each touch
    is stored. Whenever any touch event is detected on the document, we flush that
    global array that keeps track of each touch, create a `div` element for each active
    touch, and push that new node to the global array. At the same time as this is
    happening, we use a request animation frame look to continuously render all the
    DOM nodes contained in the global touches array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: An example of multi touch taking into account the radius of each touch is illustrated
    as follows. By touching the side of a closed fist to a mobile device, we can see
    how each part of the hand that touches the screen is detected with their relative
    size and area of contact.
  prefs: []
  type: TYPE_NORMAL
- en: '![radiusY](img/6029OT_08_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: rotationAngle
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Depending on the way a touch is detected, the ellipse that represents the touch
    might be rotated. The `rotationAngle` attribute associated with each touch object
    is the clockwise angle in degrees that rotates the ellipse to most closely match
    the touch.
  prefs: []
  type: TYPE_NORMAL
- en: force
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some touch devices are capable of detecting the amount of pressure applied to
    the surface of the input surface by the user. When this is the case, the force
    attribute represents that pressure with a variable between 0.0 and 1.0, where
    1.0 represents the maximum pressure that the device can handle. When a device
    doesn't support force sensitivity, this attribute will always return 1.0.
  prefs: []
  type: TYPE_NORMAL
- en: Since the value of the force attribute is always between zero and one, we can
    conveniently use this to render elements with a varying degree of opacity (with
    zero being a completely transparent—invisible—element and one being completely
    rendered).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: target
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When a touch event is detected, the DOM element, where the touch was first detected,
    is referenced through the `target` attribute. Since a touch object is tracked
    until the touch ends, the target attribute will reference the original DOM element
    where the touch was first started for the duration of the touch life cycle.
  prefs: []
  type: TYPE_NORMAL
- en: The game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we discussed at the beginning of this chapter, there are several considerations
    that must be kept in mind when designing and building a game to be played on a
    mobile device as well as on a desktop browser. As we write this final game in
    this book, we will apply those principles and best practices making a game to
    be playable on both a mobile device and an HTML5-ready browser.
  prefs: []
  type: TYPE_NORMAL
- en: The approach taken in this particular project is to design for desktop first
    then add mobile-specific APIs and functionality later. The number one reason for
    this decision was because it is much easier to test and debug an application on
    a desktop browser using existing tools and common practices, then add the things
    needed to make the code run smoothly on mobile as well.
  prefs: []
  type: TYPE_NORMAL
- en: The final game is a traditional two-dimensional space shooter, where the player
    controls a single ship that can move around the screen and always shoots up in
    the same direction. Random enemy space ships come from all sides of the screen,
    attempting to hit the player's ship, thus giving damage to the player's ship until
    it explodes.
  prefs: []
  type: TYPE_NORMAL
- en: '![The game](img/6029OT_08_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Code structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Given the complexity of this game, the structure of the code has to be carefully
    considered. For simplicity, we will use a component-based approach so that adding
    feature upon feature is much easier, especially when it comes down dynamically
    adding the input handling mechanism. Since the game needs to be played equally
    well on a mobile device as well as on a desktop (in other words, the game needs
    to take and handle mouse and keyboard input as well as touch input, depending
    on the environment in which it is played), being able to add a specific component
    to the game on the fly is a very important feature.
  prefs: []
  type: TYPE_NORMAL
- en: If you're not familiar with component-based game development, don't worry too
    much about it. The general idea of component-based development is to separate
    each piece of functionality from a class and make that functionality its own class.
    What this allows us to do is to create individual objects that represent individual
    pieces of functionality, such as moving, rendering, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final project structure for this game is as follows, where the list of
    files and directories shows the root of the project folder:'
  prefs: []
  type: TYPE_NORMAL
- en: /css
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is where the single stylesheet file is stored. This stylesheet defines
    all the styling for both the desktop and mobile versions, although there are very
    few differences between the two. The way to add CSS features to a version of the
    game is to declare these features inside CSS classes then assign those classes
    to DOM elements when appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we want to declare in this stylesheet is the viewport, making
    sure that every pixel within the screen is part of the document, so that we can
    capture input events everywhere on our document. We also want to keep the document
    from somehow growing larger than the viewport which would introduce scrollbars
    to the game, which in this case is not desired.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Two features that we want in our game, if the device running it supports it,
    are transitioned effects of DOM elements as well as animating the background image.
    In order to add that functionality only where appropriate (for example, adding
    this feature to some mobile devices might slow down the game play to unplayable
    levels, given the amount of processing the mobile browser would need to do in
    order to produce the CSS animation and transitions), we create the CSS animation
    and add it to a custom class. When we determine that the device can handle the
    animation, we simply add the class to the document.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Finally, in order to simplify some of the game user interface, we create some
    of the game elements as ordinary DOM elements, as opposed to rendering equivalent
    elements directly in the canvas where the rest of the game is rendered.
  prefs: []
  type: TYPE_NORMAL
- en: The only game element we're building as a DOM element is the energy bar for
    the player's ship, which indicates how much energy the ship has left. This energy
    bar is composed of a container element containing a `div` element inside of it.
    The width of this nested `div` represents the amount of energy the player has
    left, which can be a value between 0-100%.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: /img
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Inside this folder we store all the image assets used in the game. Since all
    of these images are rendered inside a canvas, we could have very well combined
    all of the images into a single image atlas. This would be a very nice optimization,
    especially as the game grows and the number of image assets grows. Since most
    browsers limit the number of parallel HTTP requests that an application makes
    to the same server, we can only fetch a limited amount of images at the same time.
    This means that if there are too many individual image files being fetched from
    the same server, the first 4-8 requests are processed (the default number of parallel
    connections to the same server varies from browser to browser but is usually around
    6 or so) while the rest of them wait in a queue.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, it is easy to see how creating a single image atlas asset is a much better
    choice over downloading multiple individual image files. Even if the total image
    file size of the atlas is greater than the total size of all the other images
    combined, the big gain is in the transfer latency. Even if the game doubles in
    individual image assets at some point in time, we would still only have to download
    a single image atlas (or a few separate atlases which can all be downloaded simultaneously).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since not everybody is highly talented when it comes to creating awesome looking
    graphics for your games and even fewer people have the time to create each image
    to be used in the game. Many game developers find it worthwhile to buy graphics
    from digital artists.
  prefs: []
  type: TYPE_NORMAL
- en: In this game, all of the graphics were downloaded from websites where artists
    share their creations for free or very low costs. The website address to this
    wonderful community is [http://opengameart.org](http://opengameart.org).
  prefs: []
  type: TYPE_NORMAL
- en: /js
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As mentioned earlier, this game is built on a component-based model. The file
    structure is divided into four main categories; namely components, entities, widgets,
    and general purpose code. Each of these pieces of code are meant to be somewhat
    generic and reusable. The gluing together of all these pieces is done in a file
    called `main.js`.
  prefs: []
  type: TYPE_NORMAL
- en: /components
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The components directory is where we store all of the components used in the
    game. In the context of game development, a component is a very specific class
    that may contain its own data and performs a very specific function. For example,
    when designing a class to represent the player, instead of having this class handle
    the rendering of the player's ship, moving, performing collision detection, and
    so on, we can break down each piece of functionality from this class into many
    individual smaller classes—or components.
  prefs: []
  type: TYPE_NORMAL
- en: Commonly, each component in your game implements a common interface so we can
    take advantage of object-oriented techniques. Although classical inheritance and
    other object-oriented techniques can be simulated in JavaScript, we simply copy
    the same base interface for each component and make the assumption in our client
    code that every component follows the same interface.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Every component in this game has two things in common. They all live within
    the `Pack.Components` object simulating a package-based structure and they all
    hold a reference to the parent entity that uses the service provided by the component.
  prefs: []
  type: TYPE_NORMAL
- en: The first component that we'll create will be the `sprite` component, which
    is responsible for rendering an entity. As we'll see in our discussion about entities,
    an entity only keeps track of its own position in the game world and has no notion
    of its width and height. For this reason, the `sprite` component also keeps track
    of the entity's physical size as well as the image that represents the entity
    visually.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Once the functionality to render an entity is in place, we can now move on to
    adding a component to allow the player to move the entity about the screen. Now,
    the whole point of using components is to allow for maximum code reuse. In our
    case, we want to reuse the component that makes a player move so that we can have
    each enemy ship move about the game world using the same functionality.
  prefs: []
  type: TYPE_NORMAL
- en: To make the entity move, we use a very standard `Move` component which moves
    the entity based on its direction vector and a constant speed at which the entity
    is to move in this given direction. The `Vec2` data type is a custom general purpose
    class discussed later in the chapter. Basically, this class represents a vector
    where it holds two variables representing the two components of a vector and defines
    a very handy function to normalize the vector when needed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Now, the way that both a player and an enemy can use this same `Move` component
    to move their entities is slightly different. In the case of an enemy, we can
    simply create some raw artificial intelligence to set the direction of the enemy's
    entity every so often and the `Move` component takes care of updating the entity's
    position as needed.
  prefs: []
  type: TYPE_NORMAL
- en: In order to make the player's ship move, however, we want the player himself
    or herself to tell the entity where to go. To accomplish this, we simply create
    an input component that listens for human input. However, since the player might
    be playing this game from a device that may support either mouse events or direct
    touch events, we need to create two separate components to handle each case.
  prefs: []
  type: TYPE_NORMAL
- en: These components are identical in every way, except for the fact that one registers
    for mouse events and the other for touch events. While this could have been done
    inside a single component, and conditional statements dictated which events to
    listen for instead, we opted for separate components in order to make the code
    less coupled to any particular device.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Next, let's look at a very crucial component of any game with moving entities,
    namely the `physics` components whose sole responsibility in life is to tell if
    two entities collide. This is done in a very simple and efficient fashion. In
    order for an entity to be able to use the `physics` component, it must also have
    a `sprite` component since the `physics` component needs to know where each entity
    is located as well as how tall and wide each entity is. With a `sprite` component,
    we're able to extract both pieces of information about each entity.
  prefs: []
  type: TYPE_NORMAL
- en: The way to check whether two entities collide is very simple. The component
    itself stores a reference to an entity so the function that performs the check
    needs to know the position and size of the entity we're checking against for collision.
    Once we have the location and dimensions of both entities, we simply check if
    one entity's right side is to the left of the other's left side, if one's left
    side is to the right of the other's right side, or if one's bottom is above the
    other's top, and if one's top is below the other entity's bottom. If any of these
    tests passes (in other words, the conditional check returns positive) then we
    know that there is no collision, since it is impossible for two rectangles to
    be intersecting each other, and yet any of those four statements are true about
    them. Similarly, if all of those tests fail, we know that the entities are intersecting
    each other and a collision has occurred.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The last two components used in the game are very simple and are slightly more
    unique to this particular type of game than the other components. These components
    are the `Strength` component and the `LaserGun` component, which gives entities
    the ability to shoot laser beams at other entities.
  prefs: []
  type: TYPE_NORMAL
- en: The `Strength` component isolates the management of the player's own energy
    as well as all enemy ships and everybody's lasers. This component is used to determine
    if an entity is still alive and how much damage it can cause on other entities
    upon contact. If an entity is no longer alive (if its strength has gotten below
    zero) then it is removed from the game altogether, as is the case with lasers
    every time they collide with another entity.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The `LaserGun` component is slightly more involved because it contains a collection
    of entities that it manages. Each time a laser beam is fired by the entity containing
    the laser gun, a new entity is created to represent that laser beam. This entity
    is similar to all the other entities in the game since it also contains a `sprite`
    component to draw itself a `Move` component and a `physics` component as well.
  prefs: []
  type: TYPE_NORMAL
- en: Each time the laser gun updates itself, it needs to move all of its lasers forward
    and remove any of its laser beams from its control if the laser has gone outside
    the screen area.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: With all of our major components in place, we're ready to take a look at the
    other classes in the game. Remember, though, that the whole purpose of using components
    is to simplify development and to loosen the coupling between individual pieces
    of functionality. Thus, if we wanted to add more components to the game, say,
    an explosion effect component, for example, all we'd need to do is follow the
    same basic structure of a component and we'd be ready to simply plug it into the
    main game logic script.
  prefs: []
  type: TYPE_NORMAL
- en: /entities
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Entities are the main building blocks of the game. They are the generalized
    representation of anything that we can interact with—the player's ship, enemy
    ships, or laser beams. Some people call their entities objects, characters, or
    actors, but the idea behind them is the same.
  prefs: []
  type: TYPE_NORMAL
- en: In our game, we don't extend the base entity class in order to create a distinction
    between ships and lasers. The only thing that sets them apart are the components
    they use and how those components are used.
  prefs: []
  type: TYPE_NORMAL
- en: The structure of our game entities is basic and to the point. Each entity keeps
    track of its own position within the game world, a flag that indicates its state
    (whether the entity is active or not—dead or alive), a list of components, and
    an update function. Also, for simplicity, each entity declares a `draw` function
    which delegates the actual drawing to the `sprite` component, if the entity happens
    to have one. We also define a few general purpose functions inside each entity
    so as to make adding, removing, and using components a bit easier. Finally, each
    entity allows for a custom update function, so that each instantiated entity can
    update itself differently.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this entity class is really quite bare bones. It takes into
    account what our game needs to do, what is used in the game, and it encapsulates
    the most common functionality based on that. From here we can instantiate an entity
    and add components to it, making it a very unique entity, based on all that it
    potentially can and cannot do.
  prefs: []
  type: TYPE_NORMAL
- en: /widgets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The only widget used in this game is the `EnergyBar` widget. The whole point
    of widgets is to simplify the management of different user interface elements.
    The way in which each widget decides how to display the elements they represent
    is their own business and any client code using them should only be concerned
    about the interface through which it can communicate with the widget.
  prefs: []
  type: TYPE_NORMAL
- en: What the `EnergyBar` widget does is display a horizontal bar across the top
    of the page representing how much energy the player has left. Each time the player
    is hit by an enemy ship, its energy levels drop by some amount. When that energy
    meter goes to zero, the player dies, and the game is over.
  prefs: []
  type: TYPE_NORMAL
- en: One way this energy bar could have been rendered was through the canvas API,
    where the widget was rendered directly on the game canvas. While this is a very
    acceptable solution as well as a very common one, I decided to just use a plain
    old DOM element instead. This way the styling can be changed much more easily
    through CSS and nothing else would need to be changed within the code. In other
    words, while someone worked on the actual code, a second person could work on
    styling the widget and all they'd need to access would be the stylesheet associated
    with it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: When an `EnergyBar` widget is instantiated, it creates its own DOM element that
    represents the widget, adding any CSS classes and IDs associated with it. The
    member attribute energy represents the amount of energy that an entity has and
    the width of one of the DOM elements created by the widget matches to the percentage
    of energy it contains. After a widget's element has been added to the document,
    we can simply communicate with the widget class through its public interface and
    the DOM elements displayed on the document get updated accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Canvas.js
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With the exception of the `EnergyBar` widget, everything else rendered to the
    screen in this game is rendered through a canvas, using the 2D rendering context.
    In order to keep things together and make the code more organized, we create a
    very simple abstraction over the canvas API. Instead of keeping track of a canvas
    variable referencing some DOM element, along with its accompanying context reference,
    we encapsulate the canvas element, the JavaScript reference to it, and the reference
    to the rendering context all inside a single object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: We also hide some of the detailed functionality of the canvas API by adding
    a few helper functions, such as `getWidth`, `getHeight`, and `clear`, so that
    other areas in the code can interact with the canvas through this simplified interface.
  prefs: []
  type: TYPE_NORMAL
- en: One other reason that an abstraction such as this can be very handy is that
    it would greatly simplify things if we decided to use two or more canvases. Suppose
    we wanted to render a widget into its own canvas. Without an abstraction like
    this, we would now have four separate variables to keep track of in our code.
  prefs: []
  type: TYPE_NORMAL
- en: A common optimization pattern in HTML5 game rendering with the 2D canvas is
    to separate the rendering into layers. For example, things that don't change very
    frequently from frame to frame (such as the background graphics of a level) can
    be re-rendered much less frequently than dynamic objects that may need to be rendered
    at a different location each frame (the player and the enemies that are trying
    to kill the hero). Instead of redrawing each and every pixel of the background
    graphics each frame, since most of those pixels are the exactly same as the previous
    frame, we can draw the entire background scene onto its own canvas and absolutely
    position it behind another canvas that only draws on smaller parts of it, making
    it much easier to redraw every frame.
  prefs: []
  type: TYPE_NORMAL
- en: Since the background layer doesn't change too often, if at all, we can render
    more complex graphics onto it and not have to worry about redrawing anything there
    very often. Although the foreground layer normally needs to be cleared and redrawn
    every single frame, we can still maintain a good frame rate because we're normally
    only rendering on a small portion of the foreground canvas, which doesn't take
    as much processing as it would to redraw the background layer every frame.
  prefs: []
  type: TYPE_NORMAL
- en: '![Canvas.js](img/6029OT_08_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now it becomes easy to see how valuable a simple canvas abstraction can be when
    using more advanced rendering techniques. In most cases, even if we're just rendering
    on a single canvas, being able to encapsulate all the loose variables associated
    with a canvas often makes things more efficient, especially when you need to pass
    the canvas and the canvas context around to other functions and classes.
  prefs: []
  type: TYPE_NORMAL
- en: EnemyManager.js
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since the player of our game will only control a single entity throughout the
    entire game, creating an instance of the entity class and letting the player control
    that entity is trivial. The challenge is finding a way to create enemy entities,
    move them around, and manage them as the game progresses. To solve this problem,
    we create an `EnemyManager` class, whose job is to create enemy entities when
    needed and manage their existence.
  prefs: []
  type: TYPE_NORMAL
- en: While this may seem like a complex task, it becomes more manageable if we break
    down the task into smaller pieces. The responsibilities that the `EnemyManager`
    class has include creating a new enemy entity and adding it to a list of active
    entities that it stores, updating each entity individually, and removing any dead
    entities from the entity list it manages.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Because we are using a component-based architecture, these three tasks aren't
    complex at all. In order to create a new entity, we simply instantiate the class
    and add the necessary components it needs to function. To add variety to the game,
    we can randomly assign a different `sprite` to each entity created as well as
    randomly tweak the properties of each entity, such as making it move faster, cause
    more damage, look bigger, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Removing dead entities is even easier. All we need to do is iterate over the
    list of active entities and remove them from the list if the active flag for an
    entity is unset. One thing we could also do is remove any entities that wander
    too far off the screen area, so that we don't need to manage entities that can't
    possibly be hit by the player's lasers.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the update function takes the job of updating each active entity's
    position (or rather, it tells each entity to update its own position based on
    the direction they're headed), simulate some basic artificial intelligence by
    moving each entity forward, then removing any dead entities.
  prefs: []
  type: TYPE_NORMAL
- en: GameLoop.js
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The game loop class takes care of running the game's logic for each frame. The
    main added value that we get from using a class such as this is that we can encapsulate
    this boilerplate functionality and reuse it with different settings with minimal
    effort.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: When we create an instance of this class, we tell it how fast we want the game
    loop to run in terms of frames per second and the class takes care of the rest.
    Once this is set up, the class will class its own update class at whatever frequency
    we tell it to. As an added bonus, we can also specify our own update function
    to be executed every time the game loop ticks.
  prefs: []
  type: TYPE_NORMAL
- en: PhysicsManager.js
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Similar to the `EnemyManager` class, the `PhysicsManager` class is responsible
    for isolating complex functionality so that the client code is cleaner and the
    functionality can be reused elsewhere. Since this class is a bit more involved,
    we won't be showing the complete source code for it in the book. As with the other
    chapters, check out Packt's website for this book.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, the `PhysicsManager` class takes a reference to all of the enemy
    entities (which it can get from the `EnemyManager` object), all of the player's
    laser beams, and the player's entity itself. Then, inside its update method, it
    checks for collision between all of those entities.
  prefs: []
  type: TYPE_NORMAL
- en: Vec2.js
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since the `physics` engine of this game makes extensive use of vector structures
    and since JavaScript doesn't provide native vector data types, we decided to create
    our own. This simple class represents a vector with two components and provides
    a function to normalize the vector. This is especially useful when we want to
    move an entity in whichever direction it faces.
  prefs: []
  type: TYPE_NORMAL
- en: main.js
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Finally, we bring it all together in a file that we might as well call `main.js`.
    This file looks an awful lot like me when I go to a fast food restaurant: take
    one of everything and see how it all goes together. First we instantiate a canvas
    object, then the player entity, an `EnemyManager` object, a `PhysicsManager` object,
    and finally, a game loop object. After everything is wired up, we start the game
    loop and the game is set in motion.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The main reason for the self-invoked main function is to privately scope all
    of the variables contained within the function is to prevent users from manipulating
    the game from a browser's JavaScript console. Had the game variables all been
    stored in the global scope, anyone with access to that would be able to manipulate
    the game state. Also, since this function is merely a setup function, this would
    be the perfect place to put any conditional logic to load alternate resources
    based on the user agent executing the script.
  prefs: []
  type: TYPE_NORMAL
- en: index.html
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The host page for this game could not be any briefer. All that we do in this
    file is load all of our resources. Since different components sometimes depend
    on other components or other modules defined in our game (and since JavaScript
    provides no mechanism to load individual components into a script), the order
    in which our JavaScript resources are loaded is important.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Mobile optimizations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this final section, let's take a look at a few aspects of the game that we
    could (and should) optimize particularly for deployment on mobile devices. Although
    some of the following optimizations discussed also overlap in terms of desktop
    optimizations, they are especially impactful in mobile web development.
  prefs: []
  type: TYPE_NORMAL
- en: Combine resources
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although it is a good practice to write loose, modular code, we must not stop
    there. Before deploying the application to a production server, we would be wise
    to at least combine all of those files into a single file. The easiest way to
    do this would be by simply concatenating each file and serving up that larger
    file instead of multiple ones.
  prefs: []
  type: TYPE_NORMAL
- en: The reason this is preferred over sending multiple individual files to the client
    is because after a certain amount of concurrent connection to the same server,
    the browser will queue consequent connections and the total time it will take
    to load all of the files will increase.
  prefs: []
  type: TYPE_NORMAL
- en: Also, after all of the resources have been combined into a single resource,
    we should also use one of the many available tools that lets us compress, minify,
    obfuscate, and uglify our code. Anything we can do to reduce the code to the smallest
    possible amount of bytes is a big win for a mobile player. One particularly powerful
    tool for the job is the popular open source Closure Compiler developed by Google.
    Among its many features, the Closure Compiler also offers a function that analyzes
    the final code and removes any unreachable, dead code. Doing this will further
    reduce the final size of the application code making it especially handy for download
    over limited network connections, such as those found in most mobile devices today.
  prefs: []
  type: TYPE_NORMAL
- en: Track touches by IDs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The way we wrote our component to handle user input through touch makes the
    assumption that only one touch will be used at all times. While this assumption
    may hold true for most of the time in our game, it may not be the case in other
    games. The `TouchDrag` component always looks for the touch information on the
    very first touch object found within the changed touches list. The only issue
    with that is that the original touch may not always be the first array element
    within its parent array.
  prefs: []
  type: TYPE_NORMAL
- en: To change this, all we need to do is keep track of the touch ID of the finger
    that first touches the screen, then reference that touch based on its identification
    value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: By tracking the original touch and only responding to it, we can guarantee fidelity
    in the touch input, even if multiple touches are initiated on the screen. This
    would also be the proper way of tracking separate touches for the purposes of
    implementing gestures or other input triggers based on an arbitrary combination
    of touches.
  prefs: []
  type: TYPE_NORMAL
- en: Use CSS animations with caution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is a strange phenomenon that sometimes happens in mobile browsers when
    we are too generous with some of the newer CSS properties. For example, if we
    add a box shadow to an element, we can still get pretty strong performance. Optionally,
    if we add a CSS transition to some other element, performance could still be maintained.
    However, if both of these properties are assigned together then performance all
    of a sudden drops down to barely playable conditions.
  prefs: []
  type: TYPE_NORMAL
- en: Since there is no formula that describes which properties should and should
    not be used, and which combinations should be avoided, the advice here is to use
    the least amount of CSS properties possible and add them slowly. In the case of
    our game, where the desktop version makes heavy use of CSS animations to render
    the background, we need to consider the implications that this may have on a mobile
    device. After trying the effect on the two most popular mobile platforms today
    and seeing performance drop severely, we concluded that the particular animation
    we wanted, along with a constantly rendering canvas, was too much for a mobile
    processor to handle.
  prefs: []
  type: TYPE_NORMAL
- en: One way to determine if a particular CSS animation is too demanding on a mobile
    device is to use profiling tools such as Google Developer Tools and take note
    of the sort of work that the browser needs to do in order to achieve the desired
    animation. In cases such as this game, where a background detail was so computationally
    intensive to generate that it conflicted with the calculations required to simply
    play the game, we might well opt for a less demanding alternative. In this game,
    instead of loading the CSS animation onto the document body, we simply display
    a still background graphic.
  prefs: []
  type: TYPE_NORMAL
- en: Use separate canvases for each game layer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As briefly discussed earlier, one powerful optimization technique in HTML5 rendering
    is to use more than one canvas. The point is to render less frequently those things
    that only need to be rendered every once in a while. Those things that need to
    be rendered much more often, we render by themselves in a dedicated canvas context
    so that no CPU (or CPU) power is used to render details around these elements.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the background scene of a game generally stays the same for several
    frames. Instead of clearing the entire canvas context, only to redraw those exact
    same pixels, on their exact same prior location, we can just render a background
    scene on a dedicated canvas and only render that scene again when the screen scrolls,
    or the scene otherwise changes. Until then, that canvas need not be bothered.
    Any movable objects and entities that need to be rendered multiple times per second
    can just be rendered on a second canvas, with a transparent background, so that
    the background layer can be seen through.
  prefs: []
  type: TYPE_NORMAL
- en: In this game, we could very well have rendered the image used as the background
    graphic onto a dedicated background layer, then provide the background animation
    to the canvas this way. However, since HTML5 provides a similar function that
    produces the same effect, we opted for that instead.
  prefs: []
  type: TYPE_NORMAL
- en: Use image atlases
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The idea behind image atlases is really quite brilliant. Since the canvas API
    specifies a function that allows us to draw onto the canvas context from a source
    image specifying the area within the image that the pixel copying is to take place,
    we can simply use one master image from which all of our graphics assets can be
    drawn.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of sending multiple loose images from the server down to the client,
    we can simply bundle all of our images into a single atlas file then draw each
    asset from a certain section of this larger collage.
  prefs: []
  type: TYPE_NORMAL
- en: Following is an image atlas with many smaller images inside it placed side by
    side, allowing us to retrieve each individual image from a single image asset.
    One of the main benefits of this technique is that we only need one HTTP request
    to the server in order to gain access to all of the images used within the atlas.
  prefs: []
  type: TYPE_NORMAL
- en: '![Use image atlases](img/6029OT_08_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Of course, the challenge in using this technique is that we would need a way
    to know where each particular image is located within the atlas file. While doing
    this by hand might not seem too cumbersome on a small project such as this one,
    the complexity of this task gets unruly very fast.
  prefs: []
  type: TYPE_NORMAL
- en: There exist many open source tools available to solve this very problem. These
    tools take individual loose image files, bundle them up in the smallest possible
    atlas that can be generated from the list of images provided, and also generate
    a JSON file that we can use to map each loose image to their new representation
    within the atlas.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter was dedicated to mobile development with the new HTML5 APIs available.
    We talked about the huge opportunity for game developers in the open web platform
    with regards to mobile devices as well as some of the main challenges associated
    with it. We talked about some best practices with mobile web development, which
    include degrading gracefully and enhancing progressively, designing for all finger
    sizes, saving battery life wherever possible, planning for offline game play,
    and offering a desktop version of your application.
  prefs: []
  type: TYPE_NORMAL
- en: The final two APIs presented in this chapter were CSS media queries and JavaScript
    touch events. Media queries allow us to check for other properties of the user
    agent viewing the document, such as viewport width, height, resolution, orientation,
    and so on. Depending on the properties set on the user agent executing our application,
    we can use media queries to load different CSS rules and documents, effectively
    modifying the document style at run time. The new JavaScript touch events are
    different from mouse events, in that multiple touches are allowed at the same
    time as well as pressure detection, touch size, and rotation angle.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have been introduced to the new features of HTML5, including the
    latest CSS and JavaScript APIs, the next step is for you to get some keyboard
    time and start developing your own games for the largest and most exciting computing
    platform of all time—the open web. Happy gaming!
  prefs: []
  type: TYPE_NORMAL
