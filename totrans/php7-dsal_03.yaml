- en: Using Linked Lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We know a lot about arrays already. Now, we are going to shift our focus to
    a new type of data structure known as a *list* . It is one of the most used data
    structures in the programming world. In most of the programming languages, the
    array is a fixed size structure. As a result, it cannot grow dynamically, and
    shrinking or removing an item from a fixed size array is also problematic since
    we have to shift the array's items to fill up the gap. For this reason, many developers
    prefer lists instead of arrays. Considering the fact that each array element can
    have an overhead of some extra bytes, linked lists can be used where memory efficiency
    is a big factor. In this chapter, we will explore the different types of linked
    lists in PHP and their implementation. We will also look at real-world problems
    that can be solved using linked lists.
  prefs: []
  type: TYPE_NORMAL
- en: What is a linked list?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A linked list is a collection of objects known as nodes. Each node is connected
    to the next node with a link, which is nothing but an object reference. If we
    consider the following image, each box represents a node. The arrow indicates
    the link between the nodes. This is an example of a singly linked list. The last
    node contains the next link of a NULL, so that it marks the end of the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00021.gif)'
  prefs: []
  type: TYPE_IMG
- en: A node is an object, meaning it can store any data type as simple as a string,
    integer, or float, or complex, such as an array, array of arrays, objects, or
    object arrays. We can store anything as per our need.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also perform a wide variety of operations on a linked list, such as
    the following ones:'
  prefs: []
  type: TYPE_NORMAL
- en: Checking whether the list is empty
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying all items in the list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Searching an item in the list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting the size of the list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inserting a new item at the beginning or end of the list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removing an item from the beginning or end of the list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inserting a new item at a specific place or before/after an item
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reversing a list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are only some of the operations that can be performed on a linked list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s write a simple linked list to store some names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We mentioned earlier that a linked list consists of nodes. We have created
    a simple class for our node. The `ListNode` class has two properties: one that
    will store the data and the other for the link called `next` . Now, we are going
    to implement a linked list using the `ListNode` class. For simplicity, we will
    just have two operations: `insert` and `display` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code actually implements our two basic operations for `insert`
    and `display` nodes. In the `LinkedList` class, we have two private properties:
    `$_firstNode` and `$_totalNodes` . Both have the default value of `NULL` and `0`
    , respectively. We need to mark the head node or first node, so that we always
    know where we have to start from. We can also call it the front node. Whatever
    name we provide, it will be mainly used to indicate the start of the linked list.
    Now, let''s move to the `insert` operation code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The insert method takes one argument, which is the data itself. We will create
    a new node with the data using the `ListNode` class. Before inserting a book title
    in our linked list, we have to consider two possibilities:'
  prefs: []
  type: TYPE_NORMAL
- en: The list is empty and we are inserting the first title
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The list is not empty and the title is going to be added at the end
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Why do we need to consider both cases? The answer is pretty simple. If we do
    not know whether the list is empty or not, we might get different results for
    our operations. We might also create invalid linking between the nodes. So, the
    idea is if the list is empty, our insert item is going to be the first item of
    the list. This is what the first part of the code is doing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see from the preceding code segment that we are creating a new node
    with the data and naming the node object `$newNode` . After that, it checks whether
    `$_firstNode` is `NULL` or not. If it is `NULL` , then the list is empty. If it
    is empty, then we assign the `$newNode` object to the `$_firstNode` property.
    Now, the remaining part of the `insert` method represents our second condition,
    which is that the list is not empty, and we have to add the new item at the end
    of the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Here, we get the first node of the list from the `$_firstNode` property. Now,
    we are going to iterate from the first node until the end of the list. We will
    ensure this by checking the condition that the next link for the current node
    is not `NULL` . If it is `NULL` , then we have reached the end of the list. In
    order to make sure that we are not looping to the same node all the time, we set
    the next node on from the current node as the current item during the iteration
    process. The `while` loop code implements the logic. Once we get out of the `while`
    loop, we set the last node of the linked list as `$currentNode` . Now, we have
    to assign the next link of the current last node to the newly created node named
    `$newNode` , so we simply put the object to the next link of the node. This object
    reference will work as a link between two node objects. At the end, we also increment
    the total node count value by 1 by post-incrementing the `$_totalNode` property.
  prefs: []
  type: TYPE_NORMAL
- en: We could have easily created another property for the list that would track
    the last node. It could have saved us from looping the whole list every time we
    are inserting a new node. We ignored this option intentionally to work through
    the basic understanding of the linked list. Later in this chapter, we will implement
    that for faster operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we look at our `display` method, we can see that we are using almost similar
    logic to iterate through each of the nodes and displaying its content. We first
    get the head item for the linked list. Then, we iterate through the list until
    the list item is NULL. Inside the loop, we display the node data by showing its
    `$data` property. Now, we have a node class `ListNode` to create individual nodes
    for the linked list, and we have the `LinkedList` class to do basic `insert` and
    `display` operations. Let''s write a small code to utilize the `LinkedList` class
    to create a linked list for book titles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we create a new object for `LinkedList` and name it `$BookTitles` . Then,
    we insert new book items using the `insert` method. We add three books, and then,
    we are displaying the book names using the `display` method. If we run the preceding
    code, we will see following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, there is a counter at the first line that shows that we have
    three book titles, along with their names. If we look carefully, we will see that
    the book titles are displayed the same way that we entered them. This means our
    implemented linked list is actually maintaining the order. This is because we
    have always entered the new node at the end of the list. We could have done this
    differently if we wanted. As our first example, we have covered a lot about linked
    lists and how to construct them. In the upcoming sections, we will explore more
    about how to create different types of linked lists, and with more complex examples.
    For now, we are going to focus on the different types of linked lists.
  prefs: []
  type: TYPE_NORMAL
- en: Different types of linked list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have dealt with the kind of list known as a singly linked list,
    or linear linked list. However, there are also several different types of linked
    lists based on the operations involved:'
  prefs: []
  type: TYPE_NORMAL
- en: Doubly linked list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Circular linked list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multi-linked list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Doubly linked lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In a doubly linked list, there are two links on each node: one to point to
    the next node and another one to the previous node. Where the singly linked list
    is unidirectional, the doubly linked list is bidirectional. We can move forward
    or backward in the list without any problem. The following image shows a sample
    doubly linked list. Later, in the *Implementing a doubly linked list in PHP* section,
    we will explore how to implement a doubly linked list:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00022.gif)'
  prefs: []
  type: TYPE_IMG
- en: Circular linked lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In a singly or doubly linked list, there is no node after the last node, so
    the last node does not have any subsequent node to iterate on. If we allow the
    last node to point to the first node, we are making a circle. Such linked lists
    are known as circular linked lists. We can have both singly and doubly linked
    lists as circular linked lists. We will also implement a circular linked list
    in this chapter. The following image depicts a circular linked list:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00023.gif)'
  prefs: []
  type: TYPE_IMG
- en: Multi-linked lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A multi-linked list, or multiply linked list, is a special type of linked list
    that has two or more links linking each node to another node. It can grow multi-directionally
    based on the purpose of the linked list. For example, if we take the example of
    a list of students with each student being a node with the properties of name,
    age, gender, department, major, and so on, then we can link each student''s node
    not only with the next and previous nodes, but also with age, gender, department,
    and major. Though the usage of such a linked list requires a good understanding
    of the linked list concept, we can use such special linked lists whenever we need.
    The following image depicts a multi-linked list:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00024.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Inserting, deleting, and searching for an item
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have seen only the operations for inserting a node and displaying
    all node contents. Now, we will explore the other operations available in a linked
    list. We will mainly focus on the following operations:'
  prefs: []
  type: TYPE_NORMAL
- en: Inserting at the first node
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Searching for a node
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inserting before a specific node
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inserting after a specific node
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deleting the first node
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deleting the last node
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Searching for and deleting one node
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reversing a linked list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting Nth position element
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inserting at the first node
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we add a node in the front, or head, we have to consider two simple possibilities.
    The list can be empty and as a result the new node is the head. This possibility
    is as simple as it can get. However, if the list already has a head, then we have
    to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create the new node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make the new node as first node or head.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assign the previous head or first node as the next to follow for the newly created
    first node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here is the code for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Searching for a node
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Searching for a node is pretty simple. We need to iterate through each node
    and check whether the target data matches with the node data. If the data is found,
    the node will be returned; otherwise, it will return `FALSE` . The implementation
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Inserting before a specific node
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This process is similar to the first operation that we looked at. The main
    difference is that we need to find out the specific node and then insert a new
    node before it. When we find the target node, we can change the next node so that
    it points to the newly created node, and then we can change the node following
    the newly created node so that it points to the node that we searched for. This
    is shown in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00025.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here is the code to implement the logic shown earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'If we inspect the preceding code, we can see that the logic is pretty straightforward.
    We have two parameters in this method: one is the `data` and one is the `query`
    . We iterate through each node. While doing this, we also track the current node
    and previous node. It is important to track the previous node as we will set the
    next of previous node to a newly created node when our target node is found.'
  prefs: []
  type: TYPE_NORMAL
- en: Inserting after a specific node
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This process is similar to the inserted a node before a target node. The difference
    is that we need to insert the new node after the target node. Here, we need to
    consider the target node as well as the next node, to which it''s pointing. When
    we find the target node, we can change the next node so that it points to the
    newly created node, and then we can change node following the newly created node
    so that it points to the next node following the target node. Here is the code
    used to implement this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Deleting the first node
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Deleting a node simply means taking out the node and rearranging the previous
    and subsequent node links. If we just remove a node and connect the previous node''s
    next link with the node following the deleted node, we are done with the delete
    operation. Just have a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00026.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'When we delete the first node, we just have to make the second node our head
    or first node. We can achieve that very easily by using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Now, we have to consider one special case, namely decreasing the total node
    count by one.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting the last node
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Deleting the last node will require us to assign the second from last node''s
    next link to `NULL` . We will iterate until the last node and track the previous
    node as we go. Once we hit the last node, the previous node property of the next
    will be set to `NULL` , as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: At first, we check whether the list is empty or not. After that, we check whether
    the list has more than one node. Based on the answer, we iterate to the the last
    node and tracking the previous node. Then, we assign the previous node's next
    link as `NULL` , just to omit the very last node from the list.
  prefs: []
  type: TYPE_NORMAL
- en: Searching for and deleting a node
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can delete any node from our list using a search and delete operation. First,
    we search for the node from the list and then remove the node by removing references
    from the node. Here is the code to achieve this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Reversing a list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are many approaches to reversing a linked list. We will work on a simple
    approach to reverse the list, which is known as in place reverse. We iterate through
    the nodes and change the next node to the previous, previous to the current, and
    the current to the next. A pseudo algorithm for the logic will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If we implement our reverse function based on this pseudocode, it will look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Getting the Nth position element
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As lists are different from arrays, it is not easier to get elements from their
    positions directly. In order to get an element in the Nth position, we have to
    iterate to that position and get the element. Here is the code sample for this
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We have now written all the required operations for our `LinkedList` class.
    Now, let''s run the program with different operations. If we run the following
    program, we will mostly cover all the operations we have written:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have a complete implementation of a linked list using PHP 7\. One thing
    we have understood so far is that unlike the implementation of arrays, we have
    to do lots of operations manually by writing codes. We also have to remember one
    thing: This is not the only way we can implement a linked list. Many prefer to
    track both the first and last nodes of the list for a better insert operation.
    Now, we will look at the complexity of linked list operations in average and worst-case
    scenarios.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding complexity for linked lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here is the best, worst, and average-case complexity for linked list operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operation** | **Time Complexity: Worst Case** | **Time Complexity: Average
    Case** |'
  prefs: []
  type: TYPE_TB
- en: '| Insert at beginning or end | `O(1)` | `O(1)` |'
  prefs: []
  type: TYPE_TB
- en: '| Delete at beginning or end | `O(1)` | `O(1)` |'
  prefs: []
  type: TYPE_TB
- en: '| Search | `O(n)` | `O(n)` |'
  prefs: []
  type: TYPE_TB
- en: '| Access | `O(n)` | `O(n)` |'
  prefs: []
  type: TYPE_TB
- en: We can achieve the `O(1)` insert complexity at the end of the linked list by
    keeping a track of the last node, as we did for the first node in our examples.
    This will help us jump directly to the last node of the linked list without any
    iteration.
  prefs: []
  type: TYPE_NORMAL
- en: Making the linked list iterable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have seen that we can traverse each node of the linked list using
    a `while` loop inside the methods. What if we need to iterate from outside using
    just the linked list object? It is very much possible to achieve this. PHP has
    a very intuitive iterator interface that allows any external iterators to iterate
    through an object internally. The `Iterator` interface provides the following
    methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Current** : Return the current element'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Next** : Move forward to the next element'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Key** : Return the key of the current element'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rewind** : Rewind the `Iterator` to the first element'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Valid** : Checks whether the current position is valid'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will now implement these methods in our `LinkedList` class to make our object
    iterate through the nodes from the object directly. In order to track the current
    node and the current position within the list during iteration, we will require
    two new properties for our `LinkedList` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The `$_currentNode` property will track the current node during the iteration,
    and `$_currentPosition` will track the current position during the iteration.
    We also need to make sure that our class `LinkedList` class is also implementing
    the `Iterator` interface. It will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s implement those five new methods to make our linked list object
    iterable. These five methods are very straightforward and simple to implement.
    Here is the code for that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have a list that is iterable. This means that now we can iterate through
    our linked list object using the `foreach` loop or any other iteration process
    we wish to follow. So, now, if we write the following code, we will see all the
    book titles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Another approach can be using the `rewind` , `valid` , `next` , and `current`
    methods from the iterable interface. It will have the same output as the preceding
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Building circular linked list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Building a circular linked list is not at as hard as it sounds from the name.
    So far, we have seen that adding a new node at the end is pretty simple; we set
    the next reference of the last node to `NULL` . In a circular linked list, the
    last node''s next reference will actually point to the first node, thereby creating
    a circular list. Let''s write a simple circular linked list where the nodes will
    be inserted at the end of the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'If we look closely look at the preceding code, it looks exactly like our singly
    linked list implementation. The only difference is that we do not check the end
    of the list, rather than making sure the current node is not the same as the first
    node. Also, in the following line, we assign the next reference of the newly created
    node to the first node of the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'As we are implementing this, the new nodes are added to the back of the list.
    All we need to do is set the new node''s next reference to our first node in the
    list. By doing so, we have actually created a circular linked list. We have to
    make sure that we do not run- in an infinite loop. That is why we are comparing
    `$currentNode->next` to `$this->_firstNode` . The same principle will apply when
    we are displaying all elements in the circular linked list. We need to ensure
    that we do not fall in an infinite loop while displaying the titles. Here is the
    code that will display all titles from a circular linked list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: So far, we have built a singly linked list and implemented a circular linked
    list. Now, we will implement a doubly linked list with PHP.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a doubly linked list in PHP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We already know from the definition of a doubly linked list that a doubly linked
    list node will have two links: one to point to the next node and another to point
    to the previous node. Also, when we add a new node or delete a new node, we need
    to set both the next and previous references for each affected nodes. We saw a
    different approach in the singly linked list implementation where we did not track
    the last node, and as a result, we had to use an iterator to reach the last node
    each time. This time, we will track the last node, along with our insert and delete
    operations, to make sure our insert, and delete, and end operations have `O(1)`
    complexity.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how the new node class will look with two link pointers followed by
    our barebones structure of a doubly linked list class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will explore the different operations of a doubly linked
    list so that we understand the basic difference between a singly linked list and
    a doubly linked list.
  prefs: []
  type: TYPE_NORMAL
- en: Doubly linked list operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will explore the following operations in our doubly linked list implementation.
    Though they sound similar to those used in singly linked lists, they have a major
    difference in their implementations:'
  prefs: []
  type: TYPE_NORMAL
- en: Inserting at the first node
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inserting at the last node
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inserting before a specific node
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inserting after a specific node
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deleting the first node
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deleting the last node
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Searching for and deleting one node
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying the list forward
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying the list backward
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inserting at first the node
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we add a node at the front or head, we have to check whether the list
    is empty or not. If the list is empty, both the first and last node will point
    to the newly created node. However, if the list already has a head, then we have
    to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create the new node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make the new node as the first node or head.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assign the previous head or first node as the next, to follow the newly created
    first node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assign the previous first node's previous link to the new first node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here is the code for that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Inserting at the last node
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since we are now tracking the last node, it will be easier to insert a new
    node at the end. First, we need to check that the list is not empty. If it is
    empty, then the new node becomes both the first and last node. However, if the
    list already has a last node, then we have to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create the new node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make the new node the last node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assign the previous last node as the previous link of the current last node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assign the previous last node's next link to the new last node's previous link.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here is the code for that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Inserting before a specific node
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Inserting before a specific node requires us to find the node first, and based
    on its position, we need to change the next and previous nodes for the new node,
    the target node, and the node before the target node, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Inserting after a specific node
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Inserting after a specific node is similar to the method we just discussed.
    Here, we need to change the next and previous nodes for the new node, the target
    node, and the node following the target node. Here is the code for that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Deleting the first node
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we remove the first node from a doubly linked list, we just need to make
    the second node the first node. Set the new first node''s previous node to `NULL`
    and reduce the total node count, just like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Deleting the last node
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Deleting the last node requires us to set a second to last node as the new
    last node. Also, the newly created last node should not have any next reference.
    The code sample is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Searching for and deleting one node
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we are deleting a node from the middle of the list, we have to readjust
    the previous and the following node of the item we are looking for. First, we
    will find the intended node. Get the previous node of the target node, along with
    the next node. Then, assign the node following the previous node to point to the
    next node after the target node, and the same applies for the previous node in
    a reverse manner. Here is the code for that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Displaying the list forward
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Doubly linked lists gives us the opportunity to display the list in both directions.
    So far, we have seen that we can display the list in a unidirectional way while
    working in a singly linked list. Now, we will see the list from both directions.
    Here is the code used to display the list forward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Displaying the list backward
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To display the list backward, we have to start from the last node and continue
    to move backward using the previous link until we reach the end of the list. This
    gives us a unique way of moving in any direction we need during operations. Here
    is the code for that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Complexity for doubly linked lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here is the best, worst, and average-case complexity for doubly linked list
    operations. It is similar to that of singly linked list operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operation** | **Time Complexity: Worst Case** | **Time Complexity: Average
    Case** |'
  prefs: []
  type: TYPE_TB
- en: '| Insert at beginning or end | `O(1)` | `O(1)` |'
  prefs: []
  type: TYPE_TB
- en: '| Delete at beginning or end | `O(1)` | `O(1)` |'
  prefs: []
  type: TYPE_TB
- en: '| Search | `O(n)` | `O(n)` |'
  prefs: []
  type: TYPE_TB
- en: '| Access | `O(n)` | `O(n)` |'
  prefs: []
  type: TYPE_TB
- en: Using PHP SplDoublyLinkedList
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The PHP **Standard PHP Library** (**SPL** ) has an implementation of a doubly
    linked list, which is known as `SplDoublyLinkedList` . If we are using the built-in
    class, we do not need to implement the doubly linked list ourselves. The doubly
    linked list implementation actually works as a stack and queue as well. The PHP
    implementation of the doubly linked list has lots of additional functionalities.
    Here are some of the common features of `SplDoublyLinkedList` :'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `Add` | Adds a new node in a specified index |'
  prefs: []
  type: TYPE_TB
- en: '| `Bottom` | Peeks a node from beginning of the list |'
  prefs: []
  type: TYPE_TB
- en: '| `Count` | Returns the size of the list |'
  prefs: []
  type: TYPE_TB
- en: '| `Current` | Returns the current node |'
  prefs: []
  type: TYPE_TB
- en: '| `getIteratorMode` | Returns the mode of iteration |'
  prefs: []
  type: TYPE_TB
- en: '| `setIteratorMode` | Sets the mode of iteration. For example, LIFO, FIFO,
    and so on |'
  prefs: []
  type: TYPE_TB
- en: '| `Key` | Returns the current node index |'
  prefs: []
  type: TYPE_TB
- en: '| `next` | Moves to the next node |'
  prefs: []
  type: TYPE_TB
- en: '| `pop` | Pops a node from the end of the list |'
  prefs: []
  type: TYPE_TB
- en: '| `prev` | Moves to the previous node |'
  prefs: []
  type: TYPE_TB
- en: '| `push` | Adds a new node at the end of the list |'
  prefs: []
  type: TYPE_TB
- en: '| `rewind` | Rewinds the iterator back to the top |'
  prefs: []
  type: TYPE_TB
- en: '| `shift` | Shifts a node from the beginning of the linked list |'
  prefs: []
  type: TYPE_TB
- en: '| `top` | Peeks a node from the end of the list |'
  prefs: []
  type: TYPE_TB
- en: '| `unshift` | Prepends an element in the list |'
  prefs: []
  type: TYPE_TB
- en: '| `valid` | Checks whether there are any more nodes in the list |'
  prefs: []
  type: TYPE_TB
- en: 'Now, let''s write a small program using `SplDoublyLinkedList` for our book
    titles applications:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will have the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The linked list is one of the most popular data structures that are used to
    solve different problems. Whether it's regarding for a stack, queue, priority
    queue, or for implementing complex graph algorithms, the linked list is a very
    handy data structure to solve any problems you might find. In this chapter, we
    explored all possible details regarding the singly linked list, doubly linked
    list, and circular linked list, along with their complexity analysis. In the upcoming
    chapters, we will utilize linked lists to implement different data structures
    and writing algorithms.
  prefs: []
  type: TYPE_NORMAL
