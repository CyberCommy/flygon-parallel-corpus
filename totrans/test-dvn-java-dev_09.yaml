- en: Refactoring Legacy Code – Making It Young Again
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: TDD may not adjust to legacy code straight away. You may have to fiddle a bit
    with the steps to make it work. Understand that your TDD may change in this case,
    because somehow, you are no longer performing the TDD you were used to. This chapter
    will introduce you to the world of legacy code, taking as much as we can from
    TDD.
  prefs: []
  type: TYPE_NORMAL
- en: We'll start afresh, with a legacy application that is currently in production.
    We'll alter it in small ways without introducing defects or regressions, and we'll
    even have time to have an early lunch!
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics are covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Legacy code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dealing with legacy code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: REST communication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependency injection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Tests at different levels: end-to-end, integration, and unit'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Legacy code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start with the definition of legacy code. While there are many authors
    with different definitions, such as lack of trust in your application or your
    tests, code that is no longer supported, and so on. We like the one created by
    Michael Feathers the most:'
  prefs: []
  type: TYPE_NORMAL
- en: '"Legacy code is code without tests. The reason for this definition is that
    it is objective: either there are or there aren''t tests."'
  prefs: []
  type: TYPE_NORMAL
- en: – Michael Feathers
  prefs: []
  type: TYPE_NORMAL
- en: How do we detect legacy code? Although legacy code usually equates to bad code,
    Michael Feathers exposes some smells in his book, *Working Effectively with Legacy*
    *Code*, by Dorling Kindersley (India) Pvt. Ltd. (1993).
  prefs: []
  type: TYPE_NORMAL
- en: '**Code smell**.'
  prefs: []
  type: TYPE_NORMAL
- en: Smells are certain structures in the code that indicate violation of fundamental
    design principles and negatively impact design quality.
  prefs: []
  type: TYPE_NORMAL
- en: Code smells are usually not bugs—they are not technically incorrect and do not
    currently prevent the program from functioning. Instead, they indicate weaknesses
    in design that may be slowing down development or increasing the risk of bugs
    or failures in the future.
  prefs: []
  type: TYPE_NORMAL
- en: 'Source: [http://en.wikipedia.org/wiki/Code_smell](http://en.wikipedia.org/wiki/Code_smell).'
  prefs: []
  type: TYPE_NORMAL
- en: One of the common smells for legacy code is *I can't test this code*. It is
    accessing outside resources, introducing other side effects, using a new operator,
    and so on. In general, good design is easy to test. Let's see some legacy code.
  prefs: []
  type: TYPE_NORMAL
- en: Legacy code example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Software concepts are often easiest to explain through code, and this one is
    no exception. We have seen and worked with the Tic-Tac-Toe application (see [Chapter
    3](80748be2-41bd-4ee8-bdff-ce9260cd1225.xhtml), *Red-Green-Refactor – From Failure
    Through Success until Perfection*). The following code performs position validation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The specification that corresponds with this code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The JaCoCo report indicates that everything is covered (except the last line,
    the method''s closing bracket):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5ab5211c-027a-4b93-ad7c-e7b568e5a1c3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As we believe we have good coverage, we can perform an automatic and safe refactor
    (fragment):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This code should be ready, as the tests are successful and it has very good
    test coverage.
  prefs: []
  type: TYPE_NORMAL
- en: Maybe you have already realized as much, but there is a catch. The message in
    the `RuntimeException` block is not checked for correctness; even the code coverage
    shows it as covering all the branches in that line.
  prefs: []
  type: TYPE_NORMAL
- en: What is coverage all about?
  prefs: []
  type: TYPE_NORMAL
- en: 'Coverage is a measure used to describe the degree to which the source code
    of a program is tested by a particular test suite. Source: [http://en.wikipedia.org/wiki/Code_coverage](http://en.wikipedia.org/wiki/Code_coverage).'
  prefs: []
  type: TYPE_NORMAL
- en: Let's imagine a single end-to-end test that covers an easy part of the code.
    This test will get you a high coverage percentage, but not much security, as there
    are many other parts that are still not covered.
  prefs: []
  type: TYPE_NORMAL
- en: We have already introduced legacy code in our codebase—the exception messages.
    There might be nothing wrong with this as long as this is not an expected behavior—no
    one should depend on exception messages, not programmers to debug their programs,
    or logs, or even users. Those parts of the program that are not covered by tests
    are likely to suffer regressions in the near future. This might be fine if you
    accept the risk. Maybe the exception type and the line number are enough.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have decided to remove the exception message, as it is not tested:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Other ways to recognize legacy code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You may be familiar with some of the following common signs of legacy applications:'
  prefs: []
  type: TYPE_NORMAL
- en: A patch on top of a patch, just like a living Frankenstein application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Known bugs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changes are expensive
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fragile
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Difficult to understand
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Old, outdated, static or, often, non-existent documentation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shotgun surgery
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Broken windows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Regarding the team that maintains it, these are some of the effects it produces
    on the members of the team:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Resignation: The people in charge of the software see a huge task in front'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: of them
  prefs: []
  type: TYPE_NORMAL
- en: 'No one cares anymore: If you already have broken windows in your system, it
    is easier to introduce new ones'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As legacy code is usually more difficult than other kinds of software, you would
    want your best people to work on it. However, we are often in a hurry imposed
    by deadlines, with the idea of programming the required functionalities as fast
    as possible and ignoring the quality of the solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, to avoid wasting our talented developers in such a bad way, we expect
    a non-legacy application to fulfill just the opposite. It should be:'
  prefs: []
  type: TYPE_NORMAL
- en: Easy to change
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generalizable, configurable, and expansible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easy to deploy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Robust
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No known defects or limitations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easy to teach to others/learn from others
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extensive suite of tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Self-validating
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Able to use keyhole surgery
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we have outlined some of the properties of legacy and non-legacy code, it
    should be easy to replace some qualities with others. Right? Stop shotgun surgery
    and use keyhole surgery, a few more details and you are done. Isn't that right?
  prefs: []
  type: TYPE_NORMAL
- en: It is not as easy as it sounds. Luckily, there are some tricks and rules that,
    when applied, improve our code and the application comes closer to a non-legacy
    one.
  prefs: []
  type: TYPE_NORMAL
- en: A lack of dependency injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is one of the smells often detected in a legacy codebase. As there is no
    need to test the classes in isolation, the collaborators are instantiated where
    they are needed, putting the responsibility for creating collaborators and using
    them in the same class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example, using the `new` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the current state, the `BirthdayGreeting` service is not unit-testable. It
    has the dependency to `EmailMessageSender` hardcoded in the constructor. It is
    not possible to replace this dependency without modifying the codebase (except
    for injecting objects using reflection or replacing objects on the `new` operator).
  prefs: []
  type: TYPE_NORMAL
- en: Modifying the codebase is always a source of possible regressions, so it should
    be done with caution. Refactoring requires tests, except when it is not possible.
  prefs: []
  type: TYPE_NORMAL
- en: The Legacy Code Dilemma.
  prefs: []
  type: TYPE_NORMAL
- en: When we change code, we should have tests in place. To put tests in place, we
    often have to change code.
  prefs: []
  type: TYPE_NORMAL
- en: The legacy code change algorithm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you have to make a change in a legacy codebase, here is an algorithm you
    can use:'
  prefs: []
  type: TYPE_NORMAL
- en: Identify change points
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Find test points
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Break dependencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make changes and refactor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying the legacy code change algorithm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To apply this algorithm, we usually start with a suite of tests and always keep
    it green while refactoring. This is different from the normal cycle of TDD because
    refactoring should not introduce any new features (that is, it should not write
    any new specifications).
  prefs: []
  type: TYPE_NORMAL
- en: 'To better explain the algorithm, imagine that we received the following change
    request: To greet my employees in a more informal way, I want to send them a tweet
    instead of an email.'
  prefs: []
  type: TYPE_NORMAL
- en: Identifying change points
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The system is only able to send emails right now, so a change is necessary.
    Where? A quick investigation shows that the strategy for sending the greeting
    is decided in the constructor for the `BirthdayGreetingService` class following
    the strategy pattern ([https://en.wikipedia.org/?title=Strategy_pattern](https://en.wikipedia.org/?title=Strategy_pattern)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Finding test points
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the `BirthdayGreetingService` class does not have a collaborator injected
    that could be used to attach additional responsibilities to the object, the only
    option is to go outside this service class to test it. An option would be to change
    the `EmailMessageSender` class for a mock or fake implementation, but this would
    risk the implementation in that class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another option is to create an end-to-end test for this functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This code has been used with permission from [https://github.com/GMaur/legacyutils](https://github.com/GMaur/legacyutils).
    This library helps you perform the technique of capturing the system out (`System.out`).
  prefs: []
  type: TYPE_NORMAL
- en: The name of the file does not end in Specification (or `Spec`), such as `TicTacToeSpec`,
    because this is not a specification. It is a test, to ensure the functionality
    remains constant. The file has been named `EndToEndTest` because we try to cover
    as much functionality as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Breaking dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After having created a test that guarantees the expected behavior does not
    change, we will break the hardcoded dependency between `BirthdayGreetingService`
    and `EmailMessageSender`. For this, we will use a technique called **extract**
    and **override call**, which is first explained in Michael Feathers'' book:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the tests again and verify that the lonely test we previously created
    still is green. Additionally, we need to make this method `protected` or more
    open to be able to override it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Now that the method can be overridden, we create a fake service to replace the
    original instance of the service. Introducing fakes in code is a pattern that
    consists of creating an object that could replace an existing one, with the particularity
    that we can control its behavior. This way, we can inject some customized fakes
    to achieve what we need. More information is available at [http://xunitpatterns.com/](http://xunitpatterns.com/).
  prefs: []
  type: TYPE_NORMAL
- en: 'In this particular case, we should create a fake service that extends the original
    service. The next step is to override complicated methods in order to bypass irrelevant
    parts of code for testing purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can use the fake, instead of the `BirthdayGreetingService` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The test is still green.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now apply another dependency-breaking technique, parameterize constructor,
    explained in Feathers paper at [https://archive.org/details/WorkingEffectivelyWithLegacyCode](https://archive.org/details/WorkingEffectivelyWithLegacyCode).
    The production code may look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Test code that corresponds to this implementation may be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We can also remove `FakeBirthday`, as it is no longer used.
  prefs: []
  type: TYPE_NORMAL
- en: Writing tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While keeping the old end-to-end test, create an interaction to verify the
    integration of `BirthdayGreetingService` and `MessageSender`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: At this point, a new `TweetMessageSender` can be written, completing the last
    step of the algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: The kata exercise
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The only way a programmer will be able to improve is through practice. Creating
    programs of different types and using different technologies usually provide a
    programmer with new insights into software construction. Based on this idea, a
    kata is an exercise that defines some requirements or fixed features to be implemented
    in order to achieve some goals.
  prefs: []
  type: TYPE_NORMAL
- en: The programmer is asked to implement a possible solution and then compare it
    with others trying to find the best. The key value of this exercise is not getting
    the fastest implementation but discussing decisions taken while designing the
    solution. In most cases, all programs created in kata are dropped at the end.
  prefs: []
  type: TYPE_NORMAL
- en: The kata exercise in this chapter is about a legacy system. This is a sufficiently
    simple program to be processed in this chapter but also complex enough to pose
    some difficulties.
  prefs: []
  type: TYPE_NORMAL
- en: Legacy kata
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You have been given a task to adopt a system that is already in production,
    a working piece of software for a book library: the Alexandria project.'
  prefs: []
  type: TYPE_NORMAL
- en: The project currently lacks documentation, and the old maintainer is no longer
    available for discussion. So, should you accept this mission, it is going to be
    entirely your responsibility, as there is no one else to rely on.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have been able to recover these specification snippets from the time the
    original project was written:'
  prefs: []
  type: TYPE_NORMAL
- en: The Alexandria software should be able to store books and lend them to users,
    who have the power to return them. The user can also query the system for books,
    by author, book title, status, and ID.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is no time frame for returning the books.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The books can also be censored as this is considered important for business
    reasons.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The software should not accept new users.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The user should be told, at any moment, the server's time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical comments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Alexandria is a backend project written in Java, which communicates information
    to the frontend using a REST API. For the purpose of this kata exercise,  persistence
    has been implemented as an in-memory object, using the fake test double explained
    at[ http://xunitpatterns.com/Fake%20Object.html](http://xunitpatterns.com/Fake%20Object.html).
  prefs: []
  type: TYPE_NORMAL
- en: The code is available at [https://bitbucket.org/vfarcic/tdd-java-alexandria](https://bitbucket.org/vfarcic/tdd-java-alexandria/).
  prefs: []
  type: TYPE_NORMAL
- en: Adding a new feature
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until the point of adding a new feature, the legacy code might not be a disturbance
    to the programmer's productivity. The codebase is in a state that is worse than
    desired, but the production systems work without any inconvenience.
  prefs: []
  type: TYPE_NORMAL
- en: Now is the time when the problems start to appear. The **product owner** (**PO**)
    wants to add a new feature.
  prefs: []
  type: TYPE_NORMAL
- en: For example, as a library manager, I want to know all the history for a given
    book so that I can measure which books are more in demand than others.
  prefs: []
  type: TYPE_NORMAL
- en: Black-box or spike testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the old maintainer of the Alexandria project is no longer available for questions
    and there is no documentation, black-box testing is more difficult. Thus, we decide
    to get to know the software better through investigation and then doing some spikes
    that will leak internal knowledge to us about the system.
  prefs: []
  type: TYPE_NORMAL
- en: We will later use this knowledge to implement the new feature.
  prefs: []
  type: TYPE_NORMAL
- en: 'Black-box testing is a method of software testing that examines the functionality
    of an application without peering into its internal structures or workings. This
    type of test can be applied to virtually every level of software testing: unit,
    integration, system, and acceptance. It typically most if not all higher-level
    testing, but can dominate unit testing as well.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Source: [http://en.wikipedia.org/wiki/Black-box_testing](http://en.wikipedia.org/wiki/Black-box_testing).'
  prefs: []
  type: TYPE_NORMAL
- en: Preliminary investigation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we know the required feature, we will start looking at the Alexandria
    project:'
  prefs: []
  type: TYPE_NORMAL
- en: 15 files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gradle-based (`build.gradle`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 0 tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Firstly, we want to confirm that this project has never been tested, and the
    lack of a test folder reveals so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'These are the folder contents for the Java part:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the rest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This seems to be a web project (indicated by the `web.xml` file) using Spring
    (indicated by the `applicationContext.xml`). The dependencies in the `build.gradle` show
    the following (fragment):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Having Spring is already a good sign, as it can help with the dependency injection,
    but a quick look showed that the context is not really being used. Maybe something
    that was used in the past?
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `web.xml` file, we can find this fragment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In this file, we discover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The context in `applicationContext.xml` will be loaded
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is an application file (`com.packtpublishing.tddjava.alexandria.MyApplication`)
    that will be executed inside a servlet
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `MyApplication` file is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This configures the necessary classes for executing the `BooksEndpoint` endpoint
    (fragment):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We can start by writing down the element that will be used during refactoring;
    we write the code for the **dependency injection** in `BooksEndpoint`.
  prefs: []
  type: TYPE_NORMAL
- en: How to find candidates for refactoring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are different paradigms of programming (for example, functional, imperative,
    and object-oriented) and styles (for example, compact, verbose, minimalistic,
    and too clever). Therefore, the candidates for refactoring are different from
    one person to the other.
  prefs: []
  type: TYPE_NORMAL
- en: There is another way, as opposed to subjectively, of finding candidates for
    refactoring—objectively. There are many papers investigating how to find candidates
    for refactoring objectively. This is just an introduction and it is left to the
    reader to learn more about these techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the new feature
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After getting to know the code more, it seems that the most important functional
    change is to replace the current `status` (fragment):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'And replace it with a collection of them (fragment):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This might seem to work (after changing all access to the field to the array,
    for example), but this also prompts a functional requirement.
  prefs: []
  type: TYPE_NORMAL
- en: The Alexandria software should be able to store books and lend them to users
    who have the power to return them. The user can also query the system for books,
    by author, book title, status, and ID.
  prefs: []
  type: TYPE_NORMAL
- en: The PO confirms that searching books via `status` has now changed now, it also
    allows  searching for any previous `status`.
  prefs: []
  type: TYPE_NORMAL
- en: This change is getting bigger and bigger. Whenever we feel that the time for
    removing this legacy code has come, we start applying the legacy code algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have also detected a primitive obsession and feature envy smell: storing
    the `status` as an integer (primitive obsession) and then actuating on another
    object''s state (feature envy). We will add this to the following to-do list:'
  prefs: []
  type: TYPE_NORMAL
- en: Dependency injection in `BooksEndpoint` for books
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Change `status` for `statuses`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remove the primitive obsession with `status` (optional)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying the legacy code algorithm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this case, the whole middle-end works as a standalone, using in-memory persistence.
    The same algorithm could be used if the persistence was saved into a database,
    but we would require some extra code to clean and populate the database between
    test runs.
  prefs: []
  type: TYPE_NORMAL
- en: We'll use DbUnit. More information can be found at [http://dbunit.sourceforge.net/](http://dbunit.sourceforge.net/).
  prefs: []
  type: TYPE_NORMAL
- en: Writing end-to-end test cases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first step we've decided to take to ensure that behavior is maintained during
    refactoring is to write end-to-end tests. In other applications that include frontends,
    this could be using a higher-level tool, such as Selenium/Selenide.
  prefs: []
  type: TYPE_NORMAL
- en: In our case, as the frontend is not subject to refactoring, the tool can be
    lower-level. We have chosen to write HTTP requests for the purpose of end-to-end
    tests.
  prefs: []
  type: TYPE_NORMAL
- en: These requests should be automatic and testable, and should follow all existing
    rules for automatic tests or specifications. As we were discovering the real application
    behavior while writing these tests, we have decided to write a spike in a tool
    called Postman.
  prefs: []
  type: TYPE_NORMAL
- en: 'The product website is here: [https://www.getpostman.com/](https://www.getpostman.com/).
    This is also possible with a tool called curl ([http://curl.haxx.se/](http://curl.haxx.se/)).'
  prefs: []
  type: TYPE_NORMAL
- en: What is curl?
  prefs: []
  type: TYPE_NORMAL
- en: curl is a command-line tool and library for transferring data with URL syntax,
    supporting `[...] HTTP`, `HTTPS, [...]`, `HTTP POST`, `HTTP PUT`, and `[...]`.
  prefs: []
  type: TYPE_NORMAL
- en: What's curl used for?
  prefs: []
  type: TYPE_NORMAL
- en: curl is used in command lines or scripts to transfer data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Source: [http://curl.haxx.se/](http://curl.haxx.se/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we decide to execute the legacy software locally with the following
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This fires up a local jetty server that processes requests. The big benefit
    is that deployment is done automatically and there is no need to package everything
    and manually deploy to an application server (for example, JBoss AS, GlassFish,
    Geronimo, and TomEE). This can greatly speed up the process of making changes
    and seeing the effects, therefore decreasing the feedback lead time. Later on,
    we will start the server programmatically from Java code.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start looking for functionalities. As we discovered earlier that the `BooksEndpoint`
    class contains the webservice endpoint definitions, this is a good place to start
    looking for functionalities. They are listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a new book
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: List all the books
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Search for books by ID, by author, by title, and by status
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Prepare this book to be rented
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rent this book
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Censor this book
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Uncensor the book
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We launch the server manually and start writing requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d210ad49-9c7a-48e2-b98e-a6fb7c9f6819.png)'
  prefs: []
  type: TYPE_IMG
- en: 'These tests seem good enough for a spike. One thing that we have realized is
    that each response contains a timestamp, so this makes our automation more difficult:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a2cb8545-b5bd-4d7a-adb3-bcd27600297a.png)'
  prefs: []
  type: TYPE_IMG
- en: For the tests to have more value, they should be automated and exhaustive. For
    the moment, they are not, so we consider them spikes. They will be automated in
    the future.
  prefs: []
  type: TYPE_NORMAL
- en: Each and every single test that we perform is not automated. In this case, the
    tests from the Postman interface are much faster to write than the automated ones.
    Also, the experience is far more representative of what production use would be
    like. The test client (thankfully, in this case) could introduce some problems
    with the production one, and therefore not return trusted results.
  prefs: []
  type: TYPE_NORMAL
- en: In this particular case, we have found that the Postman tests are a better investment
    because, even after writing them, we will throw them away. They give very rapid
    feedback on the API and results. We also use this tool for prototyping the REST
    APIs, as its tools are both effective and useful.
  prefs: []
  type: TYPE_NORMAL
- en: 'The general idea here is this: depending on whether you want to save those
    tests for the future or not, use one tool or another. This also depends on how
    often you want to execute them, and in which environment.'
  prefs: []
  type: TYPE_NORMAL
- en: 'After writing down all the requests, these are the states that we have found
    in the application, represented by a state diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3ea6c926-39d3-41cc-b9e4-8b78c3c4263b.png)'
  prefs: []
  type: TYPE_IMG
- en: After these tests are ready and we start to understand the application, it is
    time to automate the tests. After all, if they are not automated, we don't really
    feel confident enough for refactoring.
  prefs: []
  type: TYPE_NORMAL
- en: Automating the test cases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We start the server programmatically. For this, we have decided to use a Grizzly ([https://javaee.github.io/grizzly/](https://javaee.github.io/grizzly/)),
    which allows us to start the server using the configuration from Jersey''s `ResourceConfig`
    (FQCN: `org.glassfish.jersey.server.ResourceConfig`), as shown in the test `BooksEndpointTest`
    (fragment).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The code can be found at [https://bitbucket.org/vfarcic/tdd-java-alexandria](https://bitbucket.org/vfarcic/tdd-java-alexandria):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This prepares a local server at the address `http://localhost:8080/alexandria`.
    It will only be available for a short period of time (while the tests run), so,
    if you need to manually access the server, whenever you want to pause the execution,
    insert a call to the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: When you want to stop the server, stop the execution or hit *Enter* in the allocated
    console.
  prefs: []
  type: TYPE_NORMAL
- en: Now we can start the server programmatically, pause it (with the preceding method),
    and execute the spike again. The results are the same, so the refactor is successful.
  prefs: []
  type: TYPE_NORMAL
- en: We add the first automated test to the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code can be found at [https://bitbucket.org/vfarcic/tdd-java-alexandria](https://bitbucket.org/vfarcic/tdd-java-alexandria):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: For testing purposes, we're using a library called `RestAssured` ([https://github.com/rest-assured/rest-assured](https://github.com/rest-assured/rest-assured))
    that allows for easier testing of REST and JSON.
  prefs: []
  type: TYPE_NORMAL
- en: 'To complete the automated test suite, we create these tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '`add_one_book()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`add_a_second_book()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`get_book_details_by_id()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`get_several_books_in_a_row()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`censor_a_book()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cannot_retrieve_a_censored_book()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code can be found at[ https://bitbucket.org/vfarcic/tdd-java-alexandria/](https://bitbucket.org/vfarcic/tdd-java-alexandria/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a suite that ensures that no regression is introduced, we
    take a look at the following to-do list:'
  prefs: []
  type: TYPE_NORMAL
- en: Dependency injection in `BooksEndpoint` for books
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change `status` for `statuses`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remove the primitive obsession with `status` (optional)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will tackle dependency injection first.
  prefs: []
  type: TYPE_NORMAL
- en: Injecting the BookRepository dependency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code for the `BookRepository` dependency is in `BooksEndpoint` (fragment):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Extract and override call
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will apply the already introduced refactoring technique extract and override
    call. For this, we create a failing specification, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'To pass this red specification, also known as a failing specificiation, we
    will first extract the dependency creation to a `protected` method in the `BookRepository`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We copy the `MyApplication` launcher to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This allows us to inject any `BooksEndpoint`. In this case, in the test `BooksEndpointInteractionTest`,
    we will override the dependency getter with a mock. In this way, we can check
    that the necessary calls are being made (fragment from `BooksEndpointInteractionTest`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Run the tests; everything is green. Even though the specifications are successful,
    we have introduced a piece of design only for test purposes, and the production
    code is not executing this new launcher, `TestApplication`, but is still executing
    the old `MyApplication`. To solve this, we have to unify both launchers into one.
    This can be solved with the refactor parametrize constructor, also explained in
    Roy Osherove's book, *The Art of Unit Testing* ([http://artofunittesting.com](http://artofunittesting.com)).
  prefs: []
  type: TYPE_NORMAL
- en: Parameterizing a constructor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can unify the launchers by accepting a `BooksEndpoint` dependency. If we
    don''t specify it, it will register the dependency with the real instance of `BooksRepository`.
    Otherwise, it will register the received one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we have opted for **constructor chaining** to avoid repetition
    in the constructors.
  prefs: []
  type: TYPE_NORMAL
- en: After doing this refactor, the `BooksEndpointInteractionTest` class is as follows
  prefs: []
  type: TYPE_NORMAL
- en: 'in its final state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The first test passed, so we can mark the dependency injection task as done.
  prefs: []
  type: TYPE_NORMAL
- en: 'Tasks performed:'
  prefs: []
  type: TYPE_NORMAL
- en: Dependency injection in `BooksEndpoint` for books
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The to-do list:'
  prefs: []
  type: TYPE_NORMAL
- en: Change `status` for `statuses`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remove the primitive obsession with `status` (optional)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a new feature
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once we have the necessary test environment in place, we can add the new feature.
  prefs: []
  type: TYPE_NORMAL
- en: As a library manager, I want to know all the history for a given book so that
    I can measure which books are more in demand than others.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start with a red specification:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Run all the tests and see the last one fail.
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement the search on all states (fragment):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'In this fragment, we have omitted the irrelevant parts—things that were not
    modified, or more modifier methods, such as `rent`, that have changed the implementation
    in the same fashion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The outside methods, especially the serialization to JSON, are not affected,
    as the `getStatus` method still returns an `int` value.
  prefs: []
  type: TYPE_NORMAL
- en: We run all the tests and everything is green.
  prefs: []
  type: TYPE_NORMAL
- en: 'Tasks performed:'
  prefs: []
  type: TYPE_NORMAL
- en: Dependency injection in `BooksEndpoint` for books
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Change `status` for `statuses`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The to-do list:'
  prefs: []
  type: TYPE_NORMAL
- en: Remove the primitive obsession with `status` (optional)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removing the primitive obsession with status as int
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have decided to also tackle the optional item in our to-do list.
  prefs: []
  type: TYPE_NORMAL
- en: 'The to-do list:'
  prefs: []
  type: TYPE_NORMAL
- en: Dependency injection in `BooksEndpoint` for books
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Change `status` for `statuses`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remove the primitive obsession with `status` (optional)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The smell: Primitive obsession involves using primitive data types to represent
    domain ideas. For example, we use a string to represent a message, an integer
    to represent an amount of money, or a struct/dictionary/hash to represent a specific
    object.'
  prefs: []
  type: TYPE_NORMAL
- en: The source is [http://c2.com/cgi/wiki?PrimitiveObsession](http://c2.com/cgi/wiki?PrimitiveObsession).
  prefs: []
  type: TYPE_NORMAL
- en: As this is a refactor step (that is, we are not introducing any new behavior
    into the system), we don't need any new specification. We will proceed and try
    to always stay green, or leave it for as little time as possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have converted  `States` from a Java class with constants:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'And turned it into an `enum`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Adapt the tests as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Adapt the production code. The code snippet is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Also the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, the serialization has been done using the annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: This converts the result of the method into the field named `status`.
  prefs: []
  type: TYPE_NORMAL
- en: Also, the `status` field, now `ArrayList<States>`, is marked with `@XmlTransient`
    so it is not serialized to JSON.
  prefs: []
  type: TYPE_NORMAL
- en: We execute all the tests and they are green, so we can now cross off the optional
    element in our to-do list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Tasks performed:'
  prefs: []
  type: TYPE_NORMAL
- en: Dependency injection in `BooksEndpoint` for books
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Change `status` for `statuses`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remove the primitive obsession with `status` (optional)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you already know, inheriting a legacy codebase may be a daunting task.
  prefs: []
  type: TYPE_NORMAL
- en: 'We stated that legacy code is code without tests, so the first step in dealing
    with it is to create tests to help you preserve the same functionality during
    the process. Unfortunately, creating tests is not always as easy as it sounds.
    Many times, legacy code is tightly coupled and presents other symptoms that show
    a poor design or at least a lack of interest in the code''s quality in the past.
    Worry not: you can perform some of the tedious tasks step by step, as shown in
    [http://martinfowler.com/bliki/ParallelChange.html](http://martinfowler.com/bliki/ParallelChange.html).
    Moreover, it is also well known that software development is a learning process.
    Working code is a side effect. Therefore, the most important part is to learn
    more about the codebase, to be able to modify it with security. Please visit [http://www.slideshare.net/ziobrando/model-storming](http://www.slideshare.net/ziobrando/model-storming)
    for more information.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we encourage you to read Michael Feathers book called *Working Effectively
    with Legacy Code*. It has plenty of techniques for this kind of codebase, and
    as a result is very useful for understanding the whole process.
  prefs: []
  type: TYPE_NORMAL
