- en: Chapter 2. Creating Interactive Scripts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 1](part0014_split_000.html#DB7S1-747571d9b4814e1dbffcdef2eb0dec8d
    "Chapter 1. What and Why of Scripting with Bash"), *What and Why of Scripting
    with Bash*, of this book we learned how to create a script and use some of its
    basics elements. These include optional parameters that we can pass through to
    the script when it is executed. In this chapter, we will extend this by using
    the read shell built-in command to allow for interactive scripts. Interactive
    scripts are scripts that prompt for information during the script execution. In
    doing so, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Using `echo` with options
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic script using `read`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding comments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enhancing `read` scripts with prompts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Limiting the number of entered characters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Control the visibility of the entered text
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simple scripts to enforce our learning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using echo with options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, in this book we have been able to see that the `echo` command is very
    useful and is going to be in many of our scripts, if not all. We have also seen
    that this is both a built-in command as well as a command file. When running the
    `echo` command, the built-in command will be used unless we state the full path
    to the file. We can test this with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: To gain help on the built-in command, we can use `man bash` and search for `echo`;
    however, the `echo` command is identical to the internal command so I will recommend
    that you use `man echo` in most cases in order to display command options.
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic use of `echo` that we have seen so far will produce a text output
    and a new line. This is often the desired response so we don''t have to be concerned
    that the next prompt will append to the end of the echoed text. The new line separates
    the script output from the next shell prompt. If we do not supply any text string
    to print, `echo` will print only the new line to `STDOUT`. We can test this with
    the following command directly from the command line. We do not need to run `echo`
    or in fact any other command from a script. To run `echo` from the command line
    will simply enter the command as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will show a clear new line between the command we issued and the
    subsequent prompt. We can see this in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using echo with options](img/00020.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'If we want to suppress the new line, especially useful if we are to prompt
    users, we can do this in the following two ways with the help of `echo`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The result will be to suppress the line feed. In the initial example, the `-n`
    option is used to suppress the line feed. The second example uses the more generic
    `-e` option, which allows escape sequences to be added to the text string. To
    continue on the same line, we use `\c` as the escape sequence.
  prefs: []
  type: TYPE_NORMAL
- en: 'This does not look great as the final part of the script or when it is run
    from the command line, as the command prompt will follow. This is illustrated
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using echo with options](img/00021.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Basic script using read
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When used as a part of a script that prompts for user input, the suppression
    of the line feed is exactly what we want. We will begin by copying the existing
    `hello2.sh` script to `hello3.sh` and build an interactive script. Initially,
    we will use `echo` as the prompt mechanism but as we gradually enhance the script,
    we will generate the prompt directly from the shell built-in `read` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Edit the `$HOME/bin/hello3.sh` script so that it reads as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'As we execute the script, we will be greeted and prompted with our own name.
    This is echoed out using the `$REPLY` variable in the `echo` statement. As we
    have not yet supplied a variable name to the `read` built-in command the default
    `$REPLY` variable is used. The script execution and output is shown in the following
    screenshot. Take some time to practice the script on your own system:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Basic script using read](img/00022.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This little step has taken us a long way and there are many uses of a script
    like this, we have all used installation scripts that prompt for options and directories
    as we run through the install. I do accept that it is still quite trivial but
    as we delve into the chapter, we get closer to some more useful scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Script comments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We should always introduce commenting scripts early in the piece. A script comment
    is prefaced with a `#` symbol. Anything after the `#` symbol is a comment and
    is not evaluated by the script. The shebang, `#!/bin/bash`, is primarily a comment
    and, as such, is not evaluated by the script. The shell running the script reads
    the shebang so it knows which command interpreter to hand the script over to.
    A comment may be at the start of a line or partly into the line. Shell scripting
    does not have the notion of multi-line comments.
  prefs: []
  type: TYPE_NORMAL
- en: If you are not already familiar with comments, then they are added to the script
    to tell all about who wrote the script, when it was written and last updated,
    and what the script does. It is the metadata of the script.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of comments in scripts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: It is a good practice to comment and add comments that explain what the code
    is doing and why. This will help you and your colleagues, who need to edit the
    script at a later date.
  prefs: []
  type: TYPE_NORMAL
- en: Enhancing scripts with read prompts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen how we can use the built in read to populate a variable. So far,
    we have used `echo` to produce the prompt but this can be passed to read itself
    using the `-p` option. The `read` command will surpass the additional linefeed,
    so we reduce both the line count and the complexity to some degree.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can test this at the command line itself. Try typing the following command
    to see `read` in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We use the `read` command with the `-p` option. The argument that follows the
    option is the text that appears in the prompt. Normally, we will make sure that
    there is a trailing space at the end of the text to ensure that we can clearly
    see what we type. The last argument supplied here is the variable we want to populate,
    we simply call it `name`. Variables are case-sensitive too. Even if we did not
    supply the last argument, we can still store the user's response, but this time
    in the `REPLY` variable.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that when we return the value of a variable we use `$` but not when we
    write it. In simple terms when reading a variable we refer to `$VAR` when setting
    a variable we refer to `VAR=value`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following illustration shows the `read` command with syntax using the `-p`
    option:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Enhancing scripts with read prompts](img/00023.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can edit the script so that it appears similar to the following extract
    from `hello3.sh`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `read` prompt cannot evaluate commands within the message string, such as
    we used before.
  prefs: []
  type: TYPE_NORMAL
- en: Limiting the number of entered characters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We do not need functionality in the scripts we have used so far, but we may
    need to ask users to hit any key to continue. At the moment, we have set it up
    in such a way that the variable is not populated until we hit the *Enter* key.
    Users have to hit *Enter* to continue. If we use the `-n` option followed by an
    integer, we can specify the characters to accept before continuing, we will set
    `1` in this case. Take a look at the following code extract:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Now, the script will pause after displaying the name until we press any key;
    literally, we can press any key before continuing, as we accept just `1` key stroke.
    Whereas, earlier we were required to leave the default behavior in place, as we
    could not know how long a entered name would be. We have to wait for the user
    to hit *Enter*.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that we add an additional echo here to ensure that a new line is issued
    before the script ends. This ensures that the shell prompt starts on a new line.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling the visibility of entered text
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Even though we have limited the input to a single character, we do get to see
    the text on the screen. In the same way, if we type the name we get to see the
    entered text before we hit *Enter*. In this case, it is just untidy but if we
    were entering sensitive data, such as a pin or a password, we should hide the
    text. We can use the silent option or `-s` to achieve this. A simple edit in the
    script will set this in place:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when we use a key to continue, it will not be displayed on the screen.
    We can see the behavior of the script in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Controlling the visibility of entered text](img/00024.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Enhancing learning with simple scripts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our scripts are still a little trivial and we have not looked at conditional
    statements, so we can test for correct input, but let's take a look at some simple
    scripts that we can build with some functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Backing-up with scripts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have created some scripts, we may want to back these up in a different
    location. If we create a script to prompt us, we can choose the location and the
    type of files that we want to backup.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following script for your first practice. Create the script and
    name it as `$HOME/backup.sh`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see that the file is commented; though as black and white the readability
    is a little difficult. If you have an electronic copy of the book, you should
    see the colors in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Backing-up with scripts](img/00025.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'As the script runs, you may choose `.sh` for the files to backup and `backup`
    as the directory. The script execution is shown in the following screenshot along
    with a listing of the directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Backing-up with scripts](img/00026.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now you can see if we can start to create meaningful scripts with trivial scripting;
    although I will strongly urge adding error checking the user input if this script
    has to be for something other than personal use. As we progress into the book
    will cover this.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to a server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's look at some practical scripts that we can use to connect to servers.
    First, we will look at ping and in the second script we will look at prompting
    for SSH credentials.
  prefs: []
  type: TYPE_NORMAL
- en: Version 1 – ping
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is something we all can do as no special services are required. This will
    simplify the `ping` command for console users who may not know the details of
    the command. This will ping the server for just three counts rather than the normal
    infinite amount. There is no output if the server is alive but a failed server
    reports `Sever dead`. Create the script as `$HOME/bin/ping_server.sh`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows successful and failed output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Version 1 – ping](img/00027.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Version 2 – SSH
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Often SSH is installed and running on servers, so you may be able to run this
    script if your system is running SSH or you have access to an SSH server. In this
    script, we prompt for the server address and username and pass them through to
    the SSH client. Create the script as `$HOME/bin/connect_server.sh`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note the use of the brace bracket to delimit the variable from the `@` symbol
    in the last line of the script.
  prefs: []
  type: TYPE_NORMAL
- en: Version 3 – MySQL/MariaDB
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the next script, we will provide the detail for a database connection along
    with the SQL query to execute. You will be able to run this if you have a MariaDB
    or MySQL database server on your system or one that you can connect to. For the
    demonstration, I will use a Raspberry Pi running Ubuntu-Mate 15.04 and MariaDB
    version 10; however, this should work for any MySQL server or MariaDB from version
    5 onwards. The script collects user and password information as well as the SQL
    command to execute. Create the script as `$HOME/bin/run_mql.sh`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In the script, we can see that we suppress the display of the MySQL password
    when we input it into the `read` command using the `-s` option. Again, we use
    `echo` directly to ensure that the next prompt starts on a new line.
  prefs: []
  type: TYPE_NORMAL
- en: 'The script input is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Version 3 – MySQL/MariaDB](img/00028.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now, we can easily see the password suppression working and the ease of adding
    to the MySQL commands.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Feel proud that you have your "I can read" badge for shell scripting. We have
    developed our scripts to be interactive and prompting users for input during the
    script execution. These prompts can be used to simplify user operations on the
    command line. In this way, they do not need to remember the command line options
    or have passwords that end up stored in the command line history. When using passwords,
    we can silently store the value using the `read -sp` options.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will take our time to look at the conditional statements
    in bash.
  prefs: []
  type: TYPE_NORMAL
