- en: Identity Access Management on AWS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: AWS offers many different methods for users to authenticate their accounts through
    the IAM service, the most common of which include user accounts and roles. IAM
    users provide means of setting up credentials for something that needs long-term
    access to the environment. Users can access the AWS APIs by authenticating with
    the web UI using a username and password, or by using API keys (an access key
    ID and secret access key) to programmatically make requests.
  prefs: []
  type: TYPE_NORMAL
- en: Roles, on the other hand, provide means of delegating temporary credentials
    to users/services/applications as they need them. An IAM user who has the `sts:AssumeRole`
    permission can assume a role to get a set of API keys (an access key ID, secret
    access key, and session token) that are only valid for a small amount of time.
    When default, the lifespan is set to one hour before these keys will expire. These
    keys will have the permissions that were assigned to the role that was assumed,
    and they are often used to complete certain tasks. By using this model, the AWS
    users in an environment will not always have every single permission that they
    may need to use; instead, they can request the permissions that a role has as
    they need those permissions. This allows for more strict auditing and permissions
    management.
  prefs: []
  type: TYPE_NORMAL
- en: There are also resources in AWS IAM known as **groups**. Groups can be used
    to delegate a common set of permissions to a group of users. In an example AWS
    environment, there may be a group called **developers** that provides access to
    services that the company developers need access to. Then, users can be added
    to the group, and they will inherit the permissions associated with it. Users
    will only retain the provided permissions for as long as they are a member of
    the associated group. A single user can be a member of up to 10 separate groups
    and a single group, can hold up to the total number of users that are allowed
    in the account.
  prefs: []
  type: TYPE_NORMAL
- en: IAM users, roles, and groups are important to our attack process and for our
    basic understanding of the AWS infrastructure. This chapter aims to provide insight
    into some common features of the IAM service and how we might use them as regular
    AWS users and as attackers.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will be using the IAM service to cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: How to create IAM users, groups, roles, and associated privileges
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to limit the API actions and resources accessible to a specific role
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using IAM access keys
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Signing AWS API requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating IAM users, groups, roles, and associated privileges
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you are logged in to the AWS web console, users, groups, and roles can
    be created by navigating to the IAM service page:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To get to the IAM page, click on the Services button on the top-left of the
    page, then search for and click on the relevant link to the IAM page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6df3ba5b-11e9-4933-ac29-7da82fbedd52.png)'
  prefs: []
  type: TYPE_IMG
- en: Searching for the IAM service in the Services drop-down menu of the AWS web
    console
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure shows the relevant links for users, groups, and roles
    on the IAM dashboard. Click on Users to continue:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/cf9a5a8a-6211-4ddb-8598-b00b7b98857e.png)'
  prefs: []
  type: TYPE_IMG
- en: The relevant links on the IAM dashboard
  prefs: []
  type: TYPE_NORMAL
- en: 'To create an IAM user, click on the Add user button at the top-left of the
    page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/08c712c9-f983-48f1-8887-5ee43bbe8395.png)'
  prefs: []
  type: TYPE_IMG
- en: The Add user button on the Users dashboard
  prefs: []
  type: TYPE_NORMAL
- en: You will then be presented with a page that requests a User name and the type
    of access to provide to the new user. One of the two types of access that you
    can choose is Programmatic access, which creates an access key ID and secret access
    key for the user, so that they can access the AWS APIs through something like
    the AWS CLI or the SDKs provided for various programming languages. The other
    is AWS Management Console access, which will either autogenerate a password or
    allow you to set a custom one, so that the user can access the AWS web console.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our example, let''s create a user named `Test` that is allowed programmatic
    access to the AWS APIs. Once that has been filled out, you can click on Next:
    Permissions to continue:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/8c2b4aeb-256e-48bd-93e6-e0a1a160bd81.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4: Creating a new user named Test with programmatic access to the AWS
    APIs'
  prefs: []
  type: TYPE_NORMAL
- en: After continuing, you will be presented with three options to set up permissions
    for this new user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you wanted to create a user without any permissions (for example, if you
    were going to handle those later), you could just click on Next: Review to skip
    this page.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The three options that are presented allow you to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Add the user to an IAM group
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: Copy the permissions of another existing user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attach the existing IAM policies directly to the user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Click on the third option to attach an existing policy directly to the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e58d2e60-01bd-481e-9a93-fbfee5c6111c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5: Selecting the option to attach existing policies directly to the
    new user'
  prefs: []
  type: TYPE_NORMAL
- en: After doing so, you will be presented with a list of IAM policies.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the search box that appears, type in `AmazonEC2FullAccess` and check the
    box to the left of the policy that appears. This policy will provide the user
    with full access to the EC2 service, as well as other services that are often
    used in tandem with EC2\. If you are interested in viewing the JSON document for
    this policy, you can click on the arrow next to the policy name and then click
    on the {} JSON button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/0a3ea57e-2b69-47a7-b388-076adf17afcb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6: Viewing the JSON document for the IAM policy that we selected'
  prefs: []
  type: TYPE_NORMAL
- en: IAM policies are documents in JSON formats that specify what permissions are
    allowed or denied, what resources those permissions apply to, and under what conditions
    those permissions are valid for a certain user, group, or role.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two kinds of IAM policies: policies that are AWS managed and policies
    that are customer managed. An AWS managed policy is a pre-defined set of permissions
    that AWS manages. AWS managed policies can be recognized by the small orange AWS
    symbol next to the policy name. Customers are not allowed to modify these AWS
    managed policies, and they are provided as a method of convenience when setting
    up permissions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ae4087d6-e870-4ad6-8e68-1eac34a9027a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7: The AWS managed policy AmazonEC2FullAccess has been chosen'
  prefs: []
  type: TYPE_NORMAL
- en: Customer managed policies are the same as AWS managed policies, except that
    they must be created, and they are fully customizable at any time. These policies
    allow you to delegate fine-grained access to the various IAM users, groups, and
    roles in your account.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now click the Next: Review button towards the bottom-right of the window
    to move on. The next page will be a summary of what we have just set up, so we
    can go ahead and click on the Create user button towards the bottom-right of the
    window.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, you should be presented with a green Success message and the option to
    either view or download the associated Access key ID and Secret access key for
    this new user:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/2d0edbea-25a7-4dcd-89c3-38b71b8ebc00.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8: The success page presented after creating a new IAM user'
  prefs: []
  type: TYPE_NORMAL
- en: This is the only time that these credentials will be available to you, so it
    is important to securely store this information somewhere that only you can access.
  prefs: []
  type: TYPE_NORMAL
- en: The same general process can be followed to create roles and groups, as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to create a group and add our new user to it, we can follow these
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to the Groups tab of the IAM page in the AWS web console, then click
    on Create New Group in the top-left corner.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Supply a name for this group; in our example, it will be `Developers`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will be asked to select an IAM policy to attach to this group, which we are
    going to search for; we will add the IAMReadOnlyAccess AWS managed policy to our
    group.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Hit Next Step, and we will be presented with a summary of the group that we
    want to create, where we can complete the process by clicking on Create Group
    in the bottom-right, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c74da7ec-0c7c-4079-adaa-3fa474086c75.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9: Creating our new group named Developers with the IAMReadOnlyAccess
    policy attached'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the group is created, we can click on it from the IAM groups page,
    and we will see something like the following screenshot, where we can click on
    the Add Users to Group button to add our new user to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a994979d-fe18-4271-9567-6810fe9bb71b.png)'
  prefs: []
  type: TYPE_IMG
- en: Our newly created group without any users in it yet
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then search for and check the box next to our previously created `Test`
    user, and then click on the Add Users button, as shown in the following screenshot,
    to complete the process:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a0c41e40-b403-4f0d-b535-c0fb697c0066.png)'
  prefs: []
  type: TYPE_IMG
- en: Selecting and adding our Test user to our new Developers group
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if we navigate to the user page for our `Test` user, we can see that we
    have our previously attached AmazonEC2FullAccess AWS managed policy attached to
    our user, as well as another section, Attached from group, that includes the IAMReadOnlyAccess
    AWS managed policy that our user has inherited from the `Developers` group:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/0a875368-505e-4f0b-828c-5d5d9f930982.png)'
  prefs: []
  type: TYPE_IMG
- en: A policy directly attached to our user and a policy inherited from the Developers
    group
  prefs: []
  type: TYPE_NORMAL
- en: 'If we are curious about what groups our user is in and what policies our user
    is inheriting from them, we can click, the Groups (1) tab, and it will give us
    that information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6fec2d0f-c795-4a73-a17a-89631846149f.png)'
  prefs: []
  type: TYPE_IMG
- en: The groups that our user is a part of and what policies we have inherited from
    them
  prefs: []
  type: TYPE_NORMAL
- en: Roles cannot be added to groups, but IAM policies can be attached and removed
    from them in the same way that they can for users and groups. Roles have an additional
    important feature known as **trust relationships**. Trust relationships specify
    who can assume (request temporary credentials for) the role in question, and under
    what conditions that can occur.
  prefs: []
  type: TYPE_NORMAL
- en: 'I have created a role that has a trust relationship created with the AWS EC2
    service, which means that EC2 resources can request temporary credentials for
    this role. The following screenshot shows the Trust relationships tab when viewing
    a specific role:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d1a0b832-0a48-4439-b56d-ae5e355a1f48.png)'
  prefs: []
  type: TYPE_IMG
- en: Trust relationships tab
  prefs: []
  type: TYPE_NORMAL
- en: In the highlighted section, we can see that we have one trusted entity, and
    it is The identity provider(s) ec2.amazonaws.com.
  prefs: []
  type: TYPE_NORMAL
- en: 'Trust relationships are specified in a JSON document known as the **assume
    role policy** document. Our example role has the following assume role policy
    document specified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Policies and their supported keys will be described in more depth in the next
    section, but basically, what this JSON document says is that the EC2 service (the
    principal) is allowed (the effect) to run the `sts:AssumeRole` action while targeting
    this role. Principals can also include IAM users, other AWS services, or other
    AWS accounts. This means that you can assume cross-account roles, which is a common
    way to establish persistence in an account as an attacker. This will be described
    further in [Chapter 11](0d6c1dfb-b078-4ed0-a92a-b86751ef1db8.xhtml), *Using Boto3
    and Pacu to Maintain AWS Persistence*. We will now continue by looking at limiting
    API actions and accessible resources with IAM policies.
  prefs: []
  type: TYPE_NORMAL
- en: Limit API actions and accessible resources with IAM policies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: IAM policies are how permissions are delegated to the users, roles, and groups
    in your account. They are simple JSON documents that specify what permissions
    are specifically allowed or denied, what resources those permissions can/can't
    be used on, and under what conditions those rules apply. We can use these to enforce
    fine-grained permissions models within our AWS environment.
  prefs: []
  type: TYPE_NORMAL
- en: IAM policy structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following JSON document is an example that was created to describe some
    of the key features of IAM policy documents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This policy has examples of some of the most common features of IAM policies.
    First, we have the `Version` key, which specifies the version of the policy language
    that is being used. The best practice is to use the latest version, which is currently
    `2012-10-17`, and not much thought needs to be given to it beyond that.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we have the `Statement` key, which is a list of JSON objects known as
    statements. Statements are the individual declarations of permissions and the
    settings relating to them. A statement can consist of the `Sid`, `Effect`, `Action`,
    `NotAction`, `Principal`, `Resource`, and `Condition` keys.
  prefs: []
  type: TYPE_NORMAL
- en: '`Sid` is an optional field and is a string of your choice that is provided
    to assist in differentiating between the different statements in a policy. It
    doesn''t need to be supplied, but if it is, it basically just makes understanding
    the policy easier for a reader. In the preceding policy, the `MyGeneralEC2Statement`
    Sid is meant to convey that the statement is a general statement for the EC2 service.'
  prefs: []
  type: TYPE_NORMAL
- en: An `Effect` key is a required field that can be set to either `Allow` or `Deny`,
    and it declares whether the listed AWS permissions (under `Action` or `NotAction`)
    are explicitly allowed or explicitly denied. All of the statements in the preceding
    example policy explicitly allow the associated permissions.
  prefs: []
  type: TYPE_NORMAL
- en: One key of either `Action` or `NotAction` is required, and it contains a set
    of AWS permissions. Almost every time, you will see `Action` being used instead
    of `NotAction`. The first statement in the previous example policy explicitly
    allows the `ec2:*` action, which uses the IAM policy wildcard character (`*`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Permissions are set up in the format of `[AWS Service]:[Permission]`, so the
    `ec2:*` permission specifies every single permission relating to the AWS EC2 service
    (such as `ec2:RunInstances` and `ec2:CopyImage`). The wildcard character can be
    used in various places in an IAM policy, such as in the following permission:
    `ec2:Describe*`. That would represent every single EC2 permission that begins
    with `Describe` (such as `ec2:DescribeInstances` and `ec2:DescribeImages`). `NotAction`
    is a little bit more complicated, but basically, they are the opposite of `Action`.
    This means that `NotAction ec2:Modify*` would represent every single API call
    for all AWS services, except for EC2 permissions that begin with `Modify` (such
    as `ec2:ModifyVolume` and `ec2:ModifyHosts`).'
  prefs: []
  type: TYPE_NORMAL
- en: The `Principal` key applies to different kinds of IAM policies, outside of what
    we have looked at so far (such as the assume role policy document in the previous
    section). It represents the resource that the statement is meant to apply to,
    but it is automatically implied in permission policies for your users, roles,
    and groups, so we are going to skip over it for now.
  prefs: []
  type: TYPE_NORMAL
- en: The `Resource` key is a required field and is a list of what AWS resources the
    specified permissions under the `Action`/`NotAction` section apply to. This value
    is often just specified as the wildcard character, which represents any AWS resource,
    but it is a best practice for most AWS permissions to be locked down to the required
    resources that they must be used on. In the second statement, we have listed in
    our example policy, we have the resource listed as `arn:aws:iam::123456789012:user/TestUser`,
    which is the ARN of a user in the account with the `123456789012` account ID and
    the `TestUser` username. This means that we are only allowed (the effect) to perform
    the `iam:GetUser` API call (the action) on a user in the account with the `123456789012`
    ID and the `TestUser` username (the resource). Note that although the account
    ID is listed in the resource, many API calls cannot be used on a resource belonging
    to a different AWS account from the user/role who is making the call, even if
    a wildcard was present, rather than the account ID.
  prefs: []
  type: TYPE_NORMAL
- en: The `Condition` key is an optional field that indicates under what conditions
    the specifications of the statement apply. In the third statement of our preceding
    example, we have the `Bool` condition (Boolean—in other words, `true`/`false`)
    known as `aws:MultiFactorAuthPresent` set to true. What this means is that for
    this statement to apply (allowing the `sts:AssumeRole` permission on any resource),
    the user/role must be multi-factor authenticated with AWS; otherwise, that permission
    is not allowed. There are many other conditions that can be specified, such as
    requiring a certain source IP address for any API calls, requiring the API call
    to be made within a certain timeframe, and many more (see [https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_elements_condition_operators.html](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_elements_condition_operators.html)).
  prefs: []
  type: TYPE_NORMAL
- en: IAM policy purposes and usage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As an attacker, it is important to understand how IAM policies work, because
    once you can read them, you can determine exactly what access you have to an environment
    and why certain API calls that you make will fail with an access denied error,
    even when it seems like they should be allowed. It's possible that you are targeting
    a resource that was not specified in the policy, you aren't multi-factor authenticated,
    or it could be for various other reasons.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we are inspecting compromised keys during an attack, what we love to see
    is a statement like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This statement gives us administrator-level permissions. Because it allows for
    the use of the `*` permission, and because the `"*"` character is a wildcard,
    it means that any permission pertaining to an AWS service is allowed. The resource
    is also wild carded, so we can run any API call against any resource in our target
    account. There is an AWS-managed IAM policy with these permissions known as the
    `AdministratorAccess` policy. The ARN for this policy is `arn:aws:iam::aws:policy/AdministratorAccess`.
  prefs: []
  type: TYPE_NORMAL
- en: To manage a user's permissions while testing, you can attach an IAM policy to
    your user, role, or group, to provide or deny them the permissions setup in the
    policy. So far, the policy type that we have looked at can be reused and attached
    to multiple different kinds of resources. For example, the same IAM policy could
    be attached to a user, group, and/or role, all at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: Inline policies also exist, and rather than being an independent resource that
    is then attached to users, roles, or groups, like managed policies, they are created
    directly on a user, role, or group. Inline policies cannot be reused like managed
    policies can, and for that reason, a security best practice is to try to avoid
    using inline policies. As an attacker, we can use them for a few different malicious
    reasons, but because they only apply to a single resource, it is a little stealthier
    when creating one during an attack. They work the same as managed policies but
    require a different set of permissions to interact with. Sometimes, you may find
    that a compromised user/role may have access to work with inline policies but
    not managed policies, or the other way around.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot is from the AWS web console, which shows an IAM user
    that I have set up that has both a managed policy (AmazonEC2FullAccess) and an
    Inline policy (TestPolicy) attached:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fe977450-8419-43ae-a3ce-7e30c88481bc.png)'
  prefs: []
  type: TYPE_IMG
- en: An AWS managed policy and an inline policy attached to an IAM user
  prefs: []
  type: TYPE_NORMAL
- en: Using IAM access keys
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have created a user and access keys and understand how IAM policies
    work, it is time to put them to work to make some AWS API calls:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s get the AWS **command-line interface** (**CLI**) installed. The
    easiest way to do so (if you have Python and `pip` installed on your computer)
    is to run the following `pip` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then check to see if the installation was successful by running the
    following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'For more specific instructions for your operating system, visit: [https://docs.aws.amazon.com/cli/latest/userguide/installing.html](https://docs.aws.amazon.com/cli/latest/userguide/installing.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'To add our user credentials to the AWS CLI so that we can make API calls, we
    can run the following command that stores our credentials under the `Test` profile
    (note that profiles allow you to manage multiple different sets of credentials
    from the command line):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'You will be prompted for a few different values, including your access key
    ID and secret key, which we were presented with after we created our `Test` user
    earlier on. Then, you''ll be asked for the default region name, and in our example,
    we will choose the `us-west-2` (Oregon) region. Lastly, you will be asked for
    the default output format. We will choose `json` as our default format, but there
    are other available values, such as `table`. The following screenshot shows us
    setting up credentials for the `Test` profile in our newly installed AWS CLI:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a505a9b8-629b-48db-8212-7b50c0138d7a.png)'
  prefs: []
  type: TYPE_IMG
- en: Creating the Test profile with our newly created credentials
  prefs: []
  type: TYPE_NORMAL
- en: 'Our new profile will now be stored in the AWS CLI credentials file, which is
    in the following file: `~/.aws/credentials`.'
  prefs: []
  type: TYPE_NORMAL
- en: To update the credentials/settings for that profile, you can run that same command
    again, and to add in new sets of credentials as you compromise them, you can just
    change the name of the profile from `Test` to whatever makes sense for the keys
    you are adding. Now that we have the AWS CLI installed and our `Test` profile
    set up, it is simple to begin using our credentials. One thing to keep in mind
    is that because we are using AWS CLI profiles, you will need to remember to include
    the `--profile Test` argument in all your AWS CLI commands, so that the correct
    credentials are used to make the API call.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A very useful command to start out with is the `GetCallerIdentity` API provided
    by the **Security Token Service** (**STS**) ([https://docs.aws.amazon.com/STS/latest/APIReference/API_GetCallerIdentity.html](https://docs.aws.amazon.com/STS/latest/APIReference/API_GetCallerIdentity.html)).
    This API call is provided to every single AWS user and role, and it cannot be
    denied through IAM policies. This allows us to use this API as a method of enumerating
    some common account information about our keys. Go ahead and run the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see output like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f53cde88-ba2f-4da3-bafe-cf54e3ff9e0a.png)'
  prefs: []
  type: TYPE_IMG
- en: Running the sts:GetCallerIdentity command from our Test profile
  prefs: []
  type: TYPE_NORMAL
- en: The output includes a user ID, account ID, and an ARN of the current user. The
    user ID is how your user is referenced on the backend of the APIs, and in general,
    it will not be required by us while making API calls. The account ID is the ID
    of the account that this user belongs to.
  prefs: []
  type: TYPE_NORMAL
- en: In situations where you have an account ID, there are ways to enumerate what
    users and roles exist in the account without creating logs in the target account,
    but this attack is generally not very helpful in a post-exploitation scenario
    and is more helpful for something like social engineering. The **Amazon Resource
    Name** (**ARN**) of the current user includes the account ID and the user name.
  prefs: []
  type: TYPE_NORMAL
- en: 'All other API calls that we make with the AWS CLI will be run in a similar
    fashion, and most AWS services are supported in the AWS CLI. A small trick to
    list out services you can target and how to reference them is to run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Basically, this command tries to target the `a` service, but because that is
    not a real service, the AWS CLI will print out all the available services, as
    you can see in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fbcab712-8da7-4653-9e81-fe05089d573a.png)'
  prefs: []
  type: TYPE_IMG
- en: Running an AWS CLI command against an invalid service to list available services
  prefs: []
  type: TYPE_NORMAL
- en: 'This same trick can be used to list what APIs are available for each service.
    Let''s suppose that we know we want to target the EC2 service, but we don''t know
    the name of the command we want to run. We can run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This will try to run the `a` EC2 API call, which doesn''t exist, so the AWS
    CLI will print out all valid API calls that you can choose from, as you can see
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fb4bd6a5-0f0c-41bf-b048-82ee66473d16.png)'
  prefs: []
  type: TYPE_IMG
- en: Running an invalid AWS CLI command to list what commands are supported for our
    target service (EC2)
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information on an AWS service or API call, such as a description,
    limitations, and the supported arguments, we can use the `help` command. For an
    AWS service, you can use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'And for a specific API call, you can use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'To finish off this section, let''s utilize the AmazonEC2FullAccess policy that
    we attached to our user earlier on:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to list all the instances in the default region (we chose `us-west-2`
    earlier), we can run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If you don''t have any EC2 instances running in your account, you will likely
    see output like what is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ececbc77-236d-4d6c-b1bf-d59b798eeab0.png)'
  prefs: []
  type: TYPE_IMG
- en: The results of trying to describe EC2 instances when the target region doesn't
    have any
  prefs: []
  type: TYPE_NORMAL
- en: 'Without specifying a region, that will automatically target the `us-west-2`
    region, because we input that as our default when we set up our credentials. This
    can be done manually per API call by using the `--region` argument, like in the
    following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Our test account has an EC2 instance running in `us-east-1`, so the output
    will be different this time. It will look like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/284bc53f-a16c-475a-823c-ccb05492d8ba.png)'
  prefs: []
  type: TYPE_IMG
- en: Part of the output returned when describing an EC2 instance in the `us-east-1`
    region
  prefs: []
  type: TYPE_NORMAL
- en: The data will be returned in a JSON format, because that is what we specified
    as our default when setting up our credentials. It will include lots of information
    relevant to the EC2 instances that it found in the region and the account you
    targeted, such as the instance ID, the size of the instance, what image was used
    to launch the instance, the networking information, and much more.
  prefs: []
  type: TYPE_NORMAL
- en: Various parts of this information can be gathered and reused in subsequent requests.
    An example of this would be noting what EC2 security groups are attached to each
    instance. You are provided with the name of the security group and the ID, which
    could then be used in a request that tried to describe the firewall rules that
    are applied to those groups.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the results of our `ec2:DescribeInstances` call, we can see that the `sg-0fc793688cb3d6050`
    security group is attached to our instance. We can pull information about this
    security group by feeding that ID into the `ec2:DescribeSecurityGroups` API call,
    like in the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we are presented with the inbound and outbound firewall rules that are
    applied to the instance that we described previously. The following screenshot
    shows the command and some of the inbound traffic rules applied to our instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e0b54b40-0acb-4cac-ae8c-ef070319860d.png)'
  prefs: []
  type: TYPE_IMG
- en: Command and some of the inbound traffic rules
  prefs: []
  type: TYPE_NORMAL
- en: We can see that under the `IpPermissions` key, inbound access to port 22 from
    any IP address (`0.0.0.0/0`) is allowed. Not shown in the screenshot is the `IpPermissionsEgress`
    key that specifies the rules for outbound traffic from the EC2 instance.
  prefs: []
  type: TYPE_NORMAL
- en: Signing AWS API requests manually
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most AWS API calls require that certain data in them be signed before sending
    them to the AWS servers. This is done for a few different reasons, such as allowing
    the server to verify the identity of the API caller, to protect data from modification
    while it is in transit to the AWS servers, and to prevent replay attacks, where
    an attacker intercepts your request somehow and runs it again themselves. By default,
    a signed request is valid for five minutes, so technically, replay attacks are
    possible if the request is intercepted and re-sent prior to that five minute window
    closing. The AWS CLI and AWS SDKs (such as the `boto3` Python library at [https://boto3.amazonaws.com/v1/documentation/api/latest/index.html](https://boto3.amazonaws.com/v1/documentation/api/latest/index.html))
    automatically handle all request signing for you, so you don't need to think about
    it.
  prefs: []
  type: TYPE_NORMAL
- en: There are a couple of cases where you may need to manually sign API requests,
    though, so this section will give a brief overview of how you can do that. The
    only real cases where you will need to do something like this will be if you are
    using a programming language that does not have an AWS SDK or if you want full
    control of the request that is being sent to the AWS servers. There are two versions
    of signatures that are supported (v2 and v4), but for our use case, we will almost
    always use v4.
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information on signing requests and the specifics, visit this link
    to the AWS documentation: [https://docs.aws.amazon.com/general/latest/gr/signing_aws_api_requests.html](https://docs.aws.amazon.com/general/latest/gr/signing_aws_api_requests.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Basically, the process of manually signing an AWS API request with signature
    v4 consists of four separate steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a canonical request ([https://docs.aws.amazon.com/general/latest/gr/sigv4-create-canonical-request.html](https://docs.aws.amazon.com/general/latest/gr/sigv4-create-canonical-request.html))
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating a string to sign ([https://docs.aws.amazon.com/general/latest/gr/sigv4-create-string-to-sign.html](https://docs.aws.amazon.com/general/latest/gr/sigv4-create-string-to-sign.html))
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Calculating the signature of that string ([https://docs.aws.amazon.com/general/latest/gr/sigv4-calculate-signature.html](https://docs.aws.amazon.com/general/latest/gr/sigv4-calculate-signature.html))
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adding that signature to your HTTP request ([https://docs.aws.amazon.com/general/latest/gr/sigv4-add-signature-to-request.html](https://docs.aws.amazon.com/general/latest/gr/sigv4-add-signature-to-request.html))
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The AWS documentation has some great examples of how to go through this process.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following link has example Python code that shows the entire process and
    explains the steps along the way: [https://docs.aws.amazon.com/general/latest/gr/sigv4-signed-request-examples.html](https://docs.aws.amazon.com/general/latest/gr/sigv4-signed-request-examples.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered some of the basics of the IAM service, such as IAM
    users, roles, and groups. We also looked at using IAM policies to restrict permissions
    within an environment, as well as IAM user access keys and the AWS CLI. Information
    on manually signing AWS HTTP requests was presented, also, for the rare occasion
    that you find it necessary.
  prefs: []
  type: TYPE_NORMAL
- en: These foundational topics will reappear again and again throughout this book,
    so it is important to get a strong grasp of the AWS IAM service. There are more
    features, intricacies, and details of the IAM service that we didn't cover in
    this chapter, but some of the more important ones will be discussed separately
    in other chapters of the book. The main reason for the content of this chapter
    is to provide a base of knowledge as you dive into the more advanced topics and
    services of AWS later on.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at using the AWS `boto3` Python library with
    stolen access keys to enumerate our own permissions, as well as to escalate them
    all the way to an administrator! We will also cover Pacu, an AWS exploitation
    toolkit, which has already automated a lot of these attack processes and makes
    it easier to automate them yourself. Permission enumeration and privilege escalation
    are integral to AWS pentests, so get ready!
  prefs: []
  type: TYPE_NORMAL
