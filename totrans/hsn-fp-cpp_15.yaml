- en: Refactoring to and through Pure Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Programmers often hit code they are afraid to change. By extracting pure functions,
    using currying and composition, and taking advantage of the compiler, you can
    refactor existing code in a safer manner. We'll see an example of refactoring
    through pure functions, and then we'll look at a few design patterns, how they
    are implemented in functional programming, and how to use them in your refactoring.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: How to think about legacy code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use the compiler and pure functions to identify and separate dependencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to extract lambdas from any piece of code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to remove duplication between lambdas using currying and composition, and
    group them into classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to implement a few design patterns (strategy, command, and dependency injection)
    using functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use design patterns based on functions to refactor toward them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need a compiler that supports C++ 17\. I used GCC 7.4.0c.
  prefs: []
  type: TYPE_NORMAL
- en: The code is on GitHub at [https:/​/​github.​com/​PacktPublishing/​Hands-​On-​Functional-Programming-​with-​Cpp](https://github.%E2%80%8Bcom/PacktPublishing/Hands-On-Functional-Programming-with-Cpp)
    in the `Chapter12` folder. It includes and uses `doctest`, which is a single-header,
    open source, unit testing library. You can find it on its GitHub repository at
    [https:/​/github.​com/​onqtam/​doctest](https://github.%E2%80%8Bcom/onqtam/doctest).
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring to and through pure functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Refactoring** is an important and continuous part of software development.
    The main reason is the continuous change in requirements, driven by the changes
    in the world around the applications that we build. Our clients keep learning
    about the ecosystem in which products work, and need us to adapt these products
    to the new reality they discover. As a result, our code, even when perfectly structured,
    is almost always behind our current understanding of the problems that we''re
    solving.'
  prefs: []
  type: TYPE_NORMAL
- en: Structuring our code perfectly is no easy feat either. Programmers are people,
    so we make mistakes, lose focus, and sometimes fail to find the best solutions.
    The only way to deal with this complex situation is by using merciless refactoring;
    that is, after we make things work, we improve the code structure until the code
    is as good as it can be under the constraints we have.
  prefs: []
  type: TYPE_NORMAL
- en: That's easy to say and do, as long as we refactor very early and we write the
    tests. But what if we inherit a code base that has no tests? What do we do then?
    We'll visit this problem, along with a promising idea that uses pure functions
    to refactor the legacy code later.
  prefs: []
  type: TYPE_NORMAL
- en: First, let's define our terms. What is refactoring?
  prefs: []
  type: TYPE_NORMAL
- en: What is refactoring?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Refactoring is one of the terms that''s universally used in the industry, but
    is not well understood. Unfortunately, the term is often used to justify big redesigns.
    Consider the following common story about a given project:'
  prefs: []
  type: TYPE_NORMAL
- en: When the project starts, features are added at a fast pace.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Soon enough (months, one year, or even weeks), the speed decreases, but the
    demand is the same.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Years later, it's so difficult to add new features that the clients are annoyed
    and pressure the team.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, a decision is made to rewrite or change the whole structure of the
    code in the hope it will speed things up.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Six months later, the rewrite or redesign (usually) fails and the management
    faces an impossible situation—should we try to redesign, restart the project,
    or do something else?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **big redesign** phase of this cycle is often erroneously called refactoring,
    but that's not what refactoring is.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, to understand the true meaning of refactoring, let''s start by thinking
    about what changes we can make to a code base. We can usually classify these changes
    into categories as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a new requirement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixing a bug
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reorganizing the code in various ways—refactoring, re-engineering, re-designing,
    and/or re-architecting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can roughly classify these changes into two big categories as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Changes that impact on the behavior of the code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changes that don't impact on the behavior of the code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we talk about behavior, we talk about inputs and outputs, such as "when
    I introduce these values in a **user interface** (**UI**) form and click this
    button, then I see this output and these things are saved". We don't usually include cross-functional
    concerns such as performance, scalability, or security in the behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: With these terms clear, we can define refactoring—it is simply making changes
    to the code structure that don't affect the external behavior of the program.
    Big redesigns or rewrites rarely fit into this definition, because usually, teams
    doing big redesigns don't prove that the result has the same behaviors as the
    original (including the known bugs, since someone may depend on them).
  prefs: []
  type: TYPE_NORMAL
- en: Any change to the program that modifies its behavior is not refactoring. This
    includes fixing bugs or adding a feature. However, we can split these changes
    into two phases—first, refactor to *make space* for the change, and then make
    the change in behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'This definition raises a few questions, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'How can we prove we haven''t changed the behavior? There''s only one way we
    know to do this: automated regression tests. If we have a suite of automated tests
    that we trust and that are fast enough, we can easily make a change without changing
    any tests and see if they pass.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'How small is the refactoring? The larger a change is, the more difficult it
    is to prove that nothing is affected, since programmers are humans and make mistakes.
    We prefer to have very small steps in refactoring. Here are a few examples of
    small behavior-preserving code changes: rename, add a parameter to a function,
    change the order of parameters for a function, and extract a group of statements
    into a function, among others. Each small change can be easily made and the tests
    run to prove that no behavioral change happened. Whenever we need to make a bigger
    refactoring, we just make a series of these small changes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can we prove that we haven't changed the behavior of code when we have no
    tests? This is when we need to talk about legacy code and the legacy code dilemma.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The legacy code dilemma
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Programming is probably the only domain in which the word *legacy* has a negative
    connotation. In any other context, legacy means something that someone leaves
    behind and something that someone is usually proud of. In programming, legacy
    code refers to exclusive code that we inherit and is a pain to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: 'Too often, programmers think that legacy code is inevitable and there''s nothing
    that can be done about it. We can, however, do a lot of things. The first is to
    clarify what we mean by legacy code. Michael Feathers, in his book on legacy code,
    defines it as code that doesn''t have tests. However, I like to use a more general
    definition: *code that you''re afraid to change*. Code that you are afraid to
    change will slow you down, reduce your options, and make any new development an
    ordeal. But this is, by no means, inevitable: we can change it and we''ll see
    how.'
  prefs: []
  type: TYPE_NORMAL
- en: The second thing we can do is understand the dilemma of legacy code. To be less
    afraid of change, we need to refactor it, but in order to refactor the code, we
    need to write tests. To write tests, we need to adjust the code to make it testable;
    this looks like a circle—in order to change the code, we need to change the code!
    How do we do that if we're afraid to change the code in the first place?
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, this dilemma has a resolution. If we could just make safe changes
    to the code—changes that leave us very little opportunity for error and allows
    us to test the code—then we could slowly, but surely, improve the code. These
    changes are, indeed, refactoring, but they're even smaller and safer than the
    refactoring steps. Their main goal is to break the dependency between the design
    elements in your code, enabling us to write tests so we can continue refactoring
    afterward.
  prefs: []
  type: TYPE_NORMAL
- en: Since our focus is on using pure functions and functional constructs to refactor
    code, we won't look at the full list of techniques. I can give one simple example
    called **extract and override**. Let's say you need to write tests for a very
    large function. It would be ideal if we could just write tests for a small part
    of the function instead. The way we could do this is by extracting the code that
    we want to test into another function. However, the new function depends on old
    code, so we'll have a hard time figuring out all the dependencies. To solve this
    issue, we can create a derived class that overrides all the dependencies of our
    function with dummy functions. In unit testing, this is called a *partial mock*.
    This allows us to cover, with tests, all the code from our extracted function,
    while assuming that all the other parts of the class work as expected. Once we
    cover it with tests, we can then move to refactoring; we often end up extracting
    a new class that is fully mocked or stubbed by the end of this exercise.
  prefs: []
  type: TYPE_NORMAL
- en: These techniques were written before we had such widespread support for functional
    programming in our languages. We can now take advantage of pure functions to safely
    refactor the code we write. But, to do that, we need to understand how dependencies
    affect our ability to test and change code.
  prefs: []
  type: TYPE_NORMAL
- en: Dependencies and change
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our users and customers want more and more features, for as long as the project
    is successful. Yet, we often fail to deliver, because code tends to become more
    rigid over time. Adding new features gets slower and slower as time passes, and,
    when adding a feature, new bugs pop up.
  prefs: []
  type: TYPE_NORMAL
- en: This leads to the one-billion question—what makes code difficult to change?
    How can we write code that maintains the speed of change, or even increases it?
  prefs: []
  type: TYPE_NORMAL
- en: This is a complex problem, with many facets and with various solutions. One
    of them is fundamentally agreed in the industry—dependencies tend to slow down
    development. Code structures with fewer dependencies are generally easier to change,
    thus making it easier to add features.
  prefs: []
  type: TYPE_NORMAL
- en: We can look at dependencies on many levels. At a higher level, we can talk about
    executables that depend on other executables; for example, a web service that
    directly calls another web service. Reducing dependencies at this level can be
    done by using event-based systems instead of direct calls. At a lower level, we
    can talk about dependencies on libraries or OS routines; for example, a web service
    that depends on the existence of a specific folder or specific library version.
  prefs: []
  type: TYPE_NORMAL
- en: While all the other levels are interesting, for our goals we will focus on the
    class/function level, and specifically on how classes and functions depend on
    one another. Since it's impossible to avoid dependencies in any non-trivial code
    bases, we will focus instead on the strength of dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll use as an example a small piece of code I wrote that computes salaries
    based on a list of employees and parameters such as role, seniority, continuity
    in the organization, and bonus level. It reads the list of employees from a CSV
    file, computes salaries based on a few rules, and prints the computed salary list.
    The first version of the code is naively written, using just the `main` function
    and putting everything together in the same file, as shown in the following code
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The input file was generated with random values using a specialized tool and
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run the program, `salary` is computed for each employee and the output
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: So, does this code have dependencies? Yes, and they are hidden in plain sight.
  prefs: []
  type: TYPE_NORMAL
- en: 'One way to find dependencies is to look for constructor calls or global variables.
    In our case, we have one constructor call to `ifstream`, and one use of the `cout`, as
    shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Another way to identify dependencies is to create an imagination exercise. Imagine
    what requirements could produce changes in the code. There are a few. If we decide
    to switch to an employee database, we'll need to change the way we read data.
    If we want to output to a file, we'll need to change the lines of code that print
    the salaries. If the rules for computing salaries change, we will need to change
    the lines that compute `salary`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Both methods lead to the same conclusion; we have dependencies on the file
    system and on the standard output. Let''s focus on the standard output and ask
    one question; how can we change the code so that we can output the salaries both
    to standard output and to a file? The answer is quite easy, due to the polymorphic
    nature of the **Standard Template Library** (**STL**) streams, just extract a
    function that receives an output stream and writes the data. Let''s see what such
    a function would look like; for simplicity, we''ve also introduced a structure
    called `Employee` that contains all the fields we need, as shown in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This function doesn''t depend on the standard output anymore. In terms of dependencies,
    we can say that *we broke the dependency* between the employee printing and the
    standard output. How did we do that? Well, we passed the `cout` stream as an argument
    of the function from the caller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This seemingly minor change makes the function polymorphic. The caller of `printEmployee` now controls
    the output of the function without changing anything inside the function.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, we can now write tests for the `printEmployee` function that never
    touch the filesystem. This is important, since file system access is slow and
    errors can appear when testing the happy path due to things such as a lack of
    disk space or corrupted sections. How can we write such tests? Well, we just need
    to call the function using an in-memory stream, and then compare the output written
    into the in-memory stream with what we expect.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, breaking this dependency leads to a huge improvement in the changeability
    and testability of our code. This mechanism is so useful and widespread that it
    gained a name—**dependency injection** (**DI**). In our case, the caller of the
    `printEmployee` function (the `main` function, the `test` function, or another
    future caller) injects the dependency to the output stream into our function,
    thus controlling its behavior.
  prefs: []
  type: TYPE_NORMAL
- en: It's important to clarify one thing about DI—it is a design pattern, not a library.
    Many modern libraries and MVC frameworks enable DI, but you don't need anything
    external to inject dependencies. You just need to pass the dependency into a constructor,
    property, or function argument and you're all set.
  prefs: []
  type: TYPE_NORMAL
- en: We learned how to identify dependencies and how we can use DI to break them.
    It's time to look at how we can refactor this code by taking advantage of pure
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: Pure functions and the structure of programs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A few years ago, I learned a fundamental law about computer programs that has
    led me to study how to use pure functions in refactoring:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Any computer program can be built from two types of classes/functions—some
    that do I/O and some that are pure.*'
  prefs: []
  type: TYPE_NORMAL
- en: Searching for similar ideas afterward, I found Gary Bernhardt's concise naming
    for such structures: *functional core, imperative shell* ([https://www.destroyallsoftware.com/screencasts/catalog/functional-core-imperative-shell](https://www.destroyallsoftware.com/screencasts/catalog/functional-core-imperative-shell)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Regardless of what you call it, the consequences of this idea on refactoring
    are fundamental. If any program can be written as two separate types of classes/functions,
    some immutable and some I/O, then we can take advantage of this property to refactor
    legacy code. The high-level process would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: Extract pure functions (and we'll see that these steps identify dependencies).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test and refactor them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regroup them into classes according to the high-cohesion principle.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I would like to add an axiom to this law. I believe we can apply this at any
    level of the code, be it a function, class, group of lines of code, group of classes,
    or whole module, except for those lines of code that are pure I/O. In other words,
    this law is fractal; it applies at any level of code except the most basic ones.
  prefs: []
  type: TYPE_NORMAL
- en: The importance of this axiom is huge. What it tells us is that we can apply
    the same method we previously described on any level of the code, except the most
    basic. In other words, it doesn't matter where we start applying the method because
    it will work anywhere.
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, we will explore each step of the method. First, let's
    extract some pure functions.
  prefs: []
  type: TYPE_NORMAL
- en: Use the compiler and pure functions to identify dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It can feel risky to try to change code that we don't understand and that doesn't
    have tests. Any mistake can lead to ugly bugs, and any change can lead to a mistake.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, the compiler and pure functions can help reveal the dependencies.
    Remember what pure functions are—functions that return the same outputs for the
    same inputs. This means, by definition, that all dependencies of pure functions
    are visible, passed either as parameters, global variables, or through variable
    capture.
  prefs: []
  type: TYPE_NORMAL
- en: 'This leads us to a simple way to identify dependencies in code: pick a few
    lines of code, extract them into a function, make it pure, and let the compiler
    tell you what the dependencies are. In addition, the dependencies will have to
    be injected, thus leading us to a testable function.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at a few examples. A simple start is the following few lines of
    code that compute the base salary based on a given employee''s position in the
    company:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s extract this as a pure function. The name doesn''t matter for now, so
    we''ll temporarily call it `doesSomething` and I''ll just copy and paste the lines
    of code into the new function, without removing them from the old function, as
    shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'My compiler immediately complains that the position is not defined, so it did
    my work for me in figuring out the dependency. Let''s add it as an argument as
    shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This function is missing something; pure functions always return values, but
    this does not. Let''s add the `return` statement as shown in the following code
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The function is now simple enough to test in isolation. But first, we need
    to extract it into a separate `.h` file and give it a proper name. `baseSalaryForPosition`
    sounds good; let''s see its tests in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The tests are fairly simple to write. They also duplicate many things from
    the function, the position strings and salary values included. There are better
    ways to organize the code, but that is expected from legacy code. For now, we
    are happy that we covered part of the initial code with tests. We can also show
    these tests to a domain expert and check that they are correct, but let''s continue
    with our refactoring. We need to start calling the new function from `main()`, as
    shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'While this was an easy case, it shows the basic process, as listed in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Pick a few lines of code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extract them into a function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make the function pure.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inject all dependencies.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write tests for the new pure function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validate the behaviors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Repeat until the whole code is covered in tests.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you follow this process, the risk of introducing bugs becomes extremely small.
    From my experience, what you need to be most careful about is making the function
    pure. Remember—if it's in a class, make it static with `const` parameters, but
    if it's outside of a class, pass all parameters as `const` and make it a lambda.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we repeat this process a few more times, we end up with more pure functions.
    First,  `factorForSeniority` computes the factor based on the seniority level,
    as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, `factorForContinuity` computes the factor based on—you guessed it—continuity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the `bonusLevel` function reads the bonus level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Each of these functions can be easily tested with example-based, data-driven,
    or property-based tests. With all these functions extracted, our main method looks
    like the following example (a few lines were omitted for brevity):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This is a bit cleaner and better covered with tests. Lambdas can be used for
    much more though; let's see how we can do this.
  prefs: []
  type: TYPE_NORMAL
- en: From legacy code to lambdas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Besides purity, lambdas offer us many operations we can use: functional composition,
    partial application, currying, and higher-level functions. We can take advantage
    of these operations while refactoring legacy code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The easiest way to show this is by extracting the whole `salary` computation
    from the `main` method. These are the lines of code that compute the `salary`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We can extract this pure function in two ways—one is by passing in every value
    needed as a parameter, the result of which is shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The second option is much more interesting. Instead of passing the variables,
    how about we pass the functions and bind them to the needed variables beforehand?
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s an intriguing idea. The result is a function that receives multiple
    functions as a parameter, each of them without any arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The `main` method needs to bind the functions first and then inject them into
    our method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Why is this approach interesting? Well, let's look at it from a software design
    perspective. We created small pure functions that each have a clear responsibility.
    Then, we bound them to specific values. Afterward, we passed them as arguments
    to another lambda that uses them to compute the result we need.
  prefs: []
  type: TYPE_NORMAL
- en: What would that mean in an **object-oriented programming** (**OOP**) style?
    Well, functions would be part of a class. Binding a function to a value is equivalent
    to calling the constructor of the class. Passing the object to another function
    is called DI.
  prefs: []
  type: TYPE_NORMAL
- en: Wait a minute! What we are actually doing is separating responsibilities and
    injecting dependencies, only by using pure functions instead of objects! Because
    we use pure functions, the dependencies are made evident by the compiler. Therefore,
    we have a method to refactor code that has a very small probability of error,
    because we use the compiler a lot. This is a very useful process for refactoring.
  prefs: []
  type: TYPE_NORMAL
- en: I have to admit that the result is not as nice as I'd like. Let's refactor our
    lambda.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring lambdas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I''m not happy with what the `computeSalary` lambda we''ve extracted looks
    like. It''s quite complex due to receiving many parameters and multiple responsibilities.
    Let''s take a closer look at it, and see how we can improve it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'All the signs seem to point to the fact that the function has multiple responsibilities.
    What if we extract more functions from it? Let''s start with the `specialBonusFactor`
    computation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now inject `specialBonusFactor`. However, notice that `specialBonusFactor`
    is the only lambda that needs `bonusLevel`. This means that we can replace the
    `bonusLevel` lambda with the `specialBonusFactor` lambda partially applied to
    `bonusLevel`, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `computeSalary` lambda is now smaller. We can make it even smaller still, by
    inlining the temporary variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s pretty good! However, I''d like to get it closer to a mathematical
    formula. First, let''s rewrite the line computing `salary` (highlighted in bold
    in the code):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, let''s replace the variable with the functions. We are then left with
    the following code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Therefore, we have a lambda that receives multiple lambdas and uses them to
    compute a value. We could still make improvements to the other functions, but
    we have reached an interesting point.
  prefs: []
  type: TYPE_NORMAL
- en: So where do we go from here? We've injected dependencies, the code is more modular,
    easier to change, and easier to test. We can inject lambdas from tests that return
    the values we want, which is actually a stub in unit testing. While we haven't
    improved the whole code, we have separated dependencies and responsibilities by
    extracting pure functions and using functional operations. We can leave the code
    like this if we want to. Or, we can take another step and regroup the functions
    into classes.
  prefs: []
  type: TYPE_NORMAL
- en: From lambdas to classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've already made the point a few times in this book, that a class is nothing
    more than a set of cohesive partially applied pure functions. With our technique
    until now, we've created a bunch of partially applied pure functions. Turning
    them into classes is a simple task now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see a simple example of the `baseSalaryForPosition` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We use it in `main()` as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'To turn it into a class, we just need to create a constructor that will receive
    the `position` parameter and then change it to be a class method. Let''s see it
    in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of passing the partially applied function into the `computeSalary`
    lambda, we can simply initialize it and pass the object, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'For this to work, we also need to change our `computeSalary` lambda as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Now, to allow the injection of different implementations, we actually need to
    extract an interface from the `BaseSalaryForPosition` class and inject it as an
    interface, instead of a class. This is especially useful for injecting doubles
    from tests, such as stubs or mocks.
  prefs: []
  type: TYPE_NORMAL
- en: From now on, nothing stops you regrouping the functions into classes as you
    see fit. I will leave this as an exercise for the reader because I believe we
    have shown how to use pure functions to refactor code, even when we want to obtain
    the object-oriented code at the end.
  prefs: []
  type: TYPE_NORMAL
- en: Recapping the refactoring method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What have we learned so far? Well, we went through a structured process of refactoring
    that can be used at any level in the code, reduces the probability of errors,
    and enables changeability and testing. The process is based on two fundamental
    ideas—any program can be written as a combination of immutable functions and I/O
    functions, or as a functional core within an imperative shell. In addition, we
    have shown that this property is fractal—we can apply it to any level of code,
    from a few lines up to a whole module.
  prefs: []
  type: TYPE_NORMAL
- en: Since immutable functions can be the core of our programs, we can extract them
    little by little. We write the new function name, copy and paste the body, and
    use the compiler to pass any dependencies as arguments. When the code is compiled,
    and if we're carefully and slowly changing it, we are fairly sure that the code
    still works properly. This extraction reveals the dependencies of our function,
    thus allowing us to make design decisions.
  prefs: []
  type: TYPE_NORMAL
- en: Going forward, we will extract more functions that receive other partially applied
    pure functions as parameters. This leads to a clear distinction between dependencies
    and actual breaking dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, since the partially applied functions are equivalent to classes, we
    can easily encapsulate one or more of them, based on cohesion. This process works
    whether we start from classes or functions, and it's no matter if we want to end
    with functions or classes as well. However, it allows us to use functional constructs
    to break dependencies and to separate responsibilities in our code.
  prefs: []
  type: TYPE_NORMAL
- en: Since we are improving the design, it's time to see how design patterns apply
    in functional programming and how to refactor toward them. We'll visit a few of
    the Gang of Four patterns, as well as DI, which we've already used in our code.
  prefs: []
  type: TYPE_NORMAL
- en: Design patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many of the good things in software development come from people who notice
    how programmers work and extract certain lessons from it; in other words, looking
    at the practical approaches and extracting common and useful lessons rather than
    speculating a solution.
  prefs: []
  type: TYPE_NORMAL
- en: The so-called Gang of Four (Erich Gamma, Richard Helm, Ralph Johnson, and John
    Vlissides) took this exact approach when they documented, in a precise language,
    a list of design patterns. After noticing how more programmers were solving the
    same problems in similar ways, they decided to write these patterns down and introduced
    the world of programming to the idea of reusable solutions to specific problems
    within a clear context.
  prefs: []
  type: TYPE_NORMAL
- en: Since the design paradigm of the day was OOP, the *Design Patterns* book they
    published shows these solutions using object-oriented approaches. As an aside,
    it's quite interesting to notice that they documented at least two types of solutions
    wherever possible—one based on careful inheritance and the other on object composition.
    I've spent many hours studying the design patterns book, and I can tell you that
    it's a very interesting lesson in software design.
  prefs: []
  type: TYPE_NORMAL
- en: We'll be exploring a few design patterns and how to implement them using functions
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: The strategy pattern, functional style
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The strategy pattern can be described briefly as a way to structure your code,
    which allows the selection of an algorithm at runtime. The OOP implementation
    uses DI, and you're probably familiar with both the object-oriented and functional
    design from STL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the STL `sort` function. Its most complex form requires
    a functor object as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The `sort` function uses the `comparator` object to compare elements from the
    vector and sort it in place. It's a strategy pattern because we can exchange `comparator`
    with anything that has the same interface; in fact, it just requires the `operator()`
    function to be implemented. We could imagine, for example, a UI in which a human
    user selects the comparison function and sorts a list of values using it; we would
    only need to create the right instance of `comparator` at runtime and send it
    to the `sort` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can already see the seeds of the functional solution. In fact, the `sort`
    function allows a much simpler version, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This time, we drop the ceremony and jump straight into implementing what we
    need—a comparison function that we plug into `sort`. No more classes, no more
    operators—a strategy is just a function.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see how this works in a more complex context. We will use the problem
    from the Wikipedia page on the *Strategy pattern*, [https://en.wikipedia.org/wiki/Strategy_pattern](https://en.wikipedia.org/wiki/Strategy_pattern),
    and write it using a functional approach.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the problem: we need to write a billing system for a pub that can apply
    a discount for the happy hour. The problem lends itself to the usage of the strategy
    pattern since we have two strategies for computing the final price of the bill—one
    that returns the full price, while the second returns a happy hour discount on
    the full bill (we''ll use 50% in our case). Once again, the solution is to simply
    use two functions for the two strategies—the `normalBilling` function that just
    returns the full price it receives and the `happyHourBilling` function that returns
    half the value it receives. Let''s see this in action in the following code (resulting
    from my **test-driven development** (**TDD**) approach):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: I think this shows that the simplest implementation for a strategy is a function.
    I personally enjoy the simplicity this model brings to the strategy pattern; it's
    liberating to write minimal useful code that makes things work.
  prefs: []
  type: TYPE_NORMAL
- en: The command pattern, functional style
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The command pattern is one that I've used extensively in my work. It fits perfectly
    with MVC web frameworks, allowing the separation of the controller into multiple
    pieces of functionality, and at the same time allows separation from the storage
    format. Its intent is to separate a request from the action—that's what makes
    it so versatile, since any call can be seen as a request.
  prefs: []
  type: TYPE_NORMAL
- en: A simple example of usage for the command pattern is in games that support multiple
    controllers and changing the keyboard shortcuts. These games can't afford to link
    the *W* key press event directly to the code that moves your character up; instead,
    you bind the *W* key to a `MoveUpCommand`, thus neatly decoupling the two. We
    can easily change the controller event associated with the command or the code
    for moving up, without interference between the two.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we look at how commands are implemented in object-oriented code, the functional
    solution becomes equally obvious. A `MoveUpCommand` class would look like the
    following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'I said it was obvious! What we''re actually trying to accomplish is easily
    done with a named function, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The simplest command pattern is a function. Who would have thought it?
  prefs: []
  type: TYPE_NORMAL
- en: Dependency injection with functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can't talk about widely spread design patterns without touching on DI. While
    not defined in the Gang of Four book, the pattern has become so common in modern
    code that many programmers know it as being part of a framework or library rather
    than as the design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'The intent of the DI pattern is to separate the creation of dependencies for
    a class or function from their behavior. To understand the problem it solves,
    let''s look at this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'This is pretty fair code to write if all you need to do is add together two
    numbers read from a file. Unfortunately, in the real world, our clients will most
    likely require more sources for reading the numbers, such as, a console, as shown
    in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Before moving on, please note that the test for this function will pass only
    if you introduce from the console 2 numbers whose sum is `30`. Because they require
    input at every run, the test case is commented in our code sample; please feel
    free to enable it and play around with it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The two functions look very similar. To solve such similarities, DI can help
    as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can implement readers that use files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also implement readers who use the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'As usual, we can test that they work correctly in various combinations, as
    shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: We are injecting the code that reads the numbers through a lambda. Please note
    in the test code that using this method allows us to mix and match the dependencies
    as we see fit—the last check reads the first number from a file, while the second
    is read from the console.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, the way we usually implement DI in object-oriented languages uses
    interfaces and classes. However, as we can see, the simplest way to implement
    DI is with a function.
  prefs: []
  type: TYPE_NORMAL
- en: Purely functional design patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we've seen how some of the classic object-oriented design patterns can
    be turned into a functional variant. But can we imagine design patterns that stem
    from functional programming?
  prefs: []
  type: TYPE_NORMAL
- en: Well, we've actually already used some of them. `map`/`reduce` (or `transform`/`accumulate`
    in STL) is one example. Most of the higher-order functions (such as `filter`,
    `all_of`, and `any_of`,  among others) are also examples of patterns. However,
    we can go even further and explore a common, but opaque, design pattern that comes
    from functional programming.
  prefs: []
  type: TYPE_NORMAL
- en: The best way to understand it is by starting from specific problems. First,
    we'll see how we can maintain state in an immutable context. Then, we'll learn
    about the design pattern. Finally, we'll see it in action in another context.
  prefs: []
  type: TYPE_NORMAL
- en: Maintaining state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How can we maintain state in functional programming? This may seem like a strange
    question, given that one of the ideas behind functional programming is immutability,
    which, in turn, seems to prevent state change.
  prefs: []
  type: TYPE_NORMAL
- en: However, this limitation is an illusion. To understand it, let's think for a
    moment about how time passes. If I put on a hat, I change my state from hat off
    to hat on. If I could look back in time second by second from the moment I reached
    for the hat until I had it on, I would be able to see how my movement advanced
    each second toward this goal. But I can't change anything from any past second.
    The past is immutable, whether we like it or not (after all, maybe I look silly
    with the hat, but I can't revert it). So nature makes time work in such a way
    that the past is immutable, yet we can change state.
  prefs: []
  type: TYPE_NORMAL
- en: 'How can we model this conceptually? Well, think about it this way—first, we
    have an initial state, Alex with hat off, and a definition of a movement with
    the intent to reach the hat and put it on. In programming terms, we model the
    movement with a function. The function receives the position of the hand and the
    function itself, and returns the new position of the hand plus the function. Therefore,
    by copying nature, we end up with the sequence of states in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: By applying `MovementFunction` repeatedly, we end up with a sequence of states. *Each
    of the states is immutable, yet we can store the state*.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's see a simple example in C++. The simplest example we can use is an
    autoincrement index. The index needs to remember the last value used and use an
    `increment` function to return the next value from the index. Normally, we would
    be in trouble when trying to implement this using immutable code, but can we do
    it with the method described previously?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s find out. First, we need to initialize the auto-increment index with
    the first value—let''s say it''s `1`. As usual, I''d like to check that the value
    is initialized to what I expect, as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Note that, since the `autoIncrementIndex` does not change, we can make it `const`.
  prefs: []
  type: TYPE_NORMAL
- en: 'How do we implement `initAutoIncrement`? As we said, we need to initialize
    a structure that holds both the current value (`1` in this case) and the increment
    function. I will start with a pair like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'As for the previous `value` function, it just returns the value from the pair;
    it is the first element from the pair, as shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s compute now the next element from our autoincrement index. We initialize
    it, then compute the next value, and check that the next value is `2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Once again, please note that both `autoIncrementIndex` variables are `const` because
    they never mutate. We have the value function already, but what does the `computeNextAutoIncrement`
    function look like? Well, it has to take the current value and the function from
    the pair, apply the function to the current value, and return a pair between the
    new value and the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re using a utility function, `lambda`, that returns the lambda from the
    pair:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Does this really work? Let''s test the next value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: All the tests pass, showing that we have just stored the state in an immutable
    way!
  prefs: []
  type: TYPE_NORMAL
- en: Since this solution seems very simple, the next question is—can we generalize
    it? Let's try.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s replace `pair` with `struct`. The struct needs to have a value
    and function that will compute the next value as data members. This will remove
    the need for our `value()` and `lambda()` functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The `int` type repeats itself, but why should it? A state can be more complex
    than just `int`, so let''s turn our `struct` into a template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'With this, we can initialize an autoincrement index and check the initial value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, we need a function that computes the next `State`. The function needs
    to return a `State<ValueType>`, so it''s best to encapsulate it into the `State`
    struct. Also, it can use the current value, so there is no need to pass a value
    into it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'With this implementation, we can now check the next two values of our autoincrement
    index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The tests pass, so the code works! Now let's play with it some more.
  prefs: []
  type: TYPE_NORMAL
- en: Let's imagine we are implementing a simple Tic-Tac-Toe game. We'd like to use
    the same pattern to compute the next state of the board after a move.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need a structure that can hold a TicTacToe board. For simplicity,
    I will use `vector<vector<Token>>`, where `Token` is an `enum` that can hold the `Blank`,
    `X`, or `O` values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we need a `Move` structure. The `Move` structure needs to contain the
    board coordinates of the move and the token used to make the move:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need a function that can take a `TicTacToeBoard`, apply a move, and
    return the new board. For simplicity, I will implement it with local mutation,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need an empty board to initialize our `State`. Let''s just fill it
    with `Token::Blank` by hand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'We''d like to make the first move. However, our `makeMove` function doesn''t
    have the signature allowed by the `State` structure; it takes an additional parameter, `Move`.
    For a first test, we can just bind the `Move` parameter to a hardcoded value.
    Let''s say that `X` moves to the upper left corner, coordinates *(0,0)*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, our `State` structure works fine in this case. However, it
    has a limitation: it will only allow one move. The problem is that the function
    that computes the next stage cannot change. But what if we passed it as a parameter
    to the `nextState()` function instead? We end up with a new structure; let''s
    call it `StateEvolved`. It holds a value and a `nextState()` function that takes
    the function that computes the next state, applies it, and returns the next `StateEvolved`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now make a move by passing into `nextState` the `makeMove` function
    with the `Move` parameter bound to the actual move:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now make a second move. Let''s say `O` moves in the center to coordinates
    *(1, 1)*. Let''s check the before-and-after state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, using this pattern we can store any state in an immutable way.
  prefs: []
  type: TYPE_NORMAL
- en: The reveal
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The design pattern we discussed previously seems very useful for functional
    programming, but you may have realized that I've avoided naming it.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, the pattern we have discussed so far is one example of a monad, specifically
    a `State` monad. I've avoided telling you its name until now because monads are
    a particularly opaque topic in software development. For this book, I have watched
    hours of videos on monads; I have also read blog posts and articles, and for some
    reason none of them was understandable. Since a monad is a mathematical object
    from category theory, some of the resources I mentioned take the mathematical
    approach and explain them using definitions and operators. Other resources try
    to explain by example, but they are written in programming languages with native
    support for the monad pattern. None of them fit our goals for this book—a practical
    approach to complex concepts.
  prefs: []
  type: TYPE_NORMAL
- en: To understand monads better, we need to look at more examples. The easiest one
    is probably the `Maybe` monad.
  prefs: []
  type: TYPE_NORMAL
- en: Maybe
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Consider trying to compute an expression such as the following in C++:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'What is likely to happen? Usually, an exception will be thrown since we are
    attempting to divide by `0`. But, there are situations in which we''d like to
    see a value such as `None` or `NaN`, or some kind of message. We''ve seen that
    we can use `optional<int>` to store data that may be an integer or a value; we
    could, therefore, implement a divide function that returns an `optional<int>`, as
    shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'However, when we try to use the `divideEvenWith0` in an expression, we realize
    that we also need to change all the other operators. For example, we could implement
    a `plusOptional` function that returns `nullopt` when either parameter is `nullopt`, or
    the value if not, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'While it works, this requires writing more functions and a lot of duplication.
    But hey, could we write a function that takes a `function<int(int, int)>` and
    turns it into a `function<optional<int>(optional<int>, optional<int>)>`? Sure,
    let''s write the function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'This works fine, as shown in the following passing tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'However, this doesn''t solve one problem—we still need to return `nullopt`
    when dividing by `0`. So, the following test will fail as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'We can solve this problem by using our own `divideEvenBy0` method instead of
    the standard divide:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, the test passes, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Moreover, the display after running the tests looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: I have to say, there's something weirdly satisfying about escaping the tyranny
    of dividing by `0` and getting a result instead. Maybe that's just me.
  prefs: []
  type: TYPE_NORMAL
- en: 'Anyway, this leads us to the definition of the `Maybe` monad. It stores a value
    and a function called `apply`. The `apply` function takes an operation (`plus<int>()`,
    `minus<int>()`, `divideEvenWith0`, or `multiplies<int>()`), and a second value
    to which we apply the operation, and returns the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use the `Maybe` monad to make computations as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Once again, we can compute expressions, even with `nullopt`.
  prefs: []
  type: TYPE_NORMAL
- en: So what is a monad?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **monad** is a functional design pattern that models computations. It comes
    from mathematics; more precisely, from the domain called **category theory**.
  prefs: []
  type: TYPE_NORMAL
- en: What is computation? A basic computation is a function; however, we are interested
    in adding more behaviors to the functions. We've seen two examples of maintaining
    state and allowing operations with an optional type, but monads are quite widespread
    in software design.
  prefs: []
  type: TYPE_NORMAL
- en: 'A monad basically has a value and a higher-order function. To understand what
    they do, let''s compare the `State` monad shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'With the `Maybe` monad shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: They both hold a value. The value is encapsulated in the monad structure. They
    both hold a function that makes computation on that value. The `apply`/`nextState`
    (called `bind` in the literature) functions receive a function themselves that
    encapsulates the computation; however, the monad does something in addition to
    the computation.
  prefs: []
  type: TYPE_NORMAL
- en: There's more to the monads than just these simple examples. However, they show
    how to encapsulate certain computations and how to remove certain types of duplication.
  prefs: []
  type: TYPE_NORMAL
- en: It's worth noting that the `optional<>` type from C++ is actually inspired from
    the `Maybe` monad, as well as the promises, so you're probably already using monads
    in your code that are waiting to be discovered.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've learned a lot of things in this chapter, all around improving design.
    We learned that refactoring means restructuring the code without changing the
    external behavior of a program. We saw that to ensure the preservation of behavior,
    we need to make very small steps and tests. We learned that legacy code is code
    that we're afraid to change, and in order to write tests for it, we need to change
    the code first, which leads to a dilemma. We've also learned that, fortunately,
    we can make some small changes in the code that are guaranteed to preserve behavior,
    but that break dependencies and thus allow us to plug into the code with tests.
    We saw then that we can use pure functions to identify and break the dependencies,
    leading to lambdas that we can regroup into classes based on cohesiveness.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we learned that we can use design patterns with functional programming,
    and we saw a few examples. Even if you don't use anything else from functional
    programming, using functions such as strategy, command, or injected dependencies
    will make your code easier to change with minimal fuss. We touched on a strikingly
    abstract design pattern, the monad, and we saw how to use the `Maybe` monad and
    the `State` monad. Both can help a lot in our quest to write less code with richer
    functionality.
  prefs: []
  type: TYPE_NORMAL
- en: We've discussed quite a lot about software design. But does functional programming
    apply to architecture? That's what we'll visit in the next chapter—event sourcing.
  prefs: []
  type: TYPE_NORMAL
