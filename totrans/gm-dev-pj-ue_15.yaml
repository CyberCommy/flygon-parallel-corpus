- en: 16\. Multiplayer Basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will be introduced to some important multiplayer concepts
    in order to add multiplayer support to your game using Unreal Engine 4's network
    framework.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you'll know basic multiplayer concepts such as the
    server-client architecture, connections, and actor ownership, along with roles
    and variable replication. You'll be able to implement these concepts to create
    a multiplayer game of your own. You'll also be able to make a 2D Blend Space,
    which allows you to blend between animations laid out in a 2D grid. Finally, you'll
    learn how to use `Transform (Modify) Bone` nodes to control Skeletal Mesh bones
    at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we completed the `SuperSideScroller` game and used
    1D Blend Spaces, animation blueprints, and animation montages. In this chapter,
    we're going to build on that knowledge and learn how to add multiplayer functionality
    to a game using Unreal Engine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Multiplayer games have grown quite a lot in the last decade. Games such as
    Fortnite, PUBG, League of Legends, Rocket League, Overwatch, and CS: GO have gained
    a lot of popularity in the gaming community and have had great success. Nowadays,
    almost all games need to have some kind of multiplayer experience in order to
    be more relevant and successful.'
  prefs: []
  type: TYPE_NORMAL
- en: The reason for that is it adds a new layer of possibilities on top of the existing
    gameplay, such as being able to play with friends in cooperative mode (*also known
    as co-op mode*) or against people from all around the world, which greatly increases
    the longevity and value of a game.
  prefs: []
  type: TYPE_NORMAL
- en: In the next topic, we will be discussing the basics of multiplayer.
  prefs: []
  type: TYPE_NORMAL
- en: Multiplayer Basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may have heard the term multiplayer a lot while gaming, but what does it
    mean for game developers? Multiplayer, in reality, is just a set of instructions
    sent through the network (*internet or local area network*) between the server
    and its connected clients in order to give players the illusion of a shared world.
  prefs: []
  type: TYPE_NORMAL
- en: For this to work, the server needs to be able to talk to clients, but also the
    other way around (client to server). This is because clients are typically the
    ones that affect the game world, so they need a way to be able to inform the server
    of their intentions while playing the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of this back and forth communication between the server and a client
    is when a player tries to fire a weapon during a game. Have a look at the following
    figure, which shows a client-server interaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.1: Client-server interaction when a player wants to fire'
  prefs: []
  type: TYPE_NORMAL
- en: a weapon in a multiplayer game](img/B16183_16_01.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 16.1: Client-server interaction when a player wants to fire a weapon
    in a multiplayer game'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s examine what was shown in *Figure 16.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: The player holds the *left mouse button* down and the client of that player
    tells the server that it wants to fire a weapon.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The server validates whether the player can fire the weapon by checking the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the player is alive
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the player has a weapon equipped
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the player has enough ammo
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If all of the validations are valid, then the server will do the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the logic to deduct ammo
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spawn the projectile actor on the server, which is automatically sent to all
    of the clients
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Play the fire animation on the character instance in all of the clients to ensure
    certain synchronicity between all of them, which helps to sell the idea that it's
    the same world, even though it's not
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If any of the validations fail, then the server tells the specific client what
    to do:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Player is dead – don't do anything
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Player doesn't have a weapon equipped – don't do anything
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Player doesn't have enough ammo – play an empty click sound
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remember, if you want your game to support multiplayer, then it's highly recommended
    that you do that as soon as possible in your development cycle. If you try to
    run a single-player project with multiplayer enabled, you'll notice that some
    functionalities might *just work*, but probably most of them won't be working
    properly or as expected.
  prefs: []
  type: TYPE_NORMAL
- en: The reason for that is when you execute the game in single-player, the code
    runs locally and instantly, but when you add multiplayer into the equation, you
    are adding external factors such as an authoritative server that talks to clients
    on a network with latency, as you saw in *Figure 16.1*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to get everything working properly, you need to break apart the existing
    code into the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Code that only runs on the server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code that only runs on the client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code that runs on both, which can take a lot of time depending on the complexity
    of your single-player game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In order to add multiplayer support to games, Unreal Engine 4 comes with a very
    powerful and bandwidth-efficient network framework already built in, using an
    authoritative server-client architecture.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a diagram of how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.2: Server-client architecture in Unreal Engine 4'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_16_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 16.2: Server-client architecture in Unreal Engine 4'
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 16.2*, you can see how the server-client architecture works in Unreal
    Engine 4\. Each player controls a client that communicates with the server using
    a **two-way connection**. The server runs a specific level with a game mode (*which
    only exists in the server*) and controls the flow of information so that the clients
    can see and interact with each other in the game world.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Multiplayer can be a very advanced topic, so these next few chapters will serve
    as an introduction to help you understand the essentials, but it will not be an
    in-depth look. For that reason, some concepts might be omitted for simplicity's
    sake.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will be looking at servers.
  prefs: []
  type: TYPE_NORMAL
- en: Servers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The server is the most critical part of the architecture since it's responsible
    for handling most of the work and making important decisions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an overview of the main responsibilities of a server:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating and managing the shared world instance**: The server runs its own
    instance of the game in a specific level and game mode (*this will be covered
    in the chapters ahead*) and that will serve as the shared world between all of
    the connected clients. The level being used can be changed at any point in time
    and, if applicable, the server can bring along all of the connected clients with
    it automatically.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`PostLogin` function in the game mode is called. From that point on, the client
    will enter the game and is part of the shared world where the player will be able
    to see and interact with other clients. If a client disconnects at any point in
    time, then all of the other clients will be notified and the `Logout` function
    in the game mode will be called.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Spawning the actors that all of the clients need to know about**: If you
    want to spawn an actor that exists in all of the clients, then you need to do
    that on the server. The reason for this is the server has the authority and is
    the only one that can tell each client to create its own instance of that actor.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is the most common way of spawning actors in multiplayer, since most actors
    need to exist in all of the clients. An example of this would be with a power-up,
    which is something that all clients can see and interact with.
  prefs: []
  type: TYPE_NORMAL
- en: '**Running critical gameplay logic**: In order to make sure that the game is
    fair to all of the clients, the critical gameplay logic needs to be executed only
    on the server. If clients were responsible for handling the deduction of health,
    it would be very exploitable, because a player could use a tool to change in memory
    the current value of health to 100% all the time, so the player would never die
    in the game.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Handling variable replication**: If you have a replicated variable (*covered
    in this chapter*), then its value should only be changed on the server. This will
    ensure that all of the clients will have the value updated automatically. You
    can still change the value on the client, but it will always be replaced with
    the latest value from the server, in order to prevent cheating and to make sure
    all of the clients are in sync.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Handling RPCs from the client**: The server needs to process the remote procedure
    calls (*Chapter 17*, *Remote Procedure Calls*) sent from the clients.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that you know what a server does, we can talk about the two different ways
    of creating a server in Unreal Engine 4.
  prefs: []
  type: TYPE_NORMAL
- en: Dedicated Server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The dedicated server only runs the server logic, so you won't see the typical
    window with the game running where you control a character as a local player.
    Additionally, if you run the dedicated server with the `-log` command prompt,
    you'll have a console window that logs relevant information about what is happening
    on the server, such as if a client has connected or disconnected, and so on. You,
    as a developer, can also log your own information by using the `UE_LOG` macro.
  prefs: []
  type: TYPE_NORMAL
- en: Using dedicated servers is a very common way of creating servers for multiplayer
    games, and since it's more lightweight than a listen server (*covered in the next
    section*), you could just host it on a server stack and leave it running.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start a dedicated server in Unreal Engine 4, you can use the following command arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to start a dedicated server inside an editor through
    a shortcut or Command Prompt:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: A packaged project requires a special build of the project built specifically
    to serve as a dedicated server.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can find out more about setting up a packaged dedicated server by visiting
    [https://allarsblog.com/2015/11/06/support-dedicated-servers/](https://allarsblog.com/2015/11/06/support-dedicated-servers/)
    and [https://www.ue4community.wiki/Dedicated_Server_Guide_(Windows)](https://www.ue4community.wiki/Dedicated_Server_Guide_(Windows)).
  prefs: []
  type: TYPE_NORMAL
- en: The Listen Server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The listen server acts as a server and client at the same time, so you'll also
    have a window where you can play the game as a client with this server type. It
    also has the advantage of being the quickest way of getting a server running,
    but it's not as lightweight as a dedicated server, so the number of clients that
    can be connected at the same time will be limited.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start a listen server, you can use the following command arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to start a dedicated server inside an editor through
    a shortcut or Command Prompt:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'A packaged project (development builds only) requires a special build of the
    project built specifically to serve as a dedicated server:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will discuss clients.
  prefs: []
  type: TYPE_NORMAL
- en: Clients
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The client is the simplest part of the architecture because most of the actors
    will have the authority on the server, so in those cases, the work will be done
    on the server and the client will just obey its orders.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an overview of the main responsibilities of a client:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Enforcing variable replication from the server**: The server typically has
    authority over all of the actors that the client knows, so when the value of a
    replicated variable is changed on the server, the client needs to enforce that
    value as well.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Handling RPCs from the server**: The client needs to process the remote procedure
    calls (covered in *Chapter 17*, *Remote Procedure Calls*) sent from the server.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Predicting movement when simulating**: When a client is simulating an actor
    (*covered later in this chapter*) it needs to locally predict where it''s going
    to be based on the actor''s velocity.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Spawning the actors that only a client needs to know about**: If you want
    to spawn an actor that only exists on a client, then you need to do that on that
    specific client.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is the least common way of spawning actors since there are few instances
    when you want an actor to only exist on a client. An example of this is the placement
    preview actor you see in multiplayer survival games, where the player controls
    a semi-transparent version of a wall that other players can't see until it's actually
    placed.
  prefs: []
  type: TYPE_NORMAL
- en: 'A client can join a server in different ways. Here is a list of the most common methods:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the Unreal Engine 4 console (by default is the *`* key) to open it and
    type:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'For instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the `Execute Console Command` Blueprint node. An example is as follows:![Figure
    16.3: Joining a server with an example IP with the Execute Console Command node'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '](img/B16183_16_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 16.3: Joining a server with an example IP with the Execute Console Command
    node'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the `ConsoleCommand` function in `APlayerController` as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the editor executable through a shortcut or Command Prompt:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`C:\Program Files\Epic Games\UE_4.24\Engine\Binaries\Win64\UE4Editor.exe D:\TestProject\TestProject.uproject
    194.56.23.4 -game`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using a packaged development build through a shortcut or Command Prompt:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`D:\Packaged\TestProject\TestProject.exe 194.56.23.4`'
  prefs: []
  type: TYPE_NORMAL
- en: In the following exercise, we will test the Third Person template that comes
    with Unreal Engine 4 in multiplayer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 16.01: Testing the Third Person Template in Multiplayer'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we're going to create a Third Person template project and
    play it in multiplayer.
  prefs: []
  type: TYPE_NORMAL
- en: The following steps will help you complete the exercise.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new `Third Person` template project using `Blueprints` called `TestMultiplayer`
    and save it to a location of your choosing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once the project has been created, it should open the editor. We''ll now test
    the project in multiplayer to see how it behaves:'
  prefs: []
  type: TYPE_NORMAL
- en: In the editor, to the right of the `Play` button, you have an option with an
    arrow pointing down. Click on it and you should see a list of options. Under the
    `Multiplayer Options` section, you can configure how many clients you want to
    use and whether or not you want a dedicated server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Leave `Run Dedicated Server` unchecked, change `Number of Players` to `3`, and
    click on `New Editor Window (PIE)`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You should see three windows on top of each other representing the three clients:![Figure
    16.4: Launching three client windows with a listen server'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_16_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 16.4: Launching three client windows with a listen server'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, this is a bit cluttered, so let's change the size of the windows.
    Press *Esc* on your keyboard to stop playing.
  prefs: []
  type: TYPE_NORMAL
- en: Click once again on the downward-pointing arrow next to the `Play` button and
    pick the last option, `Advanced Settings`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Search for the `Game Viewport Settings` section. Change `New Viewport Resolution`
    to `640x480` and close the `Editor Preferences` tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Play the game again and you should see the following:![Figure 16.5: Launching
    three client windows using a 640x480 resolution with a listen server'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_16_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 16.5: Launching three client windows using a 640x480 resolution with
    a listen server'
  prefs: []
  type: TYPE_NORMAL
- en: Once you start playing, you'll notice that the title bars of the windows say
    `Server`, `Client 1`, and `Client 2`. Since you can control a character in the
    `Server` window, that means we're running a `Server + Client 0` instead of just
    `Server` to avoid confusion.
  prefs: []
  type: TYPE_NORMAL
- en: By completing this exercise, you now have a setup where you'll have one server
    and three clients running (`Client 0`, `Client 1`, and `Client 2`).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: When you have multiple windows running at the same time, you'll notice that
    you can only have input focus on one window at a time. To shift the focus to another
    window, just press *Shift* + *F1* to lose the current input focus and then just
    click on the new window you want to focus on.
  prefs: []
  type: TYPE_NORMAL
- en: If you play the game in one of the windows, you'll notice that you can move
    around and jump and the other clients will also be able to view that.
  prefs: []
  type: TYPE_NORMAL
- en: The reason why everything works is that the character movement component, which
    comes with the character class, replicates the location, rotation, and falling
    state (used to show whether you are jumping or not) for you automatically. If
    you want to add a custom behavior such as an attack animation, you can't just
    tell the client to play an animation locally when a key is pressed, because that
    will not work on the other clients. That's why you need the server, to serve as
    an intermediary and tell all the clients to play the animation when one client
    presses the key.
  prefs: []
  type: TYPE_NORMAL
- en: The Packaged Version
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once you've finished the project, it's good practice to package it (*as covered
    in the previous chapters*) so that we have a pure standalone version that doesn't
    use Unreal Engine editor, which will run faster and is more lightweight.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps will help you create the packaged version of *Exercise
    16.01*, *Testing the Third Person Template in Multiplayer file*:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to `File` -> `Package Project` -> `Windows` -> `Windows (64-bit)`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pick a folder to place the packaged build and wait for it to finish.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to the selected folder and open the `WindowsNoEditor` folder inside it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Right-click* on `TestMultiplayer.exe` and pick `Create Shortcut`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename the new shortcut `Run Server`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Right-click* on it and pick `Properties`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'On the Target, append `ThirdPersonExampleMap?Listen -server`, which creates
    a listen server using `ThirdPersonExampleMap`. You should end up with this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Click `OK` and run the shortcut.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You should get a Windows Firewall prompt, so allow it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Leave the server running and go back to the folder and create another shortcut
    from `TestMultiplayer.exe`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename it `Run Client`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Right-click* on it and pick `Properties`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the Target, append `127.0.0.1`, which is the IP of your local server. You
    should end up with `"<Path>\WindowsNoEditor\TestMultiplayer.exe" 127.0.0.1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click `OK` and run the shortcut.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You are now connected to the listen server, so you can see each other's characters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Every time you click on the `Run Client` shortcut, you'll add a new client to
    the server, so you can have a few clients running on the same machine.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the next section, we will be looking at connections and ownership.
  prefs: []
  type: TYPE_NORMAL
- en: Connections and Ownership
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When using multiplayer in Unreal Engine, an important concept to understand
    is that of a connection. When a client joins a server, it will get a new **Player
    Controller** with a connection associated with it.
  prefs: []
  type: TYPE_NORMAL
- en: If an actor doesn't have a valid connection with the server, then the actor
    won't be able to do replication operations such as variable replication (*covered
    later in this chapter*) or call RPCs (covered in *Chapter 17,* *Remote Procedure
    Calls*).
  prefs: []
  type: TYPE_NORMAL
- en: If the Player Controller is the only actor that holds a connection, then does
    that mean that it's the only place you can do replication operations? No, and
    that's where the `GetNetConnection` function, defined in `AActor`, comes into
    play.
  prefs: []
  type: TYPE_NORMAL
- en: When doing replication operations (such as variable replication or call RPCs)
    on an actor, the Unreal framework will get the actor's connection by calling the
    `GetNetConnection()` function on it. If the connection is valid, then the replication
    operation will be processed, if it's not, nothing will happen. The most common
    implementations of `GetNetConnection()` are from `APawn` and `AActor`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at how the `APawn` class implements the `GetNetConnection()`
    function, which is typically used for characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding implementation, which is part of the Unreal Engine 4 source code,
    will first check whether the pawn has a valid controller. If the controller is
    valid, then it will use its connection. If the controller is not valid, then it
    will use the parent implementation of the `GetNetConnection()` function, which
    is on `AActor`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The preceding implementation, which is also part of the Unreal Engine 4 source
    code, will check whether the actor has a valid owner. If it does, it will use
    the owner's connection; if it doesn't, it will return an invalid connection. So
    what is this `Owner` variable? Every actor has a variable called `Owner` (where
    you can set its value by calling the `SetOwner` function) that shows which actor
    *owns* it, so you can think of it as the parent actor.
  prefs: []
  type: TYPE_NORMAL
- en: Using the owner's connection in this implementation of `GetNetConnection()`
    will work like a hierarchy. If, while going up the hierarchy of owners, it finds
    an owner that is a Player Controller or is being controlled by one, then it will
    have a valid connection and will be able to process replication operations. Have
    a look at the following example.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In a listen server, the connection for the character controlled by its client
    will always be invalid, because that client is already a part of the server and
    therefore doesn't need a connection.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine a weapon actor was placed in the world and it's just sitting there.
    In that situation, the weapon won't have an owner, so if the weapon tries to do
    any replication operations, such as variable replication or calling RPCs, nothing
    will happen.
  prefs: []
  type: TYPE_NORMAL
- en: However, if a client picks up the weapon and calls `SetOwner` on the server
    with the value of the character, then the weapon will now have a valid connection.
    The reason for this is because the weapon is an actor, so in order to get its
    connection, it will use the `AActor` implementation of `GetNetConnection()`, which
    returns the connection of its owner. Since the owner is the client's character,
    it will use the implementation of `GetNetConnection()` of `APawn`. The character
    has a valid Player Controller, so that is the connection returned by the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a diagram to help you understand this logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.6: Connections and ownership example of a weapon actor'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_16_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 16.6: Connections and ownership example of a weapon actor'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s understand the elements of an invalid owner:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AWeapon` doesn''t override the `GetNetConnection` function, so to get the
    weapon''s connection, it will call the first implementation found, which is `AActor::GetNetConnection`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The implementation of `AActor::GetNetConnection` calls `GetNetConnection` on
    its owner. Since there is no owner, the connection is invalid.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A valid owner will consist of the following elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AWeapon` doesn''t override the `GetNetConnection` function, so to get its
    connection, it will call the first implementation found, which is `AActor::GetNetConnection`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The implementation of `AActor::GetNetConnection` calls `GetNetConnection` on
    its owner. Since the owner is the character that picked up the weapon, it will
    call `GetNetConnection` on it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ACharacter` doesn''t override the `GetNetConnection` function, so to get its
    connection, it will call the first implementation found, which is `APawn::GetNetConnection`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The implementation of `APawn::GetNetConnection` uses the connection from the
    owning player controller. Since the owning player controller is valid, then it
    will use that connection for the weapon.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In order for `SetOwner` to work as intended, it needs to be executed on the
    authority which, in most cases, means the server. If you only execute `SetOwner`
    on the client, it still won't be able to execute replication operations.
  prefs: []
  type: TYPE_NORMAL
- en: Roles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you spawn an actor on the server, there will be a version of the actor
    created on the server and one on each client. Since there are different versions
    of the same actor on different instances of the game (`Server`, `Client 1`, `Client
    2`, and so on), it is important to know which version of the actor is which. This
    will allow us to know what logic can be executed in each of these instances.
  prefs: []
  type: TYPE_NORMAL
- en: 'To help with this situation, every actor has the following two variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GetLocalRole()` function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GetRemoteRole()` function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The return type of the `GetLocalRole()` and `GetRemoteRole()` functions is
    `ENetRole`, which is an enumeration that can have the following possible values:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ROLE_None`: The actor doesn''t have a role because it''s not being replicated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ROLE_SimulatedProxy`: The current game instance doesn''t have authority over
    the actor and it''s not controlling it through a Player Controller. That means
    that its movement will be simulated/predicted by using the last value of the actor''s
    velocity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ROLE_AutonomousProxy`: The current game instance doesn''t have authority over
    the actor, but it''s being controlled by a Player Controller. That means that
    we can send to the server more accurate movement information, based on the player''s
    inputs, instead of just using the last value of the actor''s velocity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ROLE_Authority`: The current game instance has complete authority over the
    actor. That means that if the actor is on the server, the changes made to the
    replicated variables of the actor will be treated as the value that every client
    needs to have enforced through variable replication.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s have a look at the following example code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code snippet will store the values of the local role and remote
    role to `MyLocalRole` and `MyRemoteRole` respectively. After that, it will print
    different messages on the screen depending on whether that version of the actor
    is the authority or whether it's being controlled by a player on its client.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: It is important to understand that if an actor has a local role of `ROLE_Authority`,
    it doesn't mean that it's on the server; it means that it's on the game instance
    that originally spawned the actor and therefore has authority over it.
  prefs: []
  type: TYPE_NORMAL
- en: If a client spawns an actor, even though the server and the other clients won't
    know about it, its local role will still be `ROLE_Authority`. Most of the actors
    in a multiplayer game will be spawned by the server; that's why it's easy to misunderstand
    that the authority is always referring to the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a table to help you understand the roles that an actor will have in
    different scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.7: Roles that an actor can have in different scenarios'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_16_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 16.7: Roles that an actor can have in different scenarios'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding table, you can see the roles that an actor will have in different scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s analyze each scenario and explain why the actor has that role:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Actor Spawned on the Server**'
  prefs: []
  type: TYPE_NORMAL
- en: The actor spawns on the server, so the server's version of that actor will have
    the local role of `ROLE_Authority` and the remote role of `ROLE_SimulatedProxy`,
    which is the local role of the client's version of the actor. For the client's
    version of that actor, its local role will be `ROLE_SimulatedProxy` and the remote
    role will be `ROLE_Authority`, which is the local role of the server's actor version.
  prefs: []
  type: TYPE_NORMAL
- en: '**Actor Spawned on the Client**'
  prefs: []
  type: TYPE_NORMAL
- en: The actor was spawned on the client, so the client's version of that actor will
    have the local role of `ROLE_Authority` and the remote role of `ROLE_SimulatedProxy`.
    Since the actor wasn't spawned on the server, then it will only exist on the client
    that spawned it, so there won't be versions of this actor on the server and the
    other clients.
  prefs: []
  type: TYPE_NORMAL
- en: '**Player-Owned Pawn Spawned on the Server**'
  prefs: []
  type: TYPE_NORMAL
- en: The pawn was spawned on the server, so the server's version of that pawn will
    have the local role of `ROLE_Authority` and the remote role of `ROLE_AutonomousProxy`,
    which is the local role of the client's version of the pawn. For the client's
    version of that pawn, its local role will be `ROLE_AutonomousProxy`, because it's
    being controlled by `PlayerController`, and the remote role `ROLE_Authority`,
    which is the local role of the server's pawn version.
  prefs: []
  type: TYPE_NORMAL
- en: '**Player-Owned Pawn Spawned on the Client**'
  prefs: []
  type: TYPE_NORMAL
- en: The pawn was spawned on the client, so the client's version of that pawn will
    have the local role of `ROLE_Authority` and the remote role of `ROLE_SimulatedProxy`.
    Since the pawn wasn't spawned on the server, then it will only exist on the client
    that spawned it, so there won't be versions of this pawn on the server and the
    other clients.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 16.02: Implementing Ownership and Roles'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we're going to create a C++ project that uses the Third Person
    template as a base.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new actor called `OwnershipTestActor` that has a static mesh component
    as the root component, and on every tick, it''ll do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: On the authority, it will check which character is closest to it within a certain
    radius (configured by the `EditAnywhere` variable called `OwnershipRadius`) and
    will set that character as its owner. When no character is within the radius,
    then the owner will be `nullptr`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Display its local role, remote role, owner, and connection.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Edit `OwnershipRolesCharacter` and override the `Tick` function so that it displays
    its local role, remote role, owner, and connection.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a new header file called `OwnershipRoles.h` that contains the `ROLE_TO_String`
    macro, which converts `ENetRole` into an `Fstring` variable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following steps will help you complete the exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new `Third Person` template project using `C++` called `OwnershipRoles`
    and save it to a location of your choosing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the project has been created, it should open the editor as well as the
    Visual Studio solution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the editor, create a new C++ class called `OwnershipTestActor` that derives
    from `Actor`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once it finishes compiling, Visual Studio should pop up with the newly created
    `.h` and `.cpp` files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Close the editor and go back to Visual Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In Visual Studio, open the `OwnershipRoles.h` file and add the following macro:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This macro will convert the `ENetRole` enumeration that we get from the `GetLocalRole()`
    function and `GetRemoteRole()` into an `FString`. The way it works is by finding
    the `ENetRole` enumeration type through Unreal Engine's reflection system and
    from that, it converts the `Value` parameter into an `FString` variable so it
    can be printed on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Now, open the `OwnershipTestActor.h` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Declare the protected variables for the static mesh component and the ownership
    radius as shown in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, we declare the static mesh component and the
    `OwnershipRadius` variable, which allows you to configure the radius of the ownership.
  prefs: []
  type: TYPE_NORMAL
- en: Next, delete the declaration of `BeginPlay` and move the constructor and the
    `Tick` function declarations to the protected area.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, open the `OwnershipTestActor.cpp` file and add the required header files
    as mentioned in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, we include `DrawDebugHelpers.h` because we'll
    call the `DrawDebugSphere` and `DrawDebugString` functions. We include `OwnershipRoles.h`,
    `OwnershipRolesCharacter.h` and `StaticMeshComponent.h` so that the `.cpp` file
    knows about those classes. We finally include `GameplayStatics.h` because we'll
    call the `GetAllActorsOfClass` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the constructor definition, create the static mesh component and set it
    as the root component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Still in the constructor, set `bReplicates` to `true` to tell Unreal Engine
    that this actor replicates and should also exist in all of the clients:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Delete the `BeginPlay` function definition.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `Tick` function, draw a debug sphere to help visualize the ownership
    radius, as shown in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Still in the `Tick` function, create the authority specific logic that will
    get the closest `AOwnershipRolesCharacter` within the ownership radius, and if
    it''s different from the current one, then set it as the owner:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Still in the `Tick` function, convert the values for the local/remote roles
    (using the `ROLE_TO_STRING` macro we created earlier), the current owner, and
    the connection to the strings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'To finalize the `Tick` function, use `DrawDebugString` to display onscreen
    the strings we converted in the previous step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Instead of constantly using `GetLocalRole() == ROLE_Authority` to check whether
    the actor has authority, you can use the `HasAuthority()` helper function, defined
    in `AActor`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, open `OwnershipRolesCharacter.h` and declare the `Tick` function as protected:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, open `OwnershipRolesCharacter.cpp` and include the header files as shown
    in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `Tick` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Convert the values for the local/remote roles (using the `ROLE_TO_STRING` macro
    we created earlier), the current owner, and the connection to strings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Use `DrawDebugString` to display onscreen the strings we converted in the previous
    step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we can test the project.
  prefs: []
  type: TYPE_NORMAL
- en: Run the code and wait for the editor to fully load.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Blueprint called `OwnershipTestActor_BP` in the `Content` folder
    that derives from `OwnershipTestActor`. Set `Mesh` to use a cube mesh, and drop
    an instance of it in the world.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to `Multiplayer Options` and set the number of clients to `2`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the window size to `800x600`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Play using `New Editor Window (PIE)`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You should get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.8: Expected result on the server and Client 1 window'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_16_08.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 16.8: Expected result on the server and Client 1 window'
  prefs: []
  type: TYPE_NORMAL
- en: By completing this exercise, you'll have a better understanding of how connections
    and ownership works. These are important concepts to know as everything related
    to replication is dependent on them.
  prefs: []
  type: TYPE_NORMAL
- en: Next time you see that an actor is not doing replication operations, you'll
    know that you need to check first whether it has a **valid connection** and an
    **owner**.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's analyze the displayed values in the server and client windows.
  prefs: []
  type: TYPE_NORMAL
- en: The Server Window
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Have a look at the following output screenshot of the `Server` window from
    the previous exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.9: The Server window'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_16_09.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 16.9: The Server window'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The text that says `Server Character`, `Client 1 Character`, and `Ownership
    Test Actor` is not part of the original screenshot and was added to help you understand
    which character and actor is which.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding screenshot, you can see `Server Character`, `Client 1 Character`,
    and the `Ownership Test` cube actor.
  prefs: []
  type: TYPE_NORMAL
- en: Let's first analyze the values for `Server Character`.
  prefs: []
  type: TYPE_NORMAL
- en: Server Character
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is the character that the listen server is controlling. The values associated
    with this character are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`LocalRole = ROLE_Authority`: because this character was spawned on the server,
    which is the current game instance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RemoteRole = ROLE_SimulatedProxy`: because this character was spawned on the
    server, so the other clients should only simulate it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Owner = PlayerController_0`: because this character is being controlled by
    the client of the listen server, which uses the first `PlayerController` instance
    called `PlayerController_0`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Connection = Invalid Connection`: because we''re the client of the listen
    server, so there is no need for a connection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we are going to be looking at `Client 1 Character` in the same window.
  prefs: []
  type: TYPE_NORMAL
- en: Client 1 Character
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is the character that `Client 1` is controlling. The values associated
    with this character are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`LocalRole = ROLE_Authority`: because this character was spawned on the server,
    which is the current game instance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RemoteRole = ROLE_AutonomousProxy`: because this character was spawned on
    the server, but it''s being controlled by another client.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Owner = PlayerController_1`: because this character is being controlled by
    another client, which uses the second `PlayerController` instance called `PlayerController_1`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Connection = Valid Connection`: because this character is being controlled
    by another client, so a connection to the server is required.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we are going to be looking at the `OwnershipTest` actor in the same window.
  prefs: []
  type: TYPE_NORMAL
- en: The OwnershipTest Actor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is the cube actor that will set its owner to the closest character within
    a certain ownership radius. The values associated with this actor are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`LocalRole = ROLE_Authority`: because this actor was placed in the level and
    spawned on the server, which is the current game instance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RemoteRole = ROLE_SimulatedProxy`: because this actor was spawned in the server,
    but it''s not being controlled by any client.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Owner` and `Connection` will have their values based on the closest character.
    If there isn''t a character inside the ownership radius, then they will have the
    values of `No Owner` and `Invalid Connection`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let''s have a look at the `Client 1` window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.10: The Client 1 window'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_16_10.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 16.10: The Client 1 window'
  prefs: []
  type: TYPE_NORMAL
- en: The Client 1 Window
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The values for the `Client 1` window will be exactly the same as the `Server`
    window, except the values of `LocalRole` and `RemoteRole` will be reversed because
    they are always relative to the game instance that you are in.
  prefs: []
  type: TYPE_NORMAL
- en: Another exception is that the server character has no owner and the other connected
    clients won't have a valid connection. The reason for that is clients don't store
    player controllers and connections of other clients, only the server does, but
    this will be covered in more depth in *Chapter 18*, *Gameplay Framework Classes
    in Multiplayer*.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will be looking at variable replication.
  prefs: []
  type: TYPE_NORMAL
- en: Variable Replication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the ways the server can keep the clients synchronized is by using variable
    replication. The way it works is that every specific number of times per second
    (defined per actor in the `AActor::NetUpdateFrequency` variable, which is also
    exposed to blueprints) the variable replication system in the server will check
    whether there are any replicated variables (*explained in the next section*) in
    the client that needs to be updated with the latest value.
  prefs: []
  type: TYPE_NORMAL
- en: If the variable meets all of the replication conditions, then the server will
    send an update to the client and enforce the new value.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if you have a replicated `Health` variable and the client on its
    end uses a hacking tool to set the value of the variable from `10` to `100`, then
    the replication system will enforce the real value from the server and change
    it back to `10`, which nullifies the hack.
  prefs: []
  type: TYPE_NORMAL
- en: 'Variables are only sent to the client to be updated if:'
  prefs: []
  type: TYPE_NORMAL
- en: The variable is set to replicate.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The value was changed on the server.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The value on the client is different than on the server.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The actor has replication enabled.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The actor is relevant and meets all of the replication conditions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One important thing to take into consideration is that the logic that determines
    whether a variable should be replicated or not is only executed `AActor::NetUpdateFrequency`
    times a second. In other words, the server doesn't send an update request to a
    client immediately after you change the value of a variable on the server. It
    will only send that request when the variable replication system executes, which
    is `AActor::NetUpdateFrequency` times a second, and it has determined that the
    values from the client are different than the values from the server.
  prefs: []
  type: TYPE_NORMAL
- en: An example would be if you had an integer replicate a variable called `Test`
    that has a default value of `5`. If you call a function on the server that sets
    `Test` to `3` and in the next line changes it to `8`, then only the latter change
    would send an update request to the clients. The reason for this is these two
    changes were made in between the `NetUpdateFrequency` interval, so when the variable
    replication system executes, the current value is `8`, and as that is different
    to the value of the clients (which is still `5`), it will update them. If instead
    of setting it to `8`, you set it back to `5`, then no changes would be sent to
    the clients.
  prefs: []
  type: TYPE_NORMAL
- en: Replicated Variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Unreal Engine, any variable that can use the `UPROPERTY` macro can be set
    to replicate, and you can use two specifiers to do that.
  prefs: []
  type: TYPE_NORMAL
- en: '**Replicated**'
  prefs: []
  type: TYPE_NORMAL
- en: If you just want to say that a variable is replicated, then you use the `Replicated` specifier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Have a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, we declare a float variable called `Health`,
    as we normally do. The difference is that we've added `UPROPERTY(Replicated)`
    to tell Unreal Engine that the `Health` variable will be replicated.
  prefs: []
  type: TYPE_NORMAL
- en: '**RepNotify**'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to say that a variable is replicated and calls a function every
    time it''s updated, then you use the `ReplicatedUsing=<Function Name>` specifier.
    Have a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, we declare a float variable called `Health`.
    The difference is that we've added `UPROPERTY(ReplicatedUsing=OnRep_Health)` to
    tell Unreal Engine that this variable will be replicated and every time it's updated
    it will call the `OnRep_Health` function, which, in this specific case, will call
    a function to update `HUD`.
  prefs: []
  type: TYPE_NORMAL
- en: Typically, the naming scheme for the callback function is `OnRepNotify_<Variable
    Name>` or `OnRep_<Variable Name>`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The function used in the `ReplicatingUsing` specifier needs to be marked as
    `UFUNCTION()`.
  prefs: []
  type: TYPE_NORMAL
- en: '**GetLifetimeReplicatedProps**'
  prefs: []
  type: TYPE_NORMAL
- en: Besides marking the variable as replicated, you'll also need to implement the
    `GetLifetimeReplicatedProps` function in the actor's `cpp` file. One thing to
    take into consideration is that this function is declared internally once you
    have at least one replicated variable, so you shouldn't declare it in the actor's
    header file. The purpose of this function is for you to tell how each replicated
    variable should replicate. You do this by using the `DOREPLIFETIME` macro and
    its variants on every variable that you want to replicate.
  prefs: []
  type: TYPE_NORMAL
- en: '**DOREPLIFETIME**'
  prefs: []
  type: TYPE_NORMAL
- en: This macro tells the replication system that the replicated variable (entered
    as an argument) will replicate to all clients without a replication condition.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s its syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Have a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, we use the `DOREPLIFETIME` macro to tell the
    replication system that the `Health` variable in the `AVariableReplicationActor`
    class will replicate without an extra condition.
  prefs: []
  type: TYPE_NORMAL
- en: '**DOREPLIFETIME_CONDITION**'
  prefs: []
  type: TYPE_NORMAL
- en: This macro tells the replication system that the replicated variable (entered
    as an argument) will replicate only to the clients that meet the condition (entered
    as an argument).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The condition parameter can be one of the following values:'
  prefs: []
  type: TYPE_NORMAL
- en: '`COND_InitialOnly`: The variable will only replicate once, with the initial replication.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`COND_OwnerOnly`: The variable will only replicate to the owner of the actor.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`COND_SkipOwner`: The variable won''t replicate to the owner of the actor.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`COND_SimulatedOnly`: The variable will only replicate to actors that are simulating.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`COND_AutonomousOnly`: The variable will only replicate to actors that are autonomous.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`COND_SimulatedOrPhysics`: The variable will only replicate to actors that
    are simulating or to actors with `bRepPhysics` set to true.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`COND_InitialOrOwner`: The variable will only replicate once, with the initial
    replication or to the owner of the actor.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`COND_Custom`: The variable will only replicate if its `SetCustomIsActiveOverride`
    Boolean condition (used in the `AActor::PreReplication` function) is true.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Have a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, we use the `DOREPLIFETIME_CONDITION` macro to
    tell the replication system that the `Health` variable in the `AVariableReplicationActor`
    class will replicate only for the owner of this actor.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'There are more `DOREPLIFETIME` macros available, but they won''t be covered
    in this book. To see all of the variants, please check the `UnrealNetwork.h` file
    from the Unreal Engine 4 source code. See the instructions at: [https://docs.unrealengine.com/en-US/GettingStarted/DownloadingUnrealEngine/index.html](https://docs.unrealengine.com/en-US/GettingStarted/DownloadingUnrealEngine/index.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 16.03: Replicating Variables Using Replicated, RepNotify, DOREPLIFETIME,
    and DOREPLIFETIME_CONDITION'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we''re going to create a C++ project that uses the Third
    Person template as a base and add two variables to the character that replicate
    in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: Variable `A` is a float that will use the `Replicated UPROPERTY` specifier and
    the `DOREPLIFETIME` macro.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variable `B` is an integer that will use the `ReplicatedUsing UPROPERTY` specifier
    and the `DOREPLIFETIME_CONDITION` macro.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following steps will help you complete the exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new `Third Person` template project using `C++` called `VariableReplication`
    and save it to a location of your choosing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the project has been created, it should open the editor as well as the
    Visual Studio solution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Close the editor and go back to Visual Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `VariableReplicationCharacter.h` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, include the `UnrealNetwork.h` header file before the `VariableReplicationCharacter.generated.h`,
    which has the definition of the `DOREPLIFETIME` macros that we''re going to use:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare the protected variables `A` and `B` as `UPROPERTY` using their respective
    replication specifiers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare the `Tick` function as protected:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we''ve declared variable `B` as `ReplicatedUsing = OnRepNotify_B`, then
    we also need to declare the protected `OnRepNotify_B` callback function as `UFUNCTION`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, open the `VariableReplicationCharacter.cpp` file and include the headers
    `Engine.h`, so we can use the `AddOnScreenDebugMessage` function, and `DrawDebugHelpers.h`,
    so we can use the `DrawDebugString` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `GetLifetimeReplicatedProps` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Set that as the `A` variable, which will replicate without any extra conditions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Set that as the `B` variable, which will only replicate to the owner of this
    actor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `Tick` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, run the authority-specific logic that adds `1` to `A` and `B`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Since this character will be spawned on the server, then only the server will
    execute this logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Display the values of `A` and `B` on the location of the character:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `RepNotify` function for variable `B`, which displays on the
    screen a message saying that the `B` variable was changed to a new value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, you can test the project:'
  prefs: []
  type: TYPE_NORMAL
- en: Run the code and wait for the editor to fully load.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to `Multiplayer Options` and set the number of clients to `2`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the window size to `800x600`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Play using `New Editor Window (PIE)`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you complete this exercise, you will be able to play on each client and
    you'll notice that the characters are displaying their respective values for `A`
    and `B`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's analyze the values displayed in the `Server` and `Client 1` windows.
  prefs: []
  type: TYPE_NORMAL
- en: The Server Window
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the `Server` window, you have the values for `Server Character`, which is
    the character controlled by the server, and in the background, you have values
    for `Client 1 Character`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.11: The Server window'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_16_11.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 16.11: The Server window'
  prefs: []
  type: TYPE_NORMAL
- en: 'The outputs that can be observed are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Server` `Character` – `A = 674.00 B = 574`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Client 1` `Character` – `A = 670.00 B = 570`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At this specific point in time, `Server` `Character` has a value of `674` for
    `A` and `574` for `B`. The reason why `A` and `B` have different values is because
    `A` starts at `100` and `B` starts at `0`, which is the correct value after `574`
    ticks of `A++` and `B++`.
  prefs: []
  type: TYPE_NORMAL
- en: As for why the `Client 1` `Character` doesn't have the same values as the Server
    Character, that is because `Client 1` was created slightly after the server, so
    in this case, the count will be off by `4` ticks of `A++` and `B++`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will be looking at the `Client 1` window.
  prefs: []
  type: TYPE_NORMAL
- en: The Client 1 Window
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the `Client 1` window, you have the values for `Client 1 Character`, which
    is the character controlled by `Client 1`, and in the background, you have values
    for `Server Character`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.12: The Client 1 window'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_16_12.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 16.12: The Client 1 window'
  prefs: []
  type: TYPE_NORMAL
- en: 'The outputs that can be observed are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Server` `Character` – `A = 674.00 B = 0`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Client 1` `Character` – `A = 670.00 B = 570`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Client 1 Character` has the correct values from the server, so the variable
    replication is working as intended. If you look at `Server Character`, `A` is
    `674`, which is correct, but `B` is `0`. The reason for that is `A` is using `DOREPLIFETIME`,
    which doesn''t add any additional replication conditions, so it will replicate
    the variable and keep the client up to date every time the variable is changed
    on the server.'
  prefs: []
  type: TYPE_NORMAL
- en: The variable `B`, on the other hand, uses `DOREPLIFETIME_CONDITION` with `COND_OwnerOnly`,
    and since `Client 1` is not the client that owns `Server Character` (*the client
    of the listen server is*), then the value is not replicated and remains unchanged
    from the default value of `0`.
  prefs: []
  type: TYPE_NORMAL
- en: If you go back to the code and change the replication condition of `B` to use
    `COND_SimulatedOnly` instead of `COND_OwnerOnly`, you'll notice that the results
    will be reversed in `Client 1 window`. The value of `B` will be replicated for
    `Server Character`, but it won't replicate for its own character.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The reason why the `RepNotify` message is showing in the `Server` window instead
    of the client window is that, when playing in the editor, both windows share the
    same process, and therefore printing text on the screen won't be accurate. To
    get the correct behavior, you'll need to run the packaged version of the game.
  prefs: []
  type: TYPE_NORMAL
- en: 2D Blend Spaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In *Chapter 2*, *Working with Unreal Engine*, we created a 1D Blend Space to
    blend between the movement states (*idle, walk, and run*) of a character based
    on the value of the Speed axis. For that specific example, it worked pretty well
    because you only needed one axis, but if we wanted the character to also be able
    to strafe, then we couldn't really do that.
  prefs: []
  type: TYPE_NORMAL
- en: To explore that case, Unreal Engine allows you to create 2D Blend Spaces. The
    concepts are almost exactly the same; the only difference is that you have an
    extra axis for animations, so you can blend between them not only horizontally,
    but also vertically.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 16.04: Creating a Movement 2D Blend Space'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we're going to create a Blend Space that uses two axes instead
    of one. The vertical axis will be `Speed`, which will be between `0` and `800`.
    The horizontal axis will be `Direction`, which represents the relative angle (`-180
    to 180`) between the velocity and the rotation/forward vector of the pawn.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure will help you calculate the direction in this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.13: Direction values based on the angle between the forward'
  prefs: []
  type: TYPE_NORMAL
- en: vector and the velocity
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_16_13.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 16.13: Direction values based on the angle between the forward vector
    and the velocity'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding figure, you can see how the direction will be calculated. The
    forward vector represents the direction that the character is currently facing,
    and the numbers represent the angle that the forward vector would make with the
    velocity vector if it was pointing in that direction. If the character was looking
    in a certain direction and you pressed a key to move the character to the right,
    then the velocity vector would be perpendicular to the forward vector. That would
    mean that the angle would be 90º, so that would be our direction.
  prefs: []
  type: TYPE_NORMAL
- en: If we set up our 2D Blend Space with that logic in mind, we can use the correct
    animation based on the character's movement angle.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps will help you complete the exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new `Third Person` template project using `Blueprints` called `Blendspace2D`
    and save it to a location of your choosing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the project has been created, it should open the editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, you will be importing the movement animations. In the editor, go to the
    `Content\Mannequin\Animations` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the `Import` button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to the `Chapter16\Exercise16.04\Assets` folder, select all of the `fbx` files,
    and hit the `Open` button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the import dialog, make sure you pick the character's skeleton and hit the
    `Import All` button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save all of the new files in the `Assets` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the `Add New` button and pick `Animation -> Blend Space`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, select the character's skeleton.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename the Blend Space `BS_Movement` and open it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the horizontal `Direction` axis `(-180 to 180)` and the vertical `Speed`
    axis `(0 to 800)` as shown in the following figure:![Figure 16.14: 2D Blend Space
    Axis Settings'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_16_14.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 16.14: 2D Blend Space Axis Settings'
  prefs: []
  type: TYPE_NORMAL
- en: Drag the `Idle_Rifle_Ironsights` animation onto the `5` grid entries where `Speed`
    is `0`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the `Walk_Fwd_Rifle_Ironsights` animation where `Speed` is `800` and `Direction`
    is `0`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the `Walk_Lt_Rifle_Ironsights` animation where `Speed` is `800` and `Direction`
    is `-90`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the `Walk_Rt_Rifle_Ironsights` animation where `Speed` is `800` and `Direction`
    is `90`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You should end up with a Blend Space that can be previewed by holding *Shift*
    and moving the mouse.
  prefs: []
  type: TYPE_NORMAL
- en: Now, on the `Asset Details` panel, set the `Target Weight Interpolation Speed
    Per Sec` variable to `5` to make the interpolation smoother.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save and close the Blend Space.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, update the animation Blueprint to use the new Blend Space.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to `Content\Mannequin\Animations` and open the file that comes along with
    the Third Person template – `ThirdPerson_AnimBP`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, go to the event graph and create a new float variable called `Direction`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set the value of `Direction` with the result of the `Calculate Direction` function,
    which calculates the angle (-180º to 180º) between the pawn''s `velocity` and
    `rotation`:![Figure 16.15: Calculating the Speed and Direction to use on the 2D
    Blend Space'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_16_15.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 16.15: Calculating the Speed and Direction to use on the 2D Blend Space'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the preceding screenshot in full resolution for better viewing
    at the following link: [https://packt.live/3pAbbAl](https://packt.live/3pAbbAl).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `AnimGraph`, go to the `Idle/Run` state where the old 1D Blend Space is
    being used, as shown in the following screenshot:![Figure 16.16: Idle/run state
    in the AnimGraph'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_16_16.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 16.16: Idle/run state in the AnimGraph'
  prefs: []
  type: TYPE_NORMAL
- en: 'Replace that Blend Space with `BS_Movement` and use the `Direction` variable
    like so:![Figure 16.17: 1D Blend Space has been replaced by the new 2D Blend Space'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_16_17.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 16.17: 1D Blend Space has been replaced by the new 2D Blend Space'
  prefs: []
  type: TYPE_NORMAL
- en: Save and close the animation Blueprint. Now you need to update the character.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to the `Content\ThirdPersonBP\Blueprints` folder and open `ThirdPersonCharacter`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the `Details` panel for the character, set `Use Controller Rotation Yaw`
    to `true`, which will make the character's `Yaw` rotation always face the control
    rotation's Yaw.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to the character movement component and set `Max Walk Speed` to `800`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set `Orient Rotation to Movement` to `false`, which will prevent the character
    from rotating toward the direction of the movement.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save and close the character Blueprint.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you play the game now with two clients and move the character, it will walk
    forward and backward, but it will also strafe, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.18: Expected output on the server and Client 1 windows'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_16_18.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 16.18: Expected output on the server and Client 1 windows'
  prefs: []
  type: TYPE_NORMAL
- en: By completing this exercise, you will have improved your understanding of how
    to create 2D Blend Spaces, how they work, and the advantages they provide compared
    to just using the regular 1D Blend Space.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will be looking at transforming a character's bone so
    that we can rotate the torso of the player up and down based on the camera's Pitch.
  prefs: []
  type: TYPE_NORMAL
- en: Transform (Modify) Bone
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we move on, there is a very useful node that you can use in the AnimGraph
    called the `Transform (Modify) Bone` node, which allows you to translate, rotate,
    and scale a bone of a skeleton at *runtime*.
  prefs: []
  type: TYPE_NORMAL
- en: You can add it in the `AnimGraph` by *right-clicking* on an empty space, typing
    `transform modify`, and picking the node from the list. If you click on the `Transform
    (Modify) Bone` node, you'll have quite a few options on the `Details` panel.
  prefs: []
  type: TYPE_NORMAL
- en: Here's an explanation of what each option does.
  prefs: []
  type: TYPE_NORMAL
- en: The `Bone to Modify` option will tell the node what bone is going to be transformed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After that option, you have three sections representing each transform operation
    (`Translation`, `Rotation`, and `Scale`). In each section, you can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Translation, Rotation, Scale`: This option will tell the node how much of
    that specific transform operation you want to apply. The final result will depend
    on the mode (*covered in the next section*) you have selected.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are two ways you can set this value:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting a constant value such as (`X=0.0,Y=0.0,Z=0.0`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using a variable, so it can be changed at runtime. To enable this, you need
    to take the following steps (this example is for `Rotation`, but the same concepts
    apply for `Translation` and `Scale`):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Click the checkbox next to the constant value and make sure it is checked.
    Once you do that, the text boxes for the constant value will disappear.![Figure
    16.19: Check the checkbox'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_16_19.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 16.19: Check the checkbox'
  prefs: []
  type: TYPE_NORMAL
- en: '`Transform (Modify) Bone` will add an input so you can plug in your variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.20: Variable used as an input on the Transform (Modify) Bone node'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_16_20.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 16.20: Variable used as an input on the Transform (Modify) Bone node'
  prefs: []
  type: TYPE_NORMAL
- en: '**Setting the mode**'
  prefs: []
  type: TYPE_NORMAL
- en: 'This will tell the node what to do with the value. You can pick from one of
    these three options:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Ignore`: Don''t do anything with the supplied value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Add to Existing`: Grab the current value of the bone and add the supplied
    value to it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Replace Existing`: Replace the current value of the bone with the supplied value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Setting the space**'
  prefs: []
  type: TYPE_NORMAL
- en: 'This will define the space the node should apply the transform to. You can
    pick from one of these four options:'
  prefs: []
  type: TYPE_NORMAL
- en: '`World Space`: The transform will happen in the world space.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Component Space`: The transform will happen in the skeletal mesh component
    space.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Parent Bone Space`: The transform will happen in the parent bone''s space
    of the selected bone.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Bone Space`: The transform will happen in the space of the selected bone.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Last but not least, you have the `Alpha`, which is a value that allows you
    to control the amount of transform that you want to apply. As an example, if you
    have the `Alpha` value as a float, then you''ll have the following behavior with
    different values:'
  prefs: []
  type: TYPE_NORMAL
- en: If `Alpha` is 0.0, then no transform will be applied.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If `Alpha` is 0.5, then it will only apply half of the transform.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If `Alpha` is 1.0, then it will apply the entire transform.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next exercise, we will use the `Transform (Modify) Bone` node to enable
    the character from *Exercise 16.04*, *Creating a Movement 2D Blend Space*, to
    look up and down based on the camera's rotation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 16.05: Creating a Character That Looks up and down'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we're going to duplicate the project from *Exercise 16.04*,
    *Creating a Movement 2D Blend Space*, and enable the character to look up and
    down based on the camera's rotation. To achieve this, we're going to use the `Transform
    (Modify) Bone` node to rotate the `spine_03` bone in the component space based
    on the Pitch of the camera.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps will help you complete the exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: First, you need to duplicate and rename the project from *Exercise 16.04*, *Creating
    a Movement 2D Blend Space*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the `Blendspace2D` project folder from *Exercise 16.04*, *Creating a Movement
    2D Blend Space*, paste it in a new folder, and rename it `TransformModifyBone`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the new project folder, rename the `Blendspace2D.uproject` file `TransformModifyBone.uproject`,
    and open it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, you will be updating the animation Blueprint.
  prefs: []
  type: TYPE_NORMAL
- en: Go to `Content\Mannequin\Animations` and open `ThirdPerson_AnimBP`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Go to the `Event Graph`, create a float variable called `Pitch`, and set it
    with the Pitch of the subtraction (or delta) between the pawn''s rotation and
    the base aim rotation, as shown in the following figure:![Figure 16.21: Calculating
    the Pitch'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_16_21.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 16.21: Calculating the Pitch'
  prefs: []
  type: TYPE_NORMAL
- en: As an alternative to using the `Break Rotator` node, you can *right-click* on
    `Return Value` and pick `Split Struct Pin`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The `Break Rotator` node allows you to separate a `Rotator` variable into three
    float variables that represent the `Pitch`, `Yaw`, and `Roll`. This is useful
    when you want to access the value of each individual component or if you only
    want to work with one or two components, and not with the whole rotation.
  prefs: []
  type: TYPE_NORMAL
- en: Take into consideration that the `Split Struct Pin` option will only appear
    if `Return` `Value` is not connected to anything. Once you do the split, it will
    create three separate wires for `Roll`, `Pitch`, and `Yaw`, just like a break
    but without the extra node.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should end up with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.22: Calculating the Pitch to look up using the Split Struct Pin
    option'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_16_22.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 16.22: Calculating the Pitch to look up using the Split Struct Pin option'
  prefs: []
  type: TYPE_NORMAL
- en: 'This logic uses the rotation of the pawn and subtracts it from the camera''s
    rotation to get the difference in `Pitch`, as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.23: How to calculate the Delta Pitch'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_16_23.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 16.23: How to calculate the Delta Pitch'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, go to `AnimGraph` and add a `Transform (Modify) Bone` node with the following
    settings:![Figure 16.24: Settings for the Transform (Modify) Bone node'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_16_24.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 16.24: Settings for the Transform (Modify) Bone node'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding screenshot, we've set `Bone to Modify` to `spine_03` because
    that is the bone that we want to rotate. We've also set `Rotation Mode` to `Add
    to Existing` because we want to keep the original rotation from the animation
    and add an offset to it. The rest of the options need to have their default value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Connect the `Transform (Modify) Bone` node to the `State Machine` and the `Output
    Pose`, as shown in the following screenshot:![Figure 16.25: Transform (Modify)
    Bone connected to the Output Pose'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_16_25.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 16.25: Transform (Modify) Bone connected to the Output Pose'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding figure, you see the full `AnimGraph`, which will allow the
    character to look up and down by rotating the `spine_03` bone based on the camera
    Pitch. The `State Machine` will be the starting point, and from there, it will
    need to be converted into component space in order to be able to use the `Transform
    (Modify) Bone` node, which will connect to the `Output Pose` node after being
    converted back to local space.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The reason why we connect `Pitch` variable to the `Roll` is that the bone in
    the skeleton is internally rotated that way. You can use the `Split Struct Pin`
    on input parameters as well, so you don't have to add a `Make Rotator` node.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you test the project with two clients and move the mouse *up* and *down*
    on one of the characters, you''ll notice that it will Pitch up and down, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.26: Character mesh pitching up and down, based on the camera rotation'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_16_26.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 16.26: Character mesh pitching up and down, based on the camera rotation'
  prefs: []
  type: TYPE_NORMAL
- en: By completing this final exercise, you'll have an understanding of how to modify
    bones at runtime by using the `Transform (Modify) Bone` node in an animation blueprint.
    This node can be used in various scenarios, so it might prove really useful for
    you.
  prefs: []
  type: TYPE_NORMAL
- en: In the next activity, you're going to put everything you've learned to the test
    by creating the character we're going to use for our multiplayer FPS project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 16.01: Creating a Character for the Multiplayer FPS Project'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this activity, you''ll create the character for the multiplayer FPS project
    that we''re going to build in the next few chapters. The character will have a
    few different mechanics, but for this activity, you just need to create a character
    that walks, jumps, looks up/down, and has two replicated stats: health and armor.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps will help you complete the activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `Blank C++` project called `MultiplayerFPS` without the starter content.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import the skeletal mesh and the animations from the `Activity16.01\Assets folder`
    and place them in the `Content\Player\Mesh` and `Content\Player\Animations` folders
    respectively.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Import the following sounds from the `Activity16.01\Assets` folder to `Content\Player\Sounds`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Jump.wav`: Play this sound on the `Jump_From_Stand_Ironsights` animation with
    a `Play Sound` anim notify.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Footstep.wav`: Play this sound every time a foot is on the floor in every
    walk animation by using the `Play Sound` anim notify.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Spawn.wav`: Use this on the `SpawnSound` variable in the character.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set up the skeletal mesh by retargeting its bones and creating a socket called
    `Camera` that is a child of the head bone and has a Relative Location of (`X=7.88,
    Y=4.73, Z=-10.00`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a 2D Blend Space in `Content\Player\Animations` called `BS_Movement`
    that uses the imported movement animations and a `Target Weight Interpolation
    Speed Per Sec` of `5`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the input mappings in the `Project Settings`, using the knowledge acquired
    in *Chapter 4*, *Player Input*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Jump (action mapping) – *Spacebar*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Move Forward (axis mapping) – *W* (scale `1.0`) and *S* (scale `-1.0`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Move Right (axis mapping) – *A* (scale `-1.0`) and *D* (scale `1.0`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Turn (axis mapping) – Mouse *X* (scale `1.0`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Look Up (axis mapping) – Mouse *Y* (scale `-1.0`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Create a C++ class called `FPSCharacter` that does the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Derives from the `Character` class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Has a camera component attached to the skeletal mesh on the `Camera` socket
    and has `pawn control rotation` set to `true`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Has variables for `health` and `armor` that only replicate to the owner.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Has variables for the maximum `health` and `armor`, as well as the percentage
    of how much damage the armor absorbs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Has a constructor that initializes the camera, disables ticking, and sets `Max
    Walk Speed` to `800` and `Jump Z Velocity` to `600`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On `BeginPlay`, plays the spawning sound and initializes the `health` with `max
    health` if it has authority.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creates and binds the functions to handle the input actions and axis.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Has functions to add/remove/set health. It also ensures the situation where
    the character is dead.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Has functions to add/set/absorb armor. The armor absorption reduces the armor
    based on the `ArmorAbsorption` variable and changes the damage value based on
    the formula:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Damage = (Damage * (1 - ArmorAbsorption)) - FMath::Min(RemainingArmor, 0);*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an animation Blueprint in `Content\Player\Animations` called `ABP_Player`
    that has a `State Machine` with the following states:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Idle/Run`: Uses `BS_Movement` with the `Speed` and `Direction` variables'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Jump`: Plays the jump animation and transitions from the `Idle/Run` states
    when the `Is Jumping` variable is `true`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It also uses `Transform (Modify) Bone` to make the character Pitch up and down
    based on the camera's Pitch.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `UMG` widget in `Content\UI` called `UI_HUD` that displays the `Health`
    and `Armor` of the character in the format `Health: 100` and `Armor: 100`, using
    the knowledge acquired in *Chapter 15*, *Collectibles, Power-ups, and Pickups*.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a Blueprint in `Content\Player` called `BP_Player` that derives from
    `FPSCharacter` and set up the mesh component to have the following values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `SK_Mannequin` skeletal mesh
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the `ABP_Player` animation Blueprint
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set `Location` to be equal to (*X=0.0, Y=0.0, Z=-88.0*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set `Rotation` to be equal to (*X=0.0, Y=0.0, Z=-90.0*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also, on the `Begin Play` event, it needs to create a widget instance of `UI_HUD`
    and add it to the viewport.
  prefs: []
  type: TYPE_NORMAL
- en: Create a Blueprint in `Content\Blueprints` called `BP_GameMode` that derives
    from `MultiplayerFPSGameModeBase`, which will use `BP_Player` as the `DefaultPawn`
    class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a test map in `Content\Maps` called `DM-Test` and set it as the default
    map in `Project Settings`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Expected output:'
  prefs: []
  type: TYPE_NORMAL
- en: The result should be a project where each client will have a first-person character
    that can move, jump, and look around. These actions will also be replicated, so
    each client will be able to see what the other client's character is doing.
  prefs: []
  type: TYPE_NORMAL
- en: Each client will also have a HUD that displays the health and the armor value.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.27: Expected output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_16_27.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 16.27: Expected output'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution to this activity can be found at: [https://packt.live/338jEBx](https://packt.live/338jEBx).'
  prefs: []
  type: TYPE_NORMAL
- en: The end result should be two characters that can see each other moving, jumping,
    and looking around. Each client also displays its character's health and armor
    value.
  prefs: []
  type: TYPE_NORMAL
- en: By completing this activity, you should have a good idea of how the server-client
    architecture, variable replication, roles, 2D Blend Spaces, and the `Transform
    (Modify) Bone` node work.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned about some critical multiplayer concepts, such
    as how the server-client architecture works, the responsibilities of the server
    and the client, how the listen server is quicker to set up than the dedicated
    server but not as lightweight, ownership and connections, roles, and variable
    replication.
  prefs: []
  type: TYPE_NORMAL
- en: We've also learned some useful techniques for animation, such as how to use
    2D Blend Spaces, which allow you to have a two-axis grid to blend between animations,
    and the Transform (Modify) Bone node, which has the ability to modify the bones
    of a skeletal mesh at runtime. To finish off the chapter, we created a first-person
    multiplayer project where you have characters that can walk, look, and jump around,
    which will be the foundation of the multiplayer first-person shooter project that
    we will be working on for the next few chapters.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll learn how to use RPCs, which allow clients and servers
    to execute functions on each other. We'll also cover how to use enumerations in
    the editor and how to use bi-directional circular array indexing, which allows
    you to cycle forward and backward through an array and loop back when it's outside
    the limits.
  prefs: []
  type: TYPE_NORMAL
