- en: 16\. Multiplayer Basics
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 16\. 多人游戏基础知识
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, you will be introduced to some important multiplayer concepts
    in order to add multiplayer support to your game using Unreal Engine 4's network
    framework.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将了解一些重要的多人游戏概念，以便使用虚幻引擎4的网络框架为您的游戏添加多人游戏支持。
- en: By the end of this chapter, you'll know basic multiplayer concepts such as the
    server-client architecture, connections, and actor ownership, along with roles
    and variable replication. You'll be able to implement these concepts to create
    a multiplayer game of your own. You'll also be able to make a 2D Blend Space,
    which allows you to blend between animations laid out in a 2D grid. Finally, you'll
    learn how to use `Transform (Modify) Bone` nodes to control Skeletal Mesh bones
    at runtime.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您将了解基本的多人游戏概念，如服务器-客户端架构、连接和角色所有权，以及角色和变量复制。您将能够实现这些概念，创建自己的多人游戏。您还将能够制作2D混合空间，这允许您在2D网格中的动画之间进行混合。最后，您将学习如何使用`Transform
    (Modify) Bone`节点在运行时控制骨骼网格骨骼。
- en: Introduction
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In the previous chapter, we completed the `SuperSideScroller` game and used
    1D Blend Spaces, animation blueprints, and animation montages. In this chapter,
    we're going to build on that knowledge and learn how to add multiplayer functionality
    to a game using Unreal Engine.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们完成了`SuperSideScroller`游戏，并使用了1D混合空间、动画蓝图和动画蒙太奇。在本章中，我们将在此基础上构建，并学习如何使用虚幻引擎为游戏添加多人游戏功能。
- en: 'Multiplayer games have grown quite a lot in the last decade. Games such as
    Fortnite, PUBG, League of Legends, Rocket League, Overwatch, and CS: GO have gained
    a lot of popularity in the gaming community and have had great success. Nowadays,
    almost all games need to have some kind of multiplayer experience in order to
    be more relevant and successful.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 多人游戏在过去十年里发展迅速。像Fortnite、PUBG、英雄联盟、火箭联盟、守望先锋和CS:GO等游戏在游戏社区中获得了很大的流行，并取得了巨大的成功。如今，几乎所有的游戏都需要具有某种多人游戏体验，以使其更具相关性和成功。
- en: The reason for that is it adds a new layer of possibilities on top of the existing
    gameplay, such as being able to play with friends in cooperative mode (*also known
    as co-op mode*) or against people from all around the world, which greatly increases
    the longevity and value of a game.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的原因是它在现有的游戏玩法之上增加了新的可能性，比如能够在合作模式（*也称为合作模式*）中与朋友一起玩，或者与来自世界各地的人对战，这大大增加了游戏的长期性和价值。
- en: In the next topic, we will be discussing the basics of multiplayer.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个主题中，我们将讨论多人游戏的基础知识。
- en: Multiplayer Basics
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多人游戏基础知识
- en: You may have heard the term multiplayer a lot while gaming, but what does it
    mean for game developers? Multiplayer, in reality, is just a set of instructions
    sent through the network (*internet or local area network*) between the server
    and its connected clients in order to give players the illusion of a shared world.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏中，你可能经常听到多人游戏这个术语，但对于游戏开发者来说，它意味着什么呢？实际上，多人游戏只是通过网络（*互联网或局域网*）在服务器和其连接的客户端之间发送的一组指令，以给玩家产生共享世界的错觉。
- en: For this to work, the server needs to be able to talk to clients, but also the
    other way around (client to server). This is because clients are typically the
    ones that affect the game world, so they need a way to be able to inform the server
    of their intentions while playing the game.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使其工作，服务器需要能够与客户端进行通信，但客户端也需要与服务器进行通信（客户端到服务器）。这是因为客户端通常是影响游戏世界的一方，因此他们需要一种方式来告知服务器他们在玩游戏时的意图。
- en: 'An example of this back and forth communication between the server and a client
    is when a player tries to fire a weapon during a game. Have a look at the following
    figure, which shows a client-server interaction:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这种服务器和客户端之间的来回通信的一个例子是当玩家在游戏中尝试开火时。看一下下面的图，它展示了客户端和服务器的交互：
- en: '![Figure 16.1: Client-server interaction when a player wants to fire'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.1：玩家想要开火时的客户端-服务器交互'
- en: a weapon in a multiplayer game](img/B16183_16_01.jpg)
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 多人游戏中的武器](img/B16183_16_01.jpg)
- en: 'Figure 16.1: Client-server interaction when a player wants to fire a weapon
    in a multiplayer game'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.1：多人游戏中玩家想要开火时的客户端-服务器交互
- en: 'Let''s examine what was shown in *Figure 16.1*:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看*图16.1*中显示的内容：
- en: The player holds the *left mouse button* down and the client of that player
    tells the server that it wants to fire a weapon.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 玩家按住*鼠标左键*，并且该玩家的客户端告诉服务器它想要开火。
- en: 'The server validates whether the player can fire the weapon by checking the following:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器通过检查以下内容来验证玩家是否可以开火：
- en: If the player is alive
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果玩家还活着
- en: If the player has a weapon equipped
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果玩家装备了武器
- en: If the player has enough ammo
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果玩家有足够的弹药
- en: 'If all of the validations are valid, then the server will do the following:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果所有验证都有效，则服务器将执行以下操作：
- en: Run the logic to deduct ammo
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行逻辑以扣除弹药
- en: Spawn the projectile actor on the server, which is automatically sent to all
    of the clients
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在服务器上生成抛射物角色，自动发送到所有客户端
- en: Play the fire animation on the character instance in all of the clients to ensure
    certain synchronicity between all of them, which helps to sell the idea that it's
    the same world, even though it's not
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在所有客户端的角色实例上播放开火动画，以确保它们之间的某种同步性，这有助于传达它们是同一个世界的想法，尽管实际上并非如此
- en: 'If any of the validations fail, then the server tells the specific client what
    to do:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果任何验证失败，服务器会告诉特定的客户端该做什么：
- en: Player is dead – don't do anything
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩家已经死亡-不做任何事情
- en: Player doesn't have a weapon equipped – don't do anything
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩家没有装备武器-不做任何事情
- en: Player doesn't have enough ammo – play an empty click sound
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩家没有足够的弹药-播放空击声音
- en: Remember, if you want your game to support multiplayer, then it's highly recommended
    that you do that as soon as possible in your development cycle. If you try to
    run a single-player project with multiplayer enabled, you'll notice that some
    functionalities might *just work*, but probably most of them won't be working
    properly or as expected.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，如果您希望游戏支持多人游戏，则强烈建议您在开发周期的尽早阶段就这样做。如果您尝试运行启用了多人游戏的单人项目，您会注意到一些功能可能*正常工作*，但可能大多数功能都无法正常工作或达到预期效果。
- en: The reason for that is when you execute the game in single-player, the code
    runs locally and instantly, but when you add multiplayer into the equation, you
    are adding external factors such as an authoritative server that talks to clients
    on a network with latency, as you saw in *Figure 16.1*.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为当您在单人游戏中执行游戏时，代码在本地立即运行，但是当您将多人游戏加入到方程式中时，您正在添加外部因素，例如与具有延迟的网络上的客户端进行通信的权威服务器，就像您在*图16.1*中看到的那样。
- en: 'In order to get everything working properly, you need to break apart the existing
    code into the following:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使一切正常运行，您需要将现有代码分解为以下部分：
- en: Code that only runs on the server
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅在服务器上运行的代码
- en: Code that only runs on the client
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅在客户端上运行的代码
- en: Code that runs on both, which can take a lot of time depending on the complexity
    of your single-player game
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在两者上运行的代码，这可能需要很长时间，具体取决于您的单人游戏的复杂性
- en: In order to add multiplayer support to games, Unreal Engine 4 comes with a very
    powerful and bandwidth-efficient network framework already built in, using an
    authoritative server-client architecture.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 为了为游戏添加多人游戏支持，虚幻引擎4已经内置了一个非常强大和带宽高效的网络框架，使用权威服务器-客户端架构。
- en: 'Here is a diagram of how it works:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是其工作原理的图表：
- en: '![Figure 16.2: Server-client architecture in Unreal Engine 4'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.2：虚幻引擎4中的服务器-客户端架构'
- en: '](img/B16183_16_02.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_16_02.jpg)'
- en: 'Figure 16.2: Server-client architecture in Unreal Engine 4'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.2：虚幻引擎4中的服务器-客户端架构
- en: In *Figure 16.2*, you can see how the server-client architecture works in Unreal
    Engine 4\. Each player controls a client that communicates with the server using
    a **two-way connection**. The server runs a specific level with a game mode (*which
    only exists in the server*) and controls the flow of information so that the clients
    can see and interact with each other in the game world.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图16.2*中，您可以看到服务器-客户端架构在虚幻引擎4中是如何工作的。每个玩家控制一个客户端，使用**双向连接**与服务器通信。服务器在特定级别上运行游戏模式（*仅存在于服务器中*）并控制信息流，以便客户端可以在游戏世界中看到并相互交互。
- en: Note
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Multiplayer can be a very advanced topic, so these next few chapters will serve
    as an introduction to help you understand the essentials, but it will not be an
    in-depth look. For that reason, some concepts might be omitted for simplicity's
    sake.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 多人游戏可能是一个非常复杂的话题，因此接下来的几章将作为介绍，帮助您了解基本知识，但不会深入研究。因此，出于简单起见，一些概念可能被省略。
- en: In the next section, we will be looking at servers.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看看服务器。
- en: Servers
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器
- en: The server is the most critical part of the architecture since it's responsible
    for handling most of the work and making important decisions.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器是架构中最关键的部分，因为它负责处理大部分工作并做出重要决策。
- en: 'Here is an overview of the main responsibilities of a server:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是服务器的主要责任概述：
- en: '**Creating and managing the shared world instance**: The server runs its own
    instance of the game in a specific level and game mode (*this will be covered
    in the chapters ahead*) and that will serve as the shared world between all of
    the connected clients. The level being used can be changed at any point in time
    and, if applicable, the server can bring along all of the connected clients with
    it automatically.'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**创建和管理共享世界实例**：服务器在特定级别和游戏模式中运行其自己的游戏实例（*这将在接下来的章节中介绍*），这将成为所有连接的客户端之间的共享世界。使用的级别可以随时更改，并且如果适用，服务器可以自动带上所有连接的客户端。'
- en: '`PostLogin` function in the game mode is called. From that point on, the client
    will enter the game and is part of the shared world where the player will be able
    to see and interact with other clients. If a client disconnects at any point in
    time, then all of the other clients will be notified and the `Logout` function
    in the game mode will be called.'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 游戏模式中的`PostLogin`函数被调用。从那时起，客户端将进入游戏，并成为共享世界的一部分，玩家将能够看到并与其他客户端进行交互。如果客户端在任何时候断开连接，那么所有其他客户端都将收到通知，并且游戏模式中的`Logout`函数将被调用。
- en: '**Spawning the actors that all of the clients need to know about**: If you
    want to spawn an actor that exists in all of the clients, then you need to do
    that on the server. The reason for this is the server has the authority and is
    the only one that can tell each client to create its own instance of that actor.'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**生成所有客户端需要了解的角色**：如果要生成所有客户端中存在的角色，则需要在服务器上执行此操作。原因是服务器具有权限，并且是唯一可以告诉每个客户端创建其自己的该角色实例的人。'
- en: This is the most common way of spawning actors in multiplayer, since most actors
    need to exist in all of the clients. An example of this would be with a power-up,
    which is something that all clients can see and interact with.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在多人游戏中生成角色的最常见方式，因为大多数角色需要存在于所有客户端中。一个例子是能量增强，所有客户端都可以看到并与之交互。
- en: '**Running critical gameplay logic**: In order to make sure that the game is
    fair to all of the clients, the critical gameplay logic needs to be executed only
    on the server. If clients were responsible for handling the deduction of health,
    it would be very exploitable, because a player could use a tool to change in memory
    the current value of health to 100% all the time, so the player would never die
    in the game.'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**运行关键的游戏逻辑**：为了确保游戏对所有客户端都是公平的，关键的游戏逻辑需要仅在服务器上执行。如果客户端负责处理健康扣除，那将是非常容易被利用的，因为玩家可以使用工具在内存中更改健康当前值为100%，所以玩家在游戏中永远不会死亡。'
- en: '**Handling variable replication**: If you have a replicated variable (*covered
    in this chapter*), then its value should only be changed on the server. This will
    ensure that all of the clients will have the value updated automatically. You
    can still change the value on the client, but it will always be replaced with
    the latest value from the server, in order to prevent cheating and to make sure
    all of the clients are in sync.'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**处理变量复制**：如果您有一个复制的变量（*在本章中介绍*），那么它的值应该只在服务器上更改。这将确保所有客户端的值会自动更新。您仍然可以在客户端上更改值，但它将始终被服务器的最新值替换，以防止作弊并确保所有客户端同步。'
- en: '**Handling RPCs from the client**: The server needs to process the remote procedure
    calls (*Chapter 17*, *Remote Procedure Calls*) sent from the clients.'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**处理来自客户端的RPC**：服务器需要处理来自客户端发送的远程过程调用（*第17章*，*远程过程调用*）。'
- en: Now that you know what a server does, we can talk about the two different ways
    of creating a server in Unreal Engine 4.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您知道服务器的功能，我们可以讨论在虚幻引擎4中创建服务器的两种不同方式。
- en: Dedicated Server
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 专用服务器
- en: The dedicated server only runs the server logic, so you won't see the typical
    window with the game running where you control a character as a local player.
    Additionally, if you run the dedicated server with the `-log` command prompt,
    you'll have a console window that logs relevant information about what is happening
    on the server, such as if a client has connected or disconnected, and so on. You,
    as a developer, can also log your own information by using the `UE_LOG` macro.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 专用服务器仅运行服务器逻辑，因此您不会看到典型的游戏运行窗口，您可以在其中控制本地玩家角色。此外，如果使用`-log`命令提示符运行专用服务器，您将看到一个控制台窗口，记录有关服务器上发生的事件的相关信息，例如客户端是否已连接或断开连接等。作为开发人员，您还可以使用`UE_LOG`宏记录自己的信息。
- en: Using dedicated servers is a very common way of creating servers for multiplayer
    games, and since it's more lightweight than a listen server (*covered in the next
    section*), you could just host it on a server stack and leave it running.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 使用专用服务器是创建多人游戏服务器的一种非常常见的方式，因为它比监听服务器更轻量级，您可以将其托管在服务器堆栈上并让其保持运行。
- en: 'To start a dedicated server in Unreal Engine 4, you can use the following command arguments:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 要在虚幻引擎4中启动专用服务器，可以使用以下命令参数：
- en: 'Run the following command to start a dedicated server inside an editor through
    a shortcut or Command Prompt:'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过快捷方式或命令提示符在编辑器中启动专用服务器，请运行以下命令：
- en: '[PRE0]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here''s an example:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例：
- en: '[PRE1]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: A packaged project requires a special build of the project built specifically
    to serve as a dedicated server.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打包项目需要专门构建的项目的特殊构建，用作专用服务器。
- en: Note
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find out more about setting up a packaged dedicated server by visiting
    [https://allarsblog.com/2015/11/06/support-dedicated-servers/](https://allarsblog.com/2015/11/06/support-dedicated-servers/)
    and [https://www.ue4community.wiki/Dedicated_Server_Guide_(Windows)](https://www.ue4community.wiki/Dedicated_Server_Guide_(Windows)).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过访问[https://allarsblog.com/2015/11/06/support-dedicated-servers/](https://allarsblog.com/2015/11/06/support-dedicated-servers/)和[https://www.ue4community.wiki/Dedicated_Server_Guide_(Windows)](https://www.ue4community.wiki/Dedicated_Server_Guide_(Windows))了解有关设置打包专用服务器的更多信息。
- en: The Listen Server
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 监听服务器
- en: The listen server acts as a server and client at the same time, so you'll also
    have a window where you can play the game as a client with this server type. It
    also has the advantage of being the quickest way of getting a server running,
    but it's not as lightweight as a dedicated server, so the number of clients that
    can be connected at the same time will be limited.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 监听服务器同时充当服务器和客户端，因此您还将拥有一个窗口，可以以此服务器类型的客户端玩游戏。它还具有是最快启动服务器的优势，但它不像专用服务器那样轻量级，因此可以连接的客户端数量将受到限制。
- en: 'To start a listen server, you can use the following command arguments:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动监听服务器，可以使用以下命令参数：
- en: 'Run the following command to start a dedicated server inside an editor through
    a shortcut or Command Prompt:'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过快捷方式或命令提示符在编辑器中启动专用服务器，请运行以下命令：
- en: '[PRE2]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here''s an example:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例：
- en: '[PRE3]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'A packaged project (development builds only) requires a special build of the
    project built specifically to serve as a dedicated server:'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打包项目（仅限开发构建）需要专门构建的项目的特殊构建，用作专用服务器：
- en: '[PRE4]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here''s an example:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例：
- en: '[PRE5]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the next section, we will discuss clients.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论客户端。
- en: Clients
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端
- en: The client is the simplest part of the architecture because most of the actors
    will have the authority on the server, so in those cases, the work will be done
    on the server and the client will just obey its orders.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端是架构中最简单的部分，因为大多数参与者将在服务器上拥有权限，所以在这些情况下，工作将在服务器上完成，客户端只需服从其命令。
- en: 'Here is an overview of the main responsibilities of a client:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是客户端的主要职责概述：
- en: '**Enforcing variable replication from the server**: The server typically has
    authority over all of the actors that the client knows, so when the value of a
    replicated variable is changed on the server, the client needs to enforce that
    value as well.'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**从服务器强制执行变量复制**：服务器通常对客户端知道的所有参与者具有权限，因此当复制变量的值在服务器上更改时，客户端需要强制执行该值。'
- en: '**Handling RPCs from the server**: The client needs to process the remote procedure
    calls (covered in *Chapter 17*, *Remote Procedure Calls*) sent from the server.'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**处理来自服务器的RPC**：客户端需要处理来自服务器发送的远程过程调用（在*第17章*，*远程过程调用*中介绍）。'
- en: '**Predicting movement when simulating**: When a client is simulating an actor
    (*covered later in this chapter*) it needs to locally predict where it''s going
    to be based on the actor''s velocity.'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**模拟时预测移动**：当客户端模拟参与者（*本章后面介绍*）时，它需要根据参与者的速度本地预测其位置。'
- en: '**Spawning the actors that only a client needs to know about**: If you want
    to spawn an actor that only exists on a client, then you need to do that on that
    specific client.'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**生成只有客户端需要知道的参与者**：如果要生成只存在于客户端的参与者，则需要在特定客户端上执行该操作。'
- en: This is the least common way of spawning actors since there are few instances
    when you want an actor to only exist on a client. An example of this is the placement
    preview actor you see in multiplayer survival games, where the player controls
    a semi-transparent version of a wall that other players can't see until it's actually
    placed.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: 'A client can join a server in different ways. Here is a list of the most common methods:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the Unreal Engine 4 console (by default is the *`* key) to open it and
    type:'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'For instance:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Using the `Execute Console Command` Blueprint node. An example is as follows:![Figure
    16.3: Joining a server with an example IP with the Execute Console Command node'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '](img/B16183_16_03.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 16.3: Joining a server with an example IP with the Execute Console Command
    node'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the `ConsoleCommand` function in `APlayerController` as follows:'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here''s an example:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Using the editor executable through a shortcut or Command Prompt:'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here''s an example:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '`C:\Program Files\Epic Games\UE_4.24\Engine\Binaries\Win64\UE4Editor.exe D:\TestProject\TestProject.uproject
    194.56.23.4 -game`'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: 'Using a packaged development build through a shortcut or Command Prompt:'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here''s an example:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '`D:\Packaged\TestProject\TestProject.exe 194.56.23.4`'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: In the following exercise, we will test the Third Person template that comes
    with Unreal Engine 4 in multiplayer.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 16.01: Testing the Third Person Template in Multiplayer'
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we're going to create a Third Person template project and
    play it in multiplayer.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: The following steps will help you complete the exercise.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Create a new `Third Person` template project using `Blueprints` called `TestMultiplayer`
    and save it to a location of your choosing.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once the project has been created, it should open the editor. We''ll now test
    the project in multiplayer to see how it behaves:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: In the editor, to the right of the `Play` button, you have an option with an
    arrow pointing down. Click on it and you should see a list of options. Under the
    `Multiplayer Options` section, you can configure how many clients you want to
    use and whether or not you want a dedicated server.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Leave `Run Dedicated Server` unchecked, change `Number of Players` to `3`, and
    click on `New Editor Window (PIE)`.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You should see three windows on top of each other representing the three clients:![Figure
    16.4: Launching three client windows with a listen server'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_16_04.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 16.4: Launching three client windows with a listen server'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, this is a bit cluttered, so let's change the size of the windows.
    Press *Esc* on your keyboard to stop playing.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: Click once again on the downward-pointing arrow next to the `Play` button and
    pick the last option, `Advanced Settings`.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Search for the `Game Viewport Settings` section. Change `New Viewport Resolution`
    to `640x480` and close the `Editor Preferences` tab.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Play the game again and you should see the following:![Figure 16.5: Launching
    three client windows using a 640x480 resolution with a listen server'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_16_05.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 16.5: Launching three client windows using a 640x480 resolution with
    a listen server'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: Once you start playing, you'll notice that the title bars of the windows say
    `Server`, `Client 1`, and `Client 2`. Since you can control a character in the
    `Server` window, that means we're running a `Server + Client 0` instead of just
    `Server` to avoid confusion.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: By completing this exercise, you now have a setup where you'll have one server
    and three clients running (`Client 0`, `Client 1`, and `Client 2`).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: When you have multiple windows running at the same time, you'll notice that
    you can only have input focus on one window at a time. To shift the focus to another
    window, just press *Shift* + *F1* to lose the current input focus and then just
    click on the new window you want to focus on.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: If you play the game in one of the windows, you'll notice that you can move
    around and jump and the other clients will also be able to view that.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: The reason why everything works is that the character movement component, which
    comes with the character class, replicates the location, rotation, and falling
    state (used to show whether you are jumping or not) for you automatically. If
    you want to add a custom behavior such as an attack animation, you can't just
    tell the client to play an animation locally when a key is pressed, because that
    will not work on the other clients. That's why you need the server, to serve as
    an intermediary and tell all the clients to play the animation when one client
    presses the key.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 一切正常运行的原因是角色移动组件自动复制位置、旋转和下落状态（用于显示您是否在跳跃）给您。如果要添加自定义行为，如攻击动画，您不能只是告诉客户端在按键时本地播放动画，因为这在其他客户端上不起作用。这就是为什么需要服务器，作为中介，告诉所有客户端在一个客户端按下按键时播放动画。
- en: The Packaged Version
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打包版本
- en: Once you've finished the project, it's good practice to package it (*as covered
    in the previous chapters*) so that we have a pure standalone version that doesn't
    use Unreal Engine editor, which will run faster and is more lightweight.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 项目完成后，最好将其打包（*如前几章所述*），这样我们就会得到一个纯粹的独立版本，不需要使用虚幻引擎编辑器，运行速度更快，更轻量。
- en: 'The following steps will help you create the packaged version of *Exercise
    16.01*, *Testing the Third Person Template in Multiplayer file*:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助您创建*Exercise 16.01*，*在多人游戏文件中测试第三人称模板*的打包版本：
- en: Go to `File` -> `Package Project` -> `Windows` -> `Windows (64-bit)`.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到`文件` -> `打包项目` -> `Windows` -> `Windows（64位）`。
- en: Pick a folder to place the packaged build and wait for it to finish.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个文件夹放置打包版本，并等待完成。
- en: Go to the selected folder and open the `WindowsNoEditor` folder inside it.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到所选文件夹，并打开其中的`WindowsNoEditor`文件夹。
- en: '*Right-click* on `TestMultiplayer.exe` and pick `Create Shortcut`.'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*右键单击*`TestMultiplayer.exe`，选择“创建快捷方式”。'
- en: Rename the new shortcut `Run Server`.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新的快捷方式重命名为`运行服务器`。
- en: '*Right-click* on it and pick `Properties`.'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*右键单击*它，选择“属性”。'
- en: 'On the Target, append `ThirdPersonExampleMap?Listen -server`, which creates
    a listen server using `ThirdPersonExampleMap`. You should end up with this:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在目标上附加`ThirdPersonExampleMap?Listen -server`，这将使用`ThirdPersonExampleMap`创建一个监听服务器。您应该得到这个：
- en: '[PRE12]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Click `OK` and run the shortcut.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“确定”并运行快捷方式。
- en: You should get a Windows Firewall prompt, so allow it.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您应该会收到Windows防火墙提示，所以允许它。
- en: Leave the server running and go back to the folder and create another shortcut
    from `TestMultiplayer.exe`.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保持服务器运行，并返回文件夹，从`TestMultiplayer.exe`创建另一个快捷方式。
- en: Rename it `Run Client`.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其重命名为`运行客户端`。
- en: '*Right-click* on it and pick `Properties`.'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*右键单击*它，选择“属性”。'
- en: On the Target, append `127.0.0.1`, which is the IP of your local server. You
    should end up with `"<Path>\WindowsNoEditor\TestMultiplayer.exe" 127.0.0.1`.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在目标上附加`127.0.0.1`，这是您本地服务器的IP。您应该得到`"<Path>\WindowsNoEditor\TestMultiplayer.exe"
    127.0.0.1`。
- en: Click `OK` and run the shortcut.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“确定”并运行快捷方式。
- en: You are now connected to the listen server, so you can see each other's characters.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你已经连接到监听服务器，所以你可以看到彼此的角色。
- en: Every time you click on the `Run Client` shortcut, you'll add a new client to
    the server, so you can have a few clients running on the same machine.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每次单击“运行客户端”快捷方式，您都会向服务器添加一个新的客户端，因此您可以在同一台机器上运行几个客户端。
- en: In the next section, we will be looking at connections and ownership.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，我们将看看连接和所有权。
- en: Connections and Ownership
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接和所有权
- en: When using multiplayer in Unreal Engine, an important concept to understand
    is that of a connection. When a client joins a server, it will get a new **Player
    Controller** with a connection associated with it.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用虚幻引擎进行多人游戏时，一个重要的概念是连接。当客户端加入服务器时，它将获得一个新的**玩家控制器**，并与之关联一个连接。
- en: If an actor doesn't have a valid connection with the server, then the actor
    won't be able to do replication operations such as variable replication (*covered
    later in this chapter*) or call RPCs (covered in *Chapter 17,* *Remote Procedure
    Calls*).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个角色与服务器没有有效的连接，那么该角色将无法进行复制操作，如变量复制（*本章后面介绍*）或调用RPC（在*第17章*，*远程过程调用*中介绍）。
- en: If the Player Controller is the only actor that holds a connection, then does
    that mean that it's the only place you can do replication operations? No, and
    that's where the `GetNetConnection` function, defined in `AActor`, comes into
    play.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果玩家控制器是唯一持有连接的角色，那么这是否意味着它是唯一可以进行复制操作的地方？不是，这就是`GetNetConnection`函数发挥作用的地方，该函数在`AActor`中定义。
- en: When doing replication operations (such as variable replication or call RPCs)
    on an actor, the Unreal framework will get the actor's connection by calling the
    `GetNetConnection()` function on it. If the connection is valid, then the replication
    operation will be processed, if it's not, nothing will happen. The most common
    implementations of `GetNetConnection()` are from `APawn` and `AActor`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在对角色进行复制操作（如变量复制或调用RPC）时，虚幻框架将通过调用`GetNetConnection()`函数来获取角色的连接。如果连接有效，则复制操作将被处理，如果无效，则不会发生任何事情。`GetNetConnection()`的最常见实现来自`APawn`和`AActor`。
- en: 'Let''s take a look at how the `APawn` class implements the `GetNetConnection()`
    function, which is typically used for characters:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`APawn`类如何实现`GetNetConnection()`函数，这通常用于角色：
- en: '[PRE13]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The preceding implementation, which is part of the Unreal Engine 4 source code,
    will first check whether the pawn has a valid controller. If the controller is
    valid, then it will use its connection. If the controller is not valid, then it
    will use the parent implementation of the `GetNetConnection()` function, which
    is on `AActor`:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的实现是虚幻引擎4源代码的一部分，它首先检查pawn是否有有效的控制器。如果控制器有效，则使用其连接。如果控制器无效，则使用`GetNetConnection()`函数的父实现，即`AActor`上的实现：
- en: '[PRE14]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The preceding implementation, which is also part of the Unreal Engine 4 source
    code, will check whether the actor has a valid owner. If it does, it will use
    the owner's connection; if it doesn't, it will return an invalid connection. So
    what is this `Owner` variable? Every actor has a variable called `Owner` (where
    you can set its value by calling the `SetOwner` function) that shows which actor
    *owns* it, so you can think of it as the parent actor.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的实现也是虚幻引擎4源代码的一部分，它将检查角色是否有有效的所有者。如果有，它将使用所有者的连接；如果没有，它将返回一个无效的连接。那么这个`Owner`变量是什么？每个角色都有一个名为`Owner`的变量（可以通过调用`SetOwner`函数来设置其值），显示哪个角色*拥有*它，因此你可以将其视为父角色。
- en: Using the owner's connection in this implementation of `GetNetConnection()`
    will work like a hierarchy. If, while going up the hierarchy of owners, it finds
    an owner that is a Player Controller or is being controlled by one, then it will
    have a valid connection and will be able to process replication operations. Have
    a look at the following example.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个`GetNetConnection()`的实现中使用所有者的连接将像一个层次结构一样工作。如果在所有者的层次结构中找到一个是玩家控制器或者被玩家控制器控制的所有者，那么它将有一个有效的连接，并且能够处理复制操作。看下面的例子。
- en: Note
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In a listen server, the connection for the character controlled by its client
    will always be invalid, because that client is already a part of the server and
    therefore doesn't need a connection.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在监听服务器中，由其客户端控制的角色的连接将始终无效，因为该客户端已经是服务器的一部分，因此不需要连接。
- en: Imagine a weapon actor was placed in the world and it's just sitting there.
    In that situation, the weapon won't have an owner, so if the weapon tries to do
    any replication operations, such as variable replication or calling RPCs, nothing
    will happen.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个武器角色被放置在世界中，它就在那里。在这种情况下，武器将没有所有者，因此如果武器尝试执行任何复制操作，如变量复制或调用RPC，将不会发生任何事情。
- en: However, if a client picks up the weapon and calls `SetOwner` on the server
    with the value of the character, then the weapon will now have a valid connection.
    The reason for this is because the weapon is an actor, so in order to get its
    connection, it will use the `AActor` implementation of `GetNetConnection()`, which
    returns the connection of its owner. Since the owner is the client's character,
    it will use the implementation of `GetNetConnection()` of `APawn`. The character
    has a valid Player Controller, so that is the connection returned by the function.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果客户端拾取武器并在服务器上调用`SetOwner`并将值设置为角色，那么武器现在将有一个有效的连接。原因是武器是一个角色，因此为了获取其连接，它将使用`AActor`的`GetNetConnection()`实现，该实现返回其所有者的连接。由于所有者是客户端的角色，它将使用`APawn`的`GetNetConnection()`的实现。角色有一个有效的玩家控制器，因此这是函数返回的连接。
- en: 'Here is a diagram to help you understand this logic:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个图表来帮助你理解这个逻辑：
- en: '![Figure 16.6: Connections and ownership example of a weapon actor'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.6：武器角色的连接和所有权示例'
- en: '](img/B16183_16_06.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_16_06.jpg)'
- en: 'Figure 16.6: Connections and ownership example of a weapon actor'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.6：武器角色的连接和所有权示例
- en: 'Let''s understand the elements of an invalid owner:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解无效所有者的元素：
- en: '`AWeapon` doesn''t override the `GetNetConnection` function, so to get the
    weapon''s connection, it will call the first implementation found, which is `AActor::GetNetConnection`.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AWeapon`没有覆盖`GetNetConnection`函数，因此要获取武器的连接，它将调用找到的第一个实现，即`AActor::GetNetConnection`。'
- en: The implementation of `AActor::GetNetConnection` calls `GetNetConnection` on
    its owner. Since there is no owner, the connection is invalid.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AActor::GetNetConnection`的实现调用其所有者的`GetNetConnection`。由于没有所有者，连接是无效的。'
- en: 'A valid owner will consist of the following elements:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 有效的所有者将包括以下元素：
- en: '`AWeapon` doesn''t override the `GetNetConnection` function, so to get its
    connection, it will call the first implementation found, which is `AActor::GetNetConnection`.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AWeapon`没有覆盖`GetNetConnection`函数，因此要获取其连接，它将调用找到的第一个实现，即`AActor::GetNetConnection`。'
- en: The implementation of `AActor::GetNetConnection` calls `GetNetConnection` on
    its owner. Since the owner is the character that picked up the weapon, it will
    call `GetNetConnection` on it.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AActor::GetNetConnection`的实现调用其所有者的`GetNetConnection`。由于所有者是拾取武器的角色，它将在其上调用`GetNetConnection`。'
- en: '`ACharacter` doesn''t override the `GetNetConnection` function, so to get its
    connection, it will call the first implementation found, which is `APawn::GetNetConnection`.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ACharacter`没有覆盖`GetNetConnection`函数，因此要获取其连接，它将调用找到的第一个实现，即`APawn::GetNetConnection`。'
- en: The implementation of `APawn::GetNetConnection` uses the connection from the
    owning player controller. Since the owning player controller is valid, then it
    will use that connection for the weapon.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`APawn::GetNetConnection`的实现使用拥有的玩家控制器的连接。由于拥有的玩家控制器是有效的，因此它将使用该连接来处理武器。'
- en: Note
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In order for `SetOwner` to work as intended, it needs to be executed on the
    authority which, in most cases, means the server. If you only execute `SetOwner`
    on the client, it still won't be able to execute replication operations.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使`SetOwner`按预期工作，它需要在大多数情况下在服务器上执行，这意味着需要在权限上执行。如果你只在客户端执行`SetOwner`，它仍然无法执行复制操作。
- en: Roles
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 角色
- en: When you spawn an actor on the server, there will be a version of the actor
    created on the server and one on each client. Since there are different versions
    of the same actor on different instances of the game (`Server`, `Client 1`, `Client
    2`, and so on), it is important to know which version of the actor is which. This
    will allow us to know what logic can be executed in each of these instances.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在服务器上生成一个角色时，将在服务器上创建一个角色的版本，并在每个客户端上创建一个版本。由于在游戏的不同实例（`服务器`，`客户端1`，`客户端2`等）上有相同角色的不同版本，因此知道哪个版本的角色是哪个是很重要的。这将使我们知道可以在这些实例中执行什么逻辑。
- en: 'To help with this situation, every actor has the following two variables:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助解决这种情况，每个角色都有以下两个变量：
- en: '`GetLocalRole()` function.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetLocalRole()`函数。'
- en: '`GetRemoteRole()` function.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetRemoteRole()`函数。'
- en: 'The return type of the `GetLocalRole()` and `GetRemoteRole()` functions is
    `ENetRole`, which is an enumeration that can have the following possible values:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetLocalRole()`和`GetRemoteRole()`函数的返回类型是`ENetRole`，它是一个枚举，可以具有以下可能的值：'
- en: '`ROLE_None`: The actor doesn''t have a role because it''s not being replicated.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ROLE_None`：该角色没有角色，因为它没有被复制。'
- en: '`ROLE_SimulatedProxy`: The current game instance doesn''t have authority over
    the actor and it''s not controlling it through a Player Controller. That means
    that its movement will be simulated/predicted by using the last value of the actor''s
    velocity.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ROLE_SimulatedProxy`：当前游戏实例对该角色没有权限，并且也没有通过玩家控制器来控制它。这意味着它的移动将通过使用角色速度的最后一个值来进行模拟/预测。'
- en: '`ROLE_AutonomousProxy`: The current game instance doesn''t have authority over
    the actor, but it''s being controlled by a Player Controller. That means that
    we can send to the server more accurate movement information, based on the player''s
    inputs, instead of just using the last value of the actor''s velocity.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ROLE_AutonomousProxy`：当前游戏实例对该角色没有权限，但它由玩家控制。这意味着我们可以根据玩家的输入向服务器发送更准确的移动信息，而不仅仅使用角色速度的最后一个值。'
- en: '`ROLE_Authority`: The current game instance has complete authority over the
    actor. That means that if the actor is on the server, the changes made to the
    replicated variables of the actor will be treated as the value that every client
    needs to have enforced through variable replication.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ROLE_Authority`：当前游戏实例对该角色具有完全权限。这意味着如果该角色在服务器上，对该角色的复制变量所做的更改将被视为每个客户端需要通过变量复制强制执行的值。'
- en: 'Let''s have a look at the following example code snippet:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下以下示例代码片段：
- en: '[PRE15]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The preceding code snippet will store the values of the local role and remote
    role to `MyLocalRole` and `MyRemoteRole` respectively. After that, it will print
    different messages on the screen depending on whether that version of the actor
    is the authority or whether it's being controlled by a player on its client.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段将将本地角色和远程角色的值分别存储到`MyLocalRole`和`MyRemoteRole`中。之后，它将根据该角色的版本是权限还是在其客户端上由玩家控制而在屏幕上打印不同的消息。
- en: Note
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: It is important to understand that if an actor has a local role of `ROLE_Authority`,
    it doesn't mean that it's on the server; it means that it's on the game instance
    that originally spawned the actor and therefore has authority over it.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解，如果一个角色具有`ROLE_Authority`的本地角色，这并不意味着它在服务器上；这意味着它在最初生成角色的游戏实例上，并因此对其具有权限。
- en: If a client spawns an actor, even though the server and the other clients won't
    know about it, its local role will still be `ROLE_Authority`. Most of the actors
    in a multiplayer game will be spawned by the server; that's why it's easy to misunderstand
    that the authority is always referring to the server.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果客户端生成一个角色，即使服务器和其他客户端不知道它，它的本地角色仍将是`ROLE_Authority`。大多数多人游戏中的角色都将由服务器生成；这就是为什么很容易误解权限总是指服务器。
- en: 'Here is a table to help you understand the roles that an actor will have in
    different scenarios:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个表格，帮助您理解角色在不同情况下将具有的角色：
- en: '![Figure 16.7: Roles that an actor can have in different scenarios'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.7：角色在不同场景中可以拥有的角色'
- en: '](img/B16183_16_07.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_16_07.jpg)'
- en: 'Figure 16.7: Roles that an actor can have in different scenarios'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.7：角色在不同场景中可以拥有的角色
- en: In the preceding table, you can see the roles that an actor will have in different scenarios.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在上表中，您可以看到角色在不同情况下将具有的角色。
- en: 'Let''s analyze each scenario and explain why the actor has that role:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析每种情况，并解释为什么角色具有该角色：
- en: '**Actor Spawned on the Server**'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '**在服务器上生成的角色**'
- en: The actor spawns on the server, so the server's version of that actor will have
    the local role of `ROLE_Authority` and the remote role of `ROLE_SimulatedProxy`,
    which is the local role of the client's version of the actor. For the client's
    version of that actor, its local role will be `ROLE_SimulatedProxy` and the remote
    role will be `ROLE_Authority`, which is the local role of the server's actor version.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 该角色在服务器上生成，因此服务器版本的该角色将具有`ROLE_Authority`的本地角色和`ROLE_SimulatedProxy`的远程角色，这是客户端版本的该角色的本地角色。对于该角色的客户端版本，其本地角色将是`ROLE_SimulatedProxy`，远程角色将是`ROLE_Authority`，这是服务器角色版本的本地角色。
- en: '**Actor Spawned on the Client**'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '**在客户端上生成的角色**'
- en: The actor was spawned on the client, so the client's version of that actor will
    have the local role of `ROLE_Authority` and the remote role of `ROLE_SimulatedProxy`.
    Since the actor wasn't spawned on the server, then it will only exist on the client
    that spawned it, so there won't be versions of this actor on the server and the
    other clients.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 角色在客户端上生成，因此该角色的客户端版本将具有`ROLE_Authority`的本地角色和`ROLE_SimulatedProxy`的远程角色。由于该角色未在服务器上生成，因此它只会存在于生成它的客户端上，因此在服务器和其他客户端上不会有该角色的版本。
- en: '**Player-Owned Pawn Spawned on the Server**'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '**在服务器上生成的玩家拥有的角色**'
- en: The pawn was spawned on the server, so the server's version of that pawn will
    have the local role of `ROLE_Authority` and the remote role of `ROLE_AutonomousProxy`,
    which is the local role of the client's version of the pawn. For the client's
    version of that pawn, its local role will be `ROLE_AutonomousProxy`, because it's
    being controlled by `PlayerController`, and the remote role `ROLE_Authority`,
    which is the local role of the server's pawn version.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 该角色在服务器上生成，因此服务器版本的该角色将具有`ROLE_Authority`的本地角色和`ROLE_AutonomousProxy`的远程角色，这是客户端版本的该角色的本地角色。对于该角色的客户端版本，其本地角色将是`ROLE_AutonomousProxy`，因为它由`PlayerController`控制，并且远程角色将是`ROLE_Authority`，这是服务器角色版本的本地角色。
- en: '**Player-Owned Pawn Spawned on the Client**'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '**在客户端上生成的玩家拥有的角色**'
- en: The pawn was spawned on the client, so the client's version of that pawn will
    have the local role of `ROLE_Authority` and the remote role of `ROLE_SimulatedProxy`.
    Since the pawn wasn't spawned on the server, then it will only exist on the client
    that spawned it, so there won't be versions of this pawn on the server and the
    other clients.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 该pawn在客户端上生成，因此该pawn的客户端版本将具有`ROLE_Authority`的本地角色和`ROLE_SimulatedProxy`的远程角色。由于pawn没有在服务器上生成，因此它只会存在于生成它的客户端上，因此在服务器和其他客户端上不会有这个pawn的版本。
- en: 'Exercise 16.02: Implementing Ownership and Roles'
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习16.02：实现所有权和角色
- en: In this exercise, we're going to create a C++ project that uses the Third Person
    template as a base.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建一个使用Third Person模板作为基础的C++项目。
- en: 'Create a new actor called `OwnershipTestActor` that has a static mesh component
    as the root component, and on every tick, it''ll do the following:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`OwnershipTestActor`的新actor，它具有静态网格组件作为根组件，并且在每次tick时，它将执行以下操作：
- en: On the authority, it will check which character is closest to it within a certain
    radius (configured by the `EditAnywhere` variable called `OwnershipRadius`) and
    will set that character as its owner. When no character is within the radius,
    then the owner will be `nullptr`.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在权限方面，它将检查在一定半径内（由名为`OwnershipRadius`的`EditAnywhere`变量配置）哪个角色离它最近，并将该角色设置为其所有者。当半径内没有角色时，所有者将为`nullptr`。
- en: Display its local role, remote role, owner, and connection.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示其本地角色、远程角色、所有者和连接。
- en: Edit `OwnershipRolesCharacter` and override the `Tick` function so that it displays
    its local role, remote role, owner, and connection.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编辑`OwnershipRolesCharacter`并覆盖`Tick`函数，以便显示其本地角色、远程角色、所有者和连接。
- en: Create a new header file called `OwnershipRoles.h` that contains the `ROLE_TO_String`
    macro, which converts `ENetRole` into an `Fstring` variable.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个名为`OwnershipRoles.h`的新头文件，其中包含`ROLE_TO_String`宏，将`ENetRole`转换为`Fstring`变量。
- en: 'The following steps will help you complete the exercise:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助您完成练习：
- en: Create a new `Third Person` template project using `C++` called `OwnershipRoles`
    and save it to a location of your choosing.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`C++`创建一个名为`OwnershipRoles`的新`Third Person`模板项目，并将其保存到您选择的位置。
- en: Once the project has been created, it should open the editor as well as the
    Visual Studio solution.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 项目创建完成后，应该打开编辑器以及Visual Studio解决方案。
- en: Using the editor, create a new C++ class called `OwnershipTestActor` that derives
    from `Actor`.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用编辑器，创建一个名为`OwnershipTestActor`的新C++类，该类派生自`Actor`。
- en: Once it finishes compiling, Visual Studio should pop up with the newly created
    `.h` and `.cpp` files.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译完成后，Visual Studio应该弹出新创建的`.h`和`.cpp`文件。
- en: Close the editor and go back to Visual Studio.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭编辑器，返回Visual Studio。
- en: 'In Visual Studio, open the `OwnershipRoles.h` file and add the following macro:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio中，打开`OwnershipRoles.h`文件并添加以下宏：
- en: '[PRE16]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This macro will convert the `ENetRole` enumeration that we get from the `GetLocalRole()`
    function and `GetRemoteRole()` into an `FString`. The way it works is by finding
    the `ENetRole` enumeration type through Unreal Engine's reflection system and
    from that, it converts the `Value` parameter into an `FString` variable so it
    can be printed on the screen.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这个宏将把我们从`GetLocalRole()`函数和`GetRemoteRole()`获得的`ENetRole`枚举转换为`FString`。它的工作方式是通过在虚幻引擎的反射系统中找到`ENetRole`枚举类型，并从中将`Value`参数转换为`FString`变量，以便在屏幕上打印出来。
- en: Now, open the `OwnershipTestActor.h` file.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开`OwnershipTestActor.h`文件。
- en: 'Declare the protected variables for the static mesh component and the ownership
    radius as shown in the following code snippet:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据以下代码片段中所示，声明静态网格组件和所有权半径的受保护变量：
- en: '[PRE17]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the preceding code snippet, we declare the static mesh component and the
    `OwnershipRadius` variable, which allows you to configure the radius of the ownership.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码片段中，我们声明了静态网格组件和`OwnershipRadius`变量，它允许您配置所有权的半径。
- en: Next, delete the declaration of `BeginPlay` and move the constructor and the
    `Tick` function declarations to the protected area.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，删除`BeginPlay`的声明，并将构造函数和`Tick`函数的声明移到受保护的区域。
- en: 'Now, open the `OwnershipTestActor.cpp` file and add the required header files
    as mentioned in the following code snippet:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开`OwnershipTestActor.cpp`文件，并根据以下代码片段中提到的添加所需的头文件：
- en: '[PRE18]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the preceding code snippet, we include `DrawDebugHelpers.h` because we'll
    call the `DrawDebugSphere` and `DrawDebugString` functions. We include `OwnershipRoles.h`,
    `OwnershipRolesCharacter.h` and `StaticMeshComponent.h` so that the `.cpp` file
    knows about those classes. We finally include `GameplayStatics.h` because we'll
    call the `GetAllActorsOfClass` function.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码片段中，我们包括了`DrawDebugHelpers.h`，因为我们将调用`DrawDebugSphere`和`DrawDebugString`函数。我们包括`OwnershipRoles.h`，`OwnershipRolesCharacter.h`和`StaticMeshComponent.h`，以便`.cpp`文件知道这些类。最后，我们包括`GameplayStatics.h`，因为我们将调用`GetAllActorsOfClass`函数。
- en: 'In the constructor definition, create the static mesh component and set it
    as the root component:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数定义中，创建静态网格组件并将其设置为根组件：
- en: '[PRE19]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Still in the constructor, set `bReplicates` to `true` to tell Unreal Engine
    that this actor replicates and should also exist in all of the clients:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数中，将`bReplicates`设置为`true`，告诉虚幻引擎该actor会复制，并且也应该存在于所有客户端中：
- en: '[PRE20]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Delete the `BeginPlay` function definition.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除`BeginPlay`函数定义。
- en: 'In the `Tick` function, draw a debug sphere to help visualize the ownership
    radius, as shown in the following code snippet:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Tick`函数中，绘制一个调试球来帮助可视化所有权半径，如下面的代码片段所示：
- en: '[PRE21]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Still in the `Tick` function, create the authority specific logic that will
    get the closest `AOwnershipRolesCharacter` within the ownership radius, and if
    it''s different from the current one, then set it as the owner:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仍然在`Tick`函数中，创建特定于权限的逻辑，该逻辑将获取所有权半径内最接近的`AOwnershipRolesCharacter`，如果与当前角色不同，则将其设置为所有者：
- en: '[PRE22]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Still in the `Tick` function, convert the values for the local/remote roles
    (using the `ROLE_TO_STRING` macro we created earlier), the current owner, and
    the connection to the strings:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仍然在`Tick`函数中，将本地/远程角色的值（使用我们之前创建的`ROLE_TO_STRING`宏），当前所有者和连接转换为字符串：
- en: '[PRE23]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'To finalize the `Tick` function, use `DrawDebugString` to display onscreen
    the strings we converted in the previous step:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，使用`DrawDebugString`在屏幕上显示我们在上一步中转换的字符串：
- en: '[PRE24]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Instead of constantly using `GetLocalRole() == ROLE_Authority` to check whether
    the actor has authority, you can use the `HasAuthority()` helper function, defined
    in `AActor`.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 不要不断使用`GetLocalRole() == ROLE_Authority`来检查角色是否具有权限，可以使用`AActor`中定义的`HasAuthority()`辅助函数。
- en: 'Next, open `OwnershipRolesCharacter.h` and declare the `Tick` function as protected:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，打开`OwnershipRolesCharacter.h`并将`Tick`函数声明为受保护的：
- en: '[PRE25]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, open `OwnershipRolesCharacter.cpp` and include the header files as shown
    in the following code snippet:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开`OwnershipRolesCharacter.cpp`并按照以下代码片段中所示包含头文件：
- en: '[PRE26]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Implement the `Tick` function:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`Tick`函数：
- en: '[PRE27]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Convert the values for the local/remote roles (using the `ROLE_TO_STRING` macro
    we created earlier), the current owner, and the connection to strings:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将本地/远程角色的值（使用我们之前创建的`ROLE_TO_STRING`宏），当前所有者和连接转换为字符串：
- en: '[PRE28]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Use `DrawDebugString` to display onscreen the strings we converted in the previous
    step:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`DrawDebugString`在屏幕上显示我们在上一步中转换的字符串：
- en: '[PRE29]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Finally, we can test the project.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以测试项目。
- en: Run the code and wait for the editor to fully load.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并等待编辑器完全加载。
- en: Create a new Blueprint called `OwnershipTestActor_BP` in the `Content` folder
    that derives from `OwnershipTestActor`. Set `Mesh` to use a cube mesh, and drop
    an instance of it in the world.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Content`文件夹中创建一个名为`OwnershipTestActor_BP`的新蓝图，它派生自`OwnershipTestActor`。将`Mesh`设置为使用立方体网格，并在世界中放置一个实例。
- en: Go to `Multiplayer Options` and set the number of clients to `2`.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到`多人游戏选项`并将客户端数量设置为`2`。
- en: Set the window size to `800x600`.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将窗口大小设置为`800x600`。
- en: Play using `New Editor Window (PIE)`.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`New Editor Window (PIE)`进行游戏。
- en: 'You should get the following output:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该得到以下输出：
- en: '![Figure 16.8: Expected result on the server and Client 1 window'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.8：服务器和Client 1窗口上的预期结果'
- en: '](img/B16183_16_08.jpg)'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_16_08.jpg)'
- en: 'Figure 16.8: Expected result on the server and Client 1 window'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.8：服务器和Client 1窗口上的预期结果
- en: By completing this exercise, you'll have a better understanding of how connections
    and ownership works. These are important concepts to know as everything related
    to replication is dependent on them.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成这个练习，你将更好地理解连接和所有权是如何工作的。这些是重要的概念，因为与复制相关的一切都依赖于它们。
- en: Next time you see that an actor is not doing replication operations, you'll
    know that you need to check first whether it has a **valid connection** and an
    **owner**.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 下次当你看到一个角色没有进行复制操作时，你会知道需要首先检查它是否有**有效的连接**和**所有者**。
- en: Now, let's analyze the displayed values in the server and client windows.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们分析服务器和客户端窗口中显示的值。
- en: The Server Window
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务器窗口
- en: 'Have a look at the following output screenshot of the `Server` window from
    the previous exercise:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下上一个练习中`Server`窗口的以下输出截图：
- en: '![Figure 16.9: The Server window'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.9：服务器窗口'
- en: '](img/B16183_16_09.jpg)'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_16_09.jpg)'
- en: 'Figure 16.9: The Server window'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.9：服务器窗口
- en: Note
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The text that says `Server Character`, `Client 1 Character`, and `Ownership
    Test Actor` is not part of the original screenshot and was added to help you understand
    which character and actor is which.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 显示`Server Character`，`Client 1 Character`和`Ownership Test Actor`的文本不是原始截图的一部分，是为了帮助你理解哪个角色和角色是哪个而添加的。
- en: In the preceding screenshot, you can see `Server Character`, `Client 1 Character`,
    and the `Ownership Test` cube actor.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的截图中，你可以看到`Server Character`，`Client 1 Character`和`Ownership Test`立方体角色。
- en: Let's first analyze the values for `Server Character`.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 首先分析`Server Character`的值。
- en: Server Character
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务器角色
- en: 'This is the character that the listen server is controlling. The values associated
    with this character are as follows:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 这是监听服务器正在控制的角色。与这个角色相关的值如下：
- en: '`LocalRole = ROLE_Authority`: because this character was spawned on the server,
    which is the current game instance.'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LocalRole = ROLE_Authority`：因为这个角色是在服务器上生成的，这是当前的游戏实例。'
- en: '`RemoteRole = ROLE_SimulatedProxy`: because this character was spawned on the
    server, so the other clients should only simulate it.'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RemoteRole = ROLE_SimulatedProxy`：因为这个角色是在服务器上生成的，所以其他客户端只能模拟它。'
- en: '`Owner = PlayerController_0`: because this character is being controlled by
    the client of the listen server, which uses the first `PlayerController` instance
    called `PlayerController_0`.'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Owner = PlayerController_0`：因为这个角色由监听服务器的客户端控制，使用了名为`PlayerController_0`的第一个`PlayerController`实例。'
- en: '`Connection = Invalid Connection`: because we''re the client of the listen
    server, so there is no need for a connection.'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Connection = Invalid Connection`：因为我们是监听服务器的客户端，所以不需要连接。'
- en: Next, we are going to be looking at `Client 1 Character` in the same window.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在同一个窗口中查看`Client 1 Character`。
- en: Client 1 Character
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Client 1 Character
- en: 'This is the character that `Client 1` is controlling. The values associated
    with this character are as follows:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`Client 1`正在控制的角色。与这个角色相关的值如下：
- en: '`LocalRole = ROLE_Authority`: because this character was spawned on the server,
    which is the current game instance.'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LocalRole = ROLE_Authority`：因为这个角色是在服务器上生成的，这是当前的游戏实例。'
- en: '`RemoteRole = ROLE_AutonomousProxy`: because this character was spawned on
    the server, but it''s being controlled by another client.'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RemoteRole = ROLE_AutonomousProxy`：因为这个角色是在服务器上生成的，但是由另一个客户端控制。'
- en: '`Owner = PlayerController_1`: because this character is being controlled by
    another client, which uses the second `PlayerController` instance called `PlayerController_1`.'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Owner = PlayerController_1`：因为这个角色是由另一个客户端控制的，使用了名为`PlayerController_1`的第二个`PlayerController`实例。'
- en: '`Connection = Valid Connection`: because this character is being controlled
    by another client, so a connection to the server is required.'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Connection = Valid Connection`：因为这个角色由另一个客户端控制，所以需要与服务器建立连接。'
- en: Next, we are going to be looking at the `OwnershipTest` actor in the same window.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在同一个窗口中查看`OwnershipTest`角色。
- en: The OwnershipTest Actor
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OwnershipTest Actor
- en: 'This is the cube actor that will set its owner to the closest character within
    a certain ownership radius. The values associated with this actor are as follows:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 这是将其所有者设置为一定所有权半径内最近的角色的立方体演员。与该演员相关的值如下：
- en: '`LocalRole = ROLE_Authority`: because this actor was placed in the level and
    spawned on the server, which is the current game instance.'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LocalRole = ROLE_Authority`：因为这个演员被放置在级别中，并在服务器上生成，这是当前游戏实例。'
- en: '`RemoteRole = ROLE_SimulatedProxy`: because this actor was spawned in the server,
    but it''s not being controlled by any client.'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RemoteRole = ROLE_SimulatedProxy`：因为这个演员是在服务器中生成的，但没有被任何客户端控制。'
- en: '`Owner` and `Connection` will have their values based on the closest character.
    If there isn''t a character inside the ownership radius, then they will have the
    values of `No Owner` and `Invalid Connection`.'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Owner`和`Connection`的值将基于最近的角色。如果在所有权半径内没有角色，则它们将具有`无所有者`和`无效连接`的值。'
- en: 'Now, let''s have a look at the `Client 1` window:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一下`Client 1`窗口：
- en: '![Figure 16.10: The Client 1 window'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.10：客户端1窗口'
- en: '](img/B16183_16_10.jpg)'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16183_16_10.jpg)'
- en: 'Figure 16.10: The Client 1 window'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.10：客户端1窗口
- en: The Client 1 Window
  id: totrans-304
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 客户端1窗口
- en: The values for the `Client 1` window will be exactly the same as the `Server`
    window, except the values of `LocalRole` and `RemoteRole` will be reversed because
    they are always relative to the game instance that you are in.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '`Client 1`窗口的值将与`Server`窗口的值完全相同，只是`LocalRole`和`RemoteRole`的值将被颠倒，因为它们始终相对于您所在的游戏实例。'
- en: Another exception is that the server character has no owner and the other connected
    clients won't have a valid connection. The reason for that is clients don't store
    player controllers and connections of other clients, only the server does, but
    this will be covered in more depth in *Chapter 18*, *Gameplay Framework Classes
    in Multiplayer*.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例外是服务器角色没有所有者，其他连接的客户端将没有有效连接。原因是客户端不存储其他客户端的玩家控制器和连接，只有服务器才会存储，但这将在*第18章*中更深入地介绍*多人游戏中的游戏框架类*。
- en: In the next section, we will be looking at variable replication.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看一下变量复制。
- en: Variable Replication
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量复制
- en: One of the ways the server can keep the clients synchronized is by using variable
    replication. The way it works is that every specific number of times per second
    (defined per actor in the `AActor::NetUpdateFrequency` variable, which is also
    exposed to blueprints) the variable replication system in the server will check
    whether there are any replicated variables (*explained in the next section*) in
    the client that needs to be updated with the latest value.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器可以使客户端保持同步的一种方式是使用变量复制。其工作方式是，每秒特定次数（在`AActor::NetUpdateFrequency`变量中为每个演员定义，也暴露给蓝图）服务器中的变量复制系统将检查是否有任何需要使用最新值更新的客户端中的复制变量（*在下一节中解释*）。
- en: If the variable meets all of the replication conditions, then the server will
    send an update to the client and enforce the new value.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 如果变量满足所有复制条件，那么服务器将向客户端发送更新并强制执行新值。
- en: For example, if you have a replicated `Health` variable and the client on its
    end uses a hacking tool to set the value of the variable from `10` to `100`, then
    the replication system will enforce the real value from the server and change
    it back to `10`, which nullifies the hack.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您有一个复制的`Health`变量，并且客户端使用黑客工具将变量的值从`10`设置为`100`，那么复制系统将强制从服务器获取真实值并将其更改回`10`，从而使黑客无效。
- en: 'Variables are only sent to the client to be updated if:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在以下情况下才会将变量发送到客户端进行更新：
- en: The variable is set to replicate.
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量被设置为复制。
- en: The value was changed on the server.
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值已在服务器上更改。
- en: The value on the client is different than on the server.
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端上的值与服务器上的值不同。
- en: The actor has replication enabled.
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 演员已启用复制。
- en: The actor is relevant and meets all of the replication conditions.
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 演员是相关的，并满足所有复制条件。
- en: One important thing to take into consideration is that the logic that determines
    whether a variable should be replicated or not is only executed `AActor::NetUpdateFrequency`
    times a second. In other words, the server doesn't send an update request to a
    client immediately after you change the value of a variable on the server. It
    will only send that request when the variable replication system executes, which
    is `AActor::NetUpdateFrequency` times a second, and it has determined that the
    values from the client are different than the values from the server.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 需要考虑的一个重要事项是，确定变量是否应该复制的逻辑仅在每秒执行`AActor::NetUpdateFrequency`次。换句话说，服务器在更改服务器上的变量值后不会立即向客户端发送更新请求。只有在变量复制系统执行时（每秒`AActor::NetUpdateFrequency`次），并且确定客户端的值与服务器的值不同时，才会发送该请求。
- en: An example would be if you had an integer replicate a variable called `Test`
    that has a default value of `5`. If you call a function on the server that sets
    `Test` to `3` and in the next line changes it to `8`, then only the latter change
    would send an update request to the clients. The reason for this is these two
    changes were made in between the `NetUpdateFrequency` interval, so when the variable
    replication system executes, the current value is `8`, and as that is different
    to the value of the clients (which is still `5`), it will update them. If instead
    of setting it to `8`, you set it back to `5`, then no changes would be sent to
    the clients.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您有一个整数复制一个名为`Test`的变量，其默认值为`5`。如果您在服务器上调用一个将`Test`设置为`3`的函数，并在下一行将其更改为`8`，那么只有后者的更改会发送更新请求到客户端。原因是这两个更改是在`NetUpdateFrequency`间隔之间进行的，因此当变量复制系统执行时，当前值为`8`，因为它与客户端的值不同（仍为`5`），它将更新它们。如果您将其设置回`5`，则不会向客户端发送任何更改。
- en: Replicated Variables
  id: totrans-320
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复制变量
- en: In Unreal Engine, any variable that can use the `UPROPERTY` macro can be set
    to replicate, and you can use two specifiers to do that.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在虚幻引擎中，任何可以使用`UPROPERTY`宏的变量都可以设置为复制，并且可以使用两个限定词来执行此操作。
- en: '**Replicated**'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '**复制**'
- en: If you just want to say that a variable is replicated, then you use the `Replicated` specifier.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只想说一个变量被复制，那么你使用`Replicated`修饰符。
- en: 'Have a look at the following example:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 看下面的例子：
- en: '[PRE30]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In the preceding code snippet, we declare a float variable called `Health`,
    as we normally do. The difference is that we've added `UPROPERTY(Replicated)`
    to tell Unreal Engine that the `Health` variable will be replicated.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码片段中，我们声明了一个名为`Health`的浮点变量，就像我们通常做的那样。不同之处在于，我们添加了`UPROPERTY(Replicated)`，告诉虚幻引擎`Health`变量将被复制。
- en: '**RepNotify**'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '**RepNotify**'
- en: 'If you want to say that a variable is replicated and calls a function every
    time it''s updated, then you use the `ReplicatedUsing=<Function Name>` specifier.
    Have a look at the following example:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想说一个变量被复制并且每次更新时都调用一个函数，那么你使用`ReplicatedUsing=<Function Name>`修饰符。看下面的例子：
- en: '[PRE31]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In the preceding code snippet, we declare a float variable called `Health`.
    The difference is that we've added `UPROPERTY(ReplicatedUsing=OnRep_Health)` to
    tell Unreal Engine that this variable will be replicated and every time it's updated
    it will call the `OnRep_Health` function, which, in this specific case, will call
    a function to update `HUD`.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码片段中，我们声明了一个名为`Health`的浮点变量。不同之处在于，我们添加了`UPROPERTY(ReplicatedUsing=OnRep_Health)`，告诉虚幻引擎这个变量将被复制，并且每次更新时都会调用`OnRep_Health`函数，在这种特定情况下，它将调用一个函数来更新`HUD`。
- en: Typically, the naming scheme for the callback function is `OnRepNotify_<Variable
    Name>` or `OnRep_<Variable Name>`.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，回调函数的命名方案是`OnRepNotify_<Variable Name>`或`OnRep_<Variable Name>`。
- en: Note
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The function used in the `ReplicatingUsing` specifier needs to be marked as
    `UFUNCTION()`.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ReplicatingUsing`修饰符中使用的函数需要标记为`UFUNCTION()`。
- en: '**GetLifetimeReplicatedProps**'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '**GetLifetimeReplicatedProps**'
- en: Besides marking the variable as replicated, you'll also need to implement the
    `GetLifetimeReplicatedProps` function in the actor's `cpp` file. One thing to
    take into consideration is that this function is declared internally once you
    have at least one replicated variable, so you shouldn't declare it in the actor's
    header file. The purpose of this function is for you to tell how each replicated
    variable should replicate. You do this by using the `DOREPLIFETIME` macro and
    its variants on every variable that you want to replicate.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 除了将变量标记为复制外，您还需要在角色的`cpp`文件中实现`GetLifetimeReplicatedProps`函数。需要考虑的一件事是，一旦您至少有一个复制的变量，此函数将在内部声明，因此您不应该在角色的头文件中声明它。这个函数的目的是告诉您每个复制的变量应该如何复制。您可以通过在您想要复制的每个变量上使用`DOREPLIFETIME`宏及其变体来实现这一点。
- en: '**DOREPLIFETIME**'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '**DOREPLIFETIME**'
- en: This macro tells the replication system that the replicated variable (entered
    as an argument) will replicate to all clients without a replication condition.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 这个宏告诉复制系统，复制的变量（作为参数输入）将在没有复制条件的情况下复制到所有客户端。
- en: 'Here''s its syntax:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是它的语法：
- en: '[PRE32]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Have a look at the following example:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 看下面的例子：
- en: '[PRE33]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In the preceding code snippet, we use the `DOREPLIFETIME` macro to tell the
    replication system that the `Health` variable in the `AVariableReplicationActor`
    class will replicate without an extra condition.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码片段中，我们使用`DOREPLIFETIME`宏告诉复制系统，`AVariableReplicationActor`类中的`Health`变量将在没有额外条件的情况下复制。
- en: '**DOREPLIFETIME_CONDITION**'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '**DOREPLIFETIME_CONDITION**'
- en: This macro tells the replication system that the replicated variable (entered
    as an argument) will replicate only to the clients that meet the condition (entered
    as an argument).
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 这个宏告诉复制系统，复制的变量（作为参数输入）只会根据满足的条件（作为参数输入）复制给客户端。
- en: 'Here''s the syntax:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是语法：
- en: '[PRE34]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The condition parameter can be one of the following values:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 条件参数可以是以下值之一：
- en: '`COND_InitialOnly`: The variable will only replicate once, with the initial replication.'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`COND_InitialOnly`：变量只会复制一次，进行初始复制。'
- en: '`COND_OwnerOnly`: The variable will only replicate to the owner of the actor.'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`COND_OwnerOnly`：变量只会复制给角色的所有者。'
- en: '`COND_SkipOwner`: The variable won''t replicate to the owner of the actor.'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`COND_SkipOwner`：变量不会复制给角色的所有者。'
- en: '`COND_SimulatedOnly`: The variable will only replicate to actors that are simulating.'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`COND_SimulatedOnly`：变量只会复制到正在模拟的角色。'
- en: '`COND_AutonomousOnly`: The variable will only replicate to actors that are autonomous.'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`COND_AutonomousOnly`：变量只会复制给自主角色。'
- en: '`COND_SimulatedOrPhysics`: The variable will only replicate to actors that
    are simulating or to actors with `bRepPhysics` set to true.'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`COND_SimulatedOrPhysics`：变量只会复制到正在模拟的角色或`bRepPhysics`设置为true的角色。'
- en: '`COND_InitialOrOwner`: The variable will only replicate once, with the initial
    replication or to the owner of the actor.'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`COND_InitialOrOwner`：变量只会进行初始复制，或者只会复制给角色的所有者。'
- en: '`COND_Custom`: The variable will only replicate if its `SetCustomIsActiveOverride`
    Boolean condition (used in the `AActor::PreReplication` function) is true.'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`COND_Custom`：变量只有在其`SetCustomIsActiveOverride`布尔条件（在`AActor::PreReplication`函数中使用）为true时才会复制。'
- en: 'Have a look at the following example:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 看下面的例子：
- en: '[PRE35]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In the preceding code snippet, we use the `DOREPLIFETIME_CONDITION` macro to
    tell the replication system that the `Health` variable in the `AVariableReplicationActor`
    class will replicate only for the owner of this actor.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码片段中，我们使用`DOREPLIFETIME_CONDITION`宏告诉复制系统，`AVariableReplicationActor`类中的`Health`变量只会为该角色的所有者复制。
- en: Note
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'There are more `DOREPLIFETIME` macros available, but they won''t be covered
    in this book. To see all of the variants, please check the `UnrealNetwork.h` file
    from the Unreal Engine 4 source code. See the instructions at: [https://docs.unrealengine.com/en-US/GettingStarted/DownloadingUnrealEngine/index.html](https://docs.unrealengine.com/en-US/GettingStarted/DownloadingUnrealEngine/index.html).'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 还有更多的`DOREPLIFETIME`宏可用，但本书不会涵盖它们。要查看所有变体，请检查虚幻引擎4源代码中的`UnrealNetwork.h`文件。请参阅以下说明：[https://docs.unrealengine.com/en-US/GettingStarted/DownloadingUnrealEngine/index.html](https://docs.unrealengine.com/en-US/GettingStarted/DownloadingUnrealEngine/index.html)。
- en: 'Exercise 16.03: Replicating Variables Using Replicated, RepNotify, DOREPLIFETIME,
    and DOREPLIFETIME_CONDITION'
  id: totrans-361
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we''re going to create a C++ project that uses the Third
    Person template as a base and add two variables to the character that replicate
    in the following way:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: Variable `A` is a float that will use the `Replicated UPROPERTY` specifier and
    the `DOREPLIFETIME` macro.
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variable `B` is an integer that will use the `ReplicatedUsing UPROPERTY` specifier
    and the `DOREPLIFETIME_CONDITION` macro.
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following steps will help you complete the exercise:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: Create a new `Third Person` template project using `C++` called `VariableReplication`
    and save it to a location of your choosing.
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the project has been created, it should open the editor as well as the
    Visual Studio solution.
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Close the editor and go back to Visual Studio.
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `VariableReplicationCharacter.h` file.
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, include the `UnrealNetwork.h` header file before the `VariableReplicationCharacter.generated.h`,
    which has the definition of the `DOREPLIFETIME` macros that we''re going to use:'
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Declare the protected variables `A` and `B` as `UPROPERTY` using their respective
    replication specifiers:'
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Declare the `Tick` function as protected:'
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Since we''ve declared variable `B` as `ReplicatedUsing = OnRepNotify_B`, then
    we also need to declare the protected `OnRepNotify_B` callback function as `UFUNCTION`:'
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now, open the `VariableReplicationCharacter.cpp` file and include the headers
    `Engine.h`, so we can use the `AddOnScreenDebugMessage` function, and `DrawDebugHelpers.h`,
    so we can use the `DrawDebugString` function:'
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Implement the `GetLifetimeReplicatedProps` function:'
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Set that as the `A` variable, which will replicate without any extra conditions:'
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Set that as the `B` variable, which will only replicate to the owner of this
    actor:'
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Implement the `Tick` function:'
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Next, run the authority-specific logic that adds `1` to `A` and `B`:'
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Since this character will be spawned on the server, then only the server will
    execute this logic.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: 'Display the values of `A` and `B` on the location of the character:'
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Implement the `RepNotify` function for variable `B`, which displays on the
    screen a message saying that the `B` variable was changed to a new value:'
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Finally, you can test the project:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: Run the code and wait for the editor to fully load.
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to `Multiplayer Options` and set the number of clients to `2`.
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the window size to `800x600`.
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Play using `New Editor Window (PIE)`.
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you complete this exercise, you will be able to play on each client and
    you'll notice that the characters are displaying their respective values for `A`
    and `B`.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's analyze the values displayed in the `Server` and `Client 1` windows.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: The Server Window
  id: totrans-402
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the `Server` window, you have the values for `Server Character`, which is
    the character controlled by the server, and in the background, you have values
    for `Client 1 Character`:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.11: The Server window'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_16_11.jpg)'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 16.11: The Server window'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: 'The outputs that can be observed are as follows:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: '`Server` `Character` – `A = 674.00 B = 574`'
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Client 1` `Character` – `A = 670.00 B = 570`'
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At this specific point in time, `Server` `Character` has a value of `674` for
    `A` and `574` for `B`. The reason why `A` and `B` have different values is because
    `A` starts at `100` and `B` starts at `0`, which is the correct value after `574`
    ticks of `A++` and `B++`.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: As for why the `Client 1` `Character` doesn't have the same values as the Server
    Character, that is because `Client 1` was created slightly after the server, so
    in this case, the count will be off by `4` ticks of `A++` and `B++`.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will be looking at the `Client 1` window.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: The Client 1 Window
  id: totrans-413
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the `Client 1` window, you have the values for `Client 1 Character`, which
    is the character controlled by `Client 1`, and in the background, you have values
    for `Server Character`:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.12: The Client 1 window'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_16_12.jpg)'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 16.12: The Client 1 window'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: 'The outputs that can be observed are as follows:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: '`Server` `Character` – `A = 674.00 B = 0`'
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Client 1` `Character` – `A = 670.00 B = 570`'
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Client 1 Character` has the correct values from the server, so the variable
    replication is working as intended. If you look at `Server Character`, `A` is
    `674`, which is correct, but `B` is `0`. The reason for that is `A` is using `DOREPLIFETIME`,
    which doesn''t add any additional replication conditions, so it will replicate
    the variable and keep the client up to date every time the variable is changed
    on the server.'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: The variable `B`, on the other hand, uses `DOREPLIFETIME_CONDITION` with `COND_OwnerOnly`,
    and since `Client 1` is not the client that owns `Server Character` (*the client
    of the listen server is*), then the value is not replicated and remains unchanged
    from the default value of `0`.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: If you go back to the code and change the replication condition of `B` to use
    `COND_SimulatedOnly` instead of `COND_OwnerOnly`, you'll notice that the results
    will be reversed in `Client 1 window`. The value of `B` will be replicated for
    `Server Character`, but it won't replicate for its own character.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: The reason why the `RepNotify` message is showing in the `Server` window instead
    of the client window is that, when playing in the editor, both windows share the
    same process, and therefore printing text on the screen won't be accurate. To
    get the correct behavior, you'll need to run the packaged version of the game.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: 2D Blend Spaces
  id: totrans-426
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In *Chapter 2*, *Working with Unreal Engine*, we created a 1D Blend Space to
    blend between the movement states (*idle, walk, and run*) of a character based
    on the value of the Speed axis. For that specific example, it worked pretty well
    because you only needed one axis, but if we wanted the character to also be able
    to strafe, then we couldn't really do that.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: To explore that case, Unreal Engine allows you to create 2D Blend Spaces. The
    concepts are almost exactly the same; the only difference is that you have an
    extra axis for animations, so you can blend between them not only horizontally,
    but also vertically.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 16.04: Creating a Movement 2D Blend Space'
  id: totrans-429
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we're going to create a Blend Space that uses two axes instead
    of one. The vertical axis will be `Speed`, which will be between `0` and `800`.
    The horizontal axis will be `Direction`, which represents the relative angle (`-180
    to 180`) between the velocity and the rotation/forward vector of the pawn.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure will help you calculate the direction in this exercise:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.13: Direction values based on the angle between the forward'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: vector and the velocity
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_16_13.jpg)'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 16.13: Direction values based on the angle between the forward vector
    and the velocity'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding figure, you can see how the direction will be calculated. The
    forward vector represents the direction that the character is currently facing,
    and the numbers represent the angle that the forward vector would make with the
    velocity vector if it was pointing in that direction. If the character was looking
    in a certain direction and you pressed a key to move the character to the right,
    then the velocity vector would be perpendicular to the forward vector. That would
    mean that the angle would be 90º, so that would be our direction.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: If we set up our 2D Blend Space with that logic in mind, we can use the correct
    animation based on the character's movement angle.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps will help you complete the exercise:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: Create a new `Third Person` template project using `Blueprints` called `Blendspace2D`
    and save it to a location of your choosing.
  id: totrans-439
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the project has been created, it should open the editor.
  id: totrans-440
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, you will be importing the movement animations. In the editor, go to the
    `Content\Mannequin\Animations` folder.
  id: totrans-441
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the `Import` button.
  id: totrans-442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to the `Chapter16\Exercise16.04\Assets` folder, select all of the `fbx` files,
    and hit the `Open` button.
  id: totrans-443
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the import dialog, make sure you pick the character's skeleton and hit the
    `Import All` button.
  id: totrans-444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save all of the new files in the `Assets` folder.
  id: totrans-445
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the `Add New` button and pick `Animation -> Blend Space`.
  id: totrans-446
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, select the character's skeleton.
  id: totrans-447
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename the Blend Space `BS_Movement` and open it.
  id: totrans-448
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the horizontal `Direction` axis `(-180 to 180)` and the vertical `Speed`
    axis `(0 to 800)` as shown in the following figure:![Figure 16.14: 2D Blend Space
    Axis Settings'
  id: totrans-449
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_16_14.jpg)'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 16.14: 2D Blend Space Axis Settings'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: Drag the `Idle_Rifle_Ironsights` animation onto the `5` grid entries where `Speed`
    is `0`.
  id: totrans-452
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the `Walk_Fwd_Rifle_Ironsights` animation where `Speed` is `800` and `Direction`
    is `0`.
  id: totrans-453
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the `Walk_Lt_Rifle_Ironsights` animation where `Speed` is `800` and `Direction`
    is `-90`.
  id: totrans-454
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the `Walk_Rt_Rifle_Ironsights` animation where `Speed` is `800` and `Direction`
    is `90`.
  id: totrans-455
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You should end up with a Blend Space that can be previewed by holding *Shift*
    and moving the mouse.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: Now, on the `Asset Details` panel, set the `Target Weight Interpolation Speed
    Per Sec` variable to `5` to make the interpolation smoother.
  id: totrans-457
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save and close the Blend Space.
  id: totrans-458
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, update the animation Blueprint to use the new Blend Space.
  id: totrans-459
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to `Content\Mannequin\Animations` and open the file that comes along with
    the Third Person template – `ThirdPerson_AnimBP`.
  id: totrans-460
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, go to the event graph and create a new float variable called `Direction`.
  id: totrans-461
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set the value of `Direction` with the result of the `Calculate Direction` function,
    which calculates the angle (-180º to 180º) between the pawn''s `velocity` and
    `rotation`:![Figure 16.15: Calculating the Speed and Direction to use on the 2D
    Blend Space'
  id: totrans-462
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_16_15.jpg)'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 16.15: Calculating the Speed and Direction to use on the 2D Blend Space'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the preceding screenshot in full resolution for better viewing
    at the following link: [https://packt.live/3pAbbAl](https://packt.live/3pAbbAl).'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: 'In `AnimGraph`, go to the `Idle/Run` state where the old 1D Blend Space is
    being used, as shown in the following screenshot:![Figure 16.16: Idle/run state
    in the AnimGraph'
  id: totrans-467
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_16_16.jpg)'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 16.16: Idle/run state in the AnimGraph'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: 'Replace that Blend Space with `BS_Movement` and use the `Direction` variable
    like so:![Figure 16.17: 1D Blend Space has been replaced by the new 2D Blend Space'
  id: totrans-470
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_16_17.jpg)'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 16.17: 1D Blend Space has been replaced by the new 2D Blend Space'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: Save and close the animation Blueprint. Now you need to update the character.
  id: totrans-473
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to the `Content\ThirdPersonBP\Blueprints` folder and open `ThirdPersonCharacter`.
  id: totrans-474
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the `Details` panel for the character, set `Use Controller Rotation Yaw`
    to `true`, which will make the character's `Yaw` rotation always face the control
    rotation's Yaw.
  id: totrans-475
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to the character movement component and set `Max Walk Speed` to `800`.
  id: totrans-476
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set `Orient Rotation to Movement` to `false`, which will prevent the character
    from rotating toward the direction of the movement.
  id: totrans-477
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save and close the character Blueprint.
  id: totrans-478
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you play the game now with two clients and move the character, it will walk
    forward and backward, but it will also strafe, as shown in the following screenshot:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.18: Expected output on the server and Client 1 windows'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_16_18.jpg)'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 16.18: Expected output on the server and Client 1 windows'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
- en: By completing this exercise, you will have improved your understanding of how
    to create 2D Blend Spaces, how they work, and the advantages they provide compared
    to just using the regular 1D Blend Space.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will be looking at transforming a character's bone so
    that we can rotate the torso of the player up and down based on the camera's Pitch.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
- en: Transform (Modify) Bone
  id: totrans-485
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we move on, there is a very useful node that you can use in the AnimGraph
    called the `Transform (Modify) Bone` node, which allows you to translate, rotate,
    and scale a bone of a skeleton at *runtime*.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
- en: You can add it in the `AnimGraph` by *right-clicking* on an empty space, typing
    `transform modify`, and picking the node from the list. If you click on the `Transform
    (Modify) Bone` node, you'll have quite a few options on the `Details` panel.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
- en: Here's an explanation of what each option does.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
- en: The `Bone to Modify` option will tell the node what bone is going to be transformed.
  id: totrans-489
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After that option, you have three sections representing each transform operation
    (`Translation`, `Rotation`, and `Scale`). In each section, you can do the following:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
- en: '`Translation, Rotation, Scale`: This option will tell the node how much of
    that specific transform operation you want to apply. The final result will depend
    on the mode (*covered in the next section*) you have selected.'
  id: totrans-491
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are two ways you can set this value:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
- en: Setting a constant value such as (`X=0.0,Y=0.0,Z=0.0`)
  id: totrans-493
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using a variable, so it can be changed at runtime. To enable this, you need
    to take the following steps (this example is for `Rotation`, but the same concepts
    apply for `Translation` and `Scale`):'
  id: totrans-494
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Click the checkbox next to the constant value and make sure it is checked.
    Once you do that, the text boxes for the constant value will disappear.![Figure
    16.19: Check the checkbox'
  id: totrans-495
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_16_19.jpg)'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 16.19: Check the checkbox'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
- en: '`Transform (Modify) Bone` will add an input so you can plug in your variable:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.20: Variable used as an input on the Transform (Modify) Bone node'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_16_20.jpg)'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 16.20: Variable used as an input on the Transform (Modify) Bone node'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
- en: '**Setting the mode**'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
- en: 'This will tell the node what to do with the value. You can pick from one of
    these three options:'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
- en: '`Ignore`: Don''t do anything with the supplied value.'
  id: totrans-504
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Add to Existing`: Grab the current value of the bone and add the supplied
    value to it.'
  id: totrans-505
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Replace Existing`: Replace the current value of the bone with the supplied value.'
  id: totrans-506
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Setting the space**'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
- en: 'This will define the space the node should apply the transform to. You can
    pick from one of these four options:'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
- en: '`World Space`: The transform will happen in the world space.'
  id: totrans-509
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Component Space`: The transform will happen in the skeletal mesh component
    space.'
  id: totrans-510
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Parent Bone Space`: The transform will happen in the parent bone''s space
    of the selected bone.'
  id: totrans-511
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Bone Space`: The transform will happen in the space of the selected bone.'
  id: totrans-512
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Last but not least, you have the `Alpha`, which is a value that allows you
    to control the amount of transform that you want to apply. As an example, if you
    have the `Alpha` value as a float, then you''ll have the following behavior with
    different values:'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
- en: If `Alpha` is 0.0, then no transform will be applied.
  id: totrans-514
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If `Alpha` is 0.5, then it will only apply half of the transform.
  id: totrans-515
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If `Alpha` is 1.0, then it will apply the entire transform.
  id: totrans-516
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next exercise, we will use the `Transform (Modify) Bone` node to enable
    the character from *Exercise 16.04*, *Creating a Movement 2D Blend Space*, to
    look up and down based on the camera's rotation.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 16.05: Creating a Character That Looks up and down'
  id: totrans-518
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we're going to duplicate the project from *Exercise 16.04*,
    *Creating a Movement 2D Blend Space*, and enable the character to look up and
    down based on the camera's rotation. To achieve this, we're going to use the `Transform
    (Modify) Bone` node to rotate the `spine_03` bone in the component space based
    on the Pitch of the camera.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps will help you complete the exercise:'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
- en: First, you need to duplicate and rename the project from *Exercise 16.04*, *Creating
    a Movement 2D Blend Space*.
  id: totrans-521
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the `Blendspace2D` project folder from *Exercise 16.04*, *Creating a Movement
    2D Blend Space*, paste it in a new folder, and rename it `TransformModifyBone`.
  id: totrans-522
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the new project folder, rename the `Blendspace2D.uproject` file `TransformModifyBone.uproject`,
    and open it.
  id: totrans-523
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, you will be updating the animation Blueprint.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
- en: Go to `Content\Mannequin\Animations` and open `ThirdPerson_AnimBP`.
  id: totrans-525
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Go to the `Event Graph`, create a float variable called `Pitch`, and set it
    with the Pitch of the subtraction (or delta) between the pawn''s rotation and
    the base aim rotation, as shown in the following figure:![Figure 16.21: Calculating
    the Pitch'
  id: totrans-526
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_16_21.jpg)'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 16.21: Calculating the Pitch'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
- en: As an alternative to using the `Break Rotator` node, you can *right-click* on
    `Return Value` and pick `Split Struct Pin`.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
- en: The `Break Rotator` node allows you to separate a `Rotator` variable into three
    float variables that represent the `Pitch`, `Yaw`, and `Roll`. This is useful
    when you want to access the value of each individual component or if you only
    want to work with one or two components, and not with the whole rotation.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
- en: Take into consideration that the `Split Struct Pin` option will only appear
    if `Return` `Value` is not connected to anything. Once you do the split, it will
    create three separate wires for `Roll`, `Pitch`, and `Yaw`, just like a break
    but without the extra node.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
- en: 'You should end up with the following:'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.22: Calculating the Pitch to look up using the Split Struct Pin
    option'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_16_22.jpg)'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 16.22: Calculating the Pitch to look up using the Split Struct Pin option'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
- en: 'This logic uses the rotation of the pawn and subtracts it from the camera''s
    rotation to get the difference in `Pitch`, as shown in the following figure:'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.23: How to calculate the Delta Pitch'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_16_23.jpg)'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 16.23: How to calculate the Delta Pitch'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, go to `AnimGraph` and add a `Transform (Modify) Bone` node with the following
    settings:![Figure 16.24: Settings for the Transform (Modify) Bone node'
  id: totrans-541
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_16_24.jpg)'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 16.24: Settings for the Transform (Modify) Bone node'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding screenshot, we've set `Bone to Modify` to `spine_03` because
    that is the bone that we want to rotate. We've also set `Rotation Mode` to `Add
    to Existing` because we want to keep the original rotation from the animation
    and add an offset to it. The rest of the options need to have their default value.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
- en: 'Connect the `Transform (Modify) Bone` node to the `State Machine` and the `Output
    Pose`, as shown in the following screenshot:![Figure 16.25: Transform (Modify)
    Bone connected to the Output Pose'
  id: totrans-545
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_16_25.jpg)'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 16.25: Transform (Modify) Bone connected to the Output Pose'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding figure, you see the full `AnimGraph`, which will allow the
    character to look up and down by rotating the `spine_03` bone based on the camera
    Pitch. The `State Machine` will be the starting point, and from there, it will
    need to be converted into component space in order to be able to use the `Transform
    (Modify) Bone` node, which will connect to the `Output Pose` node after being
    converted back to local space.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
- en: The reason why we connect `Pitch` variable to the `Roll` is that the bone in
    the skeleton is internally rotated that way. You can use the `Split Struct Pin`
    on input parameters as well, so you don't have to add a `Make Rotator` node.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
- en: 'If you test the project with two clients and move the mouse *up* and *down*
    on one of the characters, you''ll notice that it will Pitch up and down, as shown
    in the following screenshot:'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.26: Character mesh pitching up and down, based on the camera rotation'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_16_26.jpg)'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 16.26: Character mesh pitching up and down, based on the camera rotation'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
- en: By completing this final exercise, you'll have an understanding of how to modify
    bones at runtime by using the `Transform (Modify) Bone` node in an animation blueprint.
    This node can be used in various scenarios, so it might prove really useful for
    you.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
- en: In the next activity, you're going to put everything you've learned to the test
    by creating the character we're going to use for our multiplayer FPS project.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 16.01: Creating a Character for the Multiplayer FPS Project'
  id: totrans-557
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this activity, you''ll create the character for the multiplayer FPS project
    that we''re going to build in the next few chapters. The character will have a
    few different mechanics, but for this activity, you just need to create a character
    that walks, jumps, looks up/down, and has two replicated stats: health and armor.'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps will help you complete the activity:'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
- en: Create a `Blank C++` project called `MultiplayerFPS` without the starter content.
  id: totrans-560
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import the skeletal mesh and the animations from the `Activity16.01\Assets folder`
    and place them in the `Content\Player\Mesh` and `Content\Player\Animations` folders
    respectively.
  id: totrans-561
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Import the following sounds from the `Activity16.01\Assets` folder to `Content\Player\Sounds`:'
  id: totrans-562
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Jump.wav`: Play this sound on the `Jump_From_Stand_Ironsights` animation with
    a `Play Sound` anim notify.'
  id: totrans-563
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Footstep.wav`: Play this sound every time a foot is on the floor in every
    walk animation by using the `Play Sound` anim notify.'
  id: totrans-564
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Spawn.wav`: Use this on the `SpawnSound` variable in the character.'
  id: totrans-565
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set up the skeletal mesh by retargeting its bones and creating a socket called
    `Camera` that is a child of the head bone and has a Relative Location of (`X=7.88,
    Y=4.73, Z=-10.00`).
  id: totrans-566
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a 2D Blend Space in `Content\Player\Animations` called `BS_Movement`
    that uses the imported movement animations and a `Target Weight Interpolation
    Speed Per Sec` of `5`.
  id: totrans-567
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the input mappings in the `Project Settings`, using the knowledge acquired
    in *Chapter 4*, *Player Input*:'
  id: totrans-568
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Jump (action mapping) – *Spacebar*
  id: totrans-569
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Move Forward (axis mapping) – *W* (scale `1.0`) and *S* (scale `-1.0`)
  id: totrans-570
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Move Right (axis mapping) – *A* (scale `-1.0`) and *D* (scale `1.0`)
  id: totrans-571
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Turn (axis mapping) – Mouse *X* (scale `1.0`)
  id: totrans-572
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Look Up (axis mapping) – Mouse *Y* (scale `-1.0`)
  id: totrans-573
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Create a C++ class called `FPSCharacter` that does the following:'
  id: totrans-574
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Derives from the `Character` class.
  id: totrans-575
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Has a camera component attached to the skeletal mesh on the `Camera` socket
    and has `pawn control rotation` set to `true`.
  id: totrans-576
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Has variables for `health` and `armor` that only replicate to the owner.
  id: totrans-577
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Has variables for the maximum `health` and `armor`, as well as the percentage
    of how much damage the armor absorbs.
  id: totrans-578
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Has a constructor that initializes the camera, disables ticking, and sets `Max
    Walk Speed` to `800` and `Jump Z Velocity` to `600`.
  id: totrans-579
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On `BeginPlay`, plays the spawning sound and initializes the `health` with `max
    health` if it has authority.
  id: totrans-580
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creates and binds the functions to handle the input actions and axis.
  id: totrans-581
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Has functions to add/remove/set health. It also ensures the situation where
    the character is dead.
  id: totrans-582
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Has functions to add/set/absorb armor. The armor absorption reduces the armor
    based on the `ArmorAbsorption` variable and changes the damage value based on
    the formula:'
  id: totrans-583
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Damage = (Damage * (1 - ArmorAbsorption)) - FMath::Min(RemainingArmor, 0);*'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an animation Blueprint in `Content\Player\Animations` called `ABP_Player`
    that has a `State Machine` with the following states:'
  id: totrans-585
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Idle/Run`: Uses `BS_Movement` with the `Speed` and `Direction` variables'
  id: totrans-586
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Jump`: Plays the jump animation and transitions from the `Idle/Run` states
    when the `Is Jumping` variable is `true`'
  id: totrans-587
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It also uses `Transform (Modify) Bone` to make the character Pitch up and down
    based on the camera's Pitch.
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `UMG` widget in `Content\UI` called `UI_HUD` that displays the `Health`
    and `Armor` of the character in the format `Health: 100` and `Armor: 100`, using
    the knowledge acquired in *Chapter 15*, *Collectibles, Power-ups, and Pickups*.'
  id: totrans-589
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a Blueprint in `Content\Player` called `BP_Player` that derives from
    `FPSCharacter` and set up the mesh component to have the following values:'
  id: totrans-590
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `SK_Mannequin` skeletal mesh
  id: totrans-591
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the `ABP_Player` animation Blueprint
  id: totrans-592
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set `Location` to be equal to (*X=0.0, Y=0.0, Z=-88.0*)
  id: totrans-593
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set `Rotation` to be equal to (*X=0.0, Y=0.0, Z=-90.0*)
  id: totrans-594
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also, on the `Begin Play` event, it needs to create a widget instance of `UI_HUD`
    and add it to the viewport.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
- en: Create a Blueprint in `Content\Blueprints` called `BP_GameMode` that derives
    from `MultiplayerFPSGameModeBase`, which will use `BP_Player` as the `DefaultPawn`
    class.
  id: totrans-596
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a test map in `Content\Maps` called `DM-Test` and set it as the default
    map in `Project Settings`.
  id: totrans-597
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Expected output:'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
- en: The result should be a project where each client will have a first-person character
    that can move, jump, and look around. These actions will also be replicated, so
    each client will be able to see what the other client's character is doing.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
- en: Each client will also have a HUD that displays the health and the armor value.
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.27: Expected output'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_16_27.jpg)'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 16.27: Expected output'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution to this activity can be found at: [https://packt.live/338jEBx](https://packt.live/338jEBx).'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
- en: The end result should be two characters that can see each other moving, jumping,
    and looking around. Each client also displays its character's health and armor
    value.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
- en: By completing this activity, you should have a good idea of how the server-client
    architecture, variable replication, roles, 2D Blend Spaces, and the `Transform
    (Modify) Bone` node work.
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-608
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned about some critical multiplayer concepts, such
    as how the server-client architecture works, the responsibilities of the server
    and the client, how the listen server is quicker to set up than the dedicated
    server but not as lightweight, ownership and connections, roles, and variable
    replication.
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
- en: We've also learned some useful techniques for animation, such as how to use
    2D Blend Spaces, which allow you to have a two-axis grid to blend between animations,
    and the Transform (Modify) Bone node, which has the ability to modify the bones
    of a skeletal mesh at runtime. To finish off the chapter, we created a first-person
    multiplayer project where you have characters that can walk, look, and jump around,
    which will be the foundation of the multiplayer first-person shooter project that
    we will be working on for the next few chapters.
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll learn how to use RPCs, which allow clients and servers
    to execute functions on each other. We'll also cover how to use enumerations in
    the editor and how to use bi-directional circular array indexing, which allows
    you to cycle forward and backward through an array and loop back when it's outside
    the limits.
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
