- en: Functors, Monoids, and Generics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"Here''s my attempt at functional programming in Go. I think it''s a good idea,
    but I''m really not sure."'
  prefs: []
  type: TYPE_NORMAL
- en: I have seen comments like this on over a dozen blog articles. I hope that after
    reading this chapter and working through the examples, you'll have a new-found
    love for functional programming (FP). Not because it's so pure that you worry
    that side-effect programming will send you to hell, but rather, because you feel
    comfortable with concepts that form the basis of pure FP and you see that its
    benefits outweigh the costs of learning how to use it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our goals in this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Appreciate how the lack of generics support in Go can be a good thing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn how to use a generics code generation tool to solve the boilerplate problem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deeply understand how function composition works
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build a few functors and understand how to map between worlds
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build a few monoids and learn how to write your own reduce functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding functors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A functor is a structure-preserving transformation between categories. In other
    words, a functor is a mappable type. Let's see what that means with an example.
  prefs: []
  type: TYPE_NORMAL
- en: An imperative versus pure FP example
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Suppose we start with a slice of ints, `ints := []int{1,2,3}`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In imperative programming, we write all the scaffold code to implement exactly
    how to process this slice of ints. In pure FP, however, we tell our functor what
    we want the loop to do:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bb333e07-c020-4551-a72f-6f87db47d65b.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here''s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Let's see how this works.
  prefs: []
  type: TYPE_NORMAL
- en: What did that Map function do for us?
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `Map` function abstracted the loop. We don't have to bother writing the
    same old range/for looping code. We simply pass in our original `ints` list and
    tell our functor to map that slice into a slice where each element is one greater
    than it was before. This is a lot like SQL, where we declare what data we want
    and let the database engine worry about how to get the data.
  prefs: []
  type: TYPE_NORMAL
- en: What possible benefits can this afford us?
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Do we have to change our SQL query code to benefit from a database engine update
    that increases the query performance? The answer is no, and the same goes for
    our pure FP code.
  prefs: []
  type: TYPE_NORMAL
- en: What if all we had to do was write `Functor(list).Map(add1)` and define our
    custom `add1` function? What if `Functor` was part of the Go Standard Library
    (or another very stable third-party package), and what if the next version of
    Go came out and it knew how to optimize performance based on the size of the list
    we passed it? Would that not be an automatic, significant benefit gained from
    simply compiling with the latest version of Go (or that other, very stable third-party
    package)?
  prefs: []
  type: TYPE_NORMAL
- en: This may not seem like a big win in terms of the lines of code written, or even
    clarity. In this case, and in smaller utility or administrative programs, it might
    not be of great benefit. The IMHO place where using FP style offers the greatest
    benefit is in business use case logic. We look for places where we need to be
    careful to not clutter business intent with noisy code like for loop scaffolding
    and error checking code blocks. Those are great places for FP-style programming.
    Other good places are where we would like to horizontally scale our application
    without worrying about race conditions or side effects.
  prefs: []
  type: TYPE_NORMAL
- en: A magical structure
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A functor can be thought of as a magical structure that can be mapped over,
    where the magical structure can be thought of as a shape with a constant set of
    elements accompanied by the ability to apply a transformation operation to each
    element.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at some examples.
  prefs: []
  type: TYPE_NORMAL
- en: Color blocks functor
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A functor consists of a structure, usually a slice in Go, and a transformation
    operation, that is, the mapping function:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Structure** | Eight blocks, each filled with a different color |'
  prefs: []
  type: TYPE_TB
- en: '| **Transformation operation** | `f(x) = x - 30`, where `x` is the hue |'
  prefs: []
  type: TYPE_TB
- en: Below, is a functor that maps eight colored blocks to eight corresponding blocks
    whose color has been altered by applying the transformation operations above to
    adjust the hue of the color displayed in the boxes.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7001a6f6-694a-4b8b-b94a-8166e7ebf186.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The preceding diagram shows a single **f(x)** arrow to keep the clutter to
    a minimum, but a more accurate representation would show arrows from each original
    element to its corresponding, new, transformed element. That''s what actually
    occurs--each element is processed inside the structure and transformed into a
    new value that is returned inside the structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cf666dbf-d617-46f4-b833-058bb997d673.png)'
  prefs: []
  type: TYPE_IMG
- en: Fingers times 10 functor
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As mentioned before, a functor consists of a structure and a transformation
    operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Structure** | Five fingers, each representing an integer |'
  prefs: []
  type: TYPE_TB
- en: '| **Transformation operation** | `f(x) = x * 10` |'
  prefs: []
  type: TYPE_TB
- en: '![](img/573afd21-9780-4895-b8d5-926181d3aa15.png)'
  prefs: []
  type: TYPE_IMG
- en: 'From the last chapter, we know that a category consists of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Grouping of objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Objects**: Dots/points/a primitive with no properties and no structure'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Morphism (arrow)**: Something that goes between two objects/elements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can you see the objects (the numbers on each finger)?
  prefs: []
  type: TYPE_NORMAL
- en: Can you see the mappings (**1** to **10**, **2** to **20**, **3** to **30**,
    and so on)?
  prefs: []
  type: TYPE_NORMAL
- en: The fact that our category is closed under multiplication, has an identity element,
    and has a mapping function (times 10), means that we've got a functor. See it?
  prefs: []
  type: TYPE_NORMAL
- en: This is a shape-preserving map that maps from one category to another; hence,
    the functor is called a category homomorphism. The **f(x)** illustrates that the
    functor is a function between two categories.
  prefs: []
  type: TYPE_NORMAL
- en: Counting on our fingers (functors) is more proof that all we really need to
    know, we are taught in kindergarten!
  prefs: []
  type: TYPE_NORMAL
- en: Definition of a functor in Haskell
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We''ve seen a **functor** in the previous chapter in the type class hierarchy
    diagram. A functor has only one type class method, `fmap`, which has a type of
    `fmap :: (a -> b) -> f a -> f b`. It says--give me a function that takes an `a`
    and returns a `b`, a structure with an `a` inside it, and I''ll give you a structure
    with a `b` inside it. The function is applied to each element inside the structure.
    The `fmap` function transforms values inside the structure.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We could use the following terms interchangeably:'
  prefs: []
  type: TYPE_NORMAL
- en: Structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Box
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The important thing to remember is that a functor operates on the element inside
    the thing (structure/container/box) and returns the structure with the transformed
    value (not the raw value).
  prefs: []
  type: TYPE_NORMAL
- en: Kinds of types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Functors in Haskell must have the kind `* -> *`. Kinds are another layer of
    types, above the concrete types in Haskell. Kinds allow us to define what behavior
    types are capable of and then connect them with the appropriate type classes.
    For example, an **Int** can act like a showable, readable, ordered, or enumerable
    thing. Values in Haskell can be classified by their type. Let''s use Haskell''s
    concise syntax to look at some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Type(Class)** | **__Kind__  ** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| **Int** | `*` | `*` represents concrete types (such as Bool, Char, or Int).
    |'
  prefs: []
  type: TYPE_TB
- en: '| **Char** | `*` | `*` represents concrete types (such as Bool, Char, or Int).
    |'
  prefs: []
  type: TYPE_TB
- en: '| **[]** | `* -> *` | [] takes a single type of kind `*` and returns a new
    type of kind `*`. |'
  prefs: []
  type: TYPE_TB
- en: '| **Maybe** | `* -> *` | A higher-kinded type that takes a single type of kind
    `*` and returns a new type of kind `*`. |'
  prefs: []
  type: TYPE_TB
- en: '| **Either** | `* -> * -> *` | A higher-kinded type that takes a single type
    of kind `*` and either returns a new type of kind `*` or returns a new type of
    kind `*`. |'
  prefs: []
  type: TYPE_TB
- en: '| **Functor** | `(* -> *) ->` Constraint | A functor is a type class, not a
    type. We define the behavior of the higher-kinded type that is a functor to be
    something that takes a kind `*` and maps it into another kind, `*`. The constraint
    refers to the fact that the functor must obey the rules defined in its algebra.
    A constraint enforces some sort of limitation. For example, a Numeric constraint
    might constrain all values of the Numeric type to be numeric. 123 passes, but
    "ABC" fails for the Numeric constraint. |'
  prefs: []
  type: TYPE_TB
- en: Maybe
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**Maybe** is a functor that maps every type to the same type with an additional
    `Nothing` value. `Maybe` is like an optional value (note that types are the objects
    in our category):'
  prefs: []
  type: TYPE_NORMAL
- en: '`data Maybe a = Just a | Nothing`'
  prefs: []
  type: TYPE_NORMAL
- en: The value of `Maybe Int` can be either just a number, such as Just 2, or Nothing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Maybe` type maps types to types. For example, it maps **Char** to **Maybe
    Char**. `fmap`, defined in the following snippet, shows how every `a -> b` function has
    a corresponding version, `Maybe a -> Maybe b`, which just returns `Nothing` when
    given `Nothing` and behaves normally otherwise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Polymorphism at a higher level
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Haskell's rich type features (type classes, parameterized algebraic data types,
    recursive data types, and so on) allow us to implement polymorphism on a much
    higher level than is currently possible in Go.
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to implement polymorphic behavior in Go. However, due to language
    limitations (the lack of generics), it requires additional code to specify each
    type that implements the desired behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: For a Golang code example that demonstrates how to leverage structs and methods
    to derive polymorphic behavior, see [http://l3x.github.io/golang-code-examples/2014/07/15/polymorphic-shapes.html](http://l3x.github.io/golang-code-examples/2014/07/15/polymorphic-shapes.html).
  prefs: []
  type: TYPE_NORMAL
- en: No Generics results in a lot of boilerplate code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Without support for generics, when we implement a list function, we must implement
    it for each type our application requires. It''s a lot of repetitive, boilerplate
    code. For example, if we must implement a `Sum` function for `int8`, `int32`,
    `float64`, and `complex128`, this is what it might look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'With generics, we would only need to implement a `Sum` function similar to
    the following one. `<T>` is a placeholder for any type we pass into `Sum` that
    supports the `+` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: It would be nice to not have to write all that repetitive boilerplate code.
    Are there any other options?
  prefs: []
  type: TYPE_NORMAL
- en: Yes. We could use the empty `interface{}` everywhere and perform reflection
    and type casting to pull the data out of the list structure and put it back into
    the generic `interface{}`, but that is not performant, and it's a lot of extra
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Solve lack of generics with metaprogramming
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Metaprogramming** (**MP**) is about writing code that writes code. In MP,
    we write programs that treat programs, even themselves, as input data. Our MP
    will read, analyze, transform, and generate code.'
  prefs: []
  type: TYPE_NORMAL
- en: Maybe we can use MP to fix what's missing in Go due to its lack of support for
    generics?
  prefs: []
  type: TYPE_NORMAL
- en: Maybe. First, let's get a better understanding of what MP is about.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: Lexers, parsers, interpreters, and compilers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Domain-Specific Languages** (**DSLs**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Aspect-Oriented Programming** (**AOP**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attributes (.NET)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Annotations (Java)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generics (.NET, Java)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Templates (C++)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Macros (C)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: method_missing (Ruby)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reflection (Go, C#, Ruby)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are several types of MP.
  prefs: []
  type: TYPE_NORMAL
- en: 'Programs that support the `eval` function can generate new code by concatenating
    strings that represent executable commands. Note: this can pose security risks
    and is generally not a best practice.'
  prefs: []
  type: TYPE_NORMAL
- en: Some languages, such as LISP, can change their own application code based on
    state information, which provides the flexibility to make new decisions at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Other statically typed languages, such as C++, have the ability to evaluate
    expressions and make compile-time decisions to generate code that can be compiled
    statically into the final executable. This is the type of MP that we'll look at
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Reflection is a form of MP where a program can observe and modify its own structure
    and behavior, such as by determining what type of data a pointer is referring
    to or returning a list of all the properties of an object.
  prefs: []
  type: TYPE_NORMAL
- en: Go does not come with support for macros or generics, so it looks like we must
    use reflection. Reflection allows our program to manipulate objects whose types
    are not known at compile time.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can create a linked list of items using the empty `interface{}`.
    That will allow us to put any type of data in our list. When we pull an item out
    of our list, we must use type assertion to assign a data type to it in order to
    use it. The problem is that this is not a type-safe operation, it''s cumbersome
    to use, and it is a slow operation. Using reflection is generally not a best practice.
    Some possible use cases include the following (none of which help us with generics):'
  prefs: []
  type: TYPE_NORMAL
- en: Calling functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recognizing interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validating fields
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For more information on reflection in Go, have a look at the following information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[golang.org/pkg/reflect/](http://golang.org/pkg/reflect/)'
  prefs: []
  type: TYPE_NORMAL
- en: '[blog.golang.org/laws-of-reflection](http://blog.golang.org/laws-of-reflection)'
  prefs: []
  type: TYPE_NORMAL
- en: '[blog.ralch.com/tutorial/golang-reflection/](http://blog.ralch.com/tutorial/golang-reflection/)'
  prefs: []
  type: TYPE_NORMAL
- en: '[blog.gopheracademy.com/birthday-bash-2014/advanced-reflection-with-go-at-hashicorp/](http://blog.gopheracademy.com/birthday-bash-2014/advanced-reflection-with-go-at-hashicorp/)'
  prefs: []
  type: TYPE_NORMAL
- en: If we shouldn't use reflection, then how can we solve this problem of repetitive,
    boilerplate code?
  prefs: []
  type: TYPE_NORMAL
- en: Generics code generation tool
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: How can we not write all that repetitive code and not take a performance hit,
    nor lose any type safety of our strongly-typed language?
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at using Go tooling to generate the boilerplate code for us. We'll
    use it to replace `interface{}` in our code with `<T>`. Here, `<T>` represents
    any type that works in the context in which it is found.
  prefs: []
  type: TYPE_NORMAL
- en: Since we'll be using real types, we'll get compile-time type safety.
  prefs: []
  type: TYPE_NORMAL
- en: The clipperhouse/gen tool
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Though there are several generics code generation tools available, let's look
    at my personal favorite, clipperhouse/gen.
  prefs: []
  type: TYPE_NORMAL
- en: 'We get the following functions for free with the clipperhouse/gen tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Aggregation** | **Filter** | **Map** | **Misc** |'
  prefs: []
  type: TYPE_TB
- en: '| [Aggregate[T]](https://clipperhouse.github.io/gen/slice/#aggregatet) | [All](https://clipperhouse.github.io/gen/slice/#all)
    | [Select[T]](https://clipperhouse.github.io/gen/slice/#selectt) | [List](https://clipperhouse.github.io/gen/optional/#list)
    |'
  prefs: []
  type: TYPE_TB
- en: '| [Average](https://clipperhouse.github.io/gen/slice/#average) | [Any](https://clipperhouse.github.io/gen/slice/#any)
    | [Where](https://clipperhouse.github.io/gen/slice/#where) | [Ring](https://clipperhouse.github.io/gen/optional/#ring)
    |'
  prefs: []
  type: TYPE_TB
- en: '| [Average[T]](https://clipperhouse.github.io/gen/slice/#averaget) | [Distinct](https://clipperhouse.github.io/gen/slice/#distinct)
    |  | [Set](https://clipperhouse.github.io/gen/optional/#set) |'
  prefs: []
  type: TYPE_TB
- en: '| [Count](https://clipperhouse.github.io/gen/slice/#count) | [DistinctBy](https://clipperhouse.github.io/gen/slice/#distinctby)
    |  | [stringer](https://clipperhouse.github.io/gen/stringer/#) |'
  prefs: []
  type: TYPE_TB
- en: '| [Max](https://clipperhouse.github.io/gen/slice/#max) | [First](https://clipperhouse.github.io/gen/slice/#first)
    |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| [Max[T]](https://clipperhouse.github.io/gen/slice/#maxt) | [GroupBy[T]](https://clipperhouse.github.io/gen/slice/#groupbyt)
    |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| [MaxBy](https://clipperhouse.github.io/gen/slice/#maxby) | [Shuffle](https://clipperhouse.github.io/gen/slice/#shuffle)
    |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| [Min](https://clipperhouse.github.io/gen/slice/#min) | [Sort](https://clipperhouse.github.io/gen/slice/#sort)
    |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| [Min[T]](https://clipperhouse.github.io/gen/slice/#mint) | [SortBy](https://clipperhouse.github.io/gen/slice/#sortby)
    |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| [MinBy](https://clipperhouse.github.io/gen/slice/#minby) |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '`gen` is a code-generation tool for Go. It''s intended to offer generics-like
    functionality for your types. Out of the box, it offers LINQ/underscore-inspired
    methods.'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/clipperhouse/gen](https://github.com/clipperhouse/gen)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Language_Integrated_Query](https://en.wikipedia.org/wiki/Language_Integrated_Query)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Underscore.js](https://en.wikipedia.org/wiki/Underscore.js)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the gen tool, we'll gain most of the benefits of generics without the
    performance hits of either reflection or type assertion.
  prefs: []
  type: TYPE_NORMAL
- en: 'What generics do for us is a lot like code generation. At runtime, when we
    pass an `a` of type `A` to a function, it seems magical that our function can
    accept the `a` and do the right thing. What happens most of the time at runtime
    (by JIT or a regular Go compiler, depending on the situation) is that Go does
    a code generation replacement operation. What happens at runtime is that our a
    gets swapped in/out of A-shaped holes in our code. This is the same pattern that
    our generics code generation tool will use to generate generic code for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll use our generics generation tool to swap out any type that fits in the
    T-shaped hole:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We can use our gen tool to generate code at development time. It spits out code
    for us, much like an IDE might do.
  prefs: []
  type: TYPE_NORMAL
- en: We mark up our types using **annotations** in a comment line above the **type**
    of our code for which we want code generation.
  prefs: []
  type: TYPE_NORMAL
- en: Let's work through an example. First, let's go to the correct directory and
    initialize our Go environment by sourcing the init script, running glide-update,
    and pulling gen into our vendors directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the list of the commands we use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This is what our directory structure looks like before running `gen`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/71ef883b-c503-4457-ae04-1e836013159e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here''s our directory structure after running `gen`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dc46692b-f53c-4fb9-8087-295c00a04762.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s look at our project''s code in `src/car/types.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Do you see the `// +gen slice:"Where,Sum[Dollars],GroupBy[string],Select[Dollars]` annotation?
    It tells our gen tool to generate a slice of `Car` and give us the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CarSlice.Where`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CarSlice.SelectDollars`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CarSlice.SumDollars`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When we run gen in the directory with `types.go`, gen will generate a **src/cars/car_slice.go**
    file with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: So, gen is generating all that boilerplate code for us. That keeps our source
    files clean and tidy. If Go supported generics, our code would be similar to the
    code we write that works with gen. How similar? Let's see.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s our `main.go` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: See that `CarSlice` type? That's what gen created for us. We must type in the
    actual struct types, such as `Car`, and gen will create the `CarSlice` type and
    all the methods that we tell it to generate for us in our annotation (just above
    the type definition).
  prefs: []
  type: TYPE_NORMAL
- en: If Go supported generics
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This is what the same block of code might look like if Go supported generics:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Looking at this code block from a lazy programmer's perspective, if Go supported
    generics, we'd have to type two extra characters, `<` and `>`.
  prefs: []
  type: TYPE_NORMAL
- en: It looks like the biggest feature of generic code support has just been neutralized.
    When we consider this information along with the functions we get for free with
    gen and the fact that the performance hit is guaranteed to occur at compile time
    (rather than runtime), it makes Go's direct support of generics seem like a benefit
    or, at the very least, much less of a problem.
  prefs: []
  type: TYPE_NORMAL
- en: Adding new methods
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If we want to add methods that gen does not provide to our `CarSlice`, we can
    put those in a separate file. The thing we need to remember is to not type any
    of our source code into the files generated by gen. That's because our code would
    be overwritten the next time we told gen to run.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a filter function
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A few lines down in our `main.go` file, let''s define a `filter` function that
    will return cars whose `Make` is `Honda.` We use our new `Where` method and pass
    it our `honda` literal function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Cool. Next, let''s create a mapping function to return the price field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Since we have already filtered by Honda, the result only contains the prices
    of Honda cars.
  prefs: []
  type: TYPE_NORMAL
- en: 'Aggregation? Sure, we can do aggregation. Let’s call the `SumDollars` function
    that we got for free when we ran our annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Nums revisited
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Remember those four numerics types that we implemented a `Sum` method for without
    generics? Let''s revisit that code and see if we can improve our code base now
    that we know about gen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we need to run glide-update so that the vendors directory will be
    created for us. It will first be placed in our GOPATH so that when we run the
    next command, the gen package and its dependencies will go in our vendors directory
    rather than our project’s src directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s cd to **~/dev/04_generics_nums/src/num** and run gen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that gen created four files, one for each slice type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e19e1fb0-d162-4e12-b621-5ba5ed88711b.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We have to define each type and annotate that we want gen to create a `Sum`
    method for each slice. Note that we never need to create a type for a slice, only
    the types. Gen creates the slices for each type for us, along with the methods
    that we request in the gen slice annotations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code from `src/num/types.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This is what one of the generated files (`src/num/int8_slice.go`) looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember the price function that we passed to the `Select<T>` function in our
    previous cars example? Let''s have a look at it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s the kind of function we''ll create in our `src/num/vars.go` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll simply return the value that''s passed into our literal function definitions
    in our `fmt.Println` statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Even with this simple sum numbers example, we see that our gen tool saves us
    from typing the boilerplate loop structures for summing numbers.
  prefs: []
  type: TYPE_NORMAL
- en: We have only used the `Sum` method, but there are about two dozen more to choose
    from.
  prefs: []
  type: TYPE_NORMAL
- en: A snippet of documentation describing the `Aggregate` method can be found at
    [https://clipperhouse.github.io/gen/slice/#](https://clipperhouse.github.io/gen/slice/#).
  prefs: []
  type: TYPE_NORMAL
- en: The slice typewriter
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The slice typewriter is built into gen by default. It generates functional convenience
    methods that will look familiar to users of C#'s LINQ or JavaScript's array methods.
    It is intended to save you some loops, using a pass a function pattern. It offers
    easier ad hoc sorting.
  prefs: []
  type: TYPE_NORMAL
- en: 'The annotation looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Here, `Example` is used as a placeholder for your type.
  prefs: []
  type: TYPE_NORMAL
- en: 'A new type, `ExampleSlice`, is generated, and becomes the receiver for the
    following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: Aggregate[T]
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '`AggregateT` iterates over a slice, aggregating each element into a single
    result. `AggregateT` is comparable to LINQ''s Aggregate and underscores reduce
    function.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following example, we specify in our comment annotation that we want
    gen to create an `Aggregate` function that operates over a slice of strings. We
    define a `join` function that we pass to `AggregateString,` which performs the
    join operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Generics implementation options
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Below is a decision matrix that can be used to evaluate which generics implementation
    is best.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/384b20d6-080a-4b7a-8021-792e51da8da6.png)'
  prefs: []
  type: TYPE_IMG
- en: There are many aspects to consider when we think about how to implement generics.
    For example, let's consider the difference between Haskell's parametric polymorphism
    and C++'s ad hoc polymorphism.
  prefs: []
  type: TYPE_NORMAL
- en: In Haskell, polymorphic functions are defined uniformly for all types. We could
    call this compile time polymorphism.
  prefs: []
  type: TYPE_NORMAL
- en: In C++, dynamic polymorphism, via substitution, virtual functions and interfaces
    enable polymorphic behavior, but whether our implementation works for any particular type
    is decided at runtime when the concrete type is substituted for its parameter.
  prefs: []
  type: TYPE_NORMAL
- en: C++ templates offer a similar functionality without the runtime overhead of
    dynamic polymorphism. The tradeoff is the fact that the flexibility is fixed at
    compile time.
  prefs: []
  type: TYPE_NORMAL
- en: Type classes in Haskell allow us to define different behaviors for the same
    function for different types. In C++, we do this using template specialization
    and function overloading.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we are only scratching the surface of the issues, and only with a
    discussion of two languages (C++ and Haskell). There are plenty of edge cases
    to consider. For example, should the Go compiler perform aggressive optimizations?
    If so, that would mean specializing polymorphic functions for all types in which
    they are used, which opens up another level of complexity to manage.
  prefs: []
  type: TYPE_NORMAL
- en: If generics support were added to Go, there would be a cost and risk involved.
    The cost would come up front, either at compile time or runtime. In all cases,
    the pros and cons of each approach should be carefully evaluated and we should
    be careful what we ask for. We'll talk more about generics in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: For more information on generics and Go, including more tools like gen, you
    can refer to [docs.google.com/document/d/1vrAy9gMpMoS3uaVphB32uVXX4pi-HnNjkMEgyAHX4N4](https://docs.google.com/document/d/1vrAy9gMpMoS3uaVphB32uVXX4pi-HnNjkMEgyAHX4N4).
    Another resource is [golang.org/doc/faq#generics.](https://golang.org/doc/faq#generics)
  prefs: []
  type: TYPE_NORMAL
- en: We used the gen tool
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We used the gen tool, which is more aligned with the C++/Template approach.
    While using gen caused us to write a little more code, we were in control, and
    we got some LINQ-like functionality out of the box, which keeps us from having
    to write a lot of boilerplate code for handling slices. Nice!
  prefs: []
  type: TYPE_NORMAL
- en: So, does Go support generics? No. But we can use a tool such as gen to solve
    the big problem of having repetitive boilerplate code. We still have our type
    safety and do not pay the performance penalty for using reflection.
  prefs: []
  type: TYPE_NORMAL
- en: The shape of a functor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A functor is an algebraic type that accepts a value (or usually, a list of values)
    and has a map function that applies to each element in the list to produce a new
    functor of the same shape. What is a shape?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an imperative example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The shape in this example means a slice with three ints. We started with a slice
    with three ints, ran our imperative code, and ended up with a slice with three
    ints.
  prefs: []
  type: TYPE_NORMAL
- en: A functor gets the same results (three elements in and three elements out) but
    a functor does it in a different way.
  prefs: []
  type: TYPE_NORMAL
- en: 'We give our functor the same slice of three ints. The functor executes `add2`
    for each int and returns a slice with three ints (each of which is two greater
    than before):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: There must be more to a functor than that, right?
  prefs: []
  type: TYPE_NORMAL
- en: Yes. The devil is in the details. So, let's shine some light on it.
  prefs: []
  type: TYPE_NORMAL
- en: Functor implementation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's look at our ints functor implementation.
  prefs: []
  type: TYPE_NORMAL
- en: ints functor
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Like the good programmers that we are, we declare our interface at the top of
    our file. Our interface, that is, our contract, has only one function, `Map.`
    Our `IntFunctor` type accepts a `func(int) int` function and returns another `IntFunctor`.
  prefs: []
  type: TYPE_NORMAL
- en: What? It returns an `IntFunctor?` What is that, and how did it print correctly?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at `src/functor/ints.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: One feature of a functor is that it applies that `f` function inside its container.
    Now, what is a container?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: That's our functor's container. We'll call it a `box`, because a box is a container,
    and since we are good, lazy programmers, we prefer names that are short.
  prefs: []
  type: TYPE_NORMAL
- en: Okay. I see the box. What happens in our magical `box`?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Firstly, we notice that `Map` is a method and box is the receiver. `Map` takes
    a function and returns another `IntFunctor.` Ah, so we map from one `IntFunctor`
    to another? Yes, indeed.
  prefs: []
  type: TYPE_NORMAL
- en: Since a functor needs to map one structure to another one, and since there may
    be more than one element to map (and when we say map, we mean transform element
    for element/three in, three out). It's safe to assume we're going to be mapping
    lists of elements.
  prefs: []
  type: TYPE_NORMAL
- en: How are list shapes in Go usually implemented? With a slice, right? It should
    be no surprise that the receiver of our `Map` method is a slice. Every slice can
    be iterated over using `range,` and that's what we use to iterate through our
    list of elements and apply our function (`f`) to each element and return the `box`
    we were passed. The difference is that the `box` now contains transformed elements.
  prefs: []
  type: TYPE_NORMAL
- en: Wait a second, what's a `range` with iterator variables `i` and `el`, that are
    mutating, doing in our pure FP world? And even more disturbing is the fact that
    we are mutating the contents of our box. That's right, mutations did occur, but
    only in the box. It's magical, remember? Inside this box is where things can change
    and not affect our otherwise pure world of FP.
  prefs: []
  type: TYPE_NORMAL
- en: 'How can we draw a line between pure and impure? This is where we do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s it. That''s the place where we allow our execution to be lowered into
    the gutter of mutation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: See the `Functor(ints)` part in the preceding line? That's where we wrap our
    `ints` inside the magical box, and that is where we allow the naughty `add2` mutation
    function to apply itself to each int in our slice.
  prefs: []
  type: TYPE_NORMAL
- en: This action of lowering elements into the gutter of mutation is typically referred
    to as lifting. I would argue that, according to the upcoming analogy, lifting
    is a misnomer. Lowering would be a more appropriate name for it. For more information,
    see [https://en.wikipedia.org/wiki/Lambda_lifting](https://en.wikipedia.org/wiki/Lambda_lifting).
  prefs: []
  type: TYPE_NORMAL
- en: 'What happens in the functor box is not unlike what happens when a person entertains
    impure thoughts. The structure would be the list of three lovely cows dressed
    in polka-dot dresses in one''s mind. The impure person would allow their thoughts
    to be lowered to a place where they would apply the `Undress<T>` literal function,
    where the `T` type in this case would be a Cow:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/900ee368-8112-4bb9-ad0a-bbeb777329c2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Pure FP goes to Hell
  prefs: []
  type: TYPE_NORMAL
- en: The person may feel safe knowing that their mind is the magical box where all
    sorts of impure mutations are permitted. When this occurs, a person exercises
    an `Undress` functor and maps lovely, dressed cows from one world down into another.
  prefs: []
  type: TYPE_NORMAL
- en: When your Momma says, *"Get your mind out of the gutter!"*, this is exactly
    what she's talking about.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last thing we do in `src/functor.ints.go` is create a `String()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we have implemented this one `String()` method, per the duck typing rules
    of Go, our `IntFunctor` is a `Stringer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This is a beautiful, one-method interface. `fmt` looks for this interface to
    print values.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Go Standard Library is very accessible and a great place to go to see how
    things really work. In our example, we see that we passed `v` as the verb (when
    we returned `fmt.Sprintf("%+v", box.ints)` ) around *line 577* in the `print.go`
    file. Here is the snippet from `print.go` that starts on *line 577*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Functor definition
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Functor ([https://hackage.haskell.org/package/base-4.8.1.0/docs/Data-Functor.html#t:Functor](https://hackage.haskell.org/package/base-4.8.1.0/docs/Data-Functor.html#t:Functor)) class
    is used for types that can be mapped over.
  prefs: []
  type: TYPE_NORMAL
- en: We'll use Haskell syntax because it so clearly defines FP algebraic data types,
    including their structures, rules, and logic. `fmap` is the map function. The
    period `.` notation is the `compose` operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instances of Functor should satisfy the following identity and associativity
    laws:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: We should recognize these two rules from [Chapter 11](../Text/Ch11.xhtml), *Category
    Theory That Applies*.
  prefs: []
  type: TYPE_NORMAL
- en: Identity operation
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The identity law of our category says that the identity morphism of **A** is
    **A**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/45776db5-ff12-437d-b841-76c5c71611b4.png)'
  prefs: []
  type: TYPE_IMG
- en: If our operation is a map and the elements in our list are numbers, then the
    identity morphism is +0\. If we add 0 to every element of our input list, our
    transformed list will consist of the same elements.
  prefs: []
  type: TYPE_NORMAL
- en: HEADS UP! We are going to hammer home the concept of composition. Your understanding
    of what composition is and how it works is essential to your ability to be productive
    in pure functional programming. If you read only a few pages in this book, let
    your reading begin now.
  prefs: []
  type: TYPE_NORMAL
- en: Composition operation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The composition operation, **g.f** or **g** after **f**, applies function **f**
    to x (which takes us from **A** to **B**) and passes the result of that to **g**
    (which takes us from **B** to **C**), and that nested set of operations is equivalent
    to the composition operation of **g.f**.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Haskell, we define our composition operation on the first line and request
    to see the type definition of our composition operation on the second line. The
    third line is what the composition means:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The `a`, `b`, and `c` above correspond to the **A**, **B**, and **C** in the
    following diagram.
  prefs: []
  type: TYPE_NORMAL
- en: It says, when we pass  the **A** to **B** function (**f**) to the **B** to **C**
    function (**g**), we get the **A** to **C** function (**g.f**).
  prefs: []
  type: TYPE_NORMAL
- en: 'This is basic composition. Assuming we start at **A**, this diagram says we
    can get to **C** either by way of **B** (**A** to **B** to **C**) or by going
    directly from **A** to **C**. When we choose the short route (**A** to **C**),
    or **g.f**, we compose **g** and **f** in a nested manner, like g(f(x)), where
    x is the value that we get from **A**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/85c1f822-890f-4447-b754-920dafc3f1c8.png)'
  prefs: []
  type: TYPE_IMG
- en: Not quite there? Hang in there. After a few examples you will be.
  prefs: []
  type: TYPE_NORMAL
- en: Composition example in Go
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We''re going to create two functions, `Humanize` and `Emphasize` (representing
    f and g), and a composition function of `Emphasize(Humanize(true))` to illustrate
    the path **A** to **B** to **C**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/04e03132-a800-4159-a025-6386d4dd9684.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `src/compose/compose.go` file contains the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '`main.go` looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'If you''re using the init script, then your terminal should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9b514e34-af68-4690-b047-b3642323ccd0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If this was a more complicated example that included external packages, then
    you would have run the following (in this order):'
  prefs: []
  type: TYPE_NORMAL
- en: '`. init`, `glide-update`, and `go-run`'
  prefs: []
  type: TYPE_NORMAL
- en: Haskell version of compose
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We''ll cover the Haskell version of composing Humanize and Emphasize:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: That's it!  Those five lines are equivalent to the 25 lines of Go code!
  prefs: []
  type: TYPE_NORMAL
- en: I am not at all advocating for any Gophers to switch to Haskell--there are far
    too many reasons to keep coding and deploying Go solutions to address here. I
    include the Haskell code for informational purposes. As mentioned earlier in the
    book, category theory trickles down from the brains of the mathematicians directly
    into Haskell. So, if we want to be good, pure functional programming Gophers,
    then we should learn Haskell.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the REPL terminal log of our session:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a5e2627c-878c-4bcf-b32a-5fd0636440ad.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's look a bit closer at some of the lines.
  prefs: []
  type: TYPE_NORMAL
- en: We can ask our Haskell REPL to tell us the type of what we define using `:t
    <symbol>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, `:t humanize` tells us that it is a function (`->`) that takes
    a `Bool` and returns a list of characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The `\x` tells Haskell that compose is a lambda expression. We name our lambda
    `compose` and pass the `g` and `f` functions as parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `g (f x)` says, apply `f` to `x`, take that result, and pass it to `g`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s see what type compose is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s a little hard to follow. So, let''s see how Haskell says the type is
    of its default implementation of the compose operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve seen that before:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2b57e872-3fab-4a46-b5bf-a87286883296.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Great! Now we''re making progress. Time to define our `emphasizeHumanize` composition
    lambda:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '`compose` is our function, and we pass it two parameters--`emphasize` and `humanize`.
    Being good, careful programmers, we''ll check our function literal''s type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Rock solid! It takes a Bool and returns a string.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, so good. Now it''s time to run this Haskell `compose` function and
    see if we get the same results as we did in Go:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Woot!
  prefs: []
  type: TYPE_NORMAL
- en: Given that a lot of Haskellers are mathematicians, we know that they like to
    use symbols instead of words. Furthermore, we know they like their code to look like
    math equations. So, let's think like good, math-minded programmers and spice up
    the syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s redefine the composition function name with the `.` symbol (notice that
    we have to put the `.` in parentheses; otherwise, Haskell complains):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'And now let''s check its type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Okay, we can grok that now...it''s basic composition. We can use our period
    in place of compose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'But that''s not good enough. We can do better. Let''s use the infix notation
    by moving the (.) in between our two parameters, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'And let''s verify that it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: (g.f)(x) = g(f(x)) composition in Go
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is a graphical representation of our final example of composition in Go:'
  prefs: []
  type: TYPE_NORMAL
- en: '>![](img/ecafc22b-274b-4a39-8856-eea7314ee282.png)'
  prefs: []
  type: TYPE_NORMAL
- en: Don't gloss over that diagram. Study it. Let it sink in.
  prefs: []
  type: TYPE_NORMAL
- en: This is composition, the fundamental principle of functional programming.
  prefs: []
  type: TYPE_NORMAL
- en: That **(g.f)(x) = g(f(x))** equation is quite literal. It says that we can execute
    the **f** function, **Humanize(true)**, and then pass that value **"yes"** to **g** ... **Emphasize**(**"yes"**)
    to get **"yes!!"**.
  prefs: []
  type: TYPE_NORMAL
- en: That **(g.f)(x) = g(f(x))** equation says one more thing. It says that we can
    nest our functions, **g(f(x))**, which is like going from **A** to **B** and then
    **B** to **C**, or we can simply go directly from **A** to **C** by executing **EmphasizeHumanize(true)**.
  prefs: []
  type: TYPE_NORMAL
- en: So, according to the left-hand diagram, **(g.f)(x) == g(f(x))**, and similarly,
    according to the right-hand diagram, **EmphasizeHumanize(true) ==  Emphasize(Humanize(true))**.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7df60447-1a1e-4479-ac5e-6c7c2fb8d0e6.png)'
  prefs: []
  type: TYPE_IMG
- en: Bam!
  prefs: []
  type: TYPE_NORMAL
- en: The (g.f)(x) = g(f(x)) implementation
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now let's take a peek at the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the **f** and **g** functions from the preceding diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Now for the new stuff.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll create two types. Fbs represents **f** (or **A** to **B**), which takes
    a bool (true), and returns a string, `"yes"`. Fss represents **g** (or **B** to
    **C**). `Fss` takes a string, `"yes"`, and returns a string, `"yes!!"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s our `Compose` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Nested inside our `Compose` function is an anonymous function. It's our Lambda.
    In Haskell, it looked like `\x -> g (f x)`.
  prefs: []
  type: TYPE_NORMAL
- en: Lambdas are expressions, and we could pass them around anywhere. We need a function
    that takes a Boolean and returns a `"yes!!"` or a `"no!!"`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, we define our `g.f` function literal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: A note about composition naming conventions in Go
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In Go, we don''t have the luxury of renaming a function name with the . symbol
    or a way to easily convert a function call that looks like **compose(f, g)** to
    one that looks like **g compose f**, much less one that looks like **g . f**.
    But no worries! We''ll just use the following naming convention to represent a
    compose function: `Emphasize_Humanize` (which reads, `g . f`, where `g` is `Emphasize`
    and `f` is `Humanize`). Typically, a camelcased symbol would look like `EmphasizeHumanize`,
    but with the `_` separating the camel humps, it''s obvious that this a special
    symbol.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s main.go:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'And here''s what it looks like when we run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/29458000-fc00-4eee-8684-6eaaee0acfbe.png)'
  prefs: []
  type: TYPE_IMG
- en: The directions of the arrows are significant
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the last chapter, we used the following chart to solve *f(x) = x + 2:*
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eb3c1664-0764-49e2-9751-e8222a3db109.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Remember when we composed *f(x) = x + 2* with *g(x) = x2 + 1*? We solved **g(f(1))
    = 10**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8b95812f-0f1a-47a6-bf5d-02a5fbaf3658.png)'
  prefs: []
  type: TYPE_IMG
- en: We also proved that **f(g(1)) = 4**, which is obviously not **10**. So, we know
    that function composition is not commutative. The arrows go one way only.
  prefs: []
  type: TYPE_NORMAL
- en: EmphasizeHumanize ordered incorrectly
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we try to reverse the order of operations, this is what we''re trying
    to do:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0499e2cc-9754-426f-8d2f-c0e33c2d6854.png)'
  prefs: []
  type: TYPE_IMG
- en: This does not compute.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by passing a Boolean **true** to **Emphasize**, but what does that
    mean?  What are we trying to do?  We are not changing the direction of the arrows,
    but we are attempting to change the order in which we call them. Given our context
    of beginning with a Boolean and trying to get a `"yes!!"` or a `"no!!"` out, it
    only makes sense to apply our `Humanize` and `Emphasize` functions in one direction.
    We are, in effect, trying to compose backwards:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Note that the rest of the code is identical to before. We only swapped the nesting
    order of **f** and **g** in our return statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our function literal that calls our `Compose` function looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: That says, *"Emphasize the true and then Humanize the result of that"*, which
    is clearly not going to work (see the preceding diagram).
  prefs: []
  type: TYPE_NORMAL
- en: 'This code won''t even compile:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6d32204b-2ad1-45ba-83f4-3fa6407afc60.png)'
  prefs: []
  type: TYPE_IMG
- en: Function composition is associative
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So, function composition does not commute, but it is associative:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0c6f1211-4f95-468c-8aee-f8824c3dd744.png)'
  prefs: []
  type: TYPE_IMG
- en: That diagram says that we can compose our functions to get from **A** to **D**
    by either choosing the upper (**A****→C**→**D**) path or the lower (**A**→**B**→**D**) path.
  prefs: []
  type: TYPE_NORMAL
- en: The idea of a functor is that it translates the diagrams we can draw in one
    category into diagrams in another category. This often lets us convert ideas and
    theorems from one category into another.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at an example of a particular functor, the forgetful functor, to
    get a better feel for what it means to convert things from one category into another.
  prefs: []
  type: TYPE_NORMAL
- en: Functional composition in the context of a legal obligation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Assume that Larry agreed to pay Lucy $5,000 by 1st October and that date has
    passed. Lucy wants to get paid $5,000 and Larry wants to pay her, but he does
    not have the money.
  prefs: []
  type: TYPE_NORMAL
- en: Should Lucy sue Larry to get him to pay?
  prefs: []
  type: TYPE_NORMAL
- en: 'The following category diagram describes their situation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b6196744-65f1-403c-8569-d9979a00200c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The category states are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**A** = Where we are today (12th October)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**B** = Lucy demands a lawsuit'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**C** = Lucy gets paid'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The category morphisms are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**f** =  Legal expense (for both, $2,000+)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**g** = Larry pays Lucy $5,000'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**h** = Larry pays Lucy $5,000'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decisions determine state transitions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If Larry, in good faith, communicates the following to Lucy, which path will
    Lucy take?
  prefs: []
  type: TYPE_NORMAL
- en: To be clear, I'm simply asking for more time to pay or for you to allow me to
    make scheduled payments directly to you without going through the court system.
  prefs: []
  type: TYPE_NORMAL
- en: Your thoughts?
  prefs: []
  type: TYPE_NORMAL
- en: Larry
  prefs: []
  type: TYPE_NORMAL
- en: It's obvious that these two will eventually get from **A** to **C**, but which
    path is the shortest? Which path is more costly, both in terms of time and financial
    expenses?
  prefs: []
  type: TYPE_NORMAL
- en: Category theory review
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We connect two arrows from **A** to **B** and **B** to **C**, and another equivalent
    arrow from **A** to **C**. **A**, **B**, and **C** are called objects. They can
    represent anything. In this example, they represent states--beginning (**A**),
    intermediate (**B**), and final (**C**) states. In the next example, the domain
    and range represent different court cases, different worlds. The facts of each
    case make up the structure of each, and the arrows between the two worlds are
    the mappings the attorneys perform to make their case.
  prefs: []
  type: TYPE_NORMAL
- en: Categorical rules
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There are only two rules that must be followed:'
  prefs: []
  type: TYPE_NORMAL
- en: Identity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Associativity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Results oriented
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Category theory is results oriented. It''s all about getting from **A** to
    **C**. The arrows are one-directional. When we compose the two paths (**A** →
    **B** and **B** → **C**), we get an equivalent path (**A** → **C**). That is what
    we are doing when we compose functions. We can call one `Compose` function (shown
    in the following snippet) rather than two functions (`f` and `g`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: The forgetful functor and the law
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Suppose Lucy chooses the longer path; how will Lucy's attorneys make the case
    for their client?
  prefs: []
  type: TYPE_NORMAL
- en: Let's assume there is more to this story. Let's assume that Lucy has injured
    Larry in some way in the past, and now that Lucy is forcing Larry into a lawsuit,
    he will in turn choose to convey this new information to his attorney in order
    to file a counterclaim.
  prefs: []
  type: TYPE_NORMAL
- en: The rule of law
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: How will the law work when they go to court? The attorneys research the law
    to find a case from prior court cases that might yield favorable results for their
    client. They then use that case's ruling as a precedent to win the current case
    for their client.
  prefs: []
  type: TYPE_NORMAL
- en: It is impossible to refer to the entirety of case history to prove their point.
    So, attorneys for both sides will use a rhetorical device, known to category theorists
    as the forgetful functor. The forgetful functor necessarily leaves behind some
    structure. It is very difficult to find a case from the past that is identical
    in every way to the case at hand.
  prefs: []
  type: TYPE_NORMAL
- en: Each attorney attempts to convince others that the structure that they present--that
    is, the one court case that, if chosen, would yield the best results for their
    client--is the one that should be applied.
  prefs: []
  type: TYPE_NORMAL
- en: The reality is that there is a very large number of court rulings in the past
    that could apply, but each attorney will try to convince the judge and/or jury
    that the case that they choose is the way the the law actually is.
  prefs: []
  type: TYPE_NORMAL
- en: The winning side will have effectively mapped a prior court ruling from a world
    that included different parties (plaintiff, defendants, and case facts) onto the
    current case. Some of the details will be different, but the winning attorney
    is the one that best communicates that they have identified the most relevant
    and applicable case to apply in court today.
  prefs: []
  type: TYPE_NORMAL
- en: Each attorney identifies the bilateral symmetry between an old case that will
    best help their client and the present court case, and does their part to convince
    others to apply that case. We might hear the argument begin this way, *"Ladies
    and gentlemen, the essential structure you need to apply is this one**".*
  prefs: []
  type: TYPE_NORMAL
- en: Lucy’s forgetful functor
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Given that G is their current case, with its current set of facts, Lucy''s
    attorney maps the facts from the case (**E**) that helps Lucy the most:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0e32e19a-3dfd-40db-94ea-248a677711f2.png)'
  prefs: []
  type: TYPE_IMG
- en: '**f[Lucy]** is the mapping function from the facts of case **E**, with precedence
    in favor of Lucy.'
  prefs: []
  type: TYPE_NORMAL
- en: Larry’s forgetful functor
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Larry''s attorney maps the facts from the case (**F**) that helps Larry the
    most:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2b9faa05-5037-48ac-af96-bd719c58b1d4.png)'
  prefs: []
  type: TYPE_IMG
- en: It's up to the judge and/or jury to decide which mapping fits best with the
    current case under review. The side with the best mapping wins.
  prefs: []
  type: TYPE_NORMAL
- en: It's time to code another functor (pun intended).
  prefs: []
  type: TYPE_NORMAL
- en: Build a 12-hour clock functor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ll build a 12-hour clock functor like this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Structure** | A clock with 12 places for the hours |'
  prefs: []
  type: TYPE_TB
- en: '| **Transformation operation** | *f(x) = x + 12*, where *x* is the hour |'
  prefs: []
  type: TYPE_TB
- en: '![](img/3da5772f-617f-406d-b8a1-9163d5f7c878.png)'
  prefs: []
  type: TYPE_IMG
- en: 'First, let’s examine the functor implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Define our `ClockFunctor` interface to include a single function (`Map`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a container to hold our list of 12 hours:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'When called, `Map` will be executed/applied to each element in the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: It's okay for the implementation of `Map` to be impure, as long as the side
    effects are limited to variables, such as the loop variables, scoped to the `Map`
    function. Notice that return the container, that we call `box`, whose elements
    have been transformed in some way by the mapper function, **f**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we create a function named Functor that wraps our list of 12 hours into
    the magical box for transformation. This is where we lower our values into the
    gutter. Some call this process lifting, where the mapping transformation from
    one world to another occurs (for details, see *Pure FP goes to Hell* earlier in
    this chapter):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Clock functor helpers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Towards the end of our `clock.go` file, we'll add some helpers, as discussed
    in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: The Unit function
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Our `Unit` function is our identity function. When applied to elements in the
    slice, it will have no effect. It''s trivial, but it''s a requirement to satisfy
    the functor algebraic laws:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: The AmPmMapper function
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This is the mapper we apply when we want to change from AM to PM hours. It will
    be passed to the `Map` method and applied to each hour contained in the box. It
    converts an AM hour (1, 2...12) to its corresponding PM hour (13, 14..0).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: The AmHoursFn helper
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We can call this handy function any time we want the list of AM hours. Note
    that if we create an `AmHours` variable to pass to our clock''s functor, its value
    can be changed. So, this is like a slice constant of AM hours:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: In real-world scenarios, we'll use functors as intended, that is, we will pass
    an initial slice of values in and allow each functor to transform the slice of
    values each time a new functor's `Map` function is called. In our `main.go` file,
    we want to reset the set of hours for learning purposes.
  prefs: []
  type: TYPE_NORMAL
- en: The String helper function
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Create a String helper function to use when printing the functor''s contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: main.go
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We start with our typical `package main` and `import` statements and the `main()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Note that we preface our internal `functor` package (found in the `src` directory)
    with a dot. That allows us to refer to symbols that it exports, such as `Functor`
    and `Map.`
  prefs: []
  type: TYPE_NORMAL
- en: First, we call our `Functor` method and pass in our slice of `AmHours`. `Functor`
    wraps our hours structure in a function of type `ClockFunctor:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Functor` function is what connects our two worlds: the world of AM hours
    and the world of PM hours (or vice versa). We can say that `Functor` lowers our
    hours into a magical box where the transformation mapping function, `amPmMapper`,
    is applied to each element, transforming it into its corresponding PM (or AM)
    hour.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the mapper function must be free of any side effects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: We can see that when we pass our functor's identity function, unit, to its `Map`
    method, it returns what we passed it, that is, the AM hours.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now for the fun part. Let''s pass our mapping function to our functor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Awesome! Our list of AM hours has been transformed into a list of PM hours.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s show off and chain two `Map` calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Why was that showing off?  It does not look like anything changed. Lame. Right?
  prefs: []
  type: TYPE_NORMAL
- en: Wrong. We're chaining our functors.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2330d241-2d2b-4a81-9b91-50bb0bfad2fb.png)'
  prefs: []
  type: TYPE_IMG
- en: The reason why the output doesn't look like it's changed is because it went
    from AM hours to PM hours and back to AM hours.
  prefs: []
  type: TYPE_NORMAL
- en: Terminal output log
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Here''s what it looks like in our terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/243541e1-0f3c-4980-aab4-e6517bfb0c19.png)'
  prefs: []
  type: TYPE_IMG
- en: Functor summary
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Our clock functor comprises a structure (an int slice) that holds 12 hours and
    a `Map` method that accepts a mapper function that is used to transform each of
    the 12 hours into the subsequent set of 12 hours (AM/PM). Each time the `Map`
    method is executed, it returns a new functor; because of this feature, we can
    chain our `Map` method calls.
  prefs: []
  type: TYPE_NORMAL
- en: 'In other words, have a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: We see that with functors, we wrap and `Map` (and can chain our maps).
  prefs: []
  type: TYPE_NORMAL
- en: The car functor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's use a functor to upgrade (and downgrade) some cars! We'll start by opening
    our `car.go` file in our `functor` package.
  prefs: []
  type: TYPE_NORMAL
- en: The functor package
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s have a look at `src/functor/car.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: It's good practice to define our types at the top. Putting them in a type block
    helps to keep our code clean and tidy. Another good practice is to add JSON annotations
    to each field of a struct to enable easy (un)marshalling of JSON into our `Car`
    struct.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to omit empty fields from a struct, you can add the `omitempty`
    clause to the end of your field annotation. For example, if the `Make` was optional
    or sometimes not included and we didn''t want the `json` created from a `Car`
    struct to include empty `Make` fields, our struct definition would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Car struct {`'
  prefs: []
  type: TYPE_NORMAL
- en: '`    Make string `json:"make"``'
  prefs: []
  type: TYPE_NORMAL
- en: '`    Model string `json:"model,omitempty"``'
  prefs: []
  type: TYPE_NORMAL
- en: '`}`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next comes our interface definition that includes the single `Map` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'And here''s our magical box that consists of the slice we''ll be transforming:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s our `Map` method implementation, where we iterate through the elements
    of the slice of cars in our magical box, applying the mapping function `f` to
    each element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s our `Wrap` method that is used to lower our slice of cars into the
    magical box for transformation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we define our helper functions. `Unit` we''ve seen before--it''s our identity
    morphism. The other two are `Upgrade` and `Downgrade.` We''ll keep it simple and
    simply append an `" LX"` to the end of the model name when we upgrade or remove
    it to downgrade a car:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, we include a `String` method so that our `fmt` package knows how to
    print our cars:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: main.go
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We''ll manipulate strings and some JSON, as well as a `car` functor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `cars` variable to hold a `Car` type and initialize it with two cars.
    Since we annotated our `Make` and `Model` fields with `''json''`, we can easily
    unmarshal a `Toyota Highlander` into a car:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s exercise our `car` functor and verify that it works properly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: Compare one line of FP to a bunch of imperative lines
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: It takes one line of FP-style code to apply an upgrade and downgrade to a car.
    Granted, the `Upgrade` and `Downgrade` mapper functions were defined in the `functor`
    package, but that's a great benefit. We can keep the boilerplate implementation
    of looping through the slice of cars separate from our business use case logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the imperative implementation style, we first implement the `for...range`
    iteration block into which we insert our Upgrade/Downgrade logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: See the difference?
  prefs: []
  type: TYPE_NORMAL
- en: Which style of coding will be easier to maintain?
  prefs: []
  type: TYPE_NORMAL
- en: Car functor terminal session
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let''s run our car functor example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ff3b748b-7219-4d67-a60a-26b586fc36ea.png)'
  prefs: []
  type: TYPE_IMG
- en: Monoids
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Monoids are the most basic way to combine any values. A monoid is algebra that
    is closed under an associative binary operation and has an identity element.
  prefs: []
  type: TYPE_NORMAL
- en: We can think of a monoid as a design pattern that allows us to quickly reduce
    (or fold) on a collection of a single type in a parallel way.
  prefs: []
  type: TYPE_NORMAL
- en: Monoid rules
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A monoid is anything that satisfies the following rules:'
  prefs: []
  type: TYPE_NORMAL
- en: Closure rule
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Associativity rule
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identity rule
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's discuss these rules in brief.
  prefs: []
  type: TYPE_NORMAL
- en: Closure rule
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: “If you combine two values of same type, you get another value of the same type.”
  prefs: []
  type: TYPE_NORMAL
- en: Given two inputs of the same type, a monoid returns one value of the same type
    as the input.
  prefs: []
  type: TYPE_NORMAL
- en: Closure rule examples
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 1 + 2 = 3, and 3 is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: 1 + 2 + 3 also equals an integer.
  prefs: []
  type: TYPE_NORMAL
- en: 1 + 2 + 3 + 4 also equals an integer.
  prefs: []
  type: TYPE_NORMAL
- en: Our binary operation has been extended into an operation that works on lists!
  prefs: []
  type: TYPE_NORMAL
- en: Closure axiom
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If a, b ∈ S, then a + b ∈ S.
  prefs: []
  type: TYPE_NORMAL
- en: That says, if a and b are any two values in the set S of integers and if we
    apply the binary operation + to any two values, then the result of that addition
    operation will be a value that is also in the set of integers.
  prefs: []
  type: TYPE_NORMAL
- en: Associativity rule
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: “If you combine several more values, the order in which you combine does not
    matter”
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: So, if we have 1 + 2 + 3 + 4, we can transform that into ( 1 + 2 ) + ( 3 + 4
    ).
  prefs: []
  type: TYPE_NORMAL
- en: Note that associativity works for addition and multiplication and string concatenation,
    but not for subtraction and division.
  prefs: []
  type: TYPE_NORMAL
- en: Identity rule
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: “There is an identity element that doesn’t do anything.”
  prefs: []
  type: TYPE_NORMAL
- en: '- Identity rule'
  prefs: []
  type: TYPE_NORMAL
- en: A monoid will take two values of the same type and return one value of the same
    type.
  prefs: []
  type: TYPE_NORMAL
- en: Identity rule examples
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Under the + operator, the set of integers has an identity of 0.
  prefs: []
  type: TYPE_NORMAL
- en: '| Rule | Example |'
  prefs: []
  type: TYPE_TB
- en: '| Left identity | 0 + 1 == 1 |'
  prefs: []
  type: TYPE_TB
- en: '| Right identity | 1 + 0 == 1 |'
  prefs: []
  type: TYPE_TB
- en: Notice that the operator is binary, that is, it takes two inputs, and those
    inputs must be of the same type.
  prefs: []
  type: TYPE_NORMAL
- en: The result of combining the identity element (sometimes called empty or zero)
    with x is always x.
  prefs: []
  type: TYPE_NORMAL
- en: An identity of 0
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Under the * operator the set of integers has an identity of 1.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: Writing a reduction function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Given the previous three rules, we can write a reduction function. When we run
    a reduction on an array of integers using addition, we seed our operation with
    a 0 (the identity element).
  prefs: []
  type: TYPE_NORMAL
- en: When we run a reduction on an array of integers using multiplication, we seed
    our operation with a 1 (the identity element).
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s the idea. The following table summarizes a number of possible reductions:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Type** | **Operation** | **Unit/zero/neutral value** |'
  prefs: []
  type: TYPE_TB
- en: '| ints | + | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| ints | * | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| string | + (concat strings) | “” |'
  prefs: []
  type: TYPE_TB
- en: '| bool | && | true |'
  prefs: []
  type: TYPE_TB
- en: '| bool | &#124;&#124; | false |'
  prefs: []
  type: TYPE_TB
- en: '| list | << (concat list) | [] |'
  prefs: []
  type: TYPE_TB
- en: '|  |  |  |'
  prefs: []
  type: TYPE_TB
- en: A semigroup is a missing neutral value
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If we are missing the unit/zero/neutral value, then we don’t have a monoid,
    we have a semigroup. Note that a semigroup can be converted into a monoid.
  prefs: []
  type: TYPE_NORMAL
- en: That was a very interesting discussion of the algebra of monoids, but what the
    heck are they good for, and why should we care?
  prefs: []
  type: TYPE_NORMAL
- en: Here are a couple of good uses for monoids.
  prefs: []
  type: TYPE_NORMAL
- en: Converting binary operations into operations that work on lists
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Consider the following operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: Instead of having to write all that code where we type a number, type a `+`,
    type another number, and we can feed a list of numbers into our reduce function
    that applies the `+` operation to each item and accumulates the sum.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example of appending strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: What was the neutral/identity element used in each of the preceding examples?
  prefs: []
  type: TYPE_NORMAL
- en: The preceding code is F# code. The `|>` symbol is just a pipe symbol, like we
    use in a Unix terminal. It allows us to pipe the list of integers `[1,2,3]` or
    a list strings `["a", "b", "c"]`  into `List.reduce(+)`. The greater than symbol
    is just an indication of the direction of the flow of data, that is, from left
    to right.
  prefs: []
  type: TYPE_NORMAL
- en: Using monoids with divide and conquer algorithms
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Monoids are frequently used to solve large computations. Monoids help us to
    break our computations into pieces. We can run smaller computations in separate
    cores or on separate servers and recombine/reduce/fold the results into a single
    result. We often employ parallel or concurrency techniques along with incremental
    accumulation of our result.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a very simple example, if we need to add these numbers: 1 + 2 + 3 + 4.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can add ( 1 + 2 ) on one CPU/core and ( 3 + 4 ) on another:'
  prefs: []
  type: TYPE_NORMAL
- en: 3 + 7 = 10
  prefs: []
  type: TYPE_NORMAL
- en: Where associativity holds, we can parallelize our computations.
  prefs: []
  type: TYPE_NORMAL
- en: Referential transparency
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Identifying when using monoid can help us make design decisions that affect
    performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'On day one, we''re asked to add 1 + 2 + 3\. Then, on day two, we''re asked
    to add 1 more. We don''t have to add 1 + 2 + 3 again. We can simply store that
    and add our new 1 to it:  6 + 1 = 7.'
  prefs: []
  type: TYPE_NORMAL
- en: Given that nothing is free, what did it cost us to gain the performance boost
    of not having to add 1 + 2 + 3? Storage. The question becomes, which is more costly?
    The answer to that will tell us whether to leverage referential transparency or
    not. Just because we can do something does not mean we always should.
  prefs: []
  type: TYPE_NORMAL
- en: Handling no data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What if we have no data but we're asked to reduce it? Similarly, what if we
    have no data but we’re asked to incrementally add to it?
  prefs: []
  type: TYPE_NORMAL
- en: This is when the identity element comes in handy! It can be the initial value
    for missing data.
  prefs: []
  type: TYPE_NORMAL
- en: More examples of monoids
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Lists are monoids. The operation to combine them is simply concatenation. Many
    types of containers are also monoids, including monads.
  prefs: []
  type: TYPE_NORMAL
- en: What are not monoids?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Integers are not monoids, but integers under addition (a way to combine them)
    are monoids.
  prefs: []
  type: TYPE_NORMAL
- en: Whole numbers (integers starting at 1), and even whole numbers under addition,
    are not monoids. What is the neutral element for addition? The answer is zero.
  prefs: []
  type: TYPE_NORMAL
- en: 'Invoices are not monoids:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0b8f0dc3-8f8b-4661-bfbc-136ea1ba44c6.png)'
  prefs: []
  type: TYPE_IMG
- en: How can we combine two invoices?
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/412e3faf-2ded-4b05-99c7-1c1353b2a4a8.png)'
  prefs: []
  type: TYPE_IMG
- en: What does it mean to add invoices? Are we going to merge the colors or somehow
    smash them together? If we stack them, how can we do anything with them, other
    than take the top one off the list? How do we combine the customer addresses?
    Sure, we can add the work order numbers, 1,000 + 1,000 = 2,000, but what value
    is that to us?
  prefs: []
  type: TYPE_NORMAL
- en: How could we possibly add invoices? Maybe if we choose some fields that are
    statistical in nature?
  prefs: []
  type: TYPE_NORMAL
- en: Monoid examples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ll cover three types of monoid here:'
  prefs: []
  type: TYPE_NORMAL
- en: Name monoid
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Int slice monoid
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Line item monoid
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That's right. We're going to turn that invoice into a monoid!
  prefs: []
  type: TYPE_NORMAL
- en: Name monoid
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's see what we can do with a name. First, we define an interface that has
    two methods, `Append` and `Zero.` We wrap our name in `nameContainer.`
  prefs: []
  type: TYPE_NORMAL
- en: Our `nameContainer` is a struct with a single string field, `name`. Our `Append`
    method appends the given name to the long name string it's building up that lives
    in the magical `nameContainer`. Our zero morphism for our name string is an empty
    string.
  prefs: []
  type: TYPE_NORMAL
- en: 'The content of `src/monoid/name_monoid.go` would look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s what `main.go` looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: Name monoid terminal session
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let''s run our monoid:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00863fff-a211-46a6-b700-096d647b1250.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, we ran our app and got good results. The initial state is Alice, and the
    **Zero** value is the empty string; after the first append we get **AliceAlice,**
    and when we chain another we get **AliceAliceAlice.**
  prefs: []
  type: TYPE_NORMAL
- en: Int slice monoid
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Let's see what we can do with a slice of ints.
  prefs: []
  type: TYPE_NORMAL
- en: First, we define an interface that has two methods, `Append` and `Zero.` We
    wrap our int in `intContainer`. `intContainer` is a struct with a single int field,
    `ints`. Our `Append` method appends the given int slice to the slice of `ints`
    it's building up that lives in the magical `intContainer`. The `Zero` morphism
    for a slice is `nil`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the content of `src/monoid/int_monoid.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: That is just about the same logic as the Name monoid, except for that `Reduce`
    method. The `Reduce` method will allow us to combine all of our ints with our
    binary operator, addition, and arrive at a sum of all ints in the `intMonoid`
    container.
  prefs: []
  type: TYPE_NORMAL
- en: 'The contents of `main.go` are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'We call the same list of methods we did for our `nameMonoid` and get correct
    results. The interesting line is the last one, where we chain our Appends and
    then call Reduce to sum up our ints:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4e8a85ac-c638-49da-a812-1693649b8ac4.png)'
  prefs: []
  type: TYPE_IMG
- en: Int slice monoid terminal session
  prefs: []
  type: TYPE_NORMAL
- en: Lineitem slice monoid
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Let's see what we can do with a slice of line items.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we define an interface that has three methods, `Append`, `Zero`, and
    `Reduce.` We wrap our line items in the `lineitemContainer.` Our `lineitemContainer`
    is a struct with three fields that correspond to our invoice''s line items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: Our `Append` method appends the given line item to the slice of line items it's
    building up that lives in the magical `lineitemContainer`.
  prefs: []
  type: TYPE_NORMAL
- en: The `Zero` morphism for a slice is `nil`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `src/monoid/lineitem_monoid.go` file will have the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: That is just about the same logic as the `Int` slice monoid, except for that
    `Reduce` method. The `Reduce` method will allow us to combine all of our line
    item fields with our binary operator, addition, and arrive at a sum total of all
    line item entries in the `lineitemMonoid` container.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `main.go` file will have the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: That's the same stuff we verified with the other monoids. Our feeder value,
    line items, is a slice of three line item tuples. Verify that the math of the
    `Reduce` works.
  prefs: []
  type: TYPE_NORMAL
- en: Int slice monoid terminal session
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Looking at the last line of output, we can see that we have called our `Reduce`
    function to sum our totals (`totalQuantity`, `totalPrice`, and `totalListPrice`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/43b2d198-4888-4d14-b678-1d996b294807.png)'
  prefs: []
  type: TYPE_IMG
- en: For a quick manual verification, let's look at `totalQuantity`--*1+2+5+1+2+5+1+2+5
    = 24*. Looks good!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we learned how to use tooling to solve issues that arise in
    Go because of its lack of support for generics. We were able to use this tooling
    to generate underscore like features in our Go code by starting with properly
    defined base types. With no more worries about potential generics support slowing
    down our runtime executables (as is the case with Java), we jumped for joy with
    an unexpected productivity boost.
  prefs: []
  type: TYPE_NORMAL
- en: We continued forward into the land of pure FP, where we tackled the concept
    of function composition. With `g.f(x) == g(f(x))` in our tool belt, we studied
    functors and learned how to transform lists of items. We chained our maps and
    even learned how attorneys can use the forgetful functor to win cases in court
    for their clients.
  prefs: []
  type: TYPE_NORMAL
- en: We wrapped up the chapter with monoids. We not only learned the algebraic laws
    of monoids, but we implemented them. We chained `Append` methods and even wrote
    a couple of reductions.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll continue our on our path towards pure enlightenment,
    and maintain our quest for simpler code and improved error handling.
  prefs: []
  type: TYPE_NORMAL
