- en: Functors, Monoids, and Generics
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数对象，幺半群和泛型
- en: '"Here''s my attempt at functional programming in Go. I think it''s a good idea,
    but I''m really not sure."'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '"这是我在Go中尝试函数式编程。我认为这是一个好主意，但我真的不确定。"'
- en: I have seen comments like this on over a dozen blog articles. I hope that after
    reading this chapter and working through the examples, you'll have a new-found
    love for functional programming (FP). Not because it's so pure that you worry
    that side-effect programming will send you to hell, but rather, because you feel
    comfortable with concepts that form the basis of pure FP and you see that its
    benefits outweigh the costs of learning how to use it.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我在超过十几篇博客文章上看到了这样的评论。我希望在阅读完本章并完成示例后，你会对函数式编程（FP）有一种新的热爱。不是因为它是如此纯净，以至于你担心有副作用的编程会把你送到地狱，而是因为你对构成纯FP基础的概念感到舒适，并且你看到它的好处超过了学习如何使用它的成本。
- en: 'Our goals in this chapter are as follows:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标如下：
- en: Appreciate how the lack of generics support in Go can be a good thing
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 欣赏Go中泛型支持的缺失可能是一件好事
- en: Learn how to use a generics code generation tool to solve the boilerplate problem
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何使用泛型代码生成工具来解决样板问题
- en: Deeply understand how function composition works
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深入理解函数组合是如何工作的
- en: Build a few functors and understand how to map between worlds
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建一些函数对象，并了解如何在不同领域之间进行映射
- en: Build a few monoids and learn how to write your own reduce functions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建一些幺半群，并学习如何编写自己的reduce函数
- en: Understanding functors
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解函数对象
- en: A functor is a structure-preserving transformation between categories. In other
    words, a functor is a mappable type. Let's see what that means with an example.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 函数对象是范畴之间保持结构的变换。换句话说，函数对象是可映射的类型。让我们通过一个例子来看看这意味着什么。
- en: An imperative versus pure FP example
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命令式与纯函数式的例子
- en: Suppose we start with a slice of ints, `ints := []int{1,2,3}`.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们从一个int切片开始，`ints := []int{1,2,3}`。
- en: 'In imperative programming, we write all the scaffold code to implement exactly
    how to process this slice of ints. In pure FP, however, we tell our functor what
    we want the loop to do:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令式编程中，我们编写所有的脚手架代码来准确实现如何处理这个int切片。然而，在纯函数式编程中，我们告诉我们的函数对象我们希望循环做什么：
- en: '![](img/bb333e07-c020-4551-a72f-6f87db47d65b.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bb333e07-c020-4551-a72f-6f87db47d65b.jpg)'
- en: 'Here''s the output:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Let's see how this works.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这是如何工作的。
- en: What did that Map function do for us?
  id: totrans-18
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 那个Map函数为我们做了什么？
- en: The `Map` function abstracted the loop. We don't have to bother writing the
    same old range/for looping code. We simply pass in our original `ints` list and
    tell our functor to map that slice into a slice where each element is one greater
    than it was before. This is a lot like SQL, where we declare what data we want
    and let the database engine worry about how to get the data.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`Map`函数抽象了循环。我们不必再写相同的range/for循环代码。我们只需传入我们原始的`ints`列表，并告诉我们的函数对象将该切片映射为一个每个元素比以前大一的切片。这很像SQL，我们声明我们想要的数据，让数据库引擎去担心如何获取数据。'
- en: What possible benefits can this afford us?
  id: totrans-20
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 这能给我们带来什么可能的好处？
- en: Do we have to change our SQL query code to benefit from a database engine update
    that increases the query performance? The answer is no, and the same goes for
    our pure FP code.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们是否必须更改我们的SQL查询代码以从数据库引擎更新中受益，从而提高查询性能？答案是否定的，对于我们的纯函数式编程代码也是一样的。
- en: What if all we had to do was write `Functor(list).Map(add1)` and define our
    custom `add1` function? What if `Functor` was part of the Go Standard Library
    (or another very stable third-party package), and what if the next version of
    Go came out and it knew how to optimize performance based on the size of the list
    we passed it? Would that not be an automatic, significant benefit gained from
    simply compiling with the latest version of Go (or that other, very stable third-party
    package)?
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只需要编写`Functor(list).Map(add1)`并定义我们自定义的`add1`函数呢？如果`Functor`是Go标准库的一部分（或者是另一个非常稳定的第三方包），并且如果Go的下一个版本发布了，并且它知道如何根据我们传递的列表的大小来优化性能，那不是仅仅编译使用最新版本的Go（或者其他非常稳定的第三方包）就能获得的自动的显著的好处吗？
- en: This may not seem like a big win in terms of the lines of code written, or even
    clarity. In this case, and in smaller utility or administrative programs, it might
    not be of great benefit. The IMHO place where using FP style offers the greatest
    benefit is in business use case logic. We look for places where we need to be
    careful to not clutter business intent with noisy code like for loop scaffolding
    and error checking code blocks. Those are great places for FP-style programming.
    Other good places are where we would like to horizontally scale our application
    without worrying about race conditions or side effects.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 从代码行数或者清晰度来看，这可能并不是一个巨大的胜利。在这种情况下，以及在较小的实用程序或管理程序中，它可能并不会带来很大的好处。在我看来，使用FP风格提供最大好处的地方是业务用例逻辑。我们寻找需要小心谨慎地不要用嘈杂的代码（如for循环脚手架和错误检查代码块）混淆业务意图的地方。这些都是FP风格编程的绝佳场所。其他好的地方是我们希望在不担心竞态条件或副作用的情况下横向扩展我们的应用程序。
- en: A magical structure
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个神奇的结构
- en: A functor can be thought of as a magical structure that can be mapped over,
    where the magical structure can be thought of as a shape with a constant set of
    elements accompanied by the ability to apply a transformation operation to each
    element.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 函数对象可以被看作是一个神奇的结构，可以被映射，其中神奇的结构可以被看作是一个形状，带有一组恒定的元素，并伴随着对每个元素应用变换操作的能力。
- en: Let's look at some examples.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一些例子。
- en: Color blocks functor
  id: totrans-27
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 颜色块函数对象
- en: 'A functor consists of a structure, usually a slice in Go, and a transformation
    operation, that is, the mapping function:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一个函数对象由一个结构组成，通常是Go中的一个切片，以及一个变换操作，即映射函数：
- en: '| **Structure** | Eight blocks, each filled with a different color |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| **结构** | 八个块，每个填充有不同的颜色 |'
- en: '| **Transformation operation** | `f(x) = x - 30`, where `x` is the hue |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| **变换操作** | `f(x) = x - 30`，其中`x`是色调 |'
- en: Below, is a functor that maps eight colored blocks to eight corresponding blocks
    whose color has been altered by applying the transformation operations above to
    adjust the hue of the color displayed in the boxes.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个函子，它将八个彩色块映射到八个相应的块，其颜色经过上面的转换操作调整色调。
- en: '![](img/7001a6f6-694a-4b8b-b94a-8166e7ebf186.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7001a6f6-694a-4b8b-b94a-8166e7ebf186.png)'
- en: 'The preceding diagram shows a single **f(x)** arrow to keep the clutter to
    a minimum, but a more accurate representation would show arrows from each original
    element to its corresponding, new, transformed element. That''s what actually
    occurs--each element is processed inside the structure and transformed into a
    new value that is returned inside the structure:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图表显示了一个单个**f(x)**箭头，以保持最小的混乱，但更准确的表示应该显示从每个原始元素到其相应的新转换元素的箭头。这实际上是发生的--每个元素在结构内被处理，并转换为一个新值，该值返回到结构内：
- en: '![](img/cf666dbf-d617-46f4-b833-058bb997d673.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cf666dbf-d617-46f4-b833-058bb997d673.png)'
- en: Fingers times 10 functor
  id: totrans-35
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 手指乘以10的函子
- en: 'As mentioned before, a functor consists of a structure and a transformation
    operation:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，函子由结构和转换操作组成：
- en: '| **Structure** | Five fingers, each representing an integer |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| **结构** | 五个手指，每个手指代表一个整数 |'
- en: '| **Transformation operation** | `f(x) = x * 10` |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| **转换操作** | `f(x) = x * 10` |'
- en: '![](img/573afd21-9780-4895-b8d5-926181d3aa15.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](img/573afd21-9780-4895-b8d5-926181d3aa15.png)'
- en: 'From the last chapter, we know that a category consists of the following:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 从上一章我们知道，一个类别包括以下内容：
- en: Grouping of objects
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象的分组
- en: '**Objects**: Dots/points/a primitive with no properties and no structure'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对象**：点/点/没有属性和结构的原始物体'
- en: '**Morphism (arrow)**: Something that goes between two objects/elements'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**态射（箭头）**：连接两个对象/元素的东西'
- en: Can you see the objects (the numbers on each finger)?
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你能看到对象（每个手指上的数字）吗？
- en: Can you see the mappings (**1** to **10**, **2** to **20**, **3** to **30**,
    and so on)?
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你能看到映射关系吗（1对应10，2对应20，3对应30，依此类推）？
- en: The fact that our category is closed under multiplication, has an identity element,
    and has a mapping function (times 10), means that we've got a functor. See it?
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的类别在乘法下是封闭的，有一个单位元，并且有一个映射函数（乘以10），这意味着我们有一个函子。看到了吗？
- en: This is a shape-preserving map that maps from one category to another; hence,
    the functor is called a category homomorphism. The **f(x)** illustrates that the
    functor is a function between two categories.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个保持形状的映射，从一个类别映射到另一个类别；因此，函子被称为类别同态。**f(x)**说明了函子是两个类别之间的函数。
- en: Counting on our fingers (functors) is more proof that all we really need to
    know, we are taught in kindergarten!
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 数手指（函子）更多地证明了我们真正需要知道的一切都是在幼儿园里教的！
- en: Definition of a functor in Haskell
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Haskell中函子的定义
- en: 'We''ve seen a **functor** in the previous chapter in the type class hierarchy
    diagram. A functor has only one type class method, `fmap`, which has a type of
    `fmap :: (a -> b) -> f a -> f b`. It says--give me a function that takes an `a`
    and returns a `b`, a structure with an `a` inside it, and I''ll give you a structure
    with a `b` inside it. The function is applied to each element inside the structure.
    The `fmap` function transforms values inside the structure.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '在上一章的类型类层次结构图中，我们已经看到了一个**函子**。函子只有一个类型类方法，`fmap`，它的类型是`fmap :: (a -> b) ->
    f a -> f b`。它说--给我一个接受`a`并返回`b`的函数，一个包含`a`的结构，我会给你一个包含`b`的结构。该函数应用于结构内的每个元素。`fmap`函数转换结构内的值。'
- en: 'We could use the following terms interchangeably:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以互换使用以下术语：
- en: Structure
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构
- en: Container
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器
- en: Box
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 盒子
- en: The important thing to remember is that a functor operates on the element inside
    the thing (structure/container/box) and returns the structure with the transformed
    value (not the raw value).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 要记住的重要一点是，函子作用于结构/容器/盒子内部的元素，并返回具有转换值的结构（而不是原始值）。
- en: Kinds of types
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类型的种类
- en: 'Functors in Haskell must have the kind `* -> *`. Kinds are another layer of
    types, above the concrete types in Haskell. Kinds allow us to define what behavior
    types are capable of and then connect them with the appropriate type classes.
    For example, an **Int** can act like a showable, readable, ordered, or enumerable
    thing. Values in Haskell can be classified by their type. Let''s use Haskell''s
    concise syntax to look at some examples:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Haskell中的函子必须具有kind `* -> *`。Kinds是Haskell中具体类型之上的另一层类型。Kinds允许我们定义类型的行为能力，然后将它们与适当的类型类连接起来。例如，一个**Int**可以像可显示的、可读的、有序的或可枚举的东西一样。Haskell中的值可以根据它们的类型进行分类。让我们使用Haskell的简洁语法来看一些例子：
- en: '| **Type(Class)** | **__Kind__  ** | **Description** |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| **类型（类）** | **__种__  ** | **描述** |'
- en: '| **Int** | `*` | `*` represents concrete types (such as Bool, Char, or Int).
    |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| **Int** | `*` | `*`代表具体类型（如Bool、Char或Int）。|'
- en: '| **Char** | `*` | `*` represents concrete types (such as Bool, Char, or Int).
    |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| **Char** | `*` | `*`代表具体类型（如Bool、Char或Int）。|'
- en: '| **[]** | `* -> *` | [] takes a single type of kind `*` and returns a new
    type of kind `*`. |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| **[]** | `* -> *` | []接受一种类型的kind `*`，并返回一种新的kind `*`的类型。|'
- en: '| **Maybe** | `* -> *` | A higher-kinded type that takes a single type of kind
    `*` and returns a new type of kind `*`. |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| **Maybe** | `* -> *` | 一种高级类型，接受一种kind `*`的类型，并返回一种新的kind `*`的类型。|'
- en: '| **Either** | `* -> * -> *` | A higher-kinded type that takes a single type
    of kind `*` and either returns a new type of kind `*` or returns a new type of
    kind `*`. |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| **Either** | `* -> * -> *` | 一种高级类型，接受一种kind `*`的类型，并返回一种新的kind `*`的类型，或者返回一种新的kind
    `*`的类型。|'
- en: '| **Functor** | `(* -> *) ->` Constraint | A functor is a type class, not a
    type. We define the behavior of the higher-kinded type that is a functor to be
    something that takes a kind `*` and maps it into another kind, `*`. The constraint
    refers to the fact that the functor must obey the rules defined in its algebra.
    A constraint enforces some sort of limitation. For example, a Numeric constraint
    might constrain all values of the Numeric type to be numeric. 123 passes, but
    "ABC" fails for the Numeric constraint. |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| **函子** | `(* -> *) ->` 约束 | 函子是一个类型类，而不是一种类型。我们定义了作为函子的高阶类型的行为，它接受一种`*`并将其映射到另一种`*`。约束指的是函子必须遵守其代数中定义的规则。约束强制执行某种限制。例如，数值约束可能限制所有数值类型的值都是数值的。123通过，但"ABC"对于数值约束失败。|'
- en: Maybe
  id: totrans-65
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 也许
- en: '**Maybe** is a functor that maps every type to the same type with an additional
    `Nothing` value. `Maybe` is like an optional value (note that types are the objects
    in our category):'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**Maybe**是一个函子，将每种类型映射到具有额外的`Nothing`值的相同类型。`Maybe`就像一个可选值（注意，类型是我们类别中的对象）：'
- en: '`data Maybe a = Just a | Nothing`'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`data Maybe a = Just a | Nothing`'
- en: The value of `Maybe Int` can be either just a number, such as Just 2, or Nothing.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`Maybe Int`的值可以是一个数字，比如`Just 2`，也可以是`Nothing`。'
- en: 'The `Maybe` type maps types to types. For example, it maps **Char** to **Maybe
    Char**. `fmap`, defined in the following snippet, shows how every `a -> b` function has
    a corresponding version, `Maybe a -> Maybe b`, which just returns `Nothing` when
    given `Nothing` and behaves normally otherwise:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: “Maybe”类型将类型映射到类型。例如，它将**Char**映射到**Maybe Char**。在下面的代码片段中定义的`fmap`显示了每个`a ->
    b`函数都有一个对应的版本，`Maybe a -> Maybe b`，当给定`Nothing`时只返回`Nothing`，否则正常运行：
- en: '[PRE1]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Polymorphism at a higher level
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更高级别的多态性
- en: Haskell's rich type features (type classes, parameterized algebraic data types,
    recursive data types, and so on) allow us to implement polymorphism on a much
    higher level than is currently possible in Go.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Haskell丰富的类型特性（类型类、参数化代数数据类型、递归数据类型等）使我们能够在比Go当前可能的更高级别上实现多态性。
- en: It is possible to implement polymorphic behavior in Go. However, due to language
    limitations (the lack of generics), it requires additional code to specify each
    type that implements the desired behaviors.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中实现多态行为是可能的。但是，由于语言限制（缺乏泛型），需要额外的代码来指定实现所需行为的每种类型。
- en: For a Golang code example that demonstrates how to leverage structs and methods
    to derive polymorphic behavior, see [http://l3x.github.io/golang-code-examples/2014/07/15/polymorphic-shapes.html](http://l3x.github.io/golang-code-examples/2014/07/15/polymorphic-shapes.html).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Golang代码示例，演示如何利用结构和方法来获得多态行为，请参阅[http://l3x.github.io/golang-code-examples/2014/07/15/polymorphic-shapes.html](http://l3x.github.io/golang-code-examples/2014/07/15/polymorphic-shapes.html)。
- en: No Generics results in a lot of boilerplate code
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 没有泛型会导致大量的样板代码
- en: 'Without support for generics, when we implement a list function, we must implement
    it for each type our application requires. It''s a lot of repetitive, boilerplate
    code. For example, if we must implement a `Sum` function for `int8`, `int32`,
    `float64`, and `complex128`, this is what it might look like:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 没有泛型的支持，当我们为应用程序需要的每种类型实现列表函数时，我们必须为每种类型都实现它。这是大量重复的样板代码。例如，如果我们必须为`int8`、`int32`、`float64`和`complex128`实现`Sum`函数，它可能看起来像这样：
- en: '[PRE2]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here''s the output:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出：
- en: '[PRE3]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'With generics, we would only need to implement a `Sum` function similar to
    the following one. `<T>` is a placeholder for any type we pass into `Sum` that
    supports the `+` operator:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 使用泛型，我们只需要实现一个类似以下的`Sum`函数。`<T>`是我们传递给`Sum`的任何类型的占位符，支持`+`运算符：
- en: '[PRE4]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: It would be nice to not have to write all that repetitive boilerplate code.
    Are there any other options?
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 不用编写所有那些重复的样板代码会很好。还有其他选择吗？
- en: Yes. We could use the empty `interface{}` everywhere and perform reflection
    and type casting to pull the data out of the list structure and put it back into
    the generic `interface{}`, but that is not performant, and it's a lot of extra
    code.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 是的。我们可以在任何地方使用空的`interface{}`，并执行反射和类型转换来从列表结构中提取数据并将其放回通用的`interface{}`，但这不是高性能的，而且会增加很多额外的代码。
- en: Solve lack of generics with metaprogramming
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用元编程解决泛型缺失问题
- en: '**Metaprogramming** (**MP**) is about writing code that writes code. In MP,
    we write programs that treat programs, even themselves, as input data. Our MP
    will read, analyze, transform, and generate code.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '**元编程**（**MP**）是关于编写编写代码的代码。在MP中，我们编写将程序视为输入数据的程序。我们的MP将读取、分析、转换和生成代码。'
- en: Maybe we can use MP to fix what's missing in Go due to its lack of support for
    generics?
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 也许我们可以使用MP来修复Go中由于不支持泛型而缺失的部分？
- en: Maybe. First, let's get a better understanding of what MP is about.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 也许。首先，让我们更好地了解MP是关于什么的。
- en: 'Here are some examples:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些示例：
- en: Lexers, parsers, interpreters, and compilers
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 词法分析器、解析器、解释器和编译器
- en: '**Domain-Specific Languages** (**DSLs**)'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**领域特定语言**（**DSL**）'
- en: '**Aspect-Oriented Programming** (**AOP**)'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**面向方面的编程**（**AOP**）'
- en: Attributes (.NET)
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性（.NET）
- en: Annotations (Java)
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注解（Java）
- en: Generics (.NET, Java)
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 泛型（.NET，Java）
- en: Templates (C++)
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板（C++）
- en: Macros (C)
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 宏（C）
- en: method_missing (Ruby)
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: method_missing（Ruby）
- en: Reflection (Go, C#, Ruby)
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反射（Go，C#，Ruby）
- en: There are several types of MP.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种类型的MP。
- en: 'Programs that support the `eval` function can generate new code by concatenating
    strings that represent executable commands. Note: this can pose security risks
    and is generally not a best practice.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 支持`eval`函数的程序可以通过连接表示可执行命令的字符串来生成新代码。注意：这可能会带来安全风险，通常不是最佳实践。
- en: Some languages, such as LISP, can change their own application code based on
    state information, which provides the flexibility to make new decisions at runtime.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 一些语言，如LISP，可以根据状态信息更改其自己的应用程序代码，这提供了在运行时做出新决策的灵活性。
- en: Other statically typed languages, such as C++, have the ability to evaluate
    expressions and make compile-time decisions to generate code that can be compiled
    statically into the final executable. This is the type of MP that we'll look at
    in the next section.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 其他静态类型的语言，比如C++，有能力评估表达式并做出编译时决策，生成可以静态编译到最终可执行文件中的代码。这是我们将在下一节中看到的MP类型。
- en: Reflection is a form of MP where a program can observe and modify its own structure
    and behavior, such as by determining what type of data a pointer is referring
    to or returning a list of all the properties of an object.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 反射是一种MP形式，程序可以观察和修改自己的结构和行为，比如确定指针引用的数据类型或返回对象的所有属性列表。
- en: Go does not come with support for macros or generics, so it looks like we must
    use reflection. Reflection allows our program to manipulate objects whose types
    are not known at compile time.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Go语言不支持宏或泛型，因此看起来我们必须使用反射。反射允许我们的程序操作那些在编译时类型未知的对象。
- en: 'For example, we can create a linked list of items using the empty `interface{}`.
    That will allow us to put any type of data in our list. When we pull an item out
    of our list, we must use type assertion to assign a data type to it in order to
    use it. The problem is that this is not a type-safe operation, it''s cumbersome
    to use, and it is a slow operation. Using reflection is generally not a best practice.
    Some possible use cases include the following (none of which help us with generics):'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以使用空的`interface{}`创建一个项目的链表。这将允许我们在列表中放入任何类型的数据。当我们从列表中取出一个项目时，我们必须使用类型断言为其分配一个数据类型以便使用它。问题在于这不是一个类型安全的操作，它使用起来很麻烦，而且速度很慢。使用反射通常不是最佳实践。一些可能的用例包括以下内容（这些都不能帮助我们实现泛型）：
- en: Calling functions
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用函数
- en: Recognizing interfaces
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别接口
- en: Validating fields
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证字段
- en: 'For more information on reflection in Go, have a look at the following information:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Go语言中反射的更多信息，请参阅以下信息：
- en: '[golang.org/pkg/reflect/](http://golang.org/pkg/reflect/)'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '[golang.org/pkg/reflect/](http://golang.org/pkg/reflect/)'
- en: '[blog.golang.org/laws-of-reflection](http://blog.golang.org/laws-of-reflection)'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '[blog.golang.org/laws-of-reflection](http://blog.golang.org/laws-of-reflection)'
- en: '[blog.ralch.com/tutorial/golang-reflection/](http://blog.ralch.com/tutorial/golang-reflection/)'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '[blog.ralch.com/tutorial/golang-reflection/](http://blog.ralch.com/tutorial/golang-reflection/)'
- en: '[blog.gopheracademy.com/birthday-bash-2014/advanced-reflection-with-go-at-hashicorp/](http://blog.gopheracademy.com/birthday-bash-2014/advanced-reflection-with-go-at-hashicorp/)'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '[blog.gopheracademy.com/birthday-bash-2014/advanced-reflection-with-go-at-hashicorp/](http://blog.gopheracademy.com/birthday-bash-2014/advanced-reflection-with-go-at-hashicorp/)'
- en: If we shouldn't use reflection, then how can we solve this problem of repetitive,
    boilerplate code?
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不应该使用反射，那么我们如何解决这种重复的样板代码问题呢？
- en: Generics code generation tool
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 泛型代码生成工具
- en: How can we not write all that repetitive code and not take a performance hit,
    nor lose any type safety of our strongly-typed language?
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何不写所有那些重复的代码，又不会受到性能损失，也不会失去我们强类型语言的类型安全性呢？
- en: Let's look at using Go tooling to generate the boilerplate code for us. We'll
    use it to replace `interface{}` in our code with `<T>`. Here, `<T>` represents
    any type that works in the context in which it is found.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看使用Go工具来为我们生成样板代码。我们将用它来用<T>替换我们代码中的`interface{}`。这里，<T>代表在其被发现的上下文中工作的任何类型。
- en: Since we'll be using real types, we'll get compile-time type safety.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将使用真实类型，我们将获得编译时类型安全性。
- en: The clipperhouse/gen tool
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: clipperhouse/gen工具
- en: Though there are several generics code generation tools available, let's look
    at my personal favorite, clipperhouse/gen.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有几种泛型代码生成工具可用，让我们来看看我个人最喜欢的clipperhouse/gen。
- en: 'We get the following functions for free with the clipperhouse/gen tool:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用clipperhouse/gen工具免费获得以下函数：
- en: '| **Aggregation** | **Filter** | **Map** | **Misc** |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| **聚合** | **过滤** | **映射** | **其他** |'
- en: '| [Aggregate[T]](https://clipperhouse.github.io/gen/slice/#aggregatet) | [All](https://clipperhouse.github.io/gen/slice/#all)
    | [Select[T]](https://clipperhouse.github.io/gen/slice/#selectt) | [List](https://clipperhouse.github.io/gen/optional/#list)
    |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '[Aggregate[T]](https://clipperhouse.github.io/gen/slice/#aggregatet) | [All](https://clipperhouse.github.io/gen/slice/#all)
    | [Select[T]](https://clipperhouse.github.io/gen/slice/#selectt) | [List](https://clipperhouse.github.io/gen/optional/#list)
    |'
- en: '| [Average](https://clipperhouse.github.io/gen/slice/#average) | [Any](https://clipperhouse.github.io/gen/slice/#any)
    | [Where](https://clipperhouse.github.io/gen/slice/#where) | [Ring](https://clipperhouse.github.io/gen/optional/#ring)
    |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| [Average](https://clipperhouse.github.io/gen/slice/#average) | [Any](https://clipperhouse.github.io/gen/slice/#any)
    | [Where](https://clipperhouse.github.io/gen/slice/#where) | [Ring](https://clipperhouse.github.io/gen/optional/#ring)
    |'
- en: '| [Average[T]](https://clipperhouse.github.io/gen/slice/#averaget) | [Distinct](https://clipperhouse.github.io/gen/slice/#distinct)
    |  | [Set](https://clipperhouse.github.io/gen/optional/#set) |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| [Average[T]](https://clipperhouse.github.io/gen/slice/#averaget) | [Distinct](https://clipperhouse.github.io/gen/slice/#distinct)
    |  | [Set](https://clipperhouse.github.io/gen/optional/#set) |'
- en: '| [Count](https://clipperhouse.github.io/gen/slice/#count) | [DistinctBy](https://clipperhouse.github.io/gen/slice/#distinctby)
    |  | [stringer](https://clipperhouse.github.io/gen/stringer/#) |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| [Count](https://clipperhouse.github.io/gen/slice/#count) | [DistinctBy](https://clipperhouse.github.io/gen/slice/#distinctby)
    |  | [stringer](https://clipperhouse.github.io/gen/stringer/#) |'
- en: '| [Max](https://clipperhouse.github.io/gen/slice/#max) | [First](https://clipperhouse.github.io/gen/slice/#first)
    |  |  |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| [Max](https://clipperhouse.github.io/gen/slice/#max) | [First](https://clipperhouse.github.io/gen/slice/#first)
    |  |  |'
- en: '| [Max[T]](https://clipperhouse.github.io/gen/slice/#maxt) | [GroupBy[T]](https://clipperhouse.github.io/gen/slice/#groupbyt)
    |  |  |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| [Max[T]](https://clipperhouse.github.io/gen/slice/#maxt) | [GroupBy[T]](https://clipperhouse.github.io/gen/slice/#groupbyt)
    |  |  |'
- en: '| [MaxBy](https://clipperhouse.github.io/gen/slice/#maxby) | [Shuffle](https://clipperhouse.github.io/gen/slice/#shuffle)
    |  |  |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| [MaxBy](https://clipperhouse.github.io/gen/slice/#maxby) | [Shuffle](https://clipperhouse.github.io/gen/slice/#shuffle)
    |  |  |'
- en: '| [Min](https://clipperhouse.github.io/gen/slice/#min) | [Sort](https://clipperhouse.github.io/gen/slice/#sort)
    |  |  |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| [Min](https://clipperhouse.github.io/gen/slice/#min) | [Sort](https://clipperhouse.github.io/gen/slice/#sort)
    |  |  |'
- en: '| [Min[T]](https://clipperhouse.github.io/gen/slice/#mint) | [SortBy](https://clipperhouse.github.io/gen/slice/#sortby)
    |  |  |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| [Min[T]](https://clipperhouse.github.io/gen/slice/#mint) | [SortBy](https://clipperhouse.github.io/gen/slice/#sortby)
    |  |  |'
- en: '| [MinBy](https://clipperhouse.github.io/gen/slice/#minby) |  |  |  |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| [MinBy](https://clipperhouse.github.io/gen/slice/#minby) |  |  |  |'
- en: '`gen` is a code-generation tool for Go. It''s intended to offer generics-like
    functionality for your types. Out of the box, it offers LINQ/underscore-inspired
    methods.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`gen`是一个用于Go的代码生成工具。它旨在为您的类型提供类似泛型的功能。开箱即用，它提供了LINQ/underscore风格的方法。'
- en: '[https://github.com/clipperhouse/gen](https://github.com/clipperhouse/gen)'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/clipperhouse/gen](https://github.com/clipperhouse/gen)'
- en: '[https://en.wikipedia.org/wiki/Language_Integrated_Query](https://en.wikipedia.org/wiki/Language_Integrated_Query)'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/Language_Integrated_Query](https://en.wikipedia.org/wiki/Language_Integrated_Query)'
- en: '[https://en.wikipedia.org/wiki/Underscore.js](https://en.wikipedia.org/wiki/Underscore.js)'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/Underscore.js](https://en.wikipedia.org/wiki/Underscore.js)'
- en: Using the gen tool, we'll gain most of the benefits of generics without the
    performance hits of either reflection or type assertion.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 使用gen工具，我们将获得大部分泛型的好处，而不会受到反射或类型断言的性能损失。
- en: 'What generics do for us is a lot like code generation. At runtime, when we
    pass an `a` of type `A` to a function, it seems magical that our function can
    accept the `a` and do the right thing. What happens most of the time at runtime
    (by JIT or a regular Go compiler, depending on the situation) is that Go does
    a code generation replacement operation. What happens at runtime is that our a
    gets swapped in/out of A-shaped holes in our code. This is the same pattern that
    our generics code generation tool will use to generate generic code for us:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型为我们做的事情很像代码生成。在运行时，当我们将类型为`A`的`a`传递给函数时，我们的函数可以接受`a`并执行正确的操作，这似乎是神奇的。大多数情况下在运行时（由JIT或常规Go编译器，取决于情况），Go进行代码生成替换操作。在运行时发生的是我们的`a`在我们的代码中被换入/换出A形状的空白。这是我们的泛型代码生成工具将用来为我们生成通用代码的相同模式：
- en: '[PRE5]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We''ll use our generics generation tool to swap out any type that fits in the
    T-shaped hole:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用我们的泛型生成工具来替换适合T形空白的任何类型：
- en: '[PRE6]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We can use our gen tool to generate code at development time. It spits out code
    for us, much like an IDE might do.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用我们的gen工具在开发时生成代码。它为我们生成代码，就像IDE可能会做的那样。
- en: We mark up our types using **annotations** in a comment line above the **type**
    of our code for which we want code generation.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用**注释**中的**注释**标记我们的类型，以便我们想要为其生成代码。
- en: Let's work through an example. First, let's go to the correct directory and
    initialize our Go environment by sourcing the init script, running glide-update,
    and pulling gen into our vendors directory.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来工作。首先，让我们进入正确的目录，并通过源init脚本，运行glide-update，并将gen拉入我们的vendors目录来初始化我们的Go环境。
- en: 'Here''s the list of the commands we use:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们使用的命令列表：
- en: '[PRE7]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This is what our directory structure looks like before running `gen`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在运行`gen`之前的目录结构：
- en: '![](img/71ef883b-c503-4457-ae04-1e836013159e.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](img/71ef883b-c503-4457-ae04-1e836013159e.png)'
- en: 'Here''s our directory structure after running `gen`:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们运行`gen`后的目录结构：
- en: '![](img/dc46692b-f53c-4fb9-8087-295c00a04762.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dc46692b-f53c-4fb9-8087-295c00a04762.jpg)'
- en: 'Now, let''s look at our project''s code in `src/car/types.go`:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们项目中的代码在`src/car/types.go`中：
- en: '[PRE8]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Do you see the `// +gen slice:"Where,Sum[Dollars],GroupBy[string],Select[Dollars]` annotation?
    It tells our gen tool to generate a slice of `Car` and give us the following methods:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到了`// +gen slice:"Where,Sum[Dollars],GroupBy[string],Select[Dollars]`的注释吗？它告诉我们的gen工具生成一个`Car`的切片，并为我们提供以下方法：
- en: '`CarSlice.Where`'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CarSlice.Where`'
- en: '`CarSlice.SelectDollars`'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CarSlice.SelectDollars`'
- en: '`CarSlice.SumDollars`'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CarSlice.SumDollars`'
- en: 'When we run gen in the directory with `types.go`, gen will generate a **src/cars/car_slice.go**
    file with the following content:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在带有`types.go`的目录中运行gen时，gen将生成一个名为**src/cars/car_slice.go**的文件，其中包含以下内容：
- en: '[PRE9]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: So, gen is generating all that boilerplate code for us. That keeps our source
    files clean and tidy. If Go supported generics, our code would be similar to the
    code we write that works with gen. How similar? Let's see.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，gen为我们生成了所有那些样板代码。这使我们的源文件保持整洁。如果Go支持泛型，我们的代码将类似于与gen一起使用的代码。有多相似？让我们看看。
- en: 'Here''s our `main.go` file:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的`main.go`文件：
- en: '[PRE10]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here''s the output:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出：
- en: '[PRE11]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: See that `CarSlice` type? That's what gen created for us. We must type in the
    actual struct types, such as `Car`, and gen will create the `CarSlice` type and
    all the methods that we tell it to generate for us in our annotation (just above
    the type definition).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 看到`CarSlice`类型了吗？那是gen为我们创建的。我们必须键入实际的结构类型，比如`Car`，gen将为我们创建`CarSlice`类型和我们在注释中告诉它为我们生成的所有方法（就在类型定义的上面）。
- en: If Go supported generics
  id: totrans-165
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 如果Go支持泛型
- en: 'This is what the same block of code might look like if Go supported generics:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Go支持泛型，同一段代码块可能会如下所示：
- en: '[PRE12]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Looking at this code block from a lazy programmer's perspective, if Go supported
    generics, we'd have to type two extra characters, `<` and `>`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 从懒惰程序员的角度来看，如果Go支持泛型，我们将不得不键入两个额外的字符，`<`和`>`。
- en: It looks like the biggest feature of generic code support has just been neutralized.
    When we consider this information along with the functions we get for free with
    gen and the fact that the performance hit is guaranteed to occur at compile time
    (rather than runtime), it makes Go's direct support of generics seem like a benefit
    or, at the very least, much less of a problem.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来泛型代码支持的最大特性刚刚被中和了。当我们考虑这些信息以及我们通过gen免费获得的函数，以及性能损失保证会在编译时发生（而不是运行时），这使得Go对泛型的直接支持看起来像是一个好处，或者至少是一个不那么严重的问题。
- en: Adding new methods
  id: totrans-170
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 添加新方法
- en: If we want to add methods that gen does not provide to our `CarSlice`, we can
    put those in a separate file. The thing we need to remember is to not type any
    of our source code into the files generated by gen. That's because our code would
    be overwritten the next time we told gen to run.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: Defining a filter function
  id: totrans-172
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A few lines down in our `main.go` file, let''s define a `filter` function that
    will return cars whose `Make` is `Honda.` We use our new `Where` method and pass
    it our `honda` literal function:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here''s the output:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Cool. Next, let''s create a mapping function to return the price field:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here''s the output:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Since we have already filtered by Honda, the result only contains the prices
    of Honda cars.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: 'Aggregation? Sure, we can do aggregation. Let’s call the `SumDollars` function
    that we got for free when we ran our annotation:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here''s the output:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Nums revisited
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Remember those four numerics types that we implemented a `Sum` method for without
    generics? Let''s revisit that code and see if we can improve our code base now
    that we know about gen:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Note that we need to run glide-update so that the vendors directory will be
    created for us. It will first be placed in our GOPATH so that when we run the
    next command, the gen package and its dependencies will go in our vendors directory
    rather than our project’s src directory:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, let''s cd to **~/dev/04_generics_nums/src/num** and run gen:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We can see that gen created four files, one for each slice type:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e19e1fb0-d162-4e12-b621-5ba5ed88711b.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
- en: We have to define each type and annotate that we want gen to create a `Sum`
    method for each slice. Note that we never need to create a type for a slice, only
    the types. Gen creates the slices for each type for us, along with the methods
    that we request in the gen slice annotations.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code from `src/num/types.go`:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This is what one of the generated files (`src/num/int8_slice.go`) looks like:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Remember the price function that we passed to the `Select<T>` function in our
    previous cars example? Let''s have a look at it:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'That''s the kind of function we''ll create in our `src/num/vars.go` file:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We''ll simply return the value that''s passed into our literal function definitions
    in our `fmt.Println` statements:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Here''s the output:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Even with this simple sum numbers example, we see that our gen tool saves us
    from typing the boilerplate loop structures for summing numbers.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: We have only used the `Sum` method, but there are about two dozen more to choose
    from.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: A snippet of documentation describing the `Aggregate` method can be found at
    [https://clipperhouse.github.io/gen/slice/#](https://clipperhouse.github.io/gen/slice/#).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: The slice typewriter
  id: totrans-211
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The slice typewriter is built into gen by default. It generates functional convenience
    methods that will look familiar to users of C#'s LINQ or JavaScript's array methods.
    It is intended to save you some loops, using a pass a function pattern. It offers
    easier ad hoc sorting.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: 'The annotation looks like this:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Here, `Example` is used as a placeholder for your type.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: 'A new type, `ExampleSlice`, is generated, and becomes the receiver for the
    following methods:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: Aggregate[T]
  id: totrans-217
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '`AggregateT` iterates over a slice, aggregating each element into a single
    result. `AggregateT` is comparable to LINQ''s Aggregate and underscores reduce
    function.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the signature:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In the following example, we specify in our comment annotation that we want
    gen to create an `Aggregate` function that operates over a slice of strings. We
    define a `join` function that we pass to `AggregateString,` which performs the
    join operation:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Generics implementation options
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Below is a decision matrix that can be used to evaluate which generics implementation
    is best.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/384b20d6-080a-4b7a-8021-792e51da8da6.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
- en: There are many aspects to consider when we think about how to implement generics.
    For example, let's consider the difference between Haskell's parametric polymorphism
    and C++'s ad hoc polymorphism.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: In Haskell, polymorphic functions are defined uniformly for all types. We could
    call this compile time polymorphism.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: In C++, dynamic polymorphism, via substitution, virtual functions and interfaces
    enable polymorphic behavior, but whether our implementation works for any particular type
    is decided at runtime when the concrete type is substituted for its parameter.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: C++ templates offer a similar functionality without the runtime overhead of
    dynamic polymorphism. The tradeoff is the fact that the flexibility is fixed at
    compile time.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: Type classes in Haskell allow us to define different behaviors for the same
    function for different types. In C++, we do this using template specialization
    and function overloading.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: Note that we are only scratching the surface of the issues, and only with a
    discussion of two languages (C++ and Haskell). There are plenty of edge cases
    to consider. For example, should the Go compiler perform aggressive optimizations?
    If so, that would mean specializing polymorphic functions for all types in which
    they are used, which opens up another level of complexity to manage.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: If generics support were added to Go, there would be a cost and risk involved.
    The cost would come up front, either at compile time or runtime. In all cases,
    the pros and cons of each approach should be carefully evaluated and we should
    be careful what we ask for. We'll talk more about generics in the next chapter.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: For more information on generics and Go, including more tools like gen, you
    can refer to [docs.google.com/document/d/1vrAy9gMpMoS3uaVphB32uVXX4pi-HnNjkMEgyAHX4N4](https://docs.google.com/document/d/1vrAy9gMpMoS3uaVphB32uVXX4pi-HnNjkMEgyAHX4N4).
    Another resource is [golang.org/doc/faq#generics.](https://golang.org/doc/faq#generics)
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: We used the gen tool
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We used the gen tool, which is more aligned with the C++/Template approach.
    While using gen caused us to write a little more code, we were in control, and
    we got some LINQ-like functionality out of the box, which keeps us from having
    to write a lot of boilerplate code for handling slices. Nice!
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: So, does Go support generics? No. But we can use a tool such as gen to solve
    the big problem of having repetitive boilerplate code. We still have our type
    safety and do not pay the performance penalty for using reflection.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: The shape of a functor
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A functor is an algebraic type that accepts a value (or usually, a list of values)
    and has a map function that applies to each element in the list to produce a new
    functor of the same shape. What is a shape?
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an imperative example:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Here''s the output:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The shape in this example means a slice with three ints. We started with a slice
    with three ints, ran our imperative code, and ended up with a slice with three
    ints.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: A functor gets the same results (three elements in and three elements out) but
    a functor does it in a different way.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: 'We give our functor the same slice of three ints. The functor executes `add2`
    for each int and returns a slice with three ints (each of which is two greater
    than before):'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Here''s the output:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: There must be more to a functor than that, right?
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: Yes. The devil is in the details. So, let's shine some light on it.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: Functor implementation
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's look at our ints functor implementation.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: ints functor
  id: totrans-253
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Like the good programmers that we are, we declare our interface at the top of
    our file. Our interface, that is, our contract, has only one function, `Map.`
    Our `IntFunctor` type accepts a `func(int) int` function and returns another `IntFunctor`.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: What? It returns an `IntFunctor?` What is that, and how did it print correctly?
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at `src/functor/ints.go`:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: One feature of a functor is that it applies that `f` function inside its container.
    Now, what is a container?
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: That's our functor's container. We'll call it a `box`, because a box is a container,
    and since we are good, lazy programmers, we prefer names that are short.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: Okay. I see the box. What happens in our magical `box`?
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Firstly, we notice that `Map` is a method and box is the receiver. `Map` takes
    a function and returns another `IntFunctor.` Ah, so we map from one `IntFunctor`
    to another? Yes, indeed.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: Since a functor needs to map one structure to another one, and since there may
    be more than one element to map (and when we say map, we mean transform element
    for element/three in, three out). It's safe to assume we're going to be mapping
    lists of elements.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: How are list shapes in Go usually implemented? With a slice, right? It should
    be no surprise that the receiver of our `Map` method is a slice. Every slice can
    be iterated over using `range,` and that's what we use to iterate through our
    list of elements and apply our function (`f`) to each element and return the `box`
    we were passed. The difference is that the `box` now contains transformed elements.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: Wait a second, what's a `range` with iterator variables `i` and `el`, that are
    mutating, doing in our pure FP world? And even more disturbing is the fact that
    we are mutating the contents of our box. That's right, mutations did occur, but
    only in the box. It's magical, remember? Inside this box is where things can change
    and not affect our otherwise pure world of FP.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: 'How can we draw a line between pure and impure? This is where we do it:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'That''s it. That''s the place where we allow our execution to be lowered into
    the gutter of mutation:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: See the `Functor(ints)` part in the preceding line? That's where we wrap our
    `ints` inside the magical box, and that is where we allow the naughty `add2` mutation
    function to apply itself to each int in our slice.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: This action of lowering elements into the gutter of mutation is typically referred
    to as lifting. I would argue that, according to the upcoming analogy, lifting
    is a misnomer. Lowering would be a more appropriate name for it. For more information,
    see [https://en.wikipedia.org/wiki/Lambda_lifting](https://en.wikipedia.org/wiki/Lambda_lifting).
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: 'What happens in the functor box is not unlike what happens when a person entertains
    impure thoughts. The structure would be the list of three lovely cows dressed
    in polka-dot dresses in one''s mind. The impure person would allow their thoughts
    to be lowered to a place where they would apply the `Undress<T>` literal function,
    where the `T` type in this case would be a Cow:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/900ee368-8112-4bb9-ad0a-bbeb777329c2.jpg)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
- en: Pure FP goes to Hell
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: The person may feel safe knowing that their mind is the magical box where all
    sorts of impure mutations are permitted. When this occurs, a person exercises
    an `Undress` functor and maps lovely, dressed cows from one world down into another.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: When your Momma says, *"Get your mind out of the gutter!"*, this is exactly
    what she's talking about.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: 'The last thing we do in `src/functor.ints.go` is create a `String()` method:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Since we have implemented this one `String()` method, per the duck typing rules
    of Go, our `IntFunctor` is a `Stringer`:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This is a beautiful, one-method interface. `fmt` looks for this interface to
    print values.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: 'The Go Standard Library is very accessible and a great place to go to see how
    things really work. In our example, we see that we passed `v` as the verb (when
    we returned `fmt.Sprintf("%+v", box.ints)` ) around *line 577* in the `print.go`
    file. Here is the snippet from `print.go` that starts on *line 577*:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Functor definition
  id: totrans-285
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Functor ([https://hackage.haskell.org/package/base-4.8.1.0/docs/Data-Functor.html#t:Functor](https://hackage.haskell.org/package/base-4.8.1.0/docs/Data-Functor.html#t:Functor)) class
    is used for types that can be mapped over.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: We'll use Haskell syntax because it so clearly defines FP algebraic data types,
    including their structures, rules, and logic. `fmap` is the map function. The
    period `.` notation is the `compose` operator.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: 'Instances of Functor should satisfy the following identity and associativity
    laws:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We should recognize these two rules from [Chapter 11](../Text/Ch11.xhtml), *Category
    Theory That Applies*.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: Identity operation
  id: totrans-291
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The identity law of our category says that the identity morphism of **A** is
    **A**:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/45776db5-ff12-437d-b841-76c5c71611b4.png)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
- en: If our operation is a map and the elements in our list are numbers, then the
    identity morphism is +0\. If we add 0 to every element of our input list, our
    transformed list will consist of the same elements.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: HEADS UP! We are going to hammer home the concept of composition. Your understanding
    of what composition is and how it works is essential to your ability to be productive
    in pure functional programming. If you read only a few pages in this book, let
    your reading begin now.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: Composition operation
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The composition operation, **g.f** or **g** after **f**, applies function **f**
    to x (which takes us from **A** to **B**) and passes the result of that to **g**
    (which takes us from **B** to **C**), and that nested set of operations is equivalent
    to the composition operation of **g.f**.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: 'In Haskell, we define our composition operation on the first line and request
    to see the type definition of our composition operation on the second line. The
    third line is what the composition means:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The `a`, `b`, and `c` above correspond to the **A**, **B**, and **C** in the
    following diagram.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: It says, when we pass  the **A** to **B** function (**f**) to the **B** to **C**
    function (**g**), we get the **A** to **C** function (**g.f**).
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: 'This is basic composition. Assuming we start at **A**, this diagram says we
    can get to **C** either by way of **B** (**A** to **B** to **C**) or by going
    directly from **A** to **C**. When we choose the short route (**A** to **C**),
    or **g.f**, we compose **g** and **f** in a nested manner, like g(f(x)), where
    x is the value that we get from **A**:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/85c1f822-890f-4447-b754-920dafc3f1c8.png)'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
- en: Not quite there? Hang in there. After a few examples you will be.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: Composition example in Go
  id: totrans-305
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We''re going to create two functions, `Humanize` and `Emphasize` (representing
    f and g), and a composition function of `Emphasize(Humanize(true))` to illustrate
    the path **A** to **B** to **C**:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/04e03132-a800-4159-a025-6386d4dd9684.png)'
  id: totrans-307
  prefs: []
  type: TYPE_IMG
- en: 'The `src/compose/compose.go` file contains the following code:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '`main.go` looks like this:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'If you''re using the init script, then your terminal should look like this:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9b514e34-af68-4690-b047-b3642323ccd0.png)'
  id: totrans-313
  prefs: []
  type: TYPE_IMG
- en: 'If this was a more complicated example that included external packages, then
    you would have run the following (in this order):'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: '`. init`, `glide-update`, and `go-run`'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: Haskell version of compose
  id: totrans-316
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We''ll cover the Haskell version of composing Humanize and Emphasize:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: That's it!  Those five lines are equivalent to the 25 lines of Go code!
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: I am not at all advocating for any Gophers to switch to Haskell--there are far
    too many reasons to keep coding and deploying Go solutions to address here. I
    include the Haskell code for informational purposes. As mentioned earlier in the
    book, category theory trickles down from the brains of the mathematicians directly
    into Haskell. So, if we want to be good, pure functional programming Gophers,
    then we should learn Haskell.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the REPL terminal log of our session:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a5e2627c-878c-4bcf-b32a-5fd0636440ad.png)'
  id: totrans-322
  prefs: []
  type: TYPE_IMG
- en: Let's look a bit closer at some of the lines.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: We can ask our Haskell REPL to tell us the type of what we define using `:t
    <symbol>`.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, `:t humanize` tells us that it is a function (`->`) that takes
    a `Bool` and returns a list of characters:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The `\x` tells Haskell that compose is a lambda expression. We name our lambda
    `compose` and pass the `g` and `f` functions as parameters.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: 'The `g (f x)` says, apply `f` to `x`, take that result, and pass it to `g`:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Now, let''s see what type compose is:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'That''s a little hard to follow. So, let''s see how Haskell says the type is
    of its default implementation of the compose operator:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We''ve seen that before:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2b57e872-3fab-4a46-b5bf-a87286883296.png)'
  id: totrans-335
  prefs: []
  type: TYPE_IMG
- en: 'Great! Now we''re making progress. Time to define our `emphasizeHumanize` composition
    lambda:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '`compose` is our function, and we pass it two parameters--`emphasize` and `humanize`.
    Being good, careful programmers, we''ll check our function literal''s type:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Rock solid! It takes a Bool and returns a string.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, so good. Now it''s time to run this Haskell `compose` function and
    see if we get the same results as we did in Go:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Woot!
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: Given that a lot of Haskellers are mathematicians, we know that they like to
    use symbols instead of words. Furthermore, we know they like their code to look like
    math equations. So, let's think like good, math-minded programmers and spice up
    the syntax.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s redefine the composition function name with the `.` symbol (notice that
    we have to put the `.` in parentheses; otherwise, Haskell complains):'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'And now let''s check its type:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Okay, we can grok that now...it''s basic composition. We can use our period
    in place of compose:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'But that''s not good enough. We can do better. Let''s use the infix notation
    by moving the (.) in between our two parameters, like so:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'And let''s verify that it works:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: (g.f)(x) = g(f(x)) composition in Go
  id: totrans-355
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is a graphical representation of our final example of composition in Go:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: '>![](img/ecafc22b-274b-4a39-8856-eea7314ee282.png)'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: Don't gloss over that diagram. Study it. Let it sink in.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: This is composition, the fundamental principle of functional programming.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: That **(g.f)(x) = g(f(x))** equation is quite literal. It says that we can execute
    the **f** function, **Humanize(true)**, and then pass that value **"yes"** to **g** ... **Emphasize**(**"yes"**)
    to get **"yes!!"**.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: That **(g.f)(x) = g(f(x))** equation says one more thing. It says that we can
    nest our functions, **g(f(x))**, which is like going from **A** to **B** and then
    **B** to **C**, or we can simply go directly from **A** to **C** by executing **EmphasizeHumanize(true)**.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: So, according to the left-hand diagram, **(g.f)(x) == g(f(x))**, and similarly,
    according to the right-hand diagram, **EmphasizeHumanize(true) ==  Emphasize(Humanize(true))**.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7df60447-1a1e-4479-ac5e-6c7c2fb8d0e6.png)'
  id: totrans-363
  prefs: []
  type: TYPE_IMG
- en: Bam!
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: The (g.f)(x) = g(f(x)) implementation
  id: totrans-365
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now let's take a peek at the code.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the **f** and **g** functions from the preceding diagram:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Now for the new stuff.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll create two types. Fbs represents **f** (or **A** to **B**), which takes
    a bool (true), and returns a string, `"yes"`. Fss represents **g** (or **B** to
    **C**). `Fss` takes a string, `"yes"`, and returns a string, `"yes!!"`:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Here''s our `Compose` function:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Nested inside our `Compose` function is an anonymous function. It's our Lambda.
    In Haskell, it looked like `\x -> g (f x)`.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: Lambdas are expressions, and we could pass them around anywhere. We need a function
    that takes a Boolean and returns a `"yes!!"` or a `"no!!"`.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, we define our `g.f` function literal:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: A note about composition naming conventions in Go
  id: totrans-378
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In Go, we don''t have the luxury of renaming a function name with the . symbol
    or a way to easily convert a function call that looks like **compose(f, g)** to
    one that looks like **g compose f**, much less one that looks like **g . f**.
    But no worries! We''ll just use the following naming convention to represent a
    compose function: `Emphasize_Humanize` (which reads, `g . f`, where `g` is `Emphasize`
    and `f` is `Humanize`). Typically, a camelcased symbol would look like `EmphasizeHumanize`,
    but with the `_` separating the camel humps, it''s obvious that this a special
    symbol.'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s main.go:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'And here''s what it looks like when we run it:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/29458000-fc00-4eee-8684-6eaaee0acfbe.png)'
  id: totrans-383
  prefs: []
  type: TYPE_IMG
- en: The directions of the arrows are significant
  id: totrans-384
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the last chapter, we used the following chart to solve *f(x) = x + 2:*
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eb3c1664-0764-49e2-9751-e8222a3db109.png)'
  id: totrans-386
  prefs: []
  type: TYPE_IMG
- en: 'Remember when we composed *f(x) = x + 2* with *g(x) = x2 + 1*? We solved **g(f(1))
    = 10**:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8b95812f-0f1a-47a6-bf5d-02a5fbaf3658.png)'
  id: totrans-388
  prefs: []
  type: TYPE_IMG
- en: We also proved that **f(g(1)) = 4**, which is obviously not **10**. So, we know
    that function composition is not commutative. The arrows go one way only.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: EmphasizeHumanize ordered incorrectly
  id: totrans-390
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When we try to reverse the order of operations, this is what we''re trying
    to do:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0499e2cc-9754-426f-8d2f-c0e33c2d6854.png)'
  id: totrans-392
  prefs: []
  type: TYPE_IMG
- en: This does not compute.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by passing a Boolean **true** to **Emphasize**, but what does that
    mean?  What are we trying to do?  We are not changing the direction of the arrows,
    but we are attempting to change the order in which we call them. Given our context
    of beginning with a Boolean and trying to get a `"yes!!"` or a `"no!!"` out, it
    only makes sense to apply our `Humanize` and `Emphasize` functions in one direction.
    We are, in effect, trying to compose backwards:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Note that the rest of the code is identical to before. We only swapped the nesting
    order of **f** and **g** in our return statement.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: 'Our function literal that calls our `Compose` function looks like this:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: That says, *"Emphasize the true and then Humanize the result of that"*, which
    is clearly not going to work (see the preceding diagram).
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: 'This code won''t even compile:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6d32204b-2ad1-45ba-83f4-3fa6407afc60.png)'
  id: totrans-401
  prefs: []
  type: TYPE_IMG
- en: Function composition is associative
  id: totrans-402
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So, function composition does not commute, but it is associative:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0c6f1211-4f95-468c-8aee-f8824c3dd744.png)'
  id: totrans-404
  prefs: []
  type: TYPE_IMG
- en: That diagram says that we can compose our functions to get from **A** to **D**
    by either choosing the upper (**A****→C**→**D**) path or the lower (**A**→**B**→**D**) path.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: The idea of a functor is that it translates the diagrams we can draw in one
    category into diagrams in another category. This often lets us convert ideas and
    theorems from one category into another.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at an example of a particular functor, the forgetful functor, to
    get a better feel for what it means to convert things from one category into another.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: Functional composition in the context of a legal obligation
  id: totrans-408
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Assume that Larry agreed to pay Lucy $5,000 by 1st October and that date has
    passed. Lucy wants to get paid $5,000 and Larry wants to pay her, but he does
    not have the money.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: Should Lucy sue Larry to get him to pay?
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: 'The following category diagram describes their situation:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b6196744-65f1-403c-8569-d9979a00200c.png)'
  id: totrans-412
  prefs: []
  type: TYPE_IMG
- en: 'The category states are as follows:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: '**A** = Where we are today (12th October)'
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**B** = Lucy demands a lawsuit'
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**C** = Lucy gets paid'
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The category morphisms are as follows:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: '**f** =  Legal expense (for both, $2,000+)'
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**g** = Larry pays Lucy $5,000'
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**h** = Larry pays Lucy $5,000'
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decisions determine state transitions
  id: totrans-421
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If Larry, in good faith, communicates the following to Lucy, which path will
    Lucy take?
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: To be clear, I'm simply asking for more time to pay or for you to allow me to
    make scheduled payments directly to you without going through the court system.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: Your thoughts?
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: Larry
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: It's obvious that these two will eventually get from **A** to **C**, but which
    path is the shortest? Which path is more costly, both in terms of time and financial
    expenses?
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: Category theory review
  id: totrans-427
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We connect two arrows from **A** to **B** and **B** to **C**, and another equivalent
    arrow from **A** to **C**. **A**, **B**, and **C** are called objects. They can
    represent anything. In this example, they represent states--beginning (**A**),
    intermediate (**B**), and final (**C**) states. In the next example, the domain
    and range represent different court cases, different worlds. The facts of each
    case make up the structure of each, and the arrows between the two worlds are
    the mappings the attorneys perform to make their case.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: Categorical rules
  id: totrans-429
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There are only two rules that must be followed:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: Identity
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Associativity
  id: totrans-432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Results oriented
  id: totrans-433
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Category theory is results oriented. It''s all about getting from **A** to
    **C**. The arrows are one-directional. When we compose the two paths (**A** →
    **B** and **B** → **C**), we get an equivalent path (**A** → **C**). That is what
    we are doing when we compose functions. We can call one `Compose` function (shown
    in the following snippet) rather than two functions (`f` and `g`):'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The forgetful functor and the law
  id: totrans-436
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Suppose Lucy chooses the longer path; how will Lucy's attorneys make the case
    for their client?
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: Let's assume there is more to this story. Let's assume that Lucy has injured
    Larry in some way in the past, and now that Lucy is forcing Larry into a lawsuit,
    he will in turn choose to convey this new information to his attorney in order
    to file a counterclaim.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: The rule of law
  id: totrans-439
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: How will the law work when they go to court? The attorneys research the law
    to find a case from prior court cases that might yield favorable results for their
    client. They then use that case's ruling as a precedent to win the current case
    for their client.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: It is impossible to refer to the entirety of case history to prove their point.
    So, attorneys for both sides will use a rhetorical device, known to category theorists
    as the forgetful functor. The forgetful functor necessarily leaves behind some
    structure. It is very difficult to find a case from the past that is identical
    in every way to the case at hand.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: Each attorney attempts to convince others that the structure that they present--that
    is, the one court case that, if chosen, would yield the best results for their
    client--is the one that should be applied.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: The reality is that there is a very large number of court rulings in the past
    that could apply, but each attorney will try to convince the judge and/or jury
    that the case that they choose is the way the the law actually is.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: The winning side will have effectively mapped a prior court ruling from a world
    that included different parties (plaintiff, defendants, and case facts) onto the
    current case. Some of the details will be different, but the winning attorney
    is the one that best communicates that they have identified the most relevant
    and applicable case to apply in court today.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: Each attorney identifies the bilateral symmetry between an old case that will
    best help their client and the present court case, and does their part to convince
    others to apply that case. We might hear the argument begin this way, *"Ladies
    and gentlemen, the essential structure you need to apply is this one**".*
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: Lucy’s forgetful functor
  id: totrans-446
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Given that G is their current case, with its current set of facts, Lucy''s
    attorney maps the facts from the case (**E**) that helps Lucy the most:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0e32e19a-3dfd-40db-94ea-248a677711f2.png)'
  id: totrans-448
  prefs: []
  type: TYPE_IMG
- en: '**f[Lucy]** is the mapping function from the facts of case **E**, with precedence
    in favor of Lucy.'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: Larry’s forgetful functor
  id: totrans-450
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Larry''s attorney maps the facts from the case (**F**) that helps Larry the
    most:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2b9faa05-5037-48ac-af96-bd719c58b1d4.png)'
  id: totrans-452
  prefs: []
  type: TYPE_IMG
- en: It's up to the judge and/or jury to decide which mapping fits best with the
    current case under review. The side with the best mapping wins.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: It's time to code another functor (pun intended).
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: Build a 12-hour clock functor
  id: totrans-455
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ll build a 12-hour clock functor like this one:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: '| **Structure** | A clock with 12 places for the hours |'
  id: totrans-457
  prefs: []
  type: TYPE_TB
- en: '| **Transformation operation** | *f(x) = x + 12*, where *x* is the hour |'
  id: totrans-458
  prefs: []
  type: TYPE_TB
- en: '![](img/3da5772f-617f-406d-b8a1-9163d5f7c878.png)'
  id: totrans-459
  prefs: []
  type: TYPE_IMG
- en: 'First, let’s examine the functor implementation:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Define our `ClockFunctor` interface to include a single function (`Map`):'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Create a container to hold our list of 12 hours:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'When called, `Map` will be executed/applied to each element in the container:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: It's okay for the implementation of `Map` to be impure, as long as the side
    effects are limited to variables, such as the loop variables, scoped to the `Map`
    function. Notice that return the container, that we call `box`, whose elements
    have been transformed in some way by the mapper function, **f**.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we create a function named Functor that wraps our list of 12 hours into
    the magical box for transformation. This is where we lower our values into the
    gutter. Some call this process lifting, where the mapping transformation from
    one world to another occurs (for details, see *Pure FP goes to Hell* earlier in
    this chapter):'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Clock functor helpers
  id: totrans-471
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Towards the end of our `clock.go` file, we'll add some helpers, as discussed
    in the following sections.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: The Unit function
  id: totrans-473
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Our `Unit` function is our identity function. When applied to elements in the
    slice, it will have no effect. It''s trivial, but it''s a requirement to satisfy
    the functor algebraic laws:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: The AmPmMapper function
  id: totrans-476
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This is the mapper we apply when we want to change from AM to PM hours. It will
    be passed to the `Map` method and applied to each hour contained in the box. It
    converts an AM hour (1, 2...12) to its corresponding PM hour (13, 14..0).
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: The AmHoursFn helper
  id: totrans-479
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We can call this handy function any time we want the list of AM hours. Note
    that if we create an `AmHours` variable to pass to our clock''s functor, its value
    can be changed. So, this is like a slice constant of AM hours:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: In real-world scenarios, we'll use functors as intended, that is, we will pass
    an initial slice of values in and allow each functor to transform the slice of
    values each time a new functor's `Map` function is called. In our `main.go` file,
    we want to reset the set of hours for learning purposes.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
- en: The String helper function
  id: totrans-483
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Create a String helper function to use when printing the functor''s contents:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: main.go
  id: totrans-486
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We start with our typical `package main` and `import` statements and the `main()`
    function:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Note that we preface our internal `functor` package (found in the `src` directory)
    with a dot. That allows us to refer to symbols that it exports, such as `Functor`
    and `Map.`
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
- en: First, we call our `Functor` method and pass in our slice of `AmHours`. `Functor`
    wraps our hours structure in a function of type `ClockFunctor:`
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Here''s the output:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'The `Functor` function is what connects our two worlds: the world of AM hours
    and the world of PM hours (or vice versa). We can say that `Functor` lowers our
    hours into a magical box where the transformation mapping function, `amPmMapper`,
    is applied to each element, transforming it into its corresponding PM (or AM)
    hour.'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the mapper function must be free of any side effects:'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Here''s the output:'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: We can see that when we pass our functor's identity function, unit, to its `Map`
    method, it returns what we passed it, that is, the AM hours.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
- en: 'Now for the fun part. Let''s pass our mapping function to our functor:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Here''s the output:'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Awesome! Our list of AM hours has been transformed into a list of PM hours.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s show off and chain two `Map` calls:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Here''s the output:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Why was that showing off?  It does not look like anything changed. Lame. Right?
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
- en: Wrong. We're chaining our functors.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2330d241-2d2b-4a81-9b91-50bb0bfad2fb.png)'
  id: totrans-511
  prefs: []
  type: TYPE_IMG
- en: The reason why the output doesn't look like it's changed is because it went
    from AM hours to PM hours and back to AM hours.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
- en: Terminal output log
  id: totrans-513
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Here''s what it looks like in our terminal:'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/243541e1-0f3c-4980-aab4-e6517bfb0c19.png)'
  id: totrans-515
  prefs: []
  type: TYPE_IMG
- en: Functor summary
  id: totrans-516
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Our clock functor comprises a structure (an int slice) that holds 12 hours and
    a `Map` method that accepts a mapper function that is used to transform each of
    the 12 hours into the subsequent set of 12 hours (AM/PM). Each time the `Map`
    method is executed, it returns a new functor; because of this feature, we can
    chain our `Map` method calls.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
- en: 'In other words, have a look at the following example:'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: We see that with functors, we wrap and `Map` (and can chain our maps).
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
- en: The car functor
  id: totrans-521
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's use a functor to upgrade (and downgrade) some cars! We'll start by opening
    our `car.go` file in our `functor` package.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
- en: The functor package
  id: totrans-523
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s have a look at `src/functor/car.go`:'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: It's good practice to define our types at the top. Putting them in a type block
    helps to keep our code clean and tidy. Another good practice is to add JSON annotations
    to each field of a struct to enable easy (un)marshalling of JSON into our `Car`
    struct.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to omit empty fields from a struct, you can add the `omitempty`
    clause to the end of your field annotation. For example, if the `Make` was optional
    or sometimes not included and we didn''t want the `json` created from a `Car`
    struct to include empty `Make` fields, our struct definition would look like this:'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
- en: '`Car struct {`'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
- en: '`    Make string `json:"make"``'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
- en: '`    Model string `json:"model,omitempty"``'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
- en: '`}`'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
- en: 'Next comes our interface definition that includes the single `Map` method:'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'And here''s our magical box that consists of the slice we''ll be transforming:'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Here''s our `Map` method implementation, where we iterate through the elements
    of the slice of cars in our magical box, applying the mapping function `f` to
    each element:'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Here''s our `Wrap` method that is used to lower our slice of cars into the
    magical box for transformation:'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Here we define our helper functions. `Unit` we''ve seen before--it''s our identity
    morphism. The other two are `Upgrade` and `Downgrade.` We''ll keep it simple and
    simply append an `" LX"` to the end of the model name when we upgrade or remove
    it to downgrade a car:'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Lastly, we include a `String` method so that our `fmt` package knows how to
    print our cars:'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: main.go
  id: totrans-544
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We''ll manipulate strings and some JSON, as well as a `car` functor:'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-546
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Create a `cars` variable to hold a `Car` type and initialize it with two cars.
    Since we annotated our `Make` and `Model` fields with `''json''`, we can easily
    unmarshal a `Toyota Highlander` into a car:'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Now, let''s exercise our `car` functor and verify that it works properly:'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Compare one line of FP to a bunch of imperative lines
  id: totrans-551
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: It takes one line of FP-style code to apply an upgrade and downgrade to a car.
    Granted, the `Upgrade` and `Downgrade` mapper functions were defined in the `functor`
    package, but that's a great benefit. We can keep the boilerplate implementation
    of looping through the slice of cars separate from our business use case logic.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
- en: 'With the imperative implementation style, we first implement the `for...range`
    iteration block into which we insert our Upgrade/Downgrade logic:'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: See the difference?
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
- en: Which style of coding will be easier to maintain?
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
- en: Car functor terminal session
  id: totrans-557
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let''s run our car functor example:'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ff3b748b-7219-4d67-a60a-26b586fc36ea.png)'
  id: totrans-559
  prefs: []
  type: TYPE_IMG
- en: Monoids
  id: totrans-560
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Monoids are the most basic way to combine any values. A monoid is algebra that
    is closed under an associative binary operation and has an identity element.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
- en: We can think of a monoid as a design pattern that allows us to quickly reduce
    (or fold) on a collection of a single type in a parallel way.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
- en: Monoid rules
  id: totrans-563
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A monoid is anything that satisfies the following rules:'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
- en: Closure rule
  id: totrans-565
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Associativity rule
  id: totrans-566
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identity rule
  id: totrans-567
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's discuss these rules in brief.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
- en: Closure rule
  id: totrans-569
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: “If you combine two values of same type, you get another value of the same type.”
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
- en: Given two inputs of the same type, a monoid returns one value of the same type
    as the input.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
- en: Closure rule examples
  id: totrans-572
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 1 + 2 = 3, and 3 is an integer.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
- en: 1 + 2 + 3 also equals an integer.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
- en: 1 + 2 + 3 + 4 also equals an integer.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
- en: Our binary operation has been extended into an operation that works on lists!
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
- en: Closure axiom
  id: totrans-577
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: If a, b ∈ S, then a + b ∈ S.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
- en: That says, if a and b are any two values in the set S of integers and if we
    apply the binary operation + to any two values, then the result of that addition
    operation will be a value that is also in the set of integers.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
- en: Associativity rule
  id: totrans-580
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: “If you combine several more values, the order in which you combine does not
    matter”
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: So, if we have 1 + 2 + 3 + 4, we can transform that into ( 1 + 2 ) + ( 3 + 4
    ).
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
- en: Note that associativity works for addition and multiplication and string concatenation,
    but not for subtraction and division.
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
- en: Identity rule
  id: totrans-585
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: “There is an identity element that doesn’t do anything.”
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
- en: '- Identity rule'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
- en: A monoid will take two values of the same type and return one value of the same
    type.
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
- en: Identity rule examples
  id: totrans-589
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Under the + operator, the set of integers has an identity of 0.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
- en: '| Rule | Example |'
  id: totrans-591
  prefs: []
  type: TYPE_TB
- en: '| Left identity | 0 + 1 == 1 |'
  id: totrans-592
  prefs: []
  type: TYPE_TB
- en: '| Right identity | 1 + 0 == 1 |'
  id: totrans-593
  prefs: []
  type: TYPE_TB
- en: Notice that the operator is binary, that is, it takes two inputs, and those
    inputs must be of the same type.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
- en: The result of combining the identity element (sometimes called empty or zero)
    with x is always x.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
- en: An identity of 0
  id: totrans-596
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Under the * operator the set of integers has an identity of 1.
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  id: totrans-598
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Writing a reduction function
  id: totrans-599
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Given the previous three rules, we can write a reduction function. When we run
    a reduction on an array of integers using addition, we seed our operation with
    a 0 (the identity element).
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
- en: When we run a reduction on an array of integers using multiplication, we seed
    our operation with a 1 (the identity element).
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s the idea. The following table summarizes a number of possible reductions:'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
- en: '| **Type** | **Operation** | **Unit/zero/neutral value** |'
  id: totrans-603
  prefs: []
  type: TYPE_TB
- en: '| ints | + | 0 |'
  id: totrans-604
  prefs: []
  type: TYPE_TB
- en: '| ints | * | 1 |'
  id: totrans-605
  prefs: []
  type: TYPE_TB
- en: '| string | + (concat strings) | “” |'
  id: totrans-606
  prefs: []
  type: TYPE_TB
- en: '| bool | && | true |'
  id: totrans-607
  prefs: []
  type: TYPE_TB
- en: '| bool | &#124;&#124; | false |'
  id: totrans-608
  prefs: []
  type: TYPE_TB
- en: '| list | << (concat list) | [] |'
  id: totrans-609
  prefs: []
  type: TYPE_TB
- en: '|  |  |  |'
  id: totrans-610
  prefs: []
  type: TYPE_TB
- en: A semigroup is a missing neutral value
  id: totrans-611
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If we are missing the unit/zero/neutral value, then we don’t have a monoid,
    we have a semigroup. Note that a semigroup can be converted into a monoid.
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
- en: That was a very interesting discussion of the algebra of monoids, but what the
    heck are they good for, and why should we care?
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
- en: Here are a couple of good uses for monoids.
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
- en: Converting binary operations into operations that work on lists
  id: totrans-615
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Consider the following operation:'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  id: totrans-617
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: Instead of having to write all that code where we type a number, type a `+`,
    type another number, and we can feed a list of numbers into our reduce function
    that applies the `+` operation to each item and accumulates the sum.
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example of appending strings:'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  id: totrans-620
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: What was the neutral/identity element used in each of the preceding examples?
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
- en: The preceding code is F# code. The `|>` symbol is just a pipe symbol, like we
    use in a Unix terminal. It allows us to pipe the list of integers `[1,2,3]` or
    a list strings `["a", "b", "c"]`  into `List.reduce(+)`. The greater than symbol
    is just an indication of the direction of the flow of data, that is, from left
    to right.
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
- en: Using monoids with divide and conquer algorithms
  id: totrans-623
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Monoids are frequently used to solve large computations. Monoids help us to
    break our computations into pieces. We can run smaller computations in separate
    cores or on separate servers and recombine/reduce/fold the results into a single
    result. We often employ parallel or concurrency techniques along with incremental
    accumulation of our result.
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
- en: 'As a very simple example, if we need to add these numbers: 1 + 2 + 3 + 4.'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
- en: 'We can add ( 1 + 2 ) on one CPU/core and ( 3 + 4 ) on another:'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
- en: 3 + 7 = 10
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
- en: Where associativity holds, we can parallelize our computations.
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
- en: Referential transparency
  id: totrans-629
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Identifying when using monoid can help us make design decisions that affect
    performance.
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
- en: 'On day one, we''re asked to add 1 + 2 + 3\. Then, on day two, we''re asked
    to add 1 more. We don''t have to add 1 + 2 + 3 again. We can simply store that
    and add our new 1 to it:  6 + 1 = 7.'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
- en: Given that nothing is free, what did it cost us to gain the performance boost
    of not having to add 1 + 2 + 3? Storage. The question becomes, which is more costly?
    The answer to that will tell us whether to leverage referential transparency or
    not. Just because we can do something does not mean we always should.
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
- en: Handling no data
  id: totrans-633
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What if we have no data but we're asked to reduce it? Similarly, what if we
    have no data but we’re asked to incrementally add to it?
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
- en: This is when the identity element comes in handy! It can be the initial value
    for missing data.
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
- en: More examples of monoids
  id: totrans-636
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Lists are monoids. The operation to combine them is simply concatenation. Many
    types of containers are also monoids, including monads.
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
- en: What are not monoids?
  id: totrans-638
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Integers are not monoids, but integers under addition (a way to combine them)
    are monoids.
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
- en: Whole numbers (integers starting at 1), and even whole numbers under addition,
    are not monoids. What is the neutral element for addition? The answer is zero.
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
- en: 'Invoices are not monoids:'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0b8f0dc3-8f8b-4661-bfbc-136ea1ba44c6.png)'
  id: totrans-642
  prefs: []
  type: TYPE_IMG
- en: How can we combine two invoices?
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/412e3faf-2ded-4b05-99c7-1c1353b2a4a8.png)'
  id: totrans-644
  prefs: []
  type: TYPE_IMG
- en: What does it mean to add invoices? Are we going to merge the colors or somehow
    smash them together? If we stack them, how can we do anything with them, other
    than take the top one off the list? How do we combine the customer addresses?
    Sure, we can add the work order numbers, 1,000 + 1,000 = 2,000, but what value
    is that to us?
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
- en: How could we possibly add invoices? Maybe if we choose some fields that are
    statistical in nature?
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
- en: Monoid examples
  id: totrans-647
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ll cover three types of monoid here:'
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
- en: Name monoid
  id: totrans-649
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Int slice monoid
  id: totrans-650
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Line item monoid
  id: totrans-651
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That's right. We're going to turn that invoice into a monoid!
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
- en: Name monoid
  id: totrans-653
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's see what we can do with a name. First, we define an interface that has
    two methods, `Append` and `Zero.` We wrap our name in `nameContainer.`
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
- en: Our `nameContainer` is a struct with a single string field, `name`. Our `Append`
    method appends the given name to the long name string it's building up that lives
    in the magical `nameContainer`. Our zero morphism for our name string is an empty
    string.
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
- en: 'The content of `src/monoid/name_monoid.go` would look as follows:'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  id: totrans-657
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Here''s what `main.go` looks like:'
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  id: totrans-659
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: Name monoid terminal session
  id: totrans-660
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let''s run our monoid:'
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00863fff-a211-46a6-b700-096d647b1250.png)'
  id: totrans-662
  prefs: []
  type: TYPE_IMG
- en: Here, we ran our app and got good results. The initial state is Alice, and the
    **Zero** value is the empty string; after the first append we get **AliceAlice,**
    and when we chain another we get **AliceAliceAlice.**
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
- en: Int slice monoid
  id: totrans-664
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Let's see what we can do with a slice of ints.
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
- en: First, we define an interface that has two methods, `Append` and `Zero.` We
    wrap our int in `intContainer`. `intContainer` is a struct with a single int field,
    `ints`. Our `Append` method appends the given int slice to the slice of `ints`
    it's building up that lives in the magical `intContainer`. The `Zero` morphism
    for a slice is `nil`.
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the content of `src/monoid/int_monoid.go`:'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  id: totrans-668
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: That is just about the same logic as the Name monoid, except for that `Reduce`
    method. The `Reduce` method will allow us to combine all of our ints with our
    binary operator, addition, and arrive at a sum of all ints in the `intMonoid`
    container.
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
- en: 'The contents of `main.go` are as follows:'
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  id: totrans-671
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'We call the same list of methods we did for our `nameMonoid` and get correct
    results. The interesting line is the last one, where we chain our Appends and
    then call Reduce to sum up our ints:'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4e8a85ac-c638-49da-a812-1693649b8ac4.png)'
  id: totrans-673
  prefs: []
  type: TYPE_IMG
- en: Int slice monoid terminal session
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
- en: Lineitem slice monoid
  id: totrans-675
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Let's see what we can do with a slice of line items.
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we define an interface that has three methods, `Append`, `Zero`, and
    `Reduce.` We wrap our line items in the `lineitemContainer.` Our `lineitemContainer`
    is a struct with three fields that correspond to our invoice''s line items:'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  id: totrans-678
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Our `Append` method appends the given line item to the slice of line items it's
    building up that lives in the magical `lineitemContainer`.
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
- en: The `Zero` morphism for a slice is `nil`.
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
- en: 'The `src/monoid/lineitem_monoid.go` file will have the following code:'
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  id: totrans-682
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: That is just about the same logic as the `Int` slice monoid, except for that
    `Reduce` method. The `Reduce` method will allow us to combine all of our line
    item fields with our binary operator, addition, and arrive at a sum total of all
    line item entries in the `lineitemMonoid` container.
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
- en: 'The `main.go` file will have the following code:'
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  id: totrans-685
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: That's the same stuff we verified with the other monoids. Our feeder value,
    line items, is a slice of three line item tuples. Verify that the math of the
    `Reduce` works.
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
- en: Int slice monoid terminal session
  id: totrans-687
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Looking at the last line of output, we can see that we have called our `Reduce`
    function to sum our totals (`totalQuantity`, `totalPrice`, and `totalListPrice`):'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/43b2d198-4888-4d14-b678-1d996b294807.png)'
  id: totrans-689
  prefs: []
  type: TYPE_IMG
- en: For a quick manual verification, let's look at `totalQuantity`--*1+2+5+1+2+5+1+2+5
    = 24*. Looks good!
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-691
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we learned how to use tooling to solve issues that arise in
    Go because of its lack of support for generics. We were able to use this tooling
    to generate underscore like features in our Go code by starting with properly
    defined base types. With no more worries about potential generics support slowing
    down our runtime executables (as is the case with Java), we jumped for joy with
    an unexpected productivity boost.
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
- en: We continued forward into the land of pure FP, where we tackled the concept
    of function composition. With `g.f(x) == g(f(x))` in our tool belt, we studied
    functors and learned how to transform lists of items. We chained our maps and
    even learned how attorneys can use the forgetful functor to win cases in court
    for their clients.
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
- en: We wrapped up the chapter with monoids. We not only learned the algebraic laws
    of monoids, but we implemented them. We chained `Append` methods and even wrote
    a couple of reductions.
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll continue our on our path towards pure enlightenment,
    and maintain our quest for simpler code and improved error handling.
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
