- en: Using Sorting Algorithms
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sorting is one of the most used algorithms in computer programming. Even in
    our everyday life, if things are not sorted, we can have a hard time with them.
    Sorting can pave the way for faster searching or ordering of items in a collection.
    Sorting can be done in many different ways, such as in ascending order or descending
    order. Sorting can also be based on the type of data. For example, sorting a collection
    of names will require lexicographical sorting rather than numerical sorting. As
    sorting can play an important role for other data structures and their efficiencies,
    there are many different sorting algorithms available. We will explore a few of
    the most popular sorting algorithms in this chapter, along with their complexity
    and usages.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Understanding sorting and their types
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sorting means a sorted order of the data. Often, our data is unsorted, which
    means we need a way to sort it. Usually, sorting is done by comparing different
    elements with each other and coming up with the ranking. In most cases, without
    the comparison, we cannot decide on the sorting part. After the comparison, we
    also need to swap the elements so that we can reorder them. A good sorting algorithm
    has the characteristics of making a minimum number of comparisons and swapping.
    There is also non-comparison based sorting, where no comparison is required to
    sort a list of items. We will also explore those algorithms in this chapter.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'Sorting can be classified into different types based on the type of data set,
    direction, computational complexities, memory usage, space usage, and so on. Here
    are few of the sorting algorithms we will explore in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Bubble sort
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Insertion sort
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selection sort
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Quick sort
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Merge sort
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bucket sort
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will keep our discussion limited to the preceding list, as they are the most
    commonly used sorting algorithms and can be grouped and classified under different
    criteria such as simple sorting, efficient sorting, distribution sorting, and
    so on. We will now explore each of the sorting functionalities, their implementations,
    and complexity analysis, along with their pros and cons. Let's get started with
    the most commonly used sorting algorithm - bubble sort.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Understanding bubble sort
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Bubble sort is the most commonly used sorting algorithm in the programming world.
    Most of the programmers start learning about sorting with this algorithm. It is
    a comparison-based sorting algorithm, which is always referred to as one of the
    most inefficient sorting algorithms. It requires maximum number of comparisons,
    and the average, and worst case complexity are the same.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: 'In bubble sort, each item of the list is compared with the rest of the items
    and swapped if required. This continues for each item in the list. We can sort
    either in ascending or descending order. Here is the pseudo algorithm for bubble
    sort:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As we can see from the preceding pseudocode, we are running one loop to ensure
    that we iterate each item of the list. The inner loop ensures that, once we point
    to an item, we are comparing the item with other items in the list. Based on our
    preference, we can swap the two items. The following image shows a single iteration
    to sort one item of the list. Let''s assume our list has the following items:
    **20** , **45** , **93** , **67** , **10** , **97** , **52** , **88** , **33**
    , **92** . For the first pass (iteration) to sort out the first item, the following
    steps will be taken:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00057.gif)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
- en: If we check the preceding image, we can see that we are comparing two numbers
    and then deciding whether we are going to swap/exchange the item. The items with
    background color shows the two items we are comparing. As we can see, the first
    iteration of the outer loop causes the topmost items to be stored in the topmost
    places in the list. This will continue until we iterate through each of the items
    in the list.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Let's now implement the bubble sort algorithm using PHP.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Implementing bubble sort using PHP
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since we are assuming the unsorted number will be in a list, we can use a PHP
    array to represent the list of unsorted numbers. Since the array has both index
    and values, we can utilize the array to easily iterate through each item, based
    on position, and swap them where it is applicable. The code will look like this,
    based on our pseudocodes:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As we can see, we are using two `for` loops to iterate each item and comparing
    with the rest of the items. The swapping is done in the lines:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: First, we assigned the second value to a temporary variable named `$tmp` . Then,
    we assigned the first value to the second value and reassigned the temporary value
    to the first value. This is known as swapping two variables using a third or temporary
    variable.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: 'We are only swapping if the first value is greater than the second value. Else,
    we are just ignoring. The comment on the right-hand side of the image shows whether
    an exchange occurred or not. If we want to sort it in a descending order (bigger
    number first), then we can just modify the `if` condition as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, let''s run the code as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This will produce the following output:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: So, we can see that the array is sorted using the bubble sort algorithm. Now,
    let's discuss the complexity of the algorithm.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Complexity of bubble sort
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For the first pass, in the worst case, we have to do *n-1* comparison and swapping.
    For the *n-1th* pass, in the worst case, we have to do only one comparison and
    swapping. So, if we write it step by step then we will see:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '*Complexity = n - 1 + n - 2 + .......... + 2 + 1 = n * ( n - 1)/2 = O(n² )*'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: Thus, the complexity of bubble sort is `O(n² )` . However, there is some constant
    time required to assign a temporary variable, swapping, go through inner loops,
    and so on. We can ignore them since they are constant.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the time complexity table for bubble sort, for best, average, and worst
    case scenarios:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '| Best time complexity | `Ω(n)` |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
- en: '| Worst time complexity | `O(n² )` |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
- en: '| Average time complexity | `Θ(n² )` |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
- en: '| Space complexity (worst case) | `O(1)` |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
- en: Though the time complexity is `O(n² )` for bubble sort, we can still apply some
    improvements to reduce the number of comparison and swaps. Let's now explore those
    options. The best time is `Ω(n)` since we need at least one inner loop to run
    to find out that the array is already sorted.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: Improving bubble sort algorithm
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the most important aspects of bubble sort is that, for each iteration
    in the outer loop, there will be at least one swapping. If there is no swapping,
    then the list is already sorted. We can utilize this improvement in our pseudocode
    and redefine it like this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As we can see that we now have a flag set for each iteration to be `false`
    , and we are expecting that, inside the inner iteration, the flag will be set
    to `true` . If the flag is still false after the inner loop is done, then we can
    break the loop so that we can mark the list as sorted. Here is the implementation
    of the improved version of the algorithm:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Another observation is that, in the first iteration, the top item is placed
    to the right of the array. In the second loop, the second top item will be in
    the second to the right of the array. If we can visualize that after each iteration,
    the *i^(th)* cell has already stored the sorted items, there is no need to visit
    that index and do a comparison. As a result, we can reduce the outer iteration
    number from the inner iteration and reduce the comparisons by a good margin. Here
    is the pseudocode for the second improvement we are proposing:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, let''s implement the final improved version with PHP:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If we look at the inner loop in the preceding code, the only difference is
    `$j < $len - $i - 1` ; other parts are the same as the first improvement. So,
    basically, for our **20** , **45** , **93** , **67** , **10** , **97** , **52**
    , **88** , **33** , **92** list, we can easily say that after the first iteration,
    the top number **97** will not be considered for second iteration comparison.
    The same goes for **93** , which will not be considered for the third iteration,
    just like the following image:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00058.gif)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
- en: 'If we look at the preceding image, the immediate question that strikes our
    mind is "Isn''t **92** already sorted? Do we need to again compare all numbers
    and mark that **92** is already sorted in its place?" Yes, we are right. It is
    a valid question. This means that we can know, in which position we did the last
    swap in the inner loop; after that, the array is already sorted. So, we can set
    a bound for the next loop to go, until then, and only compare until the boundary
    we set. Here is the pseudocode for this:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here, we are setting the bound after completion of each inner loop and making
    sure we are not iterating unnecessarily. Here is the actual PHP code using the
    preceding pseudocode:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We have seen different variations of bubble sort implementations, but the output
    will always be the same: **10** , **20** , **33** , **45** , **52** , **67** ,
    **88** , **92** , **93** , **97** . If this is the case, then how can we be sure
    that our improvements have actually had some impact on the algorithm? Here are
    some statistics on the number of comparisons for all four implementations for
    our initial list 20, 45, 93, 67, 10, 97, 52, 88, 33, 92:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '| **Solution** | **Comparison count** |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
- en: '| Regular bubble sort | 90 |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
- en: '| After first improvement | 63 |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
- en: '| After second improvement | 42 |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
- en: '| After third improvement | 38 |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
- en: As we can see, we have reduced the number of comparisons from **90** to **38**
    with our improvement. So, we can certainly boost up the algorithm with some improvements
    to reduce the number of comparisons required.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Understanding selection sort
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Selection sort is another comparison-based sorting algorithm, which looks similar
    to bubble sort. The biggest difference is that it takes fewer swapping than bubble
    sort. In selection sort, we first find the minimum/maximum item of the array and
    place it in the first place. If we are sorting in descending order, then we will
    take the maximum value from the array. For ascending order, we will take the minimum
    value. In the second iteration, we will find the second-most maximum or minimum
    value of the array and place it in second place. This goes on until we place each
    number into a correctly sorted position. This is known as selection sort. The
    pseudocode for selection sort looks like this:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If we look at the preceding algorithm, we can see that, after iteration one
    in the outer loop, the first minimum item is stored in position one. During the
    first iteration, we selected the first item and then found the minimum value from
    the remaining items (from 2 to *n* ). We assumed that the first item is the minimum
    value. If we find another minimum value , we would mark its position until we
    have scanned the remaining list and found a new minimum value . If no minimum
    value is found, then our assumption is correct, and that is indeed the minimum
    value. Here is a picture illustrating our **20** , **45** , **93** , **67** ,
    **10** , **97** , **52** , **88** , **33** , **92** arrays during the first two
    steps in selection sort:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00059.gif)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
- en: As we can see in the preceding image, we started with the first item in the
    list, which is **20** . Then, we found the minimum value from the rest of the
    array, which is **10** . At the end of the first iteration, we just swapped the
    values from two places (marked by arrows). As a result, at the end of the first
    iteration, we have the minimum value from the array stored in the first place.
    Then, we pointed to the next item, which is **45** , and started finding the next
    smallest items compared to **45** from the right side of its position. We found
    **20** from the remaining items (as shown by two arrows). At the end of the second
    iteration, we are just swapping the second position number to the newly found
    smallest one from the remainder of the list. This continues until the last element,
    and, at the end of the process, we have a sorted list of arrays. Let's now convert
    the pseudocode into a PHP code.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: Implementing selection sort
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will take the same approach as the bubble sort where our implementation
    will take an array as an argument and return a sorted array. Here is the implementation
    in PHP:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As can be seen, this is the simplest way to sort an array in ascending order.
    If you want to do it in descending order, we just need to change the comparison
    `$arr[$j] <` `$arr[$min]` to `$arr[$j] > $arr[$min]` and replace `$min` with `$max`
    .
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: Complexity of selection sort
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Selection sort also looks similar to bubble sort and has two `for` loops with
    0 to *n* . The basic difference between bubble sort and selection sort is that,
    selection sort makes maximum *n-1* number of swapping, whereas bubble sort can
    have *n*n* number of swapping, in the worst case scenario. However, in the selection
    sort, the best case, worst case, and average case have similar complexity. Here
    is the complexity chart for selection sort:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '| Best time complexity | `Ω(n² )` |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
- en: '| Worst time complexity | `O(n² )` |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
- en: '| Average time complexity | `Θ(n² )` |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
- en: '| Space complexity (worst case) | `O(1)` |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
- en: Understanding insertion Sort
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have seen two comparison-based sorting algorithms. Now, we will explore
    another sorting algorithm that is somewhat efficient compared to the previous
    two. We are talking about the insertion sort. It has the simplest implementation
    compared to the other two sorting algorithms we have just seen. If the number
    of items is smaller, insertion sort works better than bubble sort and selection
    sort. If the data set is large, then it becomes inefficient, like bubble sort.
    Since the swapping is almost linear for insertion sort, it is recommended that
    you use insertion sort instead of bubble sort and selection sort.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: 'As the name suggests, insertion sort works on the principle of inserting the
    number to its correct place on the left-hand side. It starts from the second item
    of the array and checks whether the items that are left to it are smaller than
    the current value or not. If so, it shifts the item and stores the smaller item
    in its correct position. Then, it moves to the next item, and the same principle
    continues until the full array is sorted. The pseudocode for insertion sort looks
    like this:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If we consider our previous list of numbers used for bubble sort and selection
    sort, then we will have the following scenario for which we must do insertion
    sort.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: 'The elements of our array were: **20** , **45** , **93** , **67** , **10**
    , **97** , **52** , **88** , **33** , **92** .'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the second item, which is **45** . Now, we will start from
    the first item to the left of **45** and go to the beginning of the array to see
    whether there is a value greater than **45** on the left. As there is only **20**
    , no insertion is required as the item so far is sorted until the second element
    (**20** ,**45** ). Now, we will move our pointer to **93,** and it starts again,
    comparing left of the array starting from **45** and search if the value is bigger.
    Since **45** is not bigger than **93** , it stops there, as previously, we concluded
    that the first two items are already sorted. Now, we have the first three items
    (**20** , **45** , **93** ) sorted. Next, we have **67** , and we start again
    by comparing from the left of the numbers. The first number to the left is **93**
    , which is bigger, so it has to move one place. We move **93** to the position
    that was held by **67** . Then, we move to the next item to the left of it, which
    is **45** . **45** is smaller than **67** , and no further comparison is required.
    Now, we will insert **67** at the position that was held by **93** and **93**
    will have to be moved to **67** ''s position. This continues until the full array
    is sorted. This image illustrates the full sorting process using insertion sort
    at each step:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00060.gif)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
- en: Implementing insertion sort
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will implement the insertion sort in a similar way to the other two sorts
    but with a subtle difference. This time, we will pass the array as a reference.
    By doing so, we will not require any return value from the function. We can also
    pass the argument by value and return the array at the end of the function if
    we want. Here is the code for this:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The parameter array is passed to the function by reference (`&$arr` ). Thus,
    the original array, not a copy of it, will be modified directly. Now, we want
    to run the code and check the output. For this, we have to run the following code:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This will produce the same output we had in the previous two cases. The only
    difference is that we are not expecting any return array from the function and
    not storing it into any new variable.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: If we pass the array by reference, then we do not have to return the array.
    The passed array will be modified inside the function. It is down to choice how
    we want to achieve the sorting.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: Complexity of insertion sort
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Insertion sort has a complexity similar to bubble sort. The basic difference
    with bubble sort is that the number of swapping is much lower than bubble sort.
    Here is the complexity for insertion sort:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '| Best time complexity | `Ω(n)` |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
- en: '| Worst time complexity | `O(n² )` |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
- en: '| Average time complexity | `Θ(n² )` |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
- en: '| Space complexity (worst case) | `O(1)` |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
- en: Understanding divide-and-conquer technique for sorting
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have explored the sorting option with a full list of numbers. As
    a result, we had a big list of numbers to compare every time. This can be solved
    if we can somehow make the list smaller. The divide-and-conquer method can be
    very helpful for us. With this method, we will divide a problem into two or more
    subproblems or sets, and then solve the smaller problems before combining all
    those results from the subproblems to get the final result. This is what is known
    as divide-and-conquer.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: The divide-and-conquer method can allow us to solve our sorting problems efficiently
    and reduce the complexity of our algorithm. Two of the most popular sorting algorithms
    are merge sort and quick sort, which apply the divide-and-conquer algorithm to
    sort a list of items, and hence, they are considered to be the best sorting algorithms.
    Now, we will explore these two algorithms in the next section.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: Understanding merge sort
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we already know that merge sort applies the divide-and-conquer approach
    to solve the sorting problem, we need to find out two processes to address the
    issue. The first one is to divide the problem set into smaller enough problems
    to solve easily, and then combine those results. We will apply a recursive approach
    here for the divide-and-conquer part. The following image shows how to take the
    approach for divide-and-conquer. We will now consider a smaller list of numbers
    **20** , **45** , **93** , **67** , **97** , **52** , **88** , **33** to explain
    the divide-and-conquer part:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00061.gif)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
- en: Based on the preceding image, we can now start preparing our pseudocode, which
    will have two parts - divide and conquer. Here is the pseudocode to achieve that
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '`func` mergesort ( A : array of sortable items):'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Our first part of the pseudocode shows the divide process. We divided the array
    of items until it reaches the size of 1\. Then, we started to merge the results
    using the merge function. In the merge function, we had an array to store the
    merged results. Because of this, merge sort actually has more space complexity
    than the other algorithms we have seen so far. Now, let's get into coding and
    implement this pseudocode using PHP.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: Implementing merge sort
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will first write the divide part followed by the merge or conquer part.
    PHP has some built-in functions to split an array. We will use the `array_slice`
    function to do the splitting. Here is the code to do this:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'As we can see from the code, we split the array in a recursive way until the
    array size becomes 1\. When array size is 1, we start to merge backward, just
    like the last image. Here is the code for the merge function, which will take
    two arrays, and merge them into one as per our pseudocode:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The code is now complete as we have merged the two supplied arrays and returned
    the combined results to the `mergeSort` function. We have just solved the problem
    recursively. If you run the following code, you will have a list of items in ascending
    order:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now, let's explore the complexity for merge sort.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Complexity of merge sort
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since merge sort follows the divide-and-conquer method, we have to address
    both complexities here. For an n-sized array, we first need to divide the array
    into two halves and then merge them to get an n-sized array. This can be written
    in terms of `T(n)` as:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'So, the complexity for merge sort is `O(n log(n))` . Here is the complexity
    chart for merge sort:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '| Best time complexity | `Ω(nlog(n))` |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
- en: '| Worst time complexity | `O(nlog(n))` |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
- en: '| Average time complexity | `Θ(nlog(n))` |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
- en: '| Space complexity (worst case) | `O(n)` |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
- en: Understanding quick sort
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Quick sort is another efficient sorting algorithm that applies the divide-and-conquer
    method. Although it does not divide into equal halves like merge sort, it creates
    dynamic partitions to sort the data. This is how quick sort works:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Pick a random value from the array, which we will call pivot.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Reorder the array so that the item that is smaller than the pivot goes to the
    left of it, and the items that are greater than, or equal to, the pivot go to
    the right of it. This is known as partitioning.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Recursively call *steps 1* and *2* to solve the two subarrays (left and right
    of pivot) until all items are sorted.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'There are many ways to picking a pivot from the array. We can either choose
    the left-most item of the array or the right-most item of the array. In both cases,
    if the array is already sorted, it will take worst case complexity. Choosing a
    good pivot can improve the efficiency of the algorithm. There are some different
    ways of doing a partition. We will explain the *Hoare Partition* , which makes
    comparatively fewer swaps than other partition methods. Here is our pseudo algorithm
    for the quick sort. We will do in-place sorting so that no extra space is required:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We used the first item as the pivot element. We can also choose the last item
    or take a median for choosing the pivot element. Let's now implement the algorithm
    using PHP.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: Implementing quick sort
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As shown in the pseudocode, we will have two functions to implement a quick
    sort: one function to do the quick sort itself, and the other for the partitioning.
    Here is the implementation to do the quick sort:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Here is the implementation to do the partitioning:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If we visually illustrate the pivot and the sorting in the partitions, we can
    see the following image. For simplicity, we are only showing the steps where swapping
    took place:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00062.gif)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
- en: Complexity of quick sort
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The worst case complexity of quick sort can be similar to bubble sort''s complexity.
    The selection of the pivot actually causes this. Here is the complexity chart
    for a quick sort:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '| Best time complexity | `Ω(nlog(n))` |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
- en: '| Worst time complexity | `O(n² )` |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
- en: '| Average time complexity | `Θ(nlog(n))` |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
- en: '| Space complexity (worst case) | `O(log(n))` |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
- en: Understanding bucket sort
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The bucket sort is also known as bin sort. Bucket sort is a distribution sorting
    system where array elements are placed in different buckets. Each bucket is then
    sorted individually by either another sorting algorithm, or by applying recursive
    bucket sorting. An implementation of bucket sort using PHP can look like this:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The time complexity of bucket sort is comparatively better than other comparison-based
    sorting algorithms. Here are the complexities for bucket sort:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '| Best time complexity | `Ω(n+k)` |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
- en: '| Worst time complexity | `O(n² )` |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
- en: '| Average time complexity | `Θ(n+k)` |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
- en: '| Space complexity (worst case) | `O(n)` |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
- en: Using PHP's built-in sorting function
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'PHP has a rich library of predefined functions, and that also includes different
    sorting functions. It has different functions to sort a list of items in an array
    either by value or by key/index. We can also keep the association of the array''s
    values with their respective keys while doing the sorting. Another important function
    of PHP is the built-in function for sorting a multi-dimensional array. Here is
    a summary of these functions:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '| **Function name** | **Purpose** |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
- en: '| `sort()` | This sorts an array in ascending order. Value/key association
    is not preserved. |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
- en: '| `rsort()` | Sort an array in reverse/descending order. Index/key association
    is not preserved. |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
- en: '| `asort()` | Sort an array while maintaining index association. |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
- en: '| `arsort()` | Sort an array in reverse order and maintain index association.
    |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
- en: '| `ksort()` | Sort an array by key. It maintains key to data correlations.
    This is useful mainly for associative arrays. |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
- en: '| `krsort()` | Sort an array by key in reverse order. |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
- en: '| `natsort()` | Sort an array using a natural order algorithm, and Value/key
    association is maintained. |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
- en: '| `natcasesort()` | Sort an array using a case insensitive "natural order"
    algorithm, and Value/key association is maintained. |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
- en: '| `usort()` | Sort an array by values using a user-defined comparison function,
    and Value/Key association is not maintained.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: The second parameter is a callable function for comparison. |
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '| `uksort()` | Sort an array by keys using a user-defined comparison function,
    and Value/key association is maintained.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: The second parameter is a callable function for comparison. |
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '| `uasort()` | Sort an array by values using a user-defined comparison function,
    and Value/key association is maintained.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: The second parameter is a callable function for comparison. |
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: 'For `sort` , `rsort` , `ksort` , `krsort` , `asort` , and `arsort` , the following
    sorting flags are available:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '**SORT_REGULAR** : compare items as they are (don''t change types)'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SORT_NUMERIC** : compare items numerically'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SORT_STRING** : compare items as strings'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SORT_LOCALE_STRING** : compare items as strings, based on the current locale'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SORT_NATURAL** : compare items as strings using "natural ordering"'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about different sorting algorithms. Sorting is
    an integral part of our development process, and knowledge of different sorting
    algorithms and their complexity will help us decide the best choice for sorting
    algorithms based on our problem set. There are other algorithms for sorting, which
    can be found online for further study. We intentionally did not cover the heapsort
    in this chapter as we will discuss that in *Chapter 10* . In the next chapter,
    we will discuss another important topic concerning algorithms - searching.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您了解了不同的排序算法。排序是我们开发过程中的一个重要部分，了解不同的排序算法及其复杂性将帮助我们根据问题集选择最佳的排序算法。还有其他排序算法，可以在网上找到进行进一步研究。我们故意没有在本章中涵盖堆排序，因为我们将在*第10章*中讨论。在下一章中，我们将讨论另一个关于算法的重要主题
    - 搜索。
