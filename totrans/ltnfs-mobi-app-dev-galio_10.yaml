- en: '*Chapter 10*: Building an Onboarding Screen'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've been through so much that we can say it's finally time to start building
    more than just components. We'll begin by creating a really important part of
    any application and that's the onboarding screen.
  prefs: []
  type: TYPE_NORMAL
- en: We'll go over what exactly an onboarding screen is and its purpose in an app.
    We'll understand that there are many types of onboarding screens, but we'll focus
    on creating just one of those types.
  prefs: []
  type: TYPE_NORMAL
- en: By learning how to create this type of screen, we'll learn lots of cool new
    concepts we haven't been exposed to until now. These new concepts will be helpful
    for you in the future for building lots of different types of screens. By learning
    a lot of new things, we can surpass our creative limitations and be more prepared
    for future challenges.
  prefs: []
  type: TYPE_NORMAL
- en: We'll learn about animation and how to create a cool animation for our screens.
    This will open the door to creating a smoother user experience for our customers.
    We'll understand what interpolation and extrapolation mean and how we can use
    them to build animations.
  prefs: []
  type: TYPE_NORMAL
- en: We'll also go more in-depth regarding Hooks and how to use `useRef`. And yes,
    we will also learn about a new surprise Hook that is going to help us find the
    size of our screens even faster than before.
  prefs: []
  type: TYPE_NORMAL
- en: Last but not least, we'll learn how to use a cool component that's more performant
    than any tool we've used until now. This cool component is called `FlatList` and
    it's going to help us create a cool onboarding experience for us and our users.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, we'll have a great onboarding screen that we'll
    use as the main opening screen for the next chapter's app project.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What's an onboarding screen and where can we use it?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a new project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Paginator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding the automatic scrolling functionality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can check out this chapter's code by going to GitHub at [https://github.com/PacktPublishing/Lightning-Fast-Mobile-App-Development-with-Galio](https://github.com/PacktPublishing/Lightning-Fast-Mobile-App-Development-with-Galio).
    You'll find a folder called `Chapter 10` that contains all the code we've written
    in this chapter. To use that project, please follow the instructions in the `README.md`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: What's an onboarding screen and where can we use it?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We should start this chapter by understanding what exactly an onboarding screen
    is. An onboarding screen is like a short introduction to your app before it's
    used. It's the first screen that welcomes the user.
  prefs: []
  type: TYPE_NORMAL
- en: The onboarding of your app should have a specific goal when it comes to welcoming
    users. You'll have to make sure that your onboarding will help users understand
    how they're supposed to be using the app, while also exciting them about the features
    they'll be able to use.
  prefs: []
  type: TYPE_NORMAL
- en: If you've made sure that the onboarding screen is going to be a great experience
    for your users, then you can expect more engagement from them in the first few
    days of them using the app. High engagement means happy users, which means your
    app is creating a really good user experience.
  prefs: []
  type: TYPE_NORMAL
- en: The onboarding screen should only appear to first-time users. We all know how
    annoying it would be to redo a tutorial in a game. Even though it should only
    take about 30 seconds to 1 minute to go through it, this could still make a returning
    user annoyed with the experience.
  prefs: []
  type: TYPE_NORMAL
- en: 'I''d recommend reading more about onboardings by going to Google''s Material
    website, where they recommend different design ideas and guidelines for creating
    a good onboarding screen for Android phones: [https://material.io/design/communication/onboarding.html](https://material.io/design/communication/onboarding.html).
    Of course, most of the same rules apply to iOS as well.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've figured out what an onboarding screen is, as well as where and
    when to use one, it's time for us to figure out what exactly this onboarding screen
    would look like for our app. Also, this is a good time for us to talk about what
    type of app this will be.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter is going to focus solely on the logic part of our app, while
    this chapter will focus on creating the onboarding we need for our app. The app
    in question will be a stopwatch/timer app. Knowing this, I decided to have an
    onboarding experience where the user learns about the utility of the app.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at what our onboarding screen for this app will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.1 – The onboarding screen we''re going to create'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/Figure_10.01_B17074_new.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.1 – The onboarding screen we're going to create
  prefs: []
  type: TYPE_NORMAL
- en: This looks pretty cool, right? It will be formed of four different screens,
    each of which will have a different image, title, and description. We'll have
    the ability to swipe left/right to advance and read all the screens while also
    pressing the **Next** button, which is going to swipe for us. The small four dots
    behind the text are going to be animated to show us which screen we are on.
  prefs: []
  type: TYPE_NORMAL
- en: I honestly love the way it looks, and I can't wait to finish this onboarding
    screen so that we can start creating the full app. By the end of this chapter,
    you'll be ready to start creating onboarding screens.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's start working on our screen.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we know what our project will look like and why we need this screen,
    it's time to start working on it.
  prefs: []
  type: TYPE_NORMAL
- en: Before coding, let's gather the images that we're going to use for this project.
    I've used the images from [https://undraw.co](https://undraw.co), which provides
    open source `.svg` and `.png` images. I've downloaded four different `.png` images
    and placed them in the `assets/onboarding` folder. The `onboarding` folder is
    a new folder I've created in the `assets` folder specifically for this screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by opening the terminal window and moving to the directory that
    you usually use for your projects. Now, let''s write our usual command and get
    right into it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have a new project, let''s install Galio. We can do this by using
    the following terminal command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now that we've set everything up, let's open our project and start coding.
  prefs: []
  type: TYPE_NORMAL
- en: First, we'll begin by doing the same old trick we've always done, and that is
    going into our `App.js` file and deleting everything inside `View` in our `App()`
    function. I've left out the `<StatusBar />` component just for the sake of it
    as you may wish to style or hide it.
  prefs: []
  type: TYPE_NORMAL
- en: Now, in our main folder, let's create a folder called `components`. This is
    where we'll place every component we're going to create for this beautiful app.
    By the end of this chapter, you'll have three files in this folder.
  prefs: []
  type: TYPE_NORMAL
- en: Now that our folder has been created, create a new file inside it called `Onboarding.js`.
    This will serve as our main screen. Now, let's quickly create and export this
    component so that we can import it into our main `App.js` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve already done this a lot of times but this time we''ll be using `SafeAreaView`
    instead of a `Block` or `View` component as the parent component for our screen.
    We''re using this one because we want to make sure everything is taken care of
    in case the users of our app have a phone with a notch:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.2 – Onboarding component ready to be imported'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/Figure_10.02_B17074.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.2 – Onboarding component ready to be imported
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''ve finished coding this function, let''s go ahead and import it
    into `App.js`. Once imported, we can use it inside our main function. Now, the
    main function should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.3 – The main App function with Onboarding imported'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/Figure_10.03_B17074.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.3 – The main App function with Onboarding imported
  prefs: []
  type: TYPE_NORMAL
- en: Now, we're ready to continue developing our app. Because we've imported the
    `Onboarding` component inside our `App` function, we can see whatever we're going
    to modify and add our `Onboarding` component every time we save the file.
  prefs: []
  type: TYPE_NORMAL
- en: Let's get back to `Onboarding.js` and think of how we should start working on
    our onboarding screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'By looking at *Figure 10.1*, we know that there are three main identifiable
    parts to this screen. Remember when we discussed that we need to always look at
    screens in terms of bigger containers to understand how to create the layout before
    we start coding? Well, this is the same thing, so let''s split our screen into
    those three main parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**OnboardingItem**: This area is the upper part of the screen, before the four
    dots. It''s going to include a picture, a title, and a description. This area
    needs to be set as one big area because it''s going to change with every swipe.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pagination**: The four small dots display where we''re situated in this big
    slider. This way, we always know how much more there is to read until we get to
    the last slide.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Next button**: This button is going to move the slides without the need to
    swipe, while also being the last thing we need to press to move on from the onboarding
    screen to the home screen.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Knowing that there are three parts should make things easier to sketch. First
    of all, we should start with the main area, which is also the biggest one. Let's
    go to our `components` folder and create a new file called `OnboardingItem.js`.
  prefs: []
  type: TYPE_NORMAL
- en: OnboardingItem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we mentioned previously, this component should render the top of our screen,
    which contains a picture, some text, and a description. Let's do just that. Go
    ahead and import the `Block` and `Text` components from `'galio-framework'` and
    `Image` and `StyleSheet` from `'react-native'`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we''ve imported everything we need, it''s time to start building our component.
    We''ll begin by having a main `<Block />` component, which will be hosted inside
    our `<Image />`, and another `<Block />` component. The second `<Block />` component
    will have two `<Text />` components as children – one for the title and one for
    the description. This second `<Block />` component will be used to split the screen
    into the main area, which is going to take up some more space because it''s going
    to be an image, and the secondary area, which should be smaller because it only
    contains text:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.4 – The OnboardingItem component'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/Figure_10.04_B17074.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.4 – The OnboardingItem component
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, there's a small surprise here. First of all, I've imported `useWindowDimensions`.
    This is a `hook` function that returns the width or height of the screen. This
    is an easy way to make sure that the width of your components is equal to the
    width of your screen.
  prefs: []
  type: TYPE_NORMAL
- en: I've also imported a prop called `item`. Because this is an onboarding screen,
    we'll have at least four screens with a different type of text or image. We'll
    pass an object, along with all the necessary information, through this prop called
    `item`. This way, we can make sure everything will go to the exact spot we want
    it to go, as well as that we won't have to keep wasting time writing props for
    every single part of our component.
  prefs: []
  type: TYPE_NORMAL
- en: 'All the styles have been applied already, but we haven''t discussed them much
    yet. So, let''s look at these styles for a second:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.5 – Styles for our OnboardingItem component'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/Figure_10.05_B17074.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.5 – Styles for our OnboardingItem component
  prefs: []
  type: TYPE_NORMAL
- en: 'As we can see, the container has a property of `flex: 1`, which tells our main
    `<Block />` component to take up as much space as it can. We gave our `image`
    a `flex: 0.7` property because we want it to occupy 70% of the space, while `title`
    and `description` only need to occupy 30% of the space. The other styles are just
    the usual text styles where we set `fontSize` and `fontWeight`.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip of the Day
  prefs: []
  type: TYPE_NORMAL
- en: I cannot stress enough the importance of looking at the pictures to understand
    the code. I believe you should look at the picture first, try to make all the
    connections inside your brain, and then see if you got *lucky*. I wouldn't call
    it luck, though; I'd call it more of an educated guess.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that our `OnboardingItem` component has been created, we''re ready to import
    it into our `Onboarding.js` file, which is where our main screen resides. We all
    know how to import a component but just to make sure, the line we must write for
    this looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Now that we've done this, we can start using `FlatList` to render all our items
    on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: FlatList
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we mentioned earlier, we don't want to repeat ourselves, so we won't write
    the same code four times inside our main onboarding component. The first thing
    that may come to your mind is to use the `.map()` function. This is a good guess,
    but React Native has a component that is usually used because of its better performance.
    It also has some props built into it that are lifesavers in situations like this.
    This component is called `FlatList`.
  prefs: []
  type: TYPE_NORMAL
- en: To use this component, we need to prove it with an array of elements that must
    be mapped to the component we've been creating. Earlier, I mentioned that our
    `OnboardingItem` component will accept a prop called `item`. This prop is going
    to be an object inside this array.
  prefs: []
  type: TYPE_NORMAL
- en: If we look at *Figure 10.4*, we can figure out what our object should look like
    from the way we've used it inside our component. We know that it needs to have
    a `title`, `description`, and `image`, but it also needs an `id`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a new file called `slides.js` in our root (main) folder. This
    is where the array containing all the objects that provide the information our
    onboarding needs will reside, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.6 – The array with all the information needed by the FlatList component'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/Figure_10.06_B17074.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.6 – The array with all the information needed by the FlatList component
  prefs: []
  type: TYPE_NORMAL
- en: Don't forget that you can have any type of information you'd like. The titles,
    descriptions, or images don't have to be identical to mine. Remember that when
    we started creating our app, I told you to download some images and place them
    inside the `./assets/onboarding` folder. These are the images I've chosen, and
    I imported them using the `require` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: The `require` keyword is used just like `import` in that it tells the JavaScript
    engine that it needs the file to be located at the specified destination.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have the array with data for `FlatList` ready it''s time to go
    back to our `Onboarding.js` file and import this new file just like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s make sure we have the rest of the imports ready for when we need
    them as we need some more components. First of all, we''ll remove the `Text` import
    and we''ll import the `Block` and `Button` components from `''galio-framework''`.
    Secondly, we''ll add `FlatList` to the list of imported components:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.7 – New imports added to the Onboarding.js file'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/Figure_10.07_B17074.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.7 – New imports added to the Onboarding.js file
  prefs: []
  type: TYPE_NORMAL
- en: Now that everything has been imported, we're ready to start developing the screen.
    We'll delete our `<Text />` component from within the `<SafeAreaView />` component
    and use a `<Block />` component with the `flex={3}` prop instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside of this `<Block />` component, our `<FlatList />` component will start
    its own life. Let''s take a look at how I''ve implemented this component before
    explaining how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.8 – FlatList implemented in our onboarding screen'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/Figure_10.08_B17074.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.8 – FlatList implemented in our onboarding screen
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, implementing this seems pretty straightforward. By the way,
    if you were to copy this code into your editor right now (assuming you've been
    following along with everything else as well) and try to check out your app on
    the simulator, you would see a fully working onboarding screen. Yes, it doesn't
    look as good as what we showcased at the beginning of this chapter, but it's working
    – we can slide left and right and check all the information we've been writing
    in our `slides.js` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s look at how this component works:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we'll begin with the `data` prop. This is where we're offering our `FlatList`
    component the array it needs to start rendering each element.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we have the `renderItem` prop, which is where we use a function to render
    the item we need. In this case, we need multiple instances of `<OnboardingItem
    />`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remember when I said we're going to pass this component the prop called `item`?
    This is because we only need to pass an object from the array. Our `FlatList`
    component will pass each object to a different `<OnboardingItem />` component.
    Once we've done this, we can capture that object and use it in any way we see
    fit.
  prefs: []
  type: TYPE_NORMAL
- en: The `keyExtractor` prop is used to extract a unique key for a specific item
    at the respective index.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: These keys are used for caching so that React can keep track of each item individually
    and only rerender the one that must be rerendered. Do you remember how we were
    using the `key` prop when we were rendering items with the `.map()` function?
    This is the same but all the work is done by this prop. This is why we needed
    an `id` key inside our objects for the `slides` array.
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the props are used mainly for layout purposes. I'd strongly encourage
    you just play around with those props by turning them on and off. For example,
    the `horizontal` prop makes our list, well, horizontal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we've successfully built our list of elements, which is the first step
    of creating a great onboarding experience, let's start building the paginator.
  prefs: []
  type: TYPE_NORMAL
- en: Paginator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The paginator is displayed on the screen by those four small dots. Its main
    purpose is to show the user which slide they're currently looking at while also
    displaying a sense of progress. This small component is not that hard to implement,
    but the features we're going to use to make sure this thing is working correctly
    are new to us.
  prefs: []
  type: TYPE_NORMAL
- en: One of the most important objects we're going to work with for this component
    is the `Animated` object. This is needed because we're looking at animating the
    width and the opacity of our dots. This is also important because we want to make
    sure that the animation happens at the right moment. The right moment is, of course,
    while the user interacts with `FlatList`. If your finger moves from right to left,
    we want the animation to also move at the same pace as your finger.
  prefs: []
  type: TYPE_NORMAL
- en: We're also going to use a cool new Hook called `useRef`. This Hook is used when
    we need a mutable object that persists for the entire lifetime of your component.
    `useRef` will not cause your component to rerender when its value is changed because
    it's not a state variable, but it's a really good way to make sure that you'll
    get the same `ref` object on every render.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s get started on this cool little component, which I''m sure you''re
    going to find helpful and reusable for future applications. We''ll start in `Onboarding.js`.
    Let''s begin by importing `useState` and `useRef` from `''react''`. We''ll also
    import `Animated` from `''react-native''`. After importing all of this, we''re
    ready to move on:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.9 – Fresh new imports for our Onboarding component'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/Figure_10.09_B17074.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.9 – Fresh new imports for our Onboarding component
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s start implementing everything we need for our `Paginator` component.
    We''ll begin by creating two new ref objects that we''re going to implement in
    our `FlatList` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.10 – Our newly created refs'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/Figure_10.10_B17074.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.10 – Our newly created refs
  prefs: []
  type: TYPE_NORMAL
- en: Let's explain how this works. First of all, we'll begin with `scrollX`. This
    variable has a lot going on, so let's start from the beginning. We're creating
    a new ref object using the `useRef` Hook and we're initializing this new variable
    with `Animated.Value(0)`.
  prefs: []
  type: TYPE_NORMAL
- en: '`Animated.Value` creates a value that can be animated. If we were to initialize
    this variable with just a number, such as `0`, React Native wouldn''t know how
    to handle it when it comes to animations.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `useRef` Hook returns an object that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: To access the value stored in `current`, we must write `scrollX.current`. A
    workaround for this is to let JavaScript know we want to access that value by
    chaining `.current` to our `useRef` Hook.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `viewConfig` variable works just as you''d expect it to work. Here, we
    must create a new ref object and initialize it with the object shown in *Figure
    10.10*, `{ viewAreaCoveragePercentThreshold: 50 }`. Now, let''s use these two
    new variables with our `FlatList` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.11 – Implementing our new variables inside FlatList'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/Figure_10.11_B17074.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.11 – Implementing our new variables inside FlatList
  prefs: []
  type: TYPE_NORMAL
- en: Things might look a bit complicated right now, but it's a lot easier than it
    looks. With that, we've added two new props to our `<FlatList />` component called
    `onScroll` and `viewabilityConfig`.
  prefs: []
  type: TYPE_NORMAL
- en: The `viewabilityConfig` prop is here to support our `pagingEnabled` prop, which
    is telling our list of components to move to the next or previous slide based
    on how far the user has swiped. By setting the `viewAreaCoveragePercentThreshold`
    value of `viewabilityConfig` to 50, we're telling our component to only go to
    the next slide if the user has already swiped more than or equal to 50% of our
    current slide.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `onScroll` prop is firing a function every time the user scrolls through
    the slides of our onboarding screen. You might be wondering what `Animated.event`:
    does? It maps an animated value to an event value. I agree, the function looks
    pretty chaotic, but it''s pretty easy to understand if we learn how to read it.
    So, we''re mapping our `scrollX` value to the `nativeEvent.contentOffset.x` event
    value. This event value is usually passed to the `onScroll` callback, so remember
    that you might see or use this more often than you think.'
  prefs: []
  type: TYPE_NORMAL
- en: The `Animated.event` function accepts two arguments. The first argument is the
    array of values that we're going to want to map to our **Animated** values. This
    `event()` function does this by calling the `setValue()` function on the mapped
    outputs; in this case, on `scrollX`. The second argument is a `configuration`
    object, which we're using to tell React Native that we don't want to use the native
    drivers for our animation.
  prefs: []
  type: TYPE_NORMAL
- en: You might assume that by using the native drivers, we might have better performance
    and this is correct. The reason why we don't want to use the native drivers in
    this specific use case is because we're going to animate the width of our dots
    and right now, React Native can't use the native driver to animate width or layout
    properties in general.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know why we need `scrollX` and `viewConfig`, we should start building
    our new component. Create a new file inside the `components/` folder called `Paginator.js`.
    Now that we've created a new file, we should start building our functional component.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start by importing everything necessary from `''react-native''`; that
    is, `StyleSheet`, `View`, `Animated`, and `useWindowDimensions`. The next step
    is building our function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.12 – Paginator component almost completed'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/Figure_10.12_B17074.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.12 – Paginator component almost completed
  prefs: []
  type: TYPE_NORMAL
- en: There's a bunch of new stuff here, so let's start explaining everything from
    top to bottom.
  prefs: []
  type: TYPE_NORMAL
- en: This component, which we've called `Paginator`, accepts two props called `data`
    and `scrollX`. `data` is the array of objects we passed to `FlatList`, while `scrollX`
    is the `Animated` value we defined in our `Onboarding.js` file (our parent component).
  prefs: []
  type: TYPE_NORMAL
- en: We've already discussed that the `useWindowDimensions()` Hook returns the `width`
    and `height` properties of our screen, so that should be easy to understand.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve given the styles of `flexDirection: ''row''` and a `height` of `64px`
    to our `<View />` component, which contains the *soul* of our component. We''ve
    done this to make sure the dots we''ll be creating are going to be sitting nicely
    in a row.'
  prefs: []
  type: TYPE_NORMAL
- en: After that, we used the `.map()` function to map over the array. As you can
    see, the `map()` function accepts a callback function that takes in two arguments.
    The first one, `_`, will be our element, while the second one, `i`, is going to
    give us the index of that element.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, for each element in our array, we''re creating a dot. How do we do that?
    Let''s jump straight to our `return` statement to find out. Here, we''re returning
    a `<View />` component with `styles.dot` applied to it. The reason why we''re
    calling it `<Animated.View />` is because we want to animate this component. But
    before we start to animate it, this could just be a normal `<View />` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.13 – Styles for our dots'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/Figure_10.13_B17074.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.13 – Styles for our dots
  prefs: []
  type: TYPE_NORMAL
- en: These are the styles we were using to create the dots. As you can see, there
    is no `width`, which is because we want to animate the width of the dot. However,
    if we were to never animate it, we could've just gone right ahead and given it
    a `width` of `10px`.
  prefs: []
  type: TYPE_NORMAL
- en: So, let's get back to how we animate the width of our dots. As you can see,
    we have a variable called `inputRange` that is an array of values based on the
    width of the screen and our dot's index. As we know, a slide occupies the full
    width of the screen. Knowing that, we can understand that a slide has changed
    when `contentOffset.x` is equal to the width of the screen. It's called `contentOffset`
    because it gives us the offset between two elements. It starts at `0` when the
    first slide is on the screen. Once that slide moves out of the screen and the
    next slide comes in, the difference between the last slide and the next one is
    equal to the width of the screen. Understanding how `contentOffset` works enables
    us to think of a way to start creating animations.
  prefs: []
  type: TYPE_NORMAL
- en: '*What exactly makes an animation?* I feel like this is a great place where
    we can define how exactly an animation works. Let''s imagine we have a box on
    the screen and whenever someone presses a button, we want that box to appear.
    Of course, it can suddenly appear on the screen, but that doesn''t look that good.
    This is where animations come in. Instead of suddenly appearing on the screen,
    what if we had a smoother transition? What if the box transitioned into existence
    over some time? That would look more like an animation, right?'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the same concept we''re applying here: we want the movement of our
    dots to be completely in sync with the movement of our slides. So, we need our
    dot''s width to grow at the same time as we move our finger on the screen because
    this creates a smoother experience for our users.'
  prefs: []
  type: TYPE_NORMAL
- en: Keeping that in mind, we've mapped the animated value of `scrollX` to our `nativeEvent.contentOffset.x`
    event value. Now, we can access the exact amount of change between two elements
    in our horizontal list via `scrollx`. Based on that amount, we need to change
    the width.
  prefs: []
  type: TYPE_NORMAL
- en: 'But there''s a *problem*: our dot''s `height` is `10px`, so if we want our
    dot to be, well, a dot, then we''d need `width` to be `10px` as well. The problem
    is that our `scrollX` will go way beyond `10px` because our screen''s width is
    bigger, so how can we let React Native know that we want our current dot to have
    a bigger width and the rest of the dots to have a width of `10px`? With **interpolation**.'
  prefs: []
  type: TYPE_NORMAL
- en: Interpolation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So, let's recap for a second. We want the dot corresponding to the slide we're
    viewing at this moment to have a bigger width (let's say, `20px`) than the ones
    that are corresponding to the slides that are out of our view. The only way we
    can do this is with interpolation.
  prefs: []
  type: TYPE_NORMAL
- en: Interpolation is the way we're estimating the output of a function based on
    the input we've provided.
  prefs: []
  type: TYPE_NORMAL
- en: Let's assume we have a function where all we know about it is that `f(0) = 0`
    and `f(10) = 20`. Can you guess what `f(5)` will be equal to?
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/B17074_Table_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Based on this table, we could suggest `10` as the answer to our question because
    `5` is between `0` and `10` and we know the answer should be between `0` and `20`.
    This intuitive approach is what interpolation does.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, now that we know how our values need to behave, we can take a look at the
    interpolation function for our dot''s width:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.14 – The interpolate function'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/Figure_10.14_B17074.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.14 – The interpolate function
  prefs: []
  type: TYPE_NORMAL
- en: So, we want this function to return a value between `10` and `20` based on the
    user's current position. Our `inputRange` variable, as we mentioned earlier, is
    defined by the index of that specific slide and the width of the screen. The first
    value in our `inputRange` variable is represented by the previous slide, the second
    value is represented by the current slide, and the third value is represented
    by the next slide. Based on that input, we've created an `outputRange` where we
    know that the previous slide's dot should have a width of `10px`, the current
    slide dot's width should be `20px`, and the next slide's dot width should be `10px`.
  prefs: []
  type: TYPE_NORMAL
- en: Guessing which value should be returned based on `inputRange` is React Native's
    job, but what we're really interested in is the value itself. Now, we can go to
    our `<Animated.View />` component and have the width of each dot equal to `dotWidth`,
    which is the value that's given to us by interpolation. Now, the width will change
    at the same time as the user swipes their finger.
  prefs: []
  type: TYPE_NORMAL
- en: Extrapolation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We also have another cool little thing here called `extrapolate`. So, we know
    our `inputRange` is only taking the previous, current, and next slide into consideration,
    but what about the fourth one? Because we haven't specified any value for the
    fourth one, React Native can start guessing what the width should be for itself.
  prefs: []
  type: TYPE_NORMAL
- en: If we run the code without a little help from extrapolation, we might see some
    weird results. I encourage you to delete the `extrapolate` line and see what happens
    for yourself.
  prefs: []
  type: TYPE_NORMAL
- en: We can solve those weird results by adding `extrapolate` to our `interpolate`
    function. This will tell React Native *what should happen outside of the ranges
    we've provided* and what kind of pattern the outside values should follow. This
    is great when we have no idea what the boundaries of our range are. In this case,
    the solution will be to **clamp** your ranges. This means that whatever comes
    before or after that range, we'll keep the last given value.
  prefs: []
  type: TYPE_NORMAL
- en: 'By using `extrapolate: ''clamp''`, you''re going to clamp the range from both
    sides, but if a specific case requires it, you can always clamp only the side
    of the range that you need. This means you could clamp to the left of the range
    or the right as well.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: The default mode for extrapolation is `extend`, which is React Native guessing
    the values of our range.
  prefs: []
  type: TYPE_NORMAL
- en: Great! Now that we've explained how to interpolate and extrapolate, we've understood
    how (and based on what) the `dotWidth` variable changes. Because this is all done
    with a `scrollX` animated value, we've placed the `dotWidth` variable inside a
    `<Animated.View />`. Now, our width changes based on our scrolling behavior.
  prefs: []
  type: TYPE_NORMAL
- en: What's left? Well, I feel like it'd be cool to see the opacity changing as well.
    The current dot should have an opacity equal to `1`, while the other dots should
    have an opacity of `0.4`. Based on this information, try to do this by yourself.
  prefs: []
  type: TYPE_NORMAL
- en: If you couldn't do it, worry not! This is a lot easier than it may seem. Let
    me show you!
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.15 – Animating the opacity of our dots'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/Figure_10.15_B17074.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.15 – Animating the opacity of our dots
  prefs: []
  type: TYPE_NORMAL
- en: Doesn't look that hard, right? We've done the same thing we've done with `dotWidth`
    but this time, we've created a new variable called `opacity`. We know that the
    opacity of an element is between `0` and `1`, so we've changed `outputRange` so
    that it fits our needs.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we introduced our opacity value inside the `style` prop of our `<Animated.View
    />` component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''re done with the `Paginator` component, we should implement it
    inside our `Onboarding.js` file. We know how to do that already: import the component
    and then place it underneath the `<Block />` component, which has a `flex` of
    `3` applied to it. Don''t forget to pass it the necessary props.'
  prefs: []
  type: TYPE_NORMAL
- en: We've learned a lot of things about how animation should work by building this
    `Paginator` component and for that, I must congratulate you! We've made some impressive
    progress in this chapter. Now, it's time to start adding some functionality to
    our screen. Let's learn how we can do that.
  prefs: []
  type: TYPE_NORMAL
- en: Automatic scrolling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To finish building this project, we''re going to have to create a button that
    moves the slides whenever we press it. We already have the `<Button />` component
    imported from `''galio-framework''`, so let''s implement it underneath our `<Paginator
    />` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.16 – The Button component added to our onboarding screen'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/Figure_10.16_B17074.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.16 – The Button component added to our onboarding screen
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, I've implemented `Button` below `<Paginator />`. I've added
    the same color our images and dots are and removed the shadow via the `shadowless`
    prop. Now that we know that our function needs to be called whenever we press
    the button, we need to create a function and then link it to our `onPress` prop.
  prefs: []
  type: TYPE_NORMAL
- en: But before we do that, we need to make sure we have anything in place for our
    button to work whenever we need it to.
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to think about how we can get to the next slide without swiping
    through our list of slides. Well, we'll need a reference to the `FlatList` component.
    Having a reference to that object allows us to control it from an external function
    whenever we want.
  prefs: []
  type: TYPE_NORMAL
- en: Secondly, we need to keep track of our slides as we need to know which slide
    we are on at all times. We can do that with a state variable that keeps track
    of the index that's currently being displayed on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's start solving these issues first before we look at what else we need
    to do to make sure this works.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a state variable using the `useState` Hook, which we''ve already
    imported:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Here is where we're going to store the index of the currently shown slide.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s create a ref variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Once we've finished creating our ref variable, we should apply it to our `<FlatList
    />` component. We can do that using `ref={slidesRef}`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we're going to use a prop that's already available to us from `FlatList`
    called `onViewableItemsChange`. Whenever you scroll through `FlatList`, the items
    on `FlatList` will change as well. When those items change, this function is called,
    telling you what current `viewableItems` are available. This prop should always
    be used with `viewabilityConfig`. The `onViewableItemsChange` function will be
    called whenever the corresponding conditions of `viewabilityConfig` are met.
  prefs: []
  type: TYPE_NORMAL
- en: 'This will help us make sure we always have the right index for our displayed
    slide. So, inside the function, we''ll have to make sure that we set the current
    index to the one being displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Looking at this might seem a little bit weird but as we discussed earlier, the
    function will return what current `viewableItems` there are.
  prefs: []
  type: TYPE_NORMAL
- en: The thing is… only one item can be displayed at a time, so the array of `viewableItems`
    is going to have a single element inside of it. Because what we're interested
    in is the index of that element, we're setting the `currentIndex` state variable
    so that it's equal to `viewableItems[0].index`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we know which slide is currently being displayed, the next step is
    to just scroll to `currentIndex + 1`. For example, if we''re viewing the first
    slide, that means our `currentIndex` should be equal to `0`. Naturally, the next
    slide is going to be `currentIndex + 1`, which means `1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.17 – The final Onboarding component'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/Figure_10.17_B17074.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.17 – The final Onboarding component
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've finished with `viewableItemsChanged` and we've used the variable
    with our `onViewableItemsChange` prop, let's explain how the `scrollTo` function
    works.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we've created a function called `scrollTo` that is called whenever
    we press our button. This function checks for `currentIndex` because we want different
    types of behaviors based on whether we're displaying the last slide or not. If
    this is the last slide, we won't do anything yet, but if it's the first three
    slides, we want it to scroll to the next one.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, scrolling to the next slide is pretty easy – all we have to
    do is use the reference we have to the `<FlatList />` component and use the `scrollToIndex`
    function. That function needs an argument where we're telling it which index exactly
    to jump to.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can hit **save**, reload our application, and there we have it – a beautiful
    onboarding screen with some cool little animations and a nice feature that scrolls
    the slides without us touching anything besides a button. It has been a long journey
    but I'm pretty sure you think it was worth it, now that we've seen what we're
    capable of.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we're going to build the rest of our app but for a nice
    experience, we're going to use this onboarding screen for our app. This will ensure
    that at the end of the slides, our button will jump us straight to the app.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter was one of the hardest challenges we've overcome so far. We've
    been through so many new concepts but in the end, we can happily say that we've
    successfully managed to create a great onboarding experience for our users. Even
    better, we've created a nice onboarding experience that we'll enjoy whenever we
    brag about our app.
  prefs: []
  type: TYPE_NORMAL
- en: We started by discovering how this app will look and then went through all the
    necessary steps to produce that app. We saw what it takes to create a nice list
    of elements, which brought us to `FlatList`. We used this component at the core
    of our onboarding screen, and you'll surely keep using it in the future whenever
    you encounter big lists of elements.
  prefs: []
  type: TYPE_NORMAL
- en: We also learned how to create animations and how exactly interpolation works.
    By doing this, we managed to create a cool little paginator that displays the
    current slide our users are seeing.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we even discovered that we can make things work without swiping left
    or right, just by pressing a button. For this, we used a reference object that
    is called from another function whenever we pressed that button.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter might have been a lot, but I feel like you were ready for it. I
    hope you're prepared for the next chapter as well because we're going to finish
    this mobile app!
  prefs: []
  type: TYPE_NORMAL
