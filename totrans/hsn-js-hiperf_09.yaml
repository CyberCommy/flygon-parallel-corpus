- en: Practical Example - Building a Static Server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have looked at Node.js and what it has to offer in the past few chapters.
    While we have not gone over every module or everything that Node.js has to offer,
    we have all the pieces to put together a static content/generator site. This means
    that we will set up a server to listen for requests and build pages off of that
    request.
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement this server, we will need to understand how site generation works,
    and how we might implement this as an on-the-fly operation. On top of this, we
    will look at caching so that we do not have to recompile every single time a page
    is requested. Overall, in this chapter, we will look at and implement the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding static content
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up our server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding caching and clustering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A text editor or **integrated development environment** (**IDE**), preferably
    VS Code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An operating system that supports Node.js
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The code for this chapter can be found at the following URL: [https://github.com/PacktPublishing/Hands-On-High-Performance-Web-Development-with-JavaScript/tree/master/Chapter09/microserve](https://github.com/PacktPublishing/Hands-On-High-Performance-Web-Development-with-JavaScript/tree/master/Chapter09/microserve).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding static content
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Static content means exactly that: content that does not change. This can be
    HTML pages, JavaScript, images, and so on. Anything that does not need to run
    through a database or some external system for processing can be considered as
    static content.'
  prefs: []
  type: TYPE_NORMAL
- en: While we will not be implementing a static content server directly, we will
    be implementing an on-the-fly static content generator. For those that do not
    know, a static content generator is a system that builds the static content and
    then serves that content up. The content is usually built by some type of templating
    system.
  prefs: []
  type: TYPE_NORMAL
- en: Some common templating systems that are out there include Mustache, Handlebars.js,
    and Jade. These template engines look for some sort of tags and replace the content
    based on some variables. While we will not be looking at any of these templating
    engines directly, know that they are out there and that they can be quite useful
    for things such as code documentation generation, or even creating JavaScript
    files based off of some API specification.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of using one of these common formats, we will implement our own version
    of a templating system to see how templating works. We will try to keep it as
    simple as possible since we want to use a minimal amount of dependencies for our
    server. The one dependency that we will be utilizing is a Markdown to HTML converter
    called `Remarkable`: [https://github.com/jonschlinkert/remarkable](https://github.com/jonschlinkert/remarkable).
    It depends on two libraries and each of those depends on one library, so we will
    be importing a total of five libraries.'
  prefs: []
  type: TYPE_NORMAL
- en: While creating all of the pages on-the-fly will allow us to make changes quite
    easily, we would not want to keep doing this unless we were in a development environment.
    To make sure that we do not keep building the HTML files over and over again,
    we will implement an in-memory cache to store the files that have been requested
    the most.
  prefs: []
  type: TYPE_NORMAL
- en: With all of this, let's go ahead and get started with building out our application,
    by setting up our server and getting a response sent out.
  prefs: []
  type: TYPE_NORMAL
- en: Starting our application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, let''s go ahead and set up our project by creating our `package.json`
    file in a folder of our choosing. We can start with the following basic `package.json`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This should be fairly straightforward now. The main thing is that the type
    is set to `module` so we can utilize modules inside of Node.js. Next, let''s go
    ahead and add the `Remarkable` dependency by running `npm install remarkable`
    inside the folder in which we put our `package.json` file. With that, we should
    now have `remarkable` listed as a dependency in our `package.json` file. Next,
    let''s go ahead and get our server set up. To do so, create a `main.js` file and
    do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the `http2` and `fs` modules, since we will use them to start our server
    and read our private key and certificate files, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Create our server and read in our key and certificate files. We will generate
    these after setting up our main file, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Respond to the error event by just crashing our server (we should probably
    handle this better, but for now, this will work). We will also handle an incoming
    request by just responding with a simple message and a status of `200` (which
    means all good), like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we will start listening in on port `50000` (a random port number can
    be used here).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, if we do try to run this, we should be greeted by a nasty error message
    similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We have not generated our self-signed private key and certificate yet. Remember
    from [Chapter 6](7dc2a5fd-0c78-49e7-9e84-f789eab14ca5.xhtml), *Message Passing
    – Learning about the Different Types*, that we cannot serve any content over an
    unsecured channel (HTTP); instead, we have to utilize HTTPS. To do this, we need
    to either get a certificate from a certificate authority or we need to generate
    one ourselves. From [Chapter 6](7dc2a5fd-0c78-49e7-9e84-f789eab14ca5.xhtml), *Message
    Passing – Learning about the Different Types*, we should have the `openssl` application
    installed on our computers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go ahead and generate that by running the following command and just
    pressing *Enter* through the Command Prompts:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We should now have both of those files in our current directory, and now, if
    we try running our application, we should have a server listening on port `50000`.
    We can check this by going to the following address: `127.0.0.1:50000`. If everything
    worked correctly, we should see the message A okay!'
  prefs: []
  type: TYPE_NORMAL
- en: 'While having variables such as the port, private key, and certificate hardcoded
    is okay for development purposes, we should still move these to our `package.json`
    file so another user could make the changes to them in a single place, instead
    of having to go into the code and make the changes. Let''s go ahead and make these
    changes right now. Inside of our `package.json` file, let''s add the following
    fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The `config` section will allow us to pass in various variables that we will
    let the user of the package set, either with the `package.json` `config` section,
    or when running our file by using the `npm config set tinyserve:<variable>` command.
    The `scripts` section, as we saw from [Chapter 5](6c403493-7028-408c-9da6-b6650ad6bfcb.xhtml),
    *Switching Contexts – No DOM, Different Vanilla*, allows us access to these variables
    and allows the user of our package to now just use `npm start`, instead of using
    `node --experimental-modules main.js`. With this, we can change our `main.js`
    file by declaring all of these variables near the top of our file, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: All of the configuration variables can be found on our `process.env` variable,
    so we declare a shortcut to it at the top of our file. We can then get access
    to the various variables, as we have seen in [Chapter 5](6c403493-7028-408c-9da6-b6650ad6bfcb.xhtml),
    *Switching Contexts – No DOM, Different Vanilla*. We also set defaults, just in
    case the user does not run our file using the `npm start` script that we declared.
    Users will also notice that we have declared a few extra variables. These are
    variables that we will talk about later, but they deal with where we hyperlink
    to and whether we want to enable the caching or not (the development variable).
    Next, we will take a look at how we will access the templating system that we
    want to set up.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up our templating system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are going to use Markdown for the various content we want to host, but there
    are going to be certain sections of our files that we will want to use across
    all of the articles. These will be things such as the header, footer, and the
    sidebar of our pages. Instead of having to have these inserted into all of the
    Markdown files that we will create for our articles, we can template these in.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will put these sections in a folder that will be known at runtime, by using
    the `templateDirectory` variable that we declared. This will also allow users
    of our package to change out the look and feel of our static site server without
    having to do anything too crazy. Let''s go ahead and create the directory structure
    for the template section. This should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Template**: Where we should look for the static content across all pages'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**HTML**: Where all of our static HTML code will go'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CSS**: Where our stylesheets will live'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With this directory structure, we can now create some basic header, footer,
    and sidebar HTML files, and also some basic **Cascading Style Sheets** (**CSS**),
    to get a page structure that should be familiar to everyone. So, let''s begin,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will write the `header` HTML, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: With this basic structure, we have the name of our website, and then a couple
    of links that most blog sites will have.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s create the `footer` section, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, fairly self-explanatory. Finally, we will create the sidebar, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This is where our templating engine comes into play. First, we are going to
    use `<% %>` character pattern to denote that we want to replace this with some
    static content. Next, `loop <number>` will let our templating engine know that
    we plan on looping through the next piece of content a certain amount of times
    before stopping the engine. Finally, the `<a href="article/${location}">${name}</a>`
    pattern will tell our templating engine that this is the content we want to put
    in, but we will want to replace the `${}` tags with variables in an object that
    we pass in our code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s go ahead and create the basic CSS for our page, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Most of the CSS file has been cut since a majority of it is boilerplate code.
    The only piece that is worth mentioning is the custom variables. With CSS, we
    can declare our own custom variables by using the pattern `--<name> : <content>`,
    and then we can use it later in the CSS file by using the `var()` declaration.
    This allows us to reuse variables such as colors and heights without having to
    use a preprocessor such as **Syntactically Awesome Style Sheets** (**SASS**).'
  prefs: []
  type: TYPE_NORMAL
- en: CSS variables are scoped. This means if you define the variable for the `header`
    section, it will only be available in the `header` section. This is why we decided
    to put our colors at the `:root` pseudo element level since it will be available
    across our entire page. Just remember that CSS variables have scope similar to
    the `let` and `const` variables we declare in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'With our CSS laid out, we can now write our main HTML file in our `template`
    file. We will move this outside of the HTML folder since this is the main file
    that we will want in order to put everything together. It will also let users
    of our package know that this is the main file that we will use to put together
    all of the pieces and that if they want to change it up, they should do it here.
    For now, let''s create a `main.html` file that looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The top section should look familiar, but we now have a new template type. The
    `from` directive lets us know that we are going to source this file from somewhere
    else. The next statement says it is an `HTML` file, so we will look inside the
    `HTML` folder. Finally, we see the name of the file, so we know that we want to
    bring in the `header.html` file.
  prefs: []
  type: TYPE_NORMAL
- en: With all of this, we can now write the templating system that we are going to
    use to build our pages. We will be implementing our templating system utilizing
    a `Transform` stream. While we could utilize something like a `Writable` stream,
    it makes more sense to utilize a `Transform` stream since we are changing the
    output based on some input criteria.
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement the `Transform` stream, we will need to keep track of a few things
    so, that way, we can process our keys correctly. First, let''s get us reading
    and sending off the proper chunks to be processed. We can do this by implementing
    the `transform` method and spitting out the chunks that we are going to replace.
    To do this, we will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will extend a `Transform` stream and set up the basic structure, as we did
    in [Chapter 7](81cf1aa1-6ded-4d94-8686-e2bd65db6a8c.xhtml), *Streams – Understanding
    Streams and Non-Blocking I/O*. We will also create a custom class to hold the
    start and end locations of a buffer. This will allow us to know if we got the
    start of the pattern matcher in the same loop. We will need this later. We will
    also set up some private variables for our class, such as the `begin` and `end`
    template buffers, on top of state variables such as the `#pattern` variable, as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will have to check if we have data held in our `#pattern` state variable.
    If we do not, then we know to look for the beginning of a template. Once we do
    the check for the beginning of a template statement, we can check to see if it
    is actually in this chunk of data. If it is, we set the `start` property of `#pair`
    to this location so our loop can keep going; otherwise, we have no template in
    this chunk and we can start to process the next chunk, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'To handle the other condition (we are looking for the end of a template), we
    have quite a bit more state to deal with. First, if our `#pair` variable''s `start`
    is not `-1` (we set it), we know we are still processing a current chunk. This
    means we need to check if we can find the `end` template buffer in the current
    chunk. If we do, then we can process the pattern and reset our `#pair` variable.
    Otherwise, we just push the current chunk from the `start` member location of
    `#pair` to our `#pattern` holder at the end of the chunk, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, if `start` member of `#pair` is set, we check for the `end` template
    pattern. If we do not find it, we just push the entire chunk to the `#pattern`
    array. If we do find it, we slice the chunk from the beginning of it to where
    we found our `end` template string. We then concatenate all this together and
    process it. We will then also reset our `#pattern` variable back to holding nothing,
    like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'All of this will be wrapped in a `do`/`while` loop since we want to run this
    piece of code at least once, and we will know that we are finished when our `location`
    variable is `-1` (this is what is returned from an `indexOf` check when it does
    not find what we want). After the `do`/`while` loop, we run the callback to tell
    our stream that we are ready to process more data, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'With all of this put together, we now have a `transform` loop that should handle
    almost all of the conditions to grab our templating system. We can test this by
    passing in our `main.html` file and putting the following code inside of our `processPattern`
    method, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We can create a test script to run our `main.html` file through. Go ahead and
    create a `test.js` file and put the following code in it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'With this, we should get a nice printout with the template syntax that we were
    looking for, such as `from html header`*.* If we ran our `sidebar.html` file through
    it, it should look something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Now that we know our `Transform` stream's template-finding code works, we just
    need to write our process chunk system to handle the preceding cases we have.
  prefs: []
  type: TYPE_NORMAL
- en: 'To now process the chunks, we will need to know where to look for the files.
    Remember from before, when we declared various variables inside of our `package.json`
    file? Now, we will utilize the `templateDirectory` one. Let''s go ahead and pass
    that in as an argument for our stream, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when we call `processPattern`, we can pass in the chunk and the `template`
    directory as arguments. From here, we can now implement the `processPattern` method.
    We will handle two cases: when we find a `for` loop and when we find a `find`
    statement.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To process a `for` loop and a `find` statement, we will proceed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will build out an array of buffers that will be what the template held,
    other than the `for` loop. We can do this with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We will look for the loop directive and then take the second argument, which
    should be a number. If we print this out, we will see that we have buffers that
    are all filled with the same exact data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we will need to make sure that we are filling in all of the templated
    string locations. These look like the pattern `${<name>}`. To do this, we will
    add another argument to this loop that will give the name of the variable we want
    to use. Let''s go ahead and add this to the `sidebar.html` file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'With this, we should now pass in a list of variables that we are going to want
    to use for our templating system—in this case, one named `articles` that is an
    array of objects that have a `location` and `name` key. This could look like the
    following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'With enough to satisfy our `for` loop condition, we can now head back to the
    `Transform` stream and add this as an item we will process in our constructor,
    and send it to our `processPattern` method. Once we have added these items here,
    we will update our loop case with the following code inside of the `for` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Our temporary string holds all of the data that we consider a template, and
    the `varName` variable tells us where to look in our object that we pass into
    `processPattern` to do our replacement strategy. Next, we will use a regular expression
    to pull out the name of the variable. This specific regular expression says to
    look for the `${<name>}` pattern while also saying to capture whatever is in the
    `<name>` section. This allows us to easily get to the name of the variable. We
    will also keep looping through the template to see if there are more regular expressions
    that pass these criteria. Finally, we will replace that templated code with the
    variable we have stored.
  prefs: []
  type: TYPE_NORMAL
- en: Once all of this is done, we will concatenate all of these buffers together
    and return all of them. That is a lot for that piece of code; luckily, the `from`
    section of our template is quite a bit easier to handle. The `from` section of
    our templating code will just look for a file with that name from our `templateDirectory`
    variable and will return the buffer form of it.
  prefs: []
  type: TYPE_NORMAL
- en: 'It should look something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We first grab the type of file from the second argument. If it is not an `HTML`
    or `CSS` file, we will reject it. Otherwise, we will try reading the file in and
    sending it to our stream.
  prefs: []
  type: TYPE_NORMAL
- en: Some of you may be wondering how we will handle the templating in the other
    files. Right now, if we run our system on the `main.html` file, we will get all
    the separate chunks, but our `sidebar.html` file is not filled out. This is one
    weakness of our templating system. One way around this is to create another function
    that will call our `Transform` stream a certain amount of times. This will make
    sure we get the templating done for these separate pieces. Let's go ahead and
    create that function right now.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is not the only way to handle this. Instead, we could utilize another
    system: when we see template directives in a file, we add that buffer to the list
    of items needed for processing. This would allow our stream to process the directives
    instead of looping through the buffers again and again. This leads to its own
    problems since someone could write an infinitely recursing template and would
    cause our stream to break. Everything is a trade-off, and right now, we are going
    for ease of coding over ease of use.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will need to import the `once` function from the `events` module
    and the `PassThrough` stream from the `stream` module. Let''s update those dependencies
    now, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will create a new `Transform` stream that will bring in the same information
    as before, but now, we will also add in a loop counter. We will also respond to
    the `transform` event and push it onto a private variable until we have read in
    the entire starting template, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will make our `flush` event `async` since we will utilize an async
    `for` loop, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Essentially, we will put all of the initial template data together. Then, we
    will run this data through our `TemplateBuilder`, building a new template for
    it to run over. We utilize the `await once(templateBuilder, ‘end')` system to
    let us treat this code synchronously. Once we have gone through the counter, we
    will spit out the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can test this with our old test harness. Let''s go ahead and set it up to
    utilize our new `Transform` stream, along with spitting the data out to a file,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: If we now run this, we will notice that the `test.html` file holds our fully
    built-out `template` file! We now have a functioning template system we can use.
    Let's hook this up to our server.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up our server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With our templating system working, let''s go ahead and hook all of this up
    to our server. Instead of now responding with a simple message of A okay!, we
    will respond with our template all put together. We can do this easily by running
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This should look almost exactly like our test harness. If we now head to `https://localhost:50000`,
    we should see a very basic HTML page, but we have our templated file created!
    If we now head into the development tools and look at the sources, we will see
    something odd. The CSS states that we loaded in our `main.css` file, but the contents
    of the file look exactly like our HTML file!
  prefs: []
  type: TYPE_NORMAL
- en: 'Our server is responding to every request with our HTML file! What we need
    to do is some extra work so our server can respond to the requests correctly.
    We will do this by mapping the URL of the request to the files that we have. For
    simplicity''s sake, we will only respond to HTML and CSS requests (we will not
    be sending any JavaScript across), but this system can easily be added upon to
    add in return types for images, and even files. We will add all of this by doing
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will set up a lookup table for our file endings, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will use this map to pull the files based off of `headers` of the
    request, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The basic idea is to loop through our supported file types to see if we have
    them. If we do, then we will respond with the file and also tell the browser whether
    it is an HTML or CSS file through the `content-type` header.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need a way to tell if a request is bad or not. Currently, we can go
    to any URL and we will just get the same response over and over again. We will
    utilize a `publishedDirectory` environment variable for this. Based on the name
    of the files in there, those will be our endpoints. For every sub-URL pattern,
    we will look for subdirectories that follow the same pattern. This is illustrated
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The `.md` extension means that it is a Markdown file. This is how we will write
    out pages.
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, let''s get this mapping working. To do this, we will put the following
    code below our `for` loop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We wrap our method for finding the file (`fs.statSync`) inside of a `try`/`catch`
    block. With this, if we error out, this will usually mean that we did not find
    the file, and we will send a `404` message to the user. Otherwise, we will just
    send what we have been sending: our example `template`. If we now run our server,
    we will be greeted with the following message: File Not Found! Turn Back!. We
    have nothing in that directory!'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go ahead and create the directory, and add a file called `first.md`.
    If we add this directory and the file and rerun our server, we will still get
    the error message if we head to `https://localhost:50000/first`! We are getting
    this because we did not tack on the Markdown file extension when checking for
    the file! Let''s go ahead and add this to the `fs.statSync` check, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Now, when we rerun our server, we will see the normal template that we had before.
    If we add content to the `first.md` file, we will not get that file. We now need
    to add this addition to our templating system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember at the start of the chapter we added the `npm` package `remarkable`?
    We will now add the Markdown renderer, `remarkable`, and a new keyword that our
    templating language will look for to render the Markdown, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add `Remarkable` as an import to our `template.js` file, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We will look for the following directive to include that Markdown file into
    `<% file <filename> %>` template, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We will now need to add the `publishDir` variable to our `Transform` stream''s
    possible options in the constructor, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '**Remember**: Quite a bit of code has been removed from these examples to make
    them easier to read. For the full examples, head on over to the book''s code repository.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `LoopingStream` class that will loop and run the `TemplateBuilder`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'We will need to update our template with the following templated line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to pass in the `publish` directory to our stream from the
    server. We can do this with the following code addition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'With all of this, we should get something back from the server that is not
    just our base template. If we added some Markdown to the file, we should just
    see that Markdown with our template. We now need to make sure that this Markdown
    gets processed. Let''s head back to our transformation method and call the `Remarkable`
    method so that it processes the Markdown and gives us back HTML, as shown in the
    following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'With this change, we now have a generic Markdown parser that enables us to
    take our template files and send them back with our `main.html` file. The final
    change we will need to make in order to have a functioning templating system and
    static server is to make sure that instead of the `main.html` file having the
    exact template, it has the directive state that we want in order to put a file
    there and have our templating system put the file that is declared in our stream
    constructor. We can do this easily with the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In our `template.js` file, we will utilize a unique variable called `fileToProcess`.
    We get this the same way we get the variables that we want to process for the
    `sidebar.html` file, through the `vars` that we pass through. We will utilize
    the file we have in the second part of the `template` directive if we do not have
    the file from the `fileToProcess` variable, as shown in the following code block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'We will need to pass this variable from our server to the stream, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The final change we will make is to change the `html` file, to have a new base
    Markdown file for pages that we do not have. This could allow us to have a base
    page for the root URL. We will not be implementing this, but this is a way for
    us to do that:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: With this change, if we now run our server, we have a fully functioning templating
    system with Markdown support! This is an amazing achievement! However, we will
    need to add two features to our server so that it will be able to handle more
    requests and process the same requests quickly. These features are caching and
    clustering.
  prefs: []
  type: TYPE_NORMAL
- en: Adding caching and clustering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, we will start by adding a cache to our server. We do not want to constantly
    recompile pages that we have already compiled before. To do this, we will implement
    a class that surrounds a map. This class will keep track of 10 files at a time.
    We will also implement the timestamp when the file was last used. When we reach
    the eleventh file, we will see that it is not in the cache and that we have hit
    the maximum number of files we can hold in the cache. We will replace the compiled
    page with the earliest timestamped file.
  prefs: []
  type: TYPE_NORMAL
- en: This is known as a **Least Recently Used** (**LRU**) cache. There are many other
    types of caching strategies out there, such as a **Time To Live** (**TTL**) cache.
    This type of cache will eliminate files that have been in the cache for too long.
    This is a great type of cache for when we keep using the same files over and over
    again, but we eventually want to free up space when the server has not been hit
    for a while. An LRU cache will always keep these files in place, even if the server
    has not been hit for hours. We could always implement both caching strategies,
    but we will just implement the LRU cache for now.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will create a new file called `cache.js`. Inside of here, we will
    do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new class. We don''t need to extend any other class since we are just
    writing a wrapper around the `Map` data structure built into JavaScript, as shown
    in the following code block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'We will then have a constructor that will take in the number of files that
    we want to store in the cache before we use our strategy to replace one of the
    files, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will add the `add` operation to our cache. It will take in the buffer
    form of our page and the URL that we hit to get it. The key will be the URL, and
    the value will be the buffer form of our page, as shown in the following code
    block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we will implement the `get` operation, whereby we try to grab a file
    based on the URL. If we do not have it, we will return `null`. If we do retrieve
    a file, we will update the time, since this would be considered the latest page
    grab. This is illustrated as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can update our `add` method''s `if` statement. If we are at the limit,
    we will iterate through our map and see what the shortest time is. We will remove
    that file and replace it with the newly created one, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'We now have a basic LRU cache in place for our files. To attach this to our
    server, we will need to put it in the middle of our pipeline:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s head back into the main file and import this file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'We will now change a bit of the logic in our stream handler. If we notice the
    URL is something that we have in the cache, we will just grab the data and pipe
    it into our response. Otherwise, we will compile the template, set it in our cache,
    and stream the compiled version down, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: If we try to run the preceding code, we will now see that we grab files from
    the cache if we hit the same page twice; and if we hit them for the first time,
    it will compile through our template stream and then set it in the cache.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make sure that our replace strategy works, let''s go ahead and set the size
    of the cache to only `1`, and see if we constantly replace the file if we hit
    a new URL, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: If we now log our cache when each method is hit, we will now see that we are
    replacing the file when we hit a new page, but if we stay on the same page, we
    are just sending the cached file back.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have added caching, let''s add one more piece to our server so,
    that way, we can handle a lot of connections. We will be adding in the `cluster`
    module, just as we did in [Chapter 6](7dc2a5fd-0c78-49e7-9e84-f789eab14ca5.xhtml),
    *Message Passing – Learning about the Different Types*. We''ll proceed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s import the `cluster` module in the `main.js` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: We will now have the initialization of the server in our main process. For our
    other processes, we will process the requests.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, let''s change our strategy to handle the incoming requests inside of our
    child processes, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: With this single change, we are now handling the requests between four different
    processes. Just as we learned in [Chapter 6](7dc2a5fd-0c78-49e7-9e84-f789eab14ca5.xhtml),
    *Message Passing – Learning about the Different Types*, we can share a single
    port for our `cluster` module.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While there is one piece left to add (hooking our sidebar up to point to real
    files), this should be a great general-purpose templating server. All that needs
    to be done is modifying our `FILE` template and hooking it into the sidebar of
    our templating system. With everything we have learned about Node.js, we should
    be able to handle almost any type of server-side application. We should also be
    able to understand how implementations of web servers such as Express are created
    from these basic building blocks.
  prefs: []
  type: TYPE_NORMAL
- en: From here, we will head back into the browser and take some of the concepts
    we learned from this part of the book and apply them to the web over the next
    couple of chapters. We will start by looking at worker threads in the browser,
    known as dedicated workers. We will then take a look at shared workers, and how
    we can benefit from being able to offload work to these workers, but still be
    able to grab the data from them. Finally, we will take a look at service workers,
    and see how they can help us with various optimizations, such as caching in the
    browser.
  prefs: []
  type: TYPE_NORMAL
