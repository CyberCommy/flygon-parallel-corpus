- en: Practical Example - Building a Static Server
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实际示例 - 构建静态服务器
- en: We have looked at Node.js and what it has to offer in the past few chapters.
    While we have not gone over every module or everything that Node.js has to offer,
    we have all the pieces to put together a static content/generator site. This means
    that we will set up a server to listen for requests and build pages off of that
    request.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的几章中，我们已经了解了Node.js及其提供的功能。虽然我们没有涵盖每个模块或Node.js提供的所有内容，但我们已经有了所有的要素来构建一个静态内容/生成器站点。这意味着我们将设置一个服务器来监听请求，并根据该请求构建页面。
- en: 'To implement this server, we will need to understand how site generation works,
    and how we might implement this as an on-the-fly operation. On top of this, we
    will look at caching so that we do not have to recompile every single time a page
    is requested. Overall, in this chapter, we will look at and implement the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这个服务器，我们需要了解站点生成的工作原理，以及如何将其作为即时操作实现。除此之外，我们还将研究缓存，以便我们不必在每次请求页面时重新编译。总的来说，在本章中，我们将查看并实现以下内容：
- en: Understanding static content
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解静态内容
- en: Setting up our server
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置我们的服务器
- en: Adding caching and clustering
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加缓存和集群
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: A text editor or **integrated development environment** (**IDE**), preferably
    VS Code
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个文本编辑器或**集成开发环境**（**IDE**），最好是VS Code
- en: An operating system that supports Node.js
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持Node.js的操作系统
- en: 'The code for this chapter can be found at the following URL: [https://github.com/PacktPublishing/Hands-On-High-Performance-Web-Development-with-JavaScript/tree/master/Chapter09/microserve](https://github.com/PacktPublishing/Hands-On-High-Performance-Web-Development-with-JavaScript/tree/master/Chapter09/microserve).'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章的代码可以在以下网址找到：[https://github.com/PacktPublishing/Hands-On-High-Performance-Web-Development-with-JavaScript/tree/master/Chapter09/microserve](https://github.com/PacktPublishing/Hands-On-High-Performance-Web-Development-with-JavaScript/tree/master/Chapter09/microserve)。
- en: Understanding static content
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解静态内容
- en: 'Static content means exactly that: content that does not change. This can be
    HTML pages, JavaScript, images, and so on. Anything that does not need to run
    through a database or some external system for processing can be considered as
    static content.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 静态内容就是不变的内容。这可以是HTML页面、JavaScript、图像等。任何不需要通过数据库或某些外部系统进行处理的内容都可以被视为静态内容。
- en: While we will not be implementing a static content server directly, we will
    be implementing an on-the-fly static content generator. For those that do not
    know, a static content generator is a system that builds the static content and
    then serves that content up. The content is usually built by some type of templating
    system.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们不会直接实现静态内容服务器，但我们将实现一个即时静态内容生成器。对于不了解的人来说，静态内容生成器是一个构建静态内容然后提供该内容的系统。内容通常由某种模板系统构建。
- en: Some common templating systems that are out there include Mustache, Handlebars.js,
    and Jade. These template engines look for some sort of tags and replace the content
    based on some variables. While we will not be looking at any of these templating
    engines directly, know that they are out there and that they can be quite useful
    for things such as code documentation generation, or even creating JavaScript
    files based off of some API specification.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 一些常见的模板系统包括Mustache、Handlebars.js和Jade。这些模板引擎寻找某种标记，并根据一些变量替换内容。虽然我们不会直接查看这些模板引擎，但要知道它们存在，并且它们对于诸如代码文档生成或甚至根据某些API规范创建JavaScript文件等方面非常有用。
- en: 'Instead of using one of these common formats, we will implement our own version
    of a templating system to see how templating works. We will try to keep it as
    simple as possible since we want to use a minimal amount of dependencies for our
    server. The one dependency that we will be utilizing is a Markdown to HTML converter
    called `Remarkable`: [https://github.com/jonschlinkert/remarkable](https://github.com/jonschlinkert/remarkable).
    It depends on two libraries and each of those depends on one library, so we will
    be importing a total of five libraries.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现自己的模板系统版本，而不是使用其中一个常见格式，以了解模板的工作原理。我们将尽量保持简单，因为我们希望为我们的服务器使用最少的依赖项。我们将使用一个名为`Remarkable`的Markdown到HTML转换器作为依赖项：[https://github.com/jonschlinkert/remarkable](https://github.com/jonschlinkert/remarkable)。它依赖于两个库，每个库又依赖于一个库，因此我们将导入总共五个库。
- en: While creating all of the pages on-the-fly will allow us to make changes quite
    easily, we would not want to keep doing this unless we were in a development environment.
    To make sure that we do not keep building the HTML files over and over again,
    we will implement an in-memory cache to store the files that have been requested
    the most.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然即时创建所有页面将使我们能够轻松进行更改，但除非我们处于开发环境中，否则我们不希望一直这样做。为了确保我们不一遍又一遍地构建HTML文件，我们将实现一个内存缓存来存储被请求最多的文件。
- en: With all of this, let's go ahead and get started with building out our application,
    by setting up our server and getting a response sent out.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，让我们继续开始构建我们的应用程序，通过设置我们的服务器并发送响应。
- en: Starting our application
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动我们的应用程序
- en: 'First, let''s go ahead and set up our project by creating our `package.json`
    file in a folder of our choosing. We can start with the following basic `package.json`
    file:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们通过在我们选择的文件夹中创建我们的`package.json`文件来设置我们的项目。我们可以从以下基本的`package.json`文件开始：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This should be fairly straightforward now. The main thing is that the type
    is set to `module` so we can utilize modules inside of Node.js. Next, let''s go
    ahead and add the `Remarkable` dependency by running `npm install remarkable`
    inside the folder in which we put our `package.json` file. With that, we should
    now have `remarkable` listed as a dependency in our `package.json` file. Next,
    let''s go ahead and get our server set up. To do so, create a `main.js` file and
    do the following:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应该相当简单了。主要的是将类型设置为`module`，这样我们就可以在Node.js中使用模块。接下来，让我们继续通过在放置`package.json`文件的文件夹中运行`npm
    install remarkable`来添加`Remarkable`依赖项。有了这个，我们现在应该在我们的`package.json`文件中列出`remarkable`作为一个依赖项。接下来，让我们继续设置我们的服务器。为此，创建一个`main.js`文件并执行以下操作：
- en: 'Import the `http2` and `fs` modules, since we will use them to start our server
    and read our private key and certificate files, as follows:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入`http2`和`fs`模块，因为我们将使用它们来启动我们的服务器和读取我们的私钥和证书文件，如下所示：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Create our server and read in our key and certificate files. We will generate
    these after setting up our main file, like this:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建我们的服务器并读取我们的密钥和证书文件。我们将在设置主文件后生成这些文件，就像这样：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Respond to the error event by just crashing our server (we should probably
    handle this better, but for now, this will work). We will also handle an incoming
    request by just responding with a simple message and a status of `200` (which
    means all good), like this:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过崩溃我们的服务器来响应错误事件（我们可能应该更好地处理这个问题，但现在这样做就可以了）。我们还将通过简单的消息和状态码`200`（表示一切正常）来处理传入的请求，就像这样：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Finally, we will start listening in on port `50000` (a random port number can
    be used here).
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将开始监听端口`50000`（这里可以使用一个随机端口号）。
- en: 'Now, if we do try to run this, we should be greeted by a nasty error message
    similar to the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们尝试运行这个，我们应该会被类似以下的一个令人讨厌的错误消息所打招呼：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We have not generated our self-signed private key and certificate yet. Remember
    from [Chapter 6](7dc2a5fd-0c78-49e7-9e84-f789eab14ca5.xhtml), *Message Passing
    – Learning about the Different Types*, that we cannot serve any content over an
    unsecured channel (HTTP); instead, we have to utilize HTTPS. To do this, we need
    to either get a certificate from a certificate authority or we need to generate
    one ourselves. From [Chapter 6](7dc2a5fd-0c78-49e7-9e84-f789eab14ca5.xhtml), *Message
    Passing – Learning about the Different Types*, we should have the `openssl` application
    installed on our computers.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有生成自签名的私钥和证书。请记住从[第6章](7dc2a5fd-0c78-49e7-9e84-f789eab14ca5.xhtml)中了解到，我们不能在不安全的通道（HTTP）上提供任何内容；相反，我们必须使用HTTPS。为此，我们需要从证书颁发机构获取证书，或者我们需要自己生成一个。从[第6章](7dc2a5fd-0c78-49e7-9e84-f789eab14ca5.xhtml)中了解到，我们应该在我们的计算机上安装`openssl`应用程序。
- en: 'Let''s go ahead and generate that by running the following command and just
    pressing *Enter* through the Command Prompts:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们继续通过运行以下命令来生成它，并只需通过命令提示符按*Enter*：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We should now have both of those files in our current directory, and now, if
    we try running our application, we should have a server listening on port `50000`.
    We can check this by going to the following address: `127.0.0.1:50000`. If everything
    worked correctly, we should see the message A okay!'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们应该在当前目录中有这两个文件，现在，如果我们尝试运行我们的应用程序，我们应该有一个在端口`50000`上监听的服务器。我们可以通过访问以下地址来检查：`127.0.0.1:50000`。如果一切正常，我们应该看到消息A
    okay！
- en: 'While having variables such as the port, private key, and certificate hardcoded
    is okay for development purposes, we should still move these to our `package.json`
    file so another user could make the changes to them in a single place, instead
    of having to go into the code and make the changes. Let''s go ahead and make these
    changes right now. Inside of our `package.json` file, let''s add the following
    fields:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然像端口、私钥和证书这样的变量在开发过程中硬编码是可以的，但我们仍然应该将它们移到我们的`package.json`文件中，这样另一个用户可以在一个地方进行更改，而不是必须进入代码并进行更改。让我们继续进行这些更改。在我们的`package.json`文件中，让我们添加以下字段：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `config` section will allow us to pass in various variables that we will
    let the user of the package set, either with the `package.json` `config` section,
    or when running our file by using the `npm config set tinyserve:<variable>` command.
    The `scripts` section, as we saw from [Chapter 5](6c403493-7028-408c-9da6-b6650ad6bfcb.xhtml),
    *Switching Contexts – No DOM, Different Vanilla*, allows us access to these variables
    and allows the user of our package to now just use `npm start`, instead of using
    `node --experimental-modules main.js`. With this, we can change our `main.js`
    file by declaring all of these variables near the top of our file, like so:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`config`部分将允许我们传递各种变量，让包的用户使用`package.json`的`config`部分设置，或者在运行我们的文件时使用`npm
    config set tinyserve:<variable>`命令设置。正如我们从[第5章](6c403493-7028-408c-9da6-b6650ad6bfcb.xhtml)中看到的，`scripts`部分允许我们访问这些变量，并允许我们的包的用户现在只需使用`npm
    start`，而不是使用`node --experimental-modules main.js`。有了这个，我们可以通过在我们的`main.js`文件中声明所有这些变量来改变我们的`main.js`文件，就像这样：'
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: All of the configuration variables can be found on our `process.env` variable,
    so we declare a shortcut to it at the top of our file. We can then get access
    to the various variables, as we have seen in [Chapter 5](6c403493-7028-408c-9da6-b6650ad6bfcb.xhtml),
    *Switching Contexts – No DOM, Different Vanilla*. We also set defaults, just in
    case the user does not run our file using the `npm start` script that we declared.
    Users will also notice that we have declared a few extra variables. These are
    variables that we will talk about later, but they deal with where we hyperlink
    to and whether we want to enable the caching or not (the development variable).
    Next, we will take a look at how we will access the templating system that we
    want to set up.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 所有配置变量都可以在我们的`process.env`变量中找到，因此我们在文件顶部声明了一个快捷方式。 然后，我们可以访问各种变量，就像我们在[第5章](6c403493-7028-408c-9da6-b6650ad6bfcb.xhtml)中看到的那样，*切换上下文-没有DOM，不同的Vanilla*。
    我们还设置了默认值，以防用户没有使用我们声明的`npm start`脚本运行我们的文件。 用户还会注意到我们声明了一些额外的变量。 这些是我们稍后会讨论的变量，但它们涉及到我们要超链接到的位置以及我们是否要启用缓存（开发变量）。
    接下来，我们将看一下我们将如何访问我们想要设置的模板系统。
- en: Setting up our templating system
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置我们的模板系统
- en: We are going to use Markdown for the various content we want to host, but there
    are going to be certain sections of our files that we will want to use across
    all of the articles. These will be things such as the header, footer, and the
    sidebar of our pages. Instead of having to have these inserted into all of the
    Markdown files that we will create for our articles, we can template these in.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Markdown来托管我们想要托管的各种内容，但我们将希望在所有文章中使用某些部分。 这些将是我们页面的页眉、页脚和侧边栏等内容。 我们可以将这些内容模板化，而不必将它们插入到我们为文章创建的所有Markdown文件中。
- en: 'We will put these sections in a folder that will be known at runtime, by using
    the `templateDirectory` variable that we declared. This will also allow users
    of our package to change out the look and feel of our static site server without
    having to do anything too crazy. Let''s go ahead and create the directory structure
    for the template section. This should look like the following:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把这些部分放在一个在运行时将被知道的文件夹中，通过我们声明的`templateDirectory`变量。 这也将允许我们包的用户更改我们的静态站点服务器的外观和感觉，而无需做任何太疯狂的事情。
    让我们继续创建模板部分的目录结构。 这应该看起来像下面这样：
- en: '**Template**: Where we should look for the static content across all pages'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模板**：我们应该在所有页面中查找静态内容'
- en: '**HTML**: Where all of our static HTML code will go'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HTML**：我们所有静态HTML代码将放在这里'
- en: '**CSS**: Where our stylesheets will live'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CSS**：我们的样式表将存放在这里'
- en: 'With this directory structure, we can now create some basic header, footer,
    and sidebar HTML files, and also some basic **Cascading Style Sheets** (**CSS**),
    to get a page structure that should be familiar to everyone. So, let''s begin,
    as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个目录结构，我们现在可以创建一些基本的页眉、页脚和侧边栏HTML文件，以及一些基本的**层叠样式表**（**CSS**），以获得一个对每个人都应该熟悉的页面结构。
    所以，让我们开始，如下所示：
- en: 'We will write the `header` HTML, like so:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将编写`header` HTML，如下所示：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: With this basic structure, we have the name of our website, and then a couple
    of links that most blog sites will have.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个基本结构，我们有了网站的名称，然后是大多数博客网站都会有的一些链接。
- en: 'Next, let''s create the `footer` section, like this:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们创建`footer`部分，就像这样：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Again, fairly self-explanatory. Finally, we will create the sidebar, as follows:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次，相当容易理解。 最后，我们将创建侧边栏，如下所示：
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This is where our templating engine comes into play. First, we are going to
    use `<% %>` character pattern to denote that we want to replace this with some
    static content. Next, `loop <number>` will let our templating engine know that
    we plan on looping through the next piece of content a certain amount of times
    before stopping the engine. Finally, the `<a href="article/${location}">${name}</a>`
    pattern will tell our templating engine that this is the content we want to put
    in, but we will want to replace the `${}` tags with variables in an object that
    we pass in our code.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们的模板引擎发挥作用的地方。 首先，我们将使用`<% %>`字符模式来表示我们要用一些静态内容替换它。 接下来，`loop <number>`将让我们的模板引擎知道我们计划在停止引擎之前循环一定次数的下一个内容。
    最后，`<a href="article/${location}">${name}</a>`模式将告诉我们的模板引擎这是我们要放入的内容，但我们将要用我们在代码中传递的对象中的变量替换`${}`标签。
- en: 'Next, let''s go ahead and create the basic CSS for our page, as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们继续创建我们页面的基本CSS，如下所示：
- en: '[PRE11]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Most of the CSS file has been cut since a majority of it is boilerplate code.
    The only piece that is worth mentioning is the custom variables. With CSS, we
    can declare our own custom variables by using the pattern `--<name> : <content>`,
    and then we can use it later in the CSS file by using the `var()` declaration.
    This allows us to reuse variables such as colors and heights without having to
    use a preprocessor such as **Syntactically Awesome Style Sheets** (**SASS**).'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '由于大部分是样板代码，CSS文件已经被剪切了。 值得一提的是自定义变量。 使用CSS，我们可以通过使用模式`--<name> : <content>`声明自定义变量，然后我们可以在CSS文件中使用`var()`声明来使用它。
    这使我们能够重用变量，如颜色和高度，而无需使用预处理器，如**SASS**。'
- en: CSS variables are scoped. This means if you define the variable for the `header`
    section, it will only be available in the `header` section. This is why we decided
    to put our colors at the `:root` pseudo element level since it will be available
    across our entire page. Just remember that CSS variables have scope similar to
    the `let` and `const` variables we declare in JavaScript.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: CSS变量是有作用域的。 这意味着如果您为`header`部分定义变量，它将仅在`header`部分中可用。 这就是为什么我们决定将我们的颜色放在`:root`伪元素级别，因为它将在整个页面中可用。
    只需记住，CSS变量的作用域类似于我们在JavaScript中声明的`let`和`const`变量。
- en: 'With our CSS laid out, we can now write our main HTML file in our `template`
    file. We will move this outside of the HTML folder since this is the main file
    that we will want in order to put everything together. It will also let users
    of our package know that this is the main file that we will use to put together
    all of the pieces and that if they want to change it up, they should do it here.
    For now, let''s create a `main.html` file that looks like the following:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The top section should look familiar, but we now have a new template type. The
    `from` directive lets us know that we are going to source this file from somewhere
    else. The next statement says it is an `HTML` file, so we will look inside the
    `HTML` folder. Finally, we see the name of the file, so we know that we want to
    bring in the `header.html` file.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: With all of this, we can now write the templating system that we are going to
    use to build our pages. We will be implementing our templating system utilizing
    a `Transform` stream. While we could utilize something like a `Writable` stream,
    it makes more sense to utilize a `Transform` stream since we are changing the
    output based on some input criteria.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement the `Transform` stream, we will need to keep track of a few things
    so, that way, we can process our keys correctly. First, let''s get us reading
    and sending off the proper chunks to be processed. We can do this by implementing
    the `transform` method and spitting out the chunks that we are going to replace.
    To do this, we will do the following:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: 'We will extend a `Transform` stream and set up the basic structure, as we did
    in [Chapter 7](81cf1aa1-6ded-4d94-8686-e2bd65db6a8c.xhtml), *Streams – Understanding
    Streams and Non-Blocking I/O*. We will also create a custom class to hold the
    start and end locations of a buffer. This will allow us to know if we got the
    start of the pattern matcher in the same loop. We will need this later. We will
    also set up some private variables for our class, such as the `begin` and `end`
    template buffers, on top of state variables such as the `#pattern` variable, as
    follows:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, we will have to check if we have data held in our `#pattern` state variable.
    If we do not, then we know to look for the beginning of a template. Once we do
    the check for the beginning of a template statement, we can check to see if it
    is actually in this chunk of data. If it is, we set the `start` property of `#pair`
    to this location so our loop can keep going; otherwise, we have no template in
    this chunk and we can start to process the next chunk, as shown here:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To handle the other condition (we are looking for the end of a template), we
    have quite a bit more state to deal with. First, if our `#pair` variable''s `start`
    is not `-1` (we set it), we know we are still processing a current chunk. This
    means we need to check if we can find the `end` template buffer in the current
    chunk. If we do, then we can process the pattern and reset our `#pair` variable.
    Otherwise, we just push the current chunk from the `start` member location of
    `#pair` to our `#pattern` holder at the end of the chunk, as follows:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Finally, if `start` member of `#pair` is set, we check for the `end` template
    pattern. If we do not find it, we just push the entire chunk to the `#pattern`
    array. If we do find it, we slice the chunk from the beginning of it to where
    we found our `end` template string. We then concatenate all this together and
    process it. We will then also reset our `#pattern` variable back to holding nothing,
    like this:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'All of this will be wrapped in a `do`/`while` loop since we want to run this
    piece of code at least once, and we will know that we are finished when our `location`
    variable is `-1` (this is what is returned from an `indexOf` check when it does
    not find what we want). After the `do`/`while` loop, we run the callback to tell
    our stream that we are ready to process more data, as follows:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'With all of this put together, we now have a `transform` loop that should handle
    almost all of the conditions to grab our templating system. We can test this by
    passing in our `main.html` file and putting the following code inside of our `processPattern`
    method, like this:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We can create a test script to run our `main.html` file through. Go ahead and
    create a `test.js` file and put the following code in it:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'With this, we should get a nice printout with the template syntax that we were
    looking for, such as `from html header`*.* If we ran our `sidebar.html` file through
    it, it should look something like the following:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now that we know our `Transform` stream's template-finding code works, we just
    need to write our process chunk system to handle the preceding cases we have.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: 'To now process the chunks, we will need to know where to look for the files.
    Remember from before, when we declared various variables inside of our `package.json`
    file? Now, we will utilize the `templateDirectory` one. Let''s go ahead and pass
    that in as an argument for our stream, like so:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, when we call `processPattern`, we can pass in the chunk and the `template`
    directory as arguments. From here, we can now implement the `processPattern` method.
    We will handle two cases: when we find a `for` loop and when we find a `find`
    statement.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: 'To process a `for` loop and a `find` statement, we will proceed as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: 'We will build out an array of buffers that will be what the template held,
    other than the `for` loop. We can do this with the following code:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We will look for the loop directive and then take the second argument, which
    should be a number. If we print this out, we will see that we have buffers that
    are all filled with the same exact data.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we will need to make sure that we are filling in all of the templated
    string locations. These look like the pattern `${<name>}`. To do this, we will
    add another argument to this loop that will give the name of the variable we want
    to use. Let''s go ahead and add this to the `sidebar.html` file, as follows:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'With this, we should now pass in a list of variables that we are going to want
    to use for our templating system—in this case, one named `articles` that is an
    array of objects that have a `location` and `name` key. This could look like the
    following:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'With enough to satisfy our `for` loop condition, we can now head back to the
    `Transform` stream and add this as an item we will process in our constructor,
    and send it to our `processPattern` method. Once we have added these items here,
    we will update our loop case with the following code inside of the `for` loop:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Our temporary string holds all of the data that we consider a template, and
    the `varName` variable tells us where to look in our object that we pass into
    `processPattern` to do our replacement strategy. Next, we will use a regular expression
    to pull out the name of the variable. This specific regular expression says to
    look for the `${<name>}` pattern while also saying to capture whatever is in the
    `<name>` section. This allows us to easily get to the name of the variable. We
    will also keep looping through the template to see if there are more regular expressions
    that pass these criteria. Finally, we will replace that templated code with the
    variable we have stored.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: Once all of this is done, we will concatenate all of these buffers together
    and return all of them. That is a lot for that piece of code; luckily, the `from`
    section of our template is quite a bit easier to handle. The `from` section of
    our templating code will just look for a file with that name from our `templateDirectory`
    variable and will return the buffer form of it.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: 'It should look something like the following:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We first grab the type of file from the second argument. If it is not an `HTML`
    or `CSS` file, we will reject it. Otherwise, we will try reading the file in and
    sending it to our stream.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: Some of you may be wondering how we will handle the templating in the other
    files. Right now, if we run our system on the `main.html` file, we will get all
    the separate chunks, but our `sidebar.html` file is not filled out. This is one
    weakness of our templating system. One way around this is to create another function
    that will call our `Transform` stream a certain amount of times. This will make
    sure we get the templating done for these separate pieces. Let's go ahead and
    create that function right now.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: 'This is not the only way to handle this. Instead, we could utilize another
    system: when we see template directives in a file, we add that buffer to the list
    of items needed for processing. This would allow our stream to process the directives
    instead of looping through the buffers again and again. This leads to its own
    problems since someone could write an infinitely recursing template and would
    cause our stream to break. Everything is a trade-off, and right now, we are going
    for ease of coding over ease of use.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will need to import the `once` function from the `events` module
    and the `PassThrough` stream from the `stream` module. Let''s update those dependencies
    now, like this:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Next, we will create a new `Transform` stream that will bring in the same information
    as before, but now, we will also add in a loop counter. We will also respond to
    the `transform` event and push it onto a private variable until we have read in
    the entire starting template, as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Next, we will make our `flush` event `async` since we will utilize an async
    `for` loop, like so:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Essentially, we will put all of the initial template data together. Then, we
    will run this data through our `TemplateBuilder`, building a new template for
    it to run over. We utilize the `await once(templateBuilder, ‘end')` system to
    let us treat this code synchronously. Once we have gone through the counter, we
    will spit out the data.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: 'We can test this with our old test harness. Let''s go ahead and set it up to
    utilize our new `Transform` stream, along with spitting the data out to a file,
    as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: If we now run this, we will notice that the `test.html` file holds our fully
    built-out `template` file! We now have a functioning template system we can use.
    Let's hook this up to our server.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: Setting up our server
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With our templating system working, let''s go ahead and hook all of this up
    to our server. Instead of now responding with a simple message of A okay!, we
    will respond with our template all put together. We can do this easily by running
    the following code:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This should look almost exactly like our test harness. If we now head to `https://localhost:50000`,
    we should see a very basic HTML page, but we have our templated file created!
    If we now head into the development tools and look at the sources, we will see
    something odd. The CSS states that we loaded in our `main.css` file, but the contents
    of the file look exactly like our HTML file!
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: 'Our server is responding to every request with our HTML file! What we need
    to do is some extra work so our server can respond to the requests correctly.
    We will do this by mapping the URL of the request to the files that we have. For
    simplicity''s sake, we will only respond to HTML and CSS requests (we will not
    be sending any JavaScript across), but this system can easily be added upon to
    add in return types for images, and even files. We will add all of this by doing
    the following:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: 'We will set up a lookup table for our file endings, like this:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Next, we will use this map to pull the files based off of `headers` of the
    request, like this:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The basic idea is to loop through our supported file types to see if we have
    them. If we do, then we will respond with the file and also tell the browser whether
    it is an HTML or CSS file through the `content-type` header.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need a way to tell if a request is bad or not. Currently, we can go
    to any URL and we will just get the same response over and over again. We will
    utilize a `publishedDirectory` environment variable for this. Based on the name
    of the files in there, those will be our endpoints. For every sub-URL pattern,
    we will look for subdirectories that follow the same pattern. This is illustrated
    as follows:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `.md` extension means that it is a Markdown file. This is how we will write
    out pages.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, let''s get this mapping working. To do this, we will put the following
    code below our `for` loop:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We wrap our method for finding the file (`fs.statSync`) inside of a `try`/`catch`
    block. With this, if we error out, this will usually mean that we did not find
    the file, and we will send a `404` message to the user. Otherwise, we will just
    send what we have been sending: our example `template`. If we now run our server,
    we will be greeted with the following message: File Not Found! Turn Back!. We
    have nothing in that directory!'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go ahead and create the directory, and add a file called `first.md`.
    If we add this directory and the file and rerun our server, we will still get
    the error message if we head to `https://localhost:50000/first`! We are getting
    this because we did not tack on the Markdown file extension when checking for
    the file! Let''s go ahead and add this to the `fs.statSync` check, as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Now, when we rerun our server, we will see the normal template that we had before.
    If we add content to the `first.md` file, we will not get that file. We now need
    to add this addition to our templating system.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember at the start of the chapter we added the `npm` package `remarkable`?
    We will now add the Markdown renderer, `remarkable`, and a new keyword that our
    templating language will look for to render the Markdown, as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add `Remarkable` as an import to our `template.js` file, like this:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We will look for the following directive to include that Markdown file into
    `<% file <filename> %>` template, like this:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We will now need to add the `publishDir` variable to our `Transform` stream''s
    possible options in the constructor, as follows:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '**Remember**: Quite a bit of code has been removed from these examples to make
    them easier to read. For the full examples, head on over to the book''s code repository.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `LoopingStream` class that will loop and run the `TemplateBuilder`:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We will need to update our template with the following templated line:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Finally, we need to pass in the `publish` directory to our stream from the
    server. We can do this with the following code addition:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'With all of this, we should get something back from the server that is not
    just our base template. If we added some Markdown to the file, we should just
    see that Markdown with our template. We now need to make sure that this Markdown
    gets processed. Let''s head back to our transformation method and call the `Remarkable`
    method so that it processes the Markdown and gives us back HTML, as shown in the
    following code block:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'With this change, we now have a generic Markdown parser that enables us to
    take our template files and send them back with our `main.html` file. The final
    change we will need to make in order to have a functioning templating system and
    static server is to make sure that instead of the `main.html` file having the
    exact template, it has the directive state that we want in order to put a file
    there and have our templating system put the file that is declared in our stream
    constructor. We can do this easily with the following changes:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: 'In our `template.js` file, we will utilize a unique variable called `fileToProcess`.
    We get this the same way we get the variables that we want to process for the
    `sidebar.html` file, through the `vars` that we pass through. We will utilize
    the file we have in the second part of the `template` directive if we do not have
    the file from the `fileToProcess` variable, as shown in the following code block:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We will need to pass this variable from our server to the stream, like this:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The final change we will make is to change the `html` file, to have a new base
    Markdown file for pages that we do not have. This could allow us to have a base
    page for the root URL. We will not be implementing this, but this is a way for
    us to do that:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: With this change, if we now run our server, we have a fully functioning templating
    system with Markdown support! This is an amazing achievement! However, we will
    need to add two features to our server so that it will be able to handle more
    requests and process the same requests quickly. These features are caching and
    clustering.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: Adding caching and clustering
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, we will start by adding a cache to our server. We do not want to constantly
    recompile pages that we have already compiled before. To do this, we will implement
    a class that surrounds a map. This class will keep track of 10 files at a time.
    We will also implement the timestamp when the file was last used. When we reach
    the eleventh file, we will see that it is not in the cache and that we have hit
    the maximum number of files we can hold in the cache. We will replace the compiled
    page with the earliest timestamped file.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: This is known as a **Least Recently Used** (**LRU**) cache. There are many other
    types of caching strategies out there, such as a **Time To Live** (**TTL**) cache.
    This type of cache will eliminate files that have been in the cache for too long.
    This is a great type of cache for when we keep using the same files over and over
    again, but we eventually want to free up space when the server has not been hit
    for a while. An LRU cache will always keep these files in place, even if the server
    has not been hit for hours. We could always implement both caching strategies,
    but we will just implement the LRU cache for now.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will create a new file called `cache.js`. Inside of here, we will
    do the following:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new class. We don''t need to extend any other class since we are just
    writing a wrapper around the `Map` data structure built into JavaScript, as shown
    in the following code block:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We will then have a constructor that will take in the number of files that
    we want to store in the cache before we use our strategy to replace one of the
    files, like this:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Next, we will add the `add` operation to our cache. It will take in the buffer
    form of our page and the URL that we hit to get it. The key will be the URL, and
    the value will be the buffer form of our page, as shown in the following code
    block:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Then, we will implement the `get` operation, whereby we try to grab a file
    based on the URL. If we do not have it, we will return `null`. If we do retrieve
    a file, we will update the time, since this would be considered the latest page
    grab. This is illustrated as follows:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Now, we can update our `add` method''s `if` statement. If we are at the limit,
    we will iterate through our map and see what the shortest time is. We will remove
    that file and replace it with the newly created one, like this:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We now have a basic LRU cache in place for our files. To attach this to our
    server, we will need to put it in the middle of our pipeline:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s head back into the main file and import this file:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'We will now change a bit of the logic in our stream handler. If we notice the
    URL is something that we have in the cache, we will just grab the data and pipe
    it into our response. Otherwise, we will compile the template, set it in our cache,
    and stream the compiled version down, like this:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: If we try to run the preceding code, we will now see that we grab files from
    the cache if we hit the same page twice; and if we hit them for the first time,
    it will compile through our template stream and then set it in the cache.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: 'To make sure that our replace strategy works, let''s go ahead and set the size
    of the cache to only `1`, and see if we constantly replace the file if we hit
    a new URL, as follows:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: If we now log our cache when each method is hit, we will now see that we are
    replacing the file when we hit a new page, but if we stay on the same page, we
    are just sending the cached file back.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have added caching, let''s add one more piece to our server so,
    that way, we can handle a lot of connections. We will be adding in the `cluster`
    module, just as we did in [Chapter 6](7dc2a5fd-0c78-49e7-9e84-f789eab14ca5.xhtml),
    *Message Passing – Learning about the Different Types*. We''ll proceed as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s import the `cluster` module in the `main.js` file:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: We will now have the initialization of the server in our main process. For our
    other processes, we will process the requests.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, let''s change our strategy to handle the incoming requests inside of our
    child processes, like this:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: With this single change, we are now handling the requests between four different
    processes. Just as we learned in [Chapter 6](7dc2a5fd-0c78-49e7-9e84-f789eab14ca5.xhtml),
    *Message Passing – Learning about the Different Types*, we can share a single
    port for our `cluster` module.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While there is one piece left to add (hooking our sidebar up to point to real
    files), this should be a great general-purpose templating server. All that needs
    to be done is modifying our `FILE` template and hooking it into the sidebar of
    our templating system. With everything we have learned about Node.js, we should
    be able to handle almost any type of server-side application. We should also be
    able to understand how implementations of web servers such as Express are created
    from these basic building blocks.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: From here, we will head back into the browser and take some of the concepts
    we learned from this part of the book and apply them to the web over the next
    couple of chapters. We will start by looking at worker threads in the browser,
    known as dedicated workers. We will then take a look at shared workers, and how
    we can benefit from being able to offload work to these workers, but still be
    able to grab the data from them. Finally, we will take a look at service workers,
    and see how they can help us with various optimizations, such as caching in the
    browser.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
