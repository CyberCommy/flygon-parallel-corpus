- en: Creating Data Interfaces with Model-View Classes
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The vast majority of application software is built to view and manipulate organized
    data. Even in applications that aren't explicitly *database applications*, there's
    often a need to interact with collections of data on a smaller scale, such as
    populating a combobox with options or displaying a hierarchy of settings. Without
    some sort of organizational paradigm, interactions between a GUI and a set of
    data can quickly become a nightmare of spaghetti code. The **m****odel-view**
    pattern is one such paradigm.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to learn about Qt''s model-view widgets and how
    we can use them to work elegantly with data in our applications. We''ll cover
    the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Understanding model-view design
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Models and views in PyQt
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a **comma-separated values** (**CSV**) editor
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter has the same technical requirements as the previous chapters. You
    might also wish to have the example code from [https://github.com/PacktPublishing/Mastering-GUI-Programming-with-Python/tree/master/Chapter05](https://github.com/PacktPublishing/Mastering-GUI-Programming-with-Python/tree/master/Chapter05).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: You will also need one or two CSV files to use with our CSV editor. These can
    be made in any spreadsheet program and should be created with column headers as
    the first row.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: Check out the following video to see the code in action: [http://bit.ly/2M66bnv](http://bit.ly/2M66bnv)
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Understanding model-view design
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Model-view is a software application design paradigm that implements **separation
    of concerns**. It is based on the venerable **Model-View-Controller** (**MVC**)
    pattern but differs in that the controller and view are combined into one component.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: In model-view design, the **model** is the component that holds the application
    data and contains the logic for retrieving, storing, and manipulating data. The
    **view** component presents the data to the user and provides an interface for
    entering and manipulating data. By separating these components of the application,
    we keep their interdependency to a minimum, making them much easier to reuse or
    refactor.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go through a simple example to illustrate this process. Starting with
    the application template from [Chapter 4](9281bd2a-64a1-4128-92b0-e4871b79c040.xhtml),
    *Building Applications with QMainWindow*, let''s build a simple text-file editor:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This is a simple form with a line edit for the filename, a text edit for the
    content, and a Save button that calls a  `save()`  method.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create the `save()` method as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This method checks whether there is a filename entered in the line edit, makes
    sure the filename doesn't already exist (so you don't overwrite an important file
    while testing this code!), then attempts to save it. If there is an error of any
    kind, the method displays a `QMessageBox` instance to report the error.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: This application works but lacks a clean separation of model and view. The same
    method that writes the file to disk also displays error boxes and calls input
    widget methods. If we were going to expand this application to any degree, the
    `save()` method would quickly become a maze of presentation logic mixed with data-handling
    logic.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Let's rewrite this application with separate `Model` and `View` classes.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: 'Starting with a clean copy of the application template, let''s create our `Model`
    class:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We''ve built our model by subclassing `QObject`. Models should have no involvement
    in displaying the GUI, so there''s no need to base it on `QWidget` classes. However,
    as the model will use signals and slots to communicate, we''re using  `QObject`
    as a base class. The model implements our `save()` method from the previous example,
    but with two changes:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: First, it expects user data to be passed in as arguments, having no knowledge
    of the widgets this data came from
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Second, it merely emits a Qt signal when an error is encountered, rather than
    taking any GUI-specific actions
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, let''s create our `View` class:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This class contains the same fields and field layout definitions as before.
    This time, however, rather than calling `save()`, our Save button is connected
    to a `submit()` callback that gathers the form data and emits it using a signal.
    We've also added a `show_error()` method that will display errors.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: 'In our `MainWindow.__init__()` method, we''ll bring the model and view together:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, we create an instance of the `View` class and the `Model` class and connect
    their signals and slots.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, the model-view version of our code works identically to our
    original version, but with more code involved. You might well ask, what''s the
    point? If this application was destined never to be more than it is, there might
    not be a point. However, applications tend to expand in functionality and, often,
    other applications need to reuse the same code. Consider these scenarios:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: You want to provide an alternative editing form, perhaps console-based or with
    more editing features
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You want to provide the option of saving to a database instead of a text file
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You're creating another application that also saves text content to files
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In each of these situations, using the model-view pattern means that we don't
    have to start from scratch. In the first case, for example, we don't need to rewrite
    any file-saving code; we just need to create the user-facing code that emits the
    same `submitted` signal. As your code expands and your applications become more
    complex, this separation of concerns will help you maintain order.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Models and views in PyQt
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The model-view pattern is not only useful in the design of large applications,
    but also on a smaller scale with widgets that contain data. Copy the application
    template from [Chapter 4](9281bd2a-64a1-4128-92b0-e4871b79c040.xhtml), *Building
    Applications with QMainWindow*, and let's look at a simple example of how model-view
    works on the widget level.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `MainWindow` class, create a list of items and add them to both the 
    `QListWidget` and `QComboBox` objects:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Because both widgets were initialized with the same list, both contain the
    same items. Now, let''s make the list widget items editable:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: By iterating through the items in the list widget and setting the `Qt.ItemIsEditable`
    flag on each one, the widget becomes editable and we can alter the text of the
    items. Run the application and try editing the items in the list widget. Even
    though you've altered the items in the list widget, the combobox items remain
    unchanged. Each widget has its own internal list model, which stores a copy of
    the items that were originally passed in. Altering the items in one copy of the
    list has no effect on the other copy.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: How might we keep these two lists in sync? We could connect some signals and
    slots or add class methods to do it, but Qt provides a better way.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '`QListWidget` is actually a combination of two other Qt classes: `QListView`
    and `QStringListModel`. As the names imply, these are model-view classes. We can
    use those classes directly to build our own list widget with a discrete model
    and view:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We simply create our model class, initializing it with our list of strings,
    then create the view class. Finally, we connect the two using the view's `setModel()`
    method.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '`QComboBox` doesn''t have analogous model-view classes, but is nonetheless
    internally a model-view widget and has the capability to use an external model.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we can pass our `QStringListModel` to it using `setModel()`:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Add those widgets to your layout and try running the program again. This time,
    you'll see that edits to `QListView` are immediately available in the combobox,
    because the changes you are making are being written to the `QStringModel` object,
    which both widgets consult for item data.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '`QTableWidget` and `QTreeWidget` also have analogous view classes: `QTableView`
    and `QTreeView`. However, there are no ready-made model classes that we can use
    with these views. Instead, we have to create our own custom model classes by subclassing
    `QAbstractTableModel` and `QAbstractTreeModel`, respectively.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we'll go through how to create and use a custom model class
    by building our own CSV editor.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: Building a CSV editor
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **comma-separated values** (**CSV**) is a plain-text format for storing
    tabular data. Any spreadsheet program can export to CSV, or you can make your
    own by hand in a text editor. Our program will be designed in such a way that
    it will open any arbitrary CSV file and display the data in  `QTableView`. It
    is common to use the first row of a CSV to hold column headers, so our application
    will assume this and make that row immutable.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: Creating a table model
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When developing a data-driven model-view application, the model is usually the
    best place to begin as this is where the most complex code will be found. Once
    we've put this backend in place, implementing the frontend is fairly trivial.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we need to design a model that can read and write CSV data. Copy
    the application template from [Chapter 4](9281bd2a-64a1-4128-92b0-e4871b79c040.xhtml),
    *Building Applications* *with* *QMainWindow*, and add an import at the top for
    the Python `csv` library.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s start building our model by subclassing `QAbstractTableModel`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Our model will take the name of a CSV file as an argument, and will immediately
    open the file and read it into memory (not a great strategy for large files, but
    this is only an example program). We'll assume the first row is a header row,
    and retrieve it using the `next()` function before pulling the rest of the rows
    into the model's `_data` property.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: Implementing read capabilities
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create instances of our model to display data in a view, we need to implement
    three methods:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '`rowCount()`, which must return the total number of rows in the table'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`columnCount()`, which must return the total number of columns in the table'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`data()`, which is used to request data from the model'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rowCount()` and `columnCount()` are easy enough in this case:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The row count is just the length of the `_data` property, and the column count
    can be had by taking the length of the `_headers` property. Both functions are
    required to take a `parent` argument, but in this case, it is not used as it refers
    to the parent node, which is applicable only in hierarchical data.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: 'The last required method is `data()`, which requires more explanation; `data()`
    looks like this:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The purpose of `data()` is to return the data in a single cell of the table
    given the arguments `index` and `role`. Now, `index` is an instance of the `QModelIndex`
    class, which describes the location of a single node in a list, table, or tree
    structure. Every `QModelIndex` contains the following properties:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: A `row` number
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `column` number
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `parent` model index
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the case of a table model such as ours, we are interested in the `row` and
    `column` properties, which indicate the table row and column of the data cell
    we want. If we were dealing with hierarchical data, we'd also want the `parent`
    property, which would be the index of the parent node. If this were a list, we'd
    only care about `row`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '`role` is a constant from the `QtCore.Qt.ItemDataRole` enum. When a view requests
    data from a model, it passes a `role` value so that the model can return the data
    or metadata appropriate to the context for which it is being requested. For example,
    if the view makes a request using the `EditRole` role, the model should return
    data suitable for editing. If the view requests with the `DecorationRole` role,
    the model should return an icon appropriate to the cell.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: If there is no data to be returned for a particular role, `data()` should return
    nothing.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we're only interested in displaying the data, which is represented
    by the `DisplayRole` role. To actually return the data, we need to get the index's
    row and column and use that to pull the appropriate row and column from our CSV
    data.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we have a minimally functional, read-only CSV model, but there
    is more we can add.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: Adding headers and sorting
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Being able to return the data is only one piece of a model's functionality.
    Models also need to be able to provide other information, such as the names of
    the column headers or the appropriate method for sorting the data.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement header data in our model, we need to create a `headerData()` method:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`headerData()` returns data on a single header given three pieces of information—the
    **section**, **orientation**, and **role**.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: Headers can be either vertical or horizontal as determined by the orientation
    argument, which is specified as either the `QtCore.Qt.Horizontal` or `QtCore.Qt.Vertical`
    constant.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: The section is an integer that indicates either the column number (for horizontal
    headers) or row number (for vertical headers).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: The role argument, as in the `data()` method, indicates the context for which
    the data needs to be returned.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: In our case, we're only interested in showing horizontal headers for the `DisplayRole`
    role. Unlike the `data()` method, the parent class method has some default logic
    and return values, so in any other case, we want to return the result of `super().headerData()`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to be able to sort our data, we need to implement a `sort()` method,
    which will look like this:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`sort()` takes a `column` number and `order`, which is either `QtCore.Qt.DescendingOrder`
    or `QtCore.Qt.AscendingOrder`, and the aim of this method is to sort the data
    accordingly. In this case, we''re using Python''s `list.sort()` method to sort
    our data in place, using the `column` argument to determine which column of each
    row will be returned for sorting. If descending order is requested, we''ll use
    `reverse()` to change the ordering accordingly.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '`sort()` must also emit two signals:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '`layoutAboutToBeChanged` must be emitted before any sorting happens internally.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`layoutChanged` must be emitted after the sorting is finished.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These two signals are used by the views to redraw themselves appropriately,
    so it is important to remember to emit them.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: Implementing write capabilities
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our model is read-only at this point, but because we''re implementing a CSV
    editor, we need to implement writing data. To begin with, we need to override
    some methods to enable editing of existing data rows: `flags()` and `setData()`.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '`flags()` takes a `QModelIndex` value and returns a set of `QtCore.Qt.ItemFlag`
    constants for the item at the given index. These flags are used to indicate whether
    the item can be selected, dragged, dropped, checked, or—most interesting to us—edited.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: 'Our method looks like this:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here we're adding the `ItemIsEditable` flag to the list of flags returned by
    the parent class's `flags()` method, indicating that the item is editable. If
    we wanted to implement logic to make only certain cells editable under certain
    conditions, we could do that in this method.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if we had a list of read-only indexes stored in `self.readonly_indexes`
    , we could write this method as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: For our application, though, we want every cell to be editable.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that all items in the model are marked as editable, we need to tell our
    model how to actually edit them. This is defined in the `setData()` method:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `setData()` method takes the index of the item to be set, the value to set
    it to, and an item role. This method must take on the task of setting the data
    and then return a Boolean value indicating whether or not the data were successfully
    changed. We only want to do this if the index is valid and the role is `EditRole`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: 'If the data are changed, `setData()` must also emit the `dataChanged` signal.
    This signal is emitted whenever an item or group of items is updated with regard
    to any role, and so carries with it three pieces of information: the top-leftmost
    index that was changed, the bottom-rightmost index that was changed, and a list
    of the roles for each index. In our case, we''re only changing one cell so we
    can pass our index for both ends of the cell range, and a list with a single role
    in it.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s one more small change to the `data()` method that isn''t required
    but will make things easier for the user. Go back and edit the method as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: When a table cell is selected for editing, `data()` will be called with the
    `EditRole` role. Before this change, `data()` would return `None` when called
    with that role and, as a result, the data in the cell will disappear as soon as
    the cell is selected. By returning the data for `EditRole` as well, the user will
    have access to the existing data for editing.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: 'We have now implemented the editing of existing cells, but to make our model
    completely editable we need to implement the insertion and removal of rows. We
    can do this by overriding two more methods: `insertRows()` and `removeRows()`.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: 'The `insertRows()` method looks like this:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The method takes the *position* where the insertion starts, the number of *rows*
    to be inserted, and the parent node index (used with hierarchical data).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the method, we must put our logic between calls to `beginInsertRows()`
    and `endInsertRows()`. The `beginInsertRows()` method prepares the underlying
    object for modification, and requires three arguments:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: The `ModelIndex` object of the parent node, which is an empty `QModelIndex`
    for tabular data
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The position where row insertion will start
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The position where row insertion will end
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can calculate all this from the start position and the number of rows passed
    into the method. Once we've taken care of that, we can generate a number of rows
    (in the form of lists of empty strings the same length as our header list) and
    insert them into `self._data` at the proper index.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: After the rows are inserted, we call `endInsertRows()`, which takes no arguments.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: 'The `removeRows()` method is very similar:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Once again, we need to call `beginRemoveRows()` before editing the data and
    `endRemoveRows()` after editing, just as we did for insertion. If we wanted to
    allow editing of the column structure, we could override the `insertColumns()`
    and `removeColumns()` methods, which work essentially the same way as the row
    methods. For now, we'll just stick to row editing.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, our model is fully editable, but we''ll add one more method
    that we can call to flush the data to disk, as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This method simply opens our file and writes in the headers and all data rows
    using the Python `csv` library.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: Using the model in a view
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that our model is ready to use, let's flesh out the rest of the application
    to demonstrate how to use it.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin with, we need to create a `QTableView` widget and add it to our `MainWindow`
    :'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As you can see, we don't have to do much to make the `QTableView` widget work
    with the model. Because we implemented `sort()` in the model, we'll enable sorting,
    but otherwise, it doesn't require much configuration.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, to see any data, we need to assign a model to the view; and in order
    to create a model, we need a file. Let''s create a callback to get one:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Our method uses a `QFileDialog` class to query the user for a CSV file to open.
    If one is chosen, it uses the CSV file to create an instance of our model class.
    The model class is then assigned to the view using the `setModel()` accessor method.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: 'Back in `MainWindow.__init__()`, let''s create a main menu for the application
    and add an `''Open''` action:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: If you run the script now, you should be able to open a file by going to File | Open
    and selecting a valid CSV. You should be able to view and even edit the data,
    and the data should sort by column if you click a header cell.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s add the user interface components that will allow us to save our
    file. To begin, create a menu item that calls a `MainWindow` method called `save_file()`:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, let''s create our `save_file()` method to actually save the file:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: To save the file, all we really need to do is call the model's `save_data()`
    method. However, we can't connect our menu item directly to that method, because
    the model doesn't exist until a file is actually loaded. This wrapper method allows
    us to create a menu option without a model.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: 'The last piece of functionality we want to connect is the ability to insert
    and remove rows. In a spreadsheet, it is often useful to be able to insert rows
    either above or below the selected row. So, let''s create callbacks in `MainWindow`
    that do just that:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In both methods, we're getting a list of the selected cells by calling the table
    view's `selectedIndexes()` method. These lists are sorted from upper-leftmost
    cells to lower-rightmost cells. So, for inserting above, we retrieve the row of
    the first index in the list (or 0 if the list is empty). For inserting below,
    we retrieve the row of the last index in the list (or the last index in the table
    if the list is empty). Finally, in both methods, we use the model's `insertRows()`
    method to insert one row to the appropriate location.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: 'Removing rows is similar, as shown here:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This time we only act if there is an active selection, and use the model's `removeRows()`
    method to remove the first selected row.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: 'To make these callbacks available to the user, let''s add an `''Edit''` menu
    back in `MainWindow` :'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: At this point, try loading up a CSV file. You should be able to insert and remove
    rows in your table, edit fields, and save the result. Congratulations, you've
    created a CSV editor!
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about model-view programming. You learned about
    using models with regular widgets and about the special model-view classes in
    Qt. You created a custom table model and rapidly built a CSV editor by exploiting
    the power of model-view classes.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: We will learn more advanced model-view concepts, including delegates and data
    mapping in [Chapter 9](af85c1e5-39e9-47fd-a999-16f2728fe464.xhtml), *Exploring
    SQL with QtSQL*.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you'll learn about styling your PyQt applications. We'll
    dress up our drab forms with images, dynamic icons, fancy fonts, and colors, and
    we'll learn multiple approaches for controlling the overall look and feel of your
    Qt GUIs.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Try these questions to test your knowledge from this chapter:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: Assuming we have a well-designed model-view application, is the following code
    part of a model or a view?
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Can you name at least two things that a model should never do and two things
    that a view should never do?
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`QAbstractTableModel` and `QAbstractTreeModel` both have *Abstract* in the
    name. What does *Abstract* mean in this context? Does it mean something different
    in C++ from what it means in Python?'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Which model type—list, table, or tree—would best suit the following collections
    of data:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The user's recent files
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Windows registry hive
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linux `syslog` records
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Blog entries
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Personal salutations (for example, Mr., Mrs., or Dr.)
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Distributed version control history
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why is the following code failing?
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Your table model isn't working quite right when inserting columns. What is wrong
    with your `insertColumns()` method?
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: You would like your views to display the item data as a tooltip when hovered.
    How would you accomplish this?
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You might want to check out the following resources:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: The Qt documentation on model-view programming at [https://doc.qt.io/qt-5/model-view-programming.html](https://doc.qt.io/qt-5/model-view-programming.html)
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Martin Fowler presents an overview of **Model View Controller** (**MVC**) and
    related patterns at [https://martinfowler.com/eaaDev/uiArchs.html](https://martinfowler.com/eaaDev/uiArchs.html)
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 马丁·福勒在[https://martinfowler.com/eaaDev/uiArchs.html](https://martinfowler.com/eaaDev/uiArchs.html)上介绍了**模型-视图-控制器**（**MVC**）及相关模式的概述。
