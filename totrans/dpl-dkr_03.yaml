- en: Service Decomposition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will cover how to take the knowledge from the previous chapter
    and use it to create and build an addition of a database and an application server
    container, since real-world services are usually composed in such a way. Once
    we get them all built up, we will see what is needed in order to group them together
    into a more usable service and cover even of more Docker under the hood.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: A quick review of Docker commands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Writing a real service with:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A web server service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An application service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing volumes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security considerations for credential passing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A quick review
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we start, let's review the Docker and Dockerfile commands we covered
    previously in a single section in two lists that you can use as a reference later.
  prefs: []
  type: TYPE_NORMAL
- en: Docker commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are all of the commands we covered for Docker with a few others added,
    which you might use if you build containers frequently:'
  prefs: []
  type: TYPE_NORMAL
- en: For more in-depth information about parameters required for each, or to see
    commands that we have not covered yet, type `docker help` in the Terminal or the
    command by itself into the Terminal. You can also visit [https://docs.docker.com/](https://docs.docker.com/)
    and explore the documentation if the information provided by the CLI output is
    not good enough, and it may contain more recent data.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Recently, Docker commands have begun to be isolated into their own docker CLI
    sections like `docker container`, to separate them from other cluster management
    commands. To use this newer syntax, just prepend any command with the container
    (that is, `docker stop` turns into `docker container stop`). You can feel free
    to use either version, though keep an eye out as you can probably expect the older
    style to be deprecated at some point even though the new style is overly verbose
    for most Docker usage.
  prefs: []
  type: TYPE_NORMAL
- en: Dockerfile commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following list is a similar one, but this time, we are covering the commands
    you can use in a Dockerfile, and we''ve arranged it in an order similar to the
    one you would use when working within the Dockerfile:'
  prefs: []
  type: TYPE_NORMAL
- en: '`FROM <image_name>[:<tag>]`: Base the current image on `<image_name>`'
  prefs: []
  type: TYPE_NORMAL
- en: '`LABEL <key>=<value> [<key>=value>...]`: Add metadata to the image'
  prefs: []
  type: TYPE_NORMAL
- en: '`EXPOSE <port>`: Indicate which port should be mapped into the container'
  prefs: []
  type: TYPE_NORMAL
- en: '`WORKDIR <path>`: Set the current directory for the following commands'
  prefs: []
  type: TYPE_NORMAL
- en: '`RUN <command> [ && <command>... ]`: Execute one or more shell commands'
  prefs: []
  type: TYPE_NORMAL
- en: '`ENV <name>=<value>`: Set an environment variable to a specific value'
  prefs: []
  type: TYPE_NORMAL
- en: '`VOLUME <path>`: Indicates that the <path> should be externally mounted volume'
  prefs: []
  type: TYPE_NORMAL
- en: '`COPY <src> <dest>`: Copy a local file, a group of files, or a folder into
    the container'
  prefs: []
  type: TYPE_NORMAL
- en: '`ADD <src> <dest>`: The same as `COPY` but can handle URIs and local archives'
  prefs: []
  type: TYPE_NORMAL
- en: '`USER <user | uid>`: Set the runtime context to `<user>` or `<uid>` for commands
    after this one'
  prefs: []
  type: TYPE_NORMAL
- en: '`CMD ["<path>", "<arg1>", ...]`: Define the command to run when the container
    is started'
  prefs: []
  type: TYPE_NORMAL
- en: Since almost all containers you would want to build can be constructed with
    this set, this list is not the whole superset of Docker commands, and a few of
    them have been intentionally left out. If you get curious about things such as `ENTRYPOINT`,
    `ARG`, `HEALTHCHECK`, or others, you can check out the complete documentation
    at [https://docs.docker.com/engine/reference/builder/](https://docs.docker.com/engine/reference/builder/).
  prefs: []
  type: TYPE_NORMAL
- en: Writing a real service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have spent time making fake or mock container services that helped
    us build Docker skills, but we have not had a chance to work on something that
    resembles a real-world service. In general, most of the simpler services that
    get utilized out there will look something similar to what is shown in this high-level
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/477adec9-c7a3-429e-b279-f035913c506d.png)'
  prefs: []
  type: TYPE_IMG
- en: An overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here we will discuss each service in detail.
  prefs: []
  type: TYPE_NORMAL
- en: '**Web servers**:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The rightmost piece in the image we just looked at is a web server. Web servers
    act as high-speed HTTP request processing handlers and are generally used in this
    context as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Reverse-proxy endpoints for resources within the clusters, **Virtual Private
    Cloud** (**VPC**), and/or **Virtual Private Network** (**VPN**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hardened gatekeepers to limit resource access and/or prevent abuse
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analytics collection points
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Load balancers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Static content delivery servers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reducers of application server logic utilization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SSL termination endpoints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Caches of remote data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data diodes (allow either ingress or egress of data but not both)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Local or federated account AAA handlers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This particular piece of our imaginary service is not always strictly required
    if the need for security is extremely low, the services are internal, and processing
    power is abundant, but in almost all other cases where any of these conditions
    are not present, the addition of a web server is practically mandatory. A good
    analogy to a web server is your home router. While it is not strictly necessary
    for you to use the Internet, a dedicated router enables better sharing of your
    network and serves as a dedicated security appliance between you and the Internet.
    While we have spent much of the previous chapter using NGINX, many others can
    be used (Apache, Microsoft IIS, lighttpd, and so on) and are generally functionally
    interchangeable, but beware of significantly different configuration setups.
  prefs: []
  type: TYPE_NORMAL
- en: '**Application servers**:'
  prefs: []
  type: TYPE_NORMAL
- en: 'So if the web server is doing all this for us, what does the application server
    do? The application server is actually your main service logic, generally wrapped
    up in some web-accessible endpoints or a queue-consuming daemon. This piece could
    be used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The main website framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data manipulation API logic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some sort of data transformation layer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data aggregation framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The main distinction between an application server versus a web server is that
    the web server generally operates on static data and makes generally rigid decisions
    in a flow, while the application server does almost all of the dynamic data processing
    in a non-linear fashion. Things that fall under this category are generally frameworks
    such as Node.js, Ruby on Rails, JBoss, Tornado, and others for running specific
    programming language applications which can process requests. Try not to think
    of needing a big framework as a requirement here since even the right Bash script
    or a C file could do the job just as well and still qualify as an application
    server.
  prefs: []
  type: TYPE_NORMAL
- en: The reason why we defer as much of the work as we can to the web server instead
    of the application server is that due to the framework overhead, an application
    server is generally extremely slow and thus unsuitable to do simple, small, and
    repetitive tasks that a web server could chew through without breaking a sweat.
    For reference, an average specialized web server will be about an order of magnitude
    more efficient at serving up static pages than a full blown application server
    and, by inference, that much faster than most application servers. As mentioned
    earlier, you can probably handle low loads on an application server on its own
    or with some tuning medium ones, but anything above that is something that deserves
    a dedicated reverse proxy.
  prefs: []
  type: TYPE_NORMAL
- en: '**The database**: Once we have this logic and static file processing down,
    they are sadly mostly useless without the actual data to transform and pass around.
    As with any software that uses data, this is done with a backing database. Since
    we want to be able to scale any piece of the system and isolate discrete components,
    the database gets its own section. In the pre-container world, though, we were
    dependent on big, monolithic databases that provided us with **Atomicity**, **Consistency**,
    **Isolation**, **and Durability** (**ACID**) properties, and they did their job
    well. However, in the container world, we absolutely do not want this type of
    architecture as it is neither as resilient nor as horizontally scalable as databases
    that are shardable and able to be clustered.'
  prefs: []
  type: TYPE_NORMAL
- en: With these new-style databases, though, you generally do not get the same assurance
    that your data is treated in the same manner as the old-style ones, and it is
    an important distinction to have. What you get with most container-friendly databases
    instead of ACID is **Basically Available**, **Soft state**, **Eventual consistency** (**BASE)**,which
    pretty much means that data will eventually be correct, but between the update
    initially being sent and the final state, the data may be in various states of
    intermediate values.
  prefs: []
  type: TYPE_NORMAL
- en: What we are going to build
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We want to make a service that will be able to serve as a good example but
    not be too complicated, to show what a real-word example of a service might probably
    look like. For this use case, we will make a container grouping that can do two
    things behind basic HTTP authentication:'
  prefs: []
  type: TYPE_NORMAL
- en: Save a string entered in a form on the landing page to a database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we land on the homepage, show the list of all strings saved so far.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here, we will try to cover as many things as we can while also building a generally
    realistic prototype of a container-backed web service. Keep in mind that with
    the available tooling, even making a service as simple as this is not very easy
    so we will attempt to reduce the complexity where we can though the difficulty
    of our content does ramp up from here.
  prefs: []
  type: TYPE_NORMAL
- en: The implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we covered the three major pieces that we need in general service architectures
    already, we will split our project into the same discrete parts with a web server,
    application server, and a database container, and we will outline the steps needed
    to build them here. As mentioned earlier, you can use Git to check out all of
    the code easily from GitHub at [https://github.com/sgnn7/deploying_with_docker](https://github.com/sgnn7/deploying_with_docker)
    if you do not want to retype the code from these examples.
  prefs: []
  type: TYPE_NORMAL
- en: Web server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can choose any web server software here, but since we have already worked
    with NGINX earlier, it makes sense that we would try to reuse bits and pieces
    of this component--it is practically what the container architecture is all about!
    The web server component will provide some basic authentication, cache data, and
    act as a reverse-proxy for the application server behind it. Our basic setup that
    we worked on earlier can be used here, but we will modify it a bit so that instead
    of serving files directly, it acts as a proxy and then use authentication based
    on a credentials file we will create in our `Dockerfile`. Let''s create a new
    folder named `web_server` and add these files to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '`nginx_main_site.conf`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: There are three interesting parts about this configuration here. The first one
    is the inclusion of `auth_basic_` commands that enable HTTP Basic authentication
    on all endpoints provided by this configuration. The second, if you were observant
    enough of the new `.`-prefixed credentials file, is the fact that our denial of
    fetching all files starting with a `.` is needed now since we added `.htpasswd`.
    The third and the final interesting thing here is the use of `proxy_pass`, which
    allows the server to route all traffic that is authenticated to the backend application
    server. Why we use `http://172.17.0.1:8000` as the destination is beginning to
    open the proverbial Pandora's box of Docker networking, so we will explain why
    we used it later as we will derail our service building if we cover it now.
  prefs: []
  type: TYPE_NORMAL
- en: Warning! In most cases, using basic authentication is a practical joke of security
    without HTTPS as we use it here since anyone on the network can sniff out your
    credentials in plaintext with the simplest of tools. In your services, at the
    very least, mandate the HTTPS protocol is you use basic auth or rely on stronger
    forms of credentials-passing before deploying services to anything with direct
    Internet access.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now add our new `Dockerfile` in that same directory, which will look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we''ve made a couple of changes here from our original work
    in the previous chapter. The initial thing that should stick out is the new way
    to write the `RUN apt-get` line, which we''ve annotated here briefly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Unlike in previous images, here, we install the `openssl` package since we will
    need it to create NGINX-encrypted passwords for authentication, but the `clean`
    and `autoclean`  lines are here to make sure we remove any cached `apt` packages
    on the system and remove orphaned packages, giving us a smaller image which is
    something we should always strive for. Just like before, we combine all of the
    lines in a similar manner early on so that the filesystem difference between the
    previous and current layer will only be the required changes and nothing else,
    making it a very compact change. When writing your own images, if you find yourself
    needing even more fat trimming, many more things can be removed (such as removing
    documentation files, `/var` directories, unnecessary optional packages, and so
    on), but these two should be the ones to use in most cases as they're simple to
    do and work pretty well on Debian-based systems.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Without proper authentication, our server is wide open to anyone accessing
    it so we add a username/password combo to act as a gatekeeper to our service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '`ARG` acts as a build-time substitute for an `ENV` directive and allows the
    password to be passed in as a build argument with `--build-arg <arg>`. If the
    build is not provided with one, it should default to the argument after the equals
    sign, which is a very insecure `test` in this case. We will use this variable
    a bit lower in the `Dockerfile` to create the `.htpasswd` file with a specific
    password for our user.'
  prefs: []
  type: TYPE_NORMAL
- en: The second line uses `openssl`, which we installed earlier, to take this build
    arg and create the `.htpasswd` file with encrypted credentials in a format that
    NGINX and most other web servers can understand (`<username>:<hashed_password>`).
  prefs: []
  type: TYPE_NORMAL
- en: Warning! Keep in mind that the  `-1` algorithm is less secure than the **Salted
    SHA** (SSHA) method of creating `.htpasswd` passwords, but to create them in this
    way would have involved more complicated commands that would have distracted from
    our main purpose here, but you can visit [https://nginx.org/en/docs/http/ngx_http_auth_basic_module.html#auth_basic_user_file](https://nginx.org/en/docs/http/ngx_http_auth_basic_module.html#auth_basic_user_file)
    for more details. Also be aware that you should never use online password generators
    as they can (and often do) steal your entered information.
  prefs: []
  type: TYPE_NORMAL
- en: If you haven't worked with Bash sub-shells before, `$(openssl ...)` is run in
    a separate shell and the output is substituted as a string variable before the
    rest is evaluated so the `>>` append operation will only see the encrypted password
    after `username:` and nothing related to `openssl`. As it should be somewhat apparent
    from these things, if we don't provide any build arguments, the container will
    have a single username `user` with a password set to `test`.
  prefs: []
  type: TYPE_NORMAL
- en: Warning! This type of credential passing to the image is used here as an example
    and is very nonsecure since anyone can run `docker history` and see what this
    variable was set to or start the image and echo the `PASSWORD` variable. In general,
    preferred ways of passing this type of sensitive data are through environment
    variables when you launch the container, mounting the credentials file as a volume
    onto the container, using `docker secret`, or an external credentials sharing
    service. We may cover some of these in later chapters, but for now, you should
    just keep in mind not to use this particular way of passing credentials in production
    due to security concerns.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the `web_server` piece finished up, we can move to the next piece: the
    database.'
  prefs: []
  type: TYPE_NORMAL
- en: The database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While SQL databases have come a long way in their ability to be sharded and
    clustered and generally provide good performance, many of cluster-friendly solutions
    have been based on NoSQL and in most cases use a key/value storage; plus, they
    have been gaining ground versus the entrenched SQL players in the ecosystem with
    each passing year. To get our feet wet quickest and with least amount of effort,
    we'll choose MongoDB here, which is a breeze to get working, and because it is
    NoSQL, we don't have to set up any kind of schema either, massively reducing our
    need for tricky configurations!
  prefs: []
  type: TYPE_NORMAL
- en: Warning! The default setup for MongoDB is very easy to do, but it does not enable
    any security by default, so anyone with network access to that container can read
    and write data to any database. In a private cloud, this might be somewhat acceptable,
    but in any other situation, it is not something that should be done, so keep in
    mind that if you plan on deploying MongoDB and make sure it is set up at least
    with some sort of isolation and/or authentication.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our whole setup for the database here will be really simple, and if we didn''t
    need to harden it with package updates, we wouldn''t even have a custom one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The only thing we should consider when we run it is to make sure that the database
    storage volume from the container (`/var/lib/mongodb`) is mounted from the host
    into the container so that we preserve it if the container stops, but we can worry
    about that once we start launching the container group.
  prefs: []
  type: TYPE_NORMAL
- en: The application server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this component, we will pick a framework with a minimal amount of boilerplate
    needed to get a service up and operational, which most people would say today
    is Node.js with Express. Since Node.js is based on JavaScript, which was originally
    based on a Java-like syntax, most people who worked on HTML should be able to
    figure out what the application code is be doing, but before we get there, we
    need to define our Node package and our dependencies, so create a new `application_server`
    directory on the same level as `web_server` and add the following to a file called
    `package.json`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: There's nothing really magical here; we're just using a Node package definition
    file to declare that we need Express as a dependency and that our `npm start`
    command should run `node index.js`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s also make our Dockerfile now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Many of these things should be very familiar here, especially with people familiar
    with Node. We are starting with the `node:8` image, adding our application code,
    installing the dependencies we defined in `package.json` (with `npm install`),
    and then finally making sure that the app starts when run from the `docker` CLI.
  prefs: []
  type: TYPE_NORMAL
- en: The order here is pretty important to both avoid cache breaking and ensure proper
    permissions. We place things that we don't expect to change much (`USER`, `WORKDIR`,
    `EXPOSE`, `mkdir`, and `chown`) above `COPY` since they are much less likely to
    change as opposed to the application code and since they're mostly interchangeable,
    we arrange them in the ascending order of what we think are the least likely to
    change in the future in order to prevent rebuilding of layers and wasted computing
    power.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is also a Node.js-specific image optimization trick: since `npm install`
    is usually the most time and CPU intensive part of dealing with code changes to
    a Node application, you can even further optimize this Dockerfile by copying only `package.json`,
    running `npm install`, and then copying the rest of the files to the container.
    Creating the container in this manner will only do the pricey `npm install` if
    `package.json` changes and will generally improve build times by a large margin,
    but this was excluded from this example in order to not derail our main conversation
    with framework-specific optimizations.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, we haven''t really defined any application code, so let''s see what
    that looks like too. First, we need an HTML view to be our landing page, and we
    can throw one together pretty quickly using a `pug` (formerly also known as `jade`)
    template. Create a `views/` folder and put this in a file named `index.pug` located
    in that folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: You don't have to know much about this templating style except that it is a
    simple HTML page on which we will display all items from the `words` array passed
    into it during rendering, and if a new word is put in, there will be a form submitted
    as a `POST` request to the `/new` endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: The main application logic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is no easy way around this, but our main application logic file, `index.js`,
    won''t be as simple as the other configuration files have been:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This file may seem daunting at first, but this is possibly the smallest API
    service that you can make from scratch that is also fully functional.
  prefs: []
  type: TYPE_NORMAL
- en: If you would like to learn more about either Node, Express, or the MongoDB driver,
    you can visit [https://nodejs.org/en/](https://nodejs.org/en/), [https://expressjs.com/](https://expressjs.com/),
    and [https://github.com/mongodb/node-mongodb-native](https://github.com/mongodb/node-mongodb-native).
    If you don't feel like typing, you can also copy and paste this file from [https://github.com/sgnn7/deploying_with_docker/](https://github.com/sgnn7/deploying_with_docker/).
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic operation of this app is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Load any existing words from the `MongoDB` database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keep a copy of that list in a variable so that we only need to fetch things
    from the database once
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Open a port `8000` and listen for requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we receive a `GET` request on `/`, return the rendered `index.html` template
    and fill it in with the word list array
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If we receive a `POST` to `/new`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Save the value in the database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Update our word list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Send us back to `/`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'One part here, however, needs special attention:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Remember when we previously mentioned that much of image configuration should
    be done through environment variables before? That is exactly what we are doing
    here! If an environment variable `DB_HOST` is set (as we expect it to be when
    running as a container), we will use it as the hostname, but if none is provided
    (as we expect it when running locally), it will assume that the database is running
    locally on the standard MongoDB port. This provides the flexibility of being configurable
    as a container and being able to be tested locally by a developer outside of Docker.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the main logic file in place, our service should now be arranged in a
    similar filesystem layout as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Since this is really the only easy part to test out of the three, let''s install
    MongoDB locally and see what the service does. You can visit [https://docs.mongodb.com/manual/installation/](https://docs.mongodb.com/manual/installation/)
    for information on how to install it for other platforms, but I''ve included the
    following steps to do this manually on Ubuntu 16.04:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'It seems to work: let''s check out the browser by going to `http://localhost:8000`!'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/9debc5f4-6e14-45e0-8d78-60ed42593f44.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s put a few words in it and see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/51dc3024-b575-40c0-89c7-9bde31bd511f.png)'
  prefs: []
  type: TYPE_IMG
- en: So far, so good! The final test is restarting the service and making sure that
    we see the same list. Press *Ctrl* + *C* out of our Node process and run `npm
    start`. You should see the same list again, which means that it is working as
    expected!
  prefs: []
  type: TYPE_NORMAL
- en: Running it all together
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So, we have our `web_server`, `application_server`, and `database` containers
    all figured out. Let''s verify that you have all the files matching these before
    moving on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step for us is to build all the containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This sequential building is great for showing what needs to be done in each
    step, but always think about automation and how manual processes can be improved.
    In this particular case, this whole block of statements and execution could have
    also been done from the parent directory with this single line: `for dir in *;
    do cd $dir; docker build -t $dir .; cd ..; done`'
  prefs: []
  type: TYPE_NORMAL
- en: Launching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With the three relevant containers made, we can now launch them. Some care
    needs to be taken that they are launched in order as our application tries to
    read the data from the database as soon as it is started and we don''t want the
    web server up if the application isn''t there, so we will launch them in this
    order: `database -> application_server -> web_server`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'A few things to note here:'
  prefs: []
  type: TYPE_NORMAL
- en: We mapped local port `27000` to database `27017` intentionally so that we wouldn't
    have the conflict with the MongoDB database already running on the host.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We passed in the magic `172.17.0.1` IP as the host and port `27000` to our application
    server to use as the database host.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We started the web server on port `8080` instead of `80` for the web server
    in order to make sure that we don't need root permissions*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you do not see three containers running, check the logs with `docker logs
    <container id>`. The most likely culprit will probably be the mismatch between
    the IP/port on a container and the destination, so just fix and restart the container
    that is failing until you have all three running. If you have a lot of problems,
    do not hesitate to start the containers in the non-daemon mode by removing the
    `-d` flag from the commands we used.* - On *nix systems, ports below `1024` are
    called registered or privileged ports that govern many important aspects of communications
    for a system. To prevent malicious use of these system ports, root-level access
    is required on almost all such platforms. Since we don't really care which port
    we will be using for this testing, we will avoid this issue altogether by selecting
    port 8080.
  prefs: []
  type: TYPE_NORMAL
- en: 'The flow of information in this setup is approximated to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have all the pieces running, so let's give it a whirl at `http://localhost:8080`!
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/3b3eba36-e8bd-4025-9078-7805e300de88.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Nice; our authentication is working! Let''s put in our super-secret credentials
    (User: `user`, Password: `test`).'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/47647778-1bdf-471c-af06-81f1446c17a1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once we log in, we should be able to see our application server take the processing
    of the request over and give us the form to enter the words we want to save:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/bb732e1c-5439-45ea-9bd8-45534cfdac3c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Just as we wanted, the application server is handling requests once we authenticate!
    Enter a few words and see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/0dd93630-4a99-4c86-bcc5-bf6f42fa0c98.png)'
  prefs: []
  type: TYPE_IMG
- en: Congratulations! You have made your first containerized service!
  prefs: []
  type: TYPE_NORMAL
- en: Limitations and issues with our implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We should take a minute here to consider what parts of our service might need
    improving if you are to use it in a real system and what the most optimal/practical
    mitigations might be. As the critical part of working with containers and the
    cloud is evaluating the pros and cons of larger architectures, this is something
    you should always try to do when developing a new system or changing an existing
    one.
  prefs: []
  type: TYPE_NORMAL
- en: 'From a cursory look, these are the obvious things that could be improved, what
    the impact is, and what might be the possible mitigations:'
  prefs: []
  type: TYPE_NORMAL
- en: The database has no authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Class**: Security, very high impact'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mitigation**: Private cloud or use authentication'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Database data is stored within Docker container (data lost if the container
    is lost)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Class**: Stability, critical impact'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mitigation**: Mounted volume and/or sharding and clustering'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hardcoded endpoints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Class**: Ops, very high impact'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mitigation**: Service discovery (we will cover this in later chapters)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application server assumes it is the only one changing the word list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Class**: Scaling, very high impact'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mitigation**: Refresh data on each page load'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application server requires database on container start
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Class**: Scaling/Ops, medium impact'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mitigation**: Defer loading until the page is hit and/or show message that
    the database is not available'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Web server authentication is baked into the image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Class**: Security, critical impact'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mitigation**: Add credentials at runtime'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Web server authentication is over HTTP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Class**: Security, very high impact'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mitigation**: Use HTTPS and/or OAuth'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixing the critical issues
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since we are pretty early in our Docker journey, we will only cover a few workarounds
    for the most critical issues for now, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Database data is stored within the Docker container (data is lost if the container
    is lost).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Web server authentication is baked into the image.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a local volume
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first issue is a very serious problem because all of our data is currently
    tied to our container, so if the database app stops, you have to restart the same
    container to get your data back. In this situation, if the container is run with
    the `--rm` flag and stops or is otherwise terminated, all the data associated
    with it would disappear, which is definitively not something we want. While large-scale
    solutions for this problem are done with sharding, clustering, and/or persistent
    volumes for our level, we should be fine by just mounting the data volume where
    we want to keep our data into the container directly. This should keep the data
    on the host filesystem if anything happens to the container and can be further
    backed up or moved somewhere else if needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'This process of mounting (sometimes called mapping) a directory into the container
    is actually relatively easy to do when we start it if our volume is a named volume
    stored within Docker internals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: What this will do is create a named volume in Docker's local storage called
    `local_storage`, which will be seamlessly mounted on `/data/db` in the container
    (the place where the MongoDB image stores its data in the images from Docker Hub).
    If the container dies or anything happens to it, you can mount this volume onto
    a different container and retain the data.
  prefs: []
  type: TYPE_NORMAL
- en: '`-v` , `--volume` , and using a named volume are not the only ways to create
    volumes for Docker containers. We will cover the reasons why we use this syntax
    as opposed to other options (that is, `--mount`) in more detail in [Chapter 5](28ed4c15-7ae9-44fd-9110-2dee6672c13a.xhtml), *Keeping
    the Data Persistent,* which specifically deals with volumes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us see this in action (this may require a MongoDB client CLI on your host
    machine):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, our record persisted through the original container's destruction,
    which is exactly what we want! We will cover how to handle volumes in other ways
    in later chapters, but this should be enough to get us where we want with this
    critical issue in our little service.
  prefs: []
  type: TYPE_NORMAL
- en: Generating the credentials at runtime
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unlike the database problem, this particular issue is not as easy to deal with,
    mostly because credentials are a tough problem to deal with from a security perspective.
    If you include a build argument or a baked-in environment variable, anyone with
    access to the image can read it. Also, if you pass in the credentials through
    an environment variable during container creation, anyone that has docker CLI
    access can read it so you're mostly left with mounting of volumes with credentials
    to the container.
  prefs: []
  type: TYPE_NORMAL
- en: There are a few other ways of passing credentials securely, though they are
    a bit outside of the scope of this exercise such as env variables that contain
    hashed passwords, using a broker secrets-sharing service, using cloud-specific
    roles mechanisms (that is, AWS, IAM Role, `user-data`), and a few others, but
    the important part for this section is to understand which things you should try
    not to do when handling authentication data.
  prefs: []
  type: TYPE_NORMAL
- en: 'To work around this, we will generate our own credentials file locally on the
    host machine and mount it to the container when it starts. Substitute `user123`
    with whatever username you want and `password123` with an alphanumeric password:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: With this small change, your web server will now be secured with the new username
    and the new password and the configuration won't be available to people able to
    run docker commands either. You can access [http://127.0.0.1:8080](http://127.0.0.1:8080)
    to see that the new username and password are the only credentials that work.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Docker networking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At an earlier point, we have somewhat glanced over our use of IP `172.17.0.1`
    in the `web_server` code, and it is something that is not well covered in other
    materials, but it is a *very* important thing to understand if you want to have
    a solid grasp on Docker. When the Docker service is started on a machine, a number
    of networking `iptables` rules are added to your machine in order to allow the
    container to connect to the world through forwarding and vice versa. Effectively,
    your machine becomes an Internet router for all containers started. On top of
    this, each new container is assigned a virtual address (most likely in the range
    of `172.17.0.2`+) and any communication it does will be normally invisible to
    the other containers unless a software-defined network is created, so connecting
    multiple container on the same machine is actually a really tricky task to do
    manually without helper software that is in the Docker infrastructure called **Service
    Discovery**.
  prefs: []
  type: TYPE_NORMAL
- en: Since we didn't want the overhead of this Service Discovery for now (which we
    will cover later in more depth), and we couldn't use `localhost`/`127.0.0.1`/`::1`,
    which would not have worked at all, we needed to give it the Docker virtual router
    IP (almost always `172.17.0.1`) so that it would find our actual machine where
    other container ports have been bound.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that large parts of this next section do not work on macOS nor Windows
    machines due to the way their networking stack is implemented for Docker. For
    those systems, I would suggest that you use an Ubuntu virtual machine to follow
    along.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you would like to verify this, we can use a few commands outside and inside
    of Docker in order to really see what is happening:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this system is a bit odd, but it works pretty well. Generally
    when building bigger systems, service discovery is practically mandatory, so you
    wouldn't have to worry about such low-level details in the field.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered how to build multiple containers to make a basic
    service composed of a web server, application server, and the database, launch
    multiple containers together, and tie them together with networking. We also worked
    through what the most common issues might be when connecting services and what
    the common pitfalls with these basic building blocks are. Some hints about future
    topics were also given (volumes, service discovery, credentials passing, and so
    on), but we will cover those in later chapters in depth. In the next chapter, we
    will be turning our little service into a robust service with horizontally scaled
    components.
  prefs: []
  type: TYPE_NORMAL
