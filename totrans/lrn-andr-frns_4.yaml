- en: Chapter 4. Extracting Data Logically from Android Devices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will be covering logical data extraction by using free and open
    source tools wherever possible. The majority of the material covered in this chapter
    will use the ADB methods previously discussed in [Chapter 2](part0019.xhtml "Chapter 2. Setting
    Up an Android Forensic Environment"), *Setting Up an Android Forensic Environment*.
  prefs: []
  type: TYPE_NORMAL
- en: 'By the end of this chapter, the reader should be familiar with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: What logical extraction means
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What data to expect from logical extractions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What data is available with and without root
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manual ADB data extractions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ADB Backup extractions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ADB dumpsys information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to bypass Android lock screens
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SIM card extractions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logical extraction overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In digital forensics, the term logical extraction is typically used to refer
    to extractions that do not recover deleted data, or do not include a full bit-by-bit
    copy of the evidence. However, a more correct definition of logical extraction,
    also defined in [Chapter 1](part0014.xhtml "Chapter 1. Introducing Android Forensics"),
    *Introducing Android Forensics*, is any method that requires communication with
    the base operating system. Because of this interaction with the operating system,
    a forensic examiner cannot be sure that they have recovered all of the data possible;
    the operating system is choosing which data it allows the examiner to access.
  prefs: []
  type: TYPE_NORMAL
- en: In traditional computer forensics, logical extraction is analogous to copying
    and pasting a folder in order to extract data from a system; this process will
    only copy files that the user can access and see. If any hidden or deleted files
    are present in the folder being copied, they will not be in the pasted version
    of the folder.
  prefs: []
  type: TYPE_NORMAL
- en: As you will see, however, the line between logical and physical extractions
    in mobile forensics is somewhat blurrier than in traditional computer forensics.
    For example, deleted data can routinely be recovered from logical extractions
    on mobile devices, due to the prevalence of SQLite databases being used to store
    data. Furthermore, almost every mobile extraction will require some form of interaction
    with the Android operating system; there is no simple equivalent to pulling a
    hard drive and imaging it without booting the drive. For our purposes, we will
    define a logical extraction as the process that obtains data visible to the user,
    and may include data that has been marked for deletion.
  prefs: []
  type: TYPE_NORMAL
- en: What data can be recovered logically?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For the most part, any and all user data may be recovered logically:'
  prefs: []
  type: TYPE_NORMAL
- en: Contacts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Call logs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SMS/MMS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: System logs and information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The bulk of this data is stored in SQLite databases, so it is even possible
    to recover large amounts of deleted data through a logical extraction.
  prefs: []
  type: TYPE_NORMAL
- en: Root access
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When forensically analyzing an Android device, the limiting factor is often
    not the type of data being sought, but rather whether or not the examiner has
    the ability to access the data. Root access has been covered extensively in [Chapter
    2](part0019.xhtml "Chapter 2. Setting Up an Android Forensic Environment"), *Setting
    Up an Android Forensic Environment*, but it is important enough to warrant repetition.
    All of the data listed above, when stored on the internal flash memory, is protected
    and requires root access to read. The exception to this is application data that
    is stored on the SD card, which will be discussed later in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Without root access, a forensic examiner cannot simply copy information from
    the data partition. The examiner will have to find some method of escalating their
    privileges in order to gain access to the contacts, call logs, SMS/MMS, and application
    data. These methods often carry many risks, such as the potential to destroy or
    "brick" the device (making it unable to boot), and may alter data on the device
    in order to gain permanence. The methods commonly vary from device to device,
    and there is no universal, one-click method to gain root access to every device.
    Commercial mobile forensic tools such as **MicroSystemation XRY** and **Cellebrite
    UFED** have built-in capabilities to temporarily and safely root many devices,
    but do not cover the wide range of all Android devices.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this chapter, we will make note of situations where root is required
    for each technique demonstrated.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The decision to root a device should be made in accordance with your local operating
    procedures and court opinions in your jurisdiction. The legal acceptance of evidence
    obtained by rooting varies by jurisdiction.
  prefs: []
  type: TYPE_NORMAL
- en: Manual ADB data extraction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The ADB `pull` command can be used to pull single files or entire directories
    directly from the device on to the forensic examiner's computer. This method is
    especially useful for small, targeted examinations. For example, in an investigation
    strictly involving SMS messages, the examiner can choose to pull just the relevant
    files.
  prefs: []
  type: TYPE_NORMAL
- en: USB debugging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Setting up the ADB environment has been previously discussed in this book. However,
    the device under examination must also be configured properly. USB debugging is
    the actual method through which the examiner's computer will communicate with
    the device. The **USB debugging** option is found under the **Developer options**
    in the **Settings** menu. However, as of Android 4.2, the Developer Options menu
    is hidden; to reveal it, a user has to go to **Settings** | **About Phone**, and
    then tap the **Build Number** field *seven* times. An on-screen dialog will appear
    that says **You are now a developer!** At this point, **Developer options** is
    available in the **Settings** menu; simply open this menu and select **Enable
    USB debugging**.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to USB debugging, the correct drivers must be installed on the examiner's
    computer. Generally they can be found online, either from the manufacturer's website
    or at [www.xda-developers.com](http://www.xda-developers.com). If commercial forensic
    tools are installed on the machine, the appropriate drivers may already be installed.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another excellent resource is the Universal ADB Driver that can be downloaded
    for free at [http://drivers.softpedia.com/get/MOBILES/Clockworkmod/Clockworkmod-Universal-Android-ADB-Driver.shtml](http://drivers.softpedia.com/get/MOBILES/Clockworkmod/Clockworkmod-Universal-Android-ADB-Driver.shtml).
  prefs: []
  type: TYPE_NORMAL
- en: 'Prior to Android 4.2.2, enabling **USB debugging** was the only requirement
    to communicate with the device over ADB. In Android 4.2.2, Google added **Secure
    USB debugging** option. The **Secure USB debugging** option adds an additional
    requirement of selecting to connect to a computer on the device''s screen; this
    prevents ADB access to locked devices from untrusted computers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![USB debugging](img/image00302.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: RSA fingerprint dialog
  prefs: []
  type: TYPE_NORMAL
- en: If **Always allow from this computer** is selected, the device will store the
    computer's RSA key and the prompt will not appear on future connections to that
    computer, even if the device is locked.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It may be possible, depending on the device and OS version, to circumvent the
    **Secure USB debugging** protection. Find more information at [https://labs.mwrinfosecurity.com/advisories/2014/07/03/android-4-4-2-secure-usb-debugging-bypass/](https://labs.mwrinfosecurity.com/advisories/2014/07/03/android-4-4-2-secure-usb-debugging-bypass/).
  prefs: []
  type: TYPE_NORMAL
- en: It is also possible to bypass **Secure USB debugging** by using a computer previously
    authorized to access the device, which is discussed in the Issues with Android
    Lollipop section later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once **USB debugging** has been enabled and the **Secure USB debugging** check
    passed (depending on Android version), the device is ready for examination. To
    verify that the device is connected and ready to use ADB, execute the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If no devices are shown, ensure that **USB debugging** is enabled and that
    the proper device drivers have been installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![USB debugging](img/image00303.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'If the device status is `offline` or `unauthorized`, the **Secure USB debugging**
    prompt needs to be selected on the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![USB debugging](img/image00304.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'If everything is running correctly, the device status should show `device`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![USB debugging](img/image00305.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Using ADB shell to determine if a device is rooted
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The simplest method to determine if a device is rooted is to use the ADB shell.
    This will open a shell on the device that will be accessed on the examiner''s
    computer; this means that any commands run in the shell will be executed on the
    device. Once **USB debugging** is enabled and **Secure USB debugging** is bypassed
    (or from recovery mode, as discussed in later in this chapter), open a terminal
    on the local computer and run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The shell will appear one of two ways, either with `$` or `#`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using ADB shell to determine if a device is rooted](img/image00306.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'On Linux systems, the `#` symbol is used to indicate a root user, and the `$`
    symbol indicates a non-root user. If the shell returns showing `#`, the shell
    has root access:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using ADB shell to determine if a device is rooted](img/image00307.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'One further step may be required on some rooted devices. If the shell returns
    `$`, try running the `su` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: If the su binary is installed on the device, which is usually a part of the
    root process, this will escalate the shell's permissions to root if it did not
    open with them.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some older devices automatically ran the shell as root; simply opening the ADB
    shell may be enough to give an examiner root access.
  prefs: []
  type: TYPE_NORMAL
- en: ADB pull
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As discussed in [Chapter 2](part0019.xhtml "Chapter 2. Setting Up an Android
    Forensic Environment"), *Setting Up an Android Forensic Environment*, the ADB
    `pull` command is used to transfer files from the device to the local workstation.
    The format for the ADB `pull` command is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The optional `-p` flag shows the transfer''s progress, while the optional `-a`
    flag will copy the file''s timestamp and mode. The `<remote>` parameter is the
    exact path to the file on the device. The optional `<local>` parameter is the
    path where the file will be written on the examiner''s computer. If no local path
    is specified, the file will be written to the present working directory. To see
    what an ADB `pull` command may look like, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This command would pull the SMS database file from the device, and write it
    to a directory for the case. Again, note that the device must be rooted for this
    to work; otherwise, the output would simply show that `0` files were pulled. In
    our case, the following output is obtained:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ADB pull](img/image00308.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The preceding output shows that the file is `1020400` bytes in size. As a result
    of our command, the `mmssms.db` database now resides in the `Case_0001` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ADB pull](img/image00309.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The database pulled from the device, seen in Windows Explorer
  prefs: []
  type: TYPE_NORMAL
- en: The database can now be examined with a SQL Browser or other forensic tools,
    which will be covered in [Chapter 7](part0053.xhtml "Chapter 7. Forensic Analysis
    of Android Applications"), *Forensic Analysis of Android Applications*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, if an investigator wishes to pull the files for an entire application,
    that can be done with ADB pull also:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ADB pull](img/image00310.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'This time, the ADB pull command fetched every file in the `com.google.android.gm`
    directory, which happens to contain all of the data for Gmail. The output was
    quite long, as it individually listed all `31` pulled files, so the entire output
    is not shown in the following figure, in which we see the total size of the transfer
    is shown as `1233373` bytes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ADB pull](img/image00311.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, the `Case_0002` directory contains all of the files from the Gmail application,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ADB pull](img/image00312.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: All files pulled from the Gmail directory, seen in Windows Explorer
  prefs: []
  type: TYPE_NORMAL
- en: 'It is even possible to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This would pull every logical file available from the `/data/data` directory,
    and put them in the examiner's `Case_0003` folder. This is not equivalent to a
    physical image, as certain files are skipped and deleted files will not be copied,
    but it is a simple method for pulling the vast majority of a user's application
    data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another advantage of the ADB `pull` command is that it is highly useful for
    scripting purposes. A knowledgeable examiner can maintain a list of paths for
    common files of interest, and write a script that automatically pulls these files
    from a device, or even have the script automatically pull the entire `/data/data`
    directory. A simple example of Python code that will perform this function is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Note that code is not very refined; it's only purpose is to illustrate the ease
    with which ADB commands can be scripted. At the very least, properly implementing
    the code should include the option to specify an output directory and handle any
    errors. However, the six lines of the preceding code would be sufficient to pull
    the entire `/data/data` directory logically assuming **USB debugging** is enabled
    and the device is rooted.
  prefs: []
  type: TYPE_NORMAL
- en: Recovery mode
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to truly be forensically sound, ADB data extractions should not be
    used against a phone while it is turned on. While the device is running, timestamps
    can be modified and applications may be running and updating files in the background.
    To avoid this, an examiner should place the device into a custom recovery mode,
    as shown in [Chapter 2](part0019.xhtml "Chapter 2. Setting Up an Android Forensic
    Environment"), *Setting Up an Android Forensic Environment*, if possible. ADB
    access is not available through the stock Android recovery mode. Typically, the
    first step in the rooting process is to flash a custom recovery mode to allow
    a method for repairing the device if something goes wrong. Rooted devices are
    far more likely to contain a custom recovery, but it is possible to flash a custom
    recovery to a non-rooted device. This method also allows the examiner to avoid
    the **Secure USB debugging** prompt on newer versions of Android, although our
    testing shows that this does not work on Android Lollipop. Recovery mode also
    may not require **USB debugging** to be enabled, which makes it an excellent option
    for bypassing a locked device.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This method will not work against devices with full disk encryption enabled.
    Booting into Recovery Mode will *not* decrypt the data partition.
  prefs: []
  type: TYPE_NORMAL
- en: The process to boot into recovery mode will vary for each device. Typically,
    it involves some combination of powering the device off and holding the volume
    and power keys. Guides for specific models can be found online.
  prefs: []
  type: TYPE_NORMAL
- en: 'The stock recovery mode will typically show a picture of an Android being operated
    on:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Recovery mode](img/image00313.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Stock Recovery mode
  prefs: []
  type: TYPE_NORMAL
- en: Custom recoveries look like the following screenshots. Also, stock recoveries
    will not allow ADB communication; running adb devices will simply show no devices.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Custom recovery images for many devices can be found at [https://www.clockworkmod.com/rommanager](https://www.clockworkmod.com/rommanager)
    and [http://teamw.in/project/twrp2](http://teamw.in/project/twrp2).
  prefs: []
  type: TYPE_NORMAL
- en: 'If a device is in a custom Recovery Mode and the correct drivers have been
    installed on the examiner''s computer, the device can be accessed via ADB as if
    it were live. Note that its status using the adb devices command now shows that
    it is in recovery mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Recovery mode](img/image00314.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'There is one final step before the examiner can begin extracting data over
    ADB: the data partition must be mounted in order to access user data. Some custom
    recoveries may mount this automatically, and others might not. If using either
    the Clockwork Mod Recovery or **Team Win Recovery Project** (**TWRP**) images
    from the URLs above, the data partition can be mounted by selecting **Mounts**
    and then selecting the data partition, as shown in the following screenshots.
    The recovery menu is generally either navigated by using the volume keys to move
    up and down and the power button to select, or may be touch-based depending on
    the custom recovery image used.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For a TWRP recovery, from the main recovery screen, select **Mount**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Recovery mode](img/image00315.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'After choosing **Mount**, select the partition(s) to be mounted:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Recovery mode](img/image00316.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In a Clockwork Mod Recovery, select **mounts and storage**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Recovery mode](img/image00317.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Then select the partition(s) to mount:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Recovery mode](img/image00318.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Once the data partition (and any other partition the examiner wants to investigate)
    is mounted, the examiner can perform ADB data extractions, as demonstrated earlier
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: If the device does not have a custom recovery, the following section will show
    how to boot into one.
  prefs: []
  type: TYPE_NORMAL
- en: Fastboot mode
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Fastboot is another protocol utility built into the Android SDK, and is used
    for interacting directly with a device's bootloader. Essentially, it is a much
    lower-level version of ADB, and is frequently used to flash new images to a device.
    How can this be helpful to an examiner?
  prefs: []
  type: TYPE_NORMAL
- en: Fastboot can allow an examiner to boot from a custom recovery image, and temporarily
    gain root access on a device, thus gaining access to data that would have been
    unavailable otherwise. Fastboot does not require USB debugging to be enabled or
    root access. The process of loading a custom bootloader onto a device is commonly
    used by commercial forensic tools to temporarily root a device, but a skilled
    examiner can also perform the process manually. Using this method, the recovery
    image is loaded into RAM; no permanent data on the device is altered in any way.
  prefs: []
  type: TYPE_NORMAL
- en: The most important requirement for using fastboot is an unlocked bootloader;
    locked bootloaders will not allow a device to boot from code that isn't specifically
    signed by the manufacturer. Unfortunately for forensic purposes, most devices
    no longer ship with an unlocked bootloader as it is a serious security risk, and
    manually unlocking a bootloader typically erases the user data. As such, the number
    of devices for which this is a feasible method is somewhat limited. But, when
    it works, it's an absolutely invaluable tool for an examiner to have in their
    arsenal.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This method will not work against devices with full disk encryption enabled.
    Booting into recovery mode will *not* decrypt the data partition.
  prefs: []
  type: TYPE_NORMAL
- en: Determining bootloader status
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Much like everything involving Android forensics, there is no one guaranteed
    method to determine if a bootloader is locked, as it varies depending upon the
    manufacturer. To boot into the bootloader, use the following ADB command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The device should boot to a screen that shows information regarding the bootloader.
    Frequently, this screen will display the bootloader status, as seen in the following
    screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a generic, stock fastboot menu from a Nexus 5\. Note that the **Lock
    State** indicates that the bootloader is unlocked:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Determining bootloader status](img/image00319.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'A standard HTC fastboot screen is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Determining bootloader status](img/image00320.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Following is a standard Samsung **Odin** mode screen; Odin is the Samsung proprietary
    equivalent to fastboot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Determining bootloader status](img/image00321.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Booting to a custom recovery image
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once the bootloader is determined to be unlocked, an examiner will need a custom
    recovery image from which to boot. An excellent source of recovery images is either
    [https://www.clockworkmod.com/rommanager](https://www.clockworkmod.com/rommanager)
    or [http://teamw.in/twrp_view_all_devices](http://teamw.in/twrp_view_all_devices).
    Both sites offer coverage of a wide variety of devices, and will provide the same
    functionality for the purposes of this method.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is absolutely critical to select the correct recovery image for the device
    being examined; they are not interchangeable, and booting from the wrong image
    may brick the device.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once a recovery image is selected and downloaded, the device needs to be placed
    into fastboot mode. This can be accomplished in one of two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: ADB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Physical device buttons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To enter fastboot device over ADB, the device must already have **USB debugging**
    enabled. The command to enter fastboot mode over ADB is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: If USB Debugging cannot be enabled or ADB cannot be used, there is also typically
    a combination of buttons to press while the device is booting, similar to entering
    Recovery Mode. The exact combination can be found online for each device specifically.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the device is in fastboot mode, running the following command will verify
    if the device is connected and ready to communicate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The following command will load the custom recovery image into RAM and boot
    the device into Recovery Mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '![Booting to a custom recovery image](img/image00322.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The device should now reboot and enter Recovery Mode. As shown in the Recovery
    Mode section, the /data partition may need to be mounted in order to access user
    data.
  prefs: []
  type: TYPE_NORMAL
- en: Entering the ADB shell will show that the examiner now has root access. The
    device will allow root access until it is rebooted.
  prefs: []
  type: TYPE_NORMAL
- en: '![Booting to a custom recovery image](img/image00323.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'If the fastboot boot command fails, it is a likely indicator that the device''s
    bootloader is locked, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Booting to a custom recovery image](img/image00324.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: ADB backup extractions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Google implemented ADB backup functionality, beginning in Android 4.0 Ice Cream
    Sandwich. This allows users (and forensic examiners) to backup application data
    to a local computer over ADB. This process does not require root, and is therefore
    highly useful for forensic purposes. However, it does not acquire every application
    installed on the device. When a developer makes a new app, it is set to allow
    backups by default, but this can be changed by the developer. In practice, it
    seems the vast majority of developers leave the default setting, which means that
    backups do capture most third-party applications. Unfortunately, most Google applications
    disable backups; full application data from apps such as Gmail and Google Maps
    will not be included.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This method will not be useful against a locked device as user interaction with
    the screen is required.
  prefs: []
  type: TYPE_NORMAL
- en: Extracting a backup over ADB
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The format of the ADB backup command is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The flags are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-f`: Names the path for the output file. If not specified, defaults to `backup.ab`
    in present working directory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[-apk|noapk]`: Choose whether or not to back up the `.apk` file. Defaults
    to `-noapk`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[-obb|-noobb]`: Choose whether or not to back up `.obb` (APK expansion) files.
    Defaults to `-noobb`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[-shared|-noshared]`: Choose whether or not to back up data from shared storage
    and the SD card. Defaults to `-noshared`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[-all]`: Include all applications for which backups are enabled.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[-system|-nosystem]`: Choose whether or not to include system applications.
    Defaults to `-system`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[<packages>]`: Explicitly name application packages to be backed up. Not needed
    if using `-all` or `-shared`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An example ADB backup command to capture all possible application data would
    be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, an example ADB backup command to capture a specific application''s
    data would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see something like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Extracting a backup over ADB](img/image00325.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'When performing a backup, the user must approve the backup on the device. This
    means that backups cannot be performed without bypassing screen locks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Extracting a backup over ADB](img/image00326.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Accepting the backup on the device
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the number of applications installed, the backup process may take
    a significant amount of time.
  prefs: []
  type: TYPE_NORMAL
- en: Parsing ADB backups
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The resulting backup data is stored as a .`ab` file, but is actually a `.tar`
    file that has been compressed with the **Deflate** algorithm. If a password was
    entered on the device when the backup was created, the file would also be AES
    encrypted. It should also be mentioned that these files may exist on a suspect's
    computer, and can be analyzed using the same methods.
  prefs: []
  type: TYPE_NORMAL
- en: There are many free utilities to turn the `.ab` backup file into a `.tar` that
    can be viewed. One such utility is the Android Backup Extractor, found at [http://sourceforge.net/projects/adbextractor/](http://sourceforge.net/projects/adbextractor/).
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the Android Backup Extractor, simply extract its files into the directory
    with the backup. The command to run the utility is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'If the command runs properly, the command line will display as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Parsing ADB backups](img/image00327.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The first line of the output informs the examiner that the file was not encrypted.
    Had it been encrypted, the examiner would have to pass the password as an argument
    at the end of the command line. As seen in the output, the backup created in the
    previous section is approximately 4 GB, even though it is still compressed. The
    `.tar` file will be at the path specified on the command line or the current working
    directory if no path is specified. Decompressing the `.tar` file may be done manually
    on a Linux command line or with one of the many Windows archive utilities, such
    as WinRAR or 7Zip:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Parsing ADB backups](img/image00328.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Directories within the backup, seen in Windows Explorer
  prefs: []
  type: TYPE_NORMAL
- en: Data locations within ADB backups
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that the backup has been converted to a `.tar` file and then extracted,
    the examiner can view the data contained in the backup. In our example, there
    are two directories found in the root of the backup:'
  prefs: []
  type: TYPE_NORMAL
- en: '`apps`: This folder contains data from `/data/data` for applications that were
    included in the backup.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`shared`: This folder contains all data from SD card, only present if the –shared
    argument was passed at the command line.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that the files within the apps directory are stored in directories by their
    package name (just as seen in `/data/data` from within the ADB shell), and the
    shared directory is exactly what the user would see if they accessed the SD card
    by plugging it into a computer.
  prefs: []
  type: TYPE_NORMAL
- en: For a benign example of user data that was pulled from the backup, the user's
    **Pandora** activity is shown below. Pandora is a streaming music service with
    millions of downloads in the Google Play Store. Pandora's application data will
    be contained in the apps folder of the backup in the folder named `com.pandora.android`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Data locations within ADB backups](img/image00329.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The Pandora directory from the backup
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a fairly standard layout for an Android application, as discussed in
    [Chapter 2](part0019.xhtml "Chapter 2. Setting Up an Android Forensic Environment"),
    *Setting Up an Android Forensic Environment*. The application''s databases will
    be in the `db` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Data locations within ADB backups](img/image00330.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Files within the db folder of the Pandora backup
  prefs: []
  type: TYPE_NORMAL
- en: 'XML configuration settings will be in the `sp` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Data locations within ADB backups](img/image00331.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Files within the sp folder of the Pandora backup
  prefs: []
  type: TYPE_NORMAL
- en: 'Using a database viewer to view `pandora.db` reveals stations that the user
    has created, as well as the timestamp for when it was created:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Data locations within ADB backups](img/image00332.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Contents of pandora.db from the backup
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking in the XML preferences file, the timestamp of the app installation
    can be found under `firstInstallId`. Note that the exact method for converting
    the timestamps is shown in [Chapter 7](part0053.xhtml "Chapter 7. Forensic Analysis
    of Android Applications"), *Forensic Analysis of Android Applications*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Data locations within ADB backups](img/image00333.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Contents of the XML preferences file
  prefs: []
  type: TYPE_NORMAL
- en: If, for some odd reason, the user's Pandora usage was a major question in the
    investigation, what could an examiner determine from these two seemingly innocuous
    files?
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, the `lastTransmission` and `firstInstallID` timestamps are within milliseconds
    of each other, indicating that the application was never used after it was installed.
    Furthermore, the creation dates of each station precede the installation of the
    application, in some cases, by years. This would be an indicator that the user
    has used Pandora on other devices, which may be highly relevant to the investigation.
  prefs: []
  type: TYPE_NORMAL
- en: While Pandora is generally not germane to digital forensic investigations, it
    is an example of data that can be gleaned from a simple backup over ADB. A more
    detailed application analysis will be presented in [Chapter 7](part0053.xhtml
    "Chapter 7. Forensic Analysis of Android Applications"), *Forensic Analysis of
    Android Applications*.
  prefs: []
  type: TYPE_NORMAL
- en: ADB Dumpsys
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Dumpsys** is a tool built into the Android OS, generally used for development
    purposes to show the status of services running on the device. However, it can
    also contain forensically interesting information. Dumpsys does not require root
    access, but like all ADB commands, it does require USB Debugging to be enabled
    on the device and Secure USB Debugging to be bypassed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The exact services that can be viewed differ across devices and Android versions.
    To view a list of all possible services that can be dumped, run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the command will appear as a list, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ADB Dumpsys](img/image00334.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The service name located before the colon is the argument we will pass to dumpsys.
    A valid dumpsys command, using service number seven (`iphonesubinfo`) in the preceding
    screenshot, looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following screenshot, we see that the output of the `iphonesubinfo`
    service includes the device IMEI:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ADB Dumpsys](img/image00335.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'There are many forensically interesting dumpsys services; following are several
    examples. As the dumpsys services may vary by OS version and device, this list
    is not all-inclusive and is merely intended to show the usefulness of dumpsys
    to a forensic examiner:'
  prefs: []
  type: TYPE_NORMAL
- en: iphonesubinfo
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: batterystats
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: procstats
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: appops
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wi-Fi
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: notification
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dumpsys batterystats
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Batterystats is used to show the usage of running applications. Its output
    can be very verbose, depending on the number of applications in use. In the following
    screenshot , the output was redirected to a file because it did not fit in the
    Windows command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Dumpsys batterystats](img/image00336.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This shows us the network usage of Google Chrome. This information can be used
    to show that the application had been used recently, and this information will
    exist even if Chrome was used in Incognito Mode and leaves no forensic evidence
    elsewhere.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **wake lock** section can be very useful for detecting malware. A wake lock
    is a method of keeping the device awake (not entering sleep mode), and is indicative
    of an application attempting to stay running in the background.
  prefs: []
  type: TYPE_NORMAL
- en: Dumpsys procstats
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The **procstats** is a service to display the processor usage by running applications.
    Similar to batterystats, it is another method that can be used to show that an
    application was recently used on a device, as shown in the following screen shot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Dumpsys procstats](img/image00337.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Dumpsys user
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Beginning with Android Jelly Bean, Google added support for multiple users on
    tablet devices. With the release of Lollipop, Google extended this support to
    phones. One of the most challenging problems in digital forensics for a long time
    has been to prove who was using a device when incriminating actions were performed;
    "Who was behind the keyboard?"
  prefs: []
  type: TYPE_NORMAL
- en: 'Running dumpsys on the user service will show last login info for all users:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Dumpsys user](img/image00338.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As only one user can be logged in at a time, looking at the user with the most
    recent login will identify the account currently in use on the device.
  prefs: []
  type: TYPE_NORMAL
- en: Dumpsys App Ops
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The **App Ops** may be the most interesting dumpsys service. The term App Ops
    is generally used to refer to permissions accessible by an application. In older
    versions of Android, it was rumoured that Google would include the ability for
    users to revoke specific permissions from an application. This has never come
    to fruition, but this service at least remains, and shows the last time an application
    used each permission that it can access. Following is another example from Google
    Chrome:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Dumpsys App Ops](img/image00339.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In the above output, we can see that approximately 1 hour and 7 minutes before
    App Ops was dumped with dumpsys, Chrome used the `TAKE_AUDIO_FOCUS` permission,
    and later used `AUDIO_MEDIA_VOLUME`. This indicates what Chrome was used to listen
    to and when.
  prefs: []
  type: TYPE_NORMAL
- en: 'A somewhat more interesting example is the following phone application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Dumpsys App Ops](img/image00340.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '`44` minutes ago, the user used the phone application and required the `READ_CONTACTS`
    permission, then immediately used the `WRITE_CALL_LOG` permission. We can surmise
    that the user made a phone call `44` minutes ago; even if they had deleted the
    call from the records afterwards.'
  prefs: []
  type: TYPE_NORMAL
- en: Dumpsys Wi-Fi
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The **Wi-Fi** service will show a list of all SSIDs for which a connection
    has been saved. This could be useful for showing that a user was at a certain
    location, for example. More detailed Wi-Fi information is also available on the
    file system, but requires root to view. Using dumpsys, we can access this data
    without requiring root:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Dumpsys Wi-Fi](img/image00341.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Dumpsys notification
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The **notification** service will provide information about currently active
    notifications. This can be useful for recording the state of a device when it
    is seized, or identifying which application is displaying a specific notification.
    Each notification can be rather large and contain a lot of information, only some
    of which may be of use. The following example shows an incoming email from the
    Gmail application, which includes the subject (`This is a test email`) and body
    (`To see a test notification`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Dumpsys notification](img/image00342.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Dumpsys conclusions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Running the dumpsys command with no service name will run dumpsys on all available
    services. However, the output will be very large, and should be redirected into
    a text file. On most platforms, the command to do this would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This would write the output to dumpsys.txt in the current working directory.
    The output can then be searched, or a parsing script can be run to pull out known
    relevant fields.
  prefs: []
  type: TYPE_NORMAL
- en: Dumpsys is an extremely powerful tool that can be used to show information that
    cannot be obtained elsewhere on the device. We recommend running dumpsys on every
    Android device when it is seized, prior to being shut down. This will save a wide
    variety of information that may be useful later, and does not require root.
  prefs: []
  type: TYPE_NORMAL
- en: Bypassing Android lock screens
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lock screens are the most challenging aspect of Android forensic examinations.
    Frequently, the entire investigation depends on the examiner's ability to gain
    access to a locked device. While there are methods to bypass them, this can be
    highly dependent on the OS version, device settings, and technical capabilities
    of the examiner. There is no magical solution that will work every time on every
    device. Commercial forensics tools such as Cellebrite and XRY have fairly robust
    bypass capabilities, but are far from infallible. This chapter will show how an
    examiner can increase their odds of bypassing locked devices with free tools and
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An examiner should never attempt to guess a Pattern/PIN/Password on the device.
    Many manufacturers implement a setting that will wipe the device after a number
    of failed attempts. Many also allow the user to lower that number.
  prefs: []
  type: TYPE_NORMAL
- en: Lock screen types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are many methods used to secure a device, and the methods for bypassing
    each vary:'
  prefs: []
  type: TYPE_NORMAL
- en: None/Slide
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PIN
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Password
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Smart Lock
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Trusted Face
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Trusted Location
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Trusted Device
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other security options may exist; as Android is open source, the possibilities
    are only limited by the developer's imagination. These are the options that are
    available in the stock version of Android Lollipop released by Google. Most security
    options used by vendors generally use one of these stock options as a failsafe,
    in case a user is unable to log in with their unique options. Versions in which
    the setting was first used also refer to stock Android; various manufacturers
    may have implemented them sooner.
  prefs: []
  type: TYPE_NORMAL
- en: None/Slide lock screens
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **Slide to unlock** screen is the default setting of most Android devices.
    It provides no level of security, and is bypassed by sliding a finger on the screen
    in the indicated direction.
  prefs: []
  type: TYPE_NORMAL
- en: Pattern lock screens
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Pattern lock screens are the iconic Android security method. Frequently referred
    to as **swipe codes** and similar names, these require the user to trace a pattern
    on the device with a finger. A common bypass for this lock is the **smudge attack**,
    looking for patterns left on the screen by the user's finger.
  prefs: []
  type: TYPE_NORMAL
- en: Password/PIN lock screens
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Users familiar with Apple''s iOS will recognize this option. It requires a
    user to type a password or PIN in order to unlock the device. These are lumped
    together because forensically, they are identical: they store their passwords
    the same way.'
  prefs: []
  type: TYPE_NORMAL
- en: Smart Locks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The **Smart Lock** is a term introduced in Android Lollipop, although the Face
    unlock option was previously available. They require a specific condition to unlock
    the device: a user''s face must be recognized, the user must be in a known location,
    or a specific other device must be nearby.'
  prefs: []
  type: TYPE_NORMAL
- en: Trusted Face
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Face unlock works exactly as it sounds: it uses facial recognition to determine
    if the user has been previously been set up as a trusted user. Older versions
    of Face locks were easily fooled by pictures of a trusted user, though newer versions
    may require the user to blink in order to unlock the device.'
  prefs: []
  type: TYPE_NORMAL
- en: Trusted Location
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Trusted Location is available in Android Lollipop and is also commonly referred
    to as **geo-fencing**. If a user is in a location that has been marked as trusted
    (such as home or work), the device will not lock. There is no input required from
    the user, but the GPS must be enabled.
  prefs: []
  type: TYPE_NORMAL
- en: Trusted Device
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Trusted Device is available in Android Lollipop and works via Bluetooth; if
    a device that has been setup as a trusted device is nearby, the lock screen will
    be disabled. This may be used with smart watches, vehicles that pair over Bluetooth,
    Bluetooth headsets, or any other Bluetooth-capable device.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All Smart Lock options require a Pattern/PIN/Password as a backup security method.
    This means we only have to learn how to bypass Patterns/PINs/Passwords in order
    to crack all of the security options.
  prefs: []
  type: TYPE_NORMAL
- en: General bypass information
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In all cases, bypassing the lock screen will require retrieving a file from
    the device. Pattern locks are stored as hash values at `/data/system/gesture.key`
    and PIN/Password locks are stored as hash values at `/data/system/password.key`.
    Additionally, the password.key hash is salted; the salt value is stored at `/data/data/com.android.providers.settings/databases/settings.db`
    prior to Android 4.4, and `/data/system/locksettings.db` on devices running Android
    4.4 and higher.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the device is locked, how is an examiner supposed to access these files?
    Again, there is no magic solution that works every time, but there are some options,
    which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: ADB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Requires root
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Requires **USB debugging**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Requires **Secure USB debugging** pairing (depending on OS version)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Booting into a custom recovery mode
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does not require root (root will be given through the recovery image)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does not require **USB debugging** (accomplished via fastboot)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does not require **Secure USB debugging** (this is bypassed entirely)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Requires an unlocked bootloader
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JTAG/Chip-off
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Highly advanced
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does not require any specific device settings or options
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The files that need to be pulled to crack a PIN/password on devices prior to
    Android 4.4 are:'
  prefs: []
  type: TYPE_NORMAL
- en: /`data/system/password.key`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/data/data/com.android.providers.settings/databases/settings.db`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The files that need to be pulled to crack a PIN/password on devices running
    Android 4.4 and higher are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/data/system/password.key`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/data/system/locksettings.db`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Only one file needs to be pulled to crack a Pattern lock on all versions of
    Android:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/data/system/gesture.key`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is not always necessary to actually crack the PIN or Password. They can also
    be bypassed by simply overwriting or deleting the files. However, this is changing
    the original evidence and may not be forensically valid in your jurisdiction.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the below cracking sections do NOT apply to Lollipop devices. The
    pattern locks are no longer unsalted, and as of the time of writing, no information
    has been published regarding how to recover the salt. However, the lock screen
    can still be bypassed by deleting the relevant files.
  prefs: []
  type: TYPE_NORMAL
- en: Many tools exist that will bypass lock screens automatically; however, in this
    chapter, we will show the manual process to explain what these tools are doing
    in the background. A good tool that is free for law enforcement can be found at
    [https://andriller.com/](https://andriller.com/).
  prefs: []
  type: TYPE_NORMAL
- en: Cracking an Android pattern lock
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have `gesture.key`, which contains the pattern lock information,
    let''s take a look at the file contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Cracking an Android pattern lock](img/image00343.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Contents of gesture.key in a hex editor
  prefs: []
  type: TYPE_NORMAL
- en: The hex contents of the file are an unsalted SHA-1 hash of the swipe pattern.
    The fact that there are a limited number of possible patterns (there is a four
    digit minimum and a nine digit maximum because each number can only be used once),
    the simplest method for cracking this hash is a dictionary attack. An examiner
    can create a dictionary consisting of every possible pattern, but re-inventing
    the wheel isn't always necessary. CCL Forensics, based in the UK, provides a free
    Python script to create the hash dictionary. It can be downloaded at [http://www.cclgroupltd.com/product/android-pattern-lock-scripts/](http://www.cclgroupltd.com/product/android-pattern-lock-scripts/).
  prefs: []
  type: TYPE_NORMAL
- en: 'The file is `GenerateAndroidGestureRainbowTable.py`. To run it, Python 3 must
    be installed on the examiner''s system. Python 3 can be downloaded at [https://www.python.org/downloads/](https://www.python.org/downloads/).
    Many forensics tools provide Python support or use it themselves, so an examiner
    may already have it installed. To execute the file, simply navigate to the directory
    containing it and run:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Cracking an Android pattern lock](img/image00344.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The script may take a while to run, possibly between 20 and 30 minutes. Once
    it completes, there should now be a file called `AndroidLockScreenRainbow.sqlite`
    in the same directory as the `GenerateAndroidGestureRainbowTable.py` script.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a database containing the hash of every possible Android pattern,
    we simply need to look up the hash we found in the `gesture.key` file. This can
    be done manually with a SQLite viewer or even SQL commands. However, CCL Forensics
    also provides `Android_GestureFinder.py`, a script that will look up the hash
    in the database created previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, this free script doesn''t quite suit our purposes. It is built
    to look at a physical dump binary and find a lock screen pattern; we already have
    the file containing the pattern. In order for the script to work properly, we
    will need to modify the code. `Android_GestureFinder.py` will need to be opened
    in some sort of a code-friendly editor; Notepad++, Sublime Text, or the Python
    IDLE GUI will all work. The following screenshots are from Sublime Text. Make
    a copy of the file, open the original and find line 85, which says:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This line needs to be commented out. To do so, just place a `#` sign at the
    beginning of the line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Due to Python''s formatting, we will now undo indents in the lines following
    the statement we commented out. Lines 86, 89, 91, and 92 need to be moved to the
    left, so that they are in line with our commented out statement. Finally, line
    94 needs to move four backspaces to the left so that it is one tab indented from
    the line above it. The final code should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Cracking an Android pattern lock](img/image00345.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Final code for Android_GestureFinder.py
  prefs: []
  type: TYPE_NORMAL
- en: Note that line 85 now begins with `#`, lines 86, 89, 91, and 92 are in line
    with line 85, and line 94 is indented one tab to the right from the other lines
    (or four backspaces from its original location).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now the code is ready to run against our file; save the changes to `Android_GestureFinder.py`.
    Ensure that the `AndroidLockScreenRainbow.sqlite` and `gesture.key` files are
    in the same directory as `Android_GestureFinder.py`, and run the following script:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Cracking an Android pattern lock](img/image00346.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The output should return very quickly, as it is performing a simple lookup
    in the hash database. The `Offset` is negative, due to the fact that we used the
    script against a single file; if pointed at a binary physical dump, it would display
    the offset of the lock screen hash within the blob. The `Hash` column shows the
    hash value that was found, and the `Pattern` is the corresponding lock screen
    pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Cracking an Android pattern lock](img/image00347.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Lock screen numbering
  prefs: []
  type: TYPE_NORMAL
- en: In this example, the pattern would begin at `0` in the top left corner, pass
    through **4** in the center, touch **8** in the bottom right corner, then cross
    the **7** in the bottom middle, and end at the **6** in the bottom left corner.
    This pattern can now be used on the device to bypass the lock screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the script encountered errors, the file was likely not modified correctly.
    The following result would likely indicate that the script was not modified properly;
    perhaps the copy of the file was run instead of the modified version:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Cracking an Android pattern lock](img/image00348.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'To resolve this error, verify that the script was modified as shown above.
    The following error is indicative of improper indentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Cracking an Android pattern lock](img/image00349.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: To resolve this error, navigate to the specified line (86 in the example above),
    and ensure that the alignment is as shown in the preceding modified code.
  prefs: []
  type: TYPE_NORMAL
- en: If the errors cannot be resolved, or if modifying the script is too daunting
    to an examiner, the hash value can always be looked up manually in the hash database.
    An excellent free SQL viewer, DB Browser for SQLite, can be found at [http://sourceforge.net/projects/sqlitebrowser/](http://sourceforge.net/projects/sqlitebrowser/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Open AndroidLockScreenRainbow.sqlite with DB Browser for SQLite, and select
    the Browse Data tab. Then, simply type the hash value found in gesture.key into
    the search field in the hash column. Note that the characters in the database
    are lower case; the search field is case-sensitive:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Cracking an Android pattern lock](img/image00350.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Contents of the AndroidLockScreenRainbow.sqlite file in SQLite Browser
  prefs: []
  type: TYPE_NORMAL
- en: The results are the same as if the script had been run.
  prefs: []
  type: TYPE_NORMAL
- en: Cracking an Android PIN/Password
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To crack the PIN/Password lock, we''ll need to take a look in the contents
    of the files pulled earlier. `Password.key` is very similar to `gesture.key`;
    it contains a hash of the password as shown in following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Cracking an Android PIN/Password](img/image00351.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Contents of password.key in a hex editor
  prefs: []
  type: TYPE_NORMAL
- en: However, this time the hash is salted. To have a chance at cracking it, the
    salt will have to be recovered. As noted above, its location will be dependent
    on the version of Android the device is running. If the device is running version
    4.3 or lower, it will be located in the `settings.db` file within the `secure`
    table. In 4.4 or higher, it will be in the `locksettings.db` within the `locksettings`
    table. The following example shows `locksettings.db`, but the process is identical
    for both.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within the database file, we''ll need to locate the `lockscreen.password_salt`
    key. This can be done in a SQL browser, or just by opening the file in a hex editor
    and searching. The salt value is highlighted as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Cracking an Android PIN/Password](img/image00352.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Contents of locksettings.db in a hex editor
  prefs: []
  type: TYPE_NORMAL
- en: For the Pattern lock, we were able to use a dictionary attack to quickly break
    the pattern, because there were a relatively small number of possibilities. With
    a salted hash, dictionary attacks are infeasible, so instead we will simply brute-force
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Once again, CCL Forensics provides a useful Python script for this purpose.
    Other cracking tools, such as hashcat, could also be used. The CCL Forensics PIN/Password
    tool can be downloaded for free at [http://www.cclgroupltd.com/product/android-pin-password-lock-tool/](http://www.cclgroupltd.com/product/android-pin-password-lock-tool/).
    Two files will be downloaded, `BruteForceAndroidPin.py` and `RecoverAndroidPIN.py`.
    `RecoverAndroidPIN.py` is for locating the necessary files within a physical image;
    we won't be needing it for our purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The format for `BruteForceAndroidPIN.py` is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `t` argument on the end is used to indicate the hash is of a password; it
    is not needed for cracking a PIN and would simply increase the time it takes to
    run.
  prefs: []
  type: TYPE_NORMAL
- en: 'The hash value shown above is from a PIN, so we simply need to fill in the
    `<hash>`, `<salt>`, and `<max code length>` fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Cracking an Android PIN/Password](img/image00353.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The PIN from this example was `2587` as indicated in the output. It took less
    than a second for this PIN to crack, however longer PINs or even short passwords
    may take significantly longer.
  prefs: []
  type: TYPE_NORMAL
- en: Android SIM card extractions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Traditionally, SIM cards were used for transferring data between devices. In
    the past, SIM cards were used to store many different types of data, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: User data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Contacts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SMS messages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dialed calls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Network data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integrated Circuit Card Identifier** (**ICCID**): Serial number of the SIM'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**International Mobile Subscriber Identity** (**IMSI**): Identifier that ties
    the SIM to a specific user account'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**MSISDN**: Phone number assigned to the SIM'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Location Area Identity** (**LAI**): Identifies the cell that a user is in'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Authentication Key** (**Ki**): Used to authenticate to the mobile network'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Various other network-specific information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the rise in capacity of device storage, SD cards, and cloud backups, the
    necessity for storing data on a SIM card has decreased. As such, most modern smartphones
    typically do not store much, if any, user data on the SIM card. All network data
    listed above does still reside on the SIM, as a SIM is necessary to connect to
    all modern (4G) cellular networks.
  prefs: []
  type: TYPE_NORMAL
- en: As with all Android devices, though there is no concrete stipulation that user
    data can't be stored on a SIM, it simply doesn't happen by default. Individual
    device manufacturers can easily decide to write user data to the SIM, and individual
    users can download applications to provide that functionality. This means that
    a device's SIM card should always be examined during a forensic examination. It
    is a very quick process, and should never be overlooked.
  prefs: []
  type: TYPE_NORMAL
- en: Acquiring SIM card data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The SIM card should always be removed from the device and examined separately.
    While some tools claim to read the SIM card through the device interface, this
    may not recover deleted data or all data on the SIM; the only way for an examiner
    to be certain all data was acquired is to read the SIM through a standalone SIM
    card reader with a tool that has been tested and verified.
  prefs: []
  type: TYPE_NORMAL
- en: The location of the SIM will vary by device, but is typically either stored
    beneath the battery or in a tray located on the side of the device. Once the SIM
    is removed, it should be placed in a SIM card reader. There are hundreds of SIM
    card readers available in the marketplace, and all major mobile forensics tools
    come with an included reader that will work with their software. Often, the forensic
    tools will also support third-party SIM readers as well.
  prefs: []
  type: TYPE_NORMAL
- en: There is a surprising lack of thorough, free SIM card reading softwares. Any
    software used should always be tested and validated on a SIM card that has been
    populated with known data prior to being used in an actual forensic investigation.
    Also, keep in mind that much of the free software available works for older 2G/3G
    SIMs, but may not work properly on a modern 4G SIM. We used the Mobiledit! Lite,
    a free version of Mobiledit!, for the following screenshots. It is available at
    [http://www.mobiledit.com/downloads](http://www.mobiledit.com/downloads).
  prefs: []
  type: TYPE_NORMAL
- en: The following screenshot shows a sample 4G SIM card extraction from an Android
    phone running version 4.4.4; note that nothing that could be considered user data
    was acquired, despite the SIM being used actively for over a year, though fields
    such as the ICCID, IMSI, and MSISDN (own phone number) could be useful for subpoenas/warrants
    or other aspects of an investigation.
  prefs: []
  type: TYPE_NORMAL
- en: '![Acquiring SIM card data](img/image00354.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: SIM card extraction overview
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot highlights SMS messages on the SIM card:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Acquiring SIM card data](img/image00355.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following image highlights the phonebook of the SIM card:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Acquiring SIM card data](img/image00356.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following image highlights the phone number of the SIM card (also called
    the MSISDN):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Acquiring SIM card data](img/image00357.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: SIM security
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Due to the fact that SIM cards conform to established international standards,
    all SIM cards provide the same security functionality: a 4- to 8-digit PIN. Generally,
    this PIN must be set through a menu on the device. On Android devices, this setting
    is found at **Settings** | **Security** | **Set up SIM card lock**. The SIM PIN
    is completely independent of any lock screen security settings, and only has to
    be entered when the device boots. The SIM PIN only protects user data on the SIM;
    all network information is still recoverable even if the SIM is PIN locked.'
  prefs: []
  type: TYPE_NORMAL
- en: The SIM card will allow three attempts to enter the PIN. If one of these attempts
    is correct, the counter will reset. On the other hand, if all of these attempts
    are incorrect the SIM will enter **Personal Unblocking Key** (**PUK**) mode. The
    PUK is an 8-digit number assigned by the carrier, and is frequently found on documentation
    when the SIM is purchased. Bypassing a PUK is not possible with any commercial
    forensic software; because of this, an examiner should never attempt to enter
    the PIN on the device as the device will not indicate how many attempts remain
    before the PUK is activated. An examiner could unwittingly PUK-lock the SIM, and
    be unable to access the device. Forensic tools, however, will show how many attempts
    remain before the PUK is activated, as seen in the screenshots preceding.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Common carrier defaults for SIM PINs are 0000 and 1234\. If 3 tries remain before
    activating the PUK, an examiner may successfully unlock the SIM with one of these
    defaults.
  prefs: []
  type: TYPE_NORMAL
- en: Carriers frequently retain PUK keys when a SIM is issued. These may be available
    through a subpoena or warrant issued to the carrier.
  prefs: []
  type: TYPE_NORMAL
- en: SIM cloning
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The SIM PIN itself provides almost no additional security, and can easily be
    bypassed through SIM cloning. SIM cloning is a feature provided in almost all
    commercial mobile forensic software, although the term cloning is somewhat misleading.
    SIM cloning, in the case of mobile forensics, is the process of copying the network
    data from a locked SIM onto a forensically sterile SIM that does not have the
    PIN activated. The phone will identify the cloned SIM based on this network data
    (typically the ICCID and IMSI) and think that it is the same SIM that was inserted
    previously, but this time there will be no SIM PIN. This cloned SIM will also
    be unable to access the cellular network, which makes it an effective solution
    similar to Airplane mode. Therefore, SIM cloning will allow an examiner to access
    the device, but the user data on the original SIM is still inaccessible as it
    remains protected by the PIN.
  prefs: []
  type: TYPE_NORMAL
- en: We are unaware of any free software that performs forensic SIM cloning. However,
    it is supported by almost all commercial mobile forensic kits. These kits will
    typically include a SIM card reader, software to perform the clone, as well as
    multiple blank SIM cards for the cloning process.
  prefs: []
  type: TYPE_NORMAL
- en: Issues and opportunities with Android Lollipop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As noted several times in this chapter, the recent unveiling of Android Lollipop
    Version 5.0 has introduced many strong security features, which of course creates
    complications for forensic examiners. It was initially announced that Android
    Lollipop devices would ship with full disk encryption by default, however, Google
    later retracted this requirement due to performance issues on many devices. Instead
    of a requirement, Google only strongly suggests that full disk encryption be enabled
    when the user first creates an account. Google has also hinted that this will
    be a requirement in future OS versions, more information can be found in section
    **9.9** at [http://static.googleusercontent.com/media/source.android.com/en/us/compatibility/android-cdd.pdf](http://static.googleusercontent.com/media/source.android.com/en/us/compatibility/android-cdd.pdf).
  prefs: []
  type: TYPE_NORMAL
- en: Devices with full disk encryption enabled make bypassing locked devices all
    but impossible, because even if the key files could be recovered, they would be
    encrypted; though surely the commercial tool manufacturers will eventually catch
    up. At the time of this writing, there is no known method for bypassing a locked,
    encrypted Lollipop device, unless it has **USB debugging** enabled and previously
    remembered a computer's RSA key to bypass **Secure USB debugging**. In this case,
    the `adbkey` and `adbkey.pub` files can be pulled from the suspect's computer
    and placed on an examination machine; the device will then think it is communicating
    with a known, approved computer. The `adbkey` and `adbkey.pub` files can be found
    at `C:\Users\<username>\.android` on Windows computers and `/Users/<username>/.android`
    on Apple computers.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one significant advantage for examiners performing Lollipop forensics:
    the Smart Locks mentioned earlier in this chapter. Smart Locks allow a user to
    set conditions that, if met, will leave the device unlocked without the need to
    enter the password even once. If the examination is performed at a Trusted Location
    that has been enabled, the examiner will not need to bypass the lock. The same
    is true if a Trusted Device is nearby and turned on while the device is being
    examined. However, there is no indication on the device that a trusted device
    is being used; the device just appears to not have a lock screen. Thus, securing
    all digital evidence from a scene becomes even more critical. Devices that would
    have previously been overlooked, such as Bluetooth headsets, may turn out to be
    the key that gets the examiner past a locked device. It is becoming increasingly
    common for devices to be paired with vehicles, so an examiner may have to perform
    an extraction while sitting in the suspect''s vehicle! The additional security
    of Lollipop means that examiners may have to get more creative with the forensic
    process.'
  prefs: []
  type: TYPE_NORMAL
- en: Android Lollipop also brings multi-user support to all devices, which was previously
    limited to tablets. On a device with multiple accounts, data for all users is
    still found in the `/data` partition, but resides in a slightly different location.
    If multiple accounts are setup on the device, the app data directory for each
    account can be found in `/data/user`. Each user will have a unique number assigned;
    `0` is the first account setup on the device. The `/data/user/0` directory is
    actually a symbolic link to `/data/data`. The second account was in the `10` directory,
    which directly contained all application data for the second user. Each user added
    is stored in a directory incremented by `10`; i.e. the third user is in `/data/user/20`,
    the fourth user is in `/data/user/30`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter has covered many topics related to logical extractions of Android
    devices. As a recap, the various methods and their requirements are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Requirements |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| ADB pull |'
  prefs: []
  type: TYPE_TB
- en: '**USB debugging** enabled'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Secure USB debugging** bypassed on 4.2.2+'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Root access to obtain user data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| ADB pull from Recovery Mode |'
  prefs: []
  type: TYPE_TB
- en: Must be a custom recovery to enable ADB access
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Root access to obtain user data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| Fastboot to boot from custom recovery image |'
  prefs: []
  type: TYPE_TB
- en: Unlocked bootloader
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Boot image for device
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| ADB backup |'
  prefs: []
  type: TYPE_TB
- en: '**USB debugging** enabled'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Secure USB debugging** bypassed on 4.2.2+'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Must be done from a running device (not Recovery mode)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| ADB dumpsys |'
  prefs: []
  type: TYPE_TB
- en: '**USB debugging** enabled'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Secure USB debugging** bypassed on 4.2.2+'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Must be done from a running device (not recovery mode)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| SIM card extraction |'
  prefs: []
  type: TYPE_TB
- en: None, should be done independent of device
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, valuable user data can be recovered from the SD card, which will
    be covered in [Chapter 5](part0040.xhtml "Chapter 5. Extracting Data Physically
    from Android Devices"), *Extracting Data Physically from Android Devices*.
  prefs: []
  type: TYPE_NORMAL
- en: If a screen is locked, an examiner can pull the key files using the methods
    listed above and crack them in order to bypass it.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a lot of data in this chapter. To help simplify it somewhat, a suggested
    *best practices* flow chart is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: .
  prefs: []
  type: TYPE_NORMAL
- en: '![Summary](img/image00358.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Android Forensics Flow Chart
  prefs: []
  type: TYPE_NORMAL
