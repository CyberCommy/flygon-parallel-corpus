- en: Templates and Plugins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a development environment, Android Studio provides facilities to design and
    develop all aspects of any Android app we can imagine. In the previous chapters
    we saw how it acts as a visual design tool, along with a dynamic layout editor,
    emulators, and XML structures. From now onward, we will delve under the bonnet
    and take a look at how the IDE facilitates, simplifies, and speeds up the process
    of coding, testing, and fine-tuning our work.
  prefs: []
  type: TYPE_NORMAL
- en: Most readers will already be expert coders and require no help with this. Consequently,
    it is the way Android Studio improves this experience that we will globally explore
    in the coming chapters. In this chapter, we will look at various examples of ready-made
    code that comes with the IDE in the form of activity templates and API samples.
    These are useful as ways to explore and learn how various components are coded
    and to speed up the process of coding by providing an already existing starting
    point. Moreover as we shall see, if the bundled selection of templates is not
    enough, Android Studio allows us to create our own.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding built-in project templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing the Structure Tool window
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing and using UML plugins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying simple refactoring
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying code templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a custom template
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using project samples
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Project templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most readers will have already encountered project templates whenever they start
    a new Android Studio project from the IDE's Welcome screen.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c6ee59d1-aacf-4553-a917-e96a0769eb2e.png)'
  prefs: []
  type: TYPE_IMG
- en: Project templates
  prefs: []
  type: TYPE_NORMAL
- en: Even the Empty Activity template provides files and a little code that are essential
    for almost all applications and, as you saw in the preceding screenshot, there
    is a growing collection of project templates designed to suit many common application
    structures and purposes.
  prefs: []
  type: TYPE_NORMAL
- en: The Navigation Drawer template
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It will not be necessary to examine all of these templates here, but there
    are one or two that can be very instructive and provide further insight into the
    workings of Android Studio. The first, and perhaps the most useful, is the Navigation
    Drawer Activity template, which when run as-is produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c6aebf36-d507-4d0d-a5e9-df0809060837.png)'
  prefs: []
  type: TYPE_IMG
- en: The Navigation Drawer template
  prefs: []
  type: TYPE_NORMAL
- en: As can be seen in the preceding screenshot, this template provides many common,
    and recommended, UI components, including icon drawables, menus, and action buttons.
    The most interesting aspect of these templates is the code that they create and
    the file structures they use, both of which are nice examples of best practices.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we start a new project with this template and start to look around, one
    of the first things we will observe is that the `activity_main.xml` file is different
    from those we have seen earlier, in that it uses `android.support.v4.widget.DrawerLayout`
    as its root. Inside this, we find `CoordinatorLayout` and `NavigationView` from
    the design library. As in the previous example, the coordinator layout contains
    a toolbar and an FAB; here, though these components are created in a separate
    file and included with the `include` tag, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This structure can help keep our code easier to keep track of and make future
    modifications easier. As can be seen, this approach is also used to define the
    navigation bar header and main content.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most of the template-generated XML will be familiar to the reader, but there
    are one or two snippets that might require explanation. For example, the `content_main.xml`
    file contains the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The referenced string will not be found in the `strings.xml` file, as it is
    system-provided and points to the `AppBarLayout.ScrollingViewBehavior` class,
    ensuring that our toolbar is an instance of it.
  prefs: []
  type: TYPE_NORMAL
- en: The line `tools:showIn="@layout/app_bar_main"` may also be puzzling. This is
    one of many useful features found in the `tools` namespace and is used here so
    that the navigation drawer is visible in the preview editor, saving the developer
    from having to rebuild a project every time they want to view a graphical change.
  prefs: []
  type: TYPE_NORMAL
- en: The XML resources generated by this and other templates only tell half the story,
    as many of them produce a sizable amount of Java code as well, and this is just
    as interesting, if not more so, than the XML. Just a quick look through the `MainActivity.Java`
    code will demonstrate how the template has set up methods to handle basic navigation,
    menus, and button clicks. None of the code is complex to understand, but it is
    very handy as all of these methods would have had to be coded by us at some point
    or another, and the comments and placeholders make it very simple to substitute
    our own resources and add our own code.
  prefs: []
  type: TYPE_NORMAL
- en: The Structure Explorer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is nice when we have time to browse through code this way, but few developers
    have this luxury and naturally want a way to look quickly at a class's structure
    and contents. Android Studio provides a neat, schematic window onto a Java class's
    inner workings in the form of the **Structure Tool window**, which can be selected
    from the project explorer bar or by pressing *Alt* + *7:*
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2ff9f52f-f555-409c-b47c-4477deee965f.png)'
  prefs: []
  type: TYPE_IMG
- en: The Structure (*Alt *+ *7*) Tool window
  prefs: []
  type: TYPE_NORMAL
- en: When dealing with projects having many classes, the structure tool is a very
    useful way to maintain an overview, and when dealing with lengthy classes, selecting
    any item will highlight the corresponding text in the code editor.
  prefs: []
  type: TYPE_NORMAL
- en: Pressing *F4* when an item in the structure explorer is selected will cause
    the code editor to jump to that location in the text.
  prefs: []
  type: TYPE_NORMAL
- en: The toolbar at the top of the Structure pane allows for some very handy filters
    so that our methods can be displayed according to their defining type (as shown
    in the preceding figure) and as other levels of detail, such as whether to display
    properties and fields.
  prefs: []
  type: TYPE_NORMAL
- en: Despite the usefulness of being able to view any class from such a perspective,
    there are often times when we would like to view class structures from even more
    points of view, and there are of course plugins that allow deeper inspection.
  prefs: []
  type: TYPE_NORMAL
- en: Class inspection plugins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many ways to visualize classes and groups of classes, making them
    easier to follow or to highlight certain features or properties. A tried and tested
    visual programming tool is the **Universal Modeling Language** (**UML**). These
    are of particular use if the developer is working with design patterns.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several UML class diagram plugins available to us, ranging from basic
    to sophisticated. If you just want a simple UML tool, then the JetBrains plugin,
    simpleUMLCE, can be downloaded from the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[plugins.jetbrains.com/plugin/4946-simpleumlce](http://plugins.jetbrains.com/plugin/4946-simpleumlce)'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are new to plugins, follow the quick steps to install and use the simple
    UML plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: Download the plugin from the previous link.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the Plugins dialog from Android Studio's File | Settings menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the Install plugin from disk... button to locate and install the plugin.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/13e8021a-801e-49a2-a069-1bb0ca76afb5.png)'
  prefs: []
  type: TYPE_IMG
- en: The Plugins dialog
  prefs: []
  type: TYPE_NORMAL
- en: 'You will need to restart the IDE before you can access the plugin. Once you
    have done so, right-click on a package or class from the project explorer and
    select Add to simpleUML Diagram | New Diagram... from the menu. The plugin will
    add a tab to the left gutter, which will open the tool area and display the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4e2f10ad-3cd3-49a2-b9e9-8a8b2afbda7c.png)'
  prefs: []
  type: TYPE_IMG
- en: The simpleUML Diagram tool
  prefs: []
  type: TYPE_NORMAL
- en: The activity class used in the navigation drawer example that we used in this
    chapter is a little too simple to really show off the advantages of taking a diagrammatic
    view of our code, but if the reader applies this tool to a more complex class,
    with several fields and dependencies, its value will soon become apparent.
  prefs: []
  type: TYPE_NORMAL
- en: Diagrams can be saved as images and a variety of perspectives are available
    from the window's own toolbar.
  prefs: []
  type: TYPE_NORMAL
- en: Most Studio plugins will add a tab to the guttering. This is normally placed
    at the top of the left-hand gutter. This can often interfere with our own workspace
    preferences. Fortunately, these tabs can be rearranged by simply dragging and
    dropping them into a preferred position.
  prefs: []
  type: TYPE_NORMAL
- en: For most developers, a simple UML tool like this is enough, but if you prefer
    a more sophisticated tool, then **Code Iris** may be the plugin for you.
  prefs: []
  type: TYPE_NORMAL
- en: Code Iris does not need to be downloaded, as it can be found by browsing the
    plugins repository. Although, you will still need to restart the IDE. The repository
    can be accessed from the same Plugins window of the Settings dialog as the previous
    plugin but by clicking the Browse repositories... button.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/18e2cf25-40cc-4197-bbe6-d9ed94b7fe96.png)'
  prefs: []
  type: TYPE_IMG
- en: The Browse Repositories dialog
  prefs: []
  type: TYPE_NORMAL
- en: A quick look at the description of the project web page , which can be found
    at [plugins.jetbrains.com/plugin/7324-code-iris](https://plugins.jetbrains.com/plugin/7324-code-iris),
    will show that Code Iris can do a great deal more than create class diagrams and
    should be thought of more as a more general visualization tool. The toolis described
    as a UML-based Google Maps for your source code, making it not only a useful development
    tool for individuals but also a great communication tool between teams, and it
    is better suited to graphing whole projects than equivalent tools.
  prefs: []
  type: TYPE_NORMAL
- en: Any third-party plugin repository can be made available in the repository browser,
    by clicking on the Manage repositories... button and pasting the relevant URL
    into the resultant dialog.
  prefs: []
  type: TYPE_NORMAL
- en: Code visualizations can be generated by either by opening the tool window and
    selecting the Create / Update Diagram button or from the project explorer from
    an individual module, package, or class's entry.
  prefs: []
  type: TYPE_NORMAL
- en: Code Iris' strength lies in its ability to visualize a project on any scale
    and quickly switch between these using the view slider. Used in conjunction with
    filters and an automatic arrangement algorithm called **organic layouting**, we
    can quickly generate appropriate and easily understood visualizations.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d4db0b6c-dfac-4106-93b6-5c569c634ac4.png)'
  prefs: []
  type: TYPE_IMG
- en: Code Iris visualization
  prefs: []
  type: TYPE_NORMAL
- en: Despite its pretensions toward biology and the poor use of English, the organic
    layouting tool is actually remarkably clever, useful, and good-looking. When switched
    on (using the play button), diagrams will arrange themselves dynamically, according
    to our focus, which can be directed simply by clicking on the class of interest.
    If you have ever found yourself in the unenviable position of having to work with
    poorly documented code, this tool can save you many hours of head scratching.
  prefs: []
  type: TYPE_NORMAL
- en: The two plugins covered here are by no means the only inspection and visualization
    tools available to us, and a quick search on the internet will uncover many more.
    The two we selected here were chosen as they are indicative of the types of tool
    around.
  prefs: []
  type: TYPE_NORMAL
- en: The navigation drawer template we have explored here is remarkably useful as
    it contains several, almost ubiquitous UI components. It is also quite straightforward
    to understand. Another very handy project template is the Master/Detail Flow template.
  prefs: []
  type: TYPE_NORMAL
- en: The Master/Detail Flow template
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Master/Detail UIs are found frequently on mobile devices, as they maximize
    the use of space very nicely by displaying a list and each of its items separately
    or side by side depending on the current width of the screen. This results in
    phone in a portrait orientation displaying two single panes; however, but in landscape
    mode or on a larger device, such as a tablet, two panes will be displayed side
    by side:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f5f71a36-1996-4a65-b982-59500d6f59d5.png)'
  prefs: []
  type: TYPE_IMG
- en: A two-pane view
  prefs: []
  type: TYPE_NORMAL
- en: The preceding screenshot is taken from the unmodified Master/Detail Flow project
    template viewed on a device in landscape mode so that both panes are displayed.
    We said previously that the two-pane view was visible on phones in landscape mode.
    If you have tried this on many phones, you will have found that this is not necessarily
    true. By default  the template only displays two panes on screens whose longest
    side is 900dp or more. This can be deduced from the presence of the `res/layout-w900dp`
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: To enable a two-pane view on smaller devices, we need only change the name of
    this folder. This, of course, can be done directly from our file explorers, but
    Android Studio has a powerful refactoring system with a sophisticated preview
    window. Although it is not needed in this case, it is perhaps most useful as it
    searches for references to it and renames them too.
  prefs: []
  type: TYPE_NORMAL
- en: The Rename dialog can be opened directly by pressing *Shift* + *F6*.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, if you try to access the `layout-w900dp` folder from the navigation
    bar or project explorer, you will not be able to do so. To do this, switch from
    the Android tab to the Project tab in the explorer, as this presents the project
    exactly as it is on disk.
  prefs: []
  type: TYPE_NORMAL
- en: A quick examination of the code will reveal a Java class called DummyContent.
    As you will see, there is a TODO notice, pointing out that this class needs to
    be removed before publication, although, of course, it is quite possible simply
    to refactor it. The purpose of this file is to demonstrate how content can be
    defined. All that is required from us is to replace the placeholder array applied
    in the template with our own. This can, of course, take any form we choose, such
    as video or a web view.
  prefs: []
  type: TYPE_NORMAL
- en: Being able to start a project with ready-made code is very useful and can save
    us a great deal of time. However, there are many times when we might want to begin
    a project with a structure of our own that suits our purpose, and this may well
    not be one of those available via the IDE. Such a situation does not, however,
    prevent us from doing this, as code templates are available to us at any point
    and, as we shall see, it is even possible to create our own.
  prefs: []
  type: TYPE_NORMAL
- en: Custom templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine that you are developing a project that uses one of the templates we
    have already examined, but you would also like a login activity. Fortunately,
    this is easily managed using an already started project from within the IDE.
  prefs: []
  type: TYPE_NORMAL
- en: It is not obviously apparent that the project templates screen that we are presented
    with when starting a new project is available to us at any point. Simply select
    New | Activity | Gallery... from the project explorer's context-sensitive menu,
    and then choose the activity of your choice. You will then be presented with a
    customization screen, similar to those you have seen before, but with options
    to declare the parent and package, enabling us to use as many templates as we
    wish.
  prefs: []
  type: TYPE_NORMAL
- en: If you have visited the activity gallery, you will also have noted that these
    activities can also be selected directly and without having to open the gallery.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is not the whole story, as the same menu allows us to create and save
    our own templates. Opening the context-sensitive menu of a source code folder
    and selecting New | Edit File Templates... will open the following dialog:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/163e42a5-fc7b-4016-b9e5-88c90fbe49a1.png)'
  prefs: []
  type: TYPE_IMG
- en: The template editing wizard
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from the preceding screenshot, there are a good number of file
    templates available, as well as three other tabs. The Includes tab provides file
    headers and the Code tab contains smaller code units, many of which are useful
    during testing. The Other tab is of particular use and provides templates for
    larger application components, such as activities, fragments, manifests, layouts,
    and resources.
  prefs: []
  type: TYPE_NORMAL
- en: The + icon in the top left-hand corner allows us to create our own templates
    (but only from the first two tabs). At its simplest, one can simply paste code
    directly into the window provided. Once named and saved, this will then appear
    in the File | New menu or from project explorer directories directly.
  prefs: []
  type: TYPE_NORMAL
- en: Taking just a quick look at some of the built-in templates will immediately
    reveal the use of a placeholder variable in the form of `${VARIABLE}`. It is these
    placeholders that make customized template such a useful and flexible tool.
  prefs: []
  type: TYPE_NORMAL
- en: 'The easiest way to see how these variables work is to use one of the existing
    templates to take a look at how these placeholders are implemented; this is outlined
    in the following exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the Edit File Templates wizard, as described previously.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the Other tab, copy the code from the `Activity.java` entry.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new template with the + button, name it, and paste the code into the
    space provided.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Edit the code according to what you want, ensuring to include a custom variable,
    such as in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Click on OK to save the template, which will now appear in New menus.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, whenever you create an instance of this template, Android Studio will
    prompt you to enter any variables defined in the template placeholders:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a91a2bcf-ab6d-4401-b8d0-85ef9fbdb030.png)'
  prefs: []
  type: TYPE_IMG
- en: Generating a class from a template
  prefs: []
  type: TYPE_NORMAL
- en: All developers rely on code that they can use again and again, and although
    other IDEs provide code templates, the number of built-in structures and the ease
    of creation makes this Android Studio's biggest time-saving feature.
  prefs: []
  type: TYPE_NORMAL
- en: Third-party templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before moving on, we need to take a quick look at another way to access ready-made
    templates: third-party templates. There are many of these across the web, as a
    quick search will reveal. Many of the best of these are unfortunately not free,
    although many do offer free trials.'
  prefs: []
  type: TYPE_NORMAL
- en: Sites such as Softstribe and Envato offer highly developed templates for a large
    number of app types, such as radio streaming, restaurant booking, and city guides.
    These templates are mostly fully developed apps and require little more than configuring
    and customizing. Such an approach may not suit the seasoned developer, but if
    speed is your top priority and you have a budget for such things, these services
    offer powerful shortcuts to project completion.
  prefs: []
  type: TYPE_NORMAL
- en: Templates are not the only time-saving feature of Android Studio when it comes
    to providing ready-made code, and you will no doubt have noticed the many sample
    projects available through the IDE.
  prefs: []
  type: TYPE_NORMAL
- en: Project samples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although samples can be accessed from within the IDE from the sample browser,
    it is more usual to open one of these samples at the beginning of a project. This
    can be done from the welcome screen under Import an Android code sample. There
    are hundreds of these samples (and many more can be found online), and these are
    nicely grouped into categories in the sample browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like templates, samples can be used as a starting point for a bigger project,
    but they are also an education in, and of, themselves, as they are written by
    extremely knowledgeable developers and are wonderful examples of best practices:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a1208777-3180-4179-ab0b-dd9f535b4f20.png)'
  prefs: []
  type: TYPE_IMG
- en: The sample browser
  prefs: []
  type: TYPE_NORMAL
- en: As can be seen from the preceding sample browser, samples can not only be downloaded
    from the browser but can also be viewed in GitHub. As the reader will know, GitHub
    is a fantastic code repository of immense use to developers of all kinds, and
    it houses all the samples found in the samples browser; there are thousands of
    other Android projects, code libraries, and plugins. From a samples point of view,
    this resource is a great time saver, as it is much quicker to take a look at the
    code before deciding whether to download and build.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are so many samples, and they are all equally useful and instructive,
    making it difficult to select any one to examine here, although the Camera2 samples
    can be helpful to explore as this is one API that many developers may not have
    examined before. This is down to the following two factors:'
  prefs: []
  type: TYPE_NORMAL
- en: Very often, a camera functionality can be accessed simply by calling the native
    app (or one the user has installed) from within our own app.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Camera2 API is incompatible with devices running on API level 20 and lower.
    Unlike many APIs, there is no handy support library to make Camera2 backward-compatible
    beyond this.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Despite these drawbacks, if you are planning an app that focuses on capturing
    images and video, then you will need to build in all the functionalities yourself.
    This is where these samples can come in remarkably handy. The Camera2Basic sample
    is probably the best one to look at first.
  prefs: []
  type: TYPE_NORMAL
- en: 'The sample contains just three classes and a simple layout structure catering
    to both landscape and portrait orientations. The classes include a basic startup
    activity, an extended TextureView that resizes the area to be captured depending
    on the device it is running on, and a Fragment that does most of the work. All
    these classes are nicely commented and are pretty much self-explanatory, and a
    quick examination of the code is all that is required to understand its workings.
    Like other samples, Camera2Basic can be built and run without any further modifications:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8b74924c-123e-4ddb-909e-a32a14c83c9f.png)'
  prefs: []
  type: TYPE_IMG
- en: The Camera2Basic sample
  prefs: []
  type: TYPE_NORMAL
- en: All of the samples in the repository are equally useful, depending on your choice
    of project, and all of them are equally well written and instructive.
  prefs: []
  type: TYPE_NORMAL
- en: One of GitHub's most useful properties is the large number of third-party libraries
    available there, and when we take a closer look at the Gradle build process, we
    will see how these libraries can be included as dependencies from within Android
    Studio.
  prefs: []
  type: TYPE_NORMAL
- en: These are not the only useful tools available on GitHub, and GitHub is by no
    means the only source of such tools. As we have moved from UI development to coding,
    now is as good a time as any to take another look at some of the third-party plugins
    available for Android Studio.
  prefs: []
  type: TYPE_NORMAL
- en: Third-party plugins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is a large and growing number of third-party plugins available, making
    it difficult to select a fair sample. The following sections covers a small collection
    of plugins selected primarily for their general-purpose usefulness.
  prefs: []
  type: TYPE_NORMAL
- en: ADB Wi-Fi
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is a JetBrains plugin and so can be found using the Browse Repositories...
    button of the Plugins screen of the Settings dialog:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3a3fa2a5-bdf0-4f6a-8e83-d1574feeb5e3.png)'
  prefs: []
  type: TYPE_IMG
- en: The plugins dialog
  prefs: []
  type: TYPE_NORMAL
- en: This plugin simply allows us to debug our apps using a shared Wi-Fi connection.
    Despite its simplicity, this app is more than a cable-saving convenience, as it
    allows live debugging of many of the device's sensors that would be greatly restricted
    by being tethered to the host machine. Fitness and augmented reality apps can
    be tested with far more ease this way.
  prefs: []
  type: TYPE_NORMAL
- en: ADB Wi-Fi is very simple to set up and use, especially if your host and device
    already share a Wi-Fi connection and the device has been used for debugging before.
  prefs: []
  type: TYPE_NORMAL
- en: Most plugins are far more complex than this one, and many employ some very sophisticated
    technology, such as AI.
  prefs: []
  type: TYPE_NORMAL
- en: Codota
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A great deal is being made recently of advances in Artificial Intelligence,
    and while many such claims are overblown and pretentious, nevertheless there are
    some striking examples of a truly helpful AI available, and Codota is one such
    project.
  prefs: []
  type: TYPE_NORMAL
- en: Many developers will already be familiar with Codota as an online search tool
    or browser extension. As smart and useful that these tools are, Codota really
    comes into its own as an IDE plugin. It uses a smart and evolving AI system named
    **CodeBrain**. This code is based on a form of emergent programming known as **Example-Centric
    Programming**.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/07c59adf-13fc-40b6-a181-75d32eaacac1.png)'
  prefs: []
  type: TYPE_IMG
- en: Codota's CodeBrain
  prefs: []
  type: TYPE_NORMAL
- en: Technically, the Codota plugin is not really a plugin, as it has to be installed
    separately and runs in a window  not connected from the IDE. This is because it
    works with the Java IDE, not individual environments. This has several advantages,
    and one of them is the fact that the plugin is a Java plugin and not Android-specific,
    meaning that it will run on any version of Studio and (unlike some plugins) doesn't
    require waiting for updates.
  prefs: []
  type: TYPE_NORMAL
- en: The Android Studio Codota plugin runs as a separate application, which is something
    of an advantage. When turned on, it is seriously clever (and according to its
    algorithmic philosophy, getting cleverer by the second). The software claims to
    provide an intelligent coding assistant, and very often it does just that, and
    I would challenge anyone to not be impressed by its acumen. It has some flaws
    but more often than not, finds examples from a wide variety of online sources,
    including stackoverflow and GitHub, that are almost always useful.
  prefs: []
  type: TYPE_NORMAL
- en: Once downloaded and opened, simply open the IDE click on some code of interest,
    and Codota will, most likely, provide some quite lovely answers to any questions
    you might have. Imagine having an assistant that, although not very bright, is
    very knowledgeable and can scan all pertinent online code within seconds. This
    is Codota, and whether you use it as a browser extension, a search tool, or an
    IDE plugin, it is one of the better coding assistants available.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we have looked at two approaches to assisting the process
    of code development: ready-made code, and assistant plugins and add-ons. Templates
    are often a great way to get a project off the ground quickly, and class inspection
    plugins allow us to easily understand larger templates, without having to pore
    over reams of code.'
  prefs: []
  type: TYPE_NORMAL
- en: The other plugins we looked at in this chapter offered some different ways to
    make the task of app development easier and more fun. There are, of course, very
    many fantastic tools out there, and coding is continually becoming less monotonous
    and more creative.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter has focused on programming in Java, but as any developer knows
    this is by no means the only language available. Android Studio provides support
    for both C++ and Kotlin (the latter can even be included alongside Java code).
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter we will explore how to support other languages as well as
    taking a look at Android Things, which, although not another language, does require
    skill sets that many traditional developer may be unfamiliar with. Fortunately
    Android Studio provides tools that make developing for single-board computers
    very similar to developing other Android applications.
  prefs: []
  type: TYPE_NORMAL
