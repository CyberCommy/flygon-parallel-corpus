- en: Your First Java Project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, you learned quite a few things about Java, including
    its basic aspects, and main tools. Now, we are going to apply the knowledge acquired
    to complete and take the first step toward a real-life program—creating a Java
    project. We will show you how to write application code, how to test it, and how
    to execute the main code and its tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What is a project?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing and building application code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Executing and unit testing an application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Exercise: JUnit `@Before` and `@After` annotations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is a project?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's start with the definition and origin of the term project.
  prefs: []
  type: TYPE_NORMAL
- en: Definition and origin of project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The term *project*, according to an English by Oxford Dictionaries, is *an individual
    or collaborative enterprise that is carefully planned to achieve a particular
    aim*. The term was adopted by the designers of IDEs to mean the collection of
    files that compose an application. That is why the term project is often used
    as a synonym for an application, too.
  prefs: []
  type: TYPE_NORMAL
- en: Project-related terms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The files that constitute the project are stored in the directories of a filesystem.
    The top-most directory is called the *project root directory*, and the rest of
    the project directories form a tree underneath it. That's why a project can also
    be seen as a tree of directories that contain all of the `.java` files and other
    files that comprise the source code of an application and its tests. Non-Java
    files are usually called `resources`, and are stored in a directory with the same
    name.
  prefs: []
  type: TYPE_NORMAL
- en: Programmers also use the terms *source code tree*, *source code*, or just *source*,
    as synonyms for aproject.
  prefs: []
  type: TYPE_NORMAL
- en: When a project uses the classes of another project, they are packaged in a `.jar`
    file and usually constitute a *library* (a collection of, more or less, independent
    classes) or *framework* (a system of classes designed to work together in support
    of certain functionalities). The difference between a library and a framework
    does not affect how your project accesses its classes, so from now on, we will
    call all of the third-party `.jar` files used by the project libraries for brevity. 
    In the *Maven project configuration* section, we will show you how to access such
    libraries, if your code needs them.
  prefs: []
  type: TYPE_NORMAL
- en: A project's life cycle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Java project life cycle consists of the following phases (steps, stages):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Feasibility: when a determination is made on whether to proceed with the project
    or not'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Requirements-gathering and high-level design
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Class-level design:* the first phase of the development phases*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Project creation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing application code and its unit tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Project building: code compilation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing the source code in a remote repository and sharing it with other programmers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Project packaging: gathering `.class` files and all the supporting non-Java
    files into a `.jar` file that is commonly called a *project artifact* or just
    an *artifact*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Project installation: saving the artifact in a binary repository (also called
    *an* *artifactory*), from where it can be retrieved and shared among other programmers.
    This phase is the last one of the development phases'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Project deployment and execution in a test environment; placing the artifact
    into an environment where it can be executed and tested under the condition similar
    to production, *this is the testing phase*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Project deployment and execution in the production environment: *this is the
    first phase of the production (also called maintenance) phases*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Project enhancement and maintenance:fixing the defects and adding new features
    to the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shutting down the project after it is not needed anymore
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this book, we cover only four project phases:'
  prefs: []
  type: TYPE_NORMAL
- en: Project design (see [Chapter 8](2dc9b974-3d85-458b-ac71-a7fae4599a00.xhtml),
    *Object-Oriented Design (OOD) Principles*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Project creation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing application code and its unit tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Project building, which is a code compilation using the `javac` tool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will show you how to perform all these phases using the IntelliJ IDEA Community
    edition, but similar procedures are available with other IDEs, too.
  prefs: []
  type: TYPE_NORMAL
- en: To build the project, IDE uses Java Compiler (the `javac` tool) and a dependency
    managing tool. The latter sets the values of the `-classpath` option in the `javac` and `java` commands.
    The three most popular dependency managing tools are Maven, Gradle, and Ant. IntelliJ
    IDEA has a built-in Maven capability and does not require installing an external
    dependency managing tool.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are several ways to create a project in IntelliJ IDEA (or any other IDE,
    for that matter):'
  prefs: []
  type: TYPE_NORMAL
- en: Using a project wizard (see the *Creating a project using a project wizard* section)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading the existing source code from the filesystem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading the existing source code from the source-control system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this book, we will walk you through the first option only—using a project
    wizard. The other two options are just point-and-read, in one step, and do not
    require much of an explanation. After you learn how to create a project manually,
    you will understand what happens behind the scenes, during the automatic creation
    from the existing source.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a project using a project wizard
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you start IntelliJ IDEA except for the first time, it will show you a
    list of already created projects. Otherwise, you will see the following screen
    only:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d9c1ca00-c44a-4df6-a758-41466300cb6b.png)'
  prefs: []
  type: TYPE_IMG
- en: The three options – Import Project, Open, and Check out from Version Control –
    allow you to work on an existing project. We are not going to use them in this
    book.
  prefs: []
  type: TYPE_NORMAL
- en: Click the Create New Project link, which brings you to the first screen of the
    project-creation wizard. Choose Java in the upper-left corner, then click the
    New button in the upper-right corner, and select the location of the JDK installed
    on your computer. After that, click the OK button in the bottom-right corner.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the next window, do not select anything, and just click the Next button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/61ba60bf-f3e7-4947-b186-8ce954d1be64.png)'
  prefs: []
  type: TYPE_IMG
- en: You don't see the  Next button in the preceding screenshot because it is at
    the bottom of the actual screen, and the rest is empty space, which we decided
    not to show here.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the next screen, enter the project name (typically, your application name)
    in the upper field, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1421815e-24de-4e39-8cec-9bba0f4fd9f9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'For our demo code, we have chosen the project (application) name to be `javapath`, in
    the sense of the path to the Java programming. Click the Finish button at the
    bottom of the preceding screen, and you should see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/25b5df1f-4238-4be3-8534-e105e42805bc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you don''t see the project structure in the left pane, click View (in the
    top-most menu), then Tool Windows, then Project, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e275f861-da88-4088-a94a-f662403384f7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now you should be able to see the project structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5ee3b110-40db-43bf-9b63-d774581d76ff.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The preceding project includes:'
  prefs: []
  type: TYPE_NORMAL
- en: The `.idea` directory that holds the IntelliJ IDEA settings for your project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `src` directory, with subdirectories:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`main`, which will hold your application files in its `java` subdirectory (for
    `.java` files) and `resources` subdirectory (for other types of files),'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`test`, which will hold the tests for your application in its `java` (for `.java` files)
    and the `resources` subdirectory (for other types of files).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `javapath.iml` file, which is another IntelliJ IDEA file with project configurations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `External Libraries` directory, which holds all of the libraries your project
    is using
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the preceding screenshot, you can also see the `pom.xml` file. This file
    is used to describe other libraries your code requires. We will explain how to
    use it in the *Maven project configuration* section. IDE generated it automatically,
    because in the previous chapter, while configuring the IDE, we indicated our desire
    to integrate with Maven in the IDE default settings. If you have not done that,
    you can now right-click on the project name (`JavaPath`, in our case) and select
    Add Framework Support:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fd6fe0b9-d54c-462c-b45c-d40a1e40db73.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, you will be presented with the screen where you can select Maven:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4ab050c6-5a58-44be-8f58-756afa545957.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Click the OK button, and the `pom.xml` file will be created. The same steps
    should be followed if the `pom.xml` file does not have the Maven symbol, as in
    the preceding screenshots. Here is how it looks after Maven support is added:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9cf1a0bf-2b97-459f-9abe-2fb46d64cc2a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Another way to trigger `pom.xml` creation is to respond to a small window in
    the lower-right corner that pops up with various suggestions, including Add as
    Maven Project (it means that the code dependencies are going to be managed by
    Maven):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ad8b0ad0-e94e-465c-b8d6-ed44567a3de9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you have missed clicking the preceding link, you can still recover the suggestion
    by clicking the link at the bottom line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/20cf88b3-d22d-42b9-bdf5-9096150d0c7c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'It will bring the suggestion back into the bottom-left corner of the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ddd94b75-8dde-4477-9f1f-d7d8b59d5888.png)'
  prefs: []
  type: TYPE_IMG
- en: Click on the Add as Maven Project link, and the `pom.xml` file will be created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another helpful suggestion looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cfc6d2f8-2f92-4f4c-8829-2911c6e9ca5a.png)'
  prefs: []
  type: TYPE_IMG
- en: We recommend that you click the Enable Auto-Import link. It will allow IDE to
    support your project even better, by relieving you from having to do certain things
    manually.
  prefs: []
  type: TYPE_NORMAL
- en: If none of the preceding methods work for you, it is always possible to create
    the `pom.xml` file manually. Just right-click on the project name (`JavaPath`)
    in the left pane, select New, select File, then type the filename, `pom.xml`,
    and click the OK button.
  prefs: []
  type: TYPE_NORMAL
- en: Maven project configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have already mentioned, Maven helps to compose the `javac` and `java` commands when
    you compile and run your application. It sets the value of the `-classpath` option.
    To accomplish it, Maven reads the list of libraries your project needs from `pom.xml`.
    It is your responsibility to correctly specify these libraries. Otherwise, Maven
    will not be able to find them.
  prefs: []
  type: TYPE_NORMAL
- en: By default, the `pom.xml` file is located in the project root directory. That
    is also the directory where IDE runs the `javac` command and sets the `src/main/java` directory
    on the classpath so that `javac` can find the source files of your project. It
    puts the compiled `.class` files in the `target/classes` directory into the root
    directory too, and sets this directory on the classpath while executing the `java` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another function of `pom.xml` is to describe your project so that it can be
    uniquely identified among all other projects on your computer, and even among
    all other projects on the internet. That is what we are going to do now. Let''s
    look inside the `pom.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ede91dcf-6317-495e-a25a-978535dca95c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can see the three XML tags that identify your project:'
  prefs: []
  type: TYPE_NORMAL
- en: '`groupId` identifies a group of projects within an organization or an open
    source community'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`artifactId` identifies a particular project within the group'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`version` identifies the version of the project'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The value set in the `groupId` tag has to follow the package-naming convention,
    so now, we need to explain what a package is. A package is the biggest structural
    unit of the Java application. Each package groups related Java classes. Two different
    classes in different packages can have the same name. That's why a package is
    also called a namespace.
  prefs: []
  type: TYPE_NORMAL
- en: The package name has to be unique. It enables us to identify a class correctly,
    even when a class with the same name exists in other packages listed on the classpath.
    The package can have several subpackages. They are organized in a hierarchy similar
    to the directory structure of a filesystem. The package that contains all the
    other packages is called a top-level package. Its name is used as the `groupId` tag
    value of the `pom.xml` file.
  prefs: []
  type: TYPE_NORMAL
- en: The package-naming convention requires that the top-level package name is based
    on the internet domain name (in reverse order) of the organization that created
    the package. For example, if the domain name is `oracle.com`, then the top-level
    package name has to be `com.oracle` followed by (after a dot, `.`) the project
    name. Alternatively, a subdomain, a department name, or any other project group
    can be inserted between the reversed domain name and project name. Then, other
    subpackages follow.
  prefs: []
  type: TYPE_NORMAL
- en: Many packages of JDK standard libraries, start with `jdk`, `java`, or `javax`,
    for example. But the best practice is to follow the described naming convention
    defined in section $6.1 of the Java Specification ([https://docs.oracle.com/javase/specs](https://docs.oracle.com/javase/specs)).
  prefs: []
  type: TYPE_NORMAL
- en: Selecting a unique package name may be problematic when an open source project
    starts without any organization in mind. In such cases, programmers often use
    `org.github.<author's name>` or something similar.
  prefs: []
  type: TYPE_NORMAL
- en: In our project, we have a top-level `com.packt.javapath` package. By doing so,
    we took a bit of a risk, because another Packt author may decide to start the
    packages with the same name. It would be better to start our packages with `com.packt.nicksamoylov.javapath`.
    This way, the author's name would resolve the possible conflict, unless, of course,
    another author with the same name starts writing Java books for Packt. But, we
    decided to take the risk for brevity. Besides, we do not think that the code we
    are creating in this book will be used by another project.
  prefs: []
  type: TYPE_NORMAL
- en: So, the `groupId` tag value for our project will be `com.packt.javapath`.
  prefs: []
  type: TYPE_NORMAL
- en: The `artifactId` tag value is typically set to the project name.
  prefs: []
  type: TYPE_NORMAL
- en: The `version` tag value contains the project version.
  prefs: []
  type: TYPE_NORMAL
- en: The `artifactId` and `version` are used to form a `.jar` filename during the
    project packaging. For example, if the project name is `javapath` and the version
    is `1.0.0`, the `.jar` filename will be `javapath-1.0.0.jar`.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, our `pom.xml` will now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7101640e-2074-4130-82b3-97ef4adedbc0.png)'
  prefs: []
  type: TYPE_IMG
- en: Notice the `-SNAPSHOT` suffix in the version. Its usefulness becomes apparent
    only when you are going to share the same project with other programmers. But
    we will explain it now, so that you understand the purpose of this value. When
    an artifact of a project (a `.jar` file) is created, its name will be `javapath-1.0-SNAPSHOT.jar`.
    The presence of `-SNAPSHOT` in the filename indicates that it is a work in progress
    and the code is changing from build to build. This way, other Maven-managed projects that
    use your artifact will download it every time a timestamp on the `.jar` file changes.
  prefs: []
  type: TYPE_NORMAL
- en: When the code stabilizes and the changes become rare, you can set the version
    value to `1.0.0` and change it only when the code changes and a new project version
    is released—`javapath-1.0.0.jar`, `javapath-1.0.1.jar`, or `javapath-1.2.0.jar`,
    for example. Then, a other projects that use the javapath `.jar` file do not download
    a new file version automatically. Instead, the programmers of another projects
    can read the release notes of each new version and decide whether to use it or
    not; a new version may introduce changes that are not desirable, or are incompatible
    with their application code. If they decide they need a new version, they set
    it in the `pom.xml` file in the `dependencies` tag of their project, and Maven
    downloads it for them.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our `pom.xml` file, there is no `dependencies` tag yet. But it can be placed
    anywhere inside of the `<project>...</project>` tags. Let''s look at a few examples
    of dependencies in a `pom.xml` file. We can add them to the project now, because
    we are going to use them later, anyway:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: <dependencies>
  prefs: []
  type: TYPE_NORMAL
- en: <dependency>
  prefs: []
  type: TYPE_NORMAL
- en: <groupId>org.junit.jupiter</groupId>
  prefs: []
  type: TYPE_NORMAL
- en: <artifactId>junit-jupiter-api</artifactId>
  prefs: []
  type: TYPE_NORMAL
- en: <version>5.1.0-M1</version>
  prefs: []
  type: TYPE_NORMAL
- en: </dependency>
  prefs: []
  type: TYPE_NORMAL
- en: <dependency>
  prefs: []
  type: TYPE_NORMAL
- en: <groupId>org.postgresql</groupId>
  prefs: []
  type: TYPE_NORMAL
- en: <artifactId>postgresql</artifactId>
  prefs: []
  type: TYPE_NORMAL
- en: <version>42.2.2</version>
  prefs: []
  type: TYPE_NORMAL
- en: </dependency>
  prefs: []
  type: TYPE_NORMAL
- en: <dependency>
  prefs: []
  type: TYPE_NORMAL
- en: <groupId>org.apache.commons</groupId>
  prefs: []
  type: TYPE_NORMAL
- en: <artifactId>commons-lang3</artifactId>
  prefs: []
  type: TYPE_NORMAL
- en: <version>3.4</version>
  prefs: []
  type: TYPE_NORMAL
- en: </dependency>
  prefs: []
  type: TYPE_NORMAL
- en: </dependencies>
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: The first `org.junit.jupiter` dependency refers to a `junit-jupiter-api-5.1.0-M1.jar`
    file that contains the `.class` files necessary for writing tests. We will use
    it in the next section, *Writing an application code and tests*.
  prefs: []
  type: TYPE_NORMAL
- en: The second `org.postgresql` dependency refers to a `postgresql-42.2.2.jar` file
    that allows us to connect and work with the PostgreSQL database. We will use this
    dependency in [Chapter 16](d77f1f16-0aa6-4d13-b9a8-f2b6e195f0f1.xhtml), *Database
    Programming*.
  prefs: []
  type: TYPE_NORMAL
- en: The third dependency refers to the `org.apache.commons` file, `commons-lang3-3.4.jar`,
    that contains many small, very useful methods called utilities, some of which
    we are going to use generously, for various purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each of these `.jar` files is stored in a repository on the internet. By default,
    Maven will search its own central repository, located at [http://repo1.maven.org/maven2](http://repo1.maven.org/maven2).
    The vast majority of the libraries you need are stored there. But in the rare
    case that you need to specify other repositories—in addition to the Maven central
    one—you can do it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: <repositories>
  prefs: []
  type: TYPE_NORMAL
- en: <repository>
  prefs: []
  type: TYPE_NORMAL
- en: <id>my-repo1</id>
  prefs: []
  type: TYPE_NORMAL
- en: <name>your custom repo</name>
  prefs: []
  type: TYPE_NORMAL
- en: <url>http://jarsm2.dyndns.dk</url>
  prefs: []
  type: TYPE_NORMAL
- en: </repository>
  prefs: []
  type: TYPE_NORMAL
- en: <repository>
  prefs: []
  type: TYPE_NORMAL
- en: <id>my-repo2</id>
  prefs: []
  type: TYPE_NORMAL
- en: <name>your custom repo</name>
  prefs: []
  type: TYPE_NORMAL
- en: <url>http://jarsm2.dyndns.dk</url>
  prefs: []
  type: TYPE_NORMAL
- en: </repository>
  prefs: []
  type: TYPE_NORMAL
- en: </repositories>
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Read the Maven guides for more details on Maven at [http://maven.apache.org/guides](http://maven.apache.org/guides).
  prefs: []
  type: TYPE_NORMAL
- en: With the `pom.xml` file configured, we can start writing code for our first
    application. But before that, we would like to mention how you can customize the
    configuration of IntelliJ IDEA to match your preferences for the look and feel
    and other features of the IDE.
  prefs: []
  type: TYPE_NORMAL
- en: Changing IDE settings at any time
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can change IntelliJ IDEA settings and project configuration any time, to
    adjust the appearance and behavior of the IDE to the style most comfortable for
    you. Take your time and see what you can set on each of the following configuration
    pages.
  prefs: []
  type: TYPE_NORMAL
- en: 'To change the configuration of IntelliJ IDEA itself:'
  prefs: []
  type: TYPE_NORMAL
- en: 'On Windows: click File on the top-most menu, then select Settings'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On Linux and macOS: click IntelliJ IDEA on the top-most menu, then select Preferences
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The configuration screen that you access will look similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d957132c-f95f-4808-8c69-af37ff21b84c.png)'
  prefs: []
  type: TYPE_IMG
- en: Click around and see what you can do here, so that you know the possibilities
    of your IDE.
  prefs: []
  type: TYPE_NORMAL
- en: To change project specific settings, click File, then select Project Structure,
    and see the available settings and options. Notice that the same screen can be
    accessed by right-clicking on the project name (in the left pane) and then selecting
    Open Module Settings.
  prefs: []
  type: TYPE_NORMAL
- en: After you have established your own style and know your preferences, you can
    set them as the default settings for the IDE configuration via File | Other Settings |
    Default Settings.
  prefs: []
  type: TYPE_NORMAL
- en: The default project structure can be also set via File | Other Settings | Default
    Project Structure. These default settings will be applied automatically, every
    time you create a new project.
  prefs: []
  type: TYPE_NORMAL
- en: With that out of our way, we can start writing our application code.
  prefs: []
  type: TYPE_NORMAL
- en: Writing an application code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is the most interesting activity of a programmer's profession. And that
    is the purpose of this book – to help you write Java code well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the requirements for your first application. It should take
    an integer number as an input, multiply it by `2`, and print the result in the
    following format: `<the input number> * 2 = <result>`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s come up with the design. We will create the `SimpleMath` class
    with the `multiplyByTwo(int i)` method that will accept an integer and return
    the result. This method will be called by the `main()` method of the `MyApplication` class.
    The `main()` method should:'
  prefs: []
  type: TYPE_NORMAL
- en: Receive an input number from a user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pass the input value into the `multiplyByTwo(int i)` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get back the result
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Print it on a screen in the required format
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will also create tests for the `multiplyByTwo(int i)` method, to make sure
    that the code we have written works correctly.
  prefs: []
  type: TYPE_NORMAL
- en: We will start by creating directories that will hold our `.java` files. The
    directory path must match the package name of each class. We have talked about
    a package already, and set the top-level package name as a `groupId` value. Now,
    we will describe how to declare it in the `.java` files.
  prefs: []
  type: TYPE_NORMAL
- en: Java package declaration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Package declaration is the first line of any Java class. It starts with the
    `package` keyword, followed by the package name. The `javac` and `java` tools
    search for a class on a classpath using a fully qualified class name, which is
    a class name with the package name appended in front of it. For example, if we
    put the `MyApplication` class in the `com.packt.javapath.ch04demo` package, the
    fully qualified name of this class will be `com.packt.javapath.ch04demo.MyApplication`.
    As you could guess, `ch04demo` stands for the *demo code* of Chapter 4\. This
    way, we can use the same class name in different chapters, and they will not clash.
    That is how the package name serves the purpose of unique identification of a
    class on a classpath.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another function of the package is to define the location of the `.java` files,
    relative to the `src\main\java` directory (for Windows) or the `src/main/java` directory
    (for Linux). The package name must match the path to the files that belong to
    this package:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: src\main\java\com\packt\javapath\ch04demo\MyApplication.java (for Windows)
  prefs: []
  type: TYPE_NORMAL
- en: src/main/java/com/packt/javapath/ch04demo/MyApplication.java (for Linux)
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Any mismatch between the package name and the file location triggers a compilation
    error. When you create a new class using an IDE wizard (after right-clicking on
    the package name), IDE adds the correct package declaration as the first line
    of the `.java` file automatically. But if you create a new source file without
    using IDE, then it is your responsibility to match the package name and the `.java`
    file location.
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to not have a package name declared if the `.java` file resides
    in the `src\main\java` directory (for Windows) or the `src/main/java` directory
    (for Linux). Java specification calls such a package a default package. Using
    the default package is practical for only a small or temporary application, because
    as the number of classes grows, a flat list of a hundred, or even a thousand,
    files becomes unmanageable. Besides, if you write code to be used by other projects,
    these other projects will not be able to refer to your classes without a package
    name. In [Chapter 7](c33d6d65-074b-49cb-b013-f7157eb70816.xhtml), *Packages and
    Accessibility (Visibility)*, we will talk more about this.
  prefs: []
  type: TYPE_NORMAL
- en: 'The directory tree of the `.class` files is created by the `javac` tool during
    compilation, and it mirrors the directory structure of the `.java` files. Maven
    creates a `target` directory in the project root directory with a `classes` subdirectory
    in it. Maven then specifies this subdirectory as the output location of the generated
    files, with a `-d` option in the `javac` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: '//For Windows:'
  prefs: []
  type: TYPE_NORMAL
- en: javac -classpath src\main\java -d target\classes
  prefs: []
  type: TYPE_NORMAL
- en: com.packt.javapath.ch04demo.MyApplication.java
  prefs: []
  type: TYPE_NORMAL
- en: '//For Linux:'
  prefs: []
  type: TYPE_NORMAL
- en: javac -classpath src/main/java -d target/classes
  prefs: []
  type: TYPE_NORMAL
- en: com.packt.javapath.ch04demo.MyApplication.java
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'During the execution, the `.class` files'' location is set on the classpath:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: '//For Windows:'
  prefs: []
  type: TYPE_NORMAL
- en: java -classpath target\classes com.packt.javapath.ch04demo.MyApplication
  prefs: []
  type: TYPE_NORMAL
- en: '//For Linux:'
  prefs: []
  type: TYPE_NORMAL
- en: java -classpath target/classes com.packt.javapath.ch04demo.MyApplication
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: With the knowledge of the package declaration, its function, and its relation
    with the directory structure, let's create our first package.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We assume that you have created the project by following the steps in the *Creating
    a project using a project wizard* section. If you have closed your IDE, please
    start it again, and open the created project by selecting `JavaPath` in the list
    of Recent projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the project is open, click on the `src` folder in the left pane, then click
    on the `main` folder. You should see the `java` folder now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7f2a3362-e71f-4b18-b321-994848eff558.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Right-click on the `java` folder, select the New menu item, and then select
    the Package menu item:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/12d9f974-ec53-408e-a288-edc7b25dca93.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Type `com` in the pop-up window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6bf9e2d4-2ca4-4d79-8073-f976cff359bb.png)'
  prefs: []
  type: TYPE_IMG
- en: Click the OK button. The `com` folder will be created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Right-click on it in the left pane, select the New menu item, then select the
    Package menu item, and type `packt` in the pop-up window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8bc316e8-3f10-4edf-9fff-2b5784b465cf.png)'
  prefs: []
  type: TYPE_IMG
- en: Repeat the process and create the `javapath` folder under the `packt` folder,
    and then the `ch04demo` folder under the `javapath` folder. After the `com.packt.javapath.ch04demo` package
    is in place,  we can create its member—the `MyApplication` class.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the MyApplication class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create a class, right-click on the `com.packt.javapath.che04demo` package
    in the left pane, select the New menu item, then select the Java Class menu item,
    and type `MyApplication` in the pop-up window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/12cce37d-6bdc-4d61-a9a2-3a990766a9a5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Click the OK button, and the class will be created:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c6371bf2-f8d5-44dc-a830-12f4c166a782.png)'
  prefs: []
  type: TYPE_IMG
- en: The name of the `MyApplication` class in the right pane is faded. That is how
    IntelliJ IDEA indicates that it is not used anywhere yet.
  prefs: []
  type: TYPE_NORMAL
- en: Building the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Behind the scenes, the IDE compiles the code you are writing every time you
    change it. For example, try to remove the first letter, `M`, in the name of the
    class in the right pane. IDE will immediately warn you about the syntax error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/df804b66-9c28-487f-84ec-a9d3ca2b67d1.png)'
  prefs: []
  type: TYPE_IMG
- en: If you navigate your mouse to the red bubble, or any red line that underscores
    the class declaration in the preceding screenshot, you will see the Class 'yApplication'
    is public, should be declared in a file named 'yApplication.java' message. You
    may recall that we talked about it in [Chapter 2](4eaa4fe6-9564-40ba-b799-7fdc2abb5039.xhtml),
    *Java Language Basics.*
  prefs: []
  type: TYPE_NORMAL
- en: Each `.java` file contains only one `public` class. The file name must match
    the public class name.
  prefs: []
  type: TYPE_NORMAL
- en: Because IDE compiles the code after every change, in the case of a small number
    of `.java` files, building a project explicitly is not necessary. But when the
    size of the application increases, you might not notice that something went wrong.
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s why it is a good practice to request IDE to recompile (or build, in
    other words) all of the `.java` files of your application from time to time, by
    clicking Build in the top-most menu and selecting the Rebuild Project menu item:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a1f2f3c7-e8e0-463c-9ef4-366adf39fdc4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You may have noticed other related menu items: Build Project and Build Module
    ''javapath''. A module is a way to bundle classes across packages. But using modules
    is outside the scope of this book. Build Project recompiles only the classes that
    have been changed, and those that use the changed classes. It makes sense to only
    use it for a very big application, when the build time is significant. Rebuild
    Projects, on the other hand, recompiles all of the `.java` files, whether they
    were changed or not, and we recommend that you always use it. That way, you can
    be sure that every class is rebuilt, and no dependency was missed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'After you click on Rebuild Projects, you will see a new `target` folder appear
    in the left pane:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eace96bb-ca9f-452d-b0fb-c24037973683.png)'
  prefs: []
  type: TYPE_IMG
- en: That is where Maven (and the built-in Maven used by IntelliJ IDEA) stores the
    `.class` files. You may have noticed that the `javac` tool creates a folder for
    each part of the package name. That way, the tree of compiled classes reflects
    exactly the tree of the source classes.
  prefs: []
  type: TYPE_NORMAL
- en: Now, before continuing code writing, we are going to perform a trick that will
    make your source tree look simpler.
  prefs: []
  type: TYPE_NORMAL
- en: Hiding some files and directories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you prefer not to see the IDE-specific files (`.iml` files, for example)
    or temporary files and directories (the `target` folder, for example), you can
    configure IntelliJ IDEA to not show them. Just click on File | Settings (on Windows)
    or IntelliJ IDEA | Preferences (on Linux and macOS), then click the Editor menu
    item in the left column, and then File Types. The resulting screen will have the
    following section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/182f27f3-539a-4f24-b9aa-4fc65604cd81.png)'
  prefs: []
  type: TYPE_IMG
- en: 'At the bottom of the screen, you can see the Ignore files and folders label
    and the input field with the file name patterns. Add the following to the end
    of the list: `*.iml;.idea;target;`. Then, click the OK button. Now, your project
    structure should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f17e89e1-be92-4df8-972a-f1c5e0d93a20.png)'
  prefs: []
  type: TYPE_IMG
- en: It shows only the application source files and third-party libraries (under
    External Libraries).
  prefs: []
  type: TYPE_NORMAL
- en: Creating the SimpleMath class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's now create another package, `com.packt.javapath.math`, and the `SimpleMath` class
    in it. The reason for this is that in the future, we plan to have several, similar
    math-related classes in this package, and other, non-math-related classes in other
    packages.
  prefs: []
  type: TYPE_NORMAL
- en: In the left pane, right-click on the `com.packt.javapath.ch04demo` package, select
    New, then click Package. Type `math` in the provided input field, and click the
    OK button.
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on the `math` package name, select New, then click Java Class, type
    `SimpleMath` in the provided input field, and click the OK button.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should have created a new `SimpleMath` class that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/45202168-ee23-40e7-9910-2122a88846bd.png)'
  prefs: []
  type: TYPE_IMG
- en: Creating methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we add the following method to the `SimpleMath` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public int multiplyByTwo(int i){
  prefs: []
  type: TYPE_NORMAL
- en: return i * 2;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can add the code that uses the preceding method to the `MyApplication`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public static void main(String[] args) {
  prefs: []
  type: TYPE_NORMAL
- en: int i = Integer.parseInt(args[0]);
  prefs: []
  type: TYPE_NORMAL
- en: SimpleMath simpleMath = new SimpleMath();
  prefs: []
  type: TYPE_NORMAL
- en: int result = simpleMath.multiplyByTwo(i);
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(i + " * 2 = " + result);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: The preceding code is pretty straightforward. The application receives an integer
    as an input parameter from the first element of the `String[] args` input array.
    Notice that the first element in the Java array has the index 0, not 1\. The argument
    comes as a string, and has to be converted (parsed) to an `int` type by using
    the `parseInt()` static method of the `java.lang.Integer` class from a standard
    Java library. We will talk about Java types in [Chapter 5](ddf91055-8610-4b8c-acc5-453cfa981760.xhtml),
    *Java Language Elements and Types*.
  prefs: []
  type: TYPE_NORMAL
- en: Then, an object of the `SimpleMath` class is created, and the `multiplyByTwo()` method
    is called. The returned result is stored in the `result` variable of the `int` type,
    and then printed out in the required format using the `java.lang.System` class
    of a standard Java library. This class has an `out` static property that holds
    a reference to an object of the `java.io.PrintStream` class. The `PrintStream` class,
    in turn, has the `println()` method, which prints the result to a screen.
  prefs: []
  type: TYPE_NORMAL
- en: Executing and unit testing an application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are several ways to execute our new application. In the *Building the
    application* section, we saw that all of the compiled classes are stored by IntelliJ
    IDEA (using the built-in Maven) in the `target` folder. This means that we can
    execute the application by using the `java` tool and listing the folder target
    with the `-classpath` option.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do that, open a Command Prompt or Terminal window and go to the root directory
    of our new project. If you are not sure where it is, look at the top line of the
    IntelliJ IDEA window that shows the full path to it. Once you are in the project
    root directory (it is the folder where the `pom.xml` file is located), run the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dad25f60-410a-4c64-9847-d83b2932c7f5.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding screenshot, you can see that the `-classpath` option (we used
    the short version, `-cp`, instead) has listed the directory where all of the classes
    are compiled. After that, we have typed the name of the `com.packt.javapath.ch04demo.MyApplication` main
    class, because we have to tell the `java` tool which class is an entry point to
    the application and contains the `main()` method. Then, we have typed `2` as an
    input parameter to the main class. As you may recall, the `main()` method expects
    it to be an integer.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we run that command, the result shows the output in the expected format:
    `2 * 2 = 4`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, we could collect all of the compiled classes in a `myapp.jar`
    file and run a similar `java` command with the `myapp.jar` file listed on the
    classpath:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/68445744-4225-4d7a-a13a-b29e1f44445e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the preceding screenshot, you can see that we entered the `target` folder
    and its `classes` subfolder first, then collected its content (all of the compiled
    classes) into the `myapp.jar` file with the `jar` command. Then, we typed the `java` command
    and listed the `myapp.jar` file with the `-classpath` option. Since the `myapp.jar` file
    is in the current directory, we do not include any directory path. The result
    of the `java` command was the same as before: `2 * 2 = 4`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way to get to the project root directory is to just open a terminal
    window from IDE. In IntelliJ IDEA, you can do it by clicking on the Terminal link
    in the bottom-left corner:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b634572c-f39d-48af-9664-10a12682bd46.png)'
  prefs: []
  type: TYPE_IMG
- en: Then, we can type all of the preceding commands in the Terminal window inside
    the IDE.
  prefs: []
  type: TYPE_NORMAL
- en: But there is an even easier way to execute the application from the IDE without
    typing all of the preceding commands, which is the recommended way during the
    project development phase. It is your IDE, remember? We will demonstrate how to
    do it in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Executing the application using the IDE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to be able to execute an application from the IDE, some configuration
    has to be set the first time. In IntelliJ IDEA, if you click on the top-most menu
    item, click Run, and select Edit Configurations..., you will see the following
    screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/57ee7aff-829c-47f4-a2c3-b3c1153ff62d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Click the plus (+) symbol in the upper-left corner, and type the values in
    the new window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4e6536d9-cea0-4cea-a7d5-c70c4db164f3.png)'
  prefs: []
  type: TYPE_IMG
- en: Type `MyApplication` (or any other name you like) in the Name field.
  prefs: []
  type: TYPE_NORMAL
- en: Type `com.packt.javapath.ch02demo.MyApplication` in the Main class field.
  prefs: []
  type: TYPE_NORMAL
- en: Type `2` (or any other number you like) in the Program arguments field.
  prefs: []
  type: TYPE_NORMAL
- en: Check the Single instance only checkbox in the upper-right corner. It will ensure
    that you will have only one instance of your application running at all times.
  prefs: []
  type: TYPE_NORMAL
- en: After filling in all the described values, click the OK button in the bottom-right
    corner.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if you open the `MyApplication` class, you will see two green arrows –
    one at the class level, and another at the `main()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/44313d36-8ea3-40bf-bd74-ce920ac2a46d.png)'
  prefs: []
  type: TYPE_IMG
- en: Click on any of these green arrows, and your application will be executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The result will be shown in the bottom-left corner of IntelliJ IDEA. A window
    with the title Run will open, and you will see the result of the application execution.
    If you have typed `2` in the Program arguments field, the result should be the
    same: `2 * 2 = 4`.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a unit test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, let's write a test for the `multiplyByTwo()` method of the `SimpleMath` class,
    because we would like to make sure that the `multiplyByTwo()` method works as
    expected. Such tests are useful as long as the project exists, because you can
    run them every time the code is changed, and verify that the existing functionality has
    not been changed accidentally.
  prefs: []
  type: TYPE_NORMAL
- en: A method is the smallest testable part of an application. That's why such a
    test is called a unit test. It is a good idea to have a unit test for each method
    that you create (except the trivial ones, such as getters and setters, for example).
  prefs: []
  type: TYPE_NORMAL
- en: We will use a popular test framework called JUnit. There are several versions
    of it. At the time of this writing, version 5 is the latest one, but versions
    3 and 4 are still actively used. We will use version 5\. It requires Java 8 or
    later, and we assume that on your computer, you have installed Java 9, at least.
  prefs: []
  type: TYPE_NORMAL
- en: As we have already mentioned, in order to use a third-party library or a framework,
    you need to specify it as a dependency in the `pom.xml` file. As soon as you do
    it, the Maven tool (or the built-in Maven feature of the IDE) will look for the
    corresponding `.jar` file in the Maven repository online. It will download that
    `.jar` to your local Maven repository in the `.m2` folder, which was automatically
    created in the home directory on your computer. After that, your project can access
    it and use it at any time.
  prefs: []
  type: TYPE_NORMAL
- en: We have already set values in `pom.xml` for the dependency on JUnit 5 in the *Maven
    project configuration* section. But, let's assume that we have not done it yet,
    in order to show you how programmers usually do it.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you need to do some research and decide which framework or library you
    need. For example, after searching the internet, you may have read JUnit 5 documentation
    ([http://junit.org/junit5](http://junit.org/junit5)) and figured that you need
    to set the Maven dependency on `junit-jupiter-api`. With that, you can search
    the internet again, and this time, look for `maven dependency junit-jupiter-api`,
    or just `maven dependency junit 5`. Chances are, the first link in your search
    results will bring you to the following page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/25e23750-6422-4a3e-adfc-297ea4cd2aff.png)'
  prefs: []
  type: TYPE_IMG
- en: Select any version you like (we have chosen the latest, 5.1.0-M1) and click
    on it.
  prefs: []
  type: TYPE_NORMAL
- en: 'A new page will be opened, which tells you how to set the dependency in `pom.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3c580196-a134-452e-a96d-b7e352f511d9.png)'
  prefs: []
  type: TYPE_IMG
- en: Alternatively, you can go to the Maven repository site ([https://mvnrepository.com](https://mvnrepository.com))
    and type `junit-jupiter-api` in its search window. Then, click on one of the provided
    links, and you will see the same page.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you did not add the `junit-jupiter-api` dependency while reading the [Chapter
    3](18c6e8b8-9d8a-4ece-9a3f-cd00474b713e.xhtml), *Your Development* Environment
    *Setup*, you can do it now by copying the provided dependency into your `pom.xml`
    file inside the `<dependencies></dependencies>` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1a19f2bc-aebf-42ee-aefd-43d8f4c3e9c7.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, you can use the JUnit framework to create a unit test.
  prefs: []
  type: TYPE_NORMAL
- en: In IntelliJ IDEA, the `junit-jupiter-api-5.1.0-M1.jar` file is also listed in
    the `External Libraries` folder, in the left pane. If you open the list, you will
    see that there are two other libraries that were not specified in the `pom.xml` file: `junit-latform-commons-1.0.0-M1.jar` and `opentest4j-1.0.0.jar`.
    They are there because `junit-jupiter-api-5.1.0-M1.jar` depends on them. That
    is what Maven does—it discovers all of the dependencies and downloads all necessary
    libraries.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can create a test for the `SimpleMath` class. We will use IntelliJ
    IDEA to do it. Open the `SimpleMath` class and right-click on the class name,
    then select  Go To, and click on Test:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2432ae77-367c-4583-8688-33a3955ee126.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You will get a small pop-up window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a8498649-3985-495c-aee9-94585cd58e4d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on Create New Test... and the following window will allow you to configure
    the test:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b349dccc-04c1-4b39-9c78-af90cfef7b8d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'There is built-in support for JUnit 5 in IntelliJ IDEA. In the preceding screen,
    select JUnit5 for Testing library, and check the checkbox for the `multiplyByTwo()`
    method. Then, click the OK button in the bottom-right corner. The test will be
    created:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1e3526b4-c252-4073-ad78-73a72c9c099c.png)'
  prefs: []
  type: TYPE_IMG
- en: Notice that in the left pane, under the `test/java` folder, a package structure
    is created that matches the package of the `SimpleMath` class exactly. In the
    right pane, you can see the `SimpleMathTest` test class with one test (empty,
    so far) for the `multiplyByTwo()` method. The test method can have any name, but
    it has to have `@Test` in front of it, which is called an annotation. It tells
    the test framework that this is one of the tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s implement the test. For example, we can do it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3640513c-02b3-481e-9869-09c7297fcbc5.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, we have created an object of the `SimpleMath` class and called
    the `multiplyByTwo()` method with a parameter of `2`. We know that the correct
    result has to be `4`, and we check the result using the `assertEquals()` method
    that comes from the JUnit framework. We also added the `@DisplayName` annotation
    to the class and to the test method. You will see what this annotation does shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now modify the `mutliplyByTwo()` method in the the `SimpleMath` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a6427a90-f3ca-4f1e-abb6-e8ea76953674.png)'
  prefs: []
  type: TYPE_IMG
- en: Instead of just multiplying by `2`, we also add `1` to the result, so our test
    will break. It is a good practice to run a test on the incorrect code, first,
    so we can make sure that our test catches such errors.
  prefs: []
  type: TYPE_NORMAL
- en: Executing the unit test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s go back to the `SimpleMathTest` class, and run it by clicking on
    one of the green arrows. The green arrow on the class level runs all of the test
    methods, while the green arrow on the method level runs only that test method.
    Since we have only one test method, so far, it does not matter which arrow we
    click. The result should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/168972fa-0fe1-42c0-9063-8a9127bbdef0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'That is exactly what we hoped to see: the test expected to a result equal to
    `4`, but got `5`, instead. It provides us with a level of confidence that our
    test works correctly.'
  prefs: []
  type: TYPE_NORMAL
- en: Notice in the left pane, we can see the display names that came from the `@DisplayName` annotations—that
    was the purpose of those annotations.
  prefs: []
  type: TYPE_NORMAL
- en: Also, click on each of the blue links in the right pane to see what they do.
    The first one provides more detailed information about expected and actual results.
    The second link brings you to the line of the test, where the assertion is located
    that has failed the testis located, so you can see the exact context and correct
    what went wrong.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you can go to the `SimpleMath` class again and remove the `1` that we
    added. Then ,click on the green triangle in the upper-left corner (see the preceding
    screenshot). It means *rerun the test*. The result should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8851a540-9056-4835-a8e3-45437fcb18d8.png)'
  prefs: []
  type: TYPE_IMG
- en: By the way, you may have noticed that our screenshots and the path to the project
    have slightly changed. It happened because we are now taking the screenshots from
    IntelliJ IDEA running on macOS, so we can cover Windows and macOS. As you can
    see, the appearance of IntelliJ IDEA screens look principally the same on Windows
    as on the macOS system.
  prefs: []
  type: TYPE_NORMAL
- en: How many unit tests are enough?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is always the question any programmer thinks about every time a new method
    is written or an old method is modified—How many unit tests are enough to make
    sure that the application is thoroughly tested, and what kind of tests should
    they be? Typically, it is not enough to have one test for each method of the application.
    There are usually many aspects of functionality that have to be tested. But each
    test method should test only one aspect, so it is easier to write it and to understand.
  prefs: []
  type: TYPE_NORMAL
- en: For example, for our simple `multiplyByTwo()` method, we could add another test
    (we would call it `multiplyByTwoRandom()`) that picks a random integer number
    as an input into the method and does it a hundred times. Or, we could think about
    some extreme numbers, such as `0` and negative numbers, and see how our method
    works with them (we could call them `multiplyByZero()` and `multiplyByNegative()`,
    for example). Another test would be to use a very big number – bigger than half
    the biggest integer Java allows (we will talk about such limits in [Chapter 5](ddf91055-8610-4b8c-acc5-453cfa981760.xhtml),
    *Java Language Elements and Types*). We might also think about adding the check
    of the passed-in parameter value inside the `multiplyByTwo()` method, and throwing
    an exceptionif the passed-in parameter is bigger than half the maximum integer. We
    will talk about exceptions in [Chapter 10](9b40994b-a83d-4b78-b7c2-695c2afcfaa9.xhtml),
    *Control Flow Statements*.
  prefs: []
  type: TYPE_NORMAL
- en: You can see how quickly the number of unit tests, for the simplest method can
    grow. Imagine how many unit tests can be written for a method that does much more
    than our simple code.
  prefs: []
  type: TYPE_NORMAL
- en: We don't want to write too many unit tests, either, because we need to maintain
    all this code for the rest of the project's life. In the past, on more than only
    one occasion, a big project became too expensive to maintain, only because too
    many complex unit tests were written that added little or no value. That's why
    often, after the project code stabilizes and works in production for some time,
    and if there is a reason to think that it has too many unit tests, the team revisits
    them and makes sure that there are no useless tests, duplicates, or anything else
    quite obvious.
  prefs: []
  type: TYPE_NORMAL
- en: Writing good unit tests that work quickly and test the code thoroughly is a
    skill that comes with experience. In this book, we will use every opportunity
    to share the best practices of unit testing with you, so that by the end of this
    book, you will have some experience in this very important area of professional
    Java programming.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise – JUnit @Before and @After annotations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Read the JUnit user guide ([https://junit.org/junit5/docs/current/user-guide](https://junit.org/junit5/docs/current/user-guide))
    and the class `SampleMathTest` two new methods:'
  prefs: []
  type: TYPE_NORMAL
- en: One that is executed only once before any test method is run
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One that is executed only once after all the test methods were run
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We did not talk about it, so you would need to do some research.
  prefs: []
  type: TYPE_NORMAL
- en: Answer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For JUnit 5, the annotations that can be used for this purpose are `@BeforeAll` and
    `@AfterAll`. Here is the demonstration code:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public class DemoTest {
  prefs: []
  type: TYPE_NORMAL
- en: '@BeforeAll'
  prefs: []
  type: TYPE_NORMAL
- en: static void beforeAll(){
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("beforeAll is executed");
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '@AfterAll'
  prefs: []
  type: TYPE_NORMAL
- en: static void afterAll(){
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("afterAll is executed");
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '@Test'
  prefs: []
  type: TYPE_NORMAL
- en: void test1(){
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("test1 is executed");
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '@Test'
  prefs: []
  type: TYPE_NORMAL
- en: void test2(){
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println("test2 is executed");
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run it, the output will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: beforeAll is executed
  prefs: []
  type: TYPE_NORMAL
- en: test1 is executed
  prefs: []
  type: TYPE_NORMAL
- en: test2 is executed
  prefs: []
  type: TYPE_NORMAL
- en: afterAll is executed
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about Java projects, and how to set them up and
    use them for writing your application code and unit tests. You also learned how
    to build and how to execute application code and unit tests. Basically, that is
    what a Java programmer does most of the time. In the rest of the book, you will
    gain more detailed knowledge of the Java language, the standard libraries, and
    third-party libraries and frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will dive deeper into Java language elements and types,
    including `int`, `String`, and `arrays`. You will also learn what an identifier
    is and how to use it as a variable's name, as well as information about Java-reserved
    keywords and comments.
  prefs: []
  type: TYPE_NORMAL
