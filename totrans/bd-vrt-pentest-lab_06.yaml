- en: Chapter 6. Creating an External Attack Architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will build an external architecture that we will use as
    we progress through the different phases of attack. We will discuss the following
    topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Establishing layered architectures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring firewall architectures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying IDS/IPS and load balancers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating web application firewalls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter will provide us with an external attack architecture that will
    provide the capability to emulate a number of different testing environments.
    In the chapter, we will work through the process of configuring the range core
    devices that are the connecting devices for the architectures such as the router,
    switches, and the firewall machine. Consequently, we can easily build a target
    machine or device and plug it into our architecture and begin testing it immediately.
  prefs: []
  type: TYPE_NORMAL
- en: Establishing layered architectures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our intentions here are to provide a number of layers that we, as an externally
    located attacker, may have to penetrate to get to the target. This is the reality
    of external testing; many of the targets will have multiple protections in place
    between the attacker and the target. Fortunately, as these machines are required
    to allow access to services from the outside, they will also provide access to
    us as we conduct our testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will build our network architecture to provide the layers that are shown
    in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Establishing layered architectures](img/477-1_06_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As we review the architecture, we see that we have added a web server and a
    Bastion Host machine to our original design and a router is connected to the VMnet8
    and VMnet 2 switches. As discussed in [Chapter 4](ch04.html "Chapter 4. Identifying
    Range Architecture"), *Identifying Range Architecture*, this is the power of our
    planned architecture; we just plug in machines wherever we want to test them.
    In the architecture shown in the previous diagram, we have the router device that
    we will use for our testing. As we mentioned in [Chapter 3](ch03.html "Chapter 3. Planning
    a Range"), *Planning a Range*, we are using the Dynamips Cisco software emulator
    for the book, and we need to configure this to allow our services. If you are
    using the **iptables** option, then you will have to configure that device to
    support the services of your architecture.
  prefs: []
  type: TYPE_NORMAL
- en: The first step is to boot up the router device in VMware Workstation. Once the
    machine has finished booting, log in with the username and password that you created
    during the installation of the software. Enter `dynamips –H 7200` to start the
    router. Once it has started, you need to load the configuration file by opening
    another terminal window and entering `dynagen config.net`. Once the configuration
    loads, enter the R1console and access the running router. At the router prompt,
    enter `en` to enter the privileged mode on the router.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we next enter `show ip int brief` to show the configuration
    of the router interfaces; your output should be similar to that shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Establishing layered architectures](img/477-1_06_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As the previous screenshot shows, we have our two interfaces in the router
    showing **Status** as **up** and **Protocol** also as **up** and this is what
    we want. If your router screen does not show this, you will have to go back through
    the process we used in [Chapter 4](ch04.html "Chapter 4. Identifying Range Architecture"),
    *Identifying Range Architecture*, to see what went wrong. Hopefully, you will
    at least see the IP address information as correct. If this is the case, then
    it is probably just a matter of bringing up the interface which is accomplished
    by entering `no shut` in the interface configuration menu. To bring up the interface,
    enter the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If you do not have the correct address information, then you might not have
    saved the configuration we created in [Chapter 4](ch04.html "Chapter 4. Identifying
    Range Architecture"), *Identifying Range Architecture*, and so you will have to
    return to that chapter and proceed through the steps to get the results shown
    in the previous screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We now have a router in our architecture, and while we might encounter a router
    without filtering on it, more than likely we will not get that lucky; therefore,
    we will need to set up filtering on our router device. This is definitely something
    we want to add, but for now, we will build the network and make sure it works
    before we apply filtering. This is so we can troubleshoot as required and not
    have to deal with the filtering.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we have a router, we need to add a target machine and connect our architecture;
    we are going to accomplish this by adding a web server to our architecture. Our
    intentions are to create the network at the first level, as shown in the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Establishing layered architectures](img/477-1_06_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We could continue on and build more layers to our architecture, but a better
    design method is to test each layer before you move on to the next one. As we
    review the previous diagram, we have three machines that are the components of
    the architecture. We now want to add these machines and conduct our testing. The
    router is up and running, so we have two machines to bring up. The next machine
    we will bring up is the attacker. As we did in [Chapter 4](ch04.html "Chapter 4. Identifying
    Range Architecture"), *Identifying Range Architecture*, we will use the Kali Linux
    distribution machine. The preferred machine is the one that we downloaded in the
    VM format. The configuration of the VM is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Establishing layered architectures](img/477-1_06_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The main thing that we want to ensure is that we have one of our network cards
    connected to the VMnet8 (NAT) switch, and in this case, we do have that. Once
    we have verified the network adapters, we can start up the virtual machine. Once
    the machine comes up, log in with a username and password that you have created,
    or the defaults if you have not changed the password. It is a good idea to update
    the distribution anytime you start the Kali VM. However, before you do this, always
    take a snapshot in case something goes wrong during the update. Navigate to **VM**
    | **Snapshot** | **Take snapshot**. In the window that opens, enter a name for
    your snapshot and click on **Take snapshot**. After you have taken the snapshot,
    update the distribution by entering the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the upgrade has completed, the next thing to do is to test connectivity
    to the router. On Kali, enter `ping 192.168.177.10 –c 5`, and if all goes well,
    you should see a reply, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Establishing layered architectures](img/477-1_06_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now that we have connectivity, we are ready to add our next machine, and this
    is our web server. As we mentioned in [Chapter 4](ch04.html "Chapter 4. Identifying
    Range Architecture"), *Identifying Range Architecture*, we have many choices when
    it comes to adding a web server, and it really is a matter of personal preference.
    As we know, we are going to have two web servers in the architecture; we can select
    a different web server for the second machine than that of the first one. For
    the first web server in the book, we are going to select **Broken Web Application
    VM** from the OWASP and Mandiant. As this is going to be connected to the DMZ
    switch, we only have to make sure the network adapter is connected to the VMnet2
    switch.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of this configuration is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Establishing layered architectures](img/477-1_06_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once the configuration has been verified, the next thing we will do is start
    the virtual machine. After the machine has started, you will note the IP address
    assigned to the VM. Now that we have the machine up and running, we want to verify
    that we can access it. We have a couple of choices. We can use a simple ping,
    or we can use the application layer and connect via the browser. For the purpose,
    here we will use the browser. At the time of writing this book, our machine was
    assigned the IP address of `10.2.0.132`, so we open our browser to that IP address.
    An example of this is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Establishing layered architectures](img/477-1_06_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Screen showing the browser when opened with the address 10.2.0.132 (the cropped
    text is not important)
  prefs: []
  type: TYPE_NORMAL
- en: What happened? Why are we not able to connect? It is actually a quite common
    problem when you are building virtual environments, but before we reveal the reason,
    we will walk through a logical progression of steps. Next, we will attempt to
    ping it from the router. Select your Dynamips machine, and in the router window,
    enter the ping `10.2.0.132` to verify that you can access the machine on the flat
    network. An example of this is shown in the following screenshot. It is possible
    that your IP address will not be the same, and in such cases, you will use the
    IP address that is assigned.
  prefs: []
  type: TYPE_NORMAL
- en: '![Establishing layered architectures](img/477-1_06_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This shows we have the connectivity when it is flat, and we also know that
    we can ping the router external interface from our earlier test; so, what is the
    next step? We want to look at the path to the target. So, open a command prompt
    on your host machine and enter `tracert 10.2.0.132`. An example of the output
    of this command is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Establishing layered architectures](img/477-1_06_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The key to the problem is that at the first hop, the gateway should be pointing
    to the router interface; however, it is currently pointing to the wireless router
    that the machine is connected to. This is very common when we build architectures;
    moreover, when we perform techniques such as pivoting we have to set the routing
    up so that we can access the target. We could change the default gateway, but
    this is the least attractive option as we use that to get the traffic out to the
    Internet from the NAT interface. Consequently, a better option is to manually
    add the route. This is required for all machines when we want to talk across networks.
    The syntax used to add the route will vary across the different operating systems.
    We will add the route in the host Windows machine first. Open an administrator
    command prompt, and in the command prompt, enter `route add 10.2.0.0 mask 255.255.255.0
    192.168.177.10 metric 2`, and then test it. An example is shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Establishing layered architectures](img/477-1_06_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Wait a minute! Why is it not working? This is part of the process of building
    environments; we like to say frustration is good because this is when you learn.
    Once you get stuck, take a step back and think about it and then try harder. In
    the previous image, we see that the traffic is going the right direction, that
    is, toward the router interface; however, it does not report anything back after
    that hop. This is another common thing that you will have to keep in mind. We
    have added a route on the host, but we have not added the route on the target
    and this is required; we have to configure routes on both sides of the network
    session.
  prefs: []
  type: TYPE_NORMAL
- en: Select the broken web app **VM**, and log in to the machine. Once you have logged
    in, we will enter the command to add the route. You could enter `man route` and
    review the main page to determine the syntax required to add the route. Enter
    `route add –net 192.168.177.0 netmask 255.255.255.0 dev eth0` and add the route
    to the machine. Return to your host machine and test the configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example after the test is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Establishing layered architectures](img/477-1_06_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We now have our connectivity throughout our first layer. We also need to add
    the route into our attacking machine. Fortunately, the syntax is the same; this
    is not always the case, but it is this time. In your Kali attacker machine, enter
    `route add –net 10.2.0.0 netmask 255.255.255.0 dev eth0` and test the configuration
    by pinging the target; an example of the successful test is shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Establishing layered architectures](img/477-1_06_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We now have the first layer of our defense baseline installed and more importantly,
    we have the network connectivity established and working. There is one concern
    with our configuration, and that is in the routing. We have not set the routing
    to survive a reboot. We have a number of options to do this, and we will not cover
    all of them. One option in Windows is to use a `batch` file with your route statements
    and then run it as required. There is another option in Windows that you can use
    and this is the `-p` option on the route command itself. This sets the route as
    a persistent route, and when you do this, it adds the route to the registry. The
    location of this route is inserted into the registry at the `HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Tcpip
    \Parameters\PersistentRoutes` key. For our purposes, we do not need to make the
    routes persistent, but it is only an option and this is why we covered it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will configure our second layer; this requires us to connect a web
    server to the Orange or eth2 interface that we set up in [Chapter 3](ch03.html
    "Chapter 3. Planning a Range"), *Planning a Range*, on the Bastion Host. To further
    complete our second layer, we will have to add the routing once we connect the
    machine. An example of our second layer is shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Establishing layered architectures](img/477-1_06_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As the previous diagram shows, we need to build another web server for our second
    layer that is connected to the **VMnet3** switch. This will serve as a separate
    services subnet architecture that will be screened by the router and the Bastion
    Host—effectively a two layered defensive architecture.
  prefs: []
  type: TYPE_NORMAL
- en: We can use the same platform that we have in our first layer of defense architecture,
    but we want to use a variety of machines as we architect our external environment;
    therefore, we will use another machine. We have already downloaded the metasploitable
    virtual machine from Rapid7, so we will use that as our second web server. We
    just need to configure it to match our requirements for the second layer of defense.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of the configuration is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Establishing layered architectures](img/477-1_06_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We now have our machine set for the subnet; consequently, it is time to bring
    up all machines and test it! Once the machines start, you will test the connectivity;
    the easiest way is to test from the Bastion Host virtual machine. For testing
    purposes, we will start up Kali, the router, Bastion Host, and metasploitable.
    We will note the IP address of our metasploitable when it boots up. As we have
    set the VMnet3 with a DHCP server, the address should be assigned automatically
    at boot. Log in to the machine and enter `ifconfig` to display the network configuration
    of the web server.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of this is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Establishing layered architectures](img/477-1_06_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As we discovered while building the first layer, we have to establish routing.
    As we are on an isolated subnet, we can configure a default gateway rather than
    add the subnets one by one. In the metasploitable virtual machine, enter `sudo
    route add default gw 10.3.0.10` to add the route to the table. This provides us
    with a route; any time a packet makes it to our web server, if it does not know
    in which direction to go, it will forward the packet to the default gateway, which
    is the interface on the Bastion Host. To test connectivity, you have to ping in
    the direction from the Bastion Host to the web server. By default, the Smoothwall
    firewall will not allow you to ping from the orange subnet outbound. This is a
    good thing for security, and also for our testing, because unless the administrator
    makes a mistake and opens a hole like this, we will encounter the same type of
    default configuration. An example of the successful test of the orange subnet
    is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Establishing layered architectures](img/477-1_06_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The next thing we want to do is to verify the access to the orange subnet from
    the attacker router. To do this, we need to test from the router to the web server.
    To accomplish this, we have to add a route in the router to our `10.3.0.0` subnet.
    As you may recall, we made the red interface of the Bastion Host virtual machine
    DHCP. This is one thing we might want to reconsider now that we have added another
    layer to our architecture. If you want, you can change the IP to static. For our
    purpose, we will just use the one that is assigned at the boot of the Bastion
    Host. To determine the IP address for this command, enter `ifconfig eth0` in the
    Bastion Host and note the IP address on the interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Establishing layered architectures](img/477-1_06_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As the previous screenshot shows, the IP address assigned on the eth0 interface
    is `10.2.0.131`; we will use this to add our route in the router. Switch to the
    router and enter `show ip route` in the router terminal window. The output of
    the command will show that we do not have a route to the 10.3.0.0 network; therefore,
    we have to add this so that we can access that subnet. In the router, enter `conf
    t` to enter the configuration mode. Once you are here, enter `ip route 10.3.0.0
    255.255.255.0 10.2.0.131` to add the route to the table. As you see from the command,
    we use the IP address from the eth0 interface to route traffic through. Once you
    have entered the command, return to the main prompt by entering *Ctrl* + *Z*.
    Enter `ping 10.3.0.10` to ping the eth2 interface of the Bastion Host. Next we
    will test connectivity to the web server machine. Enter `ping 10.3.0.128`; you
    will notice that this fails! Why is this? Well, you have to think about the architecture
    again. The Bastion Host is serving as a firewall, and as we showed in [Chapter
    3](ch03.html "Chapter 3. Planning a Range"), *Planning a Range*, the ingress filtering
    on the Smoothwall firewall is, by default, set to not allow anything inbound;
    therefore, we have to open the connection from the outside into the orange eth2
    subnet.
  prefs: []
  type: TYPE_NORMAL
- en: We need to access the configuration of the Smoothwall firewall, and as you may
    recall from [Chapter 3](ch03.html "Chapter 3. Planning a Range"), *Planning a
    Range*, we can do this from a web browser. Open the web browser of your choice
    and access the configuration by entering `https://10.4.0.10:441` to open the login
    page. Then, enter the username and password that you configured when you created
    the machine.
  prefs: []
  type: TYPE_NORMAL
- en: Once the configuration page comes up, navigate to **Networking** | **incoming**
    to open the configuration page for the incoming traffic. As you review the information
    that is available, you will notice that the capability to allow ICMP inbound is
    not an option; therefore, we can only allow UDP or TCP. Consequently, this is
    another reason why we like to use the Smoothwall firewall when we architect our
    ranges. We know that the metasploitable machine has a web server on it, so we
    will configure the firewall to allow access to the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will configure the rule to meet the settings that are identified in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Establishing layered architectures](img/477-1_06_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We could make the rule more granular with specific IP blocks specified for the
    external source IP, but for our purpose, this will suffice; furthermore, you might
    want to make the IP address static in the web server to avoid the possibility
    of an IP address changing and then breaking our rule, but that is easy enough
    to do and it has been covered, so it will not be covered again here.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next thing we will do is test our rule. We have already seen that we cannot
    access the machine from our router using a ping. So, we will now try to access
    the web server, which is the port 80 of the web server, as we have added it into
    our firewall rule set. In the router terminal window, enter `telnet 10.3.0.128
    80` and once the connection is completed, enter `get / http/1.1` and then press
    *Enter* twice. This will attempt to return the home page from the web server and
    verify that you do have connectivity through the Bastion Host to the web server.
    An example is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Establishing layered architectures](img/477-1_06_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We now have to add a route and test it from our attacking machine; furthermore,
    we have to add a route in the Bastion Host back to the 192.168.177.0 network.
    This is an area that is often overlooked. You have to maintain the routing of
    the network traffic for target ranges as it is essential.
  prefs: []
  type: TYPE_NORMAL
- en: In the Kali and Bastion Host machines, add the route. In the Kali machine, enter
    `route add 10.3.0.0 netmask 255.255.255.0 dev eth0` and enter `route add 192.168.177.0
    netmask 255.255.255.0 dev eth0` in the Bastion Host.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the routes are added, open a browser of your choice and connect to the
    web server located on the metasploitable VM; alternatively, you can use the telnet
    method we used from the router. An example of what you should see is shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Establishing layered architectures](img/477-1_06_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Congratulations! You made it! We have built our external architecture! It takes
    some time to build it, but once it is built, we can perform any type of external
    testing that we may run into, and this is the power of virtualization.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A note here on the routing; this can be a cumbersome thing if you get it mixed
    up and make a mistake so, you might want to consider permanently storing the routing
    changes to survive reboots or any other unforeseen challenges.
  prefs: []
  type: TYPE_NORMAL
- en: You can create batch files as we discussed, and another way is to just keep
    the routing configurations in a text file and copy and paste them as required.
    Finally, if you really want to set the routing up on a more permanent basis, then
    you can set a cron job or place the route commands in the configuration file.
    For those of you who want to do this, it is left as a homework assignment for
    you!
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of our completed external architecture is shown in the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Establishing layered architectures](img/477-1_06_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We now have the baseline architecture set here, and we are ready to start the
    build and configuration of the various components. First, we have to make some
    configuration changes as our architecture is a little loose with respect to filtering.
    We will do this now. Before we proceed, save the router configuration we have
    built. At the router prompt enter `write mem`.
  prefs: []
  type: TYPE_NORMAL
- en: For those of you who are using the iptables machine, we will start to address
    some of the changes on this configuration. So far, the changes were not required,
    and you have the advantage of not having to make the router configuration entries
    that the ones who use the Cisco IOS do.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring firewall architectures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have configured the one rule in our Smoothwall firewall, and this has been
    the only filtering we have configured. While we would love to test from an external
    location and not have any filtering in place which would effectively give us a
    flat network, in reality, this will rarely be the case. Therefore, we want a minimal
    set of filters set in our architecture that will resemble something that we may
    see in typical network architecture. There is an important point to make here:
    if we run into a well-configured layered and protected architecture, we will only
    get through on the ports that they have to allow to ingress to their services.
    This is the reality of testing; a well-configured architecture will not offer
    many vectors for us outside of the ones they have to allow. Consequently, this
    is not a bad thing because we know there will be openings and we will virtually
    always have a web server and web applications to work with.'
  prefs: []
  type: TYPE_NORMAL
- en: With the current architecture configuration, we have no filtering placed on
    the first layer of defense, and some of you, if not all of you, reading this may
    know that even though our perimeter device is serving as a router, one of the
    core features of a router is the ability to filter traffic. While the traditional
    router filtering has been considered to be stateless that is no memory of anything
    but the current packet it is processing. The routers and filtering capability
    at the perimeter today will often be stateful and operate much the same as our
    traditional firewalls. For our purpose in the book, we will maintain the traditional
    approach with our filtering of being stateless. This is required to provide us
    with weaknesses we want to test, and it still is very viable as many of the administrators
    will configure a router in the traditional fashion. Consequently, we still run
    into weak filtering configurations in our testing even today, and you need to
    know how to test for and identify this at the early stages of testing.
  prefs: []
  type: TYPE_NORMAL
- en: In your router window, enter `sh access-lists` and display the access lists
    configured on the router, as you will see there is no access list on the router
    at this time. This is why we could not only ping through it but also access the
    web server(s) through it. Therefore, the first thing we want to do is configure
    the access list. Before we do this, a word about access lists. There are a multitude
    of configurations we can put in an access list or **Access Control List** (**ACL**)
    as we like to refer to them; however, to cover these would take a chapter or two
    in itself, so we will just cover the very basics. The intent is that once you
    have an access list between you and the target, we want to see how our network
    packets behave as we progress through our testing methodology. For those of you
    who want to know more, there is an excellent tutorial located at [http://gtcc-it.net/billings/acltutorial.htm](http://gtcc-it.net/billings/acltutorial.htm).
  prefs: []
  type: TYPE_NORMAL
- en: 'To create the access control list in your router, enter `ip access-list extended
    External` and press *Enter*. The next thing to do is to create the rules; we want
    to always allow ICMP so that we can troubleshoot. We know we only want to have
    access from the VMnet8 (NAT) subnet, and as such we can set this with the rule;
    enter `permit icmp 192.168.177.0 0.0.0.255 any` and press *Enter*. The next thing
    we want to configure is the access to our web servers; we could make two rules
    and have them set granular enough to only allow port 80 traffic to the web servers.
    However, for our testing purposes, it is acceptable to allow access to the entire
    subnets behind the router. Moreover, it will make our testing much easier than
    always configuring one rule for each protocol. This is the way to do it if it
    is a production environment, but we have the luxury of a test architecture. In
    the router window, enter `permit tcp any any eq 80` and then press *Enter*. We
    now have our configuration set, and we need to apply it. Hit *Ctrl* + *Z* to return
    to the main prompt, and then enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We are now ready to test it; ping and then access the web server located at
    the 10.3.0.0 subnet. You should be successful, and if not, then it is our favorite
    troubleshooting time. To see if your access list is working in the router, press
    *Ctrl* + *Z* to return to the main prompt. Once there, enter `show access-lists`
    to display the access list information. An example is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuring firewall architectures](img/477-1_06_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The key here as you view the access list is do you see matches? If you see matches,
    then your access list is working. This is the extent of our firewall configuration.
    We can from this point add anything we want to our architecture, and this is what
    we will do as we continue to conduct a variety of different testing techniques
    to emulate what we need to plan for when we conduct our actual tests. We have
    made a number of changes to our router, so before we go on to save the router
    configuration we have built, enter `write mem` at the router prompt.
  prefs: []
  type: TYPE_NORMAL
- en: Now, for those of you who do not have access to Cisco IOS, we will work with
    the iptables we set up in [Chapter 4](ch04.html "Chapter 4. Identifying Range
    Architecture"), *Identifying Range Architecture*. As has been mentioned, there
    really is very little difference thus far in our configuration, but that is about
    to change. The iptables have to be configured to allow the traffic to the Bastion
    Host and to the OWASP web server that is in our public DMZ. Other than that, there
    are no changes to our configuration. This is another reason why we have proceeded
    in this direction. The architecture we have built enables us to place any device
    or virtual machine as the perimeter device without changing anything behind it.
    The same goes for our Bastion Host; we can change it as we build different environments,
    and our architecture allows us to do that.
  prefs: []
  type: TYPE_NORMAL
- en: iptables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For those of you who do not have a Cisco IOS, we can use the filtering features
    of **iptables** to create the firewall capability we used in the Dynamips virtual
    machine.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 4](ch04.html "Chapter 4. Identifying Range Architecture"), *Identifying
    Range Architecture*, we created a Debian distribution to serve as our iptables
    machine. We could also use iptables as our Bastion Host filter, but for the purposes
    of the book, we will stick with using the iptables machine at the first level
    of defense. Of course, you can build and plug machines in anywhere in the architecture
    because it is flexible and just a baseline-layered configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Even if you have already built the **Cisco Dynamips** machine, you still should
    follow along and complete the steps to add the iptables machine to your architecture
    as it is something you might encounter. It is no secret that many organizations
    are adding Linux to their enterprise, and virtually all of them come with some
    form of filtering. Moreover, this iptables filtering capability is virtually a
    part of all distributions.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you think back to when we built the iptables machine, we selected different
    addresses than the addresses we used for the Dynamips virtual machine. We did
    this so that we can always have both machines in the architecture, and this allows
    us to cover the potential different scenarios we may encounter as a pen tester.
    All we have to do is to add the route in the external machine (Kali) and point
    it to the interface of the iptables machine. The virtual configuration is the
    same as Dynamips. An example of this is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![iptables](img/477-1_06_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The tricky part is in the configuration of the routing; therefore, we will work
    on this before we work on the actual filter rule syntax. Note that we can enable
    packet forwarding and then we can test our routing, but for now we will just set
    the route direction and verify that it gets to where we want it to go.
  prefs: []
  type: TYPE_NORMAL
- en: 'Power on your Debian virtual machine, and once it starts, log in with the username
    and password that you created when you built the machine. Open a terminal window
    and enter `ifconfig` to display the interface configuration information. Remember,
    if you are not logged in as `root`, you will have to elevate your privileges with
    the `su` command and then enter the root password to get the command to work.
    An example of the configuration of our machine is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![iptables](img/477-1_06_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As the previous screenshot shows, we have the 15 address on both interfaces.
    We have the routes added from earlier in the chapter, but these routes are through
    the Dynamips virtual machine. So if you have both of these machines up at the
    same time, there will not be an IP conflict, but you have to tweak the routes
    in the other machines to ensure that the traffic goes through the right machine.
    The easiest and recommended way is to just suspend the Dynamips virtual machine
    before continuing. To suspend the machine in VMware Workstation, navigate to **VM**
    | **Power** | **Suspend Guest**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the machine is suspended, we will enter a route into the Kali machine
    and test it. If you still have the route in for the Dynamips machine, it will
    work as we just used the subnet 10.2.0.0 and did not make an entry for the gateway
    machine. To test your routing, enter `ping 10.2.0.15 –c 3` to test you have connectivity.
    If you do not, then you no longer have the route in the table. We have showed
    how to do this, but to save you from either having to think about it or referring
    to earlier in the chapter, an example of the method to view the table and add
    and test the route is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![iptables](img/477-1_06_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Screen showing an example of the method to view the table and add and test the
    route (the cropped text is not important)
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have successfully tested access to the interface of the iptables machine,
    we will next test for the connectivity to the OWASP web server we built. In the
    terminal window, enter `ping 10.2.0.132 –c 3` to test the connectivity to the
    web server. Remember that if your OWASP machine is at another IP address, you
    will have to enter this. However, you will notice that this fails. Do you know
    why? Hopefully, you remember that we had a router with the Dynamips machine, so
    routing is already set up. The default installation of most Linux machines does
    not have IP forwarding turned on. Therefore, we have to manually turn it on to
    provide the functionality of a router. In the iptables machine, enter `cat /proc/sys/net/ipv4/ip_forward`
    in the terminal window to check the setting for IP forwarding; the value should
    be a `1` if the forwarding is turned on. To turn on the forwarding, enter `echo
    1 > /proc/sys/net/ipv4/ip_forward` and overwrite `0` with `1`. The forwarding
    will now be enabled. An example of enabling forwarding is shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![iptables](img/477-1_06_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once you have turned it on, you will probably not be able to complete a successful
    test. When we configured our routing earlier, we were not as granular as we should
    have been. We did this for a reason: to show those of you who might be a little
    rusty on your networking skills; moreover, the routing knowledge that you had
    may have perished if you have been spending a lot of time at the upper layers.
    What we are driving at here is that you have to place a gateway into the route
    command. Sometimes, it will work without the gateway as it did in our previous
    chapter, but often it will fail, so it is best to set our routes as specific as
    possible to avoid this. You have to enter the route in the Kali and the OWASP
    virtual machines.'
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of the route command for both machines is shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![iptables](img/477-1_06_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Screen showing an example of the route command for both machines (the cropped
    text is not important)
  prefs: []
  type: TYPE_NORMAL
- en: As a reminder, your IP address might be different if you set up your own scheme.
    We now have our network architecture built, so it is time to configure and set
    up the filtering, as we can access the machine on any port. Open a browser and
    verify that you can access the web server on the OWASP machine.
  prefs: []
  type: TYPE_NORMAL
- en: We will now configure the iptables in the Debian machine. When you configure
    the iptables, you can configure the rules directly from the command line. However,
    the method we are going to use here is to enter the rules on the command line
    and then save them. With Debian, there is no setup for loading the iptables at
    boot by default. Consequently, this is not something we want to leave as is. To
    correct it, we will add the package for `iptables-persistent`. In the terminal
    window, enter `apt-get install iptables-persistent` to grab the package and install
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the package is installed, there will be a configuration file located in
    the `/etc/iptables` folder that is named `rules.ip4`. If you want to take a look
    at the file, enter `more /etc/iptables/rules.v4` to display the contents of the
    file. As you can see, by default, the chains are all set at `ACCEPT`. We will
    change that now. So, we will use the command line and then use the save utility
    to save our changes. Before we do that, we will test whether we have connectivity
    throughout our architecture; we can do this by pinging the OWASP machine. Once
    you have done this successfully, now it is time to change it and block the forwarding
    of the packets. In the Debian machine, enter `iptables –P FORWARD DROP` to set
    the policy to drop and not forward all packets. We do this as it is the prudent
    approach to security and is what we will run into in a test environment. The problem
    is that if we do not save the rule, then when we reboot, the rule will not be
    there. In the package we downloaded, there is a tool for this. In the terminal
    window, enter `iptables-save /etc/iptables/rules.v4` to save the configuration
    to the file. This will provide us with the rule even after we reboot the machine.
    An example of what the rules file should like going forward is provided in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![iptables](img/477-1_06_28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This rule should prevent you from being able to ping the machine and this is
    what we wanted to accomplish. We currently have a default deny policy and will
    add rules as required to allow the traffic that we need. The traffic that we need
    to allow is the web traffic to the web server. In the terminal window, enter `iptables
    –A FORWARD –p tcp –d 10.2.0.0/24 –dport 80 –j ACCEPT` to create a rule for the
    inbound port 80 traffic to be forwarded to the OWASP machine. We also need a rule
    for the other direction. We can use a state directive and other methods, but we
    want to create the functionality of a router the best we can and this requires
    two rules that a stateless filter would require.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second rule we want to enter is `iptables –A FORWARD –p tcp –s 10.2.0.0/24
    –sport 80 –j ACCEPT` to add the rule for the return traffic. Once you have entered
    the rules, you will save them by entering `iptables-save /etc/iptables/rules.v4`.
    Once the configuration has been saved, you should now have access to the web server,
    but nothing else on the OWASP machine, and this is what we wanted. An example
    of this configuration file is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![iptables](img/477-1_06_29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This completes our configuration. We can add protocols to the iptables filter
    as required and practice virtually all the forms of testing that we are more than
    likely going to encounter.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying IDS/IPS and load balancers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We now have the main components of our architecture built for the most part;
    therefore, it is time to discuss adding the monitoring capability to our testing
    range. There is one thing that is important to note: no matter what monitoring
    solution we select, we cannot predict how the site is going to configure it! This
    is the only thing we cannot overlook while testing. We can test and successfully
    evade the monitoring systems we have placed on the range, but as these systems
    are largely policy- and configuration-based, there is a chance that we will not
    experience the same success we did in the lab. In this section, we will discuss
    a sample of some of the types of monitoring systems that are available and look
    at deploying one of them. We will discuss the concept further when we look at
    evasion later in the book.'
  prefs: []
  type: TYPE_NORMAL
- en: Intrusion Detection System (IDS)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When it comes to selecting an IDS for our architecture, there are a number of
    things we need to take into consideration, such as what product we want to set
    as our practice IDS. There are a number of products that are available and this
    can become a daunting task, but as one of the most popular ones is Snort, we will
    concentrate on that. Another bonus of Snort is that it has a free as well as a
    commercial version.
  prefs: []
  type: TYPE_NORMAL
- en: We have a couple of choices when we deploy our Snort machine on the network,
    but before we address this, we need to discuss where we will deploy Snort sensors
    and how the traffic is going to get to the sensor in a virtual environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'In an actual architecture, a switch is a unicast device that will only forward
    traffic to the port of the destination. Furthermore, the broadcast traffic is
    the only traffic that is sent on all ports. When it comes to deploying IDS network
    sensors, this can present a problem, and we have to either use a SPAN port or
    a tap. For more information and a comparison on these options, you can go to the
    following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.networktaps.com/](http://www.networktaps.com/)'
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, we do not have this problem in a VMware switch. The switches are
    set so that we can see traffic across a switch and this allows us to connect an
    IDS network sensor and not worry about configuring a SPAN port. To verify this,
    you can conduct a ping between two of your machines and run `tcpdump` on a third
    machine and check if you can see the traffic between the two other machines. For
    an example, we are going to conduct a ping between the OWASP web server and the
    Bastion Host; we will view the ping traffic by running `tcpdump` in the Kali machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of this is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Intrusion Detection System (IDS)](img/477-1_06_30.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once we have established that we can view the traffic across the switch, the
    next thing we want to discuss is the sensor placement. With network-based IDS,
    the normal configuration is to have a network sensor on each segment. Therefore,
    the only requirement is that all of the machines have to be connected to the same
    switch. Going forward, we will follow this approach when it comes to deploying
    and monitoring in our range. An example of our external architecture with the
    IDS sensors is shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Intrusion Detection System (IDS)](img/477-1_06_31.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now that we have identified our sensor placement within our architecture, we
    will now discuss how we are going to achieve this in our virtual configuration.
    We could build another virtual machine to serve as IDS sensor, but then we could
    start to feel the strain of our existing RAM. Therefore, our preferred method
    is to have one machine and configure it with multiple network cards and configure
    the Snort sensor on each existing card that is connected to the required switch.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To accomplish this, we need to build a machine to run Snort on. We could build
    one from scratch, but for the purposes of the book, we will look at other alternatives.
    However, building a machine from scratch is an interesting experience and it is
    left as homework for the reader. An excellent resource on how to do this for Snort
    that also has guidance on a number of platforms can be found at [http://www.snort.org/docs](http://www.snort.org/docs).
    A note of caution about these study guides, they are not 100 percent accurate,
    and so your mileage may vary.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create our Snort sensors we are going to use a distribution that already
    has the Snort program installed and more importantly, all of the dependencies.
    The distribution we will use is the **Network Security Toolkit**. It contains
    125 of the top security tools, and this is something that is worth adding to your
    architecture. What we like most about it is the ease of setting up Snort. You
    can download the ISO image from [http://sourceforge.net/projects/nst/files/](http://sourceforge.net/projects/nst/files/).
    Once you have downloaded the ISO image, you need to create a virtual machine.
    As we have covered this already, we will not do it again. The thing you have to
    do is to mount the ISO image and boot it. Once the machine boots, you will install
    it to the hard drive. Located on the desktop, there is an icon to install to the
    hard drive. An example of the desktop is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Intrusion Detection System (IDS)](img/477-1_06_32.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Double-click on the icon and follow the prompts to install the image to the
    hard drive. This will take some time. You might be wondering why we are installing
    to the hard drive when we can just boot from the ISO image. The reason we are
    installing it to the hard drive is that we want to have the NST VM as an actual
    machine, so we can save and build a variety of configurations with it and then
    save them. If the installation comes up with custom partitioning selected, click
    on the icon and change it to automatic partitioning as it will save time. Once
    the installation is complete, double-click on the icon on the desktop and set
    the system password. Once the password is set, right-click in the desktop area
    and select **Open in Terminal** to open a new terminal window and enter `shutdown
    –h now` to shut down the system. Once the system is shut down, we need to configure
    the machine to support the three interfaces that we will need to connect our Snort
    sensors.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of this configuration is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Intrusion Detection System (IDS)](img/477-1_06_33.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you may have noticed in the previous screenshot, the ISO image is no longer
    mounted; it is a good idea to remove that setting to avoid any potential conflict.
    Once you have verified your configuration power on the virtual machine, we will
    continue to configure the machine to provide our IDS requirements for our external
    architecture range. Open a terminal window and enter `ifconfig` and verify that
    you have three interfaces as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Intrusion Detection System (IDS)](img/477-1_06_34.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that we have the interfaces set, we are ready to start Snort. The reason
    we have selected the Network Security Toolkit is that it provides us with a very
    easy setup of a Snort sensor. Click on **Activities** and select the Firefox icon
    and open the browser, you will be prompted for a username and password. Enter
    the username as `root` and the password you set when you installed it to the hard
    drive. In the web interface, click on **Security** | **Intrusion Detection** |
    **Snort IDS** to open the GUI to configure Snort. An example of this is shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Intrusion Detection System (IDS)](img/477-1_06_35.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Screen showing GUI to configure Snort (the cropped text is not important)
  prefs: []
  type: TYPE_NORMAL
- en: 'To configure the sensor, select the radio button for the sensor you are starting,
    which is the eth0 interface. Once you have selected the interface, scroll down
    and click on **Setup/Start Snort** to start the sensor. Give it some time and
    then click on **Check Status** to see if the sensor has started. It will sometimes
    take two tries, and if it says stopped, click on **Enable** and run through the
    process again. Once it is successful, you should see the process running on the
    interface. Follow the same steps for the other two interfaces. An example of this
    configuration is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Intrusion Detection System (IDS)](img/477-1_06_36.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Screen showing the process running on the interface (the cropped text is not
    important)
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s it! We now have a fully distributed IDS using the Snort tool and we
    have sensors connected to each switch of the architecture. We will not go into
    the details of using the IDS here, because we will cover it in great detail when
    we show methods of evasion. For now, we want to at least look at a simple way
    to verify that your Snort installation is working. To the right of the sensor,
    there are a number of buttons; click on the **Rules** button for the interface
    eth0\. This will bring up the rules that you can configure on the interface; as
    you review the rules, you will see that this base installation does not have that
    many rules enabled; this is to help avoid false positives. It is common for sites
    to disable the scan rules as it can result in a number of false positives and
    in actuality, scanning is such a common occurrence. We want to enable the scan
    rules for the interface by selecting it in the radio button. Once you have made
    the changes for the rules, you will be required to reload the interface. Click
    on **Include Only Selected Rules**. An example of this is shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Intrusion Detection System (IDS)](img/477-1_06_37.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The next step is to reload the sensor to update the rules. Click on **Manage
    Snort Processes** to manage the Snort sensor and click on the **Reload** button.
    We are now set to test our sensor! Open a terminal window and enter `cd /etc/snort_eth0`
    to enter the directory that has been configured when you ran the NST script files.
    This is where all of the configuration files are located when you use the web
    interface to start your sensor. From here, the process is to start the Snort sensor
    again and perform a quick test. Again, this is just a quick reference of how to
    test a sensor; we will use the NST distribution much more in the section of evasion.
    As you have seen, we had to enable the scan rules so we can detect a scan, and
    this is quite common.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, there are ways to avoid detection even if the scan rules are
    enabled, but that is for another time. In the terminal window, enter `snort –A
    console –c snort.conf` to start another instance of Snort and log information
    to the console. If you are not at root privileges, you will have to run the command
    as `root`. Open another terminal and enter `nmap –sX –p 137,445 192.168.177.1`
    in it to conduct a Christmas tree scan against the host machine. An example of
    the alerts that you should see on the console from Snort is shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Intrusion Detection System (IDS)](img/477-1_06_38.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This verifies that we have Snort configured and the rules are working. At this
    time, we will not do any more here. You are welcome to explore on your own. The
    NST distribution has a significant amount of tools and it is well worth exploring
    to learn more, and it is recommended that you use the NST as a nice complement
    to the Kali machine.
  prefs: []
  type: TYPE_NORMAL
- en: Intrusion Prevention System (IPS)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have deployed the IDS, so now it is time to turn our attention to the IPS.
    In the early days of IDS, there were three functions that the IDS provided us;
    they were monitor, detect, and respond. This is where the IPS came from; the function
    of response today is the capability to respond and potentially prevent an attack.
    For the most part, the response is to block by IP address when it comes to a network
    IPS. For the host or machine-based IPS, it is a matter of blocking the process
    from accessing something. A somewhat limited example of this is the **User Account
    Control** (**UAC**) protection on the latest version of Windows. The problem with
    these approaches is that we are asking software to detect an attack that is real
    compared to one that may not be real. That is, we are asking software to think.
    It is my opinion that we do not have thinking software no matter what the media
    or entertainment industry tries to portray. As an example, when we perform an
    action on a machine that involves UAC, it warns us that something is going on;
    the problem is that it warns us so much that we just click on **yes**. Therefore,
    this is not an effective method of protection. We know the user more than likely
    will click; this is good for testing and bad for security.
  prefs: []
  type: TYPE_NORMAL
- en: Years ago, we would spoof an IP address of something that the client site used
    like their gateway and then generate an attack. The response action was to block
    the IP address and as a result, they blocked their own gateway and no one could
    access anything outside of their network. So as you can imagine, an IPS can cause
    problems when it is deployed; consequently, it has been my experience that if
    it is deployed, it is configured in monitor mode and not in block mode.
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to IPS, there are not that many available for our range purposes
    that are not commercial products. For this reason, we will not go through the
    process of adding one to our range at this time. When we get to the section in
    evasion, we will take another look at this. The IPS deployment on our range will
    be dependent on what we encounter with the client and the details in the scope
    of work.
  prefs: []
  type: TYPE_NORMAL
- en: Load balancers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When it comes to adding load balancers to our architecture, there are a couple
    of choices. The main thing with testing is detecting when a load balancer is in
    place and dealing with the ramifications of that as we carry out our testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will concentrate the discussion on our potential options to have load balancing
    within our architecture. We will be discussing only protocol load balancing. We
    have the capability to use load balancing in iptables. For an example of this,
    refer to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Load balancers](img/477-1_06_39.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The example in the previous screenshot uses the concept of rotating packets
    between the three machines as specified. The configuration load balances incoming
    HTTPS traffic to three different IP addresses, using `counter 0` for every third
    packet.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our next example for load balancing is the pfsense firewall; there is a capability
    to load balance within the firewall configuration. To find additional information
    and a tutorial to configure inbound load balancing, refer to this website [https://doc.pfsense.org/index.php/Inbound_Load_Balancing](https://doc.pfsense.org/index.php/Inbound_Load_Balancing).
    Additionally, the book *Advanced Penetration Testing for Highly-Secured Environments:
    The Ultimate Security Guide* by Lee Allen has details on how to use pfsense to
    load balance.'
  prefs: []
  type: TYPE_NORMAL
- en: Integrating web application firewalls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At the time of writing this book, more and more architectures that you encounter
    start to deploy protection of their web servers. Moreover, deployment of web application
    firewalls, or WAF, as they are commonly referred to are becoming more and more
    prevalent. As such, we need to deploy them in our architecture to test and determine
    how to get past them. We will cover the details of this in a later section. For
    now, we will look at adding a WAF capability to our architecture. One of the most
    popular WAFs that are free and open source is ModSecurity. We will revisit this
    in the later chapters; for now, we are going to add a WAF to our existing metasploitable
    VM that we have used in our earlier architecture.
  prefs: []
  type: TYPE_NORMAL
- en: 'Prior to installing and configuring the WAF, we will clone the machine and
    create a WAF appliance for our architecture. This will allow us to connect the
    WAF machine to any point of our range so that we can test our ability to get past
    it. This will provide us with the configuration as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Integrating web application firewalls](img/477-1_06_43.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As we need to access the Internet, you will need to change the network adapter
    so that it connects to the NAT switch and provides us with the link to the Internet.
    Once you have made the configuration change, power on the machine. Once you have
    logged in, enter `sudo –i` to assume the root level of privilege.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to download the software, and we will use the `wget` command for this.
    The link will be different when you are reading this book. Therefore, go to the
    website and verify what version is currently available and change the version
    number to match the one you discover, then the download should progress as normal.
    In the terminal window, enter `wget http://www.applicure.com/downloads/5.12/Linux/i386/dotDefender-5.12.Linux.i386.deb.bin.gz`
    to connect and download the software. Once the software is downloaded, it is time
    to install it. However, before we do this, we have to unzip it and make it executable.
    Enter `gunzip dotDefender-5.12.Linux.i386.deb.bin.gz` to unzip the file. Once
    the file has been unzipped, we now have to make it executable. Enter `chmod +x
    dotDefender-5.12.Linux.i386.deb.bin` and change the permissions for execution.
    An example of these commands is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Integrating web application firewalls](img/477-1_06_40.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We are now ready to start the installation process. Enter `./dotDefender-5.12.Linux.i386.deb.bin`
    to start the installation process. Follow the defaults until you have to enter
    the path to the Apache executable. Enter `/usr/sbin/apache2` for the location
    of the Apache server and continue with the installation defaults until you get
    to enter a URI to access the application. Enter `dotDefender`. Then, enter a password
    for admin access; again you can enter any password of your choice, but in a test
    environment, I like to keep it simple, so we will use a password of `adminpw`
    and continue with the installation. At the update option, select the **either**
    option and continue with the installation. If prompted for an update periodicity
    options, select any one for your choice and then click on **Next**. Select the
    first option to get the updates from the website and then **Next** to continue
    on with the installation.
  prefs: []
  type: TYPE_NORMAL
- en: 'If all goes well, you should see a successful installation completion message
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Integrating web application firewalls](img/477-1_06_41.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We now need to restart Apache as directed in the completion message; enter
    `/etc/init.d/apache2 restart` to restart the server. Once the web server has been
    restarted, we will access the WAF. Open a browser of your choice and connect to
    the WAF with the URL of the Metasploitable machine. Once you are connected, enter
    the username of admin and the password you selected during installation and access
    the configuration page; an example is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Integrating web application firewalls](img/477-1_06_42.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As we have not applied a license, we are only in the monitoring mode, but for
    our purposes of testing and using a WAF to practice, this is really all we need.
    We now want to test our WAF, and we will use the Kali distribution for the test.
    In the Kali machine, open a terminal window and enter `nikto –h 192.168.177.134`
    to use the nikto web scanner and see if the dotDfender WAF alerts. If your WAF
    is at a different IP address, then you will have to change the target destination
    to the IP address of your WAF. After you have performed the scan, return to your
    dotDefender and navigate to **Log Viewer** | **Metasploitable** to view the logs
    from the WAF. You should see some alerts from the scan with nikto; an example
    is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Integrating web application firewalls](img/477-1_06_44.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We have now built a robust and complete architecture for not only external testing
    but also other methods. We have the components that can be reused in a number
    of different scenarios; therefore, from the perspective of this chapter, our requirements
    have been met and we completed our stated goals. One last thing to do is take
    snapshots of all of the machines we have configured in this chapter so that you
    have them in case something ever goes wrong.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have built a layered architecture to serve the requirements
    of the potential variety of scenarios that we might encounter. We started the
    chapter with a layered approach to meet the needs of our external testing.
  prefs: []
  type: TYPE_NORMAL
- en: Following the defined layers, we began with adding the required components to
    each of the segments of the architecture. We also looked at the filtering and
    routing requirements and built and configured both a Cisco router emulator as
    well as an iptables machine to meet our filtering requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Once we configured and tested our first layer components, we moved to the task
    of adding a firewall to the architecture. We used the popular tool Smoothwall
    as our firewall and configured it to support one service for testing purposes.
  prefs: []
  type: TYPE_NORMAL
- en: After we built the firewall and tested the configuration, we next took on the
    task of adding monitoring capability to the range. We built and configured Snort
    on all three required subnets to support our need for intrusion detection capability.
    Then, we discussed the process of adding both IPS and load balancing to the configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we closed the chapter with a discussion on the integration of web application
    firewalls. We installed and configured the web application firewall dotDefender.
    Once we built the machine, we cloned it so that we now have a WAF machine that
    we can connect to any location within our architecture. Once we finished the cloning
    process, we used a tool, nikto, to test whether our WAF was detecting web application
    types of attacks.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes the chapter. You now have a complete layered architecture to
    include the routing requirements. Now, it is just a matter of connecting the desired
    targets to this architecture and testing to see what works and does not work against
    the targets. From this point, the process will be to look at the potential targets
    that we may encounter and then lab it up and see what we can discover. The foundation
    and core of the range is built and now it is time to add targets. One of the first
    protection, and therefore targets, we will encounter is some form of a device;
    consequently, this is where we will start in the next chapter.
  prefs: []
  type: TYPE_NORMAL
