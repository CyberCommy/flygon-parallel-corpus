- en: Programming Declaratively - A Better Style
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Up to now, we haven''t really been able to appreciate the possibilities of
    FP, as pertains to working at a higher level, declarative fashion. In this chapter,
    we will correct that, and start getting shorter, more concise, and easier to understand
    code, by using some higher-order functions (HOF: functions that take functions
    as parameters) such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '`.reduce()` and `.reduceRight()` to apply an operation to a whole array reducing
    it to a single result'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.map()`, to transform an array into another, by applying a function to each
    of its elements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.forEach()`, to simplify writing loops, by abstracting the necessary looping
    code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We''ll also be able to do searches and selections with:'
  prefs: []
  type: TYPE_NORMAL
- en: '`.filter()`, to pick some elements from an array'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.find()` and `.findIndex()`, to search for elements satisfying a condition'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And a pair of predicates, `.every()` and `.some()`, to check an array for some
    Boolean test
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using these functions lets you work more declaratively, and you'll see that
    your focus tends to go to what is needed to do, and not so much on how it's going
    to be done; the dirty details are hidden inside our functions. Instead of writing
    a series of possibly nested `for` loops, we'll rather focus on using functions
    as building blocks to specify our desired result.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will also be able to work in a *fluent* fashion, in which the output of
    a function becomes the input of a next one: a style we will later touch on.'
  prefs: []
  type: TYPE_NORMAL
- en: Transformations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first set of operations we are going to consider, work on an array, and
    process it in the base of a function to produce some results. There are several
    possible results: a single value, with the `.reduce()` operations; a new array,
    with `.map()`; or just about any kind of result, with `.forEach()`.'
  prefs: []
  type: TYPE_NORMAL
- en: If you Google around, you will find some articles that declare that these functions
    are not efficient, because a loop done by hand can be faster. This, while possibly
    true, is practically irrelevant. Unless your code really suffers from speed problems,
    and you are able to measure that the slowness derives from the usage of these
    higher-order functions, trying to avoid them, with longer code, and more probability
    of bugs simply doesn't make much sense.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by considering the preceding list of functions in order, starting
    by the most general of all--which, as we'll see, can even be used to emulate the
    rest of the transformations in this chapter!
  prefs: []
  type: TYPE_NORMAL
- en: Reducing an array to a value
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Answer this question: how many times have you had to loop through an array,
    doing some operation (say, summing elements) to produce a single value (maybe
    the sum of all the array values) as a result? Probably many, many times. This
    kind of operation can be usually implemented functionally, by applying `.reduce()`
    and `.reduceRight()`. Let''s start with the former!'
  prefs: []
  type: TYPE_NORMAL
- en: 'Time for some terminology! In usual FP parlance, we speak of *folding* operations:
    `.reduce()` is *foldl* (for *fold left*) or just plain *fold*, and `.reduceRight()`
    is correspondingly known as *foldr*. In Category Theory terms, both operations
    are *catamorphisms* : the reduction of all the values in a *container* down to
    a single result.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The inner working of the `reduce()` function can be illustrated as in Figure
    5.1:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/619697be-da71-4712-b0c6-d85194919859.png)Figure 5.1: The reduce
    operation traverses the array, applying a function to each element and to the
    accumulated valueWhy should you try to always use `.reduce()` or `.reduceRight(`)
    instead of hand-coded loops?'
  prefs: []
  type: TYPE_NORMAL
- en: All the aspects of loop control are automatically taken care of, so you don't
    even have the possibility of a, say, *off by one* mistake
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The initialization and handling of the result values are also done implicitly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And, unless you work really hard at being impure and modifying the original
    array, your code will be side-effects free
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summing an array
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most common example of application of `.reduce()`, usually seen in all textbooks
    and web pages, is summing all the elements of an array. So, in order to keep with
    tradition, let's start with precisely that example!
  prefs: []
  type: TYPE_NORMAL
- en: 'Basically, to reduce an array you must provide a dyadic function (that is,
    a function with two parameters; *binary* would be an another name for that) and
    an initial value. In our case, the function will sum its two arguments. Initially,
    the function will be applied to the provided initial value and the first element
    of the array, so for us the first result we have to provide is a zero, and the
    first result will be the first element itself. Then, the function will be applied
    again, this time to the result of the previous operation, and the second element
    of the array -- and so the second result will be the sum of the first two elements
    of the array. Progressing in this fashion along the whole array, the final result
    will be the sum of all its elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You don''t actually need the `sum` definition; you might have just written
    `myArray.reduce((x,y) => x+y, 0)`. However, in this fashion the meaning of the
    code is clearer: you want to reduce the array to a single value by `sum`-ming
    all its elements. Instead of having to write out the loop, initializing a variable
    to hold the result of the calculations, and going through the array doing the
    sums, you just declare what operation should be performed. This is what I meant
    by saying that programming with functions such as those that we''ll see in this
    chapter, allows you to work more declaratively, focusing on *what* rather than
    *how*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also even do without providing the initial value: if you skip it, the
    first value of the array will be used, and the internal loop will start with the
    second element of the array. See [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce)
    for more. However, be careful if the array is empty, and if you skipped providing
    an initial value, you''ll get a runtime error!'
  prefs: []
  type: TYPE_NORMAL
- en: We can change the reducing function to see how it progresses through its calculations,
    by just including a little bit of impurity!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The output would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: You can see how the first sum was done by adding the initial value (zero) and
    the first element of the array, and how that result was used in the second addition,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Part of the reason for the *foldl* name seen previously (at least, its `l`
    part) should now be clear: the reducing operation proceeds from left to right,
    from the first element up to the last. You may wonder, however, how it would have
    been named if it had been defined by a right-to-left language (such as Arabic,
    Hebrew, Farsi, or Urdu) speaker!'
  prefs: []
  type: TYPE_NORMAL
- en: Calculating an average
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's work a bit more; how do you calculate the average of a list of numbers?
    If you were explaining this to someone, your answer would surely somewhat be like
    *sum all the elements in the list, and divide that by the number of elements*.
    This, in programming terms, is not a *procedural* description (you don't explain
    how to sum elements, or how to traverse the array), but rather a *declarative*
    one, since you say what to do, not how to do it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can transform that description of the calculation into an almost self-explanatory
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The definition of `average()` follows what would be a verbal explanation: sum
    the elements of the array, starting from zero, and divide by the array''s length
    -- simpler, impossible!'
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned in the previous section, you could have also written `arr.reduce(sum)`
    without specifying the initial value (zero) for the reduction; it's even shorter
    and closer to the verbal description of the needed calculation. This, however,
    is less safe, because it would fail (producing a runtime error) should the array
    be empty. So, it's better to always provide the starting value.
  prefs: []
  type: TYPE_NORMAL
- en: 'This isn''t, however, the only way of calculating the average. The reducing
    function also gets passed the index of the current position of the array and the
    array as well, so you could do something different the last time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Getting the array and the index means you could also turn the function into
    an impure one; avoid this! Everybody who sees a `.reduce()` call, will automatically
    assume it's a pure function, and will surely introduce bugs when using it.
  prefs: []
  type: TYPE_NORMAL
- en: However, from the point of view of legibility, I'm certain we agree that the
    first version we saw, was more declarative and closer to the mathematical definition,
    than this second version.
  prefs: []
  type: TYPE_NORMAL
- en: 'It would also be possible to modify `Array.prototype` to add the new function.
    Modifying prototypes is usually frowned upon, because, at the very least, of the
    possibility of clashes with different libraries. However, if you accept that idea,
    you could then write the following code. Do take note of the need for the outer
    `function()` (instead of an arrow function) because of the implicit handling of
    `this`, which wouldn''t be bound otherwise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Calculating several values at once
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What would you do if, instead of a single value, you needed to calculate two
    or more results? This would seem a case providing a clear advantage for common
    loops, but there''s a trick you may use. Let''s revisit yet once more the average
    calculation. We might want to do it *the old-fashioned way*, by looping, and at
    the same time summing and counting all numbers. Well, `.reduce()` only lets you
    produce a single result, but there''s no objection to returning an object, with
    as many fields as desired:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Examine the code carefully. We need two variables, for the sum and the count
    of all numbers. We provide an object as the initial value for the accumulator,
    with two properties set to zero, and our reducing function updates those two properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'By the way, using an object isn''t the only option. You could also produce
    any other data structure; let''s just see an example with an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: To be frank, I think it's way more obscure than the solution with the object.
    Just consider this as a (not very recommendable) alternative way of calculating
    many values at once!
  prefs: []
  type: TYPE_NORMAL
- en: Folding left and right
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The complementary `.reduceRight()` method works just as reduce, only starting
    at the end and looping until the beginning of the array. For many operations (such
    as the calculation of averages that we saw previously) this makes no difference,
    but there are some cases in which it will.
  prefs: []
  type: TYPE_NORMAL
- en: 'We shall be seeing a clear case of this in [Chapter 8](8e0f575a-87f7-4601-b47c-6872aaacb954.xhtml),
    *Connecting Functions - Pipelining and Composition*, when we compare pipelining
    and composition: let''s go with a simpler example here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/224b131b-0306-4be3-a482-ec57be888b0e.png)Figure 5.2: The .reduceRight()
    operation works the same way as .reduce(), but in reverse orderRead more on `.reduceRight()`
    at [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/ReduceRight](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/ReduceRight).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we want to implement a function to reverse a string. A solution could
    be transforming the string into an array by using `.split()`, then reversing that
    array, and finally using `.join()` to make it whole again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This solution (and yes, it can be shortened, but that''s not the point here)
    works, but let''s do it in another way, just to experiment with `.reduceRight()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Given that the addition operator also works with strings, we could have also
    written `reduceRight(sum,"")`. And, if instead of the function we used, we had
    written `(x,y) => y+x`, the result would have been our original string; can you
    see why?
  prefs: []
  type: TYPE_NORMAL
- en: 'From the previous examples, you can also get an idea: if you first apply `reverse()`
    to an array, and then use `reduce()`, the effect will be the same as if you had
    just applied `.reduceRight()` to the original array. Only one point to take into
    account: `reverse()` alters the given array, so you would be causing an unintended
    side effect, by reversing the original array! The only way out would be first
    generating a copy of the array, and only then doing the rest... Too much work;
    rather keep using `.reduceRight()`!'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, we can draw another conclusion, showing a result we had foretold:
    it is possible, even if more cumbersome, to use `.reduce()` to simulate the same
    result as `.reduceRight()` -- and in later sections we''ll also use it to emulate
    the other functions in the chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: Applying an operation - map
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Processing lists of elements, and applying some kind of operation to each of
    them, is a quite common pattern in computer programming. Writing loops that systematically
    go through all the elements of an array or collection, starting at the first and
    looping until finishing with the last, and doing some kind of process to each
    of them, is a basic coding exercise, usually learned in the first days of all
    programming courses. We already saw one such kind of operation in the previous
    section, with `.reduce()` and `.reduceRight()`; let's now turn a new one, called
    `.map()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In mathematics, a *map* is a transformation of elements from a *domain* into
    elements of a *codomain*. For example, you might transform numbers into strings,
    or strings into numbers, but also numbers to numbers, or strings to strings: the
    important point is that you have a way to transform an element of the first *kind*
    or *domain* (think *type* if it helps) into an element of the second kind, or
    *codomain*. In our case, it will mean taking the elements of an array and applying
    a function to each of them to produce a new array. In more computer-like terms,
    the map function transforms an array of inputs into an array of outputs.'
  prefs: []
  type: TYPE_NORMAL
- en: Some more terminology. We would say that an array is a functor because it provides
    a mapping operation with some pre-specified properties, that we shall see later.
    And, in Category Theory of which we'll talk a little in [Chapter 12](0d82d215-9bfc-436b-b09d-8ed2e2ebd441.xhtml),
    *Building Better Containers - Functional Data Types*, the mapping operation itself
    would be called a morphism.
  prefs: []
  type: TYPE_NORMAL
- en: 'The inner working of the `.map()` operation can be seen in Figure 5.3:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/0fafb8ed-5d29-4410-b453-f30e702db535.png)Figure 5.3: The map() operation
    transforms each element of the input array, by applying a mapping functionThe
    jQuery library provides a function, `$.map(array, callback)` that is similar to
    the `.map()` method. Be careful, though, for there are important differences.
    The jQuery function processes the undefined values of the array, while `.map()`
    skips them. Also, if the applied function produces an array as its result, jQuery
    *flattens* it, and adds each of its individual elements separately, while `.map()`
    just includes those arrays in the result.'
  prefs: []
  type: TYPE_NORMAL
- en: What are the advantages of using `.map()`, over using a straightforward loop?
  prefs: []
  type: TYPE_NORMAL
- en: First, you don't have to write any loops, so that's one fewer possible source
    of bugs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Second, you don't even have to access the original array or the index position,
    even though they are there for you to use if you really need them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And lastly, a new array is produced, so your code is pure (though, of course,
    if you really want to produce side-effects, of course, you can!)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In JS, `.map()` is basically available only for arrays. (Read more at [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map).)
    However, in section *Extending current data types* of [Chapter 12](0d82d215-9bfc-436b-b09d-8ed2e2ebd441.xhtml),
    *Building Better Containers - Functional Data Types*, we will consider how to
    make it available for other basic types, such as numbers, booleans, strings, and
    even functions. Also, libraries such as LoDash or Underscore or Ramda, provide
    similar functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are only two caveats when using this:'
  prefs: []
  type: TYPE_NORMAL
- en: Always return something from your mapping function. If you forget this, since
    JS always provides a default `return undefined` for all functions, you'll just
    produce an `undefined`-filled array.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the input array elements are objects or arrays, and you include them in the
    output array, then JS will still allow the original elements to be accessed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extracting data from objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's start with a simple example. Suppose we have some geographic data as shown
    in the following snippet, related to countries and the coordinates (latitude,
    longitude) of their capitals. Let's say we happened to want to calculate the average
    position of those cities. (No, I don't have a clue why we'd want to do that...)
    How would we go about it?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In case you are wondering if and why all the data are negative, it's just because
    the shown countries are all south of the Equator, and west of Greenwich. However,
    there are some South American countries with positive latitudes, such as Colombia
    or Venezuela, so not all have negative data. We'll come back to this question
    below, when we study the `some()` and `every()` methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'We would want to use our `average()` function (that we developed earlier in
    this chapter), but there is a problem: that function can only be applied to an
    array of *numbers*, and what we have here is an array of *objects*. We can, however,
    do a trick. Focus on calculating the average latitude; we can deal with the longitude
    later, in a similar fashion. We can map each element of the array to just its
    latitude, and we would then have an appropriate input for `average()`. The solution
    would be something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If you had extended `Array.prototype`, you could have then written an equivalent
    version, in a different style:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We will be seeing more about these styles in [Chapter 8](8e0f575a-87f7-4601-b47c-6872aaacb954.xhtml),
    *Connecting Functions - Pipelining and Composition*.
  prefs: []
  type: TYPE_NORMAL
- en: Parsing numbers tacitly
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Working with the map is usually far safer and simpler than looping by hand,
    but some edge cases may trip you up. Say you received an array of strings representing
    numeric values, and you wanted to parse them into actual numbers. Can you explain
    the following results?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: When you use `parseFloat()` to get floating point results, everything's OK.
    However, if you wanted to truncate results to integer values, then the output
    really goes awry... what's happening?
  prefs: []
  type: TYPE_NORMAL
- en: 'The answer lies in a problem with tacit programming. (We already saw some uses
    of tacit programming in the *An unnecessary mistake*, section of [Chapter 3](89a2ff2f-a67d-4a21-a2f5-cd54bed7198a.xhtml),
    *Starting Out with Functions - A Core Concept*, and we''ll be seeing more in [Chapter
    8](8e0f575a-87f7-4601-b47c-6872aaacb954.xhtml), *Connecting Functions - Pipelining
    and Composition*.) When you don''t explicitly show the parameters to a function,
    it''s easy to have some oversights. See the following code, which will lead us
    to the solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The reason for the unexpected behavior with `parseInt()`, is that this function
    can also receive a second parameter, that is the radix to be used when converting
    the string to a number. For instance, a call such as `parseInt("100010100001",
    2)` will convert the binary number 100010100001 to decimal.
  prefs: []
  type: TYPE_NORMAL
- en: See more on `parseInt()` at [https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/parseInt](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/parseInt),
    where the radix parameter is explained in detail. You should always provide it,
    because some browsers might interpret strings with a leading zero to be octal,
    which would once again produce unwanted results.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, what happens when we provide `parseInt()` to `map()`? Remember, that `.map()`
    calls your mapping function with three parameters: the array element value, its
    index, and the array itself. When `parseInt` receives these values, it ignores
    the array, but assumes that the provided index is actually a radix... and `NaN`
    values are produced, since the original strings are not valid numbers in the given
    radix.'
  prefs: []
  type: TYPE_NORMAL
- en: Working with ranges
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s now turn to a helper function, which will come handy for many usages.
    We want a `range(start,stop)` function, that generates an array of numbers, with
    values ranging from `start` (inclusive) to `stop` (exclusive):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Why `.fill(0)`? All undefined array elements are skipped by `map()`, so we need
    to fill them with something, or our code will have no effect.
  prefs: []
  type: TYPE_NORMAL
- en: Libraries such as Underscore or LoDash provide a more powerful version of our
    range function, letting you go in ascending or descending order, and also specifying
    the step to use, as in `_.range(0, -8, -2)` that produces [`0`, `-2`, `-4`, `-6`],
    but for our needs, the version we wrote is enough. See the *Questions* section
    at the end of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'How can we use it? In the following section, we''ll see some usages for controlled
    looping with `forEach()`, but we can redo our factorial function by applying `range()`
    and then `reduce()`. The idea for this is simply to generate all the numbers from
    1 to n and then multiply them together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: It's important to check the border cases, but the function also works for zero;
    can you see why? The reason for that is that the produced range is empty (the
    call is `range(1,1)` that returns an empty array) and then `reduce()` doesn't
    do any calculations, and simply returns the initial value (one), which is correct.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 8](8e0f575a-87f7-4601-b47c-6872aaacb954.xhtml), *Connecting Functions
    - Pipelining and Composition*, we'll have opportunity to use `range()` to generate
    source code; check out the *Currying with* *eval()* and *Partial application with*
    *eval()* sections.
  prefs: []
  type: TYPE_NORMAL
- en: 'You could use these numeric ranges, to produce other kinds of ranges. For example,
    should you need an array with the alphabet, you could certainly (and tediously)
    write `["A", "B", "C"...` up to `..."X", "Y", "Z"]`. A simpler solution would
    be generating a range with the ASCII codes for the alphabet and mapping those
    into letters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Note the use of `charCodeAt()` to get the ASCII codes for the letters, and `String.fromCharCode(x)`
    to transform the ASCII code back into a character.
  prefs: []
  type: TYPE_NORMAL
- en: Emulating map() with reduce()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Earlier in this chapter, we saw how `reduce()` could be used to implement `reduceRight()`.
    Now, let's see that `reduce()` can also be used to provide a polyfill for `map()`
    --not that you will need it, for browsers usually provide both methods, but just
    to get more ideas of what you can achieve with these tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our own `myMap()` is a one-liner--but it can be hard to understand. The idea
    is that we apply the function to each element of the array, and we `concat()`
    the result to (an initially empty) result array. When the loop finishes working
    with the input array, the result array will have the desired output values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s test this with a simple array and function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The first log shows the expected result, produced by `map()`. The second output
    gives the same result, so it seems `.myMap()` works! And, the final output is
    just to check that the original input array wasn't modified in any way; mapping
    operations should always produce a new array.
  prefs: []
  type: TYPE_NORMAL
- en: More general looping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The examples that we've seen above, simply looping through an array. However,
    sometimes you need to do some loop, but the required process doesn't really fit
    `.map()` or `.reduce()`... so what can be done? There is a `.forEach()` method
    that can help.
  prefs: []
  type: TYPE_NORMAL
- en: Read more about the specification of the `.forEach()` method at [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach).
  prefs: []
  type: TYPE_NORMAL
- en: 'You must provide a callback that will receive the value, the index, and the
    array on which you are operating. (The last two arguments are optional.) JS will
    take care of the loop control, and you can do whatever you want at each step.
    For instance, we can program an object copy method by using some `Object` methods
    to copy the source object attributes one at a time, and generate a new object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Yes, of course, you might have also written `myCopy={...myObj}`, but where''s
    the fun in that? OK, that is better, but I needed a nice example to use `.forEach()`...
    sorry about that! Also, there are some hidden inconveniences in that code, which
    we''ll explain in [Chapter 10](383f5538-72cc-420a-ae77-896776c03f27.xhtml), *Ensuring
    Purity - Immutability*, when we try to get really frozen, un-modifiable objects.
    Just a hint: the new object may share values with the old one because we have
    a *shallow* copy, not a *deep* one. We''ll see more about this later in the book.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you use the `range()` function we defined previously, you can also do common
    loops, of the `for(i=0; i<10; i++)` variety. We might write yet another version
    of factorial (!) using that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This definition of factorial really matches the usual description: it generates
    all the numbers from 1 to n inclusive, and multiplies them; simple!'
  prefs: []
  type: TYPE_NORMAL
- en: For greater generality, you might want to expand `range()` so it can generate
    ascending and descending ranges of values, possibly also stepping by a number
    different than 1\. This would practically allow you to replace all the loops in
    your code by `.forEach()` loops.
  prefs: []
  type: TYPE_NORMAL
- en: Logical higher-order functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up to now, we have been using higher-order functions to produce new results,
    but there are also some other functions that produce logical results, by applying
    a predicate to all the elements of an array.
  prefs: []
  type: TYPE_NORMAL
- en: 'A bit of terminology: the word *predicate* can be used in several senses (as
    in *Predicate Logic*) but for us, in computer science, we adopt the meaning *a
    function that returns true or false*. OK, this isn''t a very formal definition,
    but it''s enough for our needs. For example, we will filter an array depending
    on a predicate, and that just means that we get to decide which elements are included
    or excluded depending on the result of the predicate.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using these functions implies that your code will become shorter: you can,
    with a single line of code, get the results corresponding to the whole set of
    values.'
  prefs: []
  type: TYPE_NORMAL
- en: Filtering an array
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A common need is having to filter the elements of an array according to some
    condition. The `.filter()` method lets you inspect each element of an array, in
    the same fashion as `.map()`. The difference is that instead of producing a new
    element, the result of your function determines whether the input value will be
    kept in the output (if the function returned `true`) or if it will be skipped
    (if the function returned `false`). Also similarly to `.map()`, `.filter()` doesn't
    alter the original array, but rather returns a new array with the picked items.
  prefs: []
  type: TYPE_NORMAL
- en: 'See Figure 5.4 for a diagram showing the input and output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/834e362e-be10-4a3b-875c-ffdcc0685d27.png)Figure 5.4: The filter()
    method picks the elements of an array, that satisfy a given predicateRead more
    on the `.filter()` function at [https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/filter](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/filter).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The things to remember when filtering an array are these:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Always return something from your predicate**. If you forget to include a
    `return`, the function will implicitly return `undefined`, and since that''s a
    *falsy* value, the output will be an empty array.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The copy that is made, is shallow**. If the input array elements are objects
    or arrays, the original elements will still be accessible.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A reduce() example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s see a practical example. Suppose a service has returned a JSON object,
    which itself has an array of objects containing an account `id` and the account
    `balance`. How can we get the list of IDs that are *in the red*, with a negative
    balance? The input data could be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Assuming we got this data in a `serviceResult` variable, we could get the delinquent
    accounts with something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: By the way, given that the filtering operation produced yet another array, if
    you just wanted the accounts IDs, you could do so by mapping the output, to just
    get the ID field.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: And if you didn't care for the intermediate result, a one-liner would have done
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Emulating filter() with reduce()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we did before with `.map()`, we can also create our own version of `.filter()`
    by using `.reduce()`. The idea is similar: loop through all the elements of the
    input array, apply the predicate to it, and if the result is `true`, add the original
    element to the output array. When the loop is done, the output array will only
    have those elements for which the predicate was `true`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We can quickly see that our function works as expected.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The output is the same pair of accounts as earlier in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Searching an array
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes, instead of filtering all the elements of an array, you want to find
    an element that satisfies a given predicate. There are a couple of functions that
    can be used for this, depending on your specific needs:'
  prefs: []
  type: TYPE_NORMAL
- en: '`.find()` searches through the array and returns the value of the first element
    that satisfies a given condition, or `undefined` if no such element is found'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.findIndex()` does a similar task, but instead of returning an element, it
    returns the index of the first element in the array that satisfies the condition,
    or -1 if none was found'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The analogy is clear to `.includes()` and `.indexOf()`, which search for a
    specific value, instead of for an element that satisfies a more general condition.
    We can easily write equivalent one-liners:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Going back to the geographic data we used earlier, we could easily find a given
    country.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We couldn''t use the simpler `.includes()` method because we have to delve
    into the object to get the field we want. If we wanted the position of the country
    in the array, we would have used `.findIndex()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: A special search case
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, for variety, a little quiz. Suppose you had an array of numbers and wanted
    to run a sanity check, studying whether any of them was `NaN`. How would you do
    it? A tip: don''t try checking the types of the array elements: even though `NaN`
    stands for *Not a Number*, `typeof NaN === "number"`... And you''ll get a surprising
    result if you try to do the search in an *obvious way*...'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'What''s going on here? It''s a bit of interesting JS trivia: `NaN` is the only
    value that isn''t equal to itself. Should you need to look for `NaN`, you''ll
    have to use the new `isNaN()` function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Emulating find() and findIndex() with reduce()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As with other methods, let's finish this section by studying how to implement
    the methods we showed, by using the omnipotent `.reduce()`. This is a good exercise
    to get accustomed to working with higher-order functions, even if you are never
    going to actually use these polyfills!
  prefs: []
  type: TYPE_NORMAL
- en: 'The `.find()` function requires a bit of work. We start the search with an
    undefined value, and if we find an array element such that the predicate is `true`,
    we change the accumulated value to that of the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: For `findIndex()` we must remember that the callback function receives the accumulated
    value, the array current element, and the index of the current element, but other
    than that, the equivalent expression is quite similar to the one for `find()`;
    comparing them is worth the time.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The initial accumulated value is here `-1`, which will be the returned value
    in case no element fulfills the predicate. Whenever the accumulated value is still
    `-1`, but we find an element that satisfies the predicate, we change the accumulated
    value to the array index.
  prefs: []
  type: TYPE_NORMAL
- en: Higher level predicates - some, every
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The last functions we are going to consider, greatly simplify going through
    arrays to test for conditions. These functions are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`.every()`, that is `true` if and only *every* element in the array satisfies
    a given predicate'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.some()`, that is `true` if at least *one* element in the array satisfies
    the predicate'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, we could easily check our hypothesis about all the countries having
    negative coordinates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to find equivalents to these two functions in terms of `reduce()`,
    the two alternatives show nice symmetry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The first folding operation evaluates `fn(y)`, and ANDs the result with the
    previous tests; the only way the final result will be `true` is if every test
    comes out `true`. The second folding operation is similar, but ORs the result
    with the previous results, and will produce true, unless every test comes out
    `false`.
  prefs: []
  type: TYPE_NORMAL
- en: In terms of Boolean algebra, we would say that the alternative formulations
    for `every()` and `some()` exhibit duality. This duality is the same kind that
    appears in the expressions `x === x && true` and `x === x || false`; if `x` is
    a Boolean value, and we exchange `&&` and `||`, and also `true` and `false`, we
    transform one expression into the other, and both are valid.
  prefs: []
  type: TYPE_NORMAL
- en: Checking negatives - none
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you wanted, you could also define `.none()`, as the complement of `.every()`
    -- this new function would be true only if none of the elements of the array satisfied
    the given predicate. The simplest way of coding this would be by noting that if
    no elements satisfy the condition, then all elements satisfy the negation of the
    condition.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: If you want, you can turn it into a method, by modifying the array prototype,
    as we earlier saw -- it's still a bad practice, but it's what we have until we
    start looking into better methods for composing and chaining functions, as in
    [Chapter 8](8e0f575a-87f7-4601-b47c-6872aaacb954.xhtml), *Connecting Functions
    - Pipelining and Composition*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: We had to use `function()`, instead of an arrow function, for the same reasons
    we saw earlier; in this sort of case, we do need `this` to be correctly assigned.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 6](9f36fbcb-da30-4a75-9b47-01cd3427633e.xhtml), *Producing Functions
    - Higher-Order Functions*, we will see other ways of negating a function, by writing
    an appropriate higher-order function of our own.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '5.1\. **Filtering... but what**: Suppose you have an array, called `someArray`,
    and you apply the following `.filter()` to it, which at first sight doesn''t even
    look like valid JS code. What will be in the new array, and why?'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '5.2\. **Generating HTML code, with restrictions**: Using the `filter()`...`map()`...`reduce()`
    sequence is quite common (even allowing that sometimes you won''t use all three)
    and we''ll come back to this in the *Functional Design Patterns* section of [Chapter
    11](24b391f7-abaf-439e-9bfc-a71d989cfd48.xhtml), *Implementing Design Patterns
    - The Functional Way*. The problem here is to use those functions (and none others!)
    to produce an unordered list of elements (`<ul>`...`</ul>`) that can later be
    used onscreen. Your input is an array of objects like the following (does the
    list of characters date me?) and you must produce a list of each name that corresponds
    to chess or checkers players:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The output would be something like the following -- though it doesn't matter
    if you don't generate spaces and indentation. It would be easier if you could
    use, say, `.join()`, but in this case, it won't be allowed; only the three mentioned
    functions can be used.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '5.3 **More formal testing**: In some of the examples preceding, such as in
    the *Emulating* `map()` with `reduce()` section we didn''t write actual unit tests
    but rather were satisfied with doing some console logging. Can you write appropriate
    unit tests instead?'
  prefs: []
  type: TYPE_NORMAL
- en: 5.4\. **Ranging far and wide:** The `range()` function that we saw here can
    have many uses, but lacks a bit in generality. Can you expand it to allow, say,
    for descending ranges, like in `range(10,1)`? (What should the last number in
    the range be?) And, could you also allow for a step size to be included, to specify
    the difference between successive numbers in the range? With this, `range(1,10,2)`
    would produce `[1, 3, 5, 7, 9]`.
  prefs: []
  type: TYPE_NORMAL
- en: '5.5 **Doing the alphabet**: What would have happened in the *Working with ranges*
    section, if instead of writing `map(x => String.fromCharCode(x))` you had simply
    written `map(String.fromCharCode)`? Can you explain the different behavior? Hint:
    we already saw a similar problem elsewhere in this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: '5.6\. **Producing a CSV**: In a certain application, you want to enable the
    user to download a set of data as a CSV (comma separated value) file, by using
    a data URI. (See more at [https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URIs/](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URIs/).)
    Of course, the first problem is to produce the CSV itself! Assume you have an
    array of arrays of numeric values, as shown in the following snippet, and write
    a function that will transform that structure into a CSV string, that you will
    then be able to plug into the URI. As usual, `\n` stands for the newline character:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we have started working with higher-order functions, so as
    to show a more declarative way of working, with shorter, more expressive code.
    We have gone over several operations: we have seen `.reduce()` and `.reduceRight()`,
    to get a single result from an array; `.map()`, to apply a function to each element
    of an array; `.forEach()`, to simplify looping; `.filter()`, to pick elements
    from an array; `.find()` and `.findIndex()`, to search in an array, and `.every()`
    and `.some()`, to verify general logic conditions.'
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 6](9f36fbcb-da30-4a75-9b47-01cd3427633e.xhtml), *Producing Functions
    - Higher-Order Functions*, we will continue working with higher order functions,
    but we will then turn to writing our own ones, to gain more expressive power for
    our coding.
  prefs: []
  type: TYPE_NORMAL
