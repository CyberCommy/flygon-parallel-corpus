- en: Building Microservices Using Rest APIs
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we'll go on a journey to learn about the world of microservices.
    We'll learn about how they are structured, how they communicate, and how they
    persist data. The concept of microservices is a key concept to cover due to the
    fact that most of the modern cloud applications in production today rely on microservices
    to achieve resiliency and scalability.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics :'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Deep diving into the microservices architecture
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RESTful web APIs
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building RESTful APIs in the Go language
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The background
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We provided a practical definition for microservices in the first chapter. In
    this chapter, let's define microservices a bit more.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: To fully appreciate microservices, let's start by telling the story of their
    rise. Before the idea of microservices became popular, most applications used
    to be monolithic. A monolithic application is a single application that tries
    to get numerous tasks accomplished at once. Then, as new features are needed,
    the application will get bigger and bulkier. This, in effect, produced unmaintainable
    applications in the long run. With the emergence of cloud computing, and distributed
    applications with massive loads, the need for a more flexible application architecture
    became obvious.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 1](34c20397-6b29-4142-a491-73f710111135.xhtml), *Modern Microservice
    Architectures*, we provided an introduction to the MyEvents application, which
    we will be expecting to build in this book. The MyEvents application is used to
    manage event bookings for concerts, plays, and so on. The main tasks for the application
    include the following:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: '**Process bookings**: For example, a user makes a booking for a concert next
    month. We will need to store this reservation, ensure that there are seats available
    for this event, and confirm no prior reservations were made with the same name,
    among other things.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Handle events**: Our application needs to be aware of all the concerts, plays,
    and other types of events that we''re expecting to support. We need to know the
    event addresses, the total number of seats, their duration, and so on.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Handle search**: Our application needs to be capable of performing efficient
    searches to retrieve our bookings and events.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following image shows how a monolithic application design for MyEvents
    would look like:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9e7ba468-f203-4763-9927-f25afa449093.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
- en: Monolithic application
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: We'll build multiple software layers within the application to handle each distinct
    task needed. Our application will become a program with a large code base. Since
    the code is all connected, there will always be a risk of change in one layer
    affecting code on the other layers.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Since it's a single program, it won't be easy to write some of the software
    layers in different programming languages. This is typically a very good option
    to have when you know there is a really good library in language X to support
    feature Y, however, language X is not good for feature Z.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Also, as you add new features or layers, your single program will keep growing
    with no good scalability options. Wouldn't it be better to be able to run different
    software layers on different servers so that you can control your application
    load without throwing more hardware on one or two servers?
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Software engineers have tried to solve the monolithic application's dilemma
    for a long time. Microservices is one approach to address the issues that come
    with monolithic applications. Before the term microservices became popular, there
    was the concept of SOA, which was similar in principle to microservices.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Before we dive more into microservices, it is worth mentioning that monolithic
    applications are not always bad. It all depends on what you are trying to achieve.
    If you are trying to build an application that is expected to have a limited set
    of tasks, and not expected to grow by much, then a single well-built application
    might be all you need. If on the other hand, you are looking to build a complex
    application that is expected to perform numerous independent tasks, being maintained
    by multiple people, while handling massive data loads, then the microservices
    architecture is your friend.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: So, what are microservices?
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Simply put, microservices is the idea that instead of putting all of your code
    in one basket (monolithic application), you write multiple small software services
    or *microservices*. Each service is expected to focus on one task and perform
    it well. The accumulation of those services will make up your application.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c86ee87c-6276-4227-b8e1-ae23d271b8be.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
- en: Microservices application
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: For the MyEvents application, each software layer from the monolithic application
    will translate into a software service. This will then communicate together to
    form our application. Each one of those software services will be, in effect,
    a microservice.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: Since those services collaborate to build a complex application, they need to
    be able to communicate via protocols that they all understand. Microservices that
    use web Restful APIs for communication make use of the HTTP protocol extensively.
    We'll cover Restful APIs in more detail in this chapter.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: Microservices internals
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To build proper microservices, there are several components we would need to
    consider. To understand the five components, let''s discuss the main tasks a microservice
    is expected to undertake:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: The microservice will need to be able to send and receive messages with other
    services and the outside world so that tasks can be carried out in harmony. The
    communication aspect of a microservice takes different forms. Restful APIs are
    very popular when interacting with the outside world, and message queues are very
    helpful when communicating with other services. There are other popular techniques
    that are also popular such as **gRPC**.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The microservice will need a configuration layer; this could be via environmental
    variables, a file or database. This configuration layer will tell the microservice
    how to operate. For example, let's assume that our service needs to listen on
    a TCP address and a port number to be able to receive messages; the TCP address
    and the port number will be part of the configuration that gets fed to our service
    when it starts up.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The microservice will need to log events that happen to it so that we can troubleshoot
    issues and understand behaviors. For example, if a communication issue occurs
    while sending a message to another service, we'll need the error to be logged
    somewhere in order for us to be able to identify the problem.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The microservice will need to be able to persist data by storing it in a database
    or other forms of data stores; we'll also need to be able to retrieve data at
    a later time. For example, in case of the MyEvents application, our microservices
    will need to store and retrieve data related to the users, the bookings, and the
    events.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, there is the core, the most important piece of our microservice. The
    core is the code responsible for the task that our microservice is expected to
    do. For example, if our microservice is responsible for handling user bookings,
    then the microservice core is where we write the code that would perform the task
    of handling the user's bookings.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, based on the previous five points, the building blocks of a microservice
    should look like this:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d6337162-f1f4-432d-b2f9-b8cfedbc3356.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
- en: Building blocks of a microservice
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Those building blocks provide a good foundation to build efficient microservices.
    The rules are not set in stone. You can make your microservice either simpler
    or more complex, depending on the application you are trying to build.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这些构建块为构建高效的微服务提供了良好的基础。规则并非一成不变。您可以根据您尝试构建的应用程序使您的微服务变得更简单或更复杂。
- en: RESTful Web APIs
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RESTful Web API
- en: '**REST** stands for **Representational State Transfer**. REST is simply a way
    for different services to communicate and exchange data. The core of the REST
    architecture consists of a client and a server. The server listens for incoming
    messages, then replies to it, whereas the client starts the connection, then sends
    messages to the server.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**REST**代表**表述性状态转移**。REST只是不同服务进行通信和交换数据的一种方式。REST架构的核心包括客户端和服务器。服务器监听传入的消息，然后回复它，而客户端启动连接，然后向服务器发送消息。'
- en: In the modern web programming world, RESTful web applications use the HTTP protocol
    for communication. The RESTful client would be an HTTP client, and the RESTful
    server would be the HTTP server. The HTTP protocol is the key application layer
    communication protocol that powers the internet, which is why RESTful applications
    can also be called web applications. The communication layer of the RESTful applications
    is often simply referred as RESTful APIs.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代网络编程世界中，RESTful网络应用程序使用HTTP协议进行通信。RESTful客户端将是一个HTTP客户端，而RESTful服务器将是HTTP服务器。HTTP协议是支持互联网的关键应用层通信协议，这就是为什么RESTful应用程序也可以称为网络应用程序。RESTful应用程序的通信层通常简称为RESTful
    API。
- en: REST APIs allow applications developed in various types of platforms to communicate.
    This includes other microservices in your application that run on other operating
    systems, as well as client applications running on other devices. For example,
    a smartphone can communicate with your web services reliably via REST.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: REST API允许在各种平台上开发的应用程序进行通信。这包括在其他操作系统上运行的应用程序中的其他微服务，以及在其他设备上运行的客户端应用程序。例如，智能手机可以通过REST可靠地与您的Web服务通信。
- en: '![](img/273f5c32-2834-40fe-8258-1084b7ffbd41.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](img/273f5c32-2834-40fe-8258-1084b7ffbd41.png)'
- en: Web RESTful API
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Web RESTful API
- en: To understand how RESTful applications work, we will first need to gain a decent
    understanding of how the HTTP protocol works. HTTP is an application-level protocol
    used for data communications all over the web, the clouds, and the world of modern
    microservices.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解RESTful应用程序的工作原理，我们首先需要对HTTP协议的工作原理有一个相当好的理解。HTTP是一种应用级协议，用于在整个网络、云和现代微服务世界中进行数据通信。
- en: 'HTTP is a client-server, request-response protocol. This means that the data
    flow works as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP是一种客户端-服务器，请求-响应协议。这意味着数据流程如下：
- en: An HTTP client sends a request to an HTTP server
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP客户端向HTTP服务器发送请求
- en: The HTTP server listens to incoming requests, then responds to them as they
    come
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP服务器监听传入的请求，然后在其到达时做出响应
- en: '![](img/0e6d3274-ef4e-4aac-9b64-2ed72455b6a2.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0e6d3274-ef4e-4aac-9b64-2ed72455b6a2.png)'
- en: Requests and response
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 请求和响应
- en: 'An HTTP client request is typically one of two things:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP客户端请求通常是以下两种情况之一：
- en: The client is requesting a resource from the server
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端正在从服务器请求资源
- en: The client is requesting to add/edit a resource on the server
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端正在请求在服务器上添加/编辑资源
- en: The nature of the resource depends on your application. For example, if your
    client is a web browser trying to access a web page, then your client will send
    a request to the server asking for an HTML web page. The HTML page would be the
    resource returned within the response of the HTTP web server to the client.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 资源的性质取决于您的应用程序。例如，如果您的客户端是尝试访问网页的Web浏览器，那么您的客户端将向服务器发送请求，请求HTML网页。HTML页面将作为资源在HTTP
    Web服务器的响应中返回给客户端。
- en: In the world of communicating microservices, REST applications usually use the
    HTTP protocol in combination with the JSON data format in order to exchange data
    messages.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在通信微服务的世界中，REST应用程序通常使用HTTP协议结合JSON数据格式来交换数据消息。
- en: 'Consider the following scenario: In our MyEvents application, one of our microservices
    needs to obtain the information of an event (duration, start date, end date, and
    location) from another microservice. The microservice in need of the information
    will be our client, whereas the microservice providing the information will be
    our server. Let''s assume that our client microservice has the event ID, but needs
    the server microservice to provide the information of the event that belongs to
    that ID.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下情景：在我们的MyEvents应用程序中，我们的一个微服务需要从另一个微服务获取事件信息（持续时间、开始日期、结束日期和位置）。需要信息的微服务将是我们的客户端，而提供信息的微服务将是我们的服务器。假设我们的客户端微服务具有事件ID，但需要服务器微服务提供属于该ID的事件的信息。
- en: 'The client will send a request inquiring about the event information via the
    event ID; the server will respond with the information enclosed in the JSON format,
    as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端将通过事件ID发送请求，询问有关事件信息；服务器将以JSON格式回复信息，如下所示：
- en: '![](img/7ca15c58-6040-4454-a917-d086045e320b.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7ca15c58-6040-4454-a917-d086045e320b.png)'
- en: JSON document with response
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 带有响应的JSON文档
- en: This description sounds simple; however, it doesn't deliver the full picture.
    The inquiring part of the client needs more elaboration in order for us to understand
    how REST APIs really work.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这个描述听起来很简单；然而，它并没有提供完整的图片。客户端的询问部分需要更多的阐述，以便我们了解REST API的真正工作原理。
- en: There are two primary pieces of information that a REST API client request needs
    to specify in order to declare its intent—the *request URL* and the *request method*.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: REST API客户端请求需要指定两个主要信息以声明其意图——*请求URL*和*请求方法*。
- en: The request URL is the address of the resource at the server that the client
    seeks. An URL is a web address, an example of a REST API URL would be [http://quotes.rest/qod.json](http://quotes.rest/qod.json),
    which is an API service that returns a quote for the day.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 请求URL是客户端寻找的服务器上资源的地址。URL是一个Web地址，REST API URL的一个示例是[http://quotes.rest/qod.json](http://quotes.rest/qod.json)，这是一个返回当天引用的API服务。
- en: In our scenario, the MyEvents client microservice can send an HTTP request to
    the [http://10.12.13.14:5500/events/id/1345](http://10.12.13.14:5500/events/id/1345) URL
    to inquire about event ID `1345`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的场景中，MyEvents客户端微服务可以向[http://10.12.13.14:5500/events/id/1345](http://10.12.13.14:5500/events/id/1345)
    URL发送HTTP请求来查询事件ID`1345`。
- en: 'The request method is basically the type of operation that we would like to
    execute. That could range from a request to obtain a resource to a request to
    edit a resource, add a resource, or even delete a resource. In the HTTP protocol,
    there are multiple types of methods that need to be part of the client request;
    the following are some of the most common methods:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 请求方法基本上是我们想要执行的操作类型。这可以是从请求获取资源到编辑资源、添加资源，甚至删除资源的请求。在HTTP协议中，有多种类型的方法需要成为客户端请求的一部分；以下是一些最常见的方法：
- en: '`GET`: A very common HTTP method in web applications; this is how we request
    a resource from our HTTP web servers; this is the request type we would use in
    our scenario to request the data of event ID `1345`.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET`：在Web应用程序中非常常见的HTTP方法；这是我们从HTTP Web服务器请求资源的方式；这是我们在场景中使用的请求类型，用于请求事件ID`1345`的数据。'
- en: '`POST`: The HTTP method we would use to update or create a resource.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST`：我们用来更新或创建资源的HTTP方法。'
- en: Let's assume that we would like to update a piece of information that belongs
    to event ID 1345 using `POST`, then we'd send a `POST` request to relative URL
    `../events/id/1345` with new event information in the request body.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想使用`POST`更新属于事件ID 1345的某些信息，那么我们将发送一个`POST`请求到相对URL`../events/id/1345`，并在请求体中附上新的事件信息。
- en: If on the other hand, we would like to create a new event that has an ID of
    1346, we shouldn't send a `POST` request to `../events/id/1346` with the new event
    information because the ID doesn't yet exist. What we should do is just send a
    `POST` request to `.../events` and attach all the new event information in the
    request body.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果我们想创建一个ID为1346的新事件，我们不应该发送`POST`请求到`../events/id/1346`，因为该ID尚不存在。我们应该只是发送一个`POST`请求到`.../events`，并在请求体中附上所有新的事件信息。
- en: '`PUT`: The HTTP method to create or overwrite a resource.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PUT`：用于创建或覆盖资源的HTTP方法。'
- en: Unlike `POST`, the `PUT` request can be used to create a new resource by sending
    a request to a resource ID that didn't exist from before. So, for example, if
    we want to create a new event with an ID `1346`, we can send a `PUT` request to
    `../events/id/1346`, and the web server should create the resource for us.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 与`POST`不同，`PUT`请求可以通过向之前不存在的资源ID发送请求来创建新资源。因此，例如，如果我们想创建一个ID为`1346`的新事件，我们可以发送一个`PUT`请求到`../events/id/1346`，Web服务器应该为我们创建资源。
- en: '`PUT` can also be used to fully overwrite an existing resource. So, unlike
    `POST`, we shouldn''t use `PUT` to just update a single piece of information of
    a resource.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`PUT`也可以用于完全覆盖现有资源。因此，与`POST`不同，我们不应该使用`PUT`来仅更新资源的单个信息。'
- en: '`DELETE`: It is used to delete a resource. For example, if we send a delete
    request to the relative URL `../events/id/1345` of the web server, the web server
    will then delete the resource from the database.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DELETE`：用于删除资源。例如，如果我们向Web服务器的相对URL`../events/id/1345`发送删除请求，Web服务器将从数据库中删除资源。'
- en: Gorilla web toolkit
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Gorilla web toolkit
- en: Now that we have covered how web Restful APIs work, it's time to understand
    how to best implement them in Go. The Go language comes with a very powerful web
    package in the standard library; Go also enjoys the support of numerous third-party
    packages. In this book, we will use a very popular Go web third-party toolkit
    called Gorilla web toolkit. The Gorilla web toolkit consists of a collection of
    Go packages that together helps build powerful web applications quickly and efficiently.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了Web Restful API的工作原理，是时候了解如何在Go中最佳实现它们了。Go语言自带了一个非常强大的标准库web包；Go还享受着众多第三方包的支持。在本书中，我们将使用一个非常流行的Go
    web第三方工具包，名为Gorilla web toolkit。Gorilla web toolkit由一系列Go包组成，一起帮助快速高效地构建强大的Web应用程序。
- en: The key package in the Gorilla web toolkit ecosystem is called `gorilla/mux`.
    The `mux` package is described in the package documentation as *a request router
    and dispatcher*. This is basically a software component that accepts an incoming
    HTTP request, then decides what to do based on the nature of the request. For
    example, let's assume that a client sends an HTTP request to our web server. The
    HTTP router dispatcher component in our web server can then detect that the incoming
    request includes a `GET` method with a relative URL of `../events/id/1345`. It
    will then retrieve the information of the event ID `1345` and send it back to
    the client.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Gorilla web toolkit生态系统中的关键包称为`gorilla/mux`。`mux`包在包文档中被描述为*请求路由器和调度器*。这基本上是一个软件组件，它接受传入的HTTP请求，然后根据请求的性质决定要做什么。例如，假设客户端向我们的Web服务器发送了一个HTTP请求。我们的Web服务器中的HTTP路由调度器组件可以检测到传入请求包含一个相对URL为`../events/id/1345`的`GET`方法。然后它将检索事件ID`1345`的信息并将其发送回客户端。
- en: Implementing a Restful API
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施Restful API
- en: 'The first step to utilize the package is to make use of the `go get` command
    in order to obtain the package to our development environment:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 利用该包的第一步是使用`go get`命令将包获取到我们的开发环境中：
- en: '[PRE0]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'With that, the `mux` package will be ready to use. In our code, we can now
    `import` the `mux` package to our web server code:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，`mux`包将准备就绪。在我们的代码中，我们现在可以将`mux`包导入到我们的web服务器代码中：
- en: '[PRE1]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Inside our code, we now need to create a router using the Gorilla `mux` package.
    This is accomplished via the following code:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的代码中，现在需要使用Gorilla `mux`包创建一个路由器。这可以通过以下代码实现：
- en: '[PRE2]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: With this, we will get a router object called `r`, to help us define our routes
    and link them with actions to execute.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们将得到一个名为`r`的路由器对象，帮助我们定义我们的路由并将它们与要执行的操作链接起来。
- en: From this point forward, the code will differ based on the microservice in question
    since different services will support different routes and actions. Earlier in
    this chapter, we covered the following four different types of services to use
    in our MyEvents application—Web UI service, search microservice, bookings microservice,
    and events microservice. Let's focus on the events microservice.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 从这一点开始，代码将根据所涉及的微服务而有所不同，因为不同的服务将支持不同的路由和操作。在本章的前面，我们介绍了在MyEvents应用程序中使用的四种不同类型的服务——Web
    UI服务、搜索微服务、预订微服务和事件微服务。让我们专注于事件微服务。
- en: 'The events microservice will need to support a RESTFul API interface that is
    capable of doing the following:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 事件微服务将需要支持一个RESTFul API接口，能够执行以下操作：
- en: Searching for events via an ID or event name
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过ID或事件名称搜索事件
- en: Retrieving all events at once
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一次性检索所有事件
- en: Creating a new event
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个新事件
- en: Let's focus on each one of those tasks. Since we are in the process of designing
    a web RESTful API for the microservice, each task will need to translate into
    an HTTP method combined with a URL and an HTTP body if need be.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们专注于这些任务中的每一个。由于我们正在设计一个微服务的Web RESTful API，因此每个任务都需要转换为一个HTTP方法，结合一个URL和一个HTTP正文（如果需要）。
- en: 'The following is the break down:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是详细说明：
- en: 'Searching for events via:'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过搜索事件：
- en: 'ID: Relative URL is `/events/id/3434`, method is `GET`, and no data is expected
    in the HTTP body'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ID：相对URL是“/events/id/3434”，方法是“GET”，在HTTP正文中不需要数据
- en: 'Name: Relative URL is `/events/name/jazz_concert`, method is `GET`, and no
    data is expected in the HTTP body'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名称：相对URL是“/events/name/jazz_concert”，方法是“GET”，在HTTP正文中不需要数据
- en: 'Retrieving all events at once: Relative URL is `/events`, method is `GET`,
    and no data is expected in the HTTP body'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一次性检索所有事件：相对URL是“/events”，方法是“GET”，在HTTP正文中不需要数据
- en: 'Creating a new event: Relative URL is `/events`, the method is `POST`, and
    expected data in the HTTP body needs to be the JSON representation of the new
    event we would like to add. Let''s say we would like to add the event of `opera
    aida` that would play in the U.S., then the HTTP body would look like this:'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个新事件：相对URL是“/events”，方法是“POST”，并且HTTP正文中需要的数据是我们想要添加的新事件的JSON表示。假设我们想要添加在美国演出的“歌剧艾达”事件，那么HTTP正文将如下所示：
- en: '![](img/c90b3caa-a35a-4beb-bfec-24831041eb2a.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c90b3caa-a35a-4beb-bfec-24831041eb2a.png)'
- en: Now, if you look at the HTTP translations of each task, you will notice that
    their relative URLs all share a common property, which is the fact that it starts
    with `/events`. In the Gorilla web toolkit, we can create a subrouter for the
    `/events`—relative URL. A subrouter is basically an object that will be in charge
    of any incoming HTTP request directed towards a relative URL that starts with
    `/events`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您查看每个任务的HTTP翻译，您会注意到它们的相对URL都有一个共同的属性，即它们都以“/events”开头。在Gorilla web工具包中，我们可以为“/events”相对URL创建一个子路由器。子路由器基本上是一个对象，负责处理任何指向以“/events”开头的相对URL的传入HTTP请求。
- en: 'To create a subrouter for URLs prefixed with `/events`, the following code
    is needed:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 要为以“/events”为前缀的URL创建一个子路由器，需要以下代码：
- en: '[PRE3]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The preceding code makes use of the router object we created earlier, then calls
    the `PathPrefix` method, which is used to capture any URL path that starts with
    `/events`. Then, finally, we call the `Subrouter()` method, which will create
    a new router object for us to use from now on to handle any incoming requests
    to URLs that start with `/events`. The new router is called `eventsrouter`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码使用了我们之前创建的路由器对象，然后调用了`PathPrefix`方法，用于捕获以“/events”开头的任何URL路径。最后，我们调用了`Subrouter()`方法，这将为我们创建一个新的路由器对象，以便从现在开始处理任何以“/events”开头的URL的传入请求。新的路由器称为`eventsrouter`。
- en: 'Next, the `eventsrouter` object can be used to define what to do with the rest
    of the URLs that share the `/events` prefix. So, let''s revisit the list of HTTP
    translations for our tasks and explore the code needed to get them done:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`eventsrouter`对象可以用来定义其余共享“/events”前缀的URL的操作。因此，让我们重新查看我们任务的HTTP翻译列表，并探索完成它们所需的代码：
- en: '**Task:** Searching for events via:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**任务：**通过搜索事件：'
- en: '`id`: Relative URL is `/events/id/3434`, the method is `GET`, and no data is
    expected in the HTTP body'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`id`：相对URL是“/events/id/3434”，方法是“GET”，在HTTP正文中不需要数据'
- en: '`name`: Relative URL is `/events/name/jazz_concert`, the method is `GET`, and
    no data is expected in the HTTP body:'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`：相对URL是“/events/name/jazz_concert”，方法是“GET”，在HTTP正文中不需要数据：'
- en: '[PRE4]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The handler object in the preceding code is basically the object that implements
    the methods that represent the functionality that we expect to be mapped to the
    incoming HTTP request. More on that later.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码中的处理程序对象基本上是实现我们期望映射到传入HTTP请求的功能的方法的对象。稍后再详细介绍。
- en: '**Task:** Retrieving all events at once—Relative URL is `/events`, the method
    is `GET`, and no data is expected in the HTTP body:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**任务：**一次性检索所有事件——相对URL是“/events”，方法是“GET”，在HTTP正文中不需要数据'
- en: '[PRE5]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '**Task:** Creating a new event—Relative URL is `/events,` the method is `POST`,
    and expected data in the HTTP body needs to be the JSON representation of the
    new event we would like to add:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**任务：**创建一个新事件——相对URL是“/events”，方法是“POST”，并且HTTP正文中需要的数据是我们想要添加的新事件的JSON表示：'
- en: '[PRE6]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: For tasks 2 and 3, the code is self-explanatory. The Gorilla `mux` package allows
    us access to Go methods that eloquently define the properties of the incoming
    HTTP request that we would like to capture. The package also allows us to chain
    the calls together in a line to efficiently structure our code. The `Methods()` call
    defined the expected HTTP method, the `Path()` call defined the expected relative
    URL path (note that we placed the call on the `eventsrouter` object, which would
    append `/events` to the relative path defined in the `Path()` call), and finally
    comes the `HandlerFunc()` method.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任务2和3，代码是不言自明的。Gorilla `mux`包允许我们访问优雅地定义我们想要捕获的传入HTTP请求的属性的Go方法。该包还允许我们将调用链接在一起，以有效地构造我们的代码。`Methods()`调用定义了预期的HTTP方法，`Path()`调用定义了预期的相对URL路径（请注意，我们将调用放在`eventsrouter`对象上，它将在`Path()`调用中定义的相对路径后附加`/events`），最后是`HandlerFunc()`方法。
- en: The `HandlerFunc()` method is how we will link the captured incoming HTTP request
    with an action. `HandlerFunc()` takes an argument of the `func(http.ResponseWriter,
    *http.Request)` type. This argument is basically a function with two important
    arguments—an HTTP response object that we need to fill with our response to the
    incoming request and an HTTP request object, which will contain all the information
    about the incoming HTTP request.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`HandlerFunc()`方法是我们将捕获的传入HTTP请求与操作关联的方式。`HandlerFunc()`接受一个`func(http.ResponseWriter,
    *http.Request)`类型的参数。这个参数基本上是一个具有两个重要参数的函数——一个HTTP响应对象，我们需要用我们的响应填充它，以响应传入的请求，以及一个HTTP请求对象，其中包含有关传入HTTP请求的所有信息。'
- en: The functions we pass to `HandlerFunc()` in the preceding code is `handler.findEventHandler`,
    `handler.allEventHandler`, and `handler.newEventHandler`—all support the `func(http.ResponseWriter,
    *http.Request)` signature. `handler` is a Go struct object, created to host all
    those functions. The `handler` object belongs to a custom Go struct type called
    `eventServiceHandler`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们传递给`HandlerFunc()`的函数是`handler.findEventHandler`、`handler.allEventHandler`和`handler.newEventHandler`，它们都支持`func(http.ResponseWriter,
    *http.Request)`签名。`handler`是一个Go结构对象，用于承载所有这些函数。`handler`对象属于一个名为`eventServiceHandler`的自定义Go结构类型。
- en: 'In order for the `eventServiceHandler` type to support the HTTP handlers for
    tasks 1, 2, and 3, it needs to be defined like this:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使`eventServiceHandler`类型支持任务1、2和3的HTTP处理程序，它需要定义如下：
- en: '[PRE7]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the preceding code, we created `eventServiceHandler` as a struct type with
    no fields, then, we attached three empty methods to it. Each one of the handler
    methods supports the function signature needed to become an argument for the Gorilla
    `mux` package `HandlerFunc()` method. The detailed implementation of each one
    of the `eventServiceHandler` methods will be discussed in more detail in this
    chapter when we cover the persistence layer of our microservice.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们将`eventServiceHandler`创建为一个没有字段的结构类型，然后将三个空方法附加到它上面。每一个处理程序方法都支持成为Gorilla
    `mux`包`HandlerFunc()`方法的参数所需的函数签名。在本章中，当我们讨论微服务的持久层时，将更详细地讨论`eventServiceHandler`方法的详细实现。
- en: Now, let's go back to task 1\. The `/{SearchCriteria}/{search}` path in our
    code represents the equivalent of the `/id/2323` path to search for the event
    ID `2323`, or the path `/name/opera aida` to search for an event with name `opera
    aida`. The curly braces in our path alert the Gorilla `mux` package that `SearchCriteria` and
    `search` are basically variables expected to be substituted in the real-incoming
    HTTP request URL with other things.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到任务1。我们代码中的`/{SearchCriteria}/{search}`路径代表了搜索事件ID`2323`的等价路径`/id/2323`，或者搜索名称为`opera
    aida`的事件的路径`/name/opera aida`。我们路径中的大括号提醒Gorilla `mux`包，`SearchCriteria`和`search`基本上是预期在真实传入的HTTP请求URL中用其他内容替换的变量。
- en: The Gorilla `mux` package enjoys powerful support for URL path variables. It
    also supports pattern-matching via regular expressions. So, for example, if I
    use a path that looks like `/{search:[0-9]+}`, it will provide me a variable called
    `search` that hosts a number.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Gorilla `mux`包支持URL路径变量的强大功能。它还支持通过正则表达式进行模式匹配。因此，例如，如果我使用一个看起来像`/{search:[0-9]+}`的路径，它将为我提供一个名为`search`的变量，其中包含一个数字。
- en: 'After we finish defining our routers, paths, and handlers, we will need to
    specify the local TCP address where our web server will listen for incoming HTTP
    requests. For this, we need Go''s `net/http` package; here''s what the code would
    look like:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们完成定义路由器、路径和处理程序之后，我们需要指定本地TCP地址，以便我们的Web服务器监听传入的HTTP请求。为此，我们需要Go的`net/http`包；代码如下：
- en: '[PRE8]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this single line of code, we created a web server. It will listen for incoming
    HTTP requests on local port `8181` and will use the `r` object as the router for
    the requests. We created the `r` object earlier using the `mux` package.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一行代码中，我们创建了一个Web服务器。它将在本地端口`8181`上监听传入的HTTP请求，并将使用`r`对象作为请求的路由器。我们之前使用`mux`包创建了`r`对象。
- en: It's now time to put all the code we covered up to this point together. Let's
    assume that the code lives inside a function called `ServeAPI()` that is responsible
    for activating the Restful API logic for our microservice.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候将我们到目前为止涵盖的所有代码放在一起了。假设代码位于一个名为`ServeAPI()`的函数中，该函数负责激活我们微服务的Restful API逻辑。
- en: '[PRE9]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We defined the `eventServiceHandler` object to look like this:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了`eventServiceHandler`对象如下：
- en: '[PRE10]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Obviously, the next step will be to fill in the empty methods of the `eventServiceHandler`
    type. We have the `findEventHandler()`, `allEventHandler()`, and `newEventHandler()` methods.
    Each one of them needs a persistence layer to carry out their tasks. That is because
    they either retrieve stored data or add new data to a store.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，下一步将是填写`eventServiceHandler`类型的空方法。我们有`findEventHandler()`、`allEventHandler()`和`newEventHandler()`方法。它们每一个都需要一个持久层来执行它们的任务。这是因为它们要么检索存储的数据，要么向存储添加新数据。
- en: As mentioned earlier in this section, the persistence layer is the component
    of a microservice that is tasked with storing data in databases or retrieving
    data from databases. We arrived to the point where we need to cover the persistence
    layer in much more detail.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中前面提到过，持久层是微服务的一个组件，负责将数据存储在数据库中或从数据库中检索数据。我们已经到了需要更详细地介绍持久层的时候了。
- en: Persistence layer
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持久层
- en: The first decision that needs to be made when designing a persistence layer
    is to decide on the type of the data store. The data store could be a relational
    SQL database such as Microsoft SQL or MySQL, among others. Alternatively, it can
    be a NoSQL store, such as MongoDB, or Apache Cassandra, among others.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计持久层时需要做出的第一个决定是决定数据存储的类型。数据存储可以是关系型SQL数据库，如Microsoft SQL或MySQL等。或者，它可以是NoSQL存储，如MongoDB或Apache
    Cassandra等。
- en: In an efficient and complex production environment, the code needs to be capable
    of switching from one data store to another without too much refactoring. Consider
    the following example—you build a number of microservices for a start-up that
    relies on MongoDB as the data store; then, as the organization changes, you decide
    that AWS cloud-based DynamoDB would make a better data store for the microservices.
    If the code doesn't allow easily unplugging MySQL, then plugging a MongoDB layer
    in its place, tons of code refactoring will be needed in our microservices. In
    Go, we will achieve that flexible design using interfaces.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在高效和复杂的生产环境中，代码需要能够在不需要太多重构的情况下从一个数据存储切换到另一个。考虑以下例子——您为一家依赖MongoDB作为数据存储的初创公司构建了许多微服务；然后，随着组织的变化，您决定AWS基于云的DynamoDB将成为微服务更好的数据存储。如果代码不允许轻松地拔掉MySQL，然后插入MongoDB层，那么我们的微服务将需要大量的代码重构。在Go语言中，我们将使用接口来实现灵活的设计。
- en: It is worth mentioning that in microservices architectures, different services
    can require different types of datastores, so it is normal for one microservice
    to use MongoDB, whereas another service would use MySQL.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一提的是，在微服务架构中，不同的服务可能需要不同类型的数据存储，因此一个微服务使用MongoDB，而另一个服务可能使用MySQL是很正常的。
- en: 'Let''s assume that we are building a persistence layer for the events microservice.
    Based on what we have covered so far, the events microservice persistence layer
    would primarily care about three things:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在为事件微服务构建持久层。根据我们目前所涵盖的内容，事件微服务的持久层主要关心三件事：
- en: Adding a new event to the databases
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向数据库添加新事件
- en: Finding an event by ID
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过ID查找事件
- en: Finding an event by name
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过名称查找事件
- en: 'To achieve flexible code design, we would need the preceding three functionalities
    to be defined in an interface. It would look like this:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现灵活的代码设计，我们需要在接口中定义前面三个功能。它会是这样的：
- en: '[PRE11]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `Event` datatype is a struct type that represents the data of an event,
    such as the event name, location, time, among other things. For now, let's focus
    on the `DatabaseHandler` interface. It supports four methods that represent the
    required tasks from the events service persistence layer. We can then create numerous
    concrete implementations from this interface. One implementation can support MongoDB,
    while another can support the cloud-native AWS DynamoDB database.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`Event`数据类型是一个代表事件数据的结构类型，例如事件名称、位置、时间等。现在，让我们专注于`DatabaseHandler`接口。它支持四种方法，代表了事件服务持久层所需的任务。然后我们可以从这个接口创建多个具体的实现。一个实现可以支持MongoDB，而另一个可以支持云原生的AWS
    DynamoDB数据库。'
- en: We'll cover AWS DynamoDB in a later chapter. In this chapter, the focus will
    be on MongoDB.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在后面的章节中介绍AWS DynamoDB。本章的重点将放在MongoDB上。
- en: MongoDB
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MongoDB
- en: If you are not already familiar with the MongoDB NoSQL database engine, this
    section will be very useful for you.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对MongoDB NoSQL数据库引擎还不熟悉，本节将对您非常有用。
- en: MongoDB is a NoSQL document store database engine. The two keywords to understand
    MongoDB are *NoSQL* and *document store*.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB是一个NoSQL文档存储数据库引擎。理解MongoDB的两个关键词是*NoSQL*和*文档存储*。
- en: NoSQL is a relatively recent keyword in the software industry that is used to
    indicate that a database engine does not deeply rely on relational data. Relational
    data is the idea that there are webs of relations between different pieces of
    data in your database, following the relations between your data will build a
    full picture of what the data represents.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: NoSQL是软件行业中相对较新的关键词，用于指示数据库引擎不太依赖关系数据。关系数据是指数据库中不同数据之间存在关系的概念，遵循数据之间的关系将构建出数据代表的完整图景。
- en: Take MySQL as an example of a relational database. Data gets stored in numerous
    tables, then, primary and foreign keys are used to define the relations between
    the different tables. MongoDB doesn't work this way, which is why MySQL is considered
    as a SQL database, whereas MongoDB is considered NoSQL.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 以MySQL作为关系型数据库的例子。数据存储在多个表中，然后使用主键和外键来定义不同表之间的关系。MongoDB不是这样工作的，这就是为什么MySQL被认为是SQL数据库，而MongoDB被认为是NoSQL数据库。
- en: 'If you are not yet familiar with Mongodb, or don’t have a local installation
    you can test with. Go to [https://docs.mongodb.com/manual/installation/](https://docs.mongodb.com/manual/installation/)
    , where you find a list of helpful links to guide through the process of installing
    and running the database in your operating system of choice. Generally, when installed,
    Mongodb provides two key binaries: `mongod` and `mongo`. The `mongod` command
    is what you need to execute, in order to run your database. Any software you then
    write will communicate with `mongod` to access Mongodb’s data. The `mongo` command,
    on the other hand, is basically a client tool you can use to test the data on
    Mongodb, the `mongo` command communicates with `mongod`, similarly to any application
    you write that accesses the database.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还不熟悉Mongodb，或者没有本地安装可以测试。转到[https://docs.mongodb.com/manual/installation/](https://docs.mongodb.com/manual/installation/)，在那里您会找到一系列有用的链接，指导您完成在所选操作系统中安装和运行数据库的过程。通常，安装后，Mongodb提供两个关键二进制文件：`mongod`和`mongo`。`mongod`命令是您需要执行的，以便运行您的数据库。然后编写的任何软件都将与`mongod`通信，以访问Mongodb的数据。另一方面，`mongo`命令基本上是一个客户端工具，您可以使用它来测试Mongodb上的数据，`mongo`命令与`mongod`通信，类似于您编写的任何访问数据库的应用程序。
- en: 'There are two flavors of MongoDB: the community edition, and the enterprise
    edition. Obviously, the enterprise edition targets larger enterprise installations,
    whereas the community edition is what you’d use for your testing and smaller scale
    deployments.  Here are the links for the community edition guides covering the
    three major operating systems:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种MongoDB：社区版和企业版。显然，企业版针对更大的企业安装，而社区版是您用于测试和较小规模部署的版本。以下是涵盖三个主要操作系统的社区版指南的链接：
- en: 'For linux Mongodb installation and deployment: [https://docs.mongodb.com/manual/administration/install-on-linux/](https://docs.mongodb.com/manual/administration/install-on-linux/)'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于Linux Mongodb安装和部署：[https://docs.mongodb.com/manual/administration/install-on-linux/](https://docs.mongodb.com/manual/administration/install-on-linux/)
- en: 'For Windows Mongodb installation and deployment: [https://docs.mongodb.com/manual/tutorial/install-mongodb-on-windows/](https://docs.mongodb.com/manual/tutorial/install-mongodb-on-windows/)'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows Mongodb安装和部署：[https://docs.mongodb.com/manual/tutorial/install-mongodb-on-windows/](https://docs.mongodb.com/manual/tutorial/install-mongodb-on-windows/)
- en: 'For OS X Mongodb installation and deployment: [https://docs.mongodb.com/manual/tutorial/install-mongodb-on-os-x/](https://docs.mongodb.com/manual/tutorial/install-mongodb-on-os-x/)'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于OS X Mongodb安装和部署：[https://docs.mongodb.com/manual/tutorial/install-mongodb-on-os-x/](https://docs.mongodb.com/manual/tutorial/install-mongodb-on-os-x/)
- en: 'Overall, there are three main steps you need to consider when deploying a Mongodb
    instance:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，在部署Mongodb实例时，有三个主要步骤需要考虑：
- en: 'Install Mongodb for your operating system, the download page can be found here:
    [https://www.mongodb.com/download-center](https://www.mongodb.com/download-center)'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为您的操作系统安装Mongodb，下载页面在这里：[https://www.mongodb.com/download-center](https://www.mongodb.com/download-center)
- en: Ensure MongoDB’s key binaries are defined in your environmental path, so that
    you can run them from the terminal no matter what your current directory is. The
    key binaries are `mongod` and `mongo`. Another binary worth mentioning is `mongos`,
    which is important if you are planning to utilize clustering
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保MongoDB的关键二进制文件在您的环境路径中定义，以便您可以从终端运行它们，无论当前目录是什么。关键二进制文件是`mongod`和`mongo`。另一个值得一提的二进制文件是`mongos`，如果您计划使用集群，则这一点很重要
- en: 'Run the `mongod` command with no arguments, and this will run Mongodb with
    all your default settings. Alternatively, you can use it with different configuration.
    You can either use a configuration file or just runtime parameters. You can find
    information about the configuration file here: [https://docs.mongodb.com/manual/reference/configuration-options/#configuration-file](https://docs.mongodb.com/manual/reference/configuration-options/#configuration-file).  To
     start `mongod` with a custom configuration file, you can use the `--config` option,
    here is an example: `mongod --config /etc/mongod.conf`. On the other hand, for
    runtime parameters, you can just use `--option` to change an option when running
    `mongod`, for example you can type `mongod --port 5454` to start `mongod` on a
    different port than the default'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`mongod`命令，不带任何参数，这将使用所有默认设置运行Mongodb。或者，您可以使用不同的配置。您可以使用配置文件或运行时参数。您可以在这里找到有关配置文件的信息：[https://docs.mongodb.com/manual/reference/configuration-options/#configuration-file](https://docs.mongodb.com/manual/reference/configuration-options/#configuration-file)。要使用自定义配置文件启动`mongod`，可以使用`--config`选项，这是一个示例：`mongod
    --config /etc/mongod.conf`。另一方面，对于运行时参数，您可以在运行`mongod`时使用`--option`来更改选项，例如，您可以键入`mongod
    --port 5454`以在与默认值不同的端口上启动`mongod`
- en: There are different types of NoSQL databases. One of these types is the *document
    store* database. The idea of a document store is that data gets stored in numerous
    document files stacked together to represent what we are trying to store. Let's
    take the data store needed for the event's microservice as an example. If we are
    using a document store in the microservice persistence layer, each event will
    be stored in a separate document with a unique ID. Say that we have an Opera Aida
    event, a Coldplay concert event, and a ballet performance event. In MongoDB, we
    would create a collection of documents called *events*, which will contain three
    documents—one for the Opera, one for Coldplay, and one for the ballet performance.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 有不同类型的NoSQL数据库。其中一种类型是*文档存储*数据库。文档存储的概念是数据存储在许多文档文件中，堆叠在一起以表示我们要存储的内容。让我们以事件微服务所需的数据存储为例。如果我们在微服务持久层中使用文档存储，每个事件将存储在一个单独的带有唯一ID的文档中。假设我们有一个Aida歌剧事件，一个Coldplay音乐会事件和一个芭蕾表演事件。在MongoDB中，我们将创建一个名为*events*的文档集合，其中包含三个文档——一个用于歌剧，一个用于Coldplay，一个用于芭蕾表演。
- en: 'So, to solidify our understanding of how MongoDB would represent this data,
    here is a diagram of the events collection:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了巩固我们对MongoDB如何表示这些数据的理解，这里是事件集合的图表：
- en: '![](img/0f10361f-cb37-42de-b2ee-16b8b80c7786.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0f10361f-cb37-42de-b2ee-16b8b80c7786.png)'
- en: Events collection
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: 'Collections and documents are important concepts in MongoDB. A production MongoDB
    environment typically consists of multiple collections; each collection would
    represent a different piece of our data. So, for example, our MyEvents application
    consists of a number of microservices, each microservice cares about a distinctive
    piece of data. The bookings microservice would store data in a bookings collection,
    and the events microservices would store data in an events collection. We''d also
    need the user''s data to be stored separately in order to manage the users of
    our applications independently. Here is what this would end up looking like:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9bc4b09d-c5d4-4727-b6d7-a08167d37aef.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
- en: Our MongoDB database
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: You can download this file from [https://www.packtpub.com/sites/default/files/downloads/CloudNativeprogrammingwithGolang_ColorImages.pdf](https://www.packtpub.com/sites/default/files/downloads/CloudNativeprogrammingwithGolang_ColorImages.pdf).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: The code bundle for the book is also hosted on GitHub at [https://github.com/PacktPublishing/Cloud-Native-Programming-with-Golang](https://github.com/PacktPublishing/Cloud-Native-programming-with-Golang).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we have focused so far on the events microservice as a showcase on how
    to build a microservice, let''s dive deeper into the events collection, which
    would be used by the event''s microservice:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9422f73b-196c-4be4-a1c2-7e17df8ecd1f.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
- en: Events collection
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: 'Each document in the events collection needs to include all the information
    necessary to represent a single event. Here''s how an event document should look
    like:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5505e49b-7894-44b0-93e1-b4b75e9245f4.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
- en: If you haven't noticed already, the preceding JSON document is the same as the
    HTTP body document that we presented as an example of what the add event API HTTP
    `POST` request body looks like.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to write software that can work with this data, we need to create
    models. Models are basically data structures containing fields that match the
    data we are expecting from the database. In the case of Go, we''d use struct types
    to create our models. Here is what a model for an event should look like:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `Event struct` is the data structure or model for our event document. It
    contains the ID, event name, event duration, event start date, event end date,
    and event location. Since the event location needs to hold more information than
    just a single field, we will create a struct type called location to model a location.
    The `Location struct` type contains the location's name, address, country, open
    time and close time, and the halls in that area. A hall is basically the room
    inside the location where the event is taking place.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: So, for example, Mountain View, Opera house in downtown Mountain View would
    be the location, whereas the silicon valley room on the east side would be the
    hall.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: In turn, the hall cannot be represented by a single field since we need to know
    its name, its location in the building (south-east, west, and so forth), and its
    capacity (the number of people it can host).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: The `bson.ObjectId` type in the event struct is a special type that represents
    MongoDB document ID. The `bson` package can be found in the `mgo` adapter, which
    is the Go third part framework of choice to communicate with MongoDB. The `bson.ObjectId`
    type also provides some helpful methods that we can use later in our code to verify
    the validity of the ID.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: Before we start covering `mgo`, let's take a moment to explain what `bson` means.
    `bson` is a data format used by MongoDB to represent data in stored documents.
    It could be simply considered as binary JSON because it is a binary-encoded serialization
    of JSON-like documents. The specification can be found at: [http://bsonspec.org/](http://bsonspec.org/).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's cover `mgo`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: MongoDB and the Go language
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: mgo is a popular MongoDB driver written in the Go language. The package page
    can be found at: [http://labix.org/mgo](http://labix.org/mgo). The driver is nothing
    more than a number of Go packages that facilitate writing Go programs capable
    of working with MongoDB.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to make use of `mgo`, the first step is to make use of the `go get`
    command to retrieve the package:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: With the preceding command executed, we get the ability to use `mgo` in our
    code. We'd need to import the `mgo` package and the `bson` package that we discussed
    earlier. The package name we use to host our MongoDB persistence layer is called
    `mongolayer`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at the `mongolayer` package:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Next, let''s create some constants to represent the name of our database and
    the names of the collections involved in our persistence layer. The database name
    in MongoDB would be `myevents`. The collection names we''ll use are `users` for
    the users collection, and `events` for the collection of events in our database:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In order to expose the features of the `mgo` package, we will need to utilize
    a database session object that belongs to the `mgo` package, the session object
    type is called `*mgo.session`. To make use of `*mgo.session` inside our code,
    we will wrap it with a struct type called `MongoDBLayer`, as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: It is now time to implement the `DatabaseHandler` interface that we covered
    earlier in order to construct the concrete persistence layer of our application.
    In the Go language, it is typically preferred to use a pointer type when implementing
    an interface because pointers preserve references to the original memory addresses
    of the underlying objects as opposed to copying the entire object around when
    we make use of it. In other words, the implementer object type for the `DatabaseHandler`
    interface needs to be a pointer to a `MongoDBLayer` struct object, or just simply
    `*MongoDBLayer`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: 'However, before we start implementing the interface, we will first need to
    create a constructor function that returns an object of the `*MongoDBLayer` type.
    This is idiomatic in Go in order for us to be able to execute any necessary initialization
    code while creating a new object of the `*MongoDBLayer` type. In our cases, the
    initialization code is basically to obtain a connection session handler to the
    desired MongoDB database address. The following is what the constructor code will
    look like:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the preceding code, we created a constructor function called `NewMongoDBLayer`,
    which requires a single argument of type string. The argument represents the connection
    string with the information needed to establish the connection to the MongoDB
    database. According to `mgo` documentation at [https://godoc.org/gopkg.in/mgo.v2#Dial](https://godoc.org/gopkg.in/mgo.v2#Dial),
    the format of the connection string needs to look like this:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d5bfd2e3-f4bc-45d4-9c86-8cbf1998639b.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
- en: If it is just a localhost connection, the connection string will look as follows: `mongodb://127.0.0.1`
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: If a port number is not provided in the connection string, the port defaults
    to `27017`.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's look at the code inside our constructor function. In the first line,
    we call `mgo.Dial()` with the connection string as an argument. The `mgo.Dial()`
    is the function in the `mgo` package, which will return a MongoDB connection session
    for us to use later in our code. It returns two results—the `*mgo.Session` object
    and an error object. We use struct literals at the end to return a fresh object
    of type pointer to `MongoDBLayer`, which hosts the newly created `*mgo.Session`
    object. We also return the error object so that we communicate to the caller any
    errors that would have occurred during the initialization process.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Now, with the constructor out of the way, it's time to implement the methods
    of the `DatabaseHandler` interface. So far, we have four methods—`AddEvent(Event)`,
    `FindEvent([]byte)`, `FindEventByName(string)`, and `FindAllAvailableEvents()`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is what the code for the `AddEvent(Event)` method will look like:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The method takes an argument of type  `persistence.Event`, which models the
    information expected from an event as we covered earlier. It returns a slice of
    bytes, which represents the event ID, and an error object, which will be nil if
    no errors are found.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: 'In the first line, we call a `getFreshSession()` method—this is a helper method
    implemented in our code to help retrieve a fresh database session from the connection
    pool. Here is what the method code looks like:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `session.Copy()` is the method that is called whenever we are requesting
    a new session from the `mgo` package connection pool. `mgoLayer.session` here
    is basically the `*mgo.Session` object we have hosted inside the `MongoDBLayer`
    struct. It is idiomatic to call `session.Copy()` at the beginning of any method
    or function that is about to issue queries or commands to MongoDB via the `mgo`
    package. The `getFreshSession()` method is just a helper method that calls `session.Copy()` for
    us and returns the resulting session.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's return to the `AddEvent()` method. We now have a working `*mgo.Session`
    object from the database connection pool to use in our code. The first thing to
    do is to call defer `s.Close()` to ensure that this session gets returned back
    to the `mgo` database connection pool after the `AddEvent()` method exits.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Next, we check whether the event ID supplied by the `Event` argument object
    is valid and whether the ID field of the `Event` object is of the `bson.ObjectID` type
    as we covered earlier. `bson.ObjectID` supports a `Valid()` method, which we can
    use to detect whether the ID is a valid MongoDB document ID or not. If the supplied
    event ID is not valid, we will create one of our own using the `bson.NewObjectID()`
    function call. We will then repeat the same pattern with the location-embedded
    object inside the event.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Finally, at the end, we will return two results—the first result is the event
    ID of the added event, and a second result is an error object representing the
    result of the event insertion operation. In order to insert the event object to
    the MongoDB database, we will use the session object in the `s` variable, then
    call `s.DB(DB).C(EVENTS)` to obtain an object that represents our events collection
    in the database. The object will be of the `*mgo.Collection` type. The `DB()`
    method helps us access the database; we will give it the `DB` constant as an argument,
    which has our database name. The `C()` method helps us access the collection;
    we will give it the `EVENTS` constant, which has the name of our events collection.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: The `DB` and `EVENTS` constants were defined earlier in our code. Then, finally,
    we will call the `Insert()` method of the collection object, with the `Event`
    object as an argument, which is why the code ends up looking like this—`s.DB(DB).C(EVENTS).Insert(e)`.
    This line is what we need in order to insert a new document into a MongoDB database
    collection that utilizes Go objects and the `mgo` package.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s look at the code for `FindEvent()`, which we use to retrieve the
    information of a certain event from the database from its ID. The code will look
    as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note how the ID is passed as a slice of bytes instead of a `bson.ObjectId` type.
    We do this to ensure that the `FindEvent()` method in the `DatabaseHandler` interface
    stays as generic as possible. For example, we know that in the world of MongoDB,
    the ID will be of the `bson.ObjectId` type, but what if we now want to implement
    a MySQL database layer? It would not make sense to have the ID argument type passed
    to `FindEvent()` as `bson.ObjectId`. So, that's why we picked the `[]byte` type
    to represent our ID argument. In theory, we should be able to convert a slice
    of bytes to any other type that can represent an id.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: An important remark is that we could also have picked the empty interface type
    (`interface{}`), which in Go can be converted to any other type.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: In the first line of the `FindEvent()` method, we obtained a fresh session from
    the connection pool using the `mgoLayer.getFreshSession()` as before. We then
    call `defer s.Close()` to ensure that the session goes back to the connection
    pool after we are done.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: Next, we created an empty event object `e` using the code `e := persistence.Event{}`.
    We then use `s.DB(DB).C(EVENTS)` to access the events collection in MongoDB. There
    is a method called `FindId()`, which is supported by `*mgoCollection` objects
    of `mgo`. The method takes an object of the `bson.ObjectId` type as an argument
    then searches for the document with the desired ID.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '`FindId()` returns an object of the `*mgo.Query` type, which is a common type
    in `mgo` that we can use to retrieve results of queries. In order to feed the
    retrieved document data to the `e` object we created earlier, we will need to
    call the `One()` method, which belongs to the `*mgo.Query` type, and pass a reference
    to `e` as an argument. By doing this, `e` will obtain the data of the retrieved
    document with the desired ID. If the operation fails, the `One()` method will
    return an error object containing the error information, otherwise `One()` will
    return nil.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: At the end of the `FindEvent()` method, we will return the event object and
    the error object.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s look at the implementation of the `FindEventByName()` method, which
    retrieves an event by its name from the MongoDB database. Here is what the code
    looks like:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The method is very similar to the `FindEvent()` method, except for two things.
    The first difference is the fact that `FindEvent()` takes a string as an argument,
    which represents the event name that we would like to find.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: 'The second difference is that we query for an event name instead of an event
    ID. The code line where we query the document uses a method called `Find()` instead
    of `FindId()`, which makes the code look like this:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `Find()` method takes an argument that represents the query we would like
    to pass along to MongoDB. The `bson` package provides a nice type called `bson.M`,
    which is basically a map we can use to represent the query parameters that we
    would like to look for. In our case, we are looking for the name that got passed
    as an argument to `FindEventByName`. The name field in the event collection in
    our database is simply coded as `name`, whereas the variable that got passed to
    us as an argument and has the name is called `name`. Hence, our query ends up
    as `bson.M{"name":name}`.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: 'Last but not least is our `FindAllAvailableEvents()` method. The method returns
    all available events in our database. In other words, it returns the entire events
    collection from our MongoDB database. Here is what the code looks like:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The code is almost the same as `FindEventByName()`, except for three simple
    differences. The first difference is obviously the fact that `FindAllAvailableEvents()`
    doesn't take any arguments.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: The second difference is the fact that we need the query results to be fed to
    a slice of the event's objects instead of a single event object. This is why the
    return type is `[]persistence.Event` , instead of just `persistence.Event`.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: 'The third difference is that the `Find()` method will take an argument of nil
    instead of a `bson.M` object. This will cause the code to look like this:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: When the `Find()` method gets a nil argument, it will return everything found
    in the associated MongoDB collection. Also, note that we used `All()` instead
    of `One()` after `Find()`. That is because we expect multiple results and not
    just one.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: With this, we finish covering our persistence layer.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: Implementing our RESTful APIs handler functions
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So, now that have covered our persistence layer, it''s time to return to our
    RESTful API handlers and cover their implementation. Earlier in this chapter,
    we defined the `eventServiceHandler` struct type to look like this:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `eventServiceHandler` type now needs to support the `DatabaseHandler` interface
    type we created earlier in the chapter in order to be capable of performing database
    operations. This will make the struct look like this:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Next, we will need to write a constructor to initialize the `eventServiceHandler`
    object; it will look as follows:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: However, we left the three methods of the `eventServiceHandler` struct type
    empty. Let's go through them one by one.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: 'The first method `findEventHandler()` is responsible for handling HTTP requests
    used to query events stored in our database. We can query events via their IDs
    or names. As mentioned earlier in the chapter, when searching for an ID, the request
    URL will resemble `/events/id/3434` and will be of the `GET` type. On the other
    hand, when searching by name, the request will resemble `/events/name/jazz_concert`
    and be of the `GET` type. As a reminder, the following is how we defined the path
    and linked it to the handler:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '`{SearchCriteria}` and `{Search}` are two variables in our path. `{SearchCriteria}`
    can be replaced with `id` or `name`.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is what the code for the `findEventHandler` method will look like:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The method takes two arguments: an object of the `http.ResponseWriter` type, which
    represents the HTTP response we need to fill, whereas the second argument is of
    the `*http.Request` type, which represents the HTTP request that we received.
    In the first line, we use `mux.Vars()` with the request object as an argument;
    this will return a map of keys and values, which will represent our request URL
    variables and their values. So, for example, if the request URL looks like `/events/name/jazz_concert`,
    we will have two key-value pairs in our resulting map—the first key is `"SearchCriteria"`
    with a value of `"name"`, whereas the second key is `"search"` with a value of
    `jazz_concert`. The resulting map is stored in the vars variable.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: 'We then obtain the criteria from our map in the next line:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: So, the criteria variable will now have either `name` or `id` if the user sent
    the correct request URL. The `ok` variable is of the boolean type; if `ok` is
    true, then we will find a key called `SearchCriteria` in our `vars` map. If it
    is false, then we know that the request URL we received is not valid.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we check whether we retrieved the search criteria; if we didn''t, then
    we report the error and then exit. Notice here how we report the error in a JSON
    like format? That is because it is typically preferred for RESTful APIs with JSON
    body formats to return everything in JSON form, including errors. Another way
    to do this is to create a JSONError type and feed it our error strings; however,
    I will just spell out the JSON string here in the code for simplicity:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '`fmt.Fprint` allows us to write the error message directly to the `w` variable,
    which contains our HTTP response writer. The `http.responseWriter` object type
    supports Go''s `io.Writer` interface, which can be used with `fmt.Fprint()`.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will need to do the same with the `{search}` variable:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'It''s time to extract the information from the database based on the provided
    request URL variables; here is how we do it:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In case of the name search criteria, we will use the `FindEventByName()` database
    handler method to search by name. In case of the ID search criteria, we will convert
    the search key to a slice of bytes using `hex.DecodeString()`—if we successfully
    obtain the slice of bytes, we will call `FindEvent()` with the obtained ID.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: 'We then check whether any errors occurred during the database operations by
    checking the err object. If we find errors, we write a `404` error header in our
    response, then print the error in the HTTP response body:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The last thing we need to do is to convert the response to a JSON format, so
    we change the HTTP `content-type` header to `application/json`; then, we use the
    powerful Go JSON package to convert the results obtained from our database calls
    to the JSON format:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now, let''s look at the code for the `allEventHandler()` method, which will
    return all the available events in the HTTP response:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We start by calling the `FindAllAvailableEvents()` that belongs to the database
    handler in order to obtain all events from the database. We then check whether
    any errors occurred. If any found, we write an error header, print the error to
    the HTTP response, and then return from the function.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: If no errors have occurred, we write `application/json` to the `Content-Type` header
    of the HTTP response. We then encode the events to the JSON format and send them
    to the HTTP response writer object. Again, if any errors occur, we will log them
    and then exit.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s discuss the `newEventHandler()` handler method, which will add
    a new event to our database using the data retrieved from incoming HTTP requests.
    We expect the event data in the incoming HTTP request to be in the JSON format.
    Here is what the code will look like:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In the first line, we create a new object of the `persistence.Event` type, which
    we will use to hold the data we are expecting to parse out from the incoming HTTP
    request.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: 'In the second line, we use Go''s JSON package to take the body of the incoming
    HTTP request (which we obtain by calling `r.Body`). We then decode the JSON data
    embedded in it and feed it to the new event object, as follows:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We then check our errors as usual. If no errors are observed, we call the `AddEvent()`
    method of our database handler and pass the event object as the argument. This
    in effect will add the event object we obtained from the incoming HTTP request
    to the database. We then check errors again as usual and exit.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: 'To put the final touches on our events microservice, we will need to do three
    things. The first is to allow the `ServeAPI()` function we covered earlier in
    this chapter, which define the HTTP routes and handlers, to call the `eventServiceHandler`
    constructor. The code will end up looking like this:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The second final touch we need to do is to write a configuration layer for
    our microservice. As mentioned earlier in the chapter, a well-designed microservice
    needs a configuration layer which reads from a file, a database, an environmental
    variable, or a similar medium. There are three main parameters we need to support
    for now for our configuration—the database type used by our microservice (MongoDB
    is our default), the database connection string (default is `mongodb://127.0.0.1`
    for a local connection), and the Restful API endpoint. Here is what our configuration
    layer will end up looking like:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The third touch is to build a database layer package that acts as the gateway
    to the persistence layer in our microservice. The package will utilize the factory
    design pattern by implementing a factory function. A factory function will manufacture
    our database handler.  This is done by taking the name of the database that we
    would like to connect to, as well as the connection string, then returning a database
    handler object which we can use for database related tasks from this point forward.
    We currently only support MongoDB, so here is how this would look like:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The fourth and final touch is our `main` package. We will write the main function
    that makes use of the `flag` package to take the location of the configuration
    file from the user and then use the configuration file to initialize the database
    connection and the HTTP server. The following is the resultant code:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: With this piece of code, we come to the conclusion of this chapter. In the next
    chapter, we will discuss how to secure our microservice.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered a wide range of topics regarding designing and building
    modern microservices. You now should have practical knowledge regarding RESTful
    web APIs, NoSQL data stores like MongoDB, and proper Go design patterns for scalable
    code.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
