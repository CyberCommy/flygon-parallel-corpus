- en: Building Microservices Using Rest APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we'll go on a journey to learn about the world of microservices.
    We'll learn about how they are structured, how they communicate, and how they
    persist data. The concept of microservices is a key concept to cover due to the
    fact that most of the modern cloud applications in production today rely on microservices
    to achieve resiliency and scalability.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics :'
  prefs: []
  type: TYPE_NORMAL
- en: Deep diving into the microservices architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RESTful web APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building RESTful APIs in the Go language
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The background
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We provided a practical definition for microservices in the first chapter. In
    this chapter, let's define microservices a bit more.
  prefs: []
  type: TYPE_NORMAL
- en: To fully appreciate microservices, let's start by telling the story of their
    rise. Before the idea of microservices became popular, most applications used
    to be monolithic. A monolithic application is a single application that tries
    to get numerous tasks accomplished at once. Then, as new features are needed,
    the application will get bigger and bulkier. This, in effect, produced unmaintainable
    applications in the long run. With the emergence of cloud computing, and distributed
    applications with massive loads, the need for a more flexible application architecture
    became obvious.
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 1](34c20397-6b29-4142-a491-73f710111135.xhtml), *Modern Microservice
    Architectures*, we provided an introduction to the MyEvents application, which
    we will be expecting to build in this book. The MyEvents application is used to
    manage event bookings for concerts, plays, and so on. The main tasks for the application
    include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Process bookings**: For example, a user makes a booking for a concert next
    month. We will need to store this reservation, ensure that there are seats available
    for this event, and confirm no prior reservations were made with the same name,
    among other things.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Handle events**: Our application needs to be aware of all the concerts, plays,
    and other types of events that we''re expecting to support. We need to know the
    event addresses, the total number of seats, their duration, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Handle search**: Our application needs to be capable of performing efficient
    searches to retrieve our bookings and events.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following image shows how a monolithic application design for MyEvents
    would look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9e7ba468-f203-4763-9927-f25afa449093.png)'
  prefs: []
  type: TYPE_IMG
- en: Monolithic application
  prefs: []
  type: TYPE_NORMAL
- en: We'll build multiple software layers within the application to handle each distinct
    task needed. Our application will become a program with a large code base. Since
    the code is all connected, there will always be a risk of change in one layer
    affecting code on the other layers.
  prefs: []
  type: TYPE_NORMAL
- en: Since it's a single program, it won't be easy to write some of the software
    layers in different programming languages. This is typically a very good option
    to have when you know there is a really good library in language X to support
    feature Y, however, language X is not good for feature Z.
  prefs: []
  type: TYPE_NORMAL
- en: Also, as you add new features or layers, your single program will keep growing
    with no good scalability options. Wouldn't it be better to be able to run different
    software layers on different servers so that you can control your application
    load without throwing more hardware on one or two servers?
  prefs: []
  type: TYPE_NORMAL
- en: Software engineers have tried to solve the monolithic application's dilemma
    for a long time. Microservices is one approach to address the issues that come
    with monolithic applications. Before the term microservices became popular, there
    was the concept of SOA, which was similar in principle to microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Before we dive more into microservices, it is worth mentioning that monolithic
    applications are not always bad. It all depends on what you are trying to achieve.
    If you are trying to build an application that is expected to have a limited set
    of tasks, and not expected to grow by much, then a single well-built application
    might be all you need. If on the other hand, you are looking to build a complex
    application that is expected to perform numerous independent tasks, being maintained
    by multiple people, while handling massive data loads, then the microservices
    architecture is your friend.
  prefs: []
  type: TYPE_NORMAL
- en: So, what are microservices?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Simply put, microservices is the idea that instead of putting all of your code
    in one basket (monolithic application), you write multiple small software services
    or *microservices*. Each service is expected to focus on one task and perform
    it well. The accumulation of those services will make up your application.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c86ee87c-6276-4227-b8e1-ae23d271b8be.png)'
  prefs: []
  type: TYPE_IMG
- en: Microservices application
  prefs: []
  type: TYPE_NORMAL
- en: For the MyEvents application, each software layer from the monolithic application
    will translate into a software service. This will then communicate together to
    form our application. Each one of those software services will be, in effect,
    a microservice.
  prefs: []
  type: TYPE_NORMAL
- en: Since those services collaborate to build a complex application, they need to
    be able to communicate via protocols that they all understand. Microservices that
    use web Restful APIs for communication make use of the HTTP protocol extensively.
    We'll cover Restful APIs in more detail in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Microservices internals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To build proper microservices, there are several components we would need to
    consider. To understand the five components, let''s discuss the main tasks a microservice
    is expected to undertake:'
  prefs: []
  type: TYPE_NORMAL
- en: The microservice will need to be able to send and receive messages with other
    services and the outside world so that tasks can be carried out in harmony. The
    communication aspect of a microservice takes different forms. Restful APIs are
    very popular when interacting with the outside world, and message queues are very
    helpful when communicating with other services. There are other popular techniques
    that are also popular such as **gRPC**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The microservice will need a configuration layer; this could be via environmental
    variables, a file or database. This configuration layer will tell the microservice
    how to operate. For example, let's assume that our service needs to listen on
    a TCP address and a port number to be able to receive messages; the TCP address
    and the port number will be part of the configuration that gets fed to our service
    when it starts up.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The microservice will need to log events that happen to it so that we can troubleshoot
    issues and understand behaviors. For example, if a communication issue occurs
    while sending a message to another service, we'll need the error to be logged
    somewhere in order for us to be able to identify the problem.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The microservice will need to be able to persist data by storing it in a database
    or other forms of data stores; we'll also need to be able to retrieve data at
    a later time. For example, in case of the MyEvents application, our microservices
    will need to store and retrieve data related to the users, the bookings, and the
    events.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, there is the core, the most important piece of our microservice. The
    core is the code responsible for the task that our microservice is expected to
    do. For example, if our microservice is responsible for handling user bookings,
    then the microservice core is where we write the code that would perform the task
    of handling the user's bookings.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, based on the previous five points, the building blocks of a microservice
    should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d6337162-f1f4-432d-b2f9-b8cfedbc3356.png)'
  prefs: []
  type: TYPE_IMG
- en: Building blocks of a microservice
  prefs: []
  type: TYPE_NORMAL
- en: Those building blocks provide a good foundation to build efficient microservices.
    The rules are not set in stone. You can make your microservice either simpler
    or more complex, depending on the application you are trying to build.
  prefs: []
  type: TYPE_NORMAL
- en: RESTful Web APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**REST** stands for **Representational State Transfer**. REST is simply a way
    for different services to communicate and exchange data. The core of the REST
    architecture consists of a client and a server. The server listens for incoming
    messages, then replies to it, whereas the client starts the connection, then sends
    messages to the server.'
  prefs: []
  type: TYPE_NORMAL
- en: In the modern web programming world, RESTful web applications use the HTTP protocol
    for communication. The RESTful client would be an HTTP client, and the RESTful
    server would be the HTTP server. The HTTP protocol is the key application layer
    communication protocol that powers the internet, which is why RESTful applications
    can also be called web applications. The communication layer of the RESTful applications
    is often simply referred as RESTful APIs.
  prefs: []
  type: TYPE_NORMAL
- en: REST APIs allow applications developed in various types of platforms to communicate.
    This includes other microservices in your application that run on other operating
    systems, as well as client applications running on other devices. For example,
    a smartphone can communicate with your web services reliably via REST.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/273f5c32-2834-40fe-8258-1084b7ffbd41.png)'
  prefs: []
  type: TYPE_IMG
- en: Web RESTful API
  prefs: []
  type: TYPE_NORMAL
- en: To understand how RESTful applications work, we will first need to gain a decent
    understanding of how the HTTP protocol works. HTTP is an application-level protocol
    used for data communications all over the web, the clouds, and the world of modern
    microservices.
  prefs: []
  type: TYPE_NORMAL
- en: 'HTTP is a client-server, request-response protocol. This means that the data
    flow works as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: An HTTP client sends a request to an HTTP server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The HTTP server listens to incoming requests, then responds to them as they
    come
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/0e6d3274-ef4e-4aac-9b64-2ed72455b6a2.png)'
  prefs: []
  type: TYPE_IMG
- en: Requests and response
  prefs: []
  type: TYPE_NORMAL
- en: 'An HTTP client request is typically one of two things:'
  prefs: []
  type: TYPE_NORMAL
- en: The client is requesting a resource from the server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The client is requesting to add/edit a resource on the server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The nature of the resource depends on your application. For example, if your
    client is a web browser trying to access a web page, then your client will send
    a request to the server asking for an HTML web page. The HTML page would be the
    resource returned within the response of the HTTP web server to the client.
  prefs: []
  type: TYPE_NORMAL
- en: In the world of communicating microservices, REST applications usually use the
    HTTP protocol in combination with the JSON data format in order to exchange data
    messages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following scenario: In our MyEvents application, one of our microservices
    needs to obtain the information of an event (duration, start date, end date, and
    location) from another microservice. The microservice in need of the information
    will be our client, whereas the microservice providing the information will be
    our server. Let''s assume that our client microservice has the event ID, but needs
    the server microservice to provide the information of the event that belongs to
    that ID.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The client will send a request inquiring about the event information via the
    event ID; the server will respond with the information enclosed in the JSON format,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7ca15c58-6040-4454-a917-d086045e320b.png)'
  prefs: []
  type: TYPE_IMG
- en: JSON document with response
  prefs: []
  type: TYPE_NORMAL
- en: This description sounds simple; however, it doesn't deliver the full picture.
    The inquiring part of the client needs more elaboration in order for us to understand
    how REST APIs really work.
  prefs: []
  type: TYPE_NORMAL
- en: There are two primary pieces of information that a REST API client request needs
    to specify in order to declare its intent—the *request URL* and the *request method*.
  prefs: []
  type: TYPE_NORMAL
- en: The request URL is the address of the resource at the server that the client
    seeks. An URL is a web address, an example of a REST API URL would be [http://quotes.rest/qod.json](http://quotes.rest/qod.json),
    which is an API service that returns a quote for the day.
  prefs: []
  type: TYPE_NORMAL
- en: In our scenario, the MyEvents client microservice can send an HTTP request to
    the [http://10.12.13.14:5500/events/id/1345](http://10.12.13.14:5500/events/id/1345) URL
    to inquire about event ID `1345`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The request method is basically the type of operation that we would like to
    execute. That could range from a request to obtain a resource to a request to
    edit a resource, add a resource, or even delete a resource. In the HTTP protocol,
    there are multiple types of methods that need to be part of the client request;
    the following are some of the most common methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GET`: A very common HTTP method in web applications; this is how we request
    a resource from our HTTP web servers; this is the request type we would use in
    our scenario to request the data of event ID `1345`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`POST`: The HTTP method we would use to update or create a resource.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's assume that we would like to update a piece of information that belongs
    to event ID 1345 using `POST`, then we'd send a `POST` request to relative URL
    `../events/id/1345` with new event information in the request body.
  prefs: []
  type: TYPE_NORMAL
- en: If on the other hand, we would like to create a new event that has an ID of
    1346, we shouldn't send a `POST` request to `../events/id/1346` with the new event
    information because the ID doesn't yet exist. What we should do is just send a
    `POST` request to `.../events` and attach all the new event information in the
    request body.
  prefs: []
  type: TYPE_NORMAL
- en: '`PUT`: The HTTP method to create or overwrite a resource.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unlike `POST`, the `PUT` request can be used to create a new resource by sending
    a request to a resource ID that didn't exist from before. So, for example, if
    we want to create a new event with an ID `1346`, we can send a `PUT` request to
    `../events/id/1346`, and the web server should create the resource for us.
  prefs: []
  type: TYPE_NORMAL
- en: '`PUT` can also be used to fully overwrite an existing resource. So, unlike
    `POST`, we shouldn''t use `PUT` to just update a single piece of information of
    a resource.'
  prefs: []
  type: TYPE_NORMAL
- en: '`DELETE`: It is used to delete a resource. For example, if we send a delete
    request to the relative URL `../events/id/1345` of the web server, the web server
    will then delete the resource from the database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gorilla web toolkit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have covered how web Restful APIs work, it's time to understand
    how to best implement them in Go. The Go language comes with a very powerful web
    package in the standard library; Go also enjoys the support of numerous third-party
    packages. In this book, we will use a very popular Go web third-party toolkit
    called Gorilla web toolkit. The Gorilla web toolkit consists of a collection of
    Go packages that together helps build powerful web applications quickly and efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: The key package in the Gorilla web toolkit ecosystem is called `gorilla/mux`.
    The `mux` package is described in the package documentation as *a request router
    and dispatcher*. This is basically a software component that accepts an incoming
    HTTP request, then decides what to do based on the nature of the request. For
    example, let's assume that a client sends an HTTP request to our web server. The
    HTTP router dispatcher component in our web server can then detect that the incoming
    request includes a `GET` method with a relative URL of `../events/id/1345`. It
    will then retrieve the information of the event ID `1345` and send it back to
    the client.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a Restful API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first step to utilize the package is to make use of the `go get` command
    in order to obtain the package to our development environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'With that, the `mux` package will be ready to use. In our code, we can now
    `import` the `mux` package to our web server code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside our code, we now need to create a router using the Gorilla `mux` package.
    This is accomplished via the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: With this, we will get a router object called `r`, to help us define our routes
    and link them with actions to execute.
  prefs: []
  type: TYPE_NORMAL
- en: From this point forward, the code will differ based on the microservice in question
    since different services will support different routes and actions. Earlier in
    this chapter, we covered the following four different types of services to use
    in our MyEvents application—Web UI service, search microservice, bookings microservice,
    and events microservice. Let's focus on the events microservice.
  prefs: []
  type: TYPE_NORMAL
- en: 'The events microservice will need to support a RESTFul API interface that is
    capable of doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Searching for events via an ID or event name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Retrieving all events at once
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a new event
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's focus on each one of those tasks. Since we are in the process of designing
    a web RESTful API for the microservice, each task will need to translate into
    an HTTP method combined with a URL and an HTTP body if need be.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the break down:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Searching for events via:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ID: Relative URL is `/events/id/3434`, method is `GET`, and no data is expected
    in the HTTP body'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Name: Relative URL is `/events/name/jazz_concert`, method is `GET`, and no
    data is expected in the HTTP body'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Retrieving all events at once: Relative URL is `/events`, method is `GET`,
    and no data is expected in the HTTP body'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Creating a new event: Relative URL is `/events`, the method is `POST`, and
    expected data in the HTTP body needs to be the JSON representation of the new
    event we would like to add. Let''s say we would like to add the event of `opera
    aida` that would play in the U.S., then the HTTP body would look like this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/c90b3caa-a35a-4beb-bfec-24831041eb2a.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, if you look at the HTTP translations of each task, you will notice that
    their relative URLs all share a common property, which is the fact that it starts
    with `/events`. In the Gorilla web toolkit, we can create a subrouter for the
    `/events`—relative URL. A subrouter is basically an object that will be in charge
    of any incoming HTTP request directed towards a relative URL that starts with
    `/events`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a subrouter for URLs prefixed with `/events`, the following code
    is needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code makes use of the router object we created earlier, then calls
    the `PathPrefix` method, which is used to capture any URL path that starts with
    `/events`. Then, finally, we call the `Subrouter()` method, which will create
    a new router object for us to use from now on to handle any incoming requests
    to URLs that start with `/events`. The new router is called `eventsrouter`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, the `eventsrouter` object can be used to define what to do with the rest
    of the URLs that share the `/events` prefix. So, let''s revisit the list of HTTP
    translations for our tasks and explore the code needed to get them done:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Task:** Searching for events via:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`id`: Relative URL is `/events/id/3434`, the method is `GET`, and no data is
    expected in the HTTP body'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`name`: Relative URL is `/events/name/jazz_concert`, the method is `GET`, and
    no data is expected in the HTTP body:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The handler object in the preceding code is basically the object that implements
    the methods that represent the functionality that we expect to be mapped to the
    incoming HTTP request. More on that later.
  prefs: []
  type: TYPE_NORMAL
- en: '**Task:** Retrieving all events at once—Relative URL is `/events`, the method
    is `GET`, and no data is expected in the HTTP body:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '**Task:** Creating a new event—Relative URL is `/events,` the method is `POST`,
    and expected data in the HTTP body needs to be the JSON representation of the
    new event we would like to add:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: For tasks 2 and 3, the code is self-explanatory. The Gorilla `mux` package allows
    us access to Go methods that eloquently define the properties of the incoming
    HTTP request that we would like to capture. The package also allows us to chain
    the calls together in a line to efficiently structure our code. The `Methods()` call
    defined the expected HTTP method, the `Path()` call defined the expected relative
    URL path (note that we placed the call on the `eventsrouter` object, which would
    append `/events` to the relative path defined in the `Path()` call), and finally
    comes the `HandlerFunc()` method.
  prefs: []
  type: TYPE_NORMAL
- en: The `HandlerFunc()` method is how we will link the captured incoming HTTP request
    with an action. `HandlerFunc()` takes an argument of the `func(http.ResponseWriter,
    *http.Request)` type. This argument is basically a function with two important
    arguments—an HTTP response object that we need to fill with our response to the
    incoming request and an HTTP request object, which will contain all the information
    about the incoming HTTP request.
  prefs: []
  type: TYPE_NORMAL
- en: The functions we pass to `HandlerFunc()` in the preceding code is `handler.findEventHandler`,
    `handler.allEventHandler`, and `handler.newEventHandler`—all support the `func(http.ResponseWriter,
    *http.Request)` signature. `handler` is a Go struct object, created to host all
    those functions. The `handler` object belongs to a custom Go struct type called
    `eventServiceHandler`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order for the `eventServiceHandler` type to support the HTTP handlers for
    tasks 1, 2, and 3, it needs to be defined like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we created `eventServiceHandler` as a struct type with
    no fields, then, we attached three empty methods to it. Each one of the handler
    methods supports the function signature needed to become an argument for the Gorilla
    `mux` package `HandlerFunc()` method. The detailed implementation of each one
    of the `eventServiceHandler` methods will be discussed in more detail in this
    chapter when we cover the persistence layer of our microservice.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's go back to task 1\. The `/{SearchCriteria}/{search}` path in our
    code represents the equivalent of the `/id/2323` path to search for the event
    ID `2323`, or the path `/name/opera aida` to search for an event with name `opera
    aida`. The curly braces in our path alert the Gorilla `mux` package that `SearchCriteria` and
    `search` are basically variables expected to be substituted in the real-incoming
    HTTP request URL with other things.
  prefs: []
  type: TYPE_NORMAL
- en: The Gorilla `mux` package enjoys powerful support for URL path variables. It
    also supports pattern-matching via regular expressions. So, for example, if I
    use a path that looks like `/{search:[0-9]+}`, it will provide me a variable called
    `search` that hosts a number.
  prefs: []
  type: TYPE_NORMAL
- en: 'After we finish defining our routers, paths, and handlers, we will need to
    specify the local TCP address where our web server will listen for incoming HTTP
    requests. For this, we need Go''s `net/http` package; here''s what the code would
    look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In this single line of code, we created a web server. It will listen for incoming
    HTTP requests on local port `8181` and will use the `r` object as the router for
    the requests. We created the `r` object earlier using the `mux` package.
  prefs: []
  type: TYPE_NORMAL
- en: It's now time to put all the code we covered up to this point together. Let's
    assume that the code lives inside a function called `ServeAPI()` that is responsible
    for activating the Restful API logic for our microservice.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We defined the `eventServiceHandler` object to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Obviously, the next step will be to fill in the empty methods of the `eventServiceHandler`
    type. We have the `findEventHandler()`, `allEventHandler()`, and `newEventHandler()` methods.
    Each one of them needs a persistence layer to carry out their tasks. That is because
    they either retrieve stored data or add new data to a store.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned earlier in this section, the persistence layer is the component
    of a microservice that is tasked with storing data in databases or retrieving
    data from databases. We arrived to the point where we need to cover the persistence
    layer in much more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Persistence layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first decision that needs to be made when designing a persistence layer
    is to decide on the type of the data store. The data store could be a relational
    SQL database such as Microsoft SQL or MySQL, among others. Alternatively, it can
    be a NoSQL store, such as MongoDB, or Apache Cassandra, among others.
  prefs: []
  type: TYPE_NORMAL
- en: In an efficient and complex production environment, the code needs to be capable
    of switching from one data store to another without too much refactoring. Consider
    the following example—you build a number of microservices for a start-up that
    relies on MongoDB as the data store; then, as the organization changes, you decide
    that AWS cloud-based DynamoDB would make a better data store for the microservices.
    If the code doesn't allow easily unplugging MySQL, then plugging a MongoDB layer
    in its place, tons of code refactoring will be needed in our microservices. In
    Go, we will achieve that flexible design using interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: It is worth mentioning that in microservices architectures, different services
    can require different types of datastores, so it is normal for one microservice
    to use MongoDB, whereas another service would use MySQL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s assume that we are building a persistence layer for the events microservice.
    Based on what we have covered so far, the events microservice persistence layer
    would primarily care about three things:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding a new event to the databases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding an event by ID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding an event by name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To achieve flexible code design, we would need the preceding three functionalities
    to be defined in an interface. It would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `Event` datatype is a struct type that represents the data of an event,
    such as the event name, location, time, among other things. For now, let's focus
    on the `DatabaseHandler` interface. It supports four methods that represent the
    required tasks from the events service persistence layer. We can then create numerous
    concrete implementations from this interface. One implementation can support MongoDB,
    while another can support the cloud-native AWS DynamoDB database.
  prefs: []
  type: TYPE_NORMAL
- en: We'll cover AWS DynamoDB in a later chapter. In this chapter, the focus will
    be on MongoDB.
  prefs: []
  type: TYPE_NORMAL
- en: MongoDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are not already familiar with the MongoDB NoSQL database engine, this
    section will be very useful for you.
  prefs: []
  type: TYPE_NORMAL
- en: MongoDB is a NoSQL document store database engine. The two keywords to understand
    MongoDB are *NoSQL* and *document store*.
  prefs: []
  type: TYPE_NORMAL
- en: NoSQL is a relatively recent keyword in the software industry that is used to
    indicate that a database engine does not deeply rely on relational data. Relational
    data is the idea that there are webs of relations between different pieces of
    data in your database, following the relations between your data will build a
    full picture of what the data represents.
  prefs: []
  type: TYPE_NORMAL
- en: Take MySQL as an example of a relational database. Data gets stored in numerous
    tables, then, primary and foreign keys are used to define the relations between
    the different tables. MongoDB doesn't work this way, which is why MySQL is considered
    as a SQL database, whereas MongoDB is considered NoSQL.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are not yet familiar with Mongodb, or don’t have a local installation
    you can test with. Go to [https://docs.mongodb.com/manual/installation/](https://docs.mongodb.com/manual/installation/)
    , where you find a list of helpful links to guide through the process of installing
    and running the database in your operating system of choice. Generally, when installed,
    Mongodb provides two key binaries: `mongod` and `mongo`. The `mongod` command
    is what you need to execute, in order to run your database. Any software you then
    write will communicate with `mongod` to access Mongodb’s data. The `mongo` command,
    on the other hand, is basically a client tool you can use to test the data on
    Mongodb, the `mongo` command communicates with `mongod`, similarly to any application
    you write that accesses the database.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two flavors of MongoDB: the community edition, and the enterprise
    edition. Obviously, the enterprise edition targets larger enterprise installations,
    whereas the community edition is what you’d use for your testing and smaller scale
    deployments.  Here are the links for the community edition guides covering the
    three major operating systems:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For linux Mongodb installation and deployment: [https://docs.mongodb.com/manual/administration/install-on-linux/](https://docs.mongodb.com/manual/administration/install-on-linux/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For Windows Mongodb installation and deployment: [https://docs.mongodb.com/manual/tutorial/install-mongodb-on-windows/](https://docs.mongodb.com/manual/tutorial/install-mongodb-on-windows/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For OS X Mongodb installation and deployment: [https://docs.mongodb.com/manual/tutorial/install-mongodb-on-os-x/](https://docs.mongodb.com/manual/tutorial/install-mongodb-on-os-x/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Overall, there are three main steps you need to consider when deploying a Mongodb
    instance:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install Mongodb for your operating system, the download page can be found here:
    [https://www.mongodb.com/download-center](https://www.mongodb.com/download-center)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure MongoDB’s key binaries are defined in your environmental path, so that
    you can run them from the terminal no matter what your current directory is. The
    key binaries are `mongod` and `mongo`. Another binary worth mentioning is `mongos`,
    which is important if you are planning to utilize clustering
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the `mongod` command with no arguments, and this will run Mongodb with
    all your default settings. Alternatively, you can use it with different configuration.
    You can either use a configuration file or just runtime parameters. You can find
    information about the configuration file here: [https://docs.mongodb.com/manual/reference/configuration-options/#configuration-file](https://docs.mongodb.com/manual/reference/configuration-options/#configuration-file).  To
     start `mongod` with a custom configuration file, you can use the `--config` option,
    here is an example: `mongod --config /etc/mongod.conf`. On the other hand, for
    runtime parameters, you can just use `--option` to change an option when running
    `mongod`, for example you can type `mongod --port 5454` to start `mongod` on a
    different port than the default'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There are different types of NoSQL databases. One of these types is the *document
    store* database. The idea of a document store is that data gets stored in numerous
    document files stacked together to represent what we are trying to store. Let's
    take the data store needed for the event's microservice as an example. If we are
    using a document store in the microservice persistence layer, each event will
    be stored in a separate document with a unique ID. Say that we have an Opera Aida
    event, a Coldplay concert event, and a ballet performance event. In MongoDB, we
    would create a collection of documents called *events*, which will contain three
    documents—one for the Opera, one for Coldplay, and one for the ballet performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, to solidify our understanding of how MongoDB would represent this data,
    here is a diagram of the events collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0f10361f-cb37-42de-b2ee-16b8b80c7786.png)'
  prefs: []
  type: TYPE_IMG
- en: Events collection
  prefs: []
  type: TYPE_NORMAL
- en: 'Collections and documents are important concepts in MongoDB. A production MongoDB
    environment typically consists of multiple collections; each collection would
    represent a different piece of our data. So, for example, our MyEvents application
    consists of a number of microservices, each microservice cares about a distinctive
    piece of data. The bookings microservice would store data in a bookings collection,
    and the events microservices would store data in an events collection. We''d also
    need the user''s data to be stored separately in order to manage the users of
    our applications independently. Here is what this would end up looking like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9bc4b09d-c5d4-4727-b6d7-a08167d37aef.png)'
  prefs: []
  type: TYPE_IMG
- en: Our MongoDB database
  prefs: []
  type: TYPE_NORMAL
- en: You can download this file from [https://www.packtpub.com/sites/default/files/downloads/CloudNativeprogrammingwithGolang_ColorImages.pdf](https://www.packtpub.com/sites/default/files/downloads/CloudNativeprogrammingwithGolang_ColorImages.pdf).
  prefs: []
  type: TYPE_NORMAL
- en: The code bundle for the book is also hosted on GitHub at [https://github.com/PacktPublishing/Cloud-Native-Programming-with-Golang](https://github.com/PacktPublishing/Cloud-Native-programming-with-Golang).
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we have focused so far on the events microservice as a showcase on how
    to build a microservice, let''s dive deeper into the events collection, which
    would be used by the event''s microservice:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9422f73b-196c-4be4-a1c2-7e17df8ecd1f.png)'
  prefs: []
  type: TYPE_IMG
- en: Events collection
  prefs: []
  type: TYPE_NORMAL
- en: 'Each document in the events collection needs to include all the information
    necessary to represent a single event. Here''s how an event document should look
    like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5505e49b-7894-44b0-93e1-b4b75e9245f4.png)'
  prefs: []
  type: TYPE_IMG
- en: If you haven't noticed already, the preceding JSON document is the same as the
    HTTP body document that we presented as an example of what the add event API HTTP
    `POST` request body looks like.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to write software that can work with this data, we need to create
    models. Models are basically data structures containing fields that match the
    data we are expecting from the database. In the case of Go, we''d use struct types
    to create our models. Here is what a model for an event should look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `Event struct` is the data structure or model for our event document. It
    contains the ID, event name, event duration, event start date, event end date,
    and event location. Since the event location needs to hold more information than
    just a single field, we will create a struct type called location to model a location.
    The `Location struct` type contains the location's name, address, country, open
    time and close time, and the halls in that area. A hall is basically the room
    inside the location where the event is taking place.
  prefs: []
  type: TYPE_NORMAL
- en: So, for example, Mountain View, Opera house in downtown Mountain View would
    be the location, whereas the silicon valley room on the east side would be the
    hall.
  prefs: []
  type: TYPE_NORMAL
- en: In turn, the hall cannot be represented by a single field since we need to know
    its name, its location in the building (south-east, west, and so forth), and its
    capacity (the number of people it can host).
  prefs: []
  type: TYPE_NORMAL
- en: The `bson.ObjectId` type in the event struct is a special type that represents
    MongoDB document ID. The `bson` package can be found in the `mgo` adapter, which
    is the Go third part framework of choice to communicate with MongoDB. The `bson.ObjectId`
    type also provides some helpful methods that we can use later in our code to verify
    the validity of the ID.
  prefs: []
  type: TYPE_NORMAL
- en: Before we start covering `mgo`, let's take a moment to explain what `bson` means.
    `bson` is a data format used by MongoDB to represent data in stored documents.
    It could be simply considered as binary JSON because it is a binary-encoded serialization
    of JSON-like documents. The specification can be found at: [http://bsonspec.org/](http://bsonspec.org/).
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's cover `mgo`.
  prefs: []
  type: TYPE_NORMAL
- en: MongoDB and the Go language
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: mgo is a popular MongoDB driver written in the Go language. The package page
    can be found at: [http://labix.org/mgo](http://labix.org/mgo). The driver is nothing
    more than a number of Go packages that facilitate writing Go programs capable
    of working with MongoDB.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to make use of `mgo`, the first step is to make use of the `go get`
    command to retrieve the package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: With the preceding command executed, we get the ability to use `mgo` in our
    code. We'd need to import the `mgo` package and the `bson` package that we discussed
    earlier. The package name we use to host our MongoDB persistence layer is called
    `mongolayer`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at the `mongolayer` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s create some constants to represent the name of our database and
    the names of the collections involved in our persistence layer. The database name
    in MongoDB would be `myevents`. The collection names we''ll use are `users` for
    the users collection, and `events` for the collection of events in our database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to expose the features of the `mgo` package, we will need to utilize
    a database session object that belongs to the `mgo` package, the session object
    type is called `*mgo.session`. To make use of `*mgo.session` inside our code,
    we will wrap it with a struct type called `MongoDBLayer`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: It is now time to implement the `DatabaseHandler` interface that we covered
    earlier in order to construct the concrete persistence layer of our application.
    In the Go language, it is typically preferred to use a pointer type when implementing
    an interface because pointers preserve references to the original memory addresses
    of the underlying objects as opposed to copying the entire object around when
    we make use of it. In other words, the implementer object type for the `DatabaseHandler`
    interface needs to be a pointer to a `MongoDBLayer` struct object, or just simply
    `*MongoDBLayer`.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, before we start implementing the interface, we will first need to
    create a constructor function that returns an object of the `*MongoDBLayer` type.
    This is idiomatic in Go in order for us to be able to execute any necessary initialization
    code while creating a new object of the `*MongoDBLayer` type. In our cases, the
    initialization code is basically to obtain a connection session handler to the
    desired MongoDB database address. The following is what the constructor code will
    look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we created a constructor function called `NewMongoDBLayer`,
    which requires a single argument of type string. The argument represents the connection
    string with the information needed to establish the connection to the MongoDB
    database. According to `mgo` documentation at [https://godoc.org/gopkg.in/mgo.v2#Dial](https://godoc.org/gopkg.in/mgo.v2#Dial),
    the format of the connection string needs to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d5bfd2e3-f4bc-45d4-9c86-8cbf1998639b.png)'
  prefs: []
  type: TYPE_IMG
- en: If it is just a localhost connection, the connection string will look as follows: `mongodb://127.0.0.1`
  prefs: []
  type: TYPE_NORMAL
- en: If a port number is not provided in the connection string, the port defaults
    to `27017`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's look at the code inside our constructor function. In the first line,
    we call `mgo.Dial()` with the connection string as an argument. The `mgo.Dial()`
    is the function in the `mgo` package, which will return a MongoDB connection session
    for us to use later in our code. It returns two results—the `*mgo.Session` object
    and an error object. We use struct literals at the end to return a fresh object
    of type pointer to `MongoDBLayer`, which hosts the newly created `*mgo.Session`
    object. We also return the error object so that we communicate to the caller any
    errors that would have occurred during the initialization process.
  prefs: []
  type: TYPE_NORMAL
- en: Now, with the constructor out of the way, it's time to implement the methods
    of the `DatabaseHandler` interface. So far, we have four methods—`AddEvent(Event)`,
    `FindEvent([]byte)`, `FindEventByName(string)`, and `FindAllAvailableEvents()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is what the code for the `AddEvent(Event)` method will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The method takes an argument of type  `persistence.Event`, which models the
    information expected from an event as we covered earlier. It returns a slice of
    bytes, which represents the event ID, and an error object, which will be nil if
    no errors are found.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the first line, we call a `getFreshSession()` method—this is a helper method
    implemented in our code to help retrieve a fresh database session from the connection
    pool. Here is what the method code looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `session.Copy()` is the method that is called whenever we are requesting
    a new session from the `mgo` package connection pool. `mgoLayer.session` here
    is basically the `*mgo.Session` object we have hosted inside the `MongoDBLayer`
    struct. It is idiomatic to call `session.Copy()` at the beginning of any method
    or function that is about to issue queries or commands to MongoDB via the `mgo`
    package. The `getFreshSession()` method is just a helper method that calls `session.Copy()` for
    us and returns the resulting session.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's return to the `AddEvent()` method. We now have a working `*mgo.Session`
    object from the database connection pool to use in our code. The first thing to
    do is to call defer `s.Close()` to ensure that this session gets returned back
    to the `mgo` database connection pool after the `AddEvent()` method exits.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we check whether the event ID supplied by the `Event` argument object
    is valid and whether the ID field of the `Event` object is of the `bson.ObjectID` type
    as we covered earlier. `bson.ObjectID` supports a `Valid()` method, which we can
    use to detect whether the ID is a valid MongoDB document ID or not. If the supplied
    event ID is not valid, we will create one of our own using the `bson.NewObjectID()`
    function call. We will then repeat the same pattern with the location-embedded
    object inside the event.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, at the end, we will return two results—the first result is the event
    ID of the added event, and a second result is an error object representing the
    result of the event insertion operation. In order to insert the event object to
    the MongoDB database, we will use the session object in the `s` variable, then
    call `s.DB(DB).C(EVENTS)` to obtain an object that represents our events collection
    in the database. The object will be of the `*mgo.Collection` type. The `DB()`
    method helps us access the database; we will give it the `DB` constant as an argument,
    which has our database name. The `C()` method helps us access the collection;
    we will give it the `EVENTS` constant, which has the name of our events collection.
  prefs: []
  type: TYPE_NORMAL
- en: The `DB` and `EVENTS` constants were defined earlier in our code. Then, finally,
    we will call the `Insert()` method of the collection object, with the `Event`
    object as an argument, which is why the code ends up looking like this—`s.DB(DB).C(EVENTS).Insert(e)`.
    This line is what we need in order to insert a new document into a MongoDB database
    collection that utilizes Go objects and the `mgo` package.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s look at the code for `FindEvent()`, which we use to retrieve the
    information of a certain event from the database from its ID. The code will look
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Note how the ID is passed as a slice of bytes instead of a `bson.ObjectId` type.
    We do this to ensure that the `FindEvent()` method in the `DatabaseHandler` interface
    stays as generic as possible. For example, we know that in the world of MongoDB,
    the ID will be of the `bson.ObjectId` type, but what if we now want to implement
    a MySQL database layer? It would not make sense to have the ID argument type passed
    to `FindEvent()` as `bson.ObjectId`. So, that's why we picked the `[]byte` type
    to represent our ID argument. In theory, we should be able to convert a slice
    of bytes to any other type that can represent an id.
  prefs: []
  type: TYPE_NORMAL
- en: An important remark is that we could also have picked the empty interface type
    (`interface{}`), which in Go can be converted to any other type.
  prefs: []
  type: TYPE_NORMAL
- en: In the first line of the `FindEvent()` method, we obtained a fresh session from
    the connection pool using the `mgoLayer.getFreshSession()` as before. We then
    call `defer s.Close()` to ensure that the session goes back to the connection
    pool after we are done.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we created an empty event object `e` using the code `e := persistence.Event{}`.
    We then use `s.DB(DB).C(EVENTS)` to access the events collection in MongoDB. There
    is a method called `FindId()`, which is supported by `*mgoCollection` objects
    of `mgo`. The method takes an object of the `bson.ObjectId` type as an argument
    then searches for the document with the desired ID.
  prefs: []
  type: TYPE_NORMAL
- en: '`FindId()` returns an object of the `*mgo.Query` type, which is a common type
    in `mgo` that we can use to retrieve results of queries. In order to feed the
    retrieved document data to the `e` object we created earlier, we will need to
    call the `One()` method, which belongs to the `*mgo.Query` type, and pass a reference
    to `e` as an argument. By doing this, `e` will obtain the data of the retrieved
    document with the desired ID. If the operation fails, the `One()` method will
    return an error object containing the error information, otherwise `One()` will
    return nil.'
  prefs: []
  type: TYPE_NORMAL
- en: At the end of the `FindEvent()` method, we will return the event object and
    the error object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s look at the implementation of the `FindEventByName()` method, which
    retrieves an event by its name from the MongoDB database. Here is what the code
    looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The method is very similar to the `FindEvent()` method, except for two things.
    The first difference is the fact that `FindEvent()` takes a string as an argument,
    which represents the event name that we would like to find.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second difference is that we query for an event name instead of an event
    ID. The code line where we query the document uses a method called `Find()` instead
    of `FindId()`, which makes the code look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `Find()` method takes an argument that represents the query we would like
    to pass along to MongoDB. The `bson` package provides a nice type called `bson.M`,
    which is basically a map we can use to represent the query parameters that we
    would like to look for. In our case, we are looking for the name that got passed
    as an argument to `FindEventByName`. The name field in the event collection in
    our database is simply coded as `name`, whereas the variable that got passed to
    us as an argument and has the name is called `name`. Hence, our query ends up
    as `bson.M{"name":name}`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Last but not least is our `FindAllAvailableEvents()` method. The method returns
    all available events in our database. In other words, it returns the entire events
    collection from our MongoDB database. Here is what the code looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The code is almost the same as `FindEventByName()`, except for three simple
    differences. The first difference is obviously the fact that `FindAllAvailableEvents()`
    doesn't take any arguments.
  prefs: []
  type: TYPE_NORMAL
- en: The second difference is the fact that we need the query results to be fed to
    a slice of the event's objects instead of a single event object. This is why the
    return type is `[]persistence.Event` , instead of just `persistence.Event`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The third difference is that the `Find()` method will take an argument of nil
    instead of a `bson.M` object. This will cause the code to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: When the `Find()` method gets a nil argument, it will return everything found
    in the associated MongoDB collection. Also, note that we used `All()` instead
    of `One()` after `Find()`. That is because we expect multiple results and not
    just one.
  prefs: []
  type: TYPE_NORMAL
- en: With this, we finish covering our persistence layer.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing our RESTful APIs handler functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So, now that have covered our persistence layer, it''s time to return to our
    RESTful API handlers and cover their implementation. Earlier in this chapter,
    we defined the `eventServiceHandler` struct type to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The `eventServiceHandler` type now needs to support the `DatabaseHandler` interface
    type we created earlier in the chapter in order to be capable of performing database
    operations. This will make the struct look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will need to write a constructor to initialize the `eventServiceHandler`
    object; it will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: However, we left the three methods of the `eventServiceHandler` struct type
    empty. Let's go through them one by one.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first method `findEventHandler()` is responsible for handling HTTP requests
    used to query events stored in our database. We can query events via their IDs
    or names. As mentioned earlier in the chapter, when searching for an ID, the request
    URL will resemble `/events/id/3434` and will be of the `GET` type. On the other
    hand, when searching by name, the request will resemble `/events/name/jazz_concert`
    and be of the `GET` type. As a reminder, the following is how we defined the path
    and linked it to the handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '`{SearchCriteria}` and `{Search}` are two variables in our path. `{SearchCriteria}`
    can be replaced with `id` or `name`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is what the code for the `findEventHandler` method will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The method takes two arguments: an object of the `http.ResponseWriter` type, which
    represents the HTTP response we need to fill, whereas the second argument is of
    the `*http.Request` type, which represents the HTTP request that we received.
    In the first line, we use `mux.Vars()` with the request object as an argument;
    this will return a map of keys and values, which will represent our request URL
    variables and their values. So, for example, if the request URL looks like `/events/name/jazz_concert`,
    we will have two key-value pairs in our resulting map—the first key is `"SearchCriteria"`
    with a value of `"name"`, whereas the second key is `"search"` with a value of
    `jazz_concert`. The resulting map is stored in the vars variable.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We then obtain the criteria from our map in the next line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: So, the criteria variable will now have either `name` or `id` if the user sent
    the correct request URL. The `ok` variable is of the boolean type; if `ok` is
    true, then we will find a key called `SearchCriteria` in our `vars` map. If it
    is false, then we know that the request URL we received is not valid.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we check whether we retrieved the search criteria; if we didn''t, then
    we report the error and then exit. Notice here how we report the error in a JSON
    like format? That is because it is typically preferred for RESTful APIs with JSON
    body formats to return everything in JSON form, including errors. Another way
    to do this is to create a JSONError type and feed it our error strings; however,
    I will just spell out the JSON string here in the code for simplicity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '`fmt.Fprint` allows us to write the error message directly to the `w` variable,
    which contains our HTTP response writer. The `http.responseWriter` object type
    supports Go''s `io.Writer` interface, which can be used with `fmt.Fprint()`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will need to do the same with the `{search}` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s time to extract the information from the database based on the provided
    request URL variables; here is how we do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: In case of the name search criteria, we will use the `FindEventByName()` database
    handler method to search by name. In case of the ID search criteria, we will convert
    the search key to a slice of bytes using `hex.DecodeString()`—if we successfully
    obtain the slice of bytes, we will call `FindEvent()` with the obtained ID.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then check whether any errors occurred during the database operations by
    checking the err object. If we find errors, we write a `404` error header in our
    response, then print the error in the HTTP response body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to do is to convert the response to a JSON format, so
    we change the HTTP `content-type` header to `application/json`; then, we use the
    powerful Go JSON package to convert the results obtained from our database calls
    to the JSON format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s look at the code for the `allEventHandler()` method, which will
    return all the available events in the HTTP response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: We start by calling the `FindAllAvailableEvents()` that belongs to the database
    handler in order to obtain all events from the database. We then check whether
    any errors occurred. If any found, we write an error header, print the error to
    the HTTP response, and then return from the function.
  prefs: []
  type: TYPE_NORMAL
- en: If no errors have occurred, we write `application/json` to the `Content-Type` header
    of the HTTP response. We then encode the events to the JSON format and send them
    to the HTTP response writer object. Again, if any errors occur, we will log them
    and then exit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s discuss the `newEventHandler()` handler method, which will add
    a new event to our database using the data retrieved from incoming HTTP requests.
    We expect the event data in the incoming HTTP request to be in the JSON format.
    Here is what the code will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: In the first line, we create a new object of the `persistence.Event` type, which
    we will use to hold the data we are expecting to parse out from the incoming HTTP
    request.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the second line, we use Go''s JSON package to take the body of the incoming
    HTTP request (which we obtain by calling `r.Body`). We then decode the JSON data
    embedded in it and feed it to the new event object, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: We then check our errors as usual. If no errors are observed, we call the `AddEvent()`
    method of our database handler and pass the event object as the argument. This
    in effect will add the event object we obtained from the incoming HTTP request
    to the database. We then check errors again as usual and exit.
  prefs: []
  type: TYPE_NORMAL
- en: 'To put the final touches on our events microservice, we will need to do three
    things. The first is to allow the `ServeAPI()` function we covered earlier in
    this chapter, which define the HTTP routes and handlers, to call the `eventServiceHandler`
    constructor. The code will end up looking like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The second final touch we need to do is to write a configuration layer for
    our microservice. As mentioned earlier in the chapter, a well-designed microservice
    needs a configuration layer which reads from a file, a database, an environmental
    variable, or a similar medium. There are three main parameters we need to support
    for now for our configuration—the database type used by our microservice (MongoDB
    is our default), the database connection string (default is `mongodb://127.0.0.1`
    for a local connection), and the Restful API endpoint. Here is what our configuration
    layer will end up looking like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The third touch is to build a database layer package that acts as the gateway
    to the persistence layer in our microservice. The package will utilize the factory
    design pattern by implementing a factory function. A factory function will manufacture
    our database handler.  This is done by taking the name of the database that we
    would like to connect to, as well as the connection string, then returning a database
    handler object which we can use for database related tasks from this point forward.
    We currently only support MongoDB, so here is how this would look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The fourth and final touch is our `main` package. We will write the main function
    that makes use of the `flag` package to take the location of the configuration
    file from the user and then use the configuration file to initialize the database
    connection and the HTTP server. The following is the resultant code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: With this piece of code, we come to the conclusion of this chapter. In the next
    chapter, we will discuss how to secure our microservice.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered a wide range of topics regarding designing and building
    modern microservices. You now should have practical knowledge regarding RESTful
    web APIs, NoSQL data stores like MongoDB, and proper Go design patterns for scalable
    code.
  prefs: []
  type: TYPE_NORMAL
