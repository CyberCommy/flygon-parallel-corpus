- en: Creating Directives and Implementing Change Detection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will learn and understand all about Angular Directives and
    change detection.
  prefs: []
  type: TYPE_NORMAL
- en: We will learn about different types of directives provided by Angular and also
    create some custom user-defined directives. We will deep dive into learning how
    Angular handles the change detection and how we can utilize change detection in
    our apps.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end of this chapter, you will be able to do the following things:'
  prefs: []
  type: TYPE_NORMAL
- en: Understand Angular Directives
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand and implement built-in Component Directives
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand and implement built-in Structural Directives
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand and implement built-in Attribute Directives
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create custom-defined Attribute Directives
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand how change detection works in Angular
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Angular Directives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Directives allows us to extend the behavior of the elements. We can manipulate
    the **Document Object Model** (**DOM**) of a HTML page using the different types
    of directive definitions.
  prefs: []
  type: TYPE_NORMAL
- en: Angular uses the `@Directive` metadata to tell the application about the type
    of directives they have and the functional capabilities defined with each directive.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the different types of directives:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/b5831068-99f7-4172-bdfb-823dd2570215.png)'
  prefs: []
  type: TYPE_IMG
- en: 'There are mainly three types of Angular Directives:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Component Directives**: We can define these as user-defined directives, similar
    to custom directives in Angular 1.x'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Structural Directives**: Directives that alter or transform the DOM elements
    (one or more) on the fly'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Attribute Directives**: Directives that extend the behavior or look and feel
    of an element'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In Angular 1.x, we had the A (Attribute), E (Element), C (Class), M (Matches
    comment) directives.
  prefs: []
  type: TYPE_NORMAL
- en: Angular comes with a lot of built-in directives, which we will be categorized
    in the preceding mentioned categories.
  prefs: []
  type: TYPE_NORMAL
- en: Angular uses directives that use `ng`, hence avoid using `ng` along with custom-defined
    directives; it may lead to unknown issues. For example, `ng-changeColor` is an
    instance of bad styling.
  prefs: []
  type: TYPE_NORMAL
- en: Component Directives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Component Directives are user-defined directives to extend the functionality
    and create small reusable functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: Think of Component Directives as directives that have a template attached to
    them since Components Directives have their own view or template defined with
    them.
  prefs: []
  type: TYPE_NORMAL
- en: In previous chapters, we have created many components. If you have mastered
    the art of creating components and using them in our layouts, you will already
    know how to create Component Directives.
  prefs: []
  type: TYPE_NORMAL
- en: 'A quick recap on Angular components: components are small reusable pieces of
    code that we can use in throughout our applications.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code snippet, we will see the basic syntax of the component.
    Create a file named `my-template.component.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Import the newly created component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Then, call the Component Directive in our `index.html` file*:*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the simplest and easiest component example you will have seen;
    it''s as simple as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/31ded739-70f8-4344-b7f2-e25a87f9d902.png)'
  prefs: []
  type: TYPE_IMG
- en: So, whatever components we have created so far are all Component Directives.
    If you want to deep dive into learning more and creating components, refer to
    [Chapter 4](ffd90f48-2aef-462a-9d96-35e182ce3db9.xhtml), Working with Components.
  prefs: []
  type: TYPE_NORMAL
- en: Structural Directives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the name mentions, Structural Directives alter the DOM structure by adding,
    appending, or removing DOM elements on the fly.
  prefs: []
  type: TYPE_NORMAL
- en: Angular Structural Directives are displayed with an (`*`) asterisk symbol before
    the directive name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the commonly used Structural Directives are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ngFor`: Repeater directive generally used to loop through and display a list
    of elements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ngIf`: Shows or hides DOM elements depending on the result of expression evaluation;
    the result is either true or false.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ngSwitch`: Returns if the match expression value matches the value of the
    switch expression. The result returned can be any value; a conditional check is
    done for matching values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Only one Structural Directive is allowed per element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s learn about each of these Structural Directives in detail and create
    few examples using them:'
  prefs: []
  type: TYPE_NORMAL
- en: ngFor directive
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `ngFor` directive will help us iterate the items and append them to the
    list on the fly.
  prefs: []
  type: TYPE_NORMAL
- en: We need to declare an array in the `StructureDirectiveComponent` class, and
    then use `ngFor` to loop the values and display them in the template.
  prefs: []
  type: TYPE_NORMAL
- en: The list `<li>` elements get appended on the fly to the `<ul>` element.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the component snippet for the `ngFor` directive usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding component is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/5aaf455e-5a7e-4fd1-bf51-2cb0ddbe07dd.png)'
  prefs: []
  type: TYPE_IMG
- en: ngIf directive
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `ngIf` directive help us to evaluate the expression based on a condition
    very similar to the `if` statements in any programming language.
  prefs: []
  type: TYPE_NORMAL
- en: 'The general syntax is shown in the following code snippet :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code snippet has a `*ngIf` condition; if `isLoggedIn` is `true`,
    the directive will render the statement inside; otherwise, it will skip and continue.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create an example using both the `*ngFor` and `*ngIf` statements as
    shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s analyze the preceding code snippet in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: We used `*ngFor` and `*ngIf` in the `view` template.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the component class, we define a `isLoggedIn` variable with Boolean values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We create an array of teams having team names in the list, which we will iterate
    and display in the view.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the app, and we should see output as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/89017779-cdb5-4ff2-884a-f4f9018faedb.png)'
  prefs: []
  type: TYPE_IMG
- en: ngSwitch directive
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we have to evaluate the expression based on multiple values, we make use
    of `ngSwitch`. An example of `ngSwitch` is shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Based on the value of `taxRate`, our application will decide which element to
    display. Let's update our example and add an `*ngSwitch` statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'The updated example code is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code example is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/d2dafbae-53df-4af5-84a7-ec492220de4e.png)'
  prefs: []
  type: TYPE_IMG
- en: Attribute Directives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Attribute Directives extend the behavior or the look and feel of a given element.
    Attribute Directives are very similar to HTML attributes defined along with the
    element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Attribute Directives can be of two types:'
  prefs: []
  type: TYPE_NORMAL
- en: Built-in Attribute Directive
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom or user-defined Attributes Directive
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's now look at them in detail in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Built-in Attribute Directives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned before, attributes are properties of the elements in the page.
    Some of the examples of the attributes for HTML elements are class, style, and
    so on.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly Angular provides several built-in Attribute Directives. The directives
    include `ngModel`, `ngClass`, `ngStyle`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s learn about each of these Attribute Directives by creating few examples
    that are shown as follows for your reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ngModel`: Using `ngModel`, we can implement a Two-way Data Binding. For learning
    more about Data Binding and Template Syntax, please refer to [Chapter 8](1dfecab5-25d2-47a0-88a2-eac2cece692e.xhtml),
    *Template and Data Binding Syntax*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ngModel` directive is written inside a square with the parentheses of event
    binding `[()]`.
  prefs: []
  type: TYPE_NORMAL
- en: Remember to import the forms Module from Angular forms or else you will get
    error messages.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of the `ngModel` Attribute Directive is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '`ngClass`: When we want to add or remove any CSS class to a DOM element, it''s
    preferred that we use the `ngClass` Attribute Directive. We can assign class names
    in different ways to `ngClass`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can assign class names using a `string`, or an `object` or a component `method`
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of the `ngClass` Attribute Directive is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Remember to wrap the name of CSS class in a single quote; otherwise, you won't
    see the styling.
  prefs: []
  type: TYPE_NORMAL
- en: Remember to include the style sheet either in `index.html` or in your respective
    component.
  prefs: []
  type: TYPE_NORMAL
- en: '`ngStyle`: When we want to manipulate a few style properties of any DOM element,
    we can use `ngStyle`. You can relate this to inline styling in the CSS world.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An example of an `ngStyle` Attribute Directive is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Alright, now that we learned about our built-in Attribute Directives, let's
    put them all together in an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a code example using `ngModel`, `ngClass`, and `ngStyle`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Take a look at the following screenshot with the output of the preceding code
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ac668668-085d-4228-930b-d3c696a4a2ff.png)'
  prefs: []
  type: TYPE_IMG
- en: Creating custom directives - Structural and Attribute Directives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far in previous sections, we have learned about and implemented built-in
    directives provided by Angular.
  prefs: []
  type: TYPE_NORMAL
- en: By creating custom user-defined directives, Angular allows us to define and
    extend the behavior and functionality of the elements in the page.
  prefs: []
  type: TYPE_NORMAL
- en: To create custom directives, we have to use the `@Directive` decorator and implement
    the logic in the class definition.
  prefs: []
  type: TYPE_NORMAL
- en: We can create custom Component, Structural, and Attribute Directives.
  prefs: []
  type: TYPE_NORMAL
- en: Any user-defined HTML tag is a component attribute (for example, `<my-app>`).
    We have been creating custom components all along, throughout each chapter of
    the book.
  prefs: []
  type: TYPE_NORMAL
- en: Angular CLI - generating the directives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will use the Angular CLI tool to generate directives for our examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to the project directory and run the following `ng` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We should see the output as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/e9f368e1-a5ad-4770-a4bf-252859cb8b9a.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see in the preceding screenshot, the newly generated directive `highlightDirective`
    is created and the `app.module.ts` file is updated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we go ahead with implementing our directives, here''s a quick recap
    of the Structural and Attribute Directives:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Structural Directive**: As the name suggests, the structural attribute affects
    the structure of the HTML layout since it shapes or reshapes the DOM structure.
    It can affect one or more elements in the page.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Attribute Directive**: Defines and extends the appearance or behavior of
    an element in the page.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We learned to generate custom directives using Angular CLI and now we clearly
    know what and how Structural and Attribute Directives work.
  prefs: []
  type: TYPE_NORMAL
- en: It's time to create our own custom directives. Read on.
  prefs: []
  type: TYPE_NORMAL
- en: Creating custom Attribute Directives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will start by creating custom Attribute Directives. We will continue with
    the example `highlightDirective` we created in the preceding section.
  prefs: []
  type: TYPE_NORMAL
- en: As the name suggests, we will use this directive to highlight the changed text
    color of elements attached to this attribute.
  prefs: []
  type: TYPE_NORMAL
- en: It's time to define the functionality and behavior of our directive, `highlightDirective`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `highlight-directive.ts` file, add the following lines of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s analyze the preceding code snippet in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: We need to import the required utilities provided by Angular for working with
    directives.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will import `Directive`, `ElementRef`, and `AfterViewInit` from `@angular/core`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As mentioned earlier, we define a directive using the `@Directive` decorator
    and passing the name `appHighlightDirective` in the metadata selector.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We are exporting the `appHighlightDirective` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As mentioned earlier, the Attribute Directive is specific to an element and
    hence we need to create an instance of the `ElementRef` variable, `elRef`, which
    we will use to target and update the element attached to our custom directive.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `constructor` we are targeting the specific element by using the `nativeElement`
    method and updating the `style` property `color` with a value, `orange`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now that we have created our directive, we need to apply it to the element
    in the app component template `app.component.html` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now run the application and we should see the output as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/f4e1909f-6687-4223-84f4-05c8e09a3c6e.png)'
  prefs: []
  type: TYPE_IMG
- en: See how easy and simple it is to create a custom Attribute Directive.
  prefs: []
  type: TYPE_NORMAL
- en: If you notice carefully, it's a very basic attribute which changes the color
    of the text. Now what if we want to pass the value of the color dynamically instead
    of a statically?
  prefs: []
  type: TYPE_NORMAL
- en: We have to enable our attribute to pass values as well. Let's see what changes
    we need to make our directive a more suitable candidate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s first edit in our component `app.component.html` template where we want
    to use the attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: You will see, we are now passing a value `green` through the `highlightColor`
    variable for our attribute `appHighlightDirective`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now update our `highlight-directive.ts` file and add the following lines of
    code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see the changes we have done in the `highlight-directive.ts` file:'
  prefs: []
  type: TYPE_NORMAL
- en: We have additionally imported `Input` and `AfterViewInit` modules from the `@angular/core`
    library.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We are using the `@Input` decorator to tell Angular that we want the value to
    be passed dynamically through the variable defined as `highlightColor`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `ngAfterViewInit` method we are creating an object instance of the element
    using the `ElementRef` instance, `elRef`, and using the `nativeElement` method
    to update the `style` property `color` of the element.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `color` of the text changes to the value passed through the element's `appHighlightDirective`
    attribute's value passed through `highlightColor`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the application and we should see the output as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/97851e61-16e0-47c9-b1ec-71eb2c6234a6.png)'
  prefs: []
  type: TYPE_IMG
- en: Alright, so far so good. Our attribute is rather shaping up really well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see the progress you have made so far in implementing our custom directive:'
  prefs: []
  type: TYPE_NORMAL
- en: We have created a custom Attribute Directive, `highlightDirective`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We learned to pass values to the custom Attribute Directive using the `highlightColor`
    variable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is good stuff. But what if we want to bind `Javascript` events such as
    `mouseover`, `mouseout`, `click`, or so on, to our attribute?
  prefs: []
  type: TYPE_NORMAL
- en: Let's make the necessary changes needed to implement events attached to our
    attribute. For this we will need a beautiful image and we will attach a few events
    along with custom Attribute Directive.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add an image to the component `app.component.html` file template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Important notes on the preceding code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: We have added our custom attribute component, `appHighlightDirective`, to the
    element.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Additionally, we have added two attributes, `showOpacity` and `hideOpacity`,
    which will have the style property of opacity to the element.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will attach `onmouseover` and `onmouseout` events to these attributes and
    will change the opacity of the image dynamically.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now that we have added an image to the component view template, the updated
    output looks like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/f5b79ad5-80cd-4d95-9af4-e71d7c152651.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s move over to the custom directive `highlight-directive.directive.ts`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s analyze the updates we have done to the file in the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: We are importing the required modules `Directive`, `ElementRef`, `Input`, `HostListener`,
    and `AfterViewInit` from `@angular/core`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that for binding and implementing events to elements, we especially need
    to import `HostListener`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the `@HostListener` decorator, we are binding the `mouseover` and `mouseout`
    events to the element we are attaching the custom attribute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that when we use `this.elRef.nativeElement`, we are referring to the element
    which has the custom attribute attached to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We are assigning the value of the `this.hideOpacity` variable when the user
    takes the mouse over the element.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We are assigning the value of the `this.showOpacity` variable when the user
    takes the mouse out of the element.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now run the application and you should see the output as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/32301da1-f670-419a-8c74-abf66825e318.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Awesome. Now let''s see the progress you have made so far in implementing our
    custom directive:'
  prefs: []
  type: TYPE_NORMAL
- en: We have created a custom Attribute Directive, `highlightDirective`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We learned to pass values to the custom Attribute Directive using the `highlightColor`
    variable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have learned to attach events such `mouseover` and `mouseout` to our custom
    attribute, `highlightDirective`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, you have learned to create and use a custom Attribute Directive
    having attributes and methods attached to the directive.
  prefs: []
  type: TYPE_NORMAL
- en: In next section, you will learn to create custom Structural Directives.
  prefs: []
  type: TYPE_NORMAL
- en: Creating custom Structural Directives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far you have learned and implemented built-in directives--Component, Structural,
    and Attribute Directives.
  prefs: []
  type: TYPE_NORMAL
- en: We also learned to generate custom directives using Angular CLI in the section
    *Angular CLI - generating the directives*.
  prefs: []
  type: TYPE_NORMAL
- en: In previous section, we learned and implemented custom Attribute Directives.
    In this section, we will learn to create Structural Directives.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a new directive using Angular CLI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the output of the preceding command as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/486c19c6-3e4f-4d92-b6c2-63183bf002a6.png)'
  prefs: []
  type: TYPE_IMG
- en: Run the preceding `ng` command and we should see the directive created and the
    `app.module.ts` is updated with the newly created directive.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alright, time to create and implement our custom Structural Directive. Here''s
    the use case we will build using our custom Structural Directive:'
  prefs: []
  type: TYPE_NORMAL
- en: We will use our Structural Directive to loop through a list of products.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The directive should display elements only which have `isAvailable` set to `true`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First let''s define our products JSON in the `app.component.ts` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We just created a JSON list of products with the keys `productName` and `isAvailable`.
  prefs: []
  type: TYPE_NORMAL
- en: Nothing super-heroic, not just yet!
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s time to use the `*ngFor` loop and display the list of products in `app.component.html`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Let's quickly analyze the preceding code
  prefs: []
  type: TYPE_NORMAL
- en: We are using a built-in Structural Directive, `*ngFor`, for looping through
    the product list and displaying the name using the key `product.productName`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We are defining our custom Structural Directive, `appCustomStructural`, and
    passing the `product` object for analysis.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since we are passing the entire product object to our attribute, we can now
    define our custom logic in `appCustomStructural` and do transformations based
    on our application needs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Time for some super-heroic work in our directive `custom-structural.directive.ts`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s analyze in detail the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: We are importing the required modules `Directive`, `Input`, `TemplateRef`, `ViewContainerRef`,
    and `AfterViewInit` from `@angular/core`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We are defining the CSS `selector` for our custom Structural Directive, `appCustomStructural`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By using the `@Input` decorator, we are explicitly telling Angular that our
    custom directive will get input through `appCustomStructural`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the constructor, we are injecting the instances of `TemplateRef<any>` and
    `ViewContainerRef`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using `TemplateRef<any>`, we are mentioning that it's an embedded template that
    can be used to instantiate embedded views.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since Structural Directives involve the shaping or reshaping of the DOM structure
    in the page, we are injecting `ViewContainerRef`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We are checking if the value of `product.isAvailable` is equal to `true`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the value of `product.isAvailable` is true using the instance of `ViewContainerRef`--a
    container where one or more views can be attached, by using the method `createEmbeddedView`--we
    are appending the element to the view.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the application and we should see the output as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/00f90d26-7cc6-4a29-a867-5628af7de144.png)'
  prefs: []
  type: TYPE_IMG
- en: We see only Shoes and Belts being displayed since only those products have the
    `isAvailable` key set to true. Try changing the values of other products too and
    see the output display.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have learned about the custom Structural Directive. We learned
    about important utilities provided by Angular--`createEmbeddedView`, `ViewContainerRef`,
    and `TemplateRef`.
  prefs: []
  type: TYPE_NORMAL
- en: A quick summary of things we have learned and implemented so far for our custom
    directives follows.
  prefs: []
  type: TYPE_NORMAL
- en: We have created a custom Attribute Directive, `highlightDirective`. We learned
    to pass values to the custom Attribute Directive using the `highlightColor` variable.
    We have learned to attach events such as `mouseover` and `mouseout` to our custom
    attribute `highlightDirective`.
  prefs: []
  type: TYPE_NORMAL
- en: We have learned to create a custom Structural Directive `appCustomStructural`.
    We have learned to use `createEmbeddedView`, `ViewContainerRef`, and `TemplateRef`.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will learn about change detection, an important aspect
    of how Angular framework works internally, and also learn to use it for our applications
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing change detection in Angular
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Change detection is the process of detecting any internal state changes in a
    model or component class and then reflect them back to the view, mainly by manipulating
    DOM.
  prefs: []
  type: TYPE_NORMAL
- en: Change detection is one of the most important changes from Angular 1.x to 2.
  prefs: []
  type: TYPE_NORMAL
- en: 'The application state changes happen either from model to view or vice versa.
    To understand better, take a look at the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/5976ebb9-6ba5-40b2-9d0e-5f09c1b09a8b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Application state changes can happen in two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: From Model to View Template (DOM)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From View (DOM) to Model (Component Class)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we know that state changes happen either in a model or in DOM, let's
    analyze what triggers change detection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change detection is triggered by the following:'
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript events (`click`, `mouseover`, `keyup`, and so on)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setTimeout()` and `setInterval()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Asynchronous requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that all the preceding three listed ways are async processes. So it's safe
    to say that in Angular, change detection happens whenever we have async methods/requests
    in place.
  prefs: []
  type: TYPE_NORMAL
- en: Before we jump into understanding more on change detection--how it works, how
    it's handled, and so on--let's quickly create an example to understand what triggers
    change detection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code snippet can be explained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We created a button with a click event calling the `toggleUser` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the click event on `toggleUser`, the variable `isLoggedIn` value is set either
    to `true` or `false`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Based on the variable, the value of `isLoggedIn` in the view is updated. If
    the value is `true`, Hello Packt Author is displayed, and if the value is false,
    `Hello Guest user` is displayed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the next section, we will learn about how Angular handles change detection
    internally and the utilities provided by Angular to help us implement better change
    detection.
  prefs: []
  type: TYPE_NORMAL
- en: Change detection - Angular and ZoneJS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The official site of ZoneJS describes the library as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A Zone is an execution context that persists across async tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Angular uses ZoneJS for detecting changes and then calls the listener methods
    of those events.
  prefs: []
  type: TYPE_NORMAL
- en: Angular takes advantage of zones to handle all the internal state changes and
    change detection. Zones understand the context of the asynchronous actions and
    state changes.
  prefs: []
  type: TYPE_NORMAL
- en: Angular has a built-in `ngZone`, which tracks all the completed asynchronous
    actions and notifies them with a `onTurnDone` event. Every component gets a change
    detector, which keeps track of all the bindings attached to the component in a
    tree structure.
  prefs: []
  type: TYPE_NORMAL
- en: We don't have `$scope.apply` or `$digest` like in the previous version of Angular.
  prefs: []
  type: TYPE_NORMAL
- en: By default, Angular change detection will always check whether the values have
    changed. Change detection is always performed the same from the top root component
    to the inner components in a tree structure.
  prefs: []
  type: TYPE_NORMAL
- en: This is done for all components through change detector objects.
  prefs: []
  type: TYPE_NORMAL
- en: Using `ngZones`, the performance of the Angular applications has increased drastically.
  prefs: []
  type: TYPE_NORMAL
- en: Change detection strategy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By default, Angular defines a change detection strategy for every component
    in our application--which means every time there is any change in our template,
    it traverses down to the last component in a tree structure check for any changes
    and makes the necessary updates.
  prefs: []
  type: TYPE_NORMAL
- en: This takes a performance hit!
  prefs: []
  type: TYPE_NORMAL
- en: Hence, Angular provides us with options to define explicitly which change detection
    strategy we want to implement for our components.
  prefs: []
  type: TYPE_NORMAL
- en: Angular provides a `ChangeDetectionStrategy` module by which we can define the
    change detection strategy we want to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two different values `ChangeDetectionStrategy` takes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Default`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OnPush`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's analyze each of these options in detail to understand how each of these
    work.
  prefs: []
  type: TYPE_NORMAL
- en: ChangeDetectionStrategy - Default
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is the default mechanism that Angular implements--changes are triggered
    by events and the propagation of changes goes from the view template to the model.
    Based on the logic implemented, the DOM structure is updated.
  prefs: []
  type: TYPE_NORMAL
- en: An important thing to note here is that using this strategy, every time Angular
    will traverse through all the components starting from the root component to the
    last component for checking if the properties have to be updated throughout.
  prefs: []
  type: TYPE_NORMAL
- en: Refer the example we created in preceding section, *Implementing change detection
    in Angular*. We are updating the properties and Angular by default uses the `ChangeDetectionStrategy`
    with the `Default` value.
  prefs: []
  type: TYPE_NORMAL
- en: ChangeDetectionStrategy - OnPush
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We use `OnPush` to improve the performance of our Angular applications. We have
    to explicitly mention that we want to use the `OnPush` value for `ChangeDetectionStrategy`.
  prefs: []
  type: TYPE_NORMAL
- en: Changes are triggered by events and the propagation of changes goes for the
    entire object that is rendered in the `view` template and not for each property.
  prefs: []
  type: TYPE_NORMAL
- en: When we use the `OnPush` value, we are forcing Angular to depend only on the
    inputs. We pass the objects through the `@Input` decorator and only the complete
    object and it's properties will be affected and not any individual property changed.
  prefs: []
  type: TYPE_NORMAL
- en: Advantages of ChangeDetectionStrategy - OnPush
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In previous section you have learned about ChangeDetectionStrategy using both
    `default` and `OnPush` options.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the advantages of using `OnPush` option over `default` are given:'
  prefs: []
  type: TYPE_NORMAL
- en: It helps in increasing the performance of our Angular applications.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Angular doesn't have to traverse the entire component tree structure for detecting
    individual changes on properties.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Angular internally can skip the nested tree structures when inputted properties
    don't change.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To understand it better, let's create a use case. For that first we need to
    create a new component named `change-detect` using Angular CLI `ng` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the component is created, you should see the output as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/f0155047-2a5f-472b-8666-670957f012c5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s create a `class` user and with properties `userName` and `userId` in
    the `user.ts` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s edit the `Component` class we generated and add the following lines
    of code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s analyze the preceding code in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: We are importing the required modules from `Input`, `Component`, and `ChangeDetectionStrategy`
    from the `@angular/core` library.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We are importing the newly created `User` class into the component class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We are explicitly mentioning the value for `changeDetection` as `ChangeDetectionStrategy.OnPush`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We are using the CSS `selector`; `app-change-detect` where we will display the
    output of the component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since we are telling Angular to use the `OnPush` option, we need to use `@Input`
    and pass object that is in our case `User`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As per the template part, we are binding the user properties, `userName` and
    `userId`, in the `view` template.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Great. So far we have created our component and have explicitly mentioned that
    whenever a change is detected, the entire object that is the `user` object should
    be updated and not just an individual property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now it''s time to create methods to test our logic. So an in the `AppComponent`
    class, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: For our component, we have mentioned the `selector` to be used as `app-change-detect`.
    We need to use the component inside the template `app.component.html` file.
  prefs: []
  type: TYPE_NORMAL
- en: We have also mentioned that the component takes the input as `user`; hence we
    are passing the user object to the component.
  prefs: []
  type: TYPE_NORMAL
- en: Add the following lines of code to the `app.component.html` template file with
    the component `app-change-detect`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Alright, we are all set. Run the app and you should see the output as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/e9cc998d-b059-4abc-bfd5-bdeda22aca63.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The application functionality can be summarized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The `app-change-detect` component is loaded into `AppComponent` template.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The default values passed for the object are displayed in the `view` template.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on the `Change Detection: OnPush` button and we see the updated user
    loaded in the view.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When we click on `Change Detection: Default`, unlike the previous examples
    we have created, we don''t see any changes happening to the properties. It''s
    because we have explicitly mentioned that any change detection should be passed
    through objects and not properties using the `OnPush` option of `ChangeDetectionStrategy`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this section, we have learned about change detection strategies provided
    by Angular. We have explored how we can improve the performance of our applications
    by using the `OnPush` option by forcing Angular to only check for objects passed
    as inputs and not individual properties.
  prefs: []
  type: TYPE_NORMAL
- en: Updating properties will tell Angular to traverse through the entire application
    component tree structure and it takes a hit on performance.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about directives and also about different types
    of directives, namely Component Directives, Structural Directives, and Attribute
    Directives.
  prefs: []
  type: TYPE_NORMAL
- en: We implemented custom user-defined directives to understand how we can extend
    directives and use them more effectively.
  prefs: []
  type: TYPE_NORMAL
- en: We learned briefly about ZoneJS, and how zones can help us to handle the `async`
    tasks in modern applications frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we learned how Angular handles changes detection and how we can use
    change detection methods to improve the overall application performance.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about asynchronous programming using Observables.
    In this chapter, we will learn how to take advantage of asynchronous programming
    with Angular by using Observable and Promises.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, we will learn how to built a basic, yet extensible asynchronous
    JSON API for querying the Marvel Cinematic Universe.
  prefs: []
  type: TYPE_NORMAL
